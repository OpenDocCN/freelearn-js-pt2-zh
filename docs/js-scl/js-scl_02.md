# 第二章：规模影响者

规模影响的发起者从我们软件的用户开始。他们是影响力度最大的发起者，因为他们是我们构建应用的原因。正如我们在前一章所看到的，用户影响最终影响我们编写的代码和实施它的开发人员。当我们停下来思考这些规模影响者时，我们认识到能够应对它们的健壮的 JavaScript 架构是一个审慎的原因。然后我们可以把我们找到的信息从不同的架构角度审视我们的代码。我们将在本书中深入探讨这些观点，从下一章开始。

但在我们这样做之前，让我们更深入地了解这些规模影响者。我们希望密切关注这些，因为关于我们的设计，我们做出的每一个决定实际上如何扩展在很大程度上取决于我们预见的影響。也许更重要的是，我们需要以这样的方式设计我们的架构，以便它能够让我们处理我们没有预见的扩展场景。

我们将从更仔细地观察我们软件的用户开始。他们为什么使用它？我们的软件是如何让他们快乐的？对我们有什么好处？这些问题，信不信由你，与我们编写 JavaScript 的方式密切相关。从用户出发，我们然后再深入到功能，我们应用的外向个性。有些功能不适合我们的应用，但有时候那并不重要——我们说了不算。如果我们想要扩大规模，取悦我们的用户，有时我们必须充分利用这些功能。

负责实施这些功能的发展资源是一个可以成就或破坏产品的规模影响者。我们将查看开发团队面临的挑战，以及他们如何受到功能影响。我们将在本章结束时为每个这些影响者提供一个通用的检查表；以帮助确保我们已经考虑了我们能够扩展的最紧迫的问题。

# 扩大用户规模

最重要的用户是我们——开发组织。虽然我们的任务是通过提供可扩展的软件来保持我们的用户快乐，但我们也需要让自己快乐。而这需要一个可行的商业模式。我们关心这个原因是因为不同的模型意味着获取新用户和管理现有用户的不同方法。从那里开始，扩大我们的用户基础的复杂性会更深。我们需要考虑我们的用户是如何组织的，他们如何使用我们的软件相互沟通，如何提供支持，收集反馈和收集用户指标。

对于 JavaScript 应用程序可行的业务模式包括提供广告支持的免费服务，到我们收取许可费的私有、本地软件部署。决定哪种方法适合组织可能不在我们手中。然而，我们的责任是理解选定的业务模式，并将其与当前和未来使用我们软件的用户联系起来。

业务模式可能会变得相当复杂。例如，组织通常会从一种清晰明了、能让用户满意，同时满足商业期望的方法开始。然而，随着组织的成长和成熟，曾经连贯的业务模式变得模糊不清，对于我们的架构产生了不可预测的结果。让我们来看看这些业务模式以及它们如何影响我们用户基础的可扩展性。

## 许可费用

软件许可是一个复杂的话题，在这里我们不会深入探讨。重要的是我们是否依赖许可软件作为我们的业务模式。如果是，那么我们很可能有其他组织在本地部署我们的 JavaScript 应用程序。个人购买许可证的可能性不大——这取决于软件的性质。销售许可证的情况下，我们的软件更有可能被多个组织私有化部署。

这种业务模式有两个有趣的扩展属性需要考虑。首先，对于给定组织内的用户数量存在一个基本限制。虽然组织可以很大，我们可以向多个大型组织销售产品，但常见的案例是拥有较少用户，并采用授权模型。其次，每个组织在定制方面都有不同的需求。这包括配置性、用户组织等。采用授权模型时，我们更有可能遇到这些类型的更改或增强请求。

所以，虽然支持的用户不多，但由于使用我们软件的组织的结构性质，支持他们的性质更加复杂，因此难以扩展。在这些环境中，依赖管理也可能具有挑战性，因为限制决定了我们的软件如何能够扩展。在其他环境中，这些限制较为宽松。

## 订阅费用

订阅服务是我们为使用我们的软件而收取的定期费用。这种方法通常对我们的用户来说成本更低。此外，这种业务模式也更加灵活，因为它可以轻松地应用于本地部署的软件，以及公开部署的软件。

由于组织部署基于订阅的软件比基于许可的软件成本更低，我们更有可能接触到更多的组织。请注意，这些组织是按部门划分的，每个部门都有自己的预算限制。

然而，在扩展方面，订阅模式的挑战与许可模式的挑战相似，即复杂的定制化请求。如果订阅可能会让我们获得更多的企业内部部署，可能会带来更复杂的功能请求。采用订阅方式所面临的另一个扩展问题就是客户保留。如果不能持续提供价值，用户是不会继续支付订阅费用的。

所以，如果我们选择订阅模式，我们需要加大力度提供新功能，这些功能可以证明用户的持续订阅费用是合理的。

## 消费费用

软件的另一种商业模式是消费模式，或者说，按需付费。这对用户来说是一个有吸引力的模式，因为他们为他们不使用的资源付费。当然，这并不适合每一个应用程序。如果用户没有有意义的东西可以消耗呢？如果我们在运行应用程序的方式上，资源消耗对我们来说不是问题呢？

在其他情况下，资源使用情况是显而易见的。也许用户执行了一些计算密集型的任务，或者在一段时间内存储了大量数据。在这些情况下，消耗模型对我们和用户来说都是完全合理的。消耗较少的用户，支付较少费用。用户行为可能会有波动，但与他们在使用我们应用程序的其他时间相比，这些事件是短暂的。

我们这个业务模型所面临的扩展挑战是我们除了应用的核心方面外，还需要好的工具。首先，我们需要一个测量和记录消耗的工具。其次，我们需要准确描绘这些消耗指标的工具，通常是以视觉化的方式。根据用户在消耗什么，以及我们期望达到什么程度的集成，可能还需要考虑第三方组件。

## 广告支持

另一个选择是将我们的应用部署到公共互联网上，并使用显示广告来赚钱。这些是免费的应用程序，因此更有可能被使用。另一方面，广告会让很多人感到厌烦，这抵消了“免费”的吸引力。

使用这种方法的目标，或许不是广告收入，而是产生大规模使用。实际上，用户越多，广告收入也会越多。然而，一个在线 JavaScript 应用程序的大规模采用可能会吸引投资者。所以，用户账户的数量本身就有价值。

这类应用程序与其他业务模型不同的地方在于它们的扩展方式。在互联网上获得广泛流行的应用程序为不同的用户角色解决不同的问题。遵循这一模式意味着我们需要有覆盖面，而扩大覆盖面意味着降低入门门槛。在使用这种业务模型时，我们的重点是易用性和社会有效性。

## 开源

我们需要考虑的最后一种商业模式是开源。别笑；开源软件对网络的功能至关重要。我们的 JavaScript 应用程序很可能使用了一些开源组件，更有可能的是，我们只使用了开源组件。但为什么人们会花宝贵的时间开发供所有人使用，甚至包括他们的竞争对手的工具呢？

这里的一个误解是，人们只是闲坐着，失业，为其他人构建开源软件。事实是，我们大多数将使用的工具都是由使用与我们相同技术的大型公司的有强大地位的人构建的。他们甚至可能启动开源项目来为公司解决问题——为他们的开发过程提供一个缺失的工具。

第二个误解是我们通过启动或贡献开源项目在帮助我们的竞争对手。我们不可能仅通过开源软件就让自己处于比竞争对手更糟的位置。通过其他标准，是的，通过伤害自己来帮助我们的竞争对手是完全可能的。

另一方面，开源项目可能对一个组织是有益的。这些项目必须是有效的；即有用且通用的。如果它发展壮大，我们就在创造我们依赖的新技术利益相关者，这是件好事。围绕开源项目的社区是无价的。虽然开源本身不能支持一个组织，但不可否认的是，它是任何 JavaScript 应用程序商业模式的一个重要组成部分。

分组与角色分组使我们能够对我们的用户进行分类。想想角色是一种用户类型。这是一个强大的抽象概念，因为它允许我们通过角色类型泛化特征的方面。例如，我们不是基于用户属性检查条件，而是基于角色属性检查条件。将用户从一个角色移动到另一个角色比修改我们的逻辑容易得多。

确定用户角色以及它们如何转化为小组实施是一个棘手的问题。我们可以确定的是，我们必须调整我们用户的组织结构。因此，使分组机制尽可能通用是我们的第一个目标。这也有一定的权衡——任何完全通用的东西都会有负面的性能影响。

有些分组决策一开始是显而易见的。比如用户是否意识到系统中还有其他用户。如果他们意识到了，我们可以开始深入探讨用户如何使用我们的应用程序相互沟通的具体问题。再次，这可能基于我们应用程序的功能类型是显而易见的。我们正在遵循的业务模式也影响我们的用户管理设计。如果我们出售软件许可证，并且很可能被部署在本地，那么我们可以预期会有很多不同的用户角色需求，以及随后的分组实现。如果我们公开部署在互联网上，分组就不是那么重要了——我们可以选择一种简单的性能方法，例如。

随着我们软件的复杂性增加，随着我们增加更多功能和吸引更多客户，我们将开始看到需要将应用程序的某些部分隔离开来的需求。也就是说，我们需要根据访问控制权限将某些功能绑定下来。与其设立不同的用户角色，安装不同的软件系统；不如让他们拥有一个带有用户、组和访问控制的单一系统更容易。

这对我们作为 JavaScript 架构师有深远影响，因为一旦我们走上了访问控制的道路，就无法回头。从那时起，我们必须保持一致性——每个功能都需要检查适当的权限。进一步 complicating 事情的是，如果我们这样分组用户，我们可能在某个时候以类似的方式对我们的系统中的其他实体进行分组。这是很合理的，特别是对最终用户来说——这一组事物是由那一组用户访问和使用的。

## Communicating users

关于用户以及他们之间的关系的另一个方面是，这些用户可用的沟通渠道。他们是否明确地选择其他用户进行沟通？还是沟通更隐性？后者的一个例子可能是我们同一个组的用户，正在查看一个图表。这个图表是基于系统中由小组其他成员输入的数据生成的。除了明确的沟通渠道外，思考这些隐性的沟通渠道是否值得？

我们应用程序的性质决定了用户可以打开哪些沟通渠道。它可能还取决于用户本身。有些应用程序的用户需要深入其中，熟练地完成一项任务——与 other users 沟通是不必要的。另一方面，我们可能会发现自己正在开发一些更加注重社交的应用程序。事实上，我们甚至可能依赖外部社交网络的服务。

如果我们打算依赖第三方用户管理，无论是社交网络还是其他方式，我们必须注意我们与这些服务耦合的紧密程度。在规模上，使用第三方认证机制可能具有我们想要的社会性增值功能——特别是考虑到大多数用户会喜欢他们不需要再创建另一个账户就能使用我们的应用程序。一旦我们开始实现新功能，第三方集成变得复杂，此时将这种用户管理方法扩展到其他方面将成为一个问题。例如，一个照片编辑应用程序可能会通过使用 Facebook 登录来扩展得更好，因为大多数用户的照片都来源于此。

如果我们的应用程序有用或有趣，用户会找到彼此沟通的方式。我们可以抵制它，或者我们可以利用用户沟通作为帮助我们扩展的工具。也就是说，扩展用户可以透明地指向对他们有用的东西的能力，否则他们需要去到处寻找。

## 支持机制

能够使我们的 JavaScript 应用程序顺利运行是非常好的。即使一切都在按计划进行，我们已经部署完毕且没有 bug，我们仍需要支持那些用户不知道如何使用某功能的情况。或者他们执行了一些他们可能不应该执行的操作。或者有其他十万里挑一的用户体验问题需要迅速解决。

我们的支持机制不扩展会让我们的事业陷入停滞。因此，除了我们的软件需要扩展得很好外，我们还需要考虑用户支持系统如何与之一同扩展。支持可以紧密集成，或者外包给第三方软件和人员。

用户最好不需要支持就能使用我们的软件。这就是为什么我们在设计时考虑易用性。我们走过各种用户体验，通常是与专家和/或实际用户一起，并将为他们整合设计到我们的软件中。这是我们支持用户时可以解决的最明显的问题。因为如果我们能通过易用性设计做到这一点，那么我们就可以消除我们扩展过程中可能遇到的大部分潜在支持问题。

无论如何，我们仍然必须假设我们没有考虑到部署后必然会出现的支持案例。用户是好奇的。即使一切都在顺利进行，他们可能仍然会有问题。因此，我们实在不能说：“我们为您设计了一个优秀的用户体验，一切都在运行，所以您走吧。”我们需要对用户的疑问和担忧做出回应。因为一旦我们对询问表现出轻视，我们就未能扩大我们的应用程序。

我们的 JavaScript 组件可以帮助支持用户吗？如果我们希望这样，绝对可以！实际上，上下文帮助可能是最有效的。如果用户对某个组件有疑问，并且他们看到在该问题组件中的帮助按钮，那么他们可以利用它来提交他们的问题。在支持问题的接收端，混淆更少。我们确切地知道用户想要做什么，而花时间创建问题周围的上下文不再必要。

这确实说起来容易做起来难，对我们还有其他的扩展影响。这些上下文帮助系统并非不劳而获。如果我们决定走那条路，我们必须考虑在实施每个功能时都提供上下文帮助。这个方法能与我们在做的其他事情一起扩展吗？

我们可能想要考虑的另一种方法是一个知识库，其中包含来自创建软件的组织以及使用它的那些人的信息。为特定目的使用它的人很可能比我们更有答案，这些答案极具价值。不仅对寻找答案的用户有价值，对我们也是如此。

## 反馈机制

是否真的需要将反馈与支持区分开来？支持无疑是反馈。如果我们关注随着时间的推移遇到的各种支持问题，我们可以将其转化为反馈，并利用这些信息作为反馈。然而，区分这两种形式仍然是有价值的，因为用户的心态是不同的。在体验支持问题时，从轻微到强烈的挫折感都有。现在的用户并不关心改进产品——他们需要完成自己的工作。

另一方面，使用我们软件一段时间的用户会高度意识到他们工作流程的低效。收集这类反馈至关重要。我们如何获得它？一种方法是在应用程序中提供一个反馈按钮，就像我们为上下文支持按钮所做的。另一种方法是让第三方处理反馈收集。对于理解用户在谈论什么，自动化上下文总是对我们更有利，这样我们就不用花太多时间在上面。

与反馈相关的一个重要方面是保持客户的参与度。并非所有使用我们软件的人都会与我们分享他们的想法。但无疑有些人会的——即使他们只是在发泄不满。我们必须回应这些反馈，以建立对话。提供这类反馈的用户希望我们回应他们。而这些用户的持续对话是产品改进的来源，而不是用户最初提交的那些辉煌想法。

随着我们的用户基础增长，我们能否保持响应并积极地响应用户反馈？显然，这是一个挑战，鉴于我们桌上还有其他一切事情，处理应用程序的增长。创建围绕给定用户数据的对话是一回事，但采取行动又是另一回事。假设我们已经为我们的软件集成了伟大的反馈机制。我们最终必须将其转化为可执行的工作。因此，我们需要考虑我们的基于用户反馈生成需求的过程如何扩展。如果它不能，并且用户反馈从未被执行，他们将会放弃，我们就未能实现扩展。

## 通知用户

JavaScript 应用程序需要向其用户显示通知。这些实现起来可能相当直接，尤其是如果我们主要关心响应用户行为的话。例如，当用户做某事时，它会导致向后端发送 API 请求。我们想要向用户显示一个通知，指示该操作是否成功或失败。这些通知在应用程序中看起来都一样——我们可以为大多数甚至所有通知使用相同的工具。

在设计可扩展的 JavaScript 架构时，通知很容易被忘记。这是一个大话题——有上下文通知、一般通知以及用户离线时发生的通知。后者通常意味着已经向用户发送了电子邮件，提示他们登录并采取必要的行动。

上下文通知可能是最重要的，因为它们向用户提供了关于他们当前正在做的事情的反馈。确保这些通知在用户界面上保持一致，对于所有类型的实体来说是一个挑战。更一般的通知是作为后台发生某事的结果而发生的。

属于用户的某些资源可能已经改变了状态，要么是预期之中，要么是出乎意料。无论如何，用户可能希望知道这些事件。理想情况下，如果他们登录并使用系统，那么一个通用的通知会自动显示。然而，我们可能还希望将这些通知通过电子邮件发送给用户。

任何通知系统的挑战都是数量问题。如果有很多用户，而且他们相对活跃，将需要生成和传递大量的通知。这无疑会干扰我们代码中其他组件的性能。我们还面临着通知带来的可配置性问题。我们永远不可能为所有用户正确设置通知，因此我们需要一定的通知调整程度。找到使应用程序可扩展的正确通知级别取决于我们 JavaScript 架构师和开发者。

## 用户指标

了解用户如何与我们的软件互动的最佳方式是通过数据。有些数据点是无法猜测或手动收集的。这就是我们需要依赖能够自动收集用户指标的工具的地方，这些工具在用户与我们的软件互动时发挥作用。有了原始数据，我们就能够很好地进行分析，并做出决策。

虽然自动化这个任务是有意义的，但这个任务可能根本就不必要。如果我们真的不确定一个特定功能的未来方向，或者当我们想要更深入地了解应该优先处理什么工作时，收集用户指标可能是有价值的。大多数时候，我们可以不费吹灰之力地得到这些答案，当然也不需要分析工具。如果我们部署在本地，我们可能甚至不被允许收集这样的数据。

市面上有很多好的第三方指标收集工具。这些工具特别有帮助，因为它们附带了我们需要的很多报告。还有我们不需要的很多报告。还有一个问题是我们希望第三方组件多么紧密地集成。总是有可能我们需要关闭这样的功能。或者，至少改变数据存储的位置。

这些数据除了作为产品方向决策的输入之外，还有许多其他用途。我们的代码可以利用用户指标数据反思性地改善体验。这可能仅仅是基于过去事件提出下一步建议。或者，我们可以根据这些数据进行效率优化。这一切都取决于我们的用户想要什么。确定用户想要什么是一个本身具有扩展性的问题，因为随着我们的成长，我们会吸引更多想要不同东西的用户。用户指标可能最终成为解决这个问题的有力工具。

## scaling users example（规模用户示例）

我们的软件公司正在开发一个在线贷款应用。这个应用相当直接；前端没有太多的移动部件。申请人首先创建一个账户，然后可以申请新贷款并管理现有贷款。这个应用的商业模型是基于消费的。我们通过贷款的利息来赚取收入，所以贷款消费得越多，我们赚的钱就越多。

显然，影响规模扩展的因素包括用户数量和易用性。我们价值主张的一部分是小型贷款的低利率。当用户申请新贷款时，应该几乎没有 overhead；所需输入最少，贷款申请成功或失败的等待时间也最少。这是我们提供价值的高度聚焦的愿景，也是我们将面临的一些更明显的规模扩展影响因素。

让我们思考一下我们应用在规模方面的更微妙的含义。鉴于这类应用的性质，我们不太可能看到对社交功能的请求。在大多数情况下，用户可以被视为一个黑箱；当使用我们的应用时，他们处于自己的小宇宙中。由于易用性对我们来说非常重要，而且我们的应用没有太多复杂的部分，因此在规模方面，支持和反馈不太可能是关键因素。我们无法消除支持和反馈，但在这些方面的关注可以最小化。

另一方面，我们需要推广我们的服务，我们真的不知道我们的客户为什么要贷款，最受欢迎的还款计划是什么，等等。为此，我们可能能够提供更有效的市场信息，以及改善我们的整体用户体验。这里的含义是，收集我们应用的元数据是一件大事。由于我们追求大量用户，这意味着我们将需要存储大量的元数据。我们还需要以这样的方式设计每个功能，以便我们可以收集指标并稍后使用，这使得设计变得复杂。

# 扩展功能

现在我们将关注如何扩展我们软件中实施的功能。用户是最终的决策者，现在我们已经有了关于在规模方面需要什么的大致想法，我们可以将这些知识应用于功能开发。当我们考虑扩展用户时，我们是在思考为什么。我们为什么选择这个商业模式而不是那个商业模式？为什么我们需要为其中一个用户角色启用事物，而为其他角色禁用它们？一旦我们开始用 JavaScript 设计和实现功能，我们开始思考如何。我们不仅关心正确性，也关心扩展性。与用户一样，影响者是决定可扩展功能的关键。

## 应用价值

我们认为我们在实施的功能方面做得很好，并且每次我们引入新功能时，我们都在为用户提供价值。值得我们思考这一点，因为本质上，这就是我们试图做的事情——将我们软件的价值扩展到更广泛的受众。在这方面没有扩展的一个例子是，当现有用户依赖现有功能而被忽视，并对我们软件因为我们关注了新的领域而感到失望。

当我们忘记了我们最初为软件解决的问题时，这种情况就会出现。这听起来可能是个荒谬的观念，但根据许多因素，我们很容易走向完全不同的方向。在某些罕见的情况下，这种改变方向导致了世界上一些最成功的软件。在更常见的情况下，它导致软件失败，确实是一个扩展问题。我们的软件应始终提供一组核心价值主张——这是我们软件的精髓，绝不能动摇。我们经常面临其他扩展影响因素，如新客户希望从我们的软件提供的核心价值中得到不同的事物。无法处理这意味着我们无法扩展应用程序的主要价值主张。

当我们扩大价值时走向错误方向的一个指标是与当前价值和理想价值混淆。也就是说，我们的软件目前所做与将来我们可能希望它做的事情之间的区别。我们必须向前看，这是毫无疑问的。但是，未来计划需要不断与可能实现的事情进行理智的检查。这通常意味着回溯我们最初创建软件的原因。

如果我们的应用程序真的很吸引人，我们希望它是这样，那么我们必须对抗其他有影响力的扩张因素，以保持这种方式。也许这意味着我们评估新功能的过程的一部分涉及确保该功能以某种方式贡献于我们软件的核心价值主张功能。并非所有考虑中的功能都能做到这一点，这些功能应受到最严格的审查。改变方向真的值得吗，会危及我们扩展能力吗？

## 杀手级功能与功能致死

我们希望我们的应用程序能够脱颖而出。如果有一个足够细分的市场，我们几乎没有任何竞争，那会很不错。那样我们就可以轻松实现稳定且无需花哨功能的软件，大家都会很满意。鉴于这并非现实，我们必须进行区分——实现杀手级功能就是其中之一，这是我们的软件独有的方面，也是用户非常关心的。

挑战在于，杀手级功能很少是计划好的。相反，它是我们在交付应用程序时其他事情做得好的副作用。随着我们不断成熟应用程序，精炼和调整功能，我们会偶然发现那个演变成杀手级功能的“小”变化。杀手级功能往往就是这样产生的，这并不令人惊讶。通过倾听客户的需求和满足扩展要求，我们能够发展我们的功能。我们增加新功能，减少一些功能，修改现有功能。如果我们成功地这样做足够长的时间，杀手级功能就会显现出来。

有时在规划某个功能时很清楚地意识到它试图成为一个杀手级功能，仅仅是为了成为一个杀手级功能。这不是最优的。这对用户也没有价值。他们选择我们的软件不是因为我们产品路线图中“有很多杀手级功能”。他们选择我们是因为我们能为他们做到他们需要的事情。可能比其他替代方案更有效率。当我们开始思考为了杀手级功能而思考时，我们开始偏离应用程序的核心价值观。

这个问题最好的解决方案是一个开放的环境，它欢迎在功能构思阶段所有团队成员的输入。我们越早能够杀死一个糟糕的想法，我们就越能节省时间，不用在它上面工作。不幸的是，情况并不总是这么清晰，我们必须在功能上做一些开发，才能发现其中一个或多个方面扩展得不好。这可能是由于任何 number of reasons，但这不是完全的损失。如果我们仍然愿意在开发已经开始后取消一个功能，那么我们可以学到一个宝贵的教训。

当事情无法扩展并且我们决定终止功能时，这对我们的软件来说是一种帮助。我们没有通过向其强制推行不适用的事物来妥协我们的架构。在开发任何功能的过程中，我们将达到一个需要问自己的点；“我们是否重视这个功能胜过我们现有的架构，如果是这样，我们愿意改变架构来适应它吗？”大多数时候，我们的架构比功能更有价值。因此，停止开发不适应的功能可以作为一个宝贵的教训。在未来，我们将根据这个被取消的功能更好地了解哪些功能可以扩展，哪些不能。

## 数据驱动的功能

拥有具有大量不同用户基础的应用程序是一回事。另一回事是我们能够通过收集数据来利用他们与我们的软件互动的方式。用户指标是收集与软件决策和未来发展方向相关的信息的强大工具。我们将这些称为数据驱动的功能。

在最初阶段，当我们没有用户或者很少有用户时，我们显然无法收集用户指标。我们将不得不依赖其他信息，比如我们团队的集体智慧。我们都可能在过去参与过 JavaScript 项目，因此我们有足够的信息来让产品起飞。一旦产品上线，我们需要工具来更好地支持我们的功能决策。特别是，我们需要了解哪些功能是我们需要的，哪些是不需要的？随着我们软件的成熟，我们收集到更多的用户指标，我们可以进一步完善我们的功能，以满足用户的实际需求。

拥有使特性数据驱动所需的必要数据是一个难以扩展的挑战，因为我们首先需要收集和精炼数据的机制。这需要我们可能根本不存在的开发努力。此外，我们实际上必须根据这些数据做出关于特性的决定——数据本身不会自己变成我们的需求。

我们还想知道我们被要求实现的特性的可行性。如果没有数据支持我们的假设，这项任务是非常困难的。例如，我们对我们的应用程序将要运行的环境有数据吗？简单的数据点可能足以确定某个特性不值得实现。

数据驱动特性需要从两个角度进行工作，那就是我们自动收集的数据和我们提供数据。这两者都难以扩展，但两者对于扩展都是必要的。唯一的真正解决方案是确保我们实现的特性数量足够少，这样我们就可以处理某个特性生成的数据量。

## 与其他产品竞争

除非我们在一个非常利基的市场中运营，否则很可能存在竞争产品。即使我们在某种程度上处于利基市场，与其他应用程序仍然会有一些重叠。有很多软件开发公司——所以我们很可能面临直接竞争。我们通过创建更优越的特性与类似的产品竞争。这意味着我们不仅要不断提供顶级软件，还要注意竞争对手在做什么，以及他们的软件用户怎么想。这是限制我们扩展能力的一个因素，因为我们必须花时间了解这些竞争技术是如何工作的。

如果我们有一个销售团队在销售我们的产品，他们往往是关于竞争对手在做什么的好信息来源。他们经常会被告知潜在客户我们的软件是否能做到这样那样，因为其他应用程序能做到。或许最有说服力的销售点是我们能够提供那个特性，而且我们能做得更好。

我们必须小心这里，因为这又是限制我们赢得客户能力的另一个扩展因素。我们必须扩展我们对现有和潜在客户的承诺。承诺过多，我们将无法实现特性，导致用户失望。承诺过少，或者根本不承诺，我们一开始就无法赢得客户。克服这种扩展限制的最佳方式是确保那些销售我们产品的人与我们的软件现实保持良好联系。它能做到什么，不能做到什么，哪些是未来的可能性，哪些是不切实际的选项。

为了销售我们的产品，必须在承诺一些事情而不了解实现这些承诺的全部影响上留有回旋余地。否则，我们将无法获得我们想要的目标客户，因为我们没有围绕我们的产品产生任何兴奋感。如果我们要将这种销售方法扩展到新的客户，我们需要一种经过验证的方法，将承诺提炼成可实现的东西。一方面，我们不能妥协架构。另一方面，我们需要在中间找到某种平衡，以满足用户的需求。

## 修改现有功能

在我们成功部署了我们的 JavaScript 应用程序之后，我们仍然在不断优化我们的代码和整体架构的设计。唯一不变的是变化，或者类似的东西。需要大量的纪律性回到软件的现有功能上进行修改，以改善用户的体验。原因是我们有更多的压力来自利益相关者要求添加新功能。这对我们的应用程序来说是一个长期的可扩展性问题，因为我们不能永远添加新功能，而从不改进已经存在的内容。

不太可能的情况是，我们不需要更改任何东西；我们所有的现有用户都很满意，他们不想让我们碰任何东西。一些用户害怕变化，这意味着他们喜欢我们软件的某些方面，因为我们在实施方面做得很好。显然，我们想要更多这样好的功能，通过这种方式，用户通常很满意，并且看不到改进的需要。

那么我们如何达到这个阶段呢？我们必须倾听用户的反馈，并根据这些反馈制定修改功能的路线图。为了与我们的用户及其需求一起扩展，我们必须在实施新功能和修改现有功能之间找到平衡。检查我们是否在正确的方向上改进功能的一种方法是将拟议的更改广播给我们的用户基础。然后我们可以衡量我们收到的任何反馈。实际上，这可能会促使我们那些通常安静的用户给出一些具体的建议。这是一种将球抛给用户的方法——“这是我们正在考虑的，你们觉得呢？”

在确定要改进哪些功能以及何时相对于实施新功能来改进它们之后，还存在架构风险。我们的代码耦合度有多紧密？我们能将一个功能隔离到什么程度，以至于我们不会破坏其他功能？我们永远不可能完全消除这种风险——我们只能减少耦合。在这里起作用的规模问题是我们花在修改给定功能上的时间，由于重构、修复回归等等原因？当我们的组件松耦合时，我们会花更少的时间在这些活动上，因此，我们可以扩展我们的功能改进。从管理的角度来看，我们总是有因为我们的更改而阻碍组织中其他人的风险。

## 支持用户组和角色

根据我们遵循的商业模式和我们的用户基础大小，用户管理对我们来说成为一个扩展问题，因为它触及我们实施的每一个功能。这种问题进一步复杂化，因为用户管理很可能与功能需求一样频繁地更改。随着我们的应用程序的增长，我们可能会处理角色、组和访问控制。

用户管理复杂时会有很多副作用。我们刚刚实施的新功能可能最初运行得非常好，但在我们的生产客户可能面临的大量其他场景中失败。这意味着我们需要花更多的时间来测试功能，并且质量保证团队可能已经不堪重负。更不用说由于每个功能中用户管理的复杂性而产生的额外的安全和隐私问题。

我们实际上并不能做太多关于复杂的用户管理架构的事情，因为它们往往是使用应用程序的组织及其结构的症状。我们在本地部署时更有可能面临这类复杂性。

## 引入新服务

有时候，现有的后端服务不再足以支持新功能。当前端开发工作的依赖性非常小的时候，我们可以更好地扩展我们的前端开发工作。如果这听起来违反直觉，不用担心。确实，我们需要后端服务来执行用户的请求。因此，依赖关系总是存在的。我们想要避免的是不必要的更改 API。

如果能够使用现有 API 实现功能，我们就这样做。这样后端团队可以专注于通过修复漏洞来提高稳定性和性能。如果 API 必须不断更改以支持我们的功能，他们就无法做到这一点。

有时不可避免地需要添加新的后端服务。为了扩展我们的开发过程，我们需要知道何时需要新的服务，以及如何实施它们。

首先是要评估新服务的必要性。有时候这很简单——无法实现所需的 API。我们将不得不将就使用现有的东西。第二个问题是新服务的可行性。由于我们需要新的 API，我们很可能形成新 API 的形状。然后我们需要听听后端团队的意见。如果我们是一个拥有全栈开发人员的团队，开销会比较小，因为我们很可能都在同一个团队中，并且彼此之间的沟通更为密切。

既然我们已经决定推进新的 API，我们必须同步前端和后端特性的实现。这里没有我们可以遵循的一刀切的解决方案，因为服务可能容易或难以实现。我们的特性可能需要几个新的服务。关键是在 API 上达成一致，并建立一个模拟机制。一旦真正的服务可用，禁用模拟就是时间问题。

然而，在扩展我们整个应用程序方面，这只是前端功能与后端服务之间的一个集成点。引入新特性对系统的影响是未知的。我们只能通过测试和先验知识猜测这么多。直到生产环境，我们才会看到我们新特性扩展效果的全面影响。使用完全相同服务的不同特性对请求负载、错误率等有不同的影响。

## 消费实时数据

在 JavaScript 应用程序中，为了保持用户会话与现实同步，通常会有面向后端数据的有状态连接。这简化了我们代码的某些方面，同时使其他方面变得复杂。扩展的影响是巨大的。通过 WebSocket 连接发送实时数据，这被称为“推送数据”。在 WebSocket 连接之前，主流的技术是长轮询 HTTP 请求。这意味着，数据不是在改变时交付给客户端，而是客户端负责检查数据是否已更改。

围绕实时数据的扩展问题今天仍然存在。有了 WebSocket 技术，一些负担已经从我们的前端代码转移到了后端。应用程序服务需要在相关消息发生时推送 WebSocket 消息。然而，我们需要从多个角度来考虑这个问题。例如，我们的整体架构是否依赖于实时数据的交付，还是我们只考虑将实时数据用于单一功能？

如果我们考虑首次引入 WebSocket 连接，以更好地支持一个新功能，我们必须问自己是否这是我们要融入我们未来架构中的东西。实时数据只影响一个或两个功能时的挑战在于缺乏清晰性。开发者看到一个实时数据输入的功能与另一个没有实时数据输入的功能相比，在开发我们软件的过程中解决一致性问题会更加困难。

通常来说，将实时数据适当地集成到前端架构的代码中，在多个方面都有更好的扩展性。这基本上意味着任何给定组件都应该能够像其他任何组件一样访问实时数据。然而，当我们自上而下地流动，从用户及其组织那里面临的可扩展性问题，最终决定了我们实施的功能类型。这反过来又影响了实时数据发布的速度。根据我们应用程序的结构以及用户数据是如何连接的，实时数据每次浏览器会话交付的频率可能会大幅波动。对于我们所实施的每一个功能，都必须考虑这些问题。

## 缩放功能示例

我们的视频会议软件在大组织中很受欢迎。这主要归功于它的稳定性、性能，以及它基于浏览器，无需插件。我们的一个客户请求我们实现聊天工具。他们非常喜欢我们的软件，以至于他们希望用它来进行所有的实时通信，而不仅仅是视频会议。

在 JavaScript 层面实现聊天工具并不会太难。我们最终会重用一些使我们的网页视频会议功能成为可能的组件。稍微重构一下，我们就能得到所需的聊天组件。但文本聊天和视频聊天之间在缩放上有一些微妙的区别。

关键的区别在于文本聊天与视频聊天的持续时间，后者通常是一时的。这意味着我们需要找出持久化聊天的方法。我们的视频聊天不需要用户账户加入，以防人们想邀请组织外的人。这与文本聊天不同，因为我们不能确切地邀请匿名参与者，然后在他们离开后取消聊天。我们很可能还需要在我们的用户管理组件中进行其他更改。例如，聊天组现在是否对应于视频组？

由于这只是其中一个客户提出了这个要求，我们可能希望有一种方法来关闭它。这个新功能不仅有可能削弱我们的核心价值——视频会议，还可能在对其他客户部署时造成问题。有了新的后端服务、增加的界面复杂性以及所需的其他培训和支持，可以理解并非所有组织都希望启用这个功能。所以，如果我们还没有在我们的架构中实现这一点，即组件的开关功能，那么这也是影响我们扩展能力的一个因素。

# 缩放开发

在扩展影响因素方面，我们需要克服的最后障碍实际上是软件开发本身。任何足够复杂的 JavaScript 应用程序都不可能由一个开发者独立编写。即使是在开源环境中，也涉及到一个团队，即使它只是非正式的和自我组织的。在其他机构中，团队及其角色定义更为具体。不管团队是如何组建的，扩大团队的规模是我们如何应对本章中讨论的其他扩展影响因素的直接结果。

我们将要解决的首要问题是我们在新兴软件项目中最早遇到的问题——寻找开发资源。团队不是一个静态的事物；随着软件在代码大小和解决方案范围上的增长，我们将不得不添加新资源。不管我们喜欢与否，最好的资源最有可能是那些离开的资源，因为它们最受欢迎。理想情况下，我们可以留住一支有才华的团队，但无论如何，我们将不得不扩大获取新资源的过程。我们如何以及何时招聘 JavaScript 程序员受到我们要实现的功能和我们要构建的架构的影响，以服务于这些功能的运行。

从日常角度来看，每个团队成员应该负责实现我们应用程序的特定部分。这是一个复杂的问题，扩展影响因素应该受到责备。我们必须小心地为团队定义角色；不要使它们过于 restrictive。当事情因影响因素而变化时，我们需要调整并交付。僵化的角色定义在这里对我们帮助不大。另一方面，我们需要至少尝试建立界限，如果我们的组件开发中有任何自主性的话。

最后，我们将尝试找出是否有健全的方法来确定我们可能拥有过多的开发资源。大声说出来几乎听起来像是一件坏事。我们拥有所有这些才华，还有这么多工作要做——这两件事似乎是相辅相成的，不是吗？不，并不总是这样。

## 寻找开发资源

诱惑确实很大，尤其是对于产品经理来说，倾向于招聘开发资源不是为了我们现在正在做的工作，而是为了我们计划在将来进行的工作。但是，出于许多原因，这种方法扩展性不佳。新员工在这种情境下首先可能面临的问题是在实际功能上无法通过工作来学习代码。要记住，他们是被招聘来完成我们尚未开始的路标上的某项工作。所以，他们最终试图有所帮助，但现在还没有真正的义务。几周后，他们要努力避免挡住那些试图完成工作的人的路。

通常更好的做法是考虑我们现在正在做的工作。下一次软件发布中预期会有哪些功能是我们目前能力中缺失的清晰缺口吗？如果没有明确定义的缺口，新程序员就无事可做，这将导致不必要的沟通开销。这种做法的缺点是，一旦我们明确了在开发所需功能方面的能力缺口，我们可能就找不到所需的资源。这种压力可能导致招聘错误的人，这些人可能因为各种原因与团队格格不入。

一种更好的扩展我们开发资源增长的方法是等待缺口出现。缺口并不意味着世界末日，你的公司要倒闭。它只是意味着我们开发方面可以做得更好。如果我们能避免的话，我们不应该一次尝试招聘超过一个开发者。如果我们花时间找到合适的资源，那么他们很可能会用我们的流程和其他方法填补我们识别出的任何缺口。

### 小贴士

在软件开发生命周期中关于沟通开销的经典资源是弗雷德·布鲁克斯的《人月神话》。

## 开发职责

网络浏览器平台是一个复杂的领域，有许多技术和许多活动部分。网络平台的某些组件比其他组件更具前瞻性，但对于我们理解来说仍然很重要。这些新兴技术是网络的未来。那么在我们团队中谁来负责学习这些新技术并在整个组织中推广呢？网络平台的挑战在于，要掌握比一个人在同时交付产品功能时合理管理的内容还要多。这就是为什么我们需要至少有一定级别的开发角色。

这些角色的边界严格程度取决于组织和其中的文化。正在开发的应用程序的性质可能会影响要设置的开发角色类型。没有固定的食谱，严格性应该在可能的情况下避免。原因是我们需要适应扩展性影响者带来的变化。严格的角色实际上阻碍了其他有能力的开发者扑灭火灾。当截止日期临近时，我们通常没有时间角色的边界争议。

前端架构师最有可能看到实施给定应用程序架构的合理角色。这些角色很可能是短暂的，由建筑师指导，但由成员本身有机形成。这在开源项目中尤为明显，人们做他们擅长的事情，因此也做他们喜欢做的事情。虽然我们不能总是完全采用这种模式，但我们确实可以从中获得启示——根据我们的功能需求，塑造人们擅长做的事情的角色。这样做将帮助开发者在需要指导的地方获得指导。对 JavaScript 开发的某些方面感兴趣，并不意味着他们在需要的水平上精通。资深人员指导他们，做他们喜欢做的事情，对产品长期的收益巨大。

## 资源过多

我们部分解决了这样一个观念：轻易招聘过多开发资源——甚至颇具诱惑。当产品管理为我们定义了一个清晰的路线图时，我们想要安心地知道我们确实拥有足够的开发资源来完成我们的路线图。过快招聘人员不可避免地导致开发资源过多。我们现在可能已经面临这种情况，那么接下来要考虑的就是如何应对。

如果我们对我们的团队成员不满意，并且很清楚我们有比所需更多的资源，答案是显而易见的。然而，如果我们有太多优秀的资源不想失去，还有另一种看待事物的方法。我们需要调整产品路线图，以适应我们招聘的开发人才。这通常意味着找到一个渠道，使我们能够将产品想法从开发传递给产品管理。这更是一门艺术，而不是一门科学。

担任前端架构师是一项具有挑战性的工作，需要确定谁将构建什么。扩展我们的开发资源的最佳方式是向当前正在实施它的人提供一个我们架构的准确地图。如果有差异，找出正确的前进路径。例如，可能存在缺口，我们需要更多的 JavaScript 程序员，或者可能资源过多，产品中需要有所调整。

## 扩展开发示例

我们的应用程序已经存在一段时间，取得了一些成功，并在各种环境中得到部署。我们的一个核心开发人员 Ryan，触及了代码的许多领域。他帮助许多其他开发者改进他们的代码，提供建议等。我们的应用程序已经达到了一个足够大的规模，以至于我们开始注意到所有功能上的性能下降。

我们需要 Ryan 来实现一些性能优化，这将涉及重构代码的某些部分，基本上会占用他所有的时间。如果我们打算扩大规模以满足客户需求，我们仍然还有功能要交付。另一方面，我们看到了在性能方面扩展能力的红旗。

我们意识到我们需要招聘一名新开发者来帮助开发新功能。这名开发者不需要像 Ryan 那样的技能。他们需要掌握我们所使用技术的基础知识。如果我们运气好，我们会找到一个可以承担更多责任的人。但目前，我们需要填补的由 Ryan 留下的空缺相当狭窄。而且，为了扩大规模，我们不需要立即找到另一个 Ryan。

# 影响者清单

我们将用几个清单来结束这一章。这些问题很简单，没有唯一正确的答案。有些答案将贯穿我们软件的整个生命周期。例如，我们的商业模式希望“不会经常改变”。其他答案取决于当前的情况，这就是这些清单的目的。我们可以随时回来再次查看，无论何时发生变化。这可能是需求、用户、新的部署或开发环境的变化。这些问题不过是影响可扩展 JavaScript 应用程序的因素的微妙提醒。如果阅读它们导致的问题比答案多，那么它们就发挥了作用。

## 用户清单

用户是我们最初构建软件的原因。这个清单涵盖了我们需要扩展应用程序的最基本方面。这些问题将在软件的整个生命周期中相关。不仅仅是在用户管理方面有问题的时候。特征开发的变化应该触发对这份清单的查看。

### 我们软件的商业模式是什么？

+   它是*基于许可*的吗？

+   它是*基于订阅*的吗？

+   它是*基于消费*的吗？

+   它是*基于广告*的吗？

+   它是*开源*的吗？

### 我们的应用程序有不同的用户角色吗？

+   一个角色是否有特征对另一个角色隐藏，而对其他角色可见？

+   我们应用程序中的每个功能都必须是*角色意识*的吗？

+   角色是如何定义和管理的？

+   我们的商业模式如何影响应用程序中角色的使用？

### 我们的用户是否使用我们的软件相互沟通？

+   用户是否相互合作以有效使用我们的应用程序？

+   用户沟通是否是我们数据模型的副作用？

+   我们应用程序中的用户角色如何影响用户沟通？

### 我们如何支持我们的应用程序？

+   支持是内置在应用程序中，还是外部处理的？

+   用户能否通过一个中央知识库互相支持？

+   我们商业模式和应用程序用户角色如何影响我们需要提供的支持类型？

### 我们如何从用户那里收集反馈？

+   反馈收集是内置在应用程序中，还是外部处理的？

+   我们如何激励用户提供反馈？

+   我们提供的支持类型如何影响我们想要收集的反馈类型？

### 我们如何向用户通知相关信息？

+   我们的应用程序是否有通用的、与上下文无关的通知机制？

+   我们如何确保在任意给定时间只发生相关的通知？

+   用户可以审计他们的通知吗？

### 我们应该收集哪种类型的用户指标？

+   我们是否使用指标来改善产品的未来版本？

+   我们的特性是否可以在运行时使用指标来改善用户体验？

+   商业模式如何影响我们收集指标的需求？

## 特性清单

遵循来自我们软件用户的规模影响者，我们的软件特性是什么。这个列表涵盖了我们应该问自己关于任何新特性或实现现有特性的变化的问题。它们将帮助我们在每个特性基础上解决与可扩展性相关的常见问题。

### 我们软件的核心价值主张是什么？

+   我们正在实施或增强的特性是否有助于我们产品整体的价值主张？

+   我们当前的价值主张是否过于宽泛？

+   用户数量和他们的角色如何影响我们专注于与应用程序价值相关的特性的能力？

### 我们如何确定一个特性的可行性？

+   我们是否试图实现杀手级特性，而不是让它们自然地出现？

+   我们是否花时间确定一个提议的特性是否可行，而不是做得差劲？

+   我们软件的价值主张以及用户的特性请求如何影响我们最终实现的特性可行性？

### 我们能否对特性做出明智的决策？

+   我们是否有任何用户指标数据，我们可以基于此做出决策？

+   过去我们实施过的类似特性有任何历史数据吗？

+   我们的商业模式如何影响我们可以收集和用于应用程序特性决策的数据？

### 我们的竞争对手是谁？

+   我们是否提供了与竞品类似，但做得更好的东西？

+   我们是否处于利基市场？

+   我们可以从竞品中学习到什么？

+   我们的商业模式如何影响我们面临的竞争程度以及我们需要实现的特性类型？

### 我们如何让现有的东西变得更好？

+   考虑到我们添加特性的速度，我们是否有足够的时间来维护现有的特性？

+   从架构上讲，修改一个特性而不破坏其他特性是否安全？

+   用户如何影响我们对现有特性的改进？

+   我们的商业模式如何影响我们部署产品增强的能力？

### 我们如何将用户管理整合到特性中？

+   访问控制机制是否已经通用到不再特性发展为日常担忧的程度？

+   我们能否将特性组织成小组？

+   用户能否开启或关闭特性？

+   我们正在构建的应用程序类型，以及我们的用户和他们的角色，如何影响我们特性的复杂性？

### 我们的特性是否与后端服务紧密耦合？

+   现有的服务是否足够通用，能够处理我们正在实施的新特性？

+   我们能够在浏览器中完全模拟后端服务吗？

+   我们的特性如何影响后端服务的设计和功能？

### 前端如何与后端数据保持同步？

+   我们能否利用 WebSocket 连接来实现推送通知？

+   高用户活动是否会导致更多消息被发送给其他用户？

+   实时数据消费如何影响我们特性的复杂性？

## 开发者清单

在我们软件开发过程中，我们需要回顾的最终清单是关于开发资源的。这个清单不会像用户或者特性清单那样经常使用。尽管如此，确保我们在开发资源方面解决出现的问题是很重要的。

### 我们如何找到合适的发展资源？

+   我们能否用目前现有的开发资源应付过去？

+   我们需要重新审视正在开发的特性，以适应我们所拥有的资源吗？

+   我们是否有为正在构建的产品配备*正确的*开发资源？

### 我们如何分配开发责任？

+   责任区域之间应该有多少重叠？

+   我们当前的责任区域是否反映了我们在构建什么？

+   团队成员的各种技能如何影响他们的职责？

### 我们能否避免雇佣过多的资源？

+   我们是否过早地雇佣了人员？

+   由于资源过多，我们是否经历了沟通上的开销？

+   同时开发多个特性是否会影响这样一种观念：更多的开发者意味着能完成更多的工作？

# 总结

当涉及到在 JavaScript 应用程序中扩展影响者时，有三个主要关注领域。每个领域都直接影响其下方的领域，直到我们最终到达底层，即开发发生的地方。

首先，也是最重要的是，我们软件的用户。有许多与用户相关的因素会影响我们软件的扩展需求。例如，我们组织选择的企业模型会在不知不觉中影响我们后来关于架构的决策。基于许可证的部署可能会在某处进行本地部署，因此更有可能需要进行定制。复杂性的组合无穷无尽，它们都源于我们软件的用户。

我们接下来主要关注的是功能本身。我们必须把我们从思考我们的用户以及他们对扩展性的影响中获得的大部分洞察力，作为输入提供给我们的功能设计。例如，一旦人们开始使用我们的软件，很短的时间内可能会发生很多事情。这会如何分散我们应用程序的核心价值呢？信不信由你，专注也是需要扩展的。

最后，还有开发活动。需要建设团队，而且找到合适的人并不容易。即使我们有了一个由优秀开发者组成的团队，也需要考虑到责任以及它们是如何受到功能和使用它们的人的影响。同样地，随着我们应用程序的开发进展，我们还需要确保正确的资源得到配置。

既然我们已经在前端奠定了扩展性的基础，现在就准备深入具体内容吧。本书的剩余部分将把前两章的概念放入 JavaScript 的语境中。我们知道什么是影响扩展性的因素，现在我们开始做出架构上的取舍。这是有趣的部分，因为我们可以开始写代码了。
