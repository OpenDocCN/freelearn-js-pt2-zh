# 第一章. Promises.js

在今天的世界里，计算机编程语言正在变得更加先进，使用技术的方法也在发生变化。这是由于技术随着商业和他们需求的变化而不断涌现。电子商务的广泛扩展导致大学、研究人员和工业界投资于生成最新技术和工具，从而导致了许多新计算机语言的产生。

然而，JavaScript 并非如此。它相对较新。现代编程景观至少三次使用并抛弃了它，现在它被广泛接受为开发现代、可扩展和实时网络应用的工具。

在 90 年代中期，点 com 时代诞生了，正是在这个时候，公司想要主导一个名为网络空间的新市场。尽管这是一个虚拟的地方，没有实体存在，但争夺主导地位的战争达到了顶峰。Netscape 通信公司想要自己的轻量级解释语言，以补充 Java，并吸引非专业程序员。这项任务交给了布兰登·艾 ich，他开发了名为"Mocha"的 JavaScript 的第一版。正式地，当 1995 年 9 月在 Netscape 的浏览器中以 2.0 测试版首次发布时，它被称为 LiveScript。

然而，当版本 2.0 B3 推出时，名称改为了 JavaScript。自 1995 年以来，JavaScript 经历了许多起伏。它的被采用、被拒绝和再次被采用的故事。在其推出后不久，JavaScript 在整个行业中获得了非常流行的响应。每个主要公司都为其增长做出了贡献，并对其进行微调以满足自己的需求。

# JavaScript 的衰落与崛起

网景浏览器见证了 90 年代末至 2000 年初 JavaScript 的衰落。网页开发的面孔正在成熟，但很少有人还对投资 JavaScript 感兴趣。

是 Mozilla 基金会发布了第一个开源浏览器 Firefox，自 2002 年初至 2003 年初以来，该基础是前 Netscape 浏览器的继承者。他们在自己的产品中再次使用了 JavaScript。2004 年，谷歌推出了**异步 JavaScript 和 XML** (**AJAX**)。这导致了许多技术的基础，并通过最小化服务器调用，使黑白的前端和服务器之间的通信变得容易。

# 谷歌对 JavaScript 的贡献

谷歌在 JavaScript 的演变、发展和应用方面的贡献超过了任何其他组织。正是谷歌在其旗舰浏览器 Chrome 中引入了 V8 引擎。V8 是浏览器的核心引擎，由于 smart usage of JavaScript，浏览器更快、更健壮，并适应于网页和安卓设备。

2009 年，基于与 Chrome 相同的 V8 引擎的 Node.js 问世。这是 JavaScript 的服务器端，但比 90 年代末 Netscape 引入的要好得多和先进。Node.js 的全局理念是开发非阻塞的**输入/输出**（**I/O**），并且用几行代码，服务器可以在给定的时间段内服务于多达 20K 的客户端。

在 Node.js 之后，一个名为 MEAN 栈的开发栈被引入，它是由 MongoDB、Express.js、Angular.js 和 Node.js 的首字母缩写而成；其中 MongoDB 是文档型的，NoSQL 是基于 JavaScript 的数据库，Express.js 用于表示层，Angular.js 用于应用程序的前端开发，Node.js 作为运行整个节目的服务器。

# Promises.js 是做什么的？

那些了解服务器端脚本在 I/O 事件中如何执行的人知道，从驱动器读取或写入数据是阻塞性的，也就是说，在其执行期间，服务器端语言不能执行其他操作，即使是客户端。好吧，有了 Promises.js，这种情况就不再存在了。Promises.js 利用非阻塞策略进行 I/O 操作，所以使用你的网络应用程序的客户端可以自由地执行任何他们想执行的其他任务，而无需等待数据读/写操作完成。

# 承诺是什么？

当一个操作的完成返回一个最终的值时，它代表一个**承诺**。如果我们把承诺比作人类之间的约定，它将帮助我们理解计算机编程中特别是在 JavaScript 角度的承诺概念。每个承诺都是两个或更多方之间交付一些值给另一方的约定。这个值可以是具体的或无形的，但承诺必须有所回报。直到承诺得到满足，它才处于未满足的状态。然而，当所说的承诺已经完成，承诺就被认为是得到了满足。如果承诺没有如预期那样交付，那么这个承诺就被认为是失败的。

那么，什么是承诺？根据官方定义：

> 承诺是一个具有 then 方法的对象或函数，其行为符合此规范，代表异步操作的最终结果。

这个定义的来源是[`www.slideshare.net/wookieb/callbacks-promises-generators-asynchronous-javascript`](http://www.slideshare.net/wookieb/callbacks-promises-generators-asynchronous-javascript)的第 21 张幻灯片。

# 我们为什么需要在 JS 中使用承诺？

Promises.js 是一个 JavaScript 库，它承诺进行异步 I/O 操作，如文件读写。每当涉及到 I/O 的所有操作的回调方法，它们都必须是异步的。这个额外的回调参数使我们的输入和返回值是什么的想法变得混乱。它从不与控制流原语一起工作。它也不处理由回调方法抛出的错误。

因此，我们需要处理回调方法抛出的错误，但也要小心不要处理回调方法抛出的错误。到这一步，我们的代码将变成一个错误处理的混乱局面。

尽管处理错误代码如此混乱，我们仍然面临着一个额外回调参数悬而未决的问题。Promises 通过自然地处理错误，不使用回调参数来编写更干净的代码来帮助你。

# 软件先决条件

在开始第二章，*JavaScript 异步模型*之前，你必须掌握一组先决概念，这将使你更好地理解在哪里使用 Promises.js，以及它如何在你的近期或即将到来的项目中节省时间和精力。下一节将详细说明这些概念是什么，以及我们如何将它们作为我们理解承诺的基础。

本书的先决条件是你对过程编程有深入的了解，并且必须掌握基本的 JavaScript 知识。由于本书旨在深入理解概念（promise）及其在不同技术中的使用，因此你还需要对 HTML 有非常深入的了解，以及如何嵌入你的代码。

对基本编程的理解将帮助你一旦完成任何章节/部分后，就能在样例代码的帮助下开始实验。在这本书中，我试图使每一个部分都自解释，每一个代码示例都是一个独立的脚本/程序，尽最大可能地展示。然而，在需要的地方，我们添加了一段代码或算法，以更清晰地表达我们的观点。

## 开始之前你需要了解的环境

使用本书中的代码，你不需要任何额外的软件/集成开发环境（IDE）来开始。要尝试本书中提供的代码，你只需要使用免费的软件/IDE，如 Notepad++或任何其他首选的开源 GPL 或 GNU 产品。

另外，为了查看你的代码结果，你需要一个像谷歌的 Chrome 或 Mozilla 的 Firefox 这样的网络浏览器。对于与微软技术相关的一些示例，你需要 Internet Explorer 9 或更高版本。

# 未来（Future）、承诺（promise）和延迟（delay）

未来（Future）、承诺（promise）和延迟（delay）描述了一个作为代理来获取最初未知的值的代理对象，其值尚未计算完成。它们通常被称作某些并发编程语言中用于同步的构造。

丹尼尔·P·弗里德曼和戴维·怀斯在 1975 年提出了“承诺”这个术语。彼得·希巴德称其为“最终”。承诺这个术语是由利斯科夫和希拉提出的，尽管他们用“call-stream”这个名字来指代流水线机制。承诺这个术语指的是在任何所述操作完成时，将获得一个最终值。同样，值也可以被视为最终值，因为它只有在任何事件发生时才会产生。因此，这两个术语同时指的是同一个事实。

未来（Future）、承诺（Promise）和延迟（Delay）这些术语经常可以互换使用。实现这些术语有一些核心的区别。未来被认为是变量的只读占位符视图，而承诺是一个可写单分配容器，设置未来的值。

在许多情况下，未来承诺是一起创建的。简单来说，未来是一个值，承诺是一个函数，用来设置这个值。未来重新运行异步函数（承诺）的值；未来设置值也称为**解析**、**满足**或**绑定**。

## 承诺流水线

使用未来（Future）可以显著降低分布式系统中的延迟；例如，在编程语言 E 和 Joule 中，承诺（Promise）使得承诺流水线（Promise pipelining）成为可能，而在 Argus 语言中，这被称为**call-stream**。

这里需要注意的一点是，承诺流水线应该与支持并行消息传递但不支持流水线的系统的并行异步消息传递区分开来。它还应该与演员系统中的流水线消息处理区分开来，在演员系统中的流水线消息处理中，一个演员可以在完成当前消息的处理之前指定并开始执行下一个消息的行为。

## 只读视图

只读视图在解析时允许读取其值，但不允许您解析它，从而使获得只读视图的未来成为可能。

只支持只读视图与最小权限原则保持一致。

只读视图允许您将值设置为仅限于需要设置它的主体。异步消息（带有结果）的发件人收到结果的只读承诺，而消息的目标收到解决器。

# 承诺的状态

承诺基于三种状态。每种状态都有其重要性，可以根据需要驱动一定级别的结果。这可以帮助程序员根据需要进行选择。承诺的这三种状态如下：

+   **挂起**：这是承诺的初始状态。

+   **满足**：这代表一个成功操作的承诺状态。

+   **拒绝**：这代表一个失败操作的承诺状态。

一旦承诺被满足或拒绝，它就是不可变的（也就是说，它永远不能再改变）。

参照前面讨论的概念，现在很清楚承诺是什么以及如何使用它及其全部潜力。

# 我们如何在本书中保持 Promises.js 的适用性？

本书将涵盖 Promises.js 与每种实现承诺概念的主要技术的使用。这本书被仔细地分成章节，以介绍、讨论和解释在该特定技术中使用承诺的方法。每个章节都有其独立的代码示例，以便更好地理解 Promises.js 的最佳使用和其结果。

本书的例子将假设操作系统的选择完全由您自主决定。这可能因读者而异，取决于他的/她的许可证。

所有代码都清晰地打印出来，带有说明和注释，以便更好地理解。此外，本书还提供了一份电子副本，列出了按其相应章节/部分分类的每一行代码。

# 浏览器兼容性

Promises 支持扩展到许多现代浏览器，但并非全部。有关它支持的浏览器的手册参考，请参阅桌面和移动屏幕分辨率：

+   桌面兼容性：

    | 特性 | Chrome | Firefox | Internet Explorer | Opera | Safari |
    | --- | --- | --- | --- | --- | --- |
    | 基本支持 | 36 | 31 | 直到 IE 11 不支持。在 Edge 中添加 | 27 | 8 |

+   移动兼容性：

    | 特性 | 安卓 | Firefox 移动版（Gecko） | IE 移动版 | Opera 移动版 | Safari 移动版 | 安卓版 Chrome |
    | --- | --- | --- | --- | --- | --- | --- |
    | 基本支持 | 4.4.4 | 31 | Edge | 不支持 | 不支持 | 42 |

# 总结

在本章中，我们学习了 JavaScript 的起源以及它是如何发展成为现代应用开发中的领先技术的。我们讨论了为什么 90 年代初需要 JavaScript，以及这种语言在其存在期间是如何经历起伏的。

我们还将看到科技公司的投资如何有助于创建、开发和演变 JavaScript，使其成为动态和快速增长的网络、移动和实时应用市场的关键参与者。

承诺概念的适应将使 JavaScript 变得更强有力，并将帮助开发者和工程师以高效的方式编写更好的代码。

在下一章中，我们将了解异步模型以及它是如何与 JavaScript 更好地配合的。这将帮助我们理解如何采用并在各种语言中实现 Promises.js。
