- en: Chapter 2. Functions, Closures, and Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 函数、闭包和模块
- en: In the previous chapter, we deliberately did not discuss certain aspects of
    JavaScript. These are some of the features of the language that give JavaScript
    its power and elegance. If you are an intermediate- or advanced-level JavaScript
    programmer, you may be actively using objects and functions. In many cases, however,
    developers stumble at these fundamental levels and develop a half-baked or sometimes
    wrong understanding of the core JavaScript constructs. There is generally a very
    poor understanding of the concept of closures in JavaScript, due to which many
    programmers cannot use the functional aspects of JavaScript very well. In JavaScript,
    there is a strong interconnection between objects, functions, and closures. Understanding
    the strong relationship between these three concepts can vastly improve our JavaScript
    programming ability, giving us a strong foundation for any type of application
    development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们故意没有讨论JavaScript的某些方面。这些是赋予JavaScript其力量和优雅的一些语言特性。如果你是一个中级或高级的JavaScript程序员，你可能正在积极使用对象和函数。然而，在许多情况下，开发者在这些基本层面上绊倒，对JavaScript核心构造产生了半生不熟或有时错误的理解。由于对JavaScript中闭包概念的普遍理解不足，许多程序员无法很好地使用JavaScript的功能方面。在JavaScript中，对象、函数和闭包之间有很强的相互联系。理解这三个概念之间强烈的关系可以大大提高我们的JavaScript编程能力，为我们提供任何类型应用程序开发坚实的基础。
- en: Functions are fundamental to JavaScript. Understanding functions in JavaScript
    is the single most important weapon in your arsenal. The most important fact about
    functions is that in JavaScript, functions are first-class objects. They are treated
    like any other JavaScript object. Just like other JavaScript data types, they
    can be referenced by variables, declared with literals, and even passed as function
    parameters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是JavaScript的基础。理解JavaScript中的函数是你武器库中最重要的武器。关于函数最重要的事实是，在JavaScript中，函数是第一类对象。它们像任何其他JavaScript对象一样被对待。与其他JavaScript数据类型一样，它们可以被变量引用，通过字面量声明，甚至可以作为函数参数传递。
- en: 'As with any other object in JavaScript, functions have the following capabilities:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就像JavaScript中的任何其他对象一样，函数具有以下能力：
- en: They can be created via literals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以通过字面量创建
- en: They can be assigned to variables, array entries, and properties of other objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以分配给变量、数组元素和其他对象的属性
- en: They can be passed as arguments to functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以作为参数传递给函数
- en: They can be returned as values from functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以从函数中作为值返回
- en: They can possess properties that can be dynamically created and assigned
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以拥有动态创建和赋值的属性
- en: We will talk about each of these unique abilities of a JavaScript function in
    this chapter and the rest of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及本书的剩余部分，我们将讨论JavaScript函数的这些独特能力。
- en: A function literal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数字面量
- en: One of the most important concepts in JavaScript is that the functions are the
    primary unit of execution. Functions are the pieces where you will wrap all your
    code, hence they will give your programs a structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中最重要的概念之一是函数是执行的主要单位。函数是你会包裹所有代码的地方，因此它们会给你的程序带来结构。
- en: JavaScript functions are declared using a function literal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript函数是通过函数字面量声明的。
- en: 'Function literals are composed of the following four parts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量由以下四个部分组成：
- en: The function keyword.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数关键字。
- en: An optional name that, if specified, must be a valid JavaScript identifier.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的名称，如果指定，必须是一个有效的JavaScript标识符。
- en: A list of parameter names enclosed in parentheses. If there are no parameters
    to the function, you need to provide empty parentheses.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用括号括起来的参数名称列表。如果函数没有参数，你需要提供空括号。
- en: The body of the function as a series of JavaScript statements enclosed in braces.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数体，作为一系列用花括号括起来的JavaScript语句。
- en: A function declaration
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数声明
- en: 'The following is a very trivial example to demonstrate all the components of
    a function declaration:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个非常简单的例子，用于展示函数声明的所有组成部分：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The declaration begins with a `function` keyword followed by the function name.
    The function name is optional. If a function is not given a name, it is said to
    be anonymous. We will see how anonymous functions are used. The third part is
    the set of parameters of the function, wrapped in parentheses. Within the parentheses
    is a set of zero or more parameter names separated by commas. These names will
    be defined as variables in the function, and instead of being initialized to undefined,
    they will be initialized to the arguments supplied when the function is invoked.
    The fourth part is a set of statements wrapped in curly braces. These statements
    are the body of the function. They are executed when the function is invoked.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明以`function`关键词开头，后接函数名。函数名是可选的。如果一个函数没有指定名称，则称其为匿名函数。我们将看到匿名函数是如何使用的。第三部分是一组函数参数，被括号括起来。括号内是一组零个或多个由逗号分隔的参数名称。这些名称将在函数中被定义为变量，并且它们不会初始化为undefined，而是初始化为函数调用时提供的参数。第四部分是一组用大括号括起来的语句。这些语句是函数的主体。当函数被调用时，它们将被执行。
- en: This method of function declaration is also known as **function statement**.
    When you declare functions like this, the content of the function is compiled
    and an object with the same name as the function is created.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数声明方法也被称为**函数语句**。当你这样声明函数时，函数的内容将被编译，并且会创建一个与函数同名的对象。
- en: 'Another way of function declaration is via **function expressions**:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种函数声明方式是通过**函数表达式**：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we are creating an anonymous function and assigning it to an `add` variable;
    this variable is used to invoke the function as in the earlier example. One problem
    with this style of function declaration is that we cannot have recursive calls
    to this kind of function. Recursion is an elegant style of coding where the function
    calls itself. You can use named function expressions to solve this limitation.
    As an example, refer to the following function to compute the factorial of a given
    number, `n`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个匿名函数并将其赋值给一个`add`变量；这个变量像之前的例子一样用来调用函数。这种函数声明方式的一个问题是，我们无法进行这种函数的递归调用。递归是一种优雅的编程方式，函数调用自己。你可以使用命名的函数表达式来解决这个限制。作为一个例子，参考以下计算给定数字`n`的阶乘的函数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, instead of creating an anonymous function, you are creating a named function.
    Now, because the function has a name, it can call itself recursively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你没有创建一个匿名函数，而是创建了一个有名字的函数。现在，因为函数有一个名字，所以它可以递归地调用自己。
- en: 'Finally, you can create self-invoking function expressions (we will discuss
    them later):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以创建自调用函数表达式（我们稍后讨论它们）：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once defined, a function can be called in other JavaScript functions. After
    the function body is executed, the caller code (that executed the function) continues
    to execute. You can also pass a function as a parameter to another function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，一个函数可以在其他JavaScript函数中被调用。函数体执行完毕后，调用者代码（执行函数的代码）将继续执行。你还可以将一个函数作为参数传递给另一个函数：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we are calling the `demofunc()` function with two
    parameters. The first parameter is the string that we want to convert to uppercase
    and the second one is the function reference to the `changeCase()` function. In
    `demofunc()`, we call the `changeCase()` function via its reference passed to
    the `passfunction` argument. Here we are passing a function reference as an argument
    to another function. This powerful concept will be discussed in detail later in
    the book when we discuss callbacks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们用两个参数调用`demofunc()`函数。第一个参数是我们想要转换为大写的字符串，第二个参数是`changeCase()`函数的函数引用。在`demofunc()`中，我们通过传递给`passfunction`参数的引用调用`changeCase()`函数。在这里，我们通过将函数引用作为参数传递给另一个函数来传递一个函数引用。这个强大的概念将在书中讨论回调的部分详细讨论。
- en: 'A function may or may not return a value. In the previous examples, we saw
    that the `add` function returned a value to the calling code. Apart from returning
    a value at the end of the function, calling `return` explicitly allows you to
    conditionally return from a function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可能返回一个值，也可能不返回值。在前面的例子中，我们看到`add`函数向调用代码返回了一个值。除了在函数末尾返回一个值外，显式调用`return`还可以让你有条件地从函数中返回：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Functions as data
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为数据
- en: 'In JavaScript, functions can be assigned to variables, and variables are data.
    You will shortly see that this is a powerful concept. Let''s see the following
    example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数可以赋值给变量，而变量是数据。你很快就会看到这是一个强大的概念。让我们看以下示例：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, we assigned the familiar `console.log()` function
    to the say variable. Any function can be assigned to a variable as shown in the
    preceding example. Adding parentheses to the variable will invoke it. Moreover,
    you can pass functions in other functions as parameters. Study the following example
    carefully and type it in JS Bin:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将熟悉的`console.log()`函数赋值给say变量。任何函数都可以赋值给一个变量，正如前面例子所示。给变量添加括号将调用它。此外，你还可以将函数作为参数传递给其他函数。仔细研究下面的例子并在JS
    Bin中键入它：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we are passing functions as parameters to a `parseRequest()`
    function. We are passing different functions for two different calls, `generateDataForScientist`
    and `generateDataForComposers`, while the other two functions remain the same.
    You can observe that we defined a generic `parseRequest()`. It takes three functions
    as arguments, which are responsible for stitching together the specifics: the
    data, validator, and error handler. The `parseRequest()` function is fully extensible
    and customizable, and because it will be invoked by every request, there is a
    single, clean debugging point. I am sure that you have started to appreciate the
    incredible power that JavaScript functions provide.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在将函数作为参数传递给`parseRequest()`函数。我们为两个不同的调用传递了不同的函数，`generateDataForScientist`和`generateDataForComposers`，而其他两个函数保持不变。你可以观察到我们定义了一个通用的`parseRequest()`。它接受三个函数作为参数，这些函数负责拼接具体内容：数据、验证器、和错误处理程序。`parseRequest()`函数是完全可扩展和可定制的，并且因为它将被每个请求调用，所以有一个单一、干净的调试点。我敢肯定你已经开始欣赏JavaScript函数所提供的强大功能。
- en: Scoping
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: For beginners, JavaScript scoping is slightly confusing. These concepts may
    seem straightforward; however, they are not. Some important subtleties exist that
    must be understood in order to master the concept. So what is Scope? In JavaScript,
    scope refers to the current context of code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，JavaScript的作用域稍微有些令人困惑。这些概念可能看起来很简单；然而，并非如此。存在一些重要的细微差别，必须理解才能掌握这个概念。那么作用域是什么？在JavaScript中，作用域指的是代码的当前上下文。
- en: A variable's scope is the context in which the variable exists. The scope specifies
    from where you can access a variable and whether you have access to the variable
    in that context. Scopes can be globally or locally defined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域是变量存在的上下文。作用域指定你可以从哪里访问变量，以及在该上下文中你是否可以访问变量。作用域可以是全局定义的或局部定义的。
- en: Global scope
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局作用域
- en: Any variable that you declare is by default defined in global scope. This is
    one of the most annoying language design decisions taken in JavaScript. As a global
    variable is visible in all other scopes, a global variable can be modified by
    any scope. Global variables make it harder to run loosely coupled subprograms
    in the same program/module. If the subprograms happen to have global variables
    that share the same names, then they will interfere with each other and likely
    fail, usually in difficult-to-diagnose ways. This is sometimes known as namespace
    clash. We discussed global scope in the previous chapter but let's revisit it
    briefly to understand how best to avoid this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你声明的变量默认都在全局作用域中定义。这是JavaScript中采取的最令人烦恼的语言设计决策之一。由于全局变量在其他所有作用域中都是可见的，所以任何作用域都可以修改全局变量。全局变量使得在同一个程序/模块中运行松耦合的子程序变得更加困难。如果子程序碰巧有全局变量并且共享相同的名称，那么它们会相互干扰，并且很可能失败，通常以难以诊断的方式失败。这种情况有时被称为命名空间冲突。我们在前一章中讨论了全局作用域，但现在让我们简要地重新访问它，以了解如何最好地避免这种情况。
- en: 'You can create a global variable in two ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用两种方法创建全局变量：
- en: The first way is to place a var statement outside any function. Essentially,
    any variable declared outside a function is defined in the global scope.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是将var声明放在任何函数外部。本质上，任何在函数外部声明的变量都被定义在全局作用域中。
- en: 'The second way is to omit the var statement while declaring a variable (also
    called implied globals). I think this was designed as a convenience for new programmers
    but turned out to be a nightmare. Even within a function scope, if you omit the
    var statement while declaring a variable, it''s created by default in the global
    scope. This is nasty. You should always run your program against **ESLint** or
    **JSHint** to let them flag such violations. The following example shows how global
    scope behaves:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是在声明变量时省略var声明（也称为隐式全局变量）。我认为这是为了方便新程序员而设计的，但结果却成了一个噩梦。即使在函数作用域内，如果你在声明变量时省略了var声明，它默认也是在全局作用域中创建的。这很糟糕。你总是应该让你程序运行于**ESLint**或**JSHint**，让他们标记出这样的违规行为。下面的示例展示了全局作用域的行为：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we are declaring a variable outside the function and in the global scope.
    This variable is available in the `scopeTest()` function. If you assign a new
    value to a global scope variable within a function scope (local), the original
    value in the global scope is overwritten:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在函数外部声明了一个变量，并在全局作用域中。这个变量在`scopeTest()`函数中可用。如果你在函数作用域（局部）内给全局作用域变量赋新值，全局作用域中的原始值将被覆盖：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Local scope
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部作用域
- en: 'Unlike most programming languages, JavaScript does not have block-level scope
    (variables scoped to surrounding curly brackets); instead, JavaScript has function-level
    scope. Variables declared within a function are local variables and are only accessible
    within that function or by functions inside that function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言不同，JavaScript 没有块级作用域（作用域限定在周围的括号内）；相反，JavaScript 有函数级作用域。函数内部声明的变量是局部变量，只能在函数内部或该函数内部的函数中访问：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Function-level scope versus block-level scope
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作用域与块作用域
- en: 'JavaScript variables are scoped at the function level. You can think of this
    as a small bubble getting created that prevents the variable to be visible from
    outside this bubble. A function creates such a bubble for variables declared inside
    the function. You can visualize the bubbles as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 变量的作用域在函数级别。你可以将这看作是一个小气泡被创建出来，防止变量从这个气泡外部被看到。函数为在其内部声明的变量创建这样一个气泡。你可以这样想象气泡：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: JavaScript uses scope chains to establish the scope for a given function. There
    is typically one global scope, and each function defined has its own nested scope.
    Any function defined within another function has a local scope that is linked
    to the outer function. *It's always the position in the source that defines the
    scope*. When resolving a variable, JavaScript starts at the innermost scope and
    searches outwards. With this, let's look at various scoping rules in JavaScript.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用作用域链来为给定函数建立作用域。通常有一个全局作用域，每个定义的函数都有自己的嵌套作用域。在另一个函数内部定义的任何函数都有一个局部作用域，它与外部函数链接。*源代码中的位置始终定义作用域*。在解析变量时，JavaScript
    从最内层的作用域开始向外搜索。有了这个，让我们来看看 JavaScript 中的各种作用域规则。
- en: In the preceding crudely drawn visual, you can see that the `foo()` function
    is defined in the global scope. The `foo()` function has its local scope and access
    to the `g` variable because it's in the global scope. The `a`, `b`, and `c` variables
    are available in the local scope because they are defined within the function
    scope. The `bar()` function is also declared within the function scope and is
    available within the `foo()` function. However, once the function scope is over,
    the `bar()` function is not available. You cannot see or call the `bar()` function
    from outside the `foo()` function—a scope bubble.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的粗略绘图视觉中，你可以看到`foo()`函数定义在全局作用域中。`foo()`函数在其局部作用域内有访问`g`变量的权限，因为它在全局作用域中。`a`、`b`和`c`变量在局部作用域内可用，因为它们是在函数作用域内定义的。`bar()`函数也在函数作用域内声明，并在`foo()`函数内可用。然而，一旦函数作用域结束，`bar()`函数就不可用了。你不能从`foo()`函数外部看到或调用`bar()`函数——一个作用域气泡。
- en: Now that the `bar()` function also has its own function scope (bubble), what
    is available in here? The `bar()` function has access to the `foo()` function
    and all the variables created in the parent scope of the `foo()` function—`a`,
    `b`, and `c`. The `bar()` function also has access to the global scoped variable,
    `g`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`bar()`函数也有了自己的函数作用域（气泡），这里有什么可用？`bar()`函数可以访问`foo()`函数以及`foo()`函数的父作用域内创建的所有变量——`a`、`b`和`c`。`bar()`函数还可以访问全局作用域变量`g`。
- en: This is a powerful idea. Take a moment to think about it. We just discussed
    how rampant and uncontrolled global scope can get in JavaScript. How about we
    take an arbitrary piece of code and wrap it around with a function? We will be
    able to hide and create a scope bubble around this piece of code. Creating the
    correct scope using function wrapping will help us create correct code and prevent
    difficult-to-detect bugs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的想法。花点时间思考一下。我们刚刚讨论了 JavaScript 中全局作用域可以变得多么泛滥和不受控制。那我们为什么不定性地将一段任意代码包裹在一个函数中呢？我们可以将这个作用域气泡隐藏起来，并围绕这段代码创建一个作用域气泡。使用函数包装来创建正确的作用域将有助于我们编写正确的代码，并防止难以检测的错误。
- en: 'Another advantage of the function scope and hiding variables and functions
    within this scope is that you can avoid collisions between two identifiers. The
    following example shows such a bad case:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作用域和在此作用域内隐藏变量及函数的另一个优点是，你可以避免两个标识符之间的冲突。以下示例展示了这样一个糟糕的情况：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `bar()` function, we are inadvertently modifying the value of `i=2`.
    When we call `bar()` from within the `for` loop, the value of the `i` variable
    is set to `2` and we never come out of an infinite loop. This is a bad case of
    namespace collision.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bar()`函数中，我们不知不觉地修改了`i=2`的值。当我们从`for`循环内部调用`bar()`时，`i`变量的值被设置为`2`，我们陷入了无限循环。这是一个命名空间冲突的坏例子。
- en: 'So far, using functions as a scope sounds like a great way to achieve modularity
    and correctness in JavaScript. Well, though this technique works, it''s not really
    ideal. The first problem is that we must create a named function. If we keep creating
    such functions just to introduce the function scope, we pollute the global scope
    or parent scope. Additionally, we have to keep calling such functions. This introduces
    a lot of boilerplate, which makes the code unreadable over time:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用函数作为作用域听起来是实现JavaScript模块化和正确性的好方法。嗯，虽然这种技术有效，但实际上并不理想。第一个问题是我们必须创建一个命名函数。如果我们只是为了引入函数作用域而不断创建这样的函数，我们就会污染全局作用域或父作用域。此外，我们必须不断调用这些函数。这引入了大量样板代码，使代码随时间变得不可读：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We introduced the function scope by creating a new function `foo()` to the global
    scope and called this function later to execute the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在全局作用域中创建了一个新的函数`foo()`，并通过调用这个函数后来执行代码。
- en: 'In JavaScript, you can solve both these problems by creating functions that
    immediately get executed. Carefully study and type the following example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以通过创建立即执行的函数来解决这两个问题。仔细研究和输入以下示例：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the wrapping function statement starts with `function`. This means
    that instead of treating the function as a standard declaration, the function
    is treated as a function expression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，包装函数声明以`function`开头。这意味着，而不是将函数视为标准声明，而是将函数视为函数表达式。
- en: 'The `(function foo(){ })` statement as an expression means that the identifier
    `foo` is found only in the scope of the `foo()` function, not in the outer scope.
    Hiding the name `foo` in itself means that it does not pollute the enclosing scope
    unnecessarily. This is so useful and far better. We add `()` after the function
    expression to execute it immediately. So the complete pattern looks as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`(function foo(){ })`表达式作为语句意味着`foo`标识符只存在于`foo()`函数的作用域中，而不是在外部作用域。隐藏`foo`名称本身意味着它不会不必要的污染外部作用域。这是非常有用且更好。我们在函数表达式后添加`()`以立即执行它。所以完整的模式如下所示：'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This pattern is so common that it has a name: **IIFE**, which stands for **Immediately
    Invoked** **Function Expression**. Several programmers omit the function name
    when they use IIFE. As the primary use of IIFE is to introduce function-level
    scope, naming the function is not really required. We can write the earlier example
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式如此常见，以至于它有一个名字：**IIFE**，代表**立即调用** **函数表达式**。许多程序员在使用IIFE时省略函数名称。由于IIFE的主要用途是引入函数作用域，因此实际上并不需要命名函数。我们可以像下面这样写先前的例子：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here we are creating an anonymous function as IIFE. While this is identical
    to the earlier named IIFE, there are a few drawbacks of using anonymous IIFEs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个匿名函数作为立即执行的函数表达式（IIFE）。虽然这与先前的命名IIFE相同，但使用匿名IIFE有几个缺点：
- en: As you can't see the function name in the stack traces, debugging such code
    is very difficult
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在堆栈跟踪中看不到函数名称，因此调试此类代码非常困难。
- en: You cannot use recursion on anonymous functions (as we discussed earlier)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能对匿名函数使用递归（如我们之前讨论的）
- en: Overusing anonymous IIFEs sometimes results in unreadable code
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用匿名IIFE有时会导致代码不可读。
- en: 'Douglas Crockford and a few other experts recommend a slight variation of IIFE:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 迪奥格斯·克劳福德（Douglas Crockford）和其他一些专家推荐IIFE的一小部分变化：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both these IIFE forms are popular and you will see a lot of code using both
    these variations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种IIFE形式都很流行，你将看到大量使用这两种变体的代码。
- en: 'You can pass parameters to IIFEs. The following example shows you how to pass
    parameters to IIFEs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向IIFE传递参数。以下示例展示了如何向IIFE传递参数：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Inline function expressions
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联函数表达式
- en: 'There is another popular usage of inline function expressions where the functions
    are passed as parameters to other functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种匿名函数表达式的流行用法，即把函数作为参数传递给其他函数：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, you can name this inline function expression to make sure that you get
    a correct stack trace while you are debugging the code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以给这个内联函数表达式命名，以确保在调试代码时获得正确的堆栈跟踪。
- en: Block scopes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块级作用域
- en: 'As we discussed earlier, JavaScript does not have the concept of block scopes.
    Programmers familiar with other languages such as Java or C find this very uncomfortable.
    **ECMAScript 6** (**ES6**) introduces the **let** keyword to introduce traditional
    block scope. This is so incredibly convenient that if you are sure your environment
    is going to support ES6, you should always use the `let` keyword. See the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，JavaScript 没有块作用域的概念。熟悉其他语言（如 Java 或 C）的程序员会觉得这非常不舒服。**ECMAScript
    6**（**ES6**）引入了**let** 关键字来引入传统的块作用域。这非常方便，如果你确定你的环境将支持 ES6，你应该总是使用 `let` 关键字。以下代码所示：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, as things stand today, ES6 is not supported by default in most popular
    browsers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，截至目前，ES6 并不被大多数流行浏览器默认支持。
- en: This chapter so far should have given you a fair understanding of how scoping
    works in JavaScript. If you are still unclear, I would suggest that you stop here
    and revisit the earlier sections of this chapter. Research your doubts on the
    Internet or put your questions on Stack Overflow. In short, make sure that you
    have no doubts related to the scoping rules.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章应该已经向你充分解释了 JavaScript 中作用域是如何工作的。如果你仍然不清楚，我建议你停在这里，重新阅读本章的早期部分。上网查找你的疑惑，或者在
    Stack Overflow 上提出你的问题。总之，一定要确保你对作用域规则没有任何疑惑。
- en: It is very natural for us to think of code execution happening from top to bottom,
    line by line. This is how most of JavaScript code is executed but with some exceptions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很容易认为代码执行是自上而下，逐行进行的。这是大多数 JavaScript 代码执行的方式，但有一些例外。
- en: 'Consider the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you said this is an invalid code and will result in `undefined` when we call
    `console.log()`, you are absolutely correct. However, what about this?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你说这是无效的代码，当我们调用 `console.log()` 时会得到 `undefined`，你完全正确。然而，这个呢？
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What should be the output of the preceding code? It is natural to expect `undefined`
    as the `var a` statement comes after `a = 1`, and it would seem natural to assume
    that the variable is redefined and thus assigned the default `undefined`. However,
    the output will be `1`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: preceding 代码的输出应该是什么？自然会期望 `undefined` 作为 `var a` 语句在 `a = 1` 之后，似乎自然地假设变量被重新定义并分配了默认的
    `undefined`。然而，输出将是 `1`。
- en: 'When you see `var a = 1`, JavaScript splits it into two statements: `var a`
    and `a = 1`. The first statement, the declaration, is processed during the compilation
    phase. The second statement, the assignment, is left in place for the execution
    phase.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到 `var a = 1` 时，JavaScript 将其拆分为两个语句：`var a` 和 `a = 1`。第一个语句，声明，在编译阶段处理。第二个语句，赋值，在执行阶段保持原位。
- en: 'So the preceding snippet would actually be executed as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，前面的片段实际上将按以下方式执行：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first snippet is actually executed as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个片段实际上按以下方式执行：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, as we can see, variable and function declarations are moved up to the top
    of the code during compilation phase—this is also popularly known as **hoisting**.
    It is very important to remember that only the declarations themselves are hoisted,
    while any assignments or other executable logic are left in place. The following
    snippet shows you how function declarations are hoisted:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如我们所见，变量和函数声明在编译阶段被移动到代码的顶部——这也被称为**提升**。非常重要记住的是，只有声明本身被提升，而任何赋值或其他可执行逻辑都保持原位。以下片段展示了函数声明是如何被提升的：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The declaration of the `foo()` function is hoisted such that we are able to
    execute the function before defining it. One important aspect of hoisting is that
    it works per scope. Within the `foo()` function, declaration of the a variable
    will be hoisted to the top of the `foo()` function, and not to the top of the
    program. The actual execution of the `foo()` function with hoisting will be something
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo()` 函数的声明被提升，以至于我们能够在定义它之前执行该函数。提升的一个重要方面是它按作用域工作。在 `foo()` 函数内部，变量的声明将被提升到
    `foo()` 函数的顶部，而不是程序的顶部。利用提升执行 `foo()` 函数的实际代码如下：'
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We saw that function declarations are hoisted but function expressions are not.
    The next section explains this case.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了函数声明被提升，但函数表达式不会。下一节解释了这个案例。
- en: Function declarations versus function expressions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数声明与函数表达式
- en: 'We saw two ways by which functions are defined. Though they both serve identical
    purposes, there is a difference between these two types of declarations. Check
    the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了定义函数的两种方式。虽然它们都服务于相同的目的，但这些两种声明之间存在差异。查看下面的例子：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, it''s perfectly safe and, in fact, smart to do the same with function
    expressions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用函数表达式这样做是完全安全且明智的：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you are curious to know why you should not use function declarations in conditional
    blocks, read on; otherwise, you can skip the following paragraph.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇想知道为什么不应该在条件块中使用函数声明，请继续阅读；否则，你可以跳过下面的段落。
- en: Function declarations are allowed to appear only in the program or function
    body. They cannot appear in a block (`{ ... }`). Blocks can only contain statements
    and not function declarations. Due to this, almost all implementations of JavaScript
    have behavior different from this. It is always advisable to *never* use function
    declarations in a conditional block.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明只能出现在程序或函数体中。它们不能出现在块（`{ ... }`）中。块只能包含语句，不能包含函数声明。由于这个原因，几乎所有JavaScript的实现都有与这个不同的行为。建议*永远*不要在条件块中使用函数声明。
- en: Function expressions, on the other hand, are very popular. A very common pattern
    among JavaScript programmers is to fork function definitions based on some kind
    of a condition. As such forks usually happen in the same scope, it is almost always
    necessary to use function expressions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数表达式非常流行。在JavaScript程序员中，基于某种条件对函数定义进行分叉是一个非常常见的模式。由于这样的分叉通常发生在同一作用域中，几乎总是需要使用函数表达式。
- en: The arguments parameter
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`arguments`参数'
- en: 'The arguments parameter is a collection of all the arguments passed to the
    function. The collection has a property named `length` that contains the count
    of arguments, and the individual argument values can be obtained using an array
    indexing notation. Okay, we lied a bit. The arguments parameter is not a JavaScript
    array, and if you try to use array methods on arguments, you''ll fail miserably.
    You can think of arguments as an array-like structure. This makes it possible
    to write functions that take an unspecified number of parameters. The following
    snippet shows you how you can pass a variable number of arguments to the function
    and iterate through them using an arguments array:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`参数包含了所有传递给函数的参数。这个集合有一个名为`length`的属性，包含了参数的数量，单个参数的值可以使用数组索引表示法来获取。好吧，我们有点撒谎。`arguments`参数不是一个JavaScript数组，如果你尝试在`arguments`上使用数组方法，你会失败得很惨。你可以把`arguments`看作是一个类似数组结构。这使得能够编写接受不确定数量参数的函数成为可能。下面的片段展示了如何向函数传递可变数量的参数，并使用`arguments`数组遍历它们：'
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we discussed, the arguments parameter is not really an array; it is possible
    to convert it to an array as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，`arguments`参数并不是一个真正的数组；可以像下面这样将其转换为数组：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once converted to an array, you can manipulate the list as you wish.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦转换为数组，你可以随意操作列表。
- en: The this parameter
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这个参数
- en: Whenever a function is invoked, in addition to the parameters that represent
    the explicit arguments that were provided on the function call, an implicit parameter
    named `this` is also passed to the function. It refers to an object that's implicitly
    associated with the function invocation, termed as a **function context**. If
    you have coded in Java, the `this` keyword will be familiar to you; like Java,
    `this` points to an instance of the class in which the method is defined.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每当函数被调用时，除了代表在函数调用中提供的显式参数之外，还会隐式地传递一个名为`this`的参数给函数。它指的是与函数调用隐式相关联的对象，称为**函数上下文**。如果你编过Java代码，`this`关键字对你来说会很熟悉；就像Java一样，`this`指向定义方法类实例。
- en: Equipped with this knowledge, let's talk about various invocation methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，让我们来谈谈各种调用方法。
- en: Invocation as a function
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为函数的调用
- en: 'If a function is not invoked as a method, constructor, or via `apply()` or
    `call()`, it''s simply invoked *as a function*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数不是作为方法、构造函数，或者通过`apply()`或`call()`调用，它就简单地以*函数*的形式调用：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When a function is invoked with this pattern, `this` is bound to the global
    object. Many experts believe this to be a bad design choice. It is natural to
    assume that `this` would be bound to the parent context. When you are in a situation
    such as this, you can capture the value of `this` in another variable. We will
    focus on this pattern later.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数以这种模式调用时，`this`绑定到全局对象。许多专家认为这是一个糟糕的设计选择。自然地，我们可能会认为`this`会被绑定到父上下文。当你处于这种情况时，你可以将`this`的值捕获到另一个变量中。我们稍后重点关注这种模式。
- en: Invocation as a method
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为方法调用
- en: 'A method is a function tied to a property on an object. For methods, `this`
    is bound to the object on invocation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是与对象上的属性绑定的函数。对于方法来说，在调用时`this`绑定到调用对象上：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, `this` is bound to the person object on invoking `greet` because
    `greet` is a method of person. Let's see how this behaves in both these invocation
    patterns.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当调用`greet`时`this`绑定到`person`对象上，因为`greet`是`person`的一个方法。让我们看看这两种调用模式下这种行为是如何表现的。
- en: 'Let''s prepare this HTML and JavaScript harness:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备这个HTML和JavaScript harness：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the **Firebug** console, you can see the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Firebug**控制台中，你可以看到以下输出：
- en: '![Invocation as a method](img/00006.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![作为方法的调用](img/00006.jpeg)'
- en: The first two method invocations were invocation as a function; hence, the `this`
    parameter pointed to the global context (`Window`, in this case).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法调用都是作为函数调用；因此，`this`参数指向全局上下文（在这个例子中是`Window`）。
- en: Next, we define an object with a `testObj` variable with a property named `testObjFunc`
    that receives a reference to `testF()`—don't fret if you are not really aware
    of object creation yet. By doing this, we created a `testObjMethod()` method.
    Now, when we invoke this method, we expect the function context to be displayed
    when we display the value of `this`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个名为`testObj`的变量，它有一个名为`testObjFunc`的属性，该属性接收对`testF()`的引用——如果你现在还不清楚对象是如何创建的，也不要担心。这样做，我们创建了一个`testObjMethod()`方法。现在，当我们调用这个方法时，我们期望当显示`this`的值时显示函数上下文。
- en: Invocation as a constructor
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为构造函数的调用
- en: '**Constructor** functions are declared just like any other functions and there''s
    nothing special about a function that''s going to be used as a constructor. However,
    the way in which they are invoked is very different.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数**的声明与其他任何函数一样，即将作为构造函数的函数也没有什么特别之处。然而，它们的调用方式却大不相同。'
- en: To invoke the function as a constructor, we precede the function invocation
    with the **new** keyword. When this happens, `this` is bound to the new object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要作为构造函数调用函数，我们在函数调用前加上**new**关键字。当这样做时，`this`绑定到新对象上。
- en: 'Before we discuss more, let''s take a quick introduction to object orientation
    in JavaScript. We will, of course, discuss the topic in great detail in the next
    chapter. JavaScript is a prototypal inheritance language. This means that objects
    can inherit properties directly from other objects. The language is class-free.
    Functions that are designed to be called with the `new` prefix are called constructors.
    Usually, they are named using **PascalCase** as opposed to **CamelCase** for easier
    distinction. In the following example, notice that the `greet` function uses this
    to access the `name` property. The `this` parameter is bound to `Person`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论更多之前，让我们先快速介绍一下JavaScript中的面向对象。当然，我们将在下一章中详细讨论这个话题。JavaScript是一种基于原型继承的语言。这意味着对象可以直接从其他对象继承属性。这种语言是无类的。设计为用`new`前缀调用的函数称为构造函数。通常，为了更容易区分，它们使用**帕斯卡命名法**而不是**驼峰命名法**。在下面的例子中，注意`greet`函数使用`this`来访问`name`属性。`this`参数绑定到`Person`上：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will discuss this particular invocation method when we study objects in the
    next chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章学习对象时讨论这种特定的调用方法。
- en: Invocation using apply() and call() methods
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`apply()`和`call()`方法调用
- en: 'We said earlier that JavaScript functions are objects. Like other objects,
    they also have certain methods. To invoke a function using its `apply()` method,
    we pass two parameters to `apply()`: the object to be used as the function context
    and an array of values to be used as the invocation arguments. The `call()` method
    is used in a similar manner, except that the arguments are passed directly in
    the argument list rather than as an array.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，JavaScript函数是对象。与其他对象一样，它们也有一些特定的方法。要使用`apply()`方法调用函数，我们向`apply()`传递两个参数：作为函数上下文的对象和一个作为调用参数的数组。`call()`方法的用法类似，不同之处在于参数是直接在参数列表中传递，而不是作为数组。
- en: Anonymous functions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: We introduced you to anonymous functions a bit earlier in this chapter, and
    as they're a crucial concept, we will take a detailed look at them. For a language
    inspired by Scheme, anonymous functions are an important logical and structural
    construct.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这章的早些时候向你介绍了匿名函数，因为它们是一个关键概念，所以我们将详细介绍它们。对于受Scheme启发的语言来说，匿名函数是一个重要的逻辑和结构构建。
- en: Anonymous functions are typically used in cases where the function doesn't need
    to have a name for later reference. Let's look at some of the most popular usages
    of anonymous functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数通常用于函数不需要在稍后引用的情况下。让我们看看匿名函数的一些最流行的使用情况。
- en: Anonymous functions while creating an object
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在创建对象时使用匿名函数
- en: 'An anonymous function can be assigned to an object property. When we do that,
    we can call that function with a dot (`.`) operator. If you are coming from a
    Java or other OO language background, you will find this very familiar. In such
    languages, a function, which is part of a class is generally called with a notation—`Class.function()`.
    Let''s consider the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '匿名函数可以赋值给对象属性。这样做时，我们可以使用点（`.`）运算符调用该函数。如果你来自Java或其他面向对象语言的背景，你会发现这非常熟悉。在这样
    languages, a function, which is part of a class is generally called with a notation—`Class.function()`.
    Let''s consider the following example:'
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we are creating an object with a `say` property, which is an
    anonymous function. In this particular case, this property is known as a method
    and not a function. We don't need to name this function because we are going to
    invoke it as the object property. This is a popular pattern and should come in
    handy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个具有`say`属性的对象，该属性是一个匿名函数。在这个特定情况下，这个属性被称为方法而不是函数。我们不需要给这个函数命名，因为我们打算将其作为对象属性调用。这是一个流行的模式，应该会派上用场。
- en: Anonymous functions while creating a list
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在创建列表时使用匿名函数
- en: 'Here, we are creating two anonymous functions and adding them to an array.
    (We will take a detailed look at arrays later.) Then, you loop through this array
    and execute the functions in a loop:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个匿名函数并将它们添加到一个数组中。（我们稍后会对数组进行详细介绍。）然后，你遍历这个数组并在循环中执行这些函数：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Anonymous functions as a parameter to another function
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将匿名函数作为另一个函数的参数
- en: 'This is one of the most popular patterns and you will find such code in most
    professional libraries:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最流行的模式之一，你会在大多数专业库中找到这样的代码：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You are passing the anonymous function to another function. In the receiving
    function, you are executing the function passed as a parameter. This can be very
    convenient if you are creating single-use functions such as object methods or
    event handlers. The anonymous function syntax is more concise than declaring a
    function and then doing something with it as two separate steps.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你将匿名函数传递给另一个函数。在接收函数中，你执行作为参数传递的函数。如果你正在创建一次性函数，例如对象方法或事件处理程序，这会非常方便。与先声明一个函数然后将其作为两个单独的步骤进行处理相比，匿名函数语法更为简洁。
- en: Anonymous functions in conditional logic
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在条件逻辑中使用匿名函数
- en: 'You can use anonymous function expressions to conditionally change behavior.
    The following example shows this pattern:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用匿名函数表达式来条件性地改变行为。以下示例展示了这种模式：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, based on a condition, we are assigning a different implementation to the
    `shape` variable. This pattern can be very useful if used with care. Overusing
    this can result in unreadable and difficult-to-debug code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，根据条件，我们将不同的实现分配给`shape`变量。如果使用得当，这种模式非常有用。过度使用可能导致代码难以阅读和调试。
- en: Later in this book, we will look at several functional tricks such as **memoization**
    and caching function calls. If you have reached here by quickly reading through
    the entire chapter, I would suggest that you stop for a while and contemplate
    on what we have discussed so far. The last few pages contain a ton of information
    and it will take some time for all this information to sink in. I would suggest
    that you reread this chapter before proceeding further. The next section will
    focus on closures and the module pattern.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的后面部分，我们将探讨几种函数式技巧，例如**记忆化**和缓存函数调用。如果你是快速浏览了整个章节后到达这里的，我建议你停一下，思考一下我们迄今为止讨论的内容。最后几页包含了大量信息，所有这些信息需要一段时间才能吸收。我建议你在继续之前重新阅读这一章。下一节将重点介绍闭包和模块模式。
- en: Closures
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: Traditionally, closures have been a feature of purely functional programming
    languages. JavaScript shows its affinity with such functional programming languages
    by considering closures integral to the core language constructs. Closures are
    gaining popularity in mainstream JavaScript libraries and advanced production
    code because they let you simplify complex operations. You will hear experienced
    JavaScript programmers talking almost reverently about closures—as if they are
    some magical construct far beyond the reach of the intellect that common men possess.
    However, this is not so. When you study this concept, you will find closures to
    be very obvious, almost matter-of-fact. Till you reach closure enlightenment,
    I suggest you read and reread this chapter, research on the Internet, write code,
    and read JavaScript libraries to understand how closures behave—but do not give
    up.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，闭包一直是纯函数式编程语言的一个特性。JavaScript通过将闭包视为核心语言结构的一部分，显示了它与这类函数式编程语言的亲和力。闭包在主流JavaScript库和高级生产代码中越来越受欢迎，因为它们可以帮助你简化复杂操作。你会在经验丰富的JavaScript程序员那里听到他们对闭包几乎带有敬畏的谈论——仿佛闭包是超出了普通人智力范围的一些神奇构造。然而，事实并非如此。当你研究这个概念时，你会发现闭包其实非常明显，几乎是不言自明。在你达到闭包的顿悟之前，我建议你多次阅读这一章节，上网查找资料，编写代码，阅读JavaScript库，以了解闭包的行为——但不要放弃。
- en: The first realization that you must have is that closure is everywhere in JavaScript.
    It is not a hidden special part of the language.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先必须认识到的是，闭包在JavaScript中无处不在。它并不是语言中一个隐藏的特殊部分。
- en: Before we jump into the nitty-gritty, let's quickly refresh the lexical scope
    in JavaScript. We discussed in great detail how lexical scope is determined at
    the function level in JavaScript. Lexical scope essentially determines where and
    how all identifiers are declared and predicts how they will be looked up during
    execution.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们快速回顾一下JavaScript中的词法作用域。我们详细讨论了在JavaScript中如何根据函数级别确定词法作用域。词法作用域基本上决定了所有标识符在哪里以及如何声明，并预测在执行期间它们如何被查找。
- en: In a nutshell, closure is the scope created when a function is declared that
    allows the function to access and manipulate variables that are external to this
    function. In other words, closures allow a function to access all the variables,
    as well as other functions, that are in scope when the function itself is declared.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，闭包是当一个函数被声明时创建的上下文，它允许函数访问和操作位于该函数之外的变量。换句话说，闭包允许函数访问在自己声明时处于作用域内的所有变量及其他函数。
- en: 'Let''s look at some example code to understand this definition:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例代码来理解这个定义：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Were you expecting something shiny? No, this is really the most ordinary case
    of a closure. We are declaring a variable in the global scope and declaring a
    function in the global scope. In the function, we are able to access the variable
    declared in the global scope—`outer`. So essentially, the outer scope for the
    `outerFn()` function is a closure and always available to `outerFn()`. This is
    a good start but perhaps then you are not sure why this is such a great thing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你期待一些闪亮的东西吗？不，这真的是闭包最普通的情况。我们在全局作用域中声明一个变量，并在全局作用域中声明一个函数。在函数中，我们能够访问在全局作用域中声明的变量——`outer`。所以，本质上，`outerFn()`函数的外部作用域就是一个闭包，并且始终对`outerFn()`可用。这是一个不错的开始，但也许你还不确定为什么这是一件多么伟大的事情。
- en: 'Let''s make things a bit more complex:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让事情变得复杂一些：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What phenomenon allows the `inner` variable to still be available when we execute
    the inner function, long after the scope in which it was created has gone away?
    When we declared `innerFn()` in `outerFn()`, not only was the function declaration
    defined, but a closure was also created that encompasses not only the function
    declaration, but also all the variables that are in scope at the point of the
    declaration. When `innerFn()` executes, even if it's executed after the scope
    in which it was declared goes away, it has access to the original scope in which
    it was declared through its closure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 是什么现象使得在`innerFn()`内部函数执行时，即使它创建的作用域已经消失很久，`inner`变量仍然可用？当我们在`outerFn()`中声明`innerFn()`时，不仅函数声明被定义，而且还创建了一个闭包，它不仅包含函数声明，还包括声明时处于作用域内的所有变量。当`innerFn()`执行时，即使它是在自己声明的作用域消失后执行，它仍然可以通过闭包访问到自己声明时的原始作用域。
- en: 'Let''s continue to expand this example to understand how far you can go with
    closures:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续扩展这个示例，以了解你可以使用闭包做到何种程度：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, we have added a few more things. First, we added a
    parameter to `innerFn()`—just to illustrate that parameters are also part of the
    closure. There are two important points that we want to highlight.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们添加了一些东西。首先，我们在`innerFn()`中添加了一个参数——只是为了说明参数也是闭包的一部分。我们有两个重要的点想要强调。
- en: All variables in an outer scope are included even if they are declared after
    the function is declared. This makes it possible for the line, `console.log(magic)`,
    in `innerFn()`, to work.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在外层作用域中声明变量是在函数声明之后，外层作用域中的所有变量也会被包含在内。这使得`innerFn()`中的行`console.log(magic)`可以正常工作。
- en: However, the same line, `console.log(magic)`, in the global scope will fail
    because even within the same scope, variables not yet defined cannot be referenced.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在全局作用域中相同的行`console.log(magic)`将失败，因为即使在相同的作用域中，尚未定义的变量也不能引用。
- en: All these examples were intended to convey a few concepts that govern how closures
    work. Closures are a prominent feature in the JavaScript language and you can
    see them in most libraries.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都是为了传达一些关于闭包如何工作的概念。闭包是JavaScript语言中的一个突出特性，您可以在大多数库中看到它们。
- en: Let's look at some popular patterns around closures.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些关于闭包的流行模式。
- en: Timers and callbacks
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器和回调
- en: 'In implementing timers or callbacks, you need to call the handler asynchronously,
    mostly at a later point in time. Due to the asynchronous calls, we need to access
    variables from outside the scope in such functions. Consider the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现定时器或回调时，您需要异步调用处理程序，通常在稍后的时间点。由于异步调用，我们需要从这些函数外部访问变量。考虑以下示例：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We pass the inner `timerFn()` function to the built-in library function, `setTimeout()`.
    However, `timerFn()` has a scope closure over the scope of `delay()`, and hence
    it can reference the variable message.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将内部`timerFn()`函数传递给内置库函数`setTimeout()`。然而，`timerFn()`对外层`delay()`作用域有闭包，因此它可以引用变量message。
- en: Private variables
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有变量
- en: 'Closures are frequently used to encapsulate some information as private variables.
    JavaScript does not allow such encapsulation found in programming languages such
    as Java or C++, but by using closures, we can achieve similar encapsulation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包经常用来封装一些作为私有变量的信息。JavaScript不允许像Java或C++这样的编程语言中的封装，但通过使用闭包，我们可以实现类似的封装：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, we are creating a function that we intend to call
    as a constructor. In this `privateTest()` function, we are creating a `var points=0`
    variable as a function-scoped variable. This variable is available only in `privateTest()`.
    Additionally, we create an accessor function (also called a getter)—`getPoints()`—this
    method allows us to read the value of only the points variable from outside `privateTest()`,
    making this variable private to the function. However, another method, `score()`,
    allows us to modify the value of the private point variable without directly accessing
    it from outside. This makes it possible for us to write code where a private variable
    is updated in a controlled fashion. This pattern can be very useful when you are
    writing libraries where you want to control how variables are accessed based on
    a contract and pre-established interface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个打算作为构造函数调用的函数。在这个`privateTest()`函数中，我们创建了一个名为`var points=0`的变量作为函数作用域变量。这个变量仅在`privateTest()`中可用。此外，我们创建了一个访问器函数（也称为获取器）——`getPoints()`——这个方法允许我们从`privateTest()`外部只读取点变量的一个值，使得这个变量成为函数的私有变量。然而，另一个方法`score()`允许我们不直接从外部访问的情况下修改私有点变量值。这使得我们可以编写代码，以受控的方式更新私有变量。当您编写基于合同和预定义接口控制变量访问的库时，这种模式非常有用。
- en: Loops and closures
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环和闭包
- en: 'Consider the following example of using functions inside loops:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在循环中使用函数的示例：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'How can we fix this behavior? We can introduce a function scope and local copy
    of the `i` variable in that scope. The following snippet shows you how we can
    do this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何修复这种行为？我们可以在作用域中引入一个函数作用域和局部复制的`i`变量。以下代码片段向您展示了我们如何这样做：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We pass the `i` variable and copy it to the `j` variable local to the IIFE.
    The introduction of an IIFE inside each iteration creates a new scope for each
    iteration and hence updates the local copy with the correct value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在IIFE中传递了`i`变量，并将其复制到局部变量`j`中。在每次迭代中引入IIFE可以为新迭代创建一个新的作用域，从而更新具有正确值的局部副本。
- en: Modules
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: 'Modules are used to mimic classes and focus on public and private access to
    variables and functions. Modules help in reducing the global scope pollution.
    Effective use of modules can reduce name collisions across a large code base.
    A typical format that this pattern takes is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 模块用于模仿类，并专注于变量和函数的公共和私有访问。模块有助于减少全局作用域的污染。有效使用模块可以减少大型代码库中的名称冲突。这种模式采取的典型格式如下：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are two requirements to implement this pattern in the preceding format:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此前格式中实现此模式，有两个要求：
- en: There must be an outer enclosing function that needs to be executed at least
    once.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个外部闭合函数至少执行一次。
- en: This enclosing function must return at least one inner function. This is necessary
    to create a closure over the private state—without this, you can't access the
    private state at all.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个闭合函数必须至少返回一个内部函数。这是创建对私有状态的闭包所必需的——没有它，你根本无法访问私有状态。
- en: 'Check the following example of a module:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下模块示例：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This example satisfies both the conditions. Firstly, we create an IIFE or a
    named function to act as an outer enclosure. The variables defined will remain
    private because they are scoped in the function. We return the public functions
    to make sure that we have a closure over the private scope. Using IIFE in the
    module pattern will actually result in a singleton instance of this function.
    If you want to create multiple instances, you can create named function expressions
    as part of the module as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例满足两个条件。首先，我们创建一个IIFE或命名函数作为外部闭合。定义的变量将保持私有，因为它们在函数作用域内。我们返回公共函数，以确保我们对私有作用域有闭包。在模块模式中使用IIFE将实际上导致这个函数的单例实例。如果你想要创建多个实例，你也可以创建作为模块一部分的命名函数表达式。
- en: We will keep exploring various facets of functional aspects of JavaScript and
    closures in particular. There can be a lot of imaginative uses of such elegant
    constructs. An effective way to understand various patterns is to study the code
    of popular libraries and practice writing these patterns in your code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续探索JavaScript函数方面的各种方面，特别是闭包。这种优雅结构可以有大量的创新用途。理解各种模式的有效方式是研究流行库的代码并在你的代码中实践这些模式。
- en: Stylistic considerations
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风格上的考虑
- en: 'As in the previous chapter, we will conclude this discussion with certain stylistic
    considerations. Again, these are generally accepted guidelines and not rules—feel
    free to deviate from them if you have reason to believe otherwise:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前章所述，我们将以某些风格上的考虑来结束这次讨论。再次说明，这些通常是公认的指导原则，而非规则——如果你有理由相信其他情况，请随意偏离它们：
- en: 'Use function declarations instead of function expressions:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数声明，而不是函数表达式：
- en: '[PRE52]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Never declare a function in a non-function block (if, while, and so on). Assign
    the function to a variable instead. Browsers allow you to do it, but they all
    interpret it differently.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在非函数块中声明一个函数（if，while等）。相反，将函数赋值给一个变量。浏览器允许这样做，但它们的解释各不相同。
- en: Never name a parameter `arguments`. This will take precedence over the `arguments`
    object that is given to every function scope.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要将参数命名为`arguments`。这将优先于给予每个函数作用域的`arguments`对象。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we studied JavaScript functions. In JavaScript, functions play
    a critical role. We discussed how functions are created and used. We also discussed
    important ideas of closures and the scope of variables in terms of functions.
    We discussed functions as a way to create visibility classes and encapsulation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了JavaScript函数。在JavaScript中，函数扮演着至关重要的角色。我们讨论了函数是如何创建和使用的。我们还讨论了闭包和函数作用域中变量的
    scope 的重要概念。我们讨论了函数作为创建可见类和封装的方法。
- en: In the next chapter, we will look at various data structures and data manipulation
    techniques in JavaScript.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将查看JavaScript中的各种数据结构和数据操作技术。
