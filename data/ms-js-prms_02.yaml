- en: Chapter 2. The JavaScript Asynchronous Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 JavaScript异步模型
- en: In this chapter, we will look at the model behind asynchronous programming,
    why it was needed, and how it is implemented in JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨异步编程背后的模型，为什么需要它，以及如何在JavaScript中实现它。
- en: We will also learn what a programming model is and its significance, starting
    from a simple programming model to a synchronous model to an asynchronous model.
    Since our prime focus is on JavaScript, which employs an asynchronous programming
    model, we will discuss it in more detail than the rest of the models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习编程模型及其重要性，从简单的编程模型到同步模型，再到异步模型。由于我们主要关注的是JavaScript，它采用了一种异步编程模型，因此我们将比其他模型更详细地讨论它。
- en: Let's start with what models are and their significance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从模型及其重要性开始。
- en: Models are basically templates upon which the logics are designed and fabricated
    within a compiler/interpreter of a programming language so that software engineers
    can use these logics in writing their software logically. Every programming language
    we use is designed on a particular programming model. Since software engineers
    are asked to solve a particular problem or to automate any particular service,
    they adopt programming languages as per the need.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 模型基本上是在编程语言的编译器/解释器中设计和管理逻辑的模板，以便软件工程师可以在编写软件时使用这些逻辑。我们使用的每种编程语言都是基于某种编程模型设计的。由于软件工程师被要求解决一个特定问题或自动化任何特定服务，他们根据需要采用编程语言。
- en: There is no set rule that assigns a particular language to create products.
    Engineers adopt any language based on the need.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 没有固定的规则将特定的语言分配给创建产品。工程师根据需要采用任何语言。
- en: Programming models
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程模型
- en: 'Ideally, we will focus on three major programming models, which are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们将关注三种主要的编程模型，如下所述：
- en: The first one is a single-threaded synchronous model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是单线程同步模型
- en: The second one a is multithreaded model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种是多线程模型
- en: The third one is an asynchronous programming model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种是异步编程模型
- en: Since JavaScript employs an asynchronous model, we will discuss it in greater
    detail. However, let's start by explaining what these programming models are and
    how they facilitate their end users.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript采用异步模型，我们将更详细地讨论它。然而，让我们先解释一下这些编程模型是什么，以及它们如何为最终用户提供便利。
- en: The single-threaded synchronous model
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单线程同步模型
- en: 'The single-threaded synchronous model is a simple programming model or single-threaded
    synchronous programming model, in which one task follows the other. If there is
    a queue of tasks, the first task is given first priority, and so on and so forth.
    It''s the simplest way of getting things done, as shown in the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程同步模型是一种简单的编程模型或单线程同步编程模型，其中一个任务接着另一个任务。如果有任务队列，首先优先考虑第一个任务，依此类推。如下所示，这是完成事情的最简单方式：
- en: '![The single-threaded synchronous model](img/5500OS_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![单线程同步模型](img/5500OS_02_01.jpg)'
- en: The single-threaded synchronous programming model is one of the best examples
    of a `Queue` data structure, which follows the **First In First Out** (**FIFO**)
    rule. This model assumes that if **Task 2** is being executed at the moment, it
    must have been done after **Task 1** was finished without errors with all the
    output available as predicted or needed. This programming model is still supported
    for writing down simple programs for simple devices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程同步编程模型是`Queue`数据结构的一个最佳示例，遵循**先进先出**（**FIFO**）规则。该模型假设如果当前正在执行**任务2**，那么必须在**任务1**顺利完成且所有输出如预测或所需后才能进行。这种编程模型仍然支持为简单设备编写简单的程序。
- en: The multithreaded synchronous model
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程同步模型
- en: Unlike single-thread programming, in multi-thread programming, every task is
    performed in a separate thread, so multiple tasks need multiple threads. The threads
    are managed by the operating system, and may run concurrently on a system with
    multiple process or multiple cores.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与单线程编程不同，在多线程编程中，每个任务都在一个单独的线程中执行，因此多个任务需要多个线程。线程由操作系统管理，可能在具有多个进程或多个核心的系统上并发运行。
- en: 'It seems quite simple that multiple threads are managed by the OS or the program
    in which it''s being executed; it''s a complex and time-consuming task that requires
    multiple level of communications between the threads in order to conclude the
    task without any deadlock and errors, as can be seen from the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎很简单的多线程是由操作系统或在其上执行的程序管理的；它是一个复杂且耗时的工作，需要线程之间进行多级通信，以无死锁和错误地完成任务，正如下面的图表所示：
- en: '![The multithreaded synchronous model](img/5500OS_02_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![多线程同步模型](img/5500OS_02_02.jpg)'
- en: Some programs implement parallelism using multiple processes instead of multiple
    threads, although the programming details are different.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序使用多个进程而不是多个线程来实现并行，尽管编程细节不同。
- en: The asynchronous programming model
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程模型
- en: Within the asynchronous programming model, tasks are interleaved with one another
    in a single thread of control.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程模型中，任务在单一控制线程中相互交织。
- en: This single thread may have multiple embedded threads and each thread may contain
    several tasks linked up one after another. This model is simpler in comparison
    to the threaded case, as the programmers always know the priority of the task
    executing at a given slot of time in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一的线程可能包含多个嵌入线程，每个线程可能包含几个连续链接的任务。与线程情况相比，这个模型更简单，因为程序员总是知道在内存中给定时间槽执行任务的优先级。
- en: Consider a task in which an OS (or an application within OS) uses some sort
    of a scenario to decide how much time is to be allotted to a task, before giving
    the same chance to others. The behavior of the OS of taking control from one task
    and passing it on to another task is called **preempting**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个任务，在这个任务中，操作系统（或操作系统中的应用程序）使用某种场景来决定分配给一个任务多少时间，然后再给其他任务同样的机会。操作系统从一项任务中夺取控制并传递给另一项任务的行为称为**抢占**。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The multithreaded sync model is also referred to as **preemptive multitasking**.
    When it's asynchronous, it's called **cooperative multitasking**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程同步模型也被称为**抢占式多任务处理**。当它是异步的时候，它被称为**协作式多任务处理**。
- en: '![The asynchronous programming model](img/5500OS_02_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![异步编程模型](img/5500OS_02_03.jpg)'
- en: With threaded systems, the priority to suspend one thread and put another on
    the exaction is not in the programmer's hand; it's the base program that controls
    it. In general, it's controlled by the operating system itself, but this is not
    the case with an asynchronous system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程系统中，优先挂起一个线程并把另一个线程放到执行上的优先权不在程序员手中；这是基础程序控制的。通常，它是由操作系统本身控制的，但异步系统并非如此。
- en: In asynchronous systems, the control of execution and suspension of a thread
    is in complete discretion of the programmer and the thread won't change its state
    until it's explicitly asked to do so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步系统中，线程的执行和挂起控制完全由程序员决定，线程除非被明确要求改变状态，否则不会改变其状态。
- en: Densities with an asynchronous programming model
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有异步编程模型的密度
- en: With all these qualities of an asynchronous programming model, it has its densities
    to deal with.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 具有异步编程模型的所有特性，它也有其需要处理的密度。
- en: Since the control of execution and priority assignment is in a programmer's
    hand, he/she will have to organize each task as a sequence of smaller steps that
    are executed immediately. If one task uses the output of the other, the dependent
    task must be engineered so that it can accept its input as a sequence of bits
    not together; this is how programmers fabricate their tasks on and set their priorities.
    The soul of an asynchronous system that can outperform synchronous systems almost
    dramatically is when the tasks are forced to wait or are blocked.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行控制和优先级分配掌握在程序员手中，他/她必须将每个任务组织成一系列更小的立即执行的步骤。如果一个任务使用了另一个任务的输出，那么依赖任务必须被设计成能够将其输入作为一系列不连续的位来接受；程序员就是这样在自己的任务中编织并设定优先级的。异步系统的灵魂在于，当任务被迫等待或被阻塞时，它能够远远超越同步系统。
- en: Why do we need to block the task?
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么我们需要阻塞任务？
- en: A more common reason why a task is forcefully blocked is that it is waiting
    to perform an I/O or transfer data to and from an external device. A normal CPU
    can handle data transfer faster than any network link is capable of, which in
    result makes a synchronous program blocked that is spending so much time on I/O.
    Such programs are also referred as **blocking programs** for this reason.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务被强制阻塞的更常见原因是因为它正在等待执行I/O或与外部设备进行数据传输。普通的CPU处理数据传输的速度比任何网络链接都要快，这使得在I/O上花费了大量时间的同步程序被阻塞。因此，这样的程序也被称为**阻塞程序**。
- en: The whole idea behind an asynchronous model is avoid wasting CPU time and avoid
    blocking bits. When an asynchronous program encounters a task that will normally
    get blocked in a synchronous program, it will instead execute some other tasks
    that can still make progress. Because of this, asynchronous programs are also
    called **non-blocking program**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 异步模型的整个理念是避免浪费CPU时间并避免阻塞数据。当一个异步程序遇到一个在同步程序中通常会被阻塞的任务时，它将执行其他仍能取得进展的任务。因此，异步程序也被称为**非阻塞程序**。
- en: Since the asynchronous program spends less time waiting and roughly giving an
    equal amount of time to every task, it supersedes synchronous programs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Since the asynchronous program spends less time waiting and roughly giving an
    equal amount of time to every task, it supersedes synchronous programs.
- en: 'Compared to the synchronous model, the asynchronous model performs best in
    the following scenarios:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与同步模型相比，异步模型在以下场景中表现最佳：
- en: There are a large number of tasks, so it's likely that there is always at least
    one task that can make progress
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: There are a large number of tasks, so it's likely that there is always at least
    one task that can make progress
- en: The tasks perform lots of I/O, causing a synchronous program to waste lots of
    time blocking, when other tasks are running
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The tasks perform lots of I/O, causing a synchronous program to waste lots of
    time blocking, when other tasks are running
- en: The tasks are largely independent from one another, so there is little need
    for intertask communication (and thus for one task to wait for another)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The tasks are largely independent from one another, so there is little need
    for intertask communication (and thus for one task to wait for another)
- en: Keeping all the preceding points in mind, it will almost perfectly highlight
    a typical busy network, say a web server in a client-server environment, where
    each task represents a client requesting some information from the server. In
    such cases, an asynchronous model will not only increase the overall response
    time, but also add value to the performance by serving more clients (requests)
    at a time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: keeping all the preceding points in mind, it will almost perfectly highlight
    a typical busy network, say a web server in a client-server environment, where
    each task represents a client requesting some information from the server. In
    such cases, an asynchronous model will not only increase the overall response
    time, but also add value to the performance by serving more clients (requests)
    at a time.
- en: Why not use some more threads?
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Why not use some more threads?
- en: At this point, you may ask why not add another thread by not relying on a single
    thread. Well, the answer is quite simple. The more the threads, the more memory
    it will consume, which in turn will create low performance and a higher turnaround
    time. Using more threads doesn't only come with a cost of memory, but also with
    effects on performance. With each thread, a certain overhead is linked to maintain
    the state of that particular thread, but multiple threads will be used when there
    is an absolute need of them, not for each and every other thing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: At this point, you may ask why not add another thread by not relying on a single
    thread. Well, the answer is quite simple. The more the threads, the more memory
    it will consume, which in turn will create low performance and a higher turnaround
    time. Using more threads doesn't only come with a cost of memory, but also with
    effects on performance. With each thread, a certain overhead is linked to maintain
    the state of that particular thread, but multiple threads will be used when there
    is an absolute need of them, not for each and every other thing.
- en: Learning the JavaScript asynchronous model
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Learning the JavaScript asynchronous model
- en: Keeping this knowledge in mind, if we see what the JavaScript asynchronous model
    is, we can now clearly relate to an asynchronous model in JavaScript and understand
    how it's implemented.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: keeping this knowledge in mind, if we see what the JavaScript asynchronous model
    is, we can now clearly relate to an asynchronous model in JavaScript and understand
    how it's implemented.
- en: In non-web languages, most of the code we write is synchronous, that is, blocking.
    JavaScript does its stuff in a different way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: In non-web languages, most of the code we write is synchronous, that is, blocking.
    JavaScript does its stuff in a different way.
- en: JavaScript is a single-threaded language. We already know what single threaded
    actually means for the sake of simplicity—two bits of the same script cannot run
    at the same time. In browsers, JavaScript shares a thread with loads of other
    processes inline. These "inline processes" can be different from one browser to
    another, but typically, **JavaScript** (**JS**) is in the same queue as painting,
    updating styles, and handling user actions (an activity in one of these processes
    delays the others).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种单线程语言。我们已经知道单线程的真正含义，为了简单起见——同一个脚本的两部分不能同时运行。在浏览器中，JavaScript与许多其他进程共享一个线程。这些“内联进程”可能因浏览器而异，但通常，**JavaScript**（**JS**）与绘制、更新样式和处理用户操作（这些进程中的一个活动会延迟其他进程）处于同一个队列中。
- en: As in the image beneath, whenever the asynchronous (non-blocking) script executes
    in a browser, it goes from top to bottom in an execution pattern. Starting from
    the page load, the script goes to a document object where the JavaScript object
    is created. The script then goes into the parsing phase where all the nodes and
    HTML tags are added. After the completion of parsing, the whole script will be
    loaded in the memory as an asynchronous (non-blocking) script.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如图片所示，每当在浏览器中执行异步（非阻塞）脚本时，它会按照执行模式从上到下进行。从页面加载开始，脚本会进入文档对象，在那里创建JavaScript对象。然后脚本进入解析阶段，在这个阶段所有的节点和HTML标签都被添加。解析完成后，整个脚本作为异步（非阻塞）脚本加载到内存中。
- en: '![Learning the JavaScript asynchronous model](img/5500OS_02_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![学习JavaScript异步模型](img/5500OS_02_04.jpg)'
- en: How JavaScript implements an asynchronous model
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何用JavaScript实现异步模型
- en: JavaScript uses an loop event and its cycle is called a "tick" (as in a clock),
    since it runs within the time slot bound by the CPU. An interpreter is responsible
    for checking whether every tick is an asynchronous callback to be executed. All
    other synchronous operations take place within the same tick. The time value passed
    is not guaranteed—there's no way of knowing how long it will take until the next
    tick, so we usually say the callbacks will run "as soon as possible"; although,
    some calls may even be dropped.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用一个循环事件，其周期被称为“滴答声”（类似于时钟），因为它在CPU规定的 时间片段内运行。解释器负责检查每个滴答声是否需要执行异步回调。所有其他的同步操作都在同一个滴答声内进行。传递的时间值没有保证——无法知道下一次滴答声将会在什么时候，所以我们通常说回调会“尽快”运行；尽管如此，一些调用甚至可能会被放弃。
- en: 'Within JavaScript, there are four core ways on how an asynchronous model is
    implemented in it. These four methods help not only for better performance of
    your program, but also in easier maintainability of code. These four methods are
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，实现异步模型的核心方式有四种。这四种方法不仅有助于提高程序的性能，还有助于代码的更容易维护。这四种方法如下：
- en: A callback function
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数
- en: The event listener
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件监听器
- en: The publisher/subscriber
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布/订阅模式
- en: The promises object
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺对象
- en: Callbacks in JavaScript
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的回调
- en: 'In JavaScript, functions are first class citizens, which means they can be
    treated as objects and because of the fact that they really are objects themselves.
    They can do what a regular object is capable of, such as these:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是一等公民，这意味着它们可以被当作对象对待，由于它们本身就是对象，所以它们可以做普通对象能做的一切，比如这些：
- en: Stored in variables
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在变量中
- en: Passed as augments to other functions
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为其他函数的参数传递
- en: Created within functions
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内创建
- en: Returned from functions after a payload of some processed data mechanism
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理了一些数据机制的负载后作为函数的返回值
- en: A callback function, also known as a higher-order function, is a function that
    is passed to another function (let's call this other function as `otherFunction`)
    as a parameter, and the callback function is called (executed) inside `otherFunction`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数，也称为高阶函数，是一个被传递到另一个函数（让我们称这个其他函数为`otherFunction`）作为参数的函数，回调函数在`otherFunction`内部被调用（执行）。
- en: A callback function is essentially a pattern (an established solution to a common
    problem), and therefore the use of a callback function is also known as a callback
    pattern. Because functions are first class objects, we can use callback functions
    in JavaScript.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，回调函数是一种模式（一个解决常见问题的既定方案），因此使用回调函数也称为回调模式。因为函数是一等对象，所以我们可以在JavaScript中使用回调函数。
- en: Since functions are first class objects, we can use callback functions in JavaScript,
    but what are callback functions? The idea behind callback functions is derived
    from functional programming, which uses functions as arguments as implementing
    callback functions is as easy as passing regular variables as arguments to functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是一等对象，我们可以在JavaScript中使用回调函数，但回调函数是什么呢？回调函数背后的想法来源于函数式编程，它使用函数作为参数来实现回调函数，就像把普通变量作为参数传递给函数一样简单。
- en: 'A common use of a callback function can be seen in the following lines of code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的回调函数用法可以在以下代码行中看到：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code explains itself as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解释了自身：
- en: We pass a function as a parameter to the `click` function
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们把一个函数作为`click`函数的参数
- en: The `click` function will call (or execute) the callback function we passed
    to it
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click`函数将会调用（或执行）我们传递给它的回调函数'
- en: This is a typical use of callback functions in JavaScript, and indeed, it is
    widely used in jQuery. We will examine promise with respect to jQuery in more
    details in [Chapter 8](ch08.html "Chapter 8. Promises in jQuery"), *Promises in
    jQuery*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript中回调函数的典型用法，实际上，它在jQuery中得到了广泛应用。我们将在[第8章](ch08.html "Chapter 8. Promises
    in jQuery")*jQuery中的Promise*中更详细地研究jQuery中的promise。
- en: Blocking functions
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻塞函数
- en: While we are discussing what a blocking function in JavaScript is and how one
    should implement it, many of us really don't clearly understand what we mean by
    a blocking function in JavaScript.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论JavaScript中的阻塞函数是什么以及应该如何实现它时，我们中的许多人实际上并不清楚地理解我们所说的JavaScript中的阻塞函数是什么意思。
- en: As humans, we have a mind that is designed in such a way that it can do many
    tasks at a time, such as while reading this book, you are aware of the surroundings
    around you, you can think and type simultaneously, and you can talk to someone
    while you are driving.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们的头脑被设计成可以同时做很多事情，比如在读这本书的时候，你意识到了你周围的环境，你可以在思考和打字的同时进行，你可以在开车的时候和人交谈。
- en: These examples are for multithreaded models, but is there any blocking function
    in our human body? The answer is yes. We have a blocking function because of which
    we all have other activities in our mind and within our body; it stops for a tiny
    pinch of a nanosecond. This blocking function is called sneezing. When any human
    sneezes, all the functions related to mind and body became blocked for a tiny
    fraction of nanosecond. This is rarely noticed by people. The same goes with the
    blocking function of JavaScript.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子是为多线程模型准备的，但在我们的人体中有没有任何阻塞函数呢？答案是有的。我们有一个阻塞函数，正因为如此，我们的头脑和体内都有其他活动；它会在纳米秒级的短暂瞬间停止。这个阻塞函数叫做打喷嚏。当任何人类打喷嚏时，与头脑和身体相关的所有函数都会在纳米秒级的短暂瞬间被阻塞。人们很少注意到这一点。JavaScript的阻塞函数也是如此。
- en: The mechanism of a callback function in JavaScript
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的回调函数机制
- en: The question here is, how on earth does a callback function work?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，回调函数究竟是如何工作的？
- en: As we know that functions are like first class objects in JS, we can pass them
    around in a similar way to variables and return them as functions and use them
    in other functions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，在JS中函数就像是一等对象，我们可以像变量一样传递它们，将它们作为函数返回，并在其他函数中使用它们。
- en: When we pass a callback function as arguments to another function, we are only
    passing the function definition. We aren't executing functions in parameters.
    We are also not passing the function with the trailing pair of executing parenthesis
    `()`, as we would when we are executing a function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们把一个回调函数作为参数传递给另一个函数时，我们只传递了函数定义。我们并没有在参数中执行函数。我们也没有用执行括号`()`来传递函数，因为我们在执行函数时才会这样做。
- en: Since the containing function has the callback function in its parameter as
    a function definition, it can execute the callback at any time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于包含函数在其参数中有回调函数作为函数定义，它可以在任何时候执行回调。
- en: It is important to note that the callback function is not executed immediately.
    It is "called back" and can still be accessed later via the arguments object by
    the containing function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，回调函数并不会立即执行。它是“回调”的，仍然可以通过参数对象在包含函数中稍后访问。
- en: Basic rules to implement callbacks
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现回调函数的基本规则
- en: There are some basic rules that you need to keep in mind while you are implementing
    the callbacks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现回调函数时，有一些基本规则你需要记住。
- en: 'Callbacks are normally simple, but you should be familiar with the rule if
    you are crafting your own callback functions. Here are some key pointers that
    you must take into account while you are working on your callback functions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常很简单，但如果你正在编写自己的回调函数，你应该熟悉这条规则。以下是你在处理回调函数时必须考虑的一些关键要点：
- en: Use named or anonymous functions as callbacks
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名或匿名函数作为回调
- en: Pass parameters to callback functions
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数传递给回调函数
- en: Make sure callback is a function before executing it
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行回调之前确保它是一个函数
- en: Handling callback hell
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理回调地狱
- en: As JavaScript uses callback functions to handle asynchronous control flow, working
    with nesting of callbacks can become messy and most of the time, out of control.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript使用回调函数来处理异步控制流，嵌套回调的工作可能会变得混乱，而且大多数时候，会变得无法控制。
- en: One needs to be very careful while writing callbacks or using it from any other
    library.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写回调或从任何其他库使用它时，需要非常小心。
- en: 'Here is what happens if the callbacks are not handled properly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不正确处理回调，会发生以下情况：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding situation is commonly referred to as **callback hell**. This is
    quite common in JavaScript, which makes the lives of engineers miserable. This
    also makes the code hard for other team members to understand and hard to maintain
    for further use. The most drastic of all is that it confuses an engineer, making
    it hard for him/her to remember where to pass on the control.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种情况通常被称为**回调地狱**。这在JavaScript中很常见，这让工程师们痛苦不堪。这也使得代码对于其他团队成员来说难以理解，对于后续使用来说难以维护。最糟糕的是，它让工程师混淆，难以记住在哪里传递控制权。
- en: 'Here are the quick reminders for callback hell:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是回调地狱的快速提醒：
- en: Never let your function be unnamed. Give your function an understandable and
    meaningful name. The name must show it's a callback function that is performing
    certain operations instead of defining an anonymous function in the parameter
    of the main function.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要让你的函数没有名字。给你的函数一个可理解且有意义的名字。这个名字必须表明它是一个执行某些操作的回调函数，而不是在主函数的参数中定义一个匿名函数。
- en: Make your code less scary to look at and easier to edit, refactor, and hack
    on later. Most of the engineers write code in a flow of thought with less focus
    on beautification of code, which makes it difficult to maintain the code later.
    Use online tools such as [http://www.jspretty.com](http://www.jspretty.com) to
    add readability to your code.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的代码看起来不那么可怕，更容易编辑、重构和以后黑客攻击。大多数工程师在思考流程中编写代码，对代码的美观性关注较少，这使得代码的后期维护变得困难。使用在线工具，如[http://www.jspretty.com](http://www.jspretty.com)，为你的代码添加可读性。
- en: Separate your code into modules; don't write all your logic in a single module.
    Instead, write short meaningful modules so that you can export a section of code
    that does a particular job. You can then import that module into your larger application.
    This approach can also help you reuse the code in similar applications, thus making
    a whole library of your modules.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的代码分成模块；不要在一个模块中编写所有的逻辑。相反，编写简短有意义的模块，这样你可以导出一个执行特定工作的代码段。然后，你可以将该模块导入到你的大型应用程序中。这种方法还可以帮助你在类似的应用程序中重用代码，从而使你的模块形成一个完整的库。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有Pact Publishing书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: The events
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Events are signals that are generated when a specific action takes place. JavaScript
    is aware of such signals and responds accordingly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是在执行特定操作时产生的信号。JavaScript能够意识到这些信号并做出相应响应。
- en: Events are messages fired in a constant stream as the user works along. Events
    are normally based on user actions, and if programmed well, they act upon as directed.
    Any event is useless if it doesn't have a handler that works to handle events.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是在用户进行操作时以恒定流发出的消息。事件通常基于用户行为，如果编程得当，它们会按照指导行动。如果没有处理事件的处理程序，那么任何事件都是无用的。
- en: Since JavaScript provides a handsome control to programmers/engineers, it's
    their ability to handle events, monitor, and respond to them. The more capable
    you are at handling events, the more interactive your application will be.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 为程序员/工程师提供了漂亮的控制，它们处理事件、监控和响应事件的能力。你处理事件的能力越强，你的应用程序将越交互式。
- en: The mechanism of event handling
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理机制
- en: There are two conventional ways to implement events in JavaScript. The first
    one is via HTML using attributes and second is via script.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中实现事件有两大传统方式。第一种是通过 HTML 使用属性，第二种是通过脚本。
- en: 'To make your application respond to a user''s action, you need to do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的应用程序响应用户的动作，你需要做以下的事情：
- en: Decide which event should be monitored.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定应该监控哪个事件。
- en: Set up event handlers that trigger functions when an event occurs.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置在事件发生时触发函数的事件处理程序。
- en: Write the functions that provide the appropriate responses to the events.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写为事件提供适当响应的函数。
- en: The event handler is always the name of the event perceived by on, for example,
    click event handled by a event handler, `onClick()`. This event handler causes
    a function to run, and the function provides the response to the event.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序总是由 on 感知的事件名称，例如，由事件处理程序处理的点击事件，`onClick()`。这个事件处理程序导致一个函数运行，而该函数为事件提供响应。
- en: DOM – event capture and event bubbling
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM – 事件捕获和事件冒泡
- en: '**Document Object Model** (**DOM**) makes it much easier to detect the events
    and assign related event handlers to react to them. This uses two concepts of
    event capture and event bubbling for this purpose. Let''s take a look at how each
    can help in detecting and assigning the right handler for the right event.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）使得检测事件和为它们分配相关事件处理程序变得容易得多。这使用事件捕获和事件冒泡这两个概念来实现这一目的。让我们看看每个如何帮助检测和为正确的事件分配正确的处理程序。'
- en: Capturing an event is referred to as the process of an event as it commutes
    to its destination document. Also, it has the ability to capture or intercept
    this event.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获事件指的是事件在到达目的地文档的过程中的通信。同时，它具有捕获或拦截此事件的能力。
- en: This makes the whole round trip go incrementally downwards to its containing
    elements of the tree until it reaches to itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得整个往返过程逐渐向下到其树包含的元素，直到它达到自身。
- en: On the contrary, event bubbling is the inverse of event capture. With bubbling,
    the event is first captured and handled by the innermost element and then propagated
    to the outer elements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，事件冒泡是事件捕获的逆过程。在冒泡中，事件首先被最内层的元素捕获和处理，然后传播到外层元素。
- en: A list of the most common events handlers
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最常见的事件处理程序列表
- en: There is an entire array of event handlers to be put to use for different needs
    and situations, but let's add a few more common and regular events handlers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一系列事件处理程序需要根据不同的需求和情况进行使用，但让我们添加一些更常见和常规的事件处理程序。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please bear in mind that some event handlers may vary from one browser to another,
    and this specification becomes more limited when it comes to Microsoft's Internet
    Explorer or Mac's Safari.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一些事件处理程序可能因浏览器而异，当涉及到 Microsoft 的 Internet Explorer 或 Mac 的 Safari 时，这个规范变得更加有限。
- en: The following list is quite handy and self-explanatory. To use this list more
    effectively, I recommend developers/engineers to make a handy note of it for reference.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表非常方便且自解释。为了更有效地使用这个列表，我建议程序员/工程师将其记下来以供参考。
- en: '| Event category | When will the event be triggered | Event handler |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 事件类别 | 事件将何时被触发 | 事件处理程序 |'
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Browser events | A page completes loading | `Onload` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器事件 | 页面完成加载 | `Onload` |'
- en: '|   | The page is removed from the browser window | `Onunload` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  | 页面从浏览器窗口中移除 | `Onunload` |'
- en: '|   | JavaScript throws an error | `Onerror` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  | JavaScript 抛出错误 | `Onerror` |'
- en: '| Mouse events | The user clicks over an element | `onclick` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 鼠标事件 | 用户点击某个元素 | `onclick` |'
- en: '|   | The user double-clicks over an element | `ondblclick` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  | 用户双击元素 | `ondblclick` |'
- en: '|   | The mouse button is pressed down over an element | `onmousedown` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  | 鼠标按钮在元素上按下 | `onmousedown` |'
- en: '|   | The mouse button is released over an element | `onmouseup` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  | 鼠标按钮在元素上释放 | `onmouseup` |'
- en: '|   | The mouse pointer moves onto an element | `onmouseover` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  | 鼠标指针移动到元素上 | `onmouseover` |'
- en: '|   | The mouse pointer leaves an element | `Onmouseout` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|  | 鼠标指针离开一个元素 | `Onmouseout` |'
- en: '| Keyboard events | A key is pressed | `onkeydown` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 键盘事件 | 一个键被按下 | `onkeydown` |'
- en: '|   | A key is released | `onkeyup` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|   | 释放一个键 | `onkeyup` |'
- en: '|   | A key is pressed and released | `Onkeypress` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|   | 按下并释放一个键 | `Onkeypress` |'
- en: '| Form events | The element receives focus from a pointer or by tabbing navigation
    | `onfocus` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 表单事件 | 元素从指针或通过标签导航获得焦点 | `onfocus` |'
- en: '|   | The element loses focus | `onblur` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|   | 元素失去焦点 | `onblur` |'
- en: '|   | The user selects the type in text or text area field | `onselect` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|   | 用户在文本或文本区域字段中选择类型 | `onselect` |'
- en: '|   | The user submits a form | `onsubmit` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|   | 用户提交表单 | `onsubmit` |'
- en: '|   | The user resets a form | `onreset` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|   | 用户重置表单 | `onreset` |'
- en: '|   | The field loses focus and the content has changed since receiving focus
    | `onchange` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|   | 元素失去焦点且自获得焦点以来内容已更改 | `onchange` |'
- en: As mentioned earlier, these are the most common list of event handlers. There
    is a separate list of specifications for Microsoft's Internet explorer that can
    be found at [http://msdn.microsoft.com/en-us/library/ie/ms533051(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/ie/ms533051(v=vs.85).aspx).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些都是最常见的事件处理列表。有一个单独的规格列表是为微软的Internet Explorer准备的，可以在[http://msdn.microsoft.com/en-us/library/ie/ms533051(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/ie/ms533051(v=vs.85).aspx)找到。
- en: 'A complete list of the event''s compatibility can be seen at:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 事件兼容性的完整列表可以在以下链接找到：
- en: '[http://www.quirksmode.org/dom/events/index.html](http://www.quirksmode.org/dom/events/index.html)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://www.quirksmode.org/dom/events/index.html](http://www.quirksmode.org/dom/events/index.html)找到兼容性信息。
- en: Triggering functions in response to events
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件响应中触发函数
- en: 'JavaScript events need triggering in order to get a response. An event handler
    is responsible for responding to such events, but there are four commonly used
    ways to trigger events in a proper manner:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript事件需要触发以获得响应。事件处理程序负责响应此类事件，但正确触发事件有四种常用方法：
- en: The JavaScript pseudo protocol
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript伪协议
- en: The inline event handler
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联事件处理程序
- en: The handler as an object property
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对象属性的处理程序
- en: Event listeners
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件监听器
- en: Types of events in JavaScript
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的事件类型
- en: 'There are many different types of events in JavaScript, some listed as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有很多不同类型的事件，其中一些如下：
- en: Interface events
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口事件
- en: Mouse events
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: Form events
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单事件
- en: W3C events
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 万维网联盟（W3C）事件
- en: Microsoft events
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软事件
- en: Mozilla events
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 火狐事件
- en: Interface events
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口事件
- en: The interface events occur due to the user's action. When the user clicks on
    any element, he/she always causes a click event. When clicking on the element
    has specific purpose, an additional interface event is caused.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接口事件是由用户的动作触发的。当用户点击任何元素时，他/她总是触发一个点击事件。当点击元素有特定的目的时，会引发一个额外的事件接口。
- en: Mouse events
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: When the user moves the mouse into the link area, the mouseover event fires.
    When he/she clicks on it, the click event fires.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将鼠标移动到链接区域时，会触发mouseover事件。当他/她点击它时，会触发click事件。
- en: Form events
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单事件
- en: Forms recognize submit and reset events, which predictably, fire when the user
    submits or resets a form. The submit event is the key of any form of a validation
    script.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表单识别提交和重置事件，当用户提交或重置表单时会预测性地触发这些事件。提交事件是任何表单验证脚本的关键。
- en: W3C events
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 万维网联盟（W3C）事件
- en: W3C events fire when the DOM structure of a document is changed. The most general
    one is the `DOMSubtreeModified` event that is fired when the DOM tree below the
    HTML element is triggered.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档的DOM结构发生变化时触发W3C事件。最通用的是`DOMSubtreeModified`事件，该事件在HTML元素以下的DOM树被触发时触发。
- en: The DOM 2 event specification can be seen at [http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-eventgroupings-mutationevents](http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-eventgroupings-mutationevents).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[DOM 2 事件规格](http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-eventgroupings-mutationevents)可以在[http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-eventgroupings-mutationevents](http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-eventgroupings-mutationevents)找到。'
- en: Microsoft events
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微软事件
- en: Microsoft has created a number of its own event's handler specification, which
    (of course) can only run on its platform. This can be seen at [http://msdn.microsoft.com/en-us/library/ie/ms533051(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/ie/ms533051(v=vs.85).aspx).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 微软创建了许多自定义事件处理规格，这些规格（当然）只能在它的平台上运行。这可以在[http://msdn.microsoft.com/en-us/library/ie/ms533051(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/ie/ms533051(v=vs.85).aspx)找到。
- en: Mozilla events
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 火狐事件
- en: Mozilla has its own specification, and it be seen at [https://developer.mozilla.org/en/docs/Web/API/Event](https://developer.mozilla.org/en/docs/Web/API/Event).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 火狐有自己的规格，可以在[https://developer.mozilla.org/en/docs/Web/API/Event](https://developer.mozilla.org/en/docs/Web/API/Event)找到。
- en: The publisher/subscriber
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者/订阅者
- en: Events are yet another solution to communicate when asynchronous callbacks finish
    execution. An object can become emitter and publish events that other objects
    can listen to. This is one of the finest examples of the observer pattern.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是另一种异步回调执行完成时进行通信的解决方案。一个对象可以成为发射器并发布其他对象可以监听的事件。这是观察者模式的绝佳例子。
- en: The nature of this method is similar to "event listener", but much better than
    the latter because we can view the "message center" in order to find out how much
    signal is present and the number of subscribers for each signal, which runs the
    monitoring program.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的本质与“事件监听器”相似，但比后者更好，因为我们可以通过查看“消息中心”来找出有多少信号存在以及每个信号的订阅者数量，从而运行监控程序。
- en: A brief account of the observer pattern
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式的简要描述
- en: The observer provides very loose coupling between objects. This provides the
    ability to broadcast changes to those who are listening to it. This broadcast
    may be for the single observer or a group of observers who are waiting to listen.
    The subject maintains a list of observers to whom it has to broadcast the updates.
    The subject also provides an interface for objects to register themselves. If
    they are not in the list, the subject doesn't care who or what is listening to
    it. This is the way how the subject is decoupled from the observers, allowing
    easy replacement of one observer for another observer or even one subject, as
    long as it maintains the same series of events.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者提供了对象之间非常松散的耦合。这提供了向收听它的人广播更改的能力。这种广播可能是针对单个观察者，也可能是一群等待收听的观察者。主题维护一个观察者的列表，以便广播更新。主题还提供了一个接口，供对象注册自己。如果它们不在列表中，主题不在乎谁或什么在听它。这是主题与观察者解耦的方式，允许轻松替换一个观察者另一个观察者，甚至是主题，只要它保持相同的事件序列。
- en: A formal definition of observer
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者的正式定义
- en: 'The following is the definition of observer:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对观察者的定义：
- en: '|   | *Define a one-to-many dependency between objects so that when one object
    changes state, all its dependents are notified and updated automatically.* |  
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|   | *定义对象之间的一对多依赖关系，以便当一个对象改变状态时，所有依赖的对象都会自动通知并更新。* |   |'
- en: '|   | --*Gang of Four* |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|   | --*四人帮* |'
- en: 'The source of this definition is page 20 of *Design Patterns: Elements of Reusable
    Object-Oriented Software*, *Addison-Wesley Professional*.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义来源于*设计模式：可重用对象导向软件的元素*，*Addison-Wesley专业出版社*第20页。
- en: The push and pull model
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拉模型和推模型
- en: When you create a subject/observer relationship, you would want to send information
    to the subject; sometimes, this information can be brief, or sometimes, it can
    be additional information. This can also happen that your observer sends a little
    chunk of information, and in return, your subject queries more information in
    response.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个主题/观察者关系时，你希望向主题发送信息；有时，这些信息可能很简单，或者有时，可能是附加信息。这也可能发生，即你的观察者发送了一小部分信息，作为回应，你的主题查询更多的信息。
- en: When you're sending a lot of information, it's referred to as the **push** model,
    and when the observers query for more information, it's referred to as the **pull**
    model.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发送大量信息时，这被称为**推**模型，而当观察者查询更多信息时，这被称为**拉**模型。
- en: '|   | *The pull model emphasizes the subject''s ignorance of its observers,
    whereas the push model assumes subjects know something about their observers''
    needs. The push model might make observers less reusable because Subject classes
    make assumptions about Observer classes that might not always be true. On the
    other hand, the pull model may be inefficient because Observer classes must ascertain
    what changed without help from the Subject.* |   |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|   | *拉模型强调主题对其观察者的无知，而推模型则假设主题了解其观察者需求的某些方面。推模型可能导致观察者更难以复用，因为主题类对观察者类做出了假设，这些假设可能并不总是正确的。另一方面，拉模型可能因为观察者类必须在没有主题帮助的情况下确定发生了什么变化而不够高效。*
    |   |'
- en: '|   | --*Gang of Four* |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|   | --*四人帮* |'
- en: 'The source of this definition is page 320, *Design Patterns: Elements of Reusable
    Object-Oriented Software*, *Addison-Wesley Professional*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义来源于*设计模式：可重用对象导向软件的元素*，*Addison-Wesley专业出版社*第320页。
- en: The advent of observer/push-pub
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察者/推-发布模式的诞生
- en: 'This observer/push-pub pattern provides a way of thinking on how to maintain
    relationship between different parts of an application. This also gives us an
    idea of what part of our application should be replaced with observers and subjects
    in order to achieve maximum performance and maintainability. Here are some points
    to bear in mind when using this pattern in JavaScript in particular, and for other
    languages in general:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观察者/推送发布模式提供了一种思考如何维持应用程序不同部分之间关系的方式。这也让我们知道我们应用程序的哪个部分应该用观察者和主题来替换，以实现最大性能和可维护性。在使用此模式特别是在
    JavaScript 中时，以及其他语言一般要注意以下几点：
- en: Using this pattern, it can break down an application into smaller, more loosely
    coupled blocks to improve code management and potential for reuse
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种模式，可以将应用程序分解为更小、耦合度更低的部分，以改善代码管理和提高可重用性。
- en: The observer pattern is best when there is a need to maintain consistency between
    related objects, without making classes tightly coupled
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式最适合在需要保持相关对象之间一致性，而不使类紧密耦合的情况下使用。
- en: Due to the dynamic relationship that exists between observers and subjects,
    it provides great flexibility, which may not be as easy to implement when disparate
    parts of our application are tightly coupled
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于观察者和主题之间的动态关系，它提供了极大的灵活性，当应用程序的不同部分紧密耦合时，可能不容易实现。
- en: The drawbacks of observer/push-pub
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察者/推送发布模式的缺点
- en: Since every pattern has its own price, it is the same with this pattern. The
    most common one is due to its loosely coupled nature, it's sometimes hard to maintain
    the states of objects and track the path of information flow, resulting in getting
    irrelevant information to subjects by those who have not subscribed for this information.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个模式都有其代价，这个模式也是如此。最常见的是，由于其松耦合性质，有时难以维护对象的状态和追踪信息流路径，导致未订阅此信息的人员向主题接收不相关信息。
- en: 'The more common drawbacks are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的缺点：
- en: By decoupling publishers from subscribers, it can sometimes become difficult
    to obtain guarantees that particular parts of our application are functioning
    as we may expect
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将发布者与订阅者解耦，有时可能难以获得保证，我们的应用程序的特定部分可能如我们期望的那样运行。
- en: Another drawback of this pattern is that subscribers are unaware of the existence
    of each other and are blind to the cost of switching between publishers
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式的另一个缺点是，订阅者不知道彼此的存在，并且对在发布者之间切换的成本视而不见。
- en: Due to the dynamic relationship between subscribers and publishers, the update
    dependency can be difficult to track
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于订阅者和发布者之间的动态关系，更新依赖关系可能难以追踪。
- en: The promises object
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise 对象
- en: The promises object is the last of the major concepts of asynchronous programming
    model implemented. We will be looking at promise as a design pattern.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 对象是实现异步编程模型的最后一个主要概念。我们将研究 Promise 作为一种设计模式。
- en: Promise is a relatively new concept in JavaScript, but it's been around for
    a long time and has been implemented in other languages.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 是 JavaScript 中相对较新的概念，但它已经存在很长时间，并在其他语言中得到实现。
- en: 'Promise is an abstraction that contains two main properties, which make them
    easier to work with:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 是一个包含两个主要属性的抽象，这使得它们更易于使用：
- en: You can attach more than one callback with a single promise
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为一个 Promise 附加多个回调。
- en: Values and states (errors) get passed along
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值和状态（错误）被传递下去
- en: Due to these properties, a promise makes common asynchronous patterns using
    callback easy
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这些属性，Promise 使使用回调的常见异步模式变得容易。
- en: 'A promise can be defined as:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 Promise 定义为：
- en: '*A promise is an observable token given from one object to another. Promises
    wrap an operation and notify their observers when the operation either succeeds
    or fails.*'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Promise 是由一个对象传递给另一个对象的可观察令牌。Promise 包装了一个操作，并在操作成功或失败时通知它们的观察者。*'
- en: 'The source of this definition is *Design Patterns: Elements of Reusable Object-Oriented
    Software*, *Addison-Wesley Professional*.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此定义的来源是 *设计模式：可重用对象导向软件的元素*，*Addison-Wesley 专业出版社*。
- en: Since the scope of this book revolves around the promise and how it is implemented,
    we will discuss it in greater detail in [Chapter 3](ch03.html "Chapter 3. The
    Promise Paradigm"), *The Promise Paradigm*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的范围围绕 Promise 以及它的实现方式，我们将在[第 3 章](ch03.html "第 3 章．Promise 范式")*Promise
    范式*中详细讨论它。
- en: Summing up – the asynchronous programing model
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结 – 异步编程模型
- en: So far, we have seen how the asynchronous model is implemented in JavaScript.
    This is one core aspect of understanding that JavaScript has its own implementation
    for the asynchronous programming model, and it has employed much of the core concepts
    in the asynchronous programming model.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了JavaScript中异步模型是如何实现的。这是理解JavaScript有自己的异步编程模型实现的一个核心方面，并且它在异步编程模型中使用了大量的核心概念。
- en: The asynchronous mode is very important. In the browser, a very time-consuming
    operation should be performed asynchronously, avoiding the browser unresponsive
    time; the best example is the Ajax operations.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步模式非常重要。在浏览器中，应该异步执行非常耗时的操作，以避免浏览器无响应的时间；最好的例子就是Ajax操作。
- en: On the server side, the asynchronous mode of execution since the environment
    is single threaded. So, if you allow synchronization to perform all http requests,
    server performance will decline sharply and will soon lose responsiveness.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端，由于环境是单线程的，所以执行异步模式。因此，如果你允许同步执行所有的HTTP请求，服务器性能将急剧下降，很快就会失去响应性。
- en: These are simple reasons why implementation on JavaScript is widely accepted
    in modern applications on all ends of needs. Databases such as MongoDB, Node.js
    as Server Side JavaScript, Angular.js, and Express.js as frontend, and logic building
    tools are examples of how heavily JavaScript is implemented throughout the industry.
    Their stack is commonly refer red to as the MEAN stack (MongoDB, Angular.js, Express.js,
    and Node.js)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些都是简单的理由，说明了为什么在现代应用程序的各个方面都广泛接受JavaScript的实现。像MongoDB这样的数据库，Node.js作为服务器端JavaScript，Angular.js和Express.js作为前端，以及逻辑构建工具，都是JavaScript在整个行业中如何被大量实施的一个例子。它们的堆栈通常被称为MEAN堆栈（MongoDB、Angular.js、Express.js和Node.js）。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned what a programming model is and how they are implemented
    in different languages, starting from a simple programming model to the synchronous
    model to the asynchronous model.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了编程模型是什么以及它们在不同语言中是如何实现的，从简单的编程模型到同步模型，再到异步模型。
- en: We also saw how tasks were organized in the memory and how they were served
    according to their turns and priorities, and how programming models decide what
    task is to be served.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了任务是如何在内存中组织的，以及它们是如何根据它们的顺序和优先级来服务的，以及编程模型是如何决定要服务哪个任务的。
- en: We have also seen how the asynchronous programming model works in JavaScript,
    and why it's necessary to learn the dynamics of the asynchronous model to write
    better, maintainable, and robust code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了在JavaScript中异步编程模型是如何工作的，以及为什么学习异步模型的动态对于编写更好的、可维护的、健壮的代码是必要的。
- en: This chapter also explained how the major concepts of JavaScript are implemented
    and their roles from different angles in an application development.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章还解释了JavaScript的主要概念是如何实现的，以及它们在应用程序开发中从不同角度扮演的角色。
- en: We have also seen how callbacks, events, and observer were applied within JavaScript
    and how these core concepts are driving today's application development scenes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到回调、事件和观察者在JavaScript中的应用，以及这些核心概念如何推动当今的应用程序开发场景。
- en: In the next chapter, [Chapter 3](ch03.html "Chapter 3. The Promise Paradigm"),
    *The Promise Paradigm*, we will learn a great deal about promise and how it's
    helping in making applications more robust and scalable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[第3章](ch03.html "第3章 承诺范式")，*承诺范式*，我们将深入学习承诺以及它是如何帮助使应用程序更加健壮和可扩展的。
