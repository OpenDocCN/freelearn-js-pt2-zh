- en: Chapter 3. Understanding JavaScript Build Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：理解JavaScript构建系统
- en: In this chapter, we will learn about JavaScript build systems and their advantages
    for JavaScript performance testing and deployment. We will also incorporate JavaScript
    code testing into our build system using the knowledge we gained about JSLint
    in the last chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习JavaScript构建系统及其对JavaScript性能测试和部署的优势。我们还将利用上一章中关于JSLint的知识，将JavaScript代码测试整合到我们的构建系统中。
- en: 'In short, we are going to cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，本章将涵盖以下内容：
- en: What is a build system?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是构建系统？
- en: Setting up our build system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭建我们的构建系统
- en: Creating a distribution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建分发
- en: What is a build system?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是构建系统？
- en: Typically, a **build system** is an automated process that assists developers
    writing clean optimized code. We may think that such a thing would be standard
    across all programming languages. Now, compiled languages usually have a compiler;
    a **compiler** takes a program written by following a language specification,
    and creates output code compatible with the target machine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**构建系统**是一个自动化过程，它帮助开发者编写干净优化的代码。我们可能会认为这样的事情会在所有编程语言中都是标准的。现在，编译语言通常有一个编译器；**编译器**根据语言规范编写的一个程序，创建与目标机器兼容的输出代码。
- en: Compiling code by example
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过示例编译代码
- en: 'Compilers typically work through a spec when a code file is sent for processing.
    To keep a compiler from crashing from bad code, a compiler is set up with many
    error checkers that stop the compiler beforehand and display an alert, thus blocking
    the compiling process. Now some IDEs allow you to see some of your mistakes before
    attempting to run your code. The following screenshot shows a simple Xcode Swift
    file being checked while editing:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常在处理代码文件时通过一个规格。为了防止编译器因坏代码而崩溃，编译器设置了许多错误检查器，在编译器崩溃之前发出警报，从而阻止编译过程。现在一些IDE允许你在尝试运行代码之前发现一些错误。下面的屏幕截图显示了一个简单的Xcode
    Swift文件在编辑时进行检查的情况：
- en: '![Compiling code by example](img/7296OS_03_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![通过示例编译代码](img/7296OS_03_01.jpg)'
- en: Without getting too technical in iOS development, we can see that, on assigning
    a constant variable in Swift, if I attempt to change the variable as in the preceding
    screenshot, my code flags an error.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在不深入iOS开发的技术细节的情况下，我们可以看到，在Swift中分配常量变量时，如果尝试像前一张截图那样更改变量，我的代码会标志一个错误。
- en: 'Now if I change the `let authors_name` constant to a dynamic `var` variable
    (just like in JavaScript), the error itself corrects, as shown in the following
    screenshot, and removes the error displayed in the IDE:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我将`let authors_name`常量更改为动态的`var`变量（就像在JavaScript中一样），错误本身会纠正，如下面的屏幕截图所示，并在IDE中删除显示的错误：
- en: '![Compiling code by example](img/7296OS_03_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![通过示例编译代码](img/7296OS_03_02.jpg)'
- en: Error-checking in a JavaScript build system
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript构建系统中进行错误检查
- en: In the past, HTML editors for JavaScript and HTML content, such as Dreamweaver,
    have done this since the creation of early web code editors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，像Dreamweaver这样的JavaScript和HTML内容的HTML编辑器，自早期网页代码编辑器创建以来就这样做了。
- en: The difference between what's done in Xcode for a compiled language and what's
    done in a JavaScript IDE is slightly different. With a compiled language, an error
    must be fixed before a code file can run; this is usually considered as static
    type checking. JavaScript, however, can run with an error, even when overridden
    with a `try-catch` block. Simply put, as stated in [Chapter 2](ch02.html "Chapter 2. Increasing
    Code Performance with JSLint"), *Increasing Code Performance with JSLint*, JavaScript
    is an interpreted language, and the *only* language that is really tested for
    errors at run time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中为编译语言所做的与在JavaScript IDE中所做的略有不同。对于编译语言，必须修复错误才能运行代码文件；这通常被认为是静态类型检查。然而，JavaScript即使出错，也可以运行，甚至可以用`try-catch`块覆盖。简单地说，正如[第2章](ch02.html
    "第2章：使用JSLint提高代码性能")《使用JSLint提高代码性能》中所述，JavaScript是一种解释型语言，是唯一真正在运行时测试错误的语言。
- en: With that in mind, how do editors such as Dreamweaver, WebStorm, or Visual Studio
    check for errors then? Well, if you remember in [Chapter 2](ch02.html "Chapter 2. Increasing
    Code Performance with JSLint"), *Increasing Code Performance with JSLint*, we
    saw how linting tools provide feedback on potential or verifiable bugs in JavaScript
    code; this returns a list of errors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，像Dreamweaver、WebStorm或Visual Studio这样的编辑器是如何检查错误的呢？嗯，如果你记得在[第2章](ch02.html
    "第2章：使用JSLint提高代码性能")，*使用JSLint提高代码性能*，我们看到了如何通过linting工具提供有关JavaScript代码中潜在或可验证错误的反馈；这返回了一个错误列表。
- en: With an IDE, the editor is coded keeping this in mind and takes each error to
    display it with the associated line and column in the JavaScript file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成开发环境（IDE）中，编辑器是按照这个思路编写的，它取每个错误并显示与JavaScript文件中的相关行和列关联的错误。
- en: So, to make a build system, we will need to incorporate this sort of error checking
    just like using [http://jslint.com/](http://jslint.com/) but in a more automated
    fashion. This allows lightweight editors to use the same checking tools that are
    used in more expensive and heavier IDEs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要建立一个构建系统，我们需要像使用[http://jslint.com/](http://jslint.com/)一样加入这种错误检查，但要以更自动化的方式。这使得轻量级编辑器能够使用在更昂贵、更重的集成开发环境（IDE）中使用的相同检查工具。
- en: Adding optimization beyond coding standards
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超出编码标准的优化
- en: Like our Xcode example earlier in the chapter, we want our final output to be
    optimized for our project; to do this, we will add minification to our build system,
    allowing us to keep a developer version or source project to be saved in a directory
    with a distribution in another directory. Simply put, minification allows us to
    compress our JavaScript code causing our web applications to download faster,
    and run more efficiently.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们章节开头提到的Xcode示例一样，我们希望我们的最终输出为我们的项目进行了优化；为此，我们将把最小化添加到我们的构建系统中，允许我们保留一个开发者版本或源项目，保存在一个带有发行版目录的另一个目录中。简单地说，最小化允许我们对JavaScript代码进行压缩，使我们的网络应用程序下载更快，运行更高效。
- en: This can be helpful if we are using source control to maintain our project,
    allowing us to quickly grab a stable distribution that's optimized, but not easily
    debuggable, and debug it with our source directory's files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们使用源代码控制来维护项目时会有帮助，它允许我们快速获取一个优化过的、但不易调试的稳定发行版，并使用我们源代码目录中的文件进行调试。
- en: Now as JavaScript developers, we can even add other minification build options
    that we may need for the project, such as an image optimizer for our project's
    image directory, or minify our CSS file and add information comment blocks on
    top of our JavaScript files. By compressing our JavaScript, the JavaScript interpreter
    doesn't have to guess the distance in whitespace in our code, which creates more
    efficient and better-performing code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在作为JavaScript开发者，我们甚至可以添加其他可能需要的项目的最小化构建选项，例如为我们的项目图像目录添加一个图像优化器，或者压缩我们的CSS文件，并在我们的JavaScript文件顶部添加信息注释块。通过压缩我们的JavaScript，JavaScript解释器不必猜测我们代码中的空白距离，这产生了更高效、性能更好的代码。
- en: Creating a build system from scratch using Gulp.js
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Gulp.js从头开始创建构建系统
- en: Now that we've introduced build systems and the reason for their use, let's
    go ahead and create a simple build system. Our goal is to create a distribution
    build from our source directory, a copy that's optimized and ready for production.
    We will also integrate JSLint, as we learned from the last chapter, to check our
    code as we create builds for any potential issues that might have been missed
    during development.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了构建系统及其使用原因，让我们创建一个简单的构建系统。我们的目标是创建一个从源目录生成的发行版构建，一个优化后且适用于生产的副本。我们还将整合JSLint，正如我们从上一章学到的，以便在我们创建构建时检查我们的代码，以发现开发过程中可能遗漏的任何潜在问题。
- en: In this chapter, we are going create a build system to test our JavaScript project.
    We will also incorporate minification into our build system, and copy files to
    our build directory. So when we are ready to deploy, our code base is already
    set to be deployed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个用于测试我们的JavaScript项目的构建系统。我们还将把最小化整合到我们的构建系统中，并将文件复制到我们的构建目录。所以当我们准备部署时，我们的代码库已经准备好部署了。
- en: Before setting off on this project, we will need to understand a few technologies
    specific to JavaScript, particularly the build system that we will want to take
    into account; we will especially deal with technologies such as Node.js, NPM,
    Grunt, and Gulp. If you have only heard about these before, or maybe have tinkered
    with some of these and never really got further than that, don't worry; we will
    go over each of these one-by-one and understand their advantages and disadvantages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个项目之前，我们需要了解一些与JavaScript相关的特定技术，特别是我们想要考虑的构建系统；我们将特别处理如Node.js、NPM、Grunt和Gulp等技术。如果你只是听说过这些，或者可能曾经摆弄过其中的一些但从未深入了解过，不用担心；我们将逐一了解这些技术，并了解它们的优缺点。
- en: Node.js
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Node.js
- en: '**Node.js** is a JavaScript interpreter for your operating system. For JavaScript
    developers, the concept of JavaScript code working as a backend code base like
    Java or C# may seem odd, but has been shown to work in new creative ways. For
    example, the community of Node.js developers has created plugins to create custom-built,
    JavaScript-based applications for the desktop.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js** 是一个为你的操作系统设计的JavaScript解释器。对于JavaScript开发者来说，JavaScript代码像Java或C#这样的后端代码基础这样的概念可能看起来很奇怪，但已经证明以新的创造性的方式工作。例如，Node.js开发者社区创建了插件，以创建基于JavaScript的定制桌面应用程序。'
- en: This puts JavaScript in a very new place. When traditional application developers
    complain about JavaScript, one of the main complaints is that JavaScript cannot
    read or write files to a hard drive, which is usually a very basic feature for
    a programming language. Node.js allows custom objects to interact with the operating
    system. These include objects such as `FS` or `FileSystem` that allow for reading
    and writing files and work pretty much like a console in a web browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得JavaScript处于一个全新的位置。当传统的应用程序开发人员抱怨JavaScript时，主要抱怨之一就是JavaScript无法读取或写入硬盘文件，这对于编程语言来说通常是一个非常基本的功能。Node.js允许自定义对象与操作系统交互。这些对象包括`FS`或`FileSystem`等，可以读写文件，并且基本上类似于Web浏览器中的控制台。
- en: 'For this project, we won''t discuss Node.js in depth (that''s another book),
    but we will be installing Node.js into our OS so that we can run and test our
    build system. So let''s download Node.js and get started. First, navigate to [http://nodejs.org/](http://nodejs.org/)
    and click the green **INSTALL** button, as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们不会深入讨论Node.js（那是另一本书的内容），但我们将在我们的操作系统中安装Node.js，这样我们就可以运行和测试我们的构建系统。所以让我们下载Node.js并开始吧。首先，导航到[http://nodejs.org/](http://nodejs.org/)，并点击下面的绿色**INSTALL**按钮，如图所示：
- en: '![Node.js](img/7296OS_03_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js](img/7296OS_03_03.jpg)'
- en: 'Node.js is cross-platform, and so most of these instructions should work for
    you. I''ll be using a Mac with OS X for this installation''s introduction. For
    most platforms, Node.js will come with either a `.pkg` or `.exe` install wizard,
    as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是跨平台的，所以这些指令大部分对你应该是有用的。我将使用一个带有OS X的Mac来进行这个安装介绍。对于大多数平台，Node.js将带有`.pkg`或`.exe`安装向导，如图所示：
- en: '![Node.js](img/7296OS_03_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js](img/7296OS_03_04.jpg)'
- en: From here, follow the wizard, accept the user licenses and install for all users.
    By installing for all users, we allow Node.js to have full system access which
    we do want, since some plugins for Node.js may require certain features that are
    not accessible by a single user or non-administrator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，跟随向导操作，接受用户许可并安装给所有用户。通过为所有用户安装，我们允许Node.js拥有完整的系统访问权限，这是我们所希望的，因为Node.js的一些插件可能需要某些单个用户或非管理员无法访问的功能。
- en: 'When you''ve finished installing Node.js, keep in mind the paths set by the
    installer; if you want to remove Node.js in future, check out the following screenshot
    to see where the installer has added Node.js:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成Node.js的安装后，请注意安装程序设置的路径；如果你将来想要删除Node.js，请查看以下屏幕截图，以查看安装程序将Node.js添加到了哪里：
- en: '![Node.js](img/7296OS_03_05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js](img/7296OS_03_05.jpg)'
- en: Testing a Node.js installation
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试Node.js安装
- en: To ensure that Node.js is properly installed, we want to check two things. The
    first thing is to check whether Node.js works in the Terminal. To validate the
    installation, we will check the current version of Node.js that's installed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保Node.js被正确安装，我们希望检查两件事。第一件事是检查Node.js在终端中是否可以正常工作。为了验证安装，我们将检查已安装的Node.js的当前版本。
- en: 'First, let''s open Terminal (or Command Prompt, if using Windows), and insert
    the `node --version` command as shown in the following screenshot, and press *Enter*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开终端（或者如果使用Windows的话，打开命令提示符），并插入如下截图所示的`node --version`命令，然后按*Enter*键：
- en: '![Testing a Node.js installation](img/7296OS_03_06.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![测试 Node.js 安装](img/7296OS_03_06.jpg)'
- en: 'If successful, we should see the version number (in my case, it''s `v0.10.32`;
    your version may be greater than my version number when attempting this) as shown
    on the next line in the Terminal in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，我们应该在终端的下一行看到版本号（在我的情况下，它是`v0.10.32`；当你尝试这个时，你的版本可能比我版本号还要新），如下面的截图所示：
- en: '![Testing a Node.js installation](img/7296OS_03_07.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![测试 Node.js 安装](img/7296OS_03_07.jpg)'
- en: Testing Node Package Manager's installation
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试 Node 包管理器的安装
- en: Great job! Now, the next thing to be checked for a full installation is whether
    Node Package Manager is installed as well. Before testing, let me explain what
    Node Package Manager is, especially to those who might not know what it is and
    why we need it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，要检查完整安装的下一个事项是Node包管理器是否也已安装。在测试之前，让我解释一下Node包管理器是什么，特别是对于那些可能不知道它是什么以及我们为什么需要它的那些人。
- en: About Node Package Manager
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于 Node 包管理器
- en: The **Node Package Manager** (**NPM**) connects to the NPM registry, an online
    repository of software libraries for Node.js. By using NPM, we can quickly set
    up a JavaScript build system and install libraries for our HTML-based JavaScript
    projects automatically, which allows us to ensure that our JavaScript libraries
    are up-to-date with the latest version of each library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node 包管理器**（NPM）连接到NPM注册表，这是Node.js的在线软件库存储库。通过使用NPM，我们可以快速设置JavaScript构建系统，并自动为我们的基于HTML的JavaScript项目安装库，这使我们能够确保我们的JavaScript库与每个库的最新版本保持更新。'
- en: 'NPM also has a website you can use to research various JavaScript libraries
    at [https://www.npmjs.org](https://www.npmjs.org). This is also shown in the following
    screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NPM还有一个网站，你可以使用它在[https://www.npmjs.org](https://www.npmjs.org)上研究各种JavaScript库。下面的截图也显示了这一点：
- en: '![About Node Package Manager](img/7296OS_03_08.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![关于 Node 包管理器](img/7296OS_03_08.jpg)'
- en: Checking NPM installation in the Terminal
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在终端中检查NPM安装
- en: 'Now, to check our installation of NPM, we are going to call NPM directly, which
    should return a `help` directory for the NPM module installed. To do this, simply
    open the Terminal and insert the `npm` command. Now, we should see our Terminal
    window populating with a bunch of NPM help documentation and sample terminal commands,
    as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检查我们的NPM安装，我们将直接调用NPM，这应该会返回已安装的NPM模块的`help`目录。要做到这一点，只需打开终端并插入`npm`命令。现在，我们应该看到我们的终端窗口充满了NPM帮助文档和示例终端命令，如下面的截图所示：
- en: '![Checking NPM installation in the Terminal](img/7296OS_03_09.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![在终端中检查 NPM 安装](img/7296OS_03_09.jpg)'
- en: The basics of using NPM
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 NPM 的基础知识
- en: Using NPM is a pretty easy process to learn. The first thing that we need to
    do before setting up NPM for a project is to create a project root directory;
    I'm going to mark this as `npm_01` for the first project, but you can name your
    root as whatever you would like. Now, we are going to open Terminal and change
    our `bash` directory to match the path to the directory I created.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 学习使用NPM是一个相对简单的过程。在我们为项目设置NPM之前，我们需要做的第一件事是创建一个项目根目录；我将这个作为第一个项目的`npm_01`，但你可以给你的根目录命名你喜欢的任何名字。现在，我们将打开终端并将我们的`bash`目录更改为我创建的目录的路径。
- en: 'To change your working directory in the Terminal, the command is `Change Directory`
    or `cd`. Using `cd` is pretty easy; simply type the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中更改工作目录的命令是`Change Directory`或`cd`。使用`cd`非常简单；只需输入以下命令：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A few things to note here are that the Terminal always points to your user home
    directory on Mac and Linux, and the tilda key (or *~*) is a shortcut to point
    to your path. For example, if your folder is in your documents directory under
    your username, an example path using cd would be `cd ~/Documents/[your_project_path]`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，终端在Mac和Linux上总是指向你的用户主目录，并且`~`键是一个快速指向你路径的快捷方式。例如，如果你的文件夹在你的用户名下的文档目录中，使用cd的示例路径可能是`cd
    ~/Documents/[你的项目路径]`。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the Terminal is getting cluttered with information, you can use the "clear"
    command to clean your terminal's contents, without changing your directory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果终端信息过于杂乱，你可以使用“clear”命令来清除终端内容，而不改变你的目录。
- en: Installing jQuery with NPM
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 NPM 安装 jQuery
- en: A common JavaScript library is jQuery, a very popular library on NPM. We can
    even check out its repository information on [npmjs.org](http://npmjs.org), found
    at [https://www.npmjs.org/package/jquery](https://www.npmjs.org/package/jquery).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的 JavaScript 库是 jQuery，NPM 上一个非常受欢迎的库。我们甚至可以在 [npmjs.org](http://npmjs.org)
    上查看它的仓库信息，地址为 [https://www.npmjs.org/package/jquery](https://www.npmjs.org/package/jquery)。
- en: '![Installing jQuery with NPM](img/7296OS_03_10.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用 NPM 安装 jQuery](img/7296OS_03_10.jpg)'
- en: If we look at this page, we can see a command for our terminal, `npm install
    jQuery`. So, let's type that into our terminal and press *Enter* to see what happens.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这个页面，可以看到一个命令，用于我们的终端，`npm install jQuery`。那么，让我们在终端中输入这个命令，并按*Enter*键看看会发生什么。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you're a Mac or Linux user, you can drag-and-drop a folder into the Terminal,
    and it will auto-write the path of your folder for you after you type the `cd`
    command.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 Mac 或 Linux 用户，你可以将一个文件夹拖放到终端中，它会在你输入`cd`命令后自动为你写入该文件夹的路径。
- en: 'In the Terminal, it looks like some files were downloaded, as indicated in
    the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，看起来有些文件已经被下载了，如下面的截图所示：
- en: '![Installing jQuery with NPM](img/7296OS_03_11.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用 NPM 安装 jQuery](img/7296OS_03_11.jpg)'
- en: 'Now, if we open our project directory, we can see that a new folder named `node_modules`
    has been created. Inside this folder, another folder is created named `jquery`.
    The contents of the `jquery` folder are shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开我们的项目目录，我们可以看到一个新的名为`node_modules`的文件夹已经创建。在这个文件夹中，又创建了一个名为`jquery`的文件夹。下面是`jquery`文件夹内容的截图：
- en: '![Installing jQuery with NPM](img/7296OS_03_12.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用 NPM 安装 jQuery](img/7296OS_03_12.jpg)'
- en: Inside the `jquery` folder, there are some interesting files. We have a `README.md`
    (`.md` is short for markdown, a type of text format) file explaining jQuery.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jquery`文件夹中，有一些有趣的文件。我们有一个`README.md`（`.md`是 markdown 的缩写，一种文本格式）文件，解释了 jQuery。
- en: The folder has two JSON files, one called `bower.json` and another called `package.json`.
    The `package.json` file handles the NPM package information while the `bower.json`
    file handles any dependent packages and notifies NPM to include those as well
    on installation request.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹中有两个 JSON 文件，一个叫做`bower.json`，另一个叫做`package.json`。`package.json`文件处理 NPM
    包的信息，而`bower.json`文件处理任何依赖包，并在安装请求时通知 NPM 也包含这些依赖包。
- en: If you're wondering what the `bower.json` file does, it's essentially another
    way to update source code from a repository. Like the NPM registry, the `bower.json`
    file uses its own; the difference is that it can use a JSON file in a project
    and update based on the setting stored in the JSON file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道`bower.json`文件的作用，它本质上是一种从仓库更新源代码的另一种方式。与 NPM 注册表类似，`bower.json`文件使用它自己的注册表；不同的是，它可以使用项目中的
    JSON 文件，并根据存储在 JSON 文件中的设置进行更新。
- en: Lastly, the most important two folders are the `src` folder (or source folder)
    and the `dist` folder (or distribution folder). This file structure is a common
    convention for NPM, where the source of a project with debug information is saved
    in the `src` folder, while the final tested output lives in the `dist` folder.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最重要的两个文件夹是`src`文件夹（或源文件夹）和`dist`文件夹（或分发文件夹）。这种文件结构是 NPM 的一种常见约定，其中项目的源代码和调试信息保存在`src`文件夹中，而最终的测试输出保存在`dist`文件夹中。
- en: Since we aren't debugging the source for jQuery, all we really need to worry
    about is the `dist` folder, where we can find the `jquery.js` file and the `jquery.min.js`
    file—the same library files typically used in jQuery projects. It's important
    to know this for our build systems as we will want to copy those into the distribution
    folder for our build system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不调试 jQuery 的源代码，我们真正需要担心的是`dist`文件夹，我们可以在其中找到`jquery.js`文件和`jquery.min.js`文件——这些通常在
    jQuery 项目中使用的库文件。了解这一点对于我们的构建系统很重要，因为我们将需要将这些文件复制到我们的构建系统的分发文件夹中。
- en: Setting up our build system
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的构建系统
- en: Now that we have learned the basics of Node.js and NPM, let's actually build
    a build system. We will want to point our Terminal to our project's root directory,
    and then we will want to install our build system (also called Task Runner).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 Node.js 和 NPM 的基础知识，那么让我们实际构建一个构建系统。我们需要将我们的终端指向项目的根目录，然后我们需要安装我们的构建系统（也称为任务运行器）。
- en: About Grunt.js and Gulp.js
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 Grunt.js 和 Gulp.js
- en: 'Node.js build systems fall within two major build system libraries: Grunt and
    Gulp. Grunt is, in many cases, the default build system for Node.js projects.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 构建系统属于两个主要的构建系统库：Grunt 和 Gulp。在很多情况下，Grunt 是 Node.js 项目的默认构建系统。
- en: Grunt Task Runner
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Grunt 任务运行器
- en: 'Grunt was designed originally for automating tasks in JavaScript and, web development
    and due to its availability, many developers have created plugins; you can view
    them in Grunt''s plugin repository shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Grunt是为了自动化JavaScript和Web开发中的任务而设计的，由于它的可用性，许多开发者都创建了插件；您可以在下面屏幕截图中查看Grunt的插件存储库：
- en: '![Grunt Task Runner](img/7296OS_03_13.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Grunt 任务运行器](img/7296OS_03_13.jpg)'
- en: About Gulp
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于Gulp
- en: Gulp is another build system for Node.js; the advantage of using Gulp is that
    it's asynchronous, and typically runs automated tasks much faster than Grunt.
    Since this book is all about performance, we will use Gulp for our build system
    as an example. That doesn't mean that Grunt is bad; it can create built systems
    as well as Gulp.js, but it may not be as fast as Gulp.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp是另一个Node.js的构建系统；使用Gulp的优势在于它是异步的，通常比Grunt更快地运行自动化任务。由于这本书都是关于性能的，我们将用Gulp作为我们的构建系统的示例。这并不意味着Grunt不好；它可以创建与Gulp.js一样的构建系统，但它可能没有Gulp快。
- en: 'Like Grunt, Gulp also has a plugin reference page found at [http://gulpjs.com/plugins/](http://gulpjs.com/plugins/),
    and shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 像Grunt一样，Gulp也有一个插件参考页面，可以在[http://gulpjs.com/plugins/](http://gulpjs.com/plugins/)找到，并在下面的屏幕截图中显示：
- en: '![About Gulp](img/7296OS_03_14.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![关于Gulp](img/7296OS_03_14.jpg)'
- en: Installing Gulp
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装Gulp
- en: 'To install Gulp, we will open our terminal and type the following into our
    prompt:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Gulp，我们将打开我们的终端，并在提示符中输入以下内容：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will install Gulp globally to our Node.js and NPM resource path. If we
    are running a Windows system, `sudo` isn''t in Window''s Shell, so we will need
    to run the Command Prompt as Administrator. Now, if everything is successful,
    we should see a bunch of URL requests for files, and our Terminal should return
    to the prompt shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将全局安装Gulp到我们的Node.js和NPM资源路径。如果我们正在运行Windows系统，`sudo`不在Windows Shell中，因此我们需要以管理员身份运行命令提示符。现在，如果一切顺利，我们应该看到一大堆文件的网络请求，并且我们的终端应该返回到下面屏幕截图中显示的提示符：
- en: '![Installing Gulp](img/7296OS_03_15.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![安装Gulp](img/7296OS_03_15.jpg)'
- en: With our global ("global" meaning installed for all folders in our system) dependencies
    for Gulp installed, we can install our developer dependencies, which allow our
    build system to be more portable when uploading to a source control. Essentially,
    these dependencies need to be in our root project file to enable our build system
    to run in our project directory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们系统的所有文件夹中安装了全局（“全局”意味着安装在系统中的所有文件夹中）的Gulp依赖之后，我们可以安装我们的开发依赖，这些依赖使得我们的构建系统在上传到源代码控制时更加便携。本质上，这些依赖必须存在于我们项目的根文件中，以使我们的构建系统能够在项目目录中运行。
- en: 'We can do it by typing the following code into our Terminal (again, `sudo`
    for Mac/Linux users and **Run as Administrator** for Windows users):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在终端中输入以下代码来完成此操作（再次说明，对于Mac/Linux用户是`sudo`，对于Windows用户是**以管理员身份运行**）：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If successful, your `bash` prompt should show again, pulling many URL sources
    and installing them to your project''s `node_modules` directory under `gulp` as
    shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，你的`bash`提示符应该再次出现，拉取许多URL源并安装到你的项目`gulp`下的`node_modules`目录中，如下面的屏幕截图所示：
- en: '![Installing Gulp](img/7296OS_03_16.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![安装Gulp](img/7296OS_03_16.jpg)'
- en: Creating a gulpfile
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个gulpfile
- en: A `gulpfile` is a file that Gulp checks for to run a list of tasks at the root
    of our project directory. To create one, we will create a simple JavaScript file
    called `gulpfile.js` (note the case of the filename). Inside the file we are going
    to reference Gulp as a variable and create a default task, called `Default`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulpfile`是Gulp检查以在项目目录的根目录运行一系列任务的文件。要创建一个，我们将创建一个简单的名为`gulpfile.js`的JavaScript文件（注意文件名的大小写）。在文件中，我们将将Gulp作为一个变量引用，并创建一个名为`Default`的默认任务。'
- en: 'This is the main task we need to run for every `gulpfile.js`; inside it, we
    can include other tasks or output log message, just like in a web browser. As
    a simple code example for a Gulp task is shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们每个`gulpfile.js`都需要运行的主要任务；在内部，我们可以包含其他任务或输出日志消息，就像在网页浏览器中一样。作为一个简单的Gulp任务的代码示例，如下面的屏幕截图所示：
- en: '![Creating a gulpfile](img/7296OS_03_17.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个gulpfile](img/7296OS_03_17.jpg)'
- en: Running a Gulp project
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行一个Gulp项目
- en: 'Running a Gulp project is easy. In your project''s root directory, type `gulp`
    in the Terminal and press *Enter*. You should see the output in your terminal
    as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个Gulp项目很简单。在你的项目根目录中，在终端中输入`gulp`并按*Enter*。你应该看到你的终端中的输出，如下面的屏幕截图所示：
- en: '![Running a Gulp project](img/7296OS_03_18.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![运行一个Gulp项目](img/7296OS_03_18.jpg)'
- en: That's nice. If we look at the fourth line of our Terminal's output, we should
    see our output message as **Default task ran**. Good job! This is the same `console.log`
    message we created for our `Default` task in our `gulpfile.js`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好。如果我们查看终端输出的第四行，我们应该会看到我们的输出信息为**默认任务运行**。干得好！这和我们为`Default`任务在`gulpfile.js`中创建的`console.log`信息是一样的。
- en: So you may ask, How did all this help optimize the JavaScript code? Well, if
    you remember [Chapter 2](ch02.html "Chapter 2. Increasing Code Performance with
    JSLint"), *Increasing Code Performance with JSLint*, we used JSLint to review
    JavaScript code, make improvements, and optimize files. What if we could run that
    test tool, while copying files and minifying (or even testing minified code) through
    JSLint? Well, we can, and that's the point of using build systems.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能会问，这一切都是如何帮助优化JavaScript代码的？嗯，如果你记得[第二章](ch02.html "第2章 使用JSLint提高代码性能")，*使用JSLint提高代码性能*，我们使用JSLint来审查JavaScript代码，进行改进，并优化文件。如果我们能在复制文件并通过JSLint进行压缩（甚至测试压缩后的代码）的同时运行这个测试工具呢？嗯，我们可以，这就是使用构建系统的目的。
- en: With a build system, we are improving it and optimizing our code before modifying
    it, even before it is deployed out as a web application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建系统，我们在修改代码之前会对其进行改进和优化，甚至在我们将其部署为网络应用程序之前。
- en: Integrating JSLint into Gulp
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将JSLint集成到Gulp中
- en: 'Earlier, we talked about Gulp''s plugin page; well one of those plugins is
    a JSLint plugin, and the installation process is pretty easy. First, check out
    the JSLint plugin page found at [https://www.npmjs.org/package/gulp-jslint/](https://www.npmjs.org/package/gulp-jslint/),
    and as shown in the following figure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们谈到了Gulp的插件页面；其中一个插件就是JSLint插件，安装过程相当简单。首先，查看位于[https://www.npmjs.org/package/gulp-jslint/](https://www.npmjs.org/package/gulp-jslint/)的JSLint插件页面，如下所示：
- en: '![Integrating JSLint into Gulp](img/7296OS_03_19.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![将JSLint集成到Gulp中](img/7296OS_03_19.jpg)'
- en: 'So, in the same way we installed Gulp, we will run the `npm` command shown
    on the page, but will include `sudo` for administrator permissions and the `-g`
    command. This is a global flag to install JSLint to the full system, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，以安装Gulp同样的方式，我们将运行页面上的`npm`命令，但会包括`sudo`以获取管理员权限和`-g`命令。这是一个全局标志，以将JSLint安装到整个系统，如下所示：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will install the developer dependencies for our project, so again
    we will point to our root project directory in the Terminal and then type our
    `npm` command but with the `-save-dev` flag this time, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装我们项目的开发依赖，所以我们再次在终端中指向我们项目的根目录，然后输入我们的`npm`命令，但这次加上`-save-dev`标志，如下所示：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To verify the installation, we can check the `node_modules` folder in our project
    directory, and see the `gulp-jslint` folder, as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证安装，我们可以检查我们项目目录中的`node_modules`文件夹，并看到`gulp-jslint`文件夹，如下所示：
- en: '![Integrating JSLint into Gulp](img/7296OS_03_20.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![将JSLint集成到Gulp中](img/7296OS_03_20.jpg)'
- en: Testing our example file
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的示例文件
- en: 'Now, our build system needs a source file, and I''ve written an example while
    adding it to a new `src` project directory created in Finder. I haven''t tested
    this yet, and it''s shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的构建系统需要一个源文件，我在添加到新创建的`src`项目目录时编写了一个示例。我还没有测试这个，如下所示：
- en: '![Testing our example file](img/7296OS_03_21.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的示例文件](img/7296OS_03_21.jpg)'
- en: 'So we have a simple Toddler JavaScript class, and it displays messages based
    on the prototype functions called; it''s pretty basic and it does have some intended
    errors, so let''s find these. Let''s go back to `gulpfile.js`; I''ve updated it
    with some JSLint examples using the same common options enabled by us and mentioned
    in [Chapter 2](ch02.html "Chapter 2. Increasing Code Performance with JSLint"),
    *Increasing Code Performance with JSLint*. Take a look at the updated `gulpfile.js`
    file, shown in the next screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的儿童JavaScript类，它根据调用原型函数来显示消息；相当基础，并且确实有一些预期的错误，让我们找出来。让我们回到`gulpfile.js`；我用一些JSLint示例对其进行了更新，使用了我们在[第二章](ch02.html
    "第2章 使用JSLint提高代码性能")中提到的相同的常用选项。看看下面更新的`gulpfile.js`文件：
- en: '![Testing our example file](img/7296OS_03_22.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的示例文件](img/7296OS_03_22.jpg)'
- en: On lines 6 and 7, we can see conventions such as, `gulp.src()` and `pipe()`.
    The `src` function is a Gulp-specific function that sets the source file or files
    using a JavaScript array; the `pipe` function, which is also Gulp-related, allows
    us to create a list of tasks that will take the source files from `gulp.src()`
    and *pipe* them through our build system. Lines 5 to 19 here show a new `gulp.task`
    called JSLint. If we look at lines 9 to 12, we can see the same options used from
    [JSLint.com](http://JSLint.com); the option names can be found under JSLint Directives
    at the bottom of the page when we select different options on the page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行和第7行，我们可以看到诸如`gulp.src()`和`pipe()`这样的约定。`src`函数是一个Gulp特定的函数，它使用JavaScript数组设置源文件或文件；`pipe`函数，也是与Gulp相关的，允许我们创建一个任务列表，该列表将源文件从`gulp.src()`通过我们的构建系统进行*管道*。这里的第5行到第19行展示了一个新的`gulp.task`，称为JSLint。如果我们看第9行到第12行，我们可以看到与[JSLint.com](http://JSLint.com)相同的选项；选项名称可以在页面上选择不同选项时页面的底部找到JSLint指令。
- en: On line 22, we added an array after our *default* task, adding our *JSLint*
    task name into an array. We can add multiple tasks here, but for now we just need
    the lint task. Now let's run the script and check our terminal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第22行，我们在我们的*默认*任务之后添加了一个数组，将我们的*JSLint*任务名称添加到数组中。我们可以在這裡添加多个任务，但现在我们只需要lint任务。现在让我们运行脚本并检查我们的终端。
- en: '![Testing our example file](img/7296OS_03_23.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的示例文件](img/7296OS_03_23.jpg)'
- en: Excellent! The red lines shown in the terminal report errors with the script
    that gives us our lint feedback in the terminal and, as we can see, we forgot
    some common things such as using *use strict*, missing semicolons, and so on.
    So we can see how we can automate the process of testing our code during a build
    using Node.js and Gulp.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！终端中显示的红色线条报告了脚本中的错误，给我们提供了终端中的lint反馈，正如我们所看到的，我们忘记了一些常见的事情，比如使用*use strict*，漏掉分号等等。因此，我们可以看到如何使用Node.js和Gulp在构建过程中自动化测试我们的代码。
- en: Creating a distribution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建分发
- en: Saving the best part for last, let's have Gulp handle minifying the JavaScript
    source code, copying the output to the `dist` folder, and then linting the output
    for testing. I've modified the `ExampleScript.js` file to fix most of the issues
    found earlier.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 把最好的部分留到最后，让Gulp处理JavaScript源代码的压缩，将输出复制到`dist`文件夹，然后对输出进行测试*校验*。我已经修改了`ExampleScript.js`文件，修复了之前发现的大部分问题。
- en: 'Now we need to download a minification tool for Gulp called **Uglify**, available
    at [https://www.npmjs.org/package/gulp-uglify](https://www.npmjs.org/package/gulp-uglify).
    It''s a common minifier for JavaScript for Gulp-based projects; its installation
    is easy and follows the same procedure used for installing Gulp itself and JSlint
    for Gulp. The following command is used for installing the tool:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为Gulp下载一个名为**Uglify**的压缩工具，可在[https://www.npmjs.org/package/gulp-uglify](https://www.npmjs.org/package/gulp-uglify)找到。这是Gulp项目常用的JavaScript压缩器；它的安装很容易，遵循与安装Gulp本身和为Gulp安装JSLint相同的程序。安装此工具的以下命令：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now I''ve updated our `gulpfile.js` with a new minify task and added it to
    the array as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经用一个新的压缩任务更新了我们的`gulpfile.js`，并将其添加到数组中，如下面的屏幕截图所示：
- en: '![Creating a distribution](img/7296OS_03_24.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![创建分发](img/7296OS_03_24.jpg)'
- en: Now, run Gulp in the Terminal window and notice the output (shown in the next
    screenshot); in the finder folder, you'll see a brand-new minified file in the
    `dist` directory of your root project folder, while retaining your developer source
    and getting performance linting at the same time!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在终端窗口中运行Gulp，注意输出（如下面的屏幕截图所示）；在finder文件夹中，你将在你的根项目文件夹的`dist`目录中看到一个全新的压缩文件，同时保留你的开发者源文件，并获得性能linting！
- en: '![Creating a distribution](img/7296OS_03_25.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![创建分发](img/7296OS_03_25.jpg)'
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to create a simple JavaScript build system using
    Node.js with Gulp. We also explored other plugins and checked out Grunt Task Runner,
    which works similar to Gulp but contains many more plugins for your work.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Node.js和Gulp创建一个简单的JavaScript构建系统。我们还探索了其他插件，并查看了Grunt任务运行器，它与Gulp类似，但包含更多用于你工作的插件。
- en: Build systems help your performance greatly without much effort; keep in mind
    that gulp files can be reused for other projects, and so experiment and find out
    what works best for your projects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统能极大地提高你的性能，而不需要太多的努力；请记住gulp文件可以被重新用于其他项目，因此尝试并找出最适合你项目的工具。
- en: In the next chapter, we will learn tips and tricks on how to use Chrome's **Developer
    tools** option to better optimize our web application code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用Chrome的**开发者工具**选项来更好地优化我们的Web应用程序代码的技巧和窍门。
