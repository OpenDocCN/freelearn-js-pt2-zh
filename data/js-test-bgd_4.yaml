- en: Chapter 4. Planning to Test
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。测试计划
- en: Welcome to the fourth chapter. Before we move into a more formal testing process,
    we must first understand what testing is about. In this chapter, we will learn
    how to make a plan for testing your JavaScript program. We will learn about the
    various testing concepts that you should know, after which I will present to you
    a brief guideline which will be used as a basis for the next chapter.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 欢迎来到第四章。在我们进入更正式的测试过程之前，我们首先必须了解测试是关于什么的。在本章中，我们将学习如何为你的JavaScript程序制定测试计划。我们将学习你应该知道的各种测试概念，之后我会向你提供一个简短的指南，它将作为下一章的基础。
- en: 'Before we move into the various testing concepts, we will first need to establish
    a brief understanding of the following issues:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入各种测试概念之前，我们首先需要建立对以下问题的简要理解：
- en: Do we really need a test plan in order to carry out testing?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们真的需要一个测试计划来进行测试吗？
- en: When should we develop the test plan for our code?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该什么时候为我们的代码开发测试计划？
- en: How much testing do we need for our program?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的程序需要多少测试？
- en: 'After covering the above issues, we will learn about the following testing
    concepts and ideas:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖上述问题之后，我们将学习以下测试概念和想法：
- en: Black box testing, white box testing, and related concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑盒测试、白盒测试及相关概念
- en: Boundary conditions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界条件
- en: Unit testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Web page functional testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页功能测试
- en: Integration testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Non-functional testing, such as performance testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非功能性测试，如性能测试
- en: Usability testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试
- en: Testing order—which of the above tests do we perform first?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试顺序——我们首先进行上述哪些测试？
- en: Regression testing—which is typically done when we make changes to the code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试——通常在我们更改代码时进行
- en: In order to get a better overview of when and where testing plays its part,
    we will first start with a very brief introduction to the software lifecycle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解测试在何时何地发挥作用，我们首先从软件生命周期的非常简要介绍开始。
- en: A very brief introduction to the software lifecycle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件生命周期的非常简要介绍
- en: Understanding the software lifecycle will help you to develop a deeper insight
    into the software development process and, more importantly, when and where testing
    will play its part.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 了解软件生命周期将帮助你更深入地了解软件开发过程，更重要的是，了解测试将在何时何地进行。
- en: 'In general, the software lifecycle has the following stages:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，软件生命周期有以下阶段：
- en: Analysis
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析
- en: Design
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计
- en: Implementation
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施
- en: Testing
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试
- en: Deployment
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署
- en: Maintenance
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 维护
- en: In the first stage, we generally perform an analysis to understand what the
    needs of the stakeholders are. For instance, if you are carrying out a customized
    project for a customer, you will need to understand the user requirements, system
    requirements, and the business goals. Once you have understood the needs, you
    will need to design the software. Things to do in this stage include drawing data
    flow diagrams, designing the database, and so on. The next stage is the implementation
    stage. We can see this as the actual coding process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，我们通常进行分析以了解干系人的需求。例如，如果你为客户进行定制项目，你需要理解用户需求、系统需求和业务目标。一旦你理解了需求，你需要设计软件。这个阶段需要做的事情包括绘制数据流程图、设计数据库等。下一阶段是实施阶段。我们可以将此视为实际的编码过程。
- en: Next comes testing, which is the main focus of this book. In this chapter, we
    will learn how to plan our test based on various testing concepts. After the testing
    stage, we will deploy the project, and finally we maintain the project. Because
    this is a cycle, we theoretically move back to the analysis stage during or after
    the maintenance stage. This is because a software or program is evolutionary;
    as needs and requirements change, so does our software.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是测试，这是本书的主要关注点。在本章中，我们将学习如何根据各种测试概念来规划我们的测试。在测试阶段之后，我们将部署项目，最后我们维护项目。因为这是一个循环，理论上我们在维护阶段期间或之后会回到分析阶段。这是因为软件或程序是进化的；随着需求和需求的变化，我们的软件也在变化。
- en: Although the terminologies and number of stages may be slightly different from
    what you see in other related content, the process is generally the same. The
    main takeaway here is that testing typically comes after implementation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管术语和阶段可能与你在其他相关内容中看到的有稍许不同，但过程通常是一样的。这里的主要收获是，测试通常在实施之后进行。
- en: The agile method
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷方法
- en: You may have heard about the agile methodology, which includes the agile software
    development methodologies, and of course, agile testing methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过敏捷方法论，它包括敏捷软件开发方法论，当然还有敏捷测试方法。
- en: In general, agile software development and testing methods typically happen
    with the end users or customers in mind. There is often little documentation,
    and a focus on short software development cycles, which typically last for one
    to four weeks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，敏捷软件开发和测试方法通常是以最终用户或客户为目标进行的。通常文档很少，专注于短暂的软件开发周期，通常为一周到四周。
- en: So how does this relate to the software development cycle that you have read
    about in the previous section? In general, testing is not an individual phase
    by itself, but rather is closely integrated with the development process, with
    code being tested from the customer perspective, as early as possible, when code
    becomes stable enough to perform testing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这和你们在上一部分读到的软件开发周期有什么关系呢？总的来说，测试不是一个独立的阶段，而是与开发过程紧密集成，从客户的角度进行代码测试，尽可能早，当代码足够稳定以进行测试时。
- en: The agile method and the software cycle in action
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏捷方法和软件周期在行动
- en: It might be difficult for you to visualize how the previous theories come into
    place. The process of creating the sample code for this book closely mimics the
    software lifecycle and agile methodology. So I thought I'll very briefly share
    with you my experience when I was creating the code samples for this book, based
    on the theories that we have learnt about.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你们很难想象之前的理论是如何应用的。为这本书创建示例代码的过程 closely mimics 软件生命周期和敏捷方法论。所以我打算非常简要地分享一下我根据我们学到的理论为这本书创建代码示例时的经历。
- en: Analysis and design
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析和设计
- en: Technically speaking, the analysis and design stage took place when I was thinking
    about what kind of code samples would meet the objectives of the book. I thought
    that the code should be simple enough to follow, and most importantly should demonstrate
    the various features of JavaScript. The code should set up the stage for code
    testing in the later chapters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来说，分析和设计阶段发生在我思考什么样的代码示例能够满足书籍目标的时候。我认为代码应该足够简单，便于理解，最重要的是能够展示JavaScript的各种特性。代码应该为后续章节的代码测试搭建好舞台。
- en: Implementation and testing
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施和测试
- en: The implementation stage occurred when I was writing the code samples. As I
    created functions for snippets of code, I tested whenever I could, and asked myself
    if the code could demonstrate the use of JavaScript and facilitate testing purposes
    later on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实施阶段发生在我编写代码示例的时候。当我为代码片段创建函数时，我尽可能地进行测试，并问自己代码是否能够展示JavaScript的使用并便于后续的测试目的。
- en: So, what happened here is that I used some form of agile testing as I tested
    as often as I could.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里发生的事情是我在尽可能多地进行测试时使用了一种敏捷测试方法。
- en: Deployment
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: Deployment of the code in the business world typically occurs after the code
    has been transferred to the end user. However, in my case, deployment involved
    sending my code samples to the editors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业世界中，代码的部署通常发生在代码传输给最终用户之后。然而，在我的情况下，部署涉及到将我的代码示例发送给编辑。
- en: Maintenance
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护
- en: The maintenance stage occurred when I fixed bugs discovered by the editors after
    the code was submitted. Despite the best of intentions, code is not always error-free.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 维护阶段发生在我提交代码后，编辑发现并修复了bug的时候。尽管有意愿，但代码并不总是无懈可击的。
- en: Do you need a test plan to be able to test?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要一个测试计划才能进行测试吗？
- en: You will most likely require a test plan in order to carry out testing. This
    is because a plan helps you keep a clear objective on what to test. It also helps
    you to figure out what kind of tests you want to perform on your program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会需要一个测试计划来执行测试。这是因为计划帮助你保持清晰的测试目标。它还帮助你确定你想对你的程序进行什么样的测试。
- en: Most importantly, as you will realize, in order to carry out a thorough test
    you will need to implement various tests, including testing concepts based on
    white box testing and black box testing, web page testing, unit testing, integration
    testing, and so on. A test plan also serves as a record of your test data, bugs,
    test results, and possible solutions for your bugs. This means that in order to
    ensure that you do not miss anything, it is good to have a solid plan as to what
    to test, when to test, and how to test your program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，正如您将意识到的，为了进行彻底的测试，您将需要实施各种测试，包括基于白盒测试和黑盒测试的概念测试，网页测试，单元测试，集成测试等。测试计划还作为测试数据，错误，测试结果以及您程序可能的解决方案的记录。这意味着，为了确保不遗漏任何内容，最好有一个明确的计划，了解要测试什么，何时测试以及如何测试您的程序。
- en: When to develop the test plan
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时制定测试计划
- en: In theory, if you look at the software development cycle, you will see that
    testing comes after implementation. Development of the test plan should take place
    after you have completed implementation (the actual coding process) of the program.
    This is because it is only at this point that you have confirmed what features,
    methods, and modules you have; planning what to test based on what you have already
    done makes good business sense, because you know what to focus on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如果您查看软件开发周期，您会发现测试是在实施之后进行的。测试计划在您完成程序的实际编码过程（实施）之后应该进行。这是因为只有在这个时候，您才确认了您有哪些功能，方法和模块；基于您已经完成的内容来规划要测试的内容是有商业意义的，因为您知道要关注什么。
- en: However, in practice, it is advisable to start planning before the implementation
    process. Depending on your situation, it is certainly possible that you can develop
    a High Level Test Plan (HLTP) or High Level Test Case (HLTC). An HLTP is required
    if you are developing a large and complex system, and is meant to address the
    overall requirements. Other supporting test plans are used to address the details
    of the system. An HLTC is somewhat similar to an HLTP, except that it covers test
    cases of the main functionalities that are directly related to the overall requirements
    of the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，建议在实施过程之前开始规划。根据您的具体情况，当然有可能您可以制定一个高级测试计划（HLTP）或高级测试用例（HLTC）。如果您正在开发一个大型复杂的系统，需要HLTP来解决整体需求。其他支持性测试计划用于解决系统的详细内容。高级测试用例（HLTC）与高级测试计划（HLTP）
    somewhat 相似，不同之处在于它覆盖了与系统整体需求直接相关的主要功能测试用例。
- en: Another point that you should take note of is that, in practice, the test plan
    can be broadly categorized into system test and user acceptance test. System test
    covers all forms of functional testing and non-functional testing (which you learn
    about later), whereas user acceptance testing is a phase where testing is carried
    out by end users prior to transferring ownership to them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意的另一个要点是，在实践中，测试计划可以广泛地分为系统测试和用户验收测试。系统测试涵盖所有形式的的功能测试和非功能测试（您稍后了解），而用户验收测试是一个阶段，在这个阶段，测试是由最终用户在移交所有权之前进行的。
- en: How much testing is required?
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要进行多少测试？
- en: You might be anxious to determine what you need to test and what you do not.
    Although there are many different arguments as to how much testing is required,
    I personally believe the aspects of your program listed in the following sections
    should define the scope of your test plan.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能急于确定需要测试什么以及不需要测试什么。关于需要进行多少测试有很多不同的观点，但我个人认为，您程序中列出的以下部分内容应该定义您的测试计划范围。
- en: What is the code intended to do?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码意图做什么？
- en: Firstly, you need to understand what the code is intended to do. For instance,
    the business requirements for our code in the previous chapters is to calculate
    whether the user can retire on time, based on his inputs, such as his current
    age, the age at which he wants to retire, his current spending, current salary,
    and so on. Therefore, we created code that meets the business needs. Once we know
    what our code is intended to do, we can test whether the code satisfies our business
    needs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要了解代码的意图。例如，我们之前章节中代码的业务需求是为了根据用户的输入计算用户是否能够按时退休，这些输入包括他的当前年龄，他希望退休的年龄，他当前的支出，当前的薪水等等。因此，我们创建了满足业务需求的代码。一旦我们知道我们的代码意图做什么，我们就可以测试代码是否满足我们的业务需求。
- en: Testing whether the code satisfies our needs
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试代码是否满足我们的需求
- en: By testing the code to see if it satisfies our business needs, we mean that
    for each input, we need to get the correct output. Going back to our example in
    [Chapter 2](ch02.html "Chapter 2. Ad Hoc Testing and Debugging in JavaScript"),
    *Ad hoc Testing and Debugging in JavaScript* and [Chapter 3](ch03.html "Chapter 3. Syntax
    Validation"), *Syntax Validation*, I would need to ensure that if the total left-over
    income is less than the amount of money that is needed for retirement, the output
    would be "unable to retire", at least in a pseudo sense. What we need to do from
    a testing point of view is to make sure that whenever the mentioned condition
    is true, the output would be "unable to retire".
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试代码以查看它是否满足我们的业务需求，我们的意思是对于每个输入，我们需要得到正确的输出。回到我们在[第2章](ch02.html "第2章 JavaScript中的即兴测试和调试")，*JavaScript中的即兴测试和调试*和[第3章](ch03.html
    "第3章 语法验证")，*语法验证*中提到的例子，如果剩余可支配收入总额小于用于退休的资金量，输出将应该是“无法退休”，至少在字面上是这样的。从测试角度来看，我们需要确保当提到的情况为真时，输出将是“无法退休”。
- en: This can be achieved through a concept called white box testing, where testing
    is carried based on the assumption that the tester knows what the code is about.
    I'll cover the specific details of white box testing and other testing concepts
    in the following chapters. To give you a heads up, some of the testing concepts
    that you will encounter will include unit testing, where you test codes in small
    units, and boundary values testing, where you test for the maximum or minimum
    acceptable values of your code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一种称为白盒测试的概念来实现，其中测试是基于测试者知道代码内容的假设进行的。我将在接下来的章节中详细介绍白盒测试和其他测试概念。为了给你一个提示，你将遇到的一些测试概念包括单元测试，你以小单元测试代码，以及边界值测试，你测试代码的最大或最小可接受值。
- en: The next thing that we will need to consider is how to test for or detect invalid
    actions by users.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要考虑的是如何测试或检测用户无效行为。
- en: Testing for invalid actions by users
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用户无效行为
- en: '"Never trust users" is a phrase which we most commonly hear when developing
    for the Web. This is because there may be malicious users who attempt to "break"
    your applications by giving invalid input. Using the example from previous chapters,
    the input fields for the name can only accept characters and spaces, and the input
    fields for the age and salary can only accept numbers, and not characters. However,
    if someone were to attempt to enter characters into the age or salary field, this
    would be an invalid action.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网页时，我们最常听到的一句话是“永远不要信任用户”。这是因为可能存在恶意的用户，他们试图通过输入无效数据来“破坏”你的应用程序。以前面章节中的例子为例，姓名输入框只能接受字符和空格，而年龄和工资输入框只能接受数字，不能接受字符。然而，如果有人试图将字符输入年龄或工资字段，这将是一种无效行为。
- en: Our program will have to be robust enough to test or check for invalid actions;
    incorrect input will result in incorrect output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序必须足够健壮，能够测试或检查无效行为；错误的输入会导致错误的输出。
- en: A short summary of the above issues
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上述问题的简要总结
- en: By knowing what your code is intended for and what it is supposed to do, and
    understanding the need to detect invalid actions by users, you have already defined
    the scope of your test plan. Your tests should revolve around these criteria.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解你的代码旨在做什么以及它应该做什么，并理解检测用户无效行为的需求，你已经定义了测试计划的范围。你的测试应该围绕这些标准进行。
- en: We can now move on to the various testing concepts that you will be using for
    various aspects of your test, and the building blocks of a test plan—major testing
    concepts and strategies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转向你将在测试的不同方面使用的各种测试概念，以及测试计划的构建块——主要测试概念和策略。
- en: Major testing concepts and strategies
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要测试概念和策略
- en: 'In this section, we will cover different types of testing concepts and strategies.
    I will not attempt to go into too much detail with regards to each concept, but
    rather I need you to get the gist of it and see where each of these concepts is
    coming from. After you have gained familiarity with these concepts, we will move
    on to creating the actual test plan. As a start, I will begin with the business
    strategies that developers follow (whether you are performing a project for an
    external or an internal client), so that you can gain a high-level idea of how
    testing is conducted. In general, no matter what testing concepts, methodology,
    or ideology you subscribe to, you will face the following test cases:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍不同类型的测试概念和策略。我不会试图详细解释每个概念，而是需要你掌握其大意，并了解这些概念的来源。熟悉这些概念后，我们将着手制定实际的测试计划。作为一个开始，我将从开发者遵循的业务策略讲起（无论你为外部或内部客户执行项目），这样你可以对测试的进行有一个高层次的了解。总之，无论你信仰哪种测试概念、方法论或理念，你都将面临以下测试用例：
- en: Functional requirement testing
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性需求测试
- en: Non-functional requirement testing
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非功能性需求测试
- en: Acceptance testing
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试
- en: Functional requirement testing
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性需求测试
- en: 'Functional requirement testing is meant to test the code, a function, or a
    module of a software system. For instance, going back to the code that we wrote
    for the previous chapters, the functional requirements consists of the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性需求测试旨在测试软件系统中的代码、功能或模块。例如，回到我们为前几章编写的代码，功能性需求包括以下内容：
- en: Check user's input for validity.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户输入的有效性。
- en: If the input from step 1 is valid, a new input box will appear on the right-hand
    side of the current input box, after the users mouse moves on to the next input
    box.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果步骤1的输入有效，一个新的输入框将在当前输入框的右侧出现，当用户将鼠标移至下一个输入框时。
- en: Provide the correct calculation output based on the users input. For example,
    if the user requires 1,000,000 dollars for retirement, and he only has 500,000
    dollars by the time he retires, then he will not be able to retire.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户输入提供正确的计算输出。例如，如果用户退休时需要1,000,000美元，而他到退休时只有500,000美元，那么他将无法退休。
- en: 'Examples of functional requirement testing that are covered in this chapter
    are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的功能性需求测试示例如下：
- en: Web page tests
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页测试
- en: Boundary testing
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界测试
- en: Equivalence partitioning
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等价类划分
- en: Non-functional requirement testing
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能性需求测试
- en: Non-functional requirement testing refers to testing requirements that are not
    related to the functionality or specific behaviour of the software. Rather, it
    is a requirement that specifies criteria that can be used to judge the operation
    of a software.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性需求测试指的是与软件的功能或特定行为无关的需求。相反，这是一个指定了可以用来评判软件运行情况的标准的需求。
- en: For example, a functional requirement would be that our software should be able
    to store the values that our users have entered, and a non functional requirement
    is that the database should be updated in real-time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，功能性需求可能是我们的软件应该能够存储用户输入的值，而非功能性需求是数据库应该实时更新。
- en: Another example that is related to our sample code in previous chapters is that
    a functional requirement would be a software, which is able to calculate whether
    our user is able to retire on time, and a non-functional requirement would be
    one in which our user interface should be intuitive. Do you see the difference
    between non functional requirements and functional requirements, now?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与前几章示例代码相关的例子是，功能性需求可能是软件能够计算用户是否能够按时退休，而非功能性需求可能是我们的用户界面应该直观。你现在看到非功能性需求与功能性需求之间的区别了吗？
- en: 'Examples of non functional requirement testing that are covered in this chapter
    are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的非功能性需求测试示例如下：
- en: Performance testing
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Usability testing
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试
- en: Integration testing
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'Other non-functional requirements that you are likely to encounter throughout
    your career as a software developer are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你作为一名软件开发者在职业生涯中可能会遇到的其它非功能性需求如下：
- en: Fast loading of pages
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面快速加载
- en: Search engine optimized web pages
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索引擎优化网页
- en: Documentation of the software that you have created
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建的软件文档
- en: Efficiency of the system
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的效率
- en: Reliability of the software
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件的可靠性
- en: Interoperability of the software code that you have produced. For instance,
    you can code JavaScript across major browsers
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你生产的软件代码的互操作性。例如，你可以在主要浏览器上编写JavaScript
- en: Acceptance testing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收测试
- en: Acceptance testing is usually the final phase of the entire testing process.
    This is often done prior to the final acceptance of the software by the customer.
    Acceptance testing can be further divided into two parts. The software vendor
    performs the acceptance testing first, and then acceptance testing by the end
    users (known as user acceptance testing) is performed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试通常是整个测试过程的最后一个阶段。这通常在软件最终被客户接受之前进行。验收测试可以进一步分为两部分。首先由软件供应商进行验收测试，然后由最终用户（称为用户验收测试）进行验收测试。
- en: Acceptance testing is the time where your customer (or the end-user) will perform
    actual testing (similar to actual usage of the system) on the software that you
    have created. A typical process will include the creation of test cases by the
    end users that reflect business use of the software.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是客户（或最终用户）将在您创建的软件上进行实际测试（类似于实际使用系统）的时间。一个典型的过程将包括最终用户创建反映软件商业使用的测试用例。
- en: If you are using agile testing methods, such test cases are often referred to
    as stories. It depends on how the customer will use them in a business setting.
    And after the user acceptance tests, you will transfer ownership of the product
    to your customers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用敏捷测试方法，这些测试用例通常被称为故事。这取决于客户在商业环境中如何使用它们。在用户验收测试之后，你将把产品的所有权移交给客户。
- en: With the most common testing scenarios covered, we will move on to the specifics
    of the testing concepts. We will start with one of the most commonly-heard testing
    concepts, the black box testing concept.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在最常见的测试场景涵盖之后，我们将进入测试概念的具体内容。我们将从最常听到的测试概念之一，即黑盒测试概念开始。
- en: Black box testing
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑盒测试
- en: Black box testing belongs to the "box approach", where a piece of software is
    regarded as a box and the box contains various functions, methods, classes, and
    so on. Metaphorically, a "black box" typically means that we cannot see what is
    inside the box. This means that we implement the test without knowing the internal
    structure of our program; we take an external perspective of the program, using
    valid and invalid inputs in order to determine if the output is correct.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试属于“箱子方法”，其中一款软件被视为一个箱子，箱子包含各种功能、方法、类等。比喻来说，“黑盒”通常意味着我们无法看到箱子里面有什么。这意味着我们不知道程序的内部结构而实施测试；我们从程序的外部视角出发，使用有效和无效的输入以确定输出是否正确。
- en: Because we have no knowledge about the internal structure and code of the program,
    we can only test the program from a user's point of view. In this case, we might
    try to determine what the major functions are, and then attempt to implement our
    test based on these functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不知道程序的内部结构和代码，所以我们只能从用户的角度来测试程序。在这种情况下，我们可能试图确定主要功能是什么，然后尝试根据这些功能实施我们的测试。
- en: The main advantage of black box testing is that the test results are often unaffiliated,
    because the tester has no knowledge of the code. However, the disadvantage is
    that because the tester has no idea of what the code is about, the tester may
    create tests or perform tests that may be repetitive, or tests that fail to test
    the most important aspects of the software. Or worse, the tester may miss out
    an entire function or method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试的主要优点是，测试结果往往是独立的，因为测试人员不知道代码。然而，缺点是，因为测试人员不知道代码是关于什么的，测试人员可能会创建或执行重复的测试，或者测试未能测试软件最重要的方面。更糟糕的是，测试人员可能会漏掉整个功能或方法。
- en: That is why, in the real world, test cases are prepared in the early phases
    of the development cycle, so that we will not miss out on certain requirements.
    The advantage is that testers will have access to the required test cases, but
    at the same time, the testers need not have full knowledge of the code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在现实世界中，测试用例会在开发周期的早期阶段准备好的原因，这样我们就不会遗漏某些需求。优点是测试人员将能够访问所需的测试用例，但同时，测试人员无需具备完整的代码知识。
- en: Some examples of black box testing include usability testing, boundary testing,
    and beta testing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试的一些例子包括可用性测试、边界测试和公测。
- en: Usability tests
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可用性测试
- en: 'In simple terms, usability testing typically involves testing from the user''s
    point of view, to see if the program we have created is easy to use. The key objective
    here is to observe users using our program, to discover errors or areas of improvement.
    Usability testing generally includes the following aspects:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，可用性测试通常涉及从用户的角度进行测试，以查看我们创建的程序是否易于使用。这里的关键目标是观察用户使用我们的程序，以发现错误或需要改进的地方。可用性测试通常包括以下方面：
- en: '**Performance:** especially in terms of the number of clicks (or actions) that
    a user has to take in orders to complete a particular task, such as signing up
    as a member, or purchasing a product form a website, and so on.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能：**特别是在用户完成特定任务所需的点击（或操作）次数方面，例如注册为会员，或从网站上购买产品等。'
- en: '**Recall:** can users remember how to use the program after not using it for
    a certain period?'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**召回率：**用户在一段时间没有使用程序后，还能记得如何使用程序吗？'
- en: '**Accuracy:** does our program design result in mistakes by the end users?'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准确性：**我们的程序设计是否导致了最终用户的错误？'
- en: '**Feedback:** feedback is certainly one of the most important AJAX-related
    application issues. For instance, after submitting an AJAX form, a user will typically
    wait for some form of feedback, (in the form of visual feedback, such as a success
    message). But imagine this—if there is no form of visual feedback or success message,
    how will the user know if he has submitted the form successfully or unsuccessfully?'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈：**反馈无疑是AJAX相关应用最重要的一个问题之一。例如，在提交AJAX表单后，用户通常会等待某种形式的反馈（以视觉反馈的形式，如成功消息）。但是想象一下，如果没有视觉反馈或成功消息，用户怎么知道他是否成功或失败地提交了表单呢？'
- en: Boundary testing
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界测试
- en: Boundary testing is a form of testing method where the maximum and minimum values
    are tested. Boundary testing sometimes includes the testing of error values and
    typical values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 边界测试是一种测试方法，其中测试最大和最小值。边界测试有时包括测试错误值和典型值。
- en: For instance, in the program in the previous chapters, the maximum number of
    characters we allow for the entry of names are 20 characters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前几章的程序中，我们允许输入名字的最大字符数是20个字符。
- en: Equivalence partitioning
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等价划分
- en: 'Equivalence partition testing is a technique that divides a range of data into
    partitions from which test cases can be derived. For instance, for input boxes
    accepting a users'' age, it should exhibit the following partition:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 等价划分测试是一种将数据范围划分为分区，从而导出测试用例的技术。例如，对于接受用户年龄的输入框，它应该表现出以下分区：
- en: '![Equivalence partitioning](img/0004_04_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![等价划分](img/0004_04_04.jpg)'
- en: Note that only positive values are accepted for our example to read in a users'
    age, as a person's age should technically be positive. Therefore, any negative
    values are unacceptable values.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的示例中，只接受正数值来输入用户的年龄，因为一个人的年龄技术上应该是正数。因此，任何负值都是不可接受的值。
- en: For the range that is less than **-231** and larger than **231-1**, it is asssumed
    that the integers can only hold values between **-231** and **231-1** due to hardware
    and EMCA operator requirements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小于**-231**且大于**231-1**的范围内，由于硬件和EMCA操作符的要求，整数只能持有**-231**到**231-1**之间的值。
- en: Beta testing
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公测
- en: Beta testing has been popularized by the current popular Web 2.0 companies,
    such as Google, where web applications are often released to a limited audience
    other than the core programing team. Beta testing occurs after alpha testing,
    where most of the bugs and faults have been detected and fixed. Beta testing is
    often used as a way to gain feedback from prospective users.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 公测已经被当前流行的Web 2.0公司，如谷歌，普及，在这些公司中，网络应用程序通常会发布给除了核心编程团队之外的其他有限受众。公测在alpha测试之后进行，此时大多数的错误和故障已经被检测并修复。公测通常被用作获取潜在用户反馈的一种方式。
- en: Such a process is commonly seen in open source projects, such as Ubuntu (an
    open source operating system based on Linux), jQuery (a JavaScript library), and
    Django (a Python-based web framework). Such open source projects or software typically
    have a series of alpha and beta releases. They also typically have release candidates
    prior to releasing a major version of the software or project.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的过程在开源项目中很常见，比如Ubuntu（一个基于Linux的开源操作系统）、jQuery（一个JavaScript库）和Django（一个基于Python的网页框架）。这些开源项目或软件通常有一系列的内测和公测版本。它们在发布软件或项目的主要版本之前，通常也会有发布候选版本。
- en: White box testing
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 白盒测试
- en: White box testing is also known as clear box testing, glass box testing, or
    transparent testing. White box testing can be seen as the opposite of black box
    testing; we test the program with knowledge of the internal structure of our program.
    We take an internal perspective of the program, and use this perspective when
    we implement our test plan.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试也被称为透明盒测试、玻璃盒测试或透明测试。白盒测试可以被视为黑盒测试的对立面；我们在了解程序的内部结构的情况下测试程序。我们从程序的内部视角来看待问题，并在实施我们的测试计划时使用这种视角。
- en: White box testing typically occurs when the test has access to the internal
    code and data structures of the program. Because we take an internal perspective
    of our program and with knowledge of our source code, we design the test plan
    based on our code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试通常发生在测试可以访问程序的内部代码和数据结构的情况下。因为我们从程序的内部视角来看待问题，并且了解我们的源代码，所以我们的测试计划是基于我们的代码来设计的。
- en: We might find ourselves tracing the path of how our code is executed and work
    out what are the input and output values for various functions or methods of our
    program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现自己追踪代码的执行路径，并找出程序中各种函数或方法的各种输入和输出值。
- en: Some examples of white box testing include Branch testing, and Pareto testing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试的一些例子包括分支测试和 Pareto 测试。
- en: Branch testing
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支测试
- en: 'Branch testing is a concept where each branch of the code should be tested
    at least once. This means that all functions or code that has been written should
    be tested. In software testing, there is a measure known as code coverage, which
    refers to how much source code of a program has been tested. Some of the more
    important types of branch testing coverage includes the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分支测试是一个概念，它要求代码中的每个分支至少测试一次。这意味着编写的一切功能或代码都应该被测试。在软件测试中，有一个度量标准称为代码覆盖率，它指的是程序的源代码中有多少已经被测试过。分支测试覆盖的一些更重要的类型包括以下内容：
- en: 'Functional coverage: where we make sure that each function of the code has
    been called (tested)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能覆盖：确保代码中的每个功能都已经被调用（测试）
- en: 'Decision coverage: where each of the `if else` statements has been tested.
    There might be cases where the `if` part of the code works but not the `else`
    part of the code, and vice versa.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策覆盖：每个`if else`语句都已经被测试过。可能存在这样的情况，代码的`if`部分可以工作，但`else`部分却不能，反之亦然。
- en: Pareto testing
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pareto 测试
- en: Pareto testing is what I personally call "real world" testing, and is conducted
    under strict time and money constraints. This is because Pareto testing only focuses
    on the most used functions; the most frequently used functions are what matter
    the most and hence we should focus our time and effort on testing these functions.
    Alternatively, we may see Pareto testing such that most bugs come from a small
    handful of functions of our programs; therefore, by spotting these functions,
    we can test our program much more effectively.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Pareto 测试我个人称之为“现实世界”的测试，并在严格的时间和金钱约束下进行。这是因为 Pareto 测试只关注最常用的功能；最经常使用的功能是最重要的，因此我们应该把时间和精力集中在测试这些功能上。另外，我们可以将
    Pareto 测试看作是大多数错误来自于我们程序中少数几个功能的情况；因此，通过发现这些功能，我们可以更有效地测试我们的程序。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pareto testing is derived from an idea called "Pareto Principle" or perhaps
    better known as the "80-20 principle". What the Pareto Principle suggests is that
    roughly 80% of the effects come from 20% of the causes. For instance, 80% of the
    sales revenue may come from 20% of the sales team or customers. Or another example
    would be 80% of the world wealth is control by 20% of the world's population.
    Applied in our case here, we can say that 80% of the bugs or program errors come
    from 20% of our code, and therefore we should focus testing on that particular
    20% of the code. Alternatively, we can say that 80% of the program's usage activity
    comes from 20% of our code. Similarly, we can focus testing on that particular
    20% of the code. Just for the record, pareto testing can be regarded as a general
    testing principle, and not just a form of white box testing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Pareto 测试源自一个被称为“帕累托原则”的想法，也许更广为人知的是“80-20 原则”。帕累托原则指出，大约 80% 的效果来自于 20% 的原因。例如，80%
    的销售收入可能来自于 20% 的销售团队或客户。或者另一个例子是，世界上 80% 的财富是由世界上 20% 的人口控制的。应用在我们的案例中，我们可以认为
    80% 的错误或程序错误来自于 20% 的代码，因此我们应该专注于这部分代码的测试。或者，我们可以说程序的 80% 的使用活动来自于 20% 的代码。同样，我们可以专注于这部分代码的测试。顺便说一下，Pareto
    测试可以被视为一个一般的测试原则，而不仅仅是白盒测试的一种形式。
- en: Unit tests
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing breaks up code into logical chunks for testing, and generally focuses
    on one method at a time. A unit can be seen as the smallest possible chunk of
    code, such as a function or method. This means that in the ideal situation, each
    unit should be independent from all other units.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试将代码分成逻辑块进行测试，通常一次关注一个方法。单元可以被视为代码的最小可能块，例如一个函数或方法。这意味着在理想情况下，每个单元应该与其他所有单元独立。
- en: When we are performing unit testing, we attempt to test each function or method
    as we complete it, thus making sure that whatever code we have works before we
    move on to the next function or method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行单元测试时，我们尝试在完成每个函数或方法时进行测试，以确保我们拥有的代码在继续下一个函数或方法之前能够正常工作。
- en: This helps to reduce errors, and you may have noticed that we have somehow applied
    the idea of unit testing when developing the JavaScript program in the previous
    chapters. As we create each function, we try to test it whenever possible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于减少错误，您可能已经注意到，在开发前几章中的JavaScript程序时，我们以某种方式应用了单元测试的概念。每当创建一个函数时，我们尽可能地进行测试。
- en: Some of the benefits of unit testing includes minimization of errors, and allowing
    ease of change, because each function or method is tested individually in isolation
    and, to a good extent, simplifies integration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一些好处包括最小化错误，以及便于变更，因为每个函数或方法都是单独在隔离环境中测试的，并且在很大程度上简化了集成。
- en: The main benefit, in my opinion, is that unit tests are flexible and allow ease
    of documentation. This is because as we write and test new functions, we can easily
    take note of what the problems are, and whether the code can work correctly. In
    effect, we are doing incremental documentation—documenting the results as we test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为主要好处是单元测试灵活，便于文档记录。这是因为当我们编写和测试新函数时，我们可以轻松地记录下问题所在，以及代码是否能正确工作。实际上，我们是在进行逐步记录——在测试的同时记录结果。
- en: Unit testing is also an integral part of integrated testing, especially in the
    bottom-up approach, as we test our program from the smallest possible unit before
    moving on to larger units. For example, as I was creating the code for [Chapter
    2](ch02.html "Chapter 2. Ad Hoc Testing and Debugging in JavaScript"), *Ad Hoc
    Testing and Debugging in Javascript*, I essentially carried out unit testing informally.
    I carried out unit testing by treating each of the functions as individual units,
    and tested each JavaScript function with the related HTML input field, in order
    to make sure that the correct output was achieved. This technique can be seen
    as part of performing continuous integration as new code is being written.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试也是集成测试的一个组成部分，尤其是在自下而上的方法中，因为我们从最小的可能单元开始测试，然后逐步测试更大的单元。例如，在我为[第2章](ch02.html
    "第2章. JavaScript中的即兴测试与调试")创建代码时，*JavaScript中的即兴测试与调试*，我实际上进行了非正式的单元测试。我将每个函数视为独立的单元，并使用相关的HTML输入字段测试每个JavaScript函数，以确保得到正确的输出。这种技术可以看作是在编写新代码时执行持续集成的一部分。
- en: Continuous integration is a process where developers integrate their code frequently,
    in order to prevent integration errors. This is often done with the help of automated
    builds of the code (and includes tests) to detect integration testing. As we create
    new code, it is important that we integrate with the existing code to make sure
    that no compatibility issues or new bugs (or even old bugs) are introduced. Continuous
    integration is becoming popular as it integrates unit tests, revision control,
    and build systems.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是一个过程，在这个过程中，开发者频繁地集成他们的代码，以防止集成错误。这通常需要自动构建代码（包括测试）来检测集成测试。当我们创建新代码时，确保与现有代码集成非常重要，以防止出现兼容性问题或新旧错误。持续集成越来越受欢迎，因为它集成了单元测试、版本控制和构建系统。
- en: Web page tests
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网页测试
- en: As mentioned previously, web page testing is a form of functional testing, and
    typically refers to the testing of the user interface, from the user's point of
    view. For our purposes here, we would test our JavaScript program in conjunction
    with HTML and CSS.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网页测试是一种功能测试，通常指的是从用户角度测试用户界面。对于我们在这里的目的，我们将测试我们的JavaScript程序与HTML和CSS结合使用。
- en: Web page testing also includes testing for correctness in terms of different
    browsers and platforms. We should at least focus on the major web browsers such
    as Internet Explorer and Firefox, and see if the presentation and JavaScript program
    works under different browsers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 网页测试还包括不同浏览器和平台上的正确性测试。我们至少应该关注像 Internet Explorer 和 Firefox 这样的主要网络浏览器，并检查在不同浏览器下的表现和
    JavaScript 程序是否正常工作。
- en: To have a brief idea regarding the usage of browsers, you might want to head
    down to [http://www.w3schools.com/browsers/browsers_stats.asp](http://www.w3schools.com/browsers/browsers_stats.asp)
    to see which browsers are popular, in decline, or on the rise.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解浏览器使用情况，你可能想去 [http://www.w3schools.com/browsers/browsers_stats.asp](http://www.w3schools.com/browsers/browsers_stats.asp)
    查看哪些浏览器受欢迎、正在下降或正在崛起。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It appears that Google Chrome is gaining a lot of momentum, and it has a good
    chance of becoming a popular web browser; in less than two years, Google Chrome
    has increased its market share from 3.15 percent to 14.5 percent, based on the
    statistics provided by w3schools. This increase in popularity is in part due to
    its JavaScript engine performance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 Google Chrome 正在迅速增加势头，它有很大的机会成为一个受欢迎的网络浏览器；根据 w3schools 提供的统计数据，不到两年的时间，Google
    Chrome 的市场份额从 3.15% 增加到 14.5%。这种受欢迎程度的部分原因在于其 JavaScript 引擎性能。
- en: The other main focus of web page tests also includes checking for the most frequently-used
    user behaviors, such as illegal and legal values, login, logout, erroneous behavior
    of the users, SQL, HTML injection, checking of HTML links, images, the possibility
    of robot attacks, and so on.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 网页测试的另一个主要焦点也包括检查最常用的用户行为，比如非法与合法值、登录、登出、用户错误行为、SQL、HTML 注入、HTML 链接检查、图像、机器人攻击的可能性等等。
- en: As SQL, HTML injection, and robot attacks are out of the scope of this book,
    we will focus on the other issues, such as making sure that the web page will
    work under different browsers, testing for illegal and legal values, erroneous
    behavior, and frequent behaviors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQL、HTML 注入和机器人攻击超出了本书的范围，我们将关注其他问题，比如确保网页在不同浏览器下能够工作、检查非法与合法值、错误行为以及频繁行为等。
- en: Performance tests
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests have a wide range of genres such as load testing, stress testing,
    endurance testing, isolation testing, spike testing, and so on. I will not attempt
    to bog you down with the details. Instead, I will focus on two of the more common
    issues that you will face as a JavaScript programer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试包括负载测试、压力测试、耐力测试、隔离测试、尖峰测试等多种类型。我不会试图让你陷入细节之中。相反，我将重点关注 JavaScript 程序员可能会面临的两个更常见的问题。
- en: Firstly, performance can refer to the amount of time required for the client
    to download a piece of JavaScript. You may argue that download time depends on
    the Internet connection. But there is one simple thing that you can do to reduce
    the size of your JavaScript without refactoring or rewriting it, and that is compressing
    your JavaScript code. A good example of this would be the JQuery library, which
    we introduced in [Chapter 3](ch03.html "Chapter 3. Syntax Validation"), *Syntax
    Validation*. If you visit the JQuery home page at [http://jquery.com](http://jquery.com),
    you may have noticed that JQuery comes in two forms—a production version and a
    development version. The production version is minified, and the file size is
    24KB, whereas the development version is 155KB. Obviously, the production version
    is smaller in file size and hence improves performance in terms of downloading
    the JavaScript.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，性能可以指客户端下载一段 JavaScript 所需的时间。你可能会认为下载时间取决于互联网连接。但有一件简单的事情你可以做，那就是压缩你的 JavaScript
    代码，而不需要重构或重写它。一个很好的例子就是我们在 [第 3 章](ch03.html "Chapter 3. Syntax Validation")，*语法验证*
    中介绍的 JQuery 库。如果你访问 JQuery 的官方网站 [http://jquery.com](http://jquery.com)，你可能注意到了
    JQuery 分为两种形式——生产版本和开发版本。生产版本是最小化的，文件大小为 24KB，而开发版本则是 155KB。显然，生产版本的文件大小更小，因此在下载
    JavaScript 方面提高了性能。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Compressing your code—or minifying your code—refers to an act where you remove
    all unnecessary white spaces and lines from your code in order to reduce file
    size. Some code minifiers automatically remove comments, replace functions, variables,
    and even encode in different codings.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩你的代码——或者最小化你的代码——指的是你删除代码中所有不必要的空白和行，以减小文件大小。一些代码最小化工具会自动删除注释、替换函数、变量，甚至采用不同的编码方式。
- en: Secondly, performance can also refer to the speed at which a particular piece
    of code executes for any given amount of input. In general, we need to use external
    libraries or tools to help us find out which parts of our code are performing
    relatively slower than the others, or where the bottlenecks are. Related tools,
    and how we can apply performance testing, will be covered in [Chapter 6](ch06.html
    "Chapter 6. Testing More Complex Code"),*Testing more complex code*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，性能也可以指执行特定代码的速度，对于给定的输入量而言。通常，我们需要使用外部库或工具来帮助我们找出我们代码中相对较慢的部分，或者瓶颈所在。相关工具以及我们如何可以应用性能测试，将在[第6章](ch06.html
    "第6章 测试更复杂的代码")，*测试更复杂的代码*中介绍。
- en: Integration testing
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integrated testing is among the last steps of the testing process prior to acceptance
    testing. Because we have made sure that the basic building blocks of the program
    work correctly as an individual unit, we will now need to make sure if they can
    work together.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是验收测试之前的测试过程中的最后一步。因为我们已经确保程序的基本构建模块作为单独的单位正确工作，我们现在需要确保它们能否一起工作。
- en: Integration testing refers to the testing of all of the different components
    of our program. The different components can refer to the various units that we
    have talked about so far. The main objective of integration testing is to ensure
    that the functional, performance, and reliability requirements are met. We also
    test the different units together and see if they can work; we'll need to check
    for any irregularities when combining the units together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试指的是我们程序的所有不同组件的测试。不同的组件可以指的是我们迄今为止谈论的各种单元。集成测试的主要目标是确保功能、性能和可靠性要求得到满足。我们也一起测试不同的单元，看看它们是否能工作；我们需要检查在组合单元时是否有任何异常。
- en: Integration testing can take different forms, such as top-down and bottom-up
    approach.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可以采取不同的形式，例如自顶向下和自底向上的方法。
- en: In the top-down approach, we start with the highest-level integrated module,
    followed by the sub-modules or functions of each module. On the other hand, bottom-up
    testing starts from the lowest level components before moving on to the upper-level
    components.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在自顶向下的方法中，我们首先从最高级别的集成模块开始，然后是每个模块的子模块或函数。另一方面，自底向上的测试从最低级别的组件开始，然后逐步过渡到更高级别的组件。
- en: Based on the sample code that we have seen so far, it would be difficult to
    understand how integrated testing works. In general, if we view the HTML code
    as a unit, CSS as a unit, and each individual JavaScript function as a unit, we
    can see that integrated testing would include testing all three together and making
    sure that it is correct.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们迄今为止看到的示例代码，很难理解集成测试是如何工作的。通常，如果我们把HTML代码视为一个单元、CSS作为一个单元、每个单独的JavaScript函数作为一个单元，我们可以看到集成测试将包括测试所有三个在一起并确保它是正确的。
- en: In the bottom-up approach, we begin testing from the basic units of code. As
    we test the basic units of code, we move up to test larger units of code. This
    process is similar to unit testing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在自底向上的方法中，我们从代码的基本单元开始测试。随着我们测试代码的基本单元，我们逐步测试更大单元的代码。这个过程与单元测试类似。
- en: Regression testing—repeating prior testing after making changes
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归测试——在做出更改后重复先前的测试
- en: Regression testing focuses on uncovering errors in a program when a program
    is being modified or upgraded. In real-life situations, we tend to make changes
    to a program—whether this is upgrading it, adding new features, and so on. The
    key point is that as we make changes to a program, we need to test the new components
    to see if they work in conjunction with the old components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试专注于在程序被修改或升级时揭示程序中的错误。在现实情况下，我们倾向于对一个程序进行更改——无论是升级它、添加新功能等等。关键是，当我们对程序进行更改时，我们需要测试新组件，看看它们是否能与旧组件一起工作。
- en: 'We need to perform regression testing because research and experience have
    shown that as a program is being modified, new or old errors may appear. For instance,
    an old, previously-fixed bug may be re-introduced into the program when a new
    feature is being added, or the new feature itself may contain a bug that affects
    the existing features. This is where regression testing comes in: we perform previous
    tests to make sure that the old components are still running and that no old faults
    have re-emerged. We test the new features with the old components to ensure that
    the entire system is working. Sometimes, in order to save time and resources,
    we may only perform testing on the new features in conjunction with the old components.
    At this point, we can apply impact analysis to determine the impact area of the
    application, by adding or modifying code.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行回归测试，因为研究和经验表明，在程序被修改时，新的或旧的错误可能会出现。例如，当添加新功能时，可能会重新引入之前修复过的旧错误，或者新功能本身可能包含影响现有功能的错误。这就是回归测试发挥作用的地方：我们执行之前的测试，以确保旧的组件仍然运行良好，并且没有旧的错误再次出现。我们用旧的组件测试新功能，以确保整个系统正常工作。有时，为了节省时间和资源，我们可能只对与旧组件结合的新功能进行测试。在这种情况下，我们可以应用影响分析来确定应用程序通过添加或修改代码的影响区域。
- en: Regression testing is as real as it gets. This is because as a program grows,
    the chances are that you will make changes to your code. As you make changes to
    your code there is a likelihood that bugs or incompatibilities may be introduced
    to your program, and regression testing helps you to spot such mistakes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试是最真实的部分。这是因为随着程序的增长，你更改代码的可能性很大。在你更改代码的过程中，可能会引入程序中的错误或不兼容。回归测试帮助你发现这些错误。
- en: Testing order
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试顺序
- en: 'We have now covered the required background knowledge, so it is time to understand
    what kind of tests we should start with. The order in which we carry out the tests
    depends on whether we want to implement bottom-up testing or top-down testing.
    There is nothing wrong with either order of testing, but I personally prefer bottom-up
    testing: I''ll typically start with unit testing first, followed by other types
    of tests (depending on what the program is like), and finish off with integration
    testing.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了所需的基础知识，所以是时候了解我们应该从哪种测试开始。我们进行测试的顺序取决于我们是要实施自下而上的测试还是自上而下的测试。测试的顺序没有问题，但我个人更喜欢自下而上的测试：我通常首先从单元测试开始，然后是其他类型的测试（取决于程序的性质），最后是集成测试。
- en: The main reason for taking this approach is that unit testing allows us to find
    errors in the code much earlier; this prevents bugs or errors from piling up.
    In addition, it provides flexibility in how you choose to document the test results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 采取这种方法的主要原因是因为单元测试允许我们更早地发现代码中的错误；这防止了错误或缺陷的累积。此外，它提供了在记录测试结果方面更大的灵活性。
- en: However, if you prefer the top-down approach, you can always start by testing
    the program as if you were an end user.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你喜欢自上而下的方法，你总是可以先以最终用户的角度来测试程序。
- en: In the real world, especially in terms of testing web applications, it can be
    difficult to differentiate (at least conceptually) between bottom-up testing and
    top-down testing. This is because although the user-interface and programing logic
    are separated, we really need to test both at the same time in order to understand
    if it works the way that we want it to.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，特别是在测试网络应用程序方面，很难区分（至少在概念上）自下而上的测试和自上而下的测试。这是因为尽管用户界面和编程逻辑是分开的，但我们确实需要同时测试两者，以了解它是否按照我们的预期工作。
- en: Nonetheless, the testing order should finish with user acceptance testing, because
    the end users are the ones who will be using our code eventually.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试顺序应该以用户验收测试结束，因为最终用户是我们代码的使用者。
- en: In the next section, we will show you how to document your test plan. You will
    notice that we will be performing tests from the users' point of view. Now, it
    is time to document our test plan.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示如何编写测试计划。你会注意到，我们将从用户的角度进行测试。现在，是编写我们的测试计划的时候了。
- en: Documenting your test plan
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的测试计划
- en: Now that we have covered the required testing concepts, it is time to learn
    how we can create the test plan. At the same time, we will document our test plan;
    this will serve as a basis for the next part of this chapter, where we will apply
    the test.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经覆盖了必要的测试概念，是时候学习如何创建测试计划了。同时，我们将记录我们的测试计划；这将作为本章下一部分的依据，我们将应用测试。
- en: The test plan
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试计划
- en: Our test plan will consist of some of the concepts we have covered earlier,
    such as web page testing, boundary testing, integration testing, and others. Because
    we are applying the test on the code we have used in [Chapter 2](ch02.html "Chapter 2. Ad
    Hoc Testing and Debugging in JavaScript"), *Ad Hoc Testing and Debugging in Javascript*,
    we have the advantage of knowing what the code is about. Therefore, we can design
    our test process in such a way that it can incorporate ideas from both black box
    testing and white box testing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试计划将包含我们之前覆盖的一些概念，例如网页测试、边界测试、集成测试等。因为我们正在对[第2章](ch02.html "第2章 JavaScript中的即兴测试和调试")中使用的代码进行测试(*Ad
    Hoc Testing and Debugging in Javascript*)，我们知道代码是关于什么的。因此，我们可以设计我们的测试过程，使其能够包含来自黑盒测试和白盒测试的思想。
- en: You might want to go to the `source code` folder and open the `sample_test_plan.doc`
    file, which is our sample test plan. This is a very simple and informal test plan,
    which contains only the bare minimum of the required components. If you are writing
    documentation for your own reference, you can save on time and effort by using
    a simple document. However, if you are preparing a test plan for a client, you
    will need a more elaborate document. For simplicity sake, we'll use the sample
    document provided in the `source code` folder to help you understand the planning
    process quickly. I will briefly run through the components of our test plan and
    at the same time, I will introduce to you the main components of our test plan.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想前往`源代码`文件夹并打开`sample_test_plan.doc`文件，这是我们的示例测试计划。这是一个非常简单和非正式的测试计划，只包含所需组件的最少量。如果你为自己的文档编写参考资料，使用简单的文档可以节省时间和精力。然而，如果你为客户准备测试计划，你需要一个更详细的文档。为了简单起见，我们将使用`source
    code`文件夹中提供的示例文档来帮助你快速理解计划过程。我将简要概述我们的测试计划的组件，同时，我将向您介绍我们测试计划的主要组件。
- en: Versioning
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制
- en: In the first component, you will notice that there is a version table, which
    documents the changes in the test plan. In the real world, plans change and therefore,
    it is a good habit to keep track of the things that have changed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个组件中，你会注意到有一个版本表，记录了测试计划的变化。在现实世界中，计划会变化，因此，跟踪已经变化的事情是一个好习惯。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another way to keep versioning easy and maintainable is to use version control
    software such as Git or BitBucket. Such versioning tools keep a log of the changes
    that you have made in your code; this will enable to trace what changes you have
    made, and this makes creating tests plans a lot easier. You can visit [http://git-scm.com/](http://git-scm.com/)
    to learn more about Git, and [http://bitbucket.org/](http://bitbucket.org/) to
    learn more about BitBucket.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使版本控制更容易维护的方法是使用版本控制软件，如Git或BitBucket。这样的版本工具记录了你代码中的变化；这将使你能够追踪你所做的变化，这使得创建测试计划变得容易得多。你可以访问[http://git-scm.com/](http://git-scm.com/)了解更多信息关于Git，以及[http://bitbucket.org/](http://bitbucket.org/)了解关于BitBucket的信息。
- en: Test strategy
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试策略
- en: The next important component that you should notice is the test strategy. The
    test strategy represents the main thoughts and ideas that we will be using for
    our test plan. You will see that we are employing both white box and black box
    testing, along with unit testing and integration testing. Because our JavaScript
    program is web-based, we are implicitly carrying out a form of web page testing,
    although this is not mentioned in the subsequent parts of the chapter. For each
    phase of the test, we will decide on the test values required. Also, if you look
    at the `sample_test_plan.doc`, you will see that I have added, in the form of
    a brief description of the expected values, the result or response for each part
    of the test.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的组成部分是你应该注意的测试策略。测试策略表示我们将用于测试计划的主要思想和想法。你会看到我们同时采用了白盒测试和黑盒测试，以及单元测试和集成测试。由于我们的JavaScript程序是基于网络的，我们隐式地执行了一种网页测试，尽管这在章节的后续部分没有提到。对于测试的每个阶段，我们将决定所需的测试值。另外，如果你查看`sample_test_plan.doc`，你会发现我添加了，以预期值的简短描述形式，每个测试部分的结果或响应。
- en: Testing expected and acceptable values by using white box testing
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过白盒测试测试预期和可接受值
- en: The first thing that we will be doing is white box testing by using unit testing.
    Because we have a strong understanding of the code and user interface (the HTML
    and CSS code), we will apply the test at the user-interface level. This means
    that we will test the program by entering the various test values that we have
    decided upon.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是使用单元测试进行白盒测试。由于我们对代码和用户界面（HTML和CSS代码）有深入的了解，我们将把测试应用到用户界面级别。这意味着我们将通过输入我们已经决定的各个测试值来测试程序。
- en: In this case, we will use the program as we have already used in [Chapter 2](ch02.html
    "Chapter 2. Ad Hoc Testing and Debugging in JavaScript"), *Ad Hoc Testing and
    Debugging in Javascript*, and [Chapter 3](ch03.html "Chapter 3. Syntax Validation"),
    *Syntax Validation*, and see if the program works the way that we intended it
    to. We will be using values that are expected and acceptable here.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在此例中，我们将像在[第2章](ch02.html "第2章. JavaScript中的即兴测试和调试")*JavaScript中的即兴测试和调试*和[第3章](ch03.html
    "第3章. 语法验证")*语法验证*中一样使用程序，看看程序是否如我们所预期的那样工作。我们将在此处使用预期和可接受的数据值。
- en: The input will be what the program requires us to enter—for input fields that
    require us to enter down our name, place of birth, and so on, we will enter characters
    into it. Input fields that require numbers as inputs, such as age, the age at
    which we would like to retire, salary, expenses, and so on, we will enter numbers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输入将是程序要求我们输入的内容—对于需要我们输入姓名、出生地等内容的输入字段，我们将向其输入字符。需要数字作为输入的输入字段，如年龄、我们希望退休的年龄、薪水、开支等，我们将输入数字。
- en: 'The details of the input are as follows (the input values are for demonstration
    purposes only):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的详细信息如下（输入值仅为演示目的）：
- en: '| Input fields | Input value (case 1) | Input Value (case 2) |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: 输入字段 | 输入值（案例1） | 输入值（案例2） |
- en: '| --- | --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '---- | ---- | ---- |'
- en: '| Name | Johnny Boy | Billy Boy |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: 姓名 | Johnny Boy | Billy Boy |
- en: '| Place of birth | San Francisco | San Francisco |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: 出生地 | 旧金山 | 旧金山 |
- en: '| Age | 25 | 25 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: 年龄 | 25 | 25 |
- en: '| Spending per month | 1000 | 1000 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: 每月开支 | 1000 | 1000 |
- en: '| Salary per month | 100000 | 2000 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: 每月薪水 | 100000 | 2000 |
- en: '| Age at which you wish to retire | 55 | 55 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: 你希望退休的年龄 | 55 | 55 |
- en: '| Amount of money I want by retirement age | 1000000 | 1000000 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: 到退休年龄我想要的钱 | 1000000 | 1000000 |
- en: 'For each of the input values, we would expect a corresponding input field to
    be created dynamically in the middle of the screen, under the header **Response**,
    and at the same time, the original input field would be disabled. This is known
    as the expected output, result, or response for the test. This goes on for the
    rest of the input fields for the first form. An example of the dynamically-created
    field is shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个输入值，我们期望相应的输入字段在屏幕中间、**响应**标题下动态创建，同时，原始输入字段将被禁用。这被称为测试的预期输出、结果或响应。这对于第一个表单的其余输入字段也是如此。动态创建的字段的示例如下所示：
- en: '![Testing expected and acceptable values by using white box testing](img/0004_04_01.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![通过白盒测试测试预期和可接受值](img/0004_04_01.jpg)'
- en: Notice that in the middle of the screenshot, under the header **Response**,
    there are two input fields. These input fields are created dynamically.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在屏幕中间，在**响应**标题下，有两个输入字段。这些输入字段是动态创建的。
- en: Testing expected and unacceptable values by using black box testing
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过黑盒测试测试预期和不可接受值
- en: 'The second thing that we will be doing is to perform black box testing by employing
    boundary value testing. There are two parts to this test: we will first test the
    boundary values of the program to see if the output is correct. The inputs are
    similar to what we have used for white box testing, except that we will use unusually
    large numbers, or unusually large number of characters, for each input. We will
    also use single number and single characters as part of our inputs. The output
    for each of the inputs should be similar to what we have seen in white box testing.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第二件事是使用边界值测试进行黑盒测试。这个测试分为两部分：首先，我们将测试程序的边界值，以查看输出是否正确。输入与白盒测试中使用的输入类似，不同之处在于我们将每个输入使用异常大的数字或异常大的字符长度。我们还将单个数字和单个字符作为输入的一部分。每个输入的输出应与白盒测试中看到的输出相似。
- en: 'To be more specific, we will be using the following test values (note that
    the test values are purely for demonstration purposes only; when you are creating
    your program you have to decide what suitable boundary values should be used):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将使用以下测试值（请注意，这些测试值仅用于演示目的；当你创建你的程序时，你必须决定应该使用哪些合适的边界值）：
- en: '| Input fields | Minimum Value | Common Value | Maximum value | Comments |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 输入字段 | 最小值 | 常见值 | 最大值 | 注释 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Name | A single character, such as ''a'' | Eugene | An extremely long string,
    not more than 255 characters. | Range of values (X):Single character 1 <= X <=
    255 characters |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 姓名 | 一个字符，例如''a'' | Eugene | 一个非常长的字符串，不超过255个字符。 | 值的范围（X）：一个字符 1 <= X <=
    255个字符 |'
- en: '| Place of birth | A single character, such as a | New York City | An extremely
    long string, not more than 255 characters. | Range of values (X):Single character
    1 <= X <= 255 characters |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 出生地 | 一个字符，例如a | 纽约市 | 一个非常长的字符串，不超过255个字符。 | 值的范围（X）：一个字符 1 <= X <= 255个字符
    |'
- en: '| Age | 1 | 25 | No more than 200 years old | Range of values (X):1 <= X <=
    200 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 年龄 | 1 | 25 | 不会超过200岁 | 值的范围（X）：1 <= X <= 200 |'
- en: '| Spending per month | 1 | 2000 | 1000000000 | Range of values (X):1 <= X <=
    1000000000 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 每月支出 | 1 | 2000 | 1000000000 | 值的范围（X）：1 <= X <= 1000000000 |'
- en: '| Salary per month | 2 | 5000 | 1000000000 | Notice that that we are assuming
    that our user earns more than he spends.Range of values (X): 1 <= X <= 1000000000
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 每月工资 | 2 | 5000 | 1000000000 | 注意到我们假设用户挣得比花得多。值的范围（X）：1 <= X <= 1000000000
    |'
- en: '| Age at which you wish to retire | This age should be greater than the present
    age | This age should be greater than the present age | This age should be greater
    than the present age | Range of values (X): 1 <= X <= 200 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 你希望在退休时的年龄 | 这个年龄应该大于现在的年龄 | 这个年龄应该大于现在的年龄 | 这个年龄应该大于现在的年龄 | 值的范围（X）：1 <=
    X <= 200 |'
- en: '| Amount of money I want by retirement age | We will be using 1 here | A suitable
    number, such as 1000000 | No more than a trillion dollars | Range of values (X):
    1 <= X <= 1000000000 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 到退休年龄时我想要的钱 | 我们将使用1这里 | 一个合适的数字，比如1000000 | 不会超过一万亿美元 | 值的范围（X）：1 <= X <=
    1000000000 |'
- en: If you refer to the `sample test` document, you will realize that I have provided
    a sample range of values for each of the input fields.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考了`sample test`文档，你就会发现我为每个输入字段提供了一个测试值的样本范围。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that we've touched on equivalence partitioning in the earlier sections?
    In practice, given a boundary value, we would test three values relating to the
    given test value. For example, if we want to test a boundary value of '50', then
    we will test on 49, 50, and 51\. However for simplicity's sake, we will be testing
    on the intended value only. This is because in the next chapter we will be carrying
    out the actual test for the given values; it can get repetitive and tedious. I
    just want you to know what the real world practices are.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们之前提到等价划分了吗？在实际操作中，给定一个边界值，我们会测试与给定测试值相关的三个值。例如，如果我们想测试一个边界值'50'，那么我们会测试49、50和51。然而为了简化，我们只会测试预期的值。这是因为下一章我们将对给定的值进行实际测试；这可能会变得重复和单调。我只是想让你知道真正的世界实践是什么。
- en: The second part of this test is that we will test for expected illegal values.
    In the first scenario, we will be using values that are both accepted and unaccepted.
    The input will be similar to what we have used for the white box testing phase,
    except that we will use characters as inputs for input fields that require numbers,
    and vice versa. The expected output each time that we enter an unaccepted value
    is that there will be an alert box telling us that we have entered a wrong value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分测试的第二部分是我们将测试预期的非法值。在第一种情景中，我们将使用既被接受又被拒绝的值。输入将类似于我们在白盒测试阶段所使用的值，不同的是，我们将数字作为需要数字的字段的输入，反之亦然。每次我们输入一个不被接受的值时，预期的输出是会出现一个警告框，告诉我们输入了错误的值。
- en: 'For details, check the following table:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 具体细节，请查看以下表格：
- en: '| Input fields | Input Value | Input Value Case 1 | Input Value Case 2 | Input
    Value Case 3 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 输入字段 | 输入值 | 输入值案例1 | 输入值案例2 | 输入值案例3 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Name | Digits or empty values | 1 | ~!@#$%^&*()" | Testing |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 姓名 | 数字或空值 | 1 | ~!@#$%^&*()" | 测试 |'
- en: '| Place of birth | Digits or empty values | 1 | ~!@#$%^&*()" | testing |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 出生地 | 数字或空值 | 1 | ~!@#$%^&*()" | 测试 |'
- en: '| Age | Characters and empty values | a | ~!@#$%^&*()" | -1 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 年龄 | 字符和空值 | a | ~!@#$%^&*()" | -1 |'
- en: '| Spending per month | Characters and empty values | a | ~!@#$%^&*()" | -1
    |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 每月支出 | 字符和空值 | a | ~!@#$%^&*()" | -1 |'
- en: '| Salary per month | Characters and empty values | a | ~!@#$%^&*()" | -1 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 每月工资 | 字符和空值 | a | ~!@#$%^&*()" | -1 |'
- en: '| Age at which you wish to retire at | Characters and empty values | a | ~!@#$%^&*()"
    | -1 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 你希望在多少岁时退休 | 字符和空值 | a | ~!@#$%^&*()" | -1 |'
- en: '| Amount of money I want by retirement age | Characters and empty values |
    a | ~!@#$%^&*()" | -1 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 我希望在退休年龄拥有多少钱 | 字符和空值 | a | ~!@#$%^&*()" | -1 |'
- en: In general, for each of the expected illegal values, we should expect our program
    to alert us with an alert box, telling us that we have entered the wrong type
    of values.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，对于每个预期的非法值，我们应期待我们的程序会通过一个警告框来提醒我们，告诉我们我们输入了错误类型的值。
- en: In the second test scenario, we will attempt to enter non-alphanumeric values,
    such as exclamation marks, asterisk signs, and so on.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试场景中，我们将尝试输入非字母数字值，例如感叹号、星号等。
- en: In the third test scenario, we will test for negative values for input fields
    that require numbers. The input values for the third test scenario are as follows:We
    are using -1 to save some typing; so negative values such as -100000 don't make
    any difference.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个测试场景中，我们将测试输入字段中数字的负值。第三个测试场景的输入值如下：我们使用-1来节省一些打字时间；所以像-100000这样的负值没有区别。
- en: Testing the program logic
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试程序逻辑
- en: For this part of the test plan, we will attempt to test the program logic. Part
    of ensuring program logic is to ensure that the inputs are what we need and want.
    However, certain aspects of the program logic cannot be guaranteed simply by validating
    the input values alone.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分的测试计划中，我们将尝试测试程序逻辑。确保程序逻辑的一部分是确保输入是我们需要和想要的。然而，程序逻辑的某些方面不能仅仅通过验证输入值来保证。
- en: For instance, an implicit assumption that we have about the user is that we
    assume the user will enter a retirement age that is bigger than his present age.
    While this assumption is logically sound, users may or may not enter the value
    according to conventional assumptions. Therefore, we need to guarantee the logic
    of the program is correct by ensuring that the retirement age is greater than
    the present age.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们对用户有一个隐含的假设，即我们认为用户将输入一个比他当前年龄大的退休年龄。虽然这个假设在逻辑上是合理的，但用户可能根据传统假设输入值，也可能不输入。因此，我们需要通过确保退休年龄大于当前年龄来确保程序逻辑是正确的。
- en: 'The inputs for this test are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的输入值如下：
- en: '| Input fields | Input value of first form |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 输入字段 | 第一份表单的输入值 |'
- en: '| --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name | Johnny Boy |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 姓名 | Johnny Boy |'
- en: '| Place of birth | San Francisco |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 出生地 | 旧金山 |'
- en: '| Age | 30 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 年龄 | 30 |'
- en: '| Spending per month | 1000 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 每月支出 | 1000 |'
- en: '| Salary per month | 2000 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 每月工资 | 2000 |'
- en: '| Age at which you wish to retire | 25 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 你希望在多少岁时退休 | 25 |'
- en: '| Amount of money I want by retirement age | 1000000 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 我希望在退休年龄拥有多少钱 | 1000000 |'
- en: The key thing to note here is that the value for "age at which you wish to retire
    " is smaller than "age".
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，“你希望在多少岁时退休”的值比“年龄”的值要小。
- en: We should expect our program to spot this logical error; if it does not, we
    will need to fix our program.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该期待我们的程序能够发现这个逻辑错误；如果它没有发现，我们需要修复我们的程序。
- en: Integrated testing and testing unexpected values
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集成测试和测试意外值
- en: The final phase is integrated testing, where we test the entire program and
    see if it works together, which includes the first form, the second form which
    is derived from the first form, and so on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个阶段是集成测试，在这个阶段中，我们测试整个程序，看它是否能协同工作，这包括第一个表单、由第一个表单派生出的第二个表单，等等。
- en: 'In the first test scenario, we begin slow and steady by testing expected and
    acceptable values. The input values for the first test scenario are as follows
    (the input values are for demonstration purposes only):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试场景中，我们开始时缓慢而稳定，通过测试预期和可接受的值。第一个测试场景的输入值如下（输入值仅用于演示目的）：
- en: '| Input fields | Input Value (case 1) | Input Value (case 2) | Input Value
    (case 3) | Input Value (case 4) |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 输入字段 | 输入值（情况1） | 输入值（情况2） | 输入值（情况3） | 输入值（情况4） |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Name | Johnny Boy | Johnny Boy | Johnny Boy | Johnny boy |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 姓名 | Johnny Boy | Johnny Boy | Johnny Boy | Johnny boy |'
- en: '| Place of birth | San Francisco | San Francisco | San Francisco | San Francisco
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 出生地 | 旧金山 | 旧金山 | 旧金山 | 旧金山 |'
- en: '| Age | 25 | 25 | 25 | 25 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 年龄 | 25 | 25 | 25 | 25 |'
- en: '| Spending per month | 1000 | 1000 | 1000 | 1000 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 每月支出 | 1000 | 1000 | 1000 | 1000 |'
- en: '| Salary per month | 100000 | 2000 | 2000 | 100000 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 每月工资 | 100000 | 2000 | 2000 | 100000 |'
- en: '| Age at which you wish to retire | 55 | 55 | 28 | 28 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 希望退休的年龄 | 55 | 55 | 28 | 28 |'
- en: '| Amount of money I want by retirement age | 2000000 | 2000000 | 1000000 |
    100000 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 到退休年龄我想要的钱的数量 | 2000000 | 2000000 | 1000000 | 100000 |'
- en: Take note of the input values that are underlined. These input values are designed
    to determine if we will get the correct response based on the input. For example,
    after entering all of the values and submitting the dynamically-generated second
    form, the input values for case 1 and case 3 will result in an output stating
    that the user will not be able to retire on time, whereas the input values for
    case 2 and 4 will result in an output stating that the user will retire on time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意下划线的输入值。这些输入值是为了确定我们是否能根据输入得到正确的响应。例如，在输入所有值并提交动态生成的第二表单后，案例1和案例3的输入值将导致输出表明用户无法按时退休，而案例2和4的输入值将导致输出表明用户可以按时退休。
- en: 'Here''s a screenshot that shows what the output looks like if the user can
    retire on time:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个截图，展示了如果用户能够按时退休，输出会是什么样子：
- en: '![Integrated testing and testing unexpected values](img/0004_04_02.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![集成测试和测试意外值](img/0004_04_02.jpg)'
- en: 'The next screenshot shows the output if the user cannot retire on time:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图展示了如果用户不能按时退休的输出：
- en: '![Integrated testing and testing unexpected values](img/0004_04_03.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![集成测试和测试意外值](img/0004_04_03.jpg)'
- en: Take note of the differences in text for the two different cases.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意两个不同案例文本的区别。
- en: For the full details of the results of the test case, open the `sample_test_plan.doc`
    file, which can be found in the `source code` folder of this chapter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看测试案例结果的详细信息，请打开`sample_test_plan.doc`文件，该文件可在本章的`source code`文件夹中找到。
- en: 'Now it''s time for the second test scenario. In the second test scenario, we
    first finish filling up the values in the first form. Before we submit the second
    form, which was created dynamically, we will attempt to change the values. The
    input values will include the values that we have used for both white box testing
    and black box testing. The input values for the first test scenario are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是第二个测试场景的时间。在第二个测试场景中，我们首先填写第一个表单的值。在我们提交由动态创建的第二表单之前，我们将尝试更改值。输入值将包括我们用于白盒测试和黑盒测试的值。第一个测试场景的输入值如下：
- en: '| Input fields | Input value of first form | Input Value the second form (random
    values) |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 输入字段 | 第一表单的输入值 | 第二表单的输入值（随机值） |'
- en: '| --- | --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Name | Johnny Boy | 25 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 姓名 | Johnny Boy | 25 |'
- en: '| Place of birth | San Francisco | 100 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 出生地 | 旧金山 | 100 |'
- en: '| Age | 25 | Johnny Boy |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 年龄 | 25 | Johnny Boy |'
- en: '| Spending per month | 1000 | Some characters |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 每月支出 | 1000 | 一些字符 |'
- en: '| Salary per month | 100000 | More characters |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 每月工资 | 100000 | 更多字符 |'
- en: '| Age at which you wish to retire at | 20 | Even more characters |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 希望退休的年龄 | 20 | 更多信息 |'
- en: '| Amount of money I want by retirement age | 1000000 | 1000000 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 到退休年龄我想要的钱的数量 | 1000000 | 1000000 |'
- en: The main objective of this phase of the test is to test the robustness of the
    second form, which we have not verified up to this point of time. If the second
    form fails, we will need to change our code to enhance the robustness of our program.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试阶段的目的是测试第二表单的健壮性，这一点我们到目前为止还没有验证。如果第二表单失败，我们将需要更改我们的代码以增强我们程序的健壮性。
- en: We'll now move on to the next component of our test plan—errors or bugs found.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进入我们测试计划的下一个部分——发现的错误或bug。
- en: Bug form
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误表单
- en: The last component helps us to record the bugs that we have found. This area
    allows us to take note of what the errors are, what caused them, and the function
    or feature in which these errors occurred. In general, whenever we spot an error,
    we need to take note of the exact function that resulted in the error, and comment
    on what the possible solutions may be.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分帮助我们记录我们找到的bug。这个区域允许我们记录错误是什么，它们是由什么引起的，以及这些错误发生的功能或特性。通常，无论我们发现什么错误，我们都需要记录导致错误的确切功能，并评论可能的解决方案。
- en: Summary of our test plan
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试计划的总结
- en: The components introduced above are some of the most important components of
    a test plan. In general, for each phase of the test, we have stated our test data
    and our expected output. Note that we are using this documentation as an informal
    way of reminding ourselves of what tests needs to be done, the required inputs,
    expected outputs, and more importantly the bugs that we have found. One thing
    not mentioned in this sample documentation is the action to be performed for those
    bugs that are discovered; this will be covered in the next chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 上面介绍的组件是测试计划中最重要的组件之一。通常对于测试的每个阶段，我们都明确指出了我们的测试数据和预期输出。请注意，我们使用这份文档作为一种非正式的方式提醒我们需要做哪些测试，所需的输入、预期的输出，更重要的是我们发现的缺陷。这份样本文档没有提到的是对于发现那些缺陷需要执行的操作，这将在下一章节中介绍。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We effectively carried out the planning process for our test plan. Although
    our test plan is informal, we have seen how we can apply various testing concepts,
    coupled with different test data values to test our program that we have created
    in previous chapters.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有效地完成了测试计划的规划过程。尽管我们的测试计划是非正式的，我们看到了如何应用各种测试概念，结合不同的测试数据值来测试我们之前章节中创建的程序。
- en: 'Specifically, we covered the following topics:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了以下主题：
- en: We first started off with a brief introduction to the key aspects of software
    engineering. We've learned that testing takes place after the implementation (coding)
    stage.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先从对软件工程关键方面的简要介绍开始。我们了解到测试发生在实现（编码）阶段之后。
- en: We've learned to define the scope of our test by asking what our code is suppose
    to do, making sure that it does what it is supposed to do, and finally testing
    for invalid actions by users.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何通过询问我们的代码应该做什么来定义测试范围，确保它做它应该做的事情，最后通过测试用户无效行为来测试。
- en: Next we covered various testing concepts such as white box testing, black box
    testing, unit testing, web page testing, performance testing, integrated testing,
    and regression testing.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来我们介绍了各种测试概念，如白盒测试、黑盒测试、单元测试、网页测试、性能测试、集成测试和回归测试。
- en: We also learnt that we need to test our program from different aspects, thus
    enhancing the robustness of the program.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还学会了我们需要从不同的方面测试我们的程序，从而增强程序的健壮性。
- en: 'Although the testing concepts introduced in this chapter may be different in
    certain aspects, we can group them as: testing expected but acceptable values,
    expected but unacceptable values, and unexpected values in general. We''ve also
    learnt to test for logical errors based on our understanding of the code that
    we have written.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这一章节中介绍的测试概念在某些方面可能有所不同，我们可以将它们归类为：测试预期但可接受的值、预期但不可接受的值和一般意义上的意外值。我们还学会了根据对编写代码的理解来测试逻辑错误。
- en: Finally we planned and documented our test plan, which includes the test process
    description, test values, expected output and other important components, such
    as versioning and a bug form.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后我们规划并记录了我们的测试计划，其中包括测试过程描述、测试值、预期输出等重要的组成部分，如版本控制和缺陷表单。
- en: Although testing methodologies can be substantially different depending on organization
    types and types of applications, the methods that are listed here are generally
    more suitable for lightweight web applications. However, the concepts also form
    the building blocks of large-scale, complex web applications.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试方法可以根据组织类型和应用程序类型有显著不同，但这里列出的一些方法通常更适合轻量级的网页应用。然而，这些概念也是构建大规模、复杂的网页应用的基础。
- en: This chapter marks the end of planning for your test. Now brace yourself as
    we move on to the next chapter, where we will carry out the test plan.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节标志着测试计划工作的结束。现在请准备好，我们将继续进入下一章节，在那里我们将执行测试计划。
