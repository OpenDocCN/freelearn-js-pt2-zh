- en: Chapter 11. Integrating with Other Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章．与其他库集成
- en: A UI framework never lives on its own, especially a web framework. The web being
    such a rich platform and being driven by such a dynamic community, there are thousands
    of libraries, widgets, and components out there that can be leveraged in countless
    scenarios, and which save developers tremendous amounts of time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UI框架永远不会独自存在，尤其是Web框架。由于Web是一个丰富的平台，并且由一个充满活力的社区推动，因此有数千个库、小部件和组件可以在这个平台上无数的场景中
    leverage，这大大节省了开发人员的时间。
- en: In this chapter, we will see how we can integrate various libraries into our
    contact-management application. We'll add UI widgets from both Bootstrap and jQuery
    UI, some drag and drop support using `sortable.js`, and graphs using D3\. We'll
    also see how we can leverage SASS instead of CSS. Finally, we'll even see how
    we can integrate Polymer components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何将各种库集成到我们的联系人管理应用程序中。我们将添加来自Bootstrap和jQuery UI的UI小部件，使用`sortable.js`提供一些拖放支持，以及使用D3的图表。我们还将了解如何利用SASS而不是CSS。最后，我们甚至将了解如何集成Polymer组件。
- en: Using Bootstrap widgets
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bootstrap小部件
- en: Since the beginning of this book, we have relied on Bootstrap to style and lay
    out our application. However, we haven't used the library's JS widgets. Let's
    see how we can integrate such widgets into our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从这本书的开头到现在，我们一直依赖于Bootstrap来为我们的应用程序样式和布局。然而，我们还没有使用库的JS小部件。让我们看看我们如何可以将此类小部件集成到我们的应用程序中。
- en: Loading the library
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载库
- en: 'Since jQuery is used by Bootstrap''s JS widgets, we''ll first need to install
    it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Bootstrap的JS小部件使用jQuery，所以我们首先需要安装它：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to add jQuery and Bootstrap JS resources to the vendor bundle:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将jQuery和Bootstrap JS资源添加到供应商包中：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we add jQuery to the bundle's dependencies, then we update the entry for
    Bootstrap so the JS widgets are loaded after jQuery is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在包的依赖项中添加了jQuery，然后更新了Bootstrap的条目，以便在jQuery之后加载JS小部件。
- en: The `bootstrap` module in the application is also configured to export the global
    `jQuery` object. This means that we'll be able to import the `jQuery` object from
    `bootstrap` in our JS code, and we'll be sure that the Bootstrap widgets have
    been registered on jQuery.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的`bootstrap`模块也配置为导出全局`jQuery`对象。这意味着我们可以在JS代码中从`bootstrap`导入`jQuery`对象，并确保Bootstrap小部件已经注册到jQuery上。
- en: Creating a bs-tooltip attribute
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个bs-tooltip属性
- en: 'Let''s go over a simple example of using a Bootstrap JS widget with Aurelia.
    We''ll create a custom attribute that will encapsulate the Bootstrap `tooltip`
    widget:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看如何使用Bootstrap JS小部件与Aurelia配合。我们将创建一个自定义属性，它将封装Bootstrap的`tooltip`小部件：
- en: '`src/resources/attributes/bs-tooltip.js`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/attributes/bs-tooltip.js`'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we start by importing the jQuery global object from Bootstrap. This will
    ensure that the Bootstrap JS library was properly loaded and registered to the
    jQuery namespace. We also declare the list of properties supported by the `tooltip`
    widget, so the attribute can use dynamic options and just ignore unsupported options.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从Bootstrap中导入jQuery全局对象。这将确保Bootstrap JS库已正确加载并注册到jQuery命名空间中。我们还声明了`tooltip`小部件支持的属性列表，因此属性可以使用动态选项，并忽略不支持的选项。
- en: 'We''ll use dynamic options instead of explicit options, just to write less
    code. We''ll write some change-handler methods next, and if we use an explicit
    list of properties, all declared as bindable on the `BsTooltipCustomAttribute`
    class, we will have to write a distinct change handler for each property. All
    those change handlers will do pretty much the same thing: update the corresponding
    option on the Bootstrap widget. Instead, since we use dynamic options, we can
    write a single change handler that will be called for all options.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用动态选项而不是显式选项，只是为了少写一些代码。我们接下来会写一些更改处理方法，如果我们使用一个显式的属性列表，在`BsTooltipCustomAttribute`类中全部声明为可绑定的，我们将为每个属性编写一个不同的更改处理器。所有这些更改处理器都会做几乎相同的事情：更新Bootstrap小部件的相应选项。相反，由于我们使用动态选项，我们可以为所有选项编写一个单一的更改处理器。
- en: We can now create a custom attribute, named `bs-tooltip`. It receives as a constructor
    argument the DOM element on which it is placed. When attached to the DOM, it assigns
    the value bound to the attribute for each supported property to an `init` object.
    This object is then passed to the `tooltip` initialization method, which is called
    on the element hosting the attribute. This last line will create the `tooltip`
    widget.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个名为`bs-tooltip`的自定义属性。它作为构造函数参数接收放置它的DOM元素。当附加到DOM时，它将传递给属性的每个支持属性的值分配给一个`init`对象。然后这个对象被传递到`tooltip`初始化方法，该方法在属性托管的元素上调用。最后一行将创建`tooltip`小部件。
- en: Finally, when detached from the DOM, it just calls the `destroy` method on the
    `tooltip` widget.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当从DOM中分离时，它只是调用`tooltip`小部件的`destroy`方法。
- en: 'This first version of the `bs-tooltip` attribute doesn''t support updating
    properties. This can be added by using the `propertyChanged` callback method to
    update the `tooltip` widget:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`bs-tooltip`属性的这个第一个版本不支持更新属性。这可以通过使用`propertyChanged`回调方法来更新`tooltip`小部件来实现：'
- en: '`src/resources/attributes/bs-tooltip.js`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/attributes/bs-tooltip.js`'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, when the value of a property changes and the attribute is currently attached
    to the DOM, we first make sure that the property is supported by the widget, then
    we simply update the widget's property.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当属性值发生变化且属性当前附加到DOM时，我们首先确保属性被小部件支持，然后我们简单地更新小部件的属性。
- en: Using the attribute
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用属性
- en: 'We can now add a Bootstrap `tooltip` to any element. Let''s replace the **Remove**
    button''s `title` attribute with a Bootstrap `tooltip` in the `list-editor` component:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向任何元素添加Bootstrap`tooltip`。让我们在`list-editor`组件中将**移除**按钮的`title`属性替换为Bootstrap`tooltip`：
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.html`'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we simply remove the `t="[title]..."` attribute from the **Remove** button
    and replace it with a `bs-tooltip` attribute. In this attribute, we define a `title`
    option, to which we bind the result of the same translation as before. The fact
    that we use the `.bind` command and the `t` binding behavior will cause the tooltip's
    `title` to be updated when the current locale changes. We also specify that the
    `tooltip` should be placed to the `right` of the hosting element using the `placement`
    option.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将**移除**按钮的`t="[title]..."`属性删除，并用`bs-tooltip`属性替换它。在这个属性中，我们定义了一个`title`选项，将其绑定到前面相同的翻译结果。我们使用`.bind`命令和`t`绑定行为，当当前区域发生变化时，将更新工具提示的`title`。我们还指定`tooltip`应该放置在托管元素的`right`侧，使用`placement`选项。
- en: Do not forget to load the `bs-tooltip` attribute, either as a global resource
    in the `resources` feature's `configure` function, or in the template of `list-editor`
    using a `require` statement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记加载`bs-tooltip`属性，可以作为`resources`特性中的`configure`函数的全球资源，或者在`list-editor`模板中使用`require`语句来加载。
- en: If you run the application at this point and hover over a **Remove** button
    in one of the `list-editor` instances with your mouse, a Bootstrap `tooltip` widget
    should show up.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候运行应用程序，并用鼠标悬停在一个`list-editor`实例中的**移除**按钮上，应该会出现一个Bootstrap`tooltip`小部件。
- en: Creating a bs-datepicker element
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建bs-datepicker元素
- en: One widget our contact-management application could greatly benefit from is
    a date picker. This would make entering a birthday much more comfortable for most
    users.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们联系人管理应用程序可以极大地受益于的一个小部件是一个日期选择器。这会让大多数用户输入生日变得更加方便。
- en: Bootstrap doesn't include a date picker per se, but some are available as plugins.
    In this section, we'll install the `bootstrap-datepicker` plugin, load it, and
    create a new custom element that will encapsulate an `input` element hosting a
    date picker.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap本身并不包括日期选择器，但有些作为插件提供。在本节中，我们将安装`bootstrap-datepicker`插件，加载它，并创建一个新的自定义元素，该元素将封装一个包含日期选择器的`input`元素。
- en: Installing the bootstrap-datepicker plugin
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装bootstrap-datepicker插件
- en: 'We''ll first install the Bootstrap plugin:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装Bootstrap插件：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to add it to the vendor bundle:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将其添加到供应商包中：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we add the `bootstrap-datepicker` library to the vendor bundle. Just like
    the standard Bootstrap widgets, this plugin adds new functions on the jQuery object,
    so it needs to have a dependency on jQuery so it can register itself. It also
    loads its own stylesheet as an additional resource.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`bootstrap-datepicker`库添加到供应商包中。与标准的Bootstrap小部件一样，这个插件在jQuery对象上添加了新的函数，所以它需要有一个对jQuery的依赖，这样它才能注册自己。它还作为额外的资源加载自己的样式表。
- en: Creating the custom element
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义元素
- en: Now that the plugin is ready to be used, we can start building the custom element.
    Our `bs-datepicker` element will expose a two-way bindable `date` property, which
    will be assigned the selected date as a `Date` object. It will also expose a bindable
    `options` property, which will be used to provide the options passed to the underlying
    `bootstrap-datepicker` widget instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已经准备好使用，我们可以开始构建自定义元素了。我们的`bs-datepicker`元素将暴露一个双向绑定的`date`属性，它将分配选定的日期作为`Date`对象。它还将暴露一个可绑定的`options`属性，我们将用它来提供传递给底层`bootstrap-datepicker`小部件实例的选项。
- en: 'First, let''s write its template:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写它的模板：
- en: '`src/resources/elements/bs-datepicker.html`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/bs-datepicker.html`'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This template simply requires the stylesheet `bootstrap-datepicker`, then declares
    an `input` element. A reference to this `input` will be assigned to the binding
    context's `input` property, so the view-model can use it to host the date picker.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板只需要样式表`bootstrap-datepicker`，然后声明一个`input`元素。这个`input`的引用将被分配给绑定上下文的`input`属性，以便视图模型可以使用它来托管日期选择器。
- en: 'Next, let''s write the view-model class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写视图模型类：
- en: '`src/resources/elements/bs-datepicker.js`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/bs-datepicker.js`'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We start by importing the global jQuery object from Bootstrap; remember, we
    configured the Bootstrap library so it exports the jQuery object when we added
    it to the vendor bundle to write the `bs-tooltip` attribute.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要从Bootstrap中导入全局jQuery对象；记住，我们在将Bootstrap库添加到vendor bundle中时，它导出了jQuery对象，以便我们编写`bs-tooltip`属性。
- en: Next, we load the `bootstrap-datepicker` plugin so it is properly registered
    to jQuery, then create the custom element's class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们加载`bootstrap-datepicker`插件，使其正确注册到jQuery中，然后创建自定义元素的类。
- en: It first declares a static `defaultOptions` property, which is used to set the
    default values for the options passed to the widget when creating it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先声明一个静态的`defaultOptions`属性，用于在创建小部件时设置选项的默认值。
- en: When the element is attached to the DOM, it creates a `datepicker` widget instance
    on the `input`. It also subscribes to the widget's `clearDate` and `changeDate`
    events, so it can update its own `date` property when the widget's selected date
    changes; then it initializes the widget's selected date.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素附加到DOM时，它在`input`上创建一个`datepicker`小部件实例。它还订阅了小部件的`clearDate`和`changeDate`事件，这样当小部件的选定日期发生变化时，它可以更新自己的`date`属性；然后初始化小部件的选定日期。
- en: You may wonder why we add those event listeners and why we don't just bind to
    the value of `input`. That's because the widget already handles validation of
    the value of `input` and its parsing as a `Date` object, so it is much simpler
    for our custom element to rely on the selected date of `datepicker`. Basically,
    our custom element just bridges its `date` bindable property with the selected
    date of `datepicker`. When the widget's selected date changes, one of the event
    listeners is triggered and the widget's new value is assigned to the element's
    `date` property. Similarly, since the element's `date` property uses two-way binding
    by default, when the `date` property changes, mostly when initializing the element
    when used in a template, the `dateChanged` method is called by the binding system
    and the widget's selected date is updated. We additionally use an `isUpdating`
    property to prevent infinite update loops between the element and the widget.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道我们为什么添加这些事件监听器，为什么不直接绑定到`input`的值。那是因为小部件已经处理了`input`值的验证及其作为`Date`对象的解析，所以我们的自定义元素只需依赖于日历的选定日期即可。基本上，我们的自定义元素只是将其`date`可绑定属性与日历的选定日期桥接起来。当小部件的选定日期发生变化时，其中一个事件监听器会被触发，并将小部件的新值分配给元素的`date`属性。同样，由于元素的`date`属性默认使用双向绑定，当`date`属性发生变化时，通常是在模板中使用元素时进行初始化，绑定系统将调用`dateChanged`方法，并更新小部件的选定日期。此外，我们使用一个`isUpdating`属性来防止元素和小部件之间发生无限循环更新。
- en: When the element is detached from the DOM, it first unsubscribes from the widget's
    `clearDate` and `changeDate` events, then calls its `destroy` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素从DOM中分离时，它首先取消订阅小部件的`clearDate`和`changeDate`事件，然后调用其`destroy`方法。
- en: Finally, when the element's `options` property changes, the widget is destroyed
    then recreated. This is because, at the time of writing, the `bootstrap-datepicker`
    plugin doesn't offer any API to update a widget's options after its creation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当元素的`options`属性发生变化时，小部件会被销毁然后重新创建。这是因为，在撰写本文时，`bootstrap-datepicker`插件没有提供任何API来更新小部件的选项。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, this element manually handles data binding between Aurelia and
    the Bootstrap widget. The patterns you see here, registering event handlers on
    the widget, and synchronizing data back and forth, are pretty common when integrating
    an external UI library in Aurelia.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个元素手动处理了Aurelia与Bootstrap小部件之间的数据绑定。这里看到的模式，在小部件上注册事件处理程序，以及前后同步数据，都是在Aurelia中整合外部UI库时相当常见的。
- en: 'A group in the Aurelia community is doing some pretty interesting work in this
    area. They develop what they call bridges, allowing us to use various UI frameworks
    in Aurelia applications. They have already released such a bridge for Kendo UI,
    and are working on bridges for Bootstrap and Materialize, among others. I suggest
    you take a look at their work if you''re interested in the subject: [https://github.com/aurelia-ui-toolkits](https://github.com/aurelia-ui-toolkits).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia社区中的一群人在这个领域做一些非常有趣的工作。他们开发了一种他们称之为桥梁的东西，允许我们在Aurelia应用程序中使用各种UI框架。他们已经发布了一个针对Kendo
    UI的桥梁，正在为Bootstrap和Materialize等开发桥梁。如果你对这个问题感兴趣，我建议你看看他们的工作：[https://github.com/aurelia-ui-toolkits](https://github.com/aurelia-ui-toolkits)。
- en: Using the element
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用元素
- en: 'We can now easily replace the `input` bound to the contact''s birthday in the
    `form` component with our new `bs-datepicker` element:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地将`form`组件中绑定到联系人生日的`input`替换为我们新的`bs-datepicker`元素：
- en: '`src/contacts/components/form.html`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/form.html`'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we simply replace the previous `input` element with a `bs-datepicker`
    element. We bind the element's `date` property to the `birthday` property of `contact`,
    decorating the binding with the `validate` binding behavior so the property is
    still validated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地将之前的`input`元素替换为`bs-datepicker`元素。我们将元素的`date`属性绑定到`contact`的`birthday`属性上，用`validate`绑定行为装饰这个绑定，以便属性仍然受到验证。
- en: 'Since our new element''s `date` property expects a `Date` object and not a
    string value, we need to change the `Contact` model class, so it parses its `birthday`
    property into a `Date` instance when created from a JS object. Additionally, we
    need to change the default value of `birthday` from an empty string to `null`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们新元素的这个`date`属性期待的是一个`Date`对象，而不是一个字符串值，我们需要改变`Contact`模型类，使其在从JS对象创建时解析它的`birthday`属性为一个`Date`实例。另外，我们需要将`birthday`的默认值从空字符串改为`null`：
- en: '`src/contacts/models/contact.js`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/models/contact.js`'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the `birthday` property of `Contact` instances will be either `null` values
    or a `Date` object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Contact`实例的`birthday`属性将是`null`值或`Date`对象。
- en: At this point, if you run the application, navigate to the creation or edition
    component, and give the focus to the birthday `input`, the date picker should
    show up. You should be able to navigate through the calendar and select a date.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果你运行应用程序，导航到创建或编辑组件，并将焦点给予生日的`input`，日历选择器应该会出现。你应该能够导航日历并选择一个日期。
- en: Do not forget to load the `bs-datepicker` element, either as a global resource
    in the `resources` feature's `configure` function, or in the `form` template using
    a `require` statement.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记加载`bs-datepicker`元素，无论是作为`resources`特性中的`configure`函数中的全局资源，还是在`form`模板中使用`require`语句。
- en: Internationalizing the bs-datepicker element
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 国际化bs-datepicker元素
- en: At this point, our `bs-datepicker` element doesn't support internationalization.
    In a typical real-world application, the format of the date displayed in the input,
    and the calendar's texts and properties, such as the first day of the week, should
    be localized.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们的`bs-datepicker`元素还不支持国际化。在典型的实际应用中，输入中显示的日期的格式，以及日历中的文本和属性，如一周的第一天，应该是本地化的。
- en: Thankfully, the `bootstrap-datepicker` contains localization data as additional
    JS modules. We simply need to include the modules for the locales we need in the
    bundles.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`bootstrap-datepicker`包含作为额外JS模块的本地化数据。我们只需要在捆绑包中包含我们需要本地化的模块。
- en: Reconfiguring bundling of jQuery and Bootstrap
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新配置jQuery和Bootstrap的捆绑
- en: 'However, at the time of writing, the localized modules don''t support module-loading
    mechanisms, but rely exclusively on the jQuery object being on the global scope.
    As such, we need to change the way we use jQuery and the Bootstrap widgets by
    loading them not as AMD modules but as global libraries, using the vendor bundle''s
    `prepend` property:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在撰写本文时，本地化的模块不支持模块加载机制，而完全依赖于jQuery对象处于全局作用域中。因此，我们需要改变使用jQuery及Bootstrap小部件的方式，不是作为AMD模块加载，而是作为全局库加载，利用供应商捆绑包的`prepend`属性：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we add jQuery, the Bootstrap widgets, the `bootstrap-datepicker` plugin,
    and its French localization module to the prepended libraries of the bundle (the
    English localization data being built into the plugin itself, so we don't need
    to include it). This means that those libraries will simply be merged at the beginning
    of the bundle, without being loaded as AMD modules, but using the global `window`
    scope. Of course, this means the entries for jQuery, Bootstrap, and the date-picker
    plugin must be removed from the `dependencies` array.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向捆绑包的预加载库中添加了jQuery、Bootstrap小部件、`bootstrap-datepicker`插件及其法语本地化模块（英语本地化数据已内置在插件本身中，因此我们不需要包含它）。这意味着那些库将简单地合并到捆绑包的开头，而不是作为AMD模块加载，而是使用全局`window`作用域。当然，这意味着必须从`dependencies`数组中删除jQuery、Bootstrap和日期选择器插件的条目。
- en: 'Since the prepended libraries can only be JS files, this also means we must
    change the way we load the Bootstrap stylesheet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于预加载的库只能是JS文件，这也意味着我们必须改变加载Bootstrap样式表的方式：
- en: '`index.html`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, the `require` statements for `bootstrap.css` and `bootstrap-datepicker3.standalone.css`
    must be respectively removed from the `src/app.html` and the `src/resources/elements/bs-datepicker.html`
    templates.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，必须分别从`src/app.html`和`src/resources/elements/bs-datepicker.html`模板中删除对`bootstrap.css`和`bootstrap-datepicker3.standalone.css`的`require`声明。
- en: Finally, the `import` statements for `bootstrap` and `bootstrap-datepicker`
    must be removed from the `bs-tooltip.js` and the `bs-datepicker.js` files, since
    jQuery, Bootstrap, and the date-picker plugin will be accessed from the global
    scope.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须从`bs-tooltip.js`和`bs-datepicker.js`文件中删除对`bootstrap`和`bootstrap-datepicker`的`import`声明，因为jQuery、Bootstrap和日期选择器插件将从全局作用域访问。
- en: Updating the element
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新元素
- en: 'To localize the date-picker widget, we simply need to set the `language` option:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要本地化日期选择器小部件，我们只需设置`language`选项：
- en: '`src/contacts/components/form.html`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/form.html`'
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This means we need to add this `locale` property to the view-model of `form`.
    We also need to subscribe to the proper event, so we can update the property when
    the current locale changes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要将这个`locale`属性添加到`form`的视图模型中。我们还需要订阅适当的事件，这样我们可以在当前语言环境发生变化时更新属性：
- en: '`src/contacts/components/form.js`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/form.js`'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we start by importing the `I18N` class from the `aurelia-i18n` library
    and the `EventAggregator` class from `aurelia-event-aggregator`. We then hint
    to the DIC that they should both be injected into the view-model's constructor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从`aurelia-i18n`库导入`I18N`类和从`aurelia-event-aggregator`库导入`EventAggregator`类。然后我们向DIC暗示它们应该都被注入到视图模型的构造函数中。
- en: When the component is data-bound, we initialize the `locale` property using
    the `I18N` instance's `getLocale` method, and we subscribe to the `i18n:locale:changed`
    event, so we can keep the `locale` property up-to-date.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件进行数据绑定时，我们使用`I18N`实例的`getLocale`方法初始化`locale`属性，并订阅`i18n:locale:changed`事件，这样我们就可以保持`locale`属性的最新。
- en: Finally, when the component is unbound, we dispose of the event subscription.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当组件解绑时，我们取消事件订阅。
- en: At this point, if you run the application and play around with the birthday
    date picker while toggling the current locale back and forth between French and
    English, the date format displayed in the `input`, and the calendar's texts and
    setup should update accordingly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，如果您运行应用程序并在切换当前语言环境（在法语和英语之间）的同时尝试生日日期选择器，`input`中显示的日期格式以及日历的文本和设置应该相应地更新。
- en: Using jQuery UI widgets
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery UI小部件
- en: The jQuery UI widget library is still pretty popular. Integrating those widgets
    in an Aurelia application is pretty similar to what we just did with Bootstrap
    widgets, although not as painless, as we'll see in the following section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI小部件库仍然相当受欢迎。将那些小部件集成到Aurelia应用程序中与刚刚与Bootstrap小部件进行的操作相当相似，尽管不如Bootstrap小部件那样无痛，正如我们将在下一节中看到的那样。
- en: Let's create a `tooltip` attribute using jQuery UI, so we can compare it with
    Bootstrap's.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用jQuery UI创建一个`tooltip`属性，以便我们可以与Bootstrap的属性进行比较。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following code snippets are excerpts from the `chapter-11/samples/using-jqueryui`
    sample in the book's assets.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段是从书籍资源中的`chapter-11/samples/using-jqueryui`示例中摘录的。
- en: Installing the libraries
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装库
- en: 'We first need to install both jQuery and jQuery UI by opening a console in
    the project directory and running the following commands:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要通过在项目目录中打开控制台并运行以下命令来安装jQuery和jQuery UI：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we need to add those libraries to the vendor bundle. The simplest way
    to do this is to put them in the `prepend` section:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将这些库添加到供应商包中。最简单的方法是将它们放入`prepend`部分：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since CSS files cannot be globally loaded into the `prepend` section, let''s
    load them into the `index.html` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSS文件不能全局加载到`prepend`部分，所以让我们将它们加载到`index.html`文件中：
- en: '`index.html`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, we can now create our attribute.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们现在可以创建我们的属性。
- en: Creating a jq-tooltip attribute
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个jq-tooltip属性
- en: 'At first, our new attribute will be pretty similar to the one using Bootstrap:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们的新属性将与使用Bootstrap的那个非常相似：
- en: '`src/resources/attributes/jq-tooltip.js`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/attributes/jq-tooltip.js`'
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We start by defining the `options` that the jQuery UI `tooltip` widget supports,
    so the attribute can use dynamic options and ignore those that are not supported
    in this; the `jq-tooltip` attribute behaves exactly like the `bs-tooltip` attribute
    we created in the previous section. Next, we hint to the DI container that the
    DOM element hosting the attribute should be injected into the constructor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了`jq-tooltip`组件支持的`options`，这样属性就可以使用动态选项并忽略那些在此不支持的属性；`jq-tooltip`属性表现得与我们在上一节创建的`bs-tooltip`属性一模一样。接下来，我们提示DI容器，应该将包含属性的DOM元素注入到构造函数中。
- en: When the attribute is attached to the DOM, it retrieves the value bound to the
    attribute instance for each supported property to build an `options` object. This
    object is then passed to the `tooltip` initialization method, which is applied
    to the element hosting the attribute.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性附加到DOM时，它检索绑定到属性实例的每个支持属性的值，以构建一个`options`对象。然后将这个对象传递给`tooltip`初始化方法，该方法应用于包含属性的元素。
- en: When the attribute is detached from the DOM, the widget's `destroy` method is
    called on the element hosting the attribute.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性从DOM中移除时，在包含属性的元素上调用了小部件的`destroy`方法。
- en: 'At this point, the attribute doesn''t support property changes. Since jQuery''s
    `tooltip` widget offers an API to update options, this implementation won''t have
    to destroy and recreate the widget to update a property like the `bs-tooltip`
    attribute did:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，属性不支持属性更改。由于jQuery的`tooltip`小部件提供了一个API来更新选项，这个实现不需要销毁并重新创建小部件来更新属性，就像`bs-tooltip`属性一样：
- en: '`src/resources/attributes/jq-tooltip.js`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/attributes/jq-tooltip.js`'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we simply add the `propertyChanged` callback method, which updates the
    widget instance if the attribute is attached to the DOM and the updated property
    is supported by the widget.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地添加了`propertyChanged`回调方法，如果属性附加到DOM并且更新后的属性被小部件支持，它将更新小部件实例。
- en: 'Now that our attribute is ready, let''s replace the **Remove** button''s `title`
    attribute for a `jq-tooltip` custom attribute in the `list-editor` component:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的属性已经准备好了，让我们在`list-editor`组件中将**移除**按钮的`title`属性替换为`jq-tooltip`自定义属性：
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.html`'
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we simply put a `jq-tooltip` attribute on the proper `button` element.
    We bind its `content` property to the proper translation, which is decorated with
    the `t` binding behavior.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在正确的`button`元素上放置了一个`jq-tooltip`属性。我们将它的`content`属性绑定到正确的翻译，这被`t`绑定行为修饰。
- en: Do not forget to load the `jq-tooltip` attribute, either as a global resource
    in the `resources` feature's `configure` function, or in the `list-editor` template
    using a `require` statement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记加载`jq-tooltip`属性，要么作为`resources`特性中的`configure`函数中的全局资源，要么在`list-editor`模板中使用`require`语句加载。
- en: However, if you run the application and hover over the **Remove** button of
    a `list-editor` element with your mouse, you'll see that the `tooltip` doesn't
    show up.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你运行应用程序，并将鼠标悬停在`list-editor`元素的**移除**按钮上，你会发现`tooltip`没有显示。
- en: This is caused by a long-known limitation; some in the community would say it's
    a bug (and I would agree) in the `tooltip` widget, which forces the hosting element
    to have a `title` attribute, even if it is not used.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由一个众所周知的长久限制造成的；社区中的一些人会说这是一个bug（我会同意）在`tooltip`小部件中，它强制宿主元素具有一个`title`属性，即使它没有被使用。
- en: 'As such, let''s update the attribute and add a method to create an empty `title`
    attribute if none exists on the hosting element:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们更新属性并添加一个方法，如果宿主元素上不存在`title`属性，则创建一个空的`title`属性：
- en: '`src/resources/attributes/jq-tooltip.js`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/attributes/jq-tooltip.js`'
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now you can run the application and the `tooltip` should show up properly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行应用程序，`tooltip`应该正确显示。
- en: Using SASS instead of CSS
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SASS而不是CSS
- en: '**SASS**, which stands for Syntactically Awesome Stylesheets, is the most mature,
    stable, and powerful professional-grade CSS extension language in the world according
    to their website. Whether this claim is true or not, it is one of the most popular,
    and I can at least say that I use it a lot.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**SASS**，代表Syntactically Awesome Stylesheets，根据他们的网站，是世界上最为成熟、稳定、强大的专业级CSS扩展语言。无论这一说法是否真实，它都是非常受欢迎的，至少我可以肯定地说我使用得很多。'
- en: Using SASS instead of CSS in an Aurelia application is pretty simple, at least
    for CLI-based projects. The CLI already offers support for many CSS processors,
    such as SASS, LESS, and Stylus.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Aurelia应用中使用SASS而不是CSS相当简单，至少对于基于CLI的项目来说是这样。CLI已经提供了许多CSS处理器的支持，比如SASS、LESS和Stylus。
- en: 'Let''s recreate our contact-management application using the CLI and, in the
    creation process, enable the SASS processor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用CLI重新创建我们的联系人管理应用，并在创建过程中启用SASS处理器：
- en: '![Using SASS instead of CSS](img/image_00_001.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![使用SASS代替CSS](img/image_00_001.jpg)'
- en: You can select the default values for all the other questions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为所有其他问题选择默认值。
- en: 'Once the project has been created and the dependencies have been fetched, we
    can move the following directories and files from our working copy of the application
    to the newly created project:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成并且已经获取了依赖项，我们就可以把我们应用的工作副本中的以下目录和文件移动到新创建的项目中：
- en: '`aurelia_project/environments`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia_project/environments`'
- en: '`locales`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locales`'
- en: '`src`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`'
- en: '`index.html`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: We also need to copy the `dependencies` from the `package.json` file, and run
    another `npm install` in order to fetch all application dependencies. Finally,
    we need to copy the vendor-bundle configuration from the `aurelia_project/aurelia.json`
    file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从`package.json`文件中复制`dependencies`，并运行另一个`npm install`以获取所有的应用依赖。最后，我们需要复制`aurelia_project/aurelia.json`文件中的vendor-bundle配置。
- en: You can take a look at the `chapter-11/samples/using-sass` sample from the book's
    assets as a reference.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考书籍资源中的`chapter-11/samples/using-sass`示例。
- en: Replacing CSS with SASS
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用SASS替换CSS
- en: 'Let''s transform the CSS files in the application into SASS files, by replacing
    the `.css` extension with the `.scss` extension:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将`.css`扩展名替换为`.scss`扩展名，将应用中的CSS文件转换为SASS文件：
- en: '`src/resources/elements/list-editor.scss`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.scss`'
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the build tasks created by the CLI now include a SASS processor, every
    `.scss` file in the `src` directory will be transformed into a `.css` file with
    the same path, and will be included in the `app-bundle` under that path.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CLI创建的构建任务现在包括一个SASS处理器，`src`目录中的每个`.scss`文件都将被转换成具有相同路径的`.css`文件，并且会包含在`app-bundle`中该路径下。
- en: For example, the `resources/elements/list-editor.scss` file will be transformed
    into CSS, and the result will be bundled as `resources/elements/list-editor.css`
    in the `app-bundle`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`resources/elements/list-editor.scss`文件将被转换成CSS，结果将被打包成`app-bundle`中的`resources/elements/list-editor.css`。
- en: 'This means that the `require` statements must keep referring to stylesheets
    using the `.css` extension:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`require`语句必须保持使用`.css`扩展名引用样式表：
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.html`'
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the application at this point, everything should be styled as before.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候运行应用程序，一切应该都会像以前一样进行样式设计。
- en: Dragging and dropping with sortable
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放与可排序
- en: Sortable ([https://github.com/RubaXa/Sortable](https://github.com/RubaXa/Sortable))
    is a well-known library for drag and drop. Its simple yet powerful API makes its
    integration very easy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可排序（Sortable）（[https://github.com/RubaXa/Sortable](https://github.com/RubaXa/Sortable)）是一个知名的拖放库。其简单而强大的API使得集成变得非常容易。
- en: Let's use it in our contact-management application to allow users to reorder
    the items for `list-editor` elements using drag and drop.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的联系人管理应用中使用它，允许用户使用拖放来重新排序`list-editor`元素的项。
- en: Installing the library
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装库
- en: 'First, we need to install the library by opening a console in the project directory
    and running the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过在项目目录中打开控制台并运行以下命令来安装库：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to add it to the vendor bundle:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将其添加到vendor bundle中：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At this point, we can start using the library in our application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以在我们的应用中使用这个库。
- en: Adding drag and drop to list-editor
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给list-editor添加拖放
- en: 'Let''s first add a handle to list items. This handle will be the area where
    the users will be able to drag items up and down the list. Additionally, we need
    to add a `div` element, which will act as the container for the sortable items:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先给列表项添加一个处理程序。这个处理程序将是用户能够拖动项目上下列表的区域。此外，我们还需要添加一个`div`元素，它将作为可排序项目的容器：
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.html`'
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we start by assigning a reference on the `div` element containing the
    list items to the view-model's `container` property. This `container` will be
    required by the `sortable` API to enable drag and drop on its children. Next,
    we remove the `col-sm-offset-1` CSS class from the label column, and we add a
    sized-1 column, using Bootstrap's `col-sm-1` CSS class containing a `bars` Font
    Awesome icon and acting as a `sort-handle`, using the CSS class of the same name.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先在包含列表项的`div`元素上为视图模型的`container`属性分配一个引用。这个`container`将由`sortable` API用来启用其子元素的拖放。接下来，我们移除了标签列上的`col-sm-offset-1`
    CSS类，并添加了一个大小为1的列，使用Bootstrap的`col-sm-1` CSS类包含一个`bars` Font Awesome图标并作为`sort-handle`，使用相同名称的CSS类。
- en: 'Let''s also add a CSS rule to change the drag handle''s mouse cursor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也添加一个CSS规则来改变拖动处理器的鼠标光标：
- en: '`src/resources/elements/list-editor.css`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.css`'
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now use `sortable` to add drag and drop support:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`sortable`来添加拖放支持：
- en: '`src/resources/elements/list-editor.js`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.js`'
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we start by importing the `sortable` API. Then, when the element is attached
    to the DOM, we create a `sortable` instance on the `container` items that have
    the `le-item` CSS class. We specify to `sortable` that the item's child element
    that has the `sort-handle` CSS class should be used as the drag handle. Finally,
    when an item is dropped at a different position in the list, the `onUpdate` callback
    is triggered, in which we remove the dropped item from its previous position in
    the `items` array and then insert it back at its new position.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先导入了`sortable` API。然后，当元素附着到DOM上时，我们在具有`le-item` CSS类的`container`元素上创建一个`sortable`实例。我们指定`sortable`应该使用具有`sort-handle`
    CSS类的项目的子元素作为拖动处理程序。最后，当一个项目在列表的不同位置被放下时，触发`onUpdate`回调，在其中我们从`items`数组中删除被放下项目的前一个位置，然后将其放回新的位置。
- en: We need to use `splice` to remove then add the moved items, because Aurelia
    is unable to observe the array's index setter. It can only react to an array's
    changes by overriding the methods of `Array.prototype`, such as `splice`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`splice`来删除然后添加移动的项目，因为Aurelia无法观察数组的索引设置器。它只能通过覆盖`Array.prototype`的方法来反应数组的变化，比如`splice`。
- en: Additionally, we need to remove the `animated` CSS class from the items before
    moving them, so the CSS rules triggering the animations won't be matched. We then
    add it back using `setTimeout`, so it is only added once the templating engine
    is done removing the old view and adding the new one. This way, the animations
    that play when removing or adding items won't play when dragging and dropping
    items, which would look weird.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在移动项目之前，我们还需要删除项目上的`animated` CSS类，这样就不会触发动画的CSS规则。我们然后使用`setTimeout`将其加回来，这样只有在模板引擎完成移除旧视图并添加新视图后，它才会被添加。这样，在拖动和放下项目时，不会播放添加或删除项目的动画，这看起来会很奇怪。
- en: Finally, when the `list-editor` is detached from the DOM, we call the `destroy`
    method on the `sortable` instance, in order to prevent memory leaks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当`list-editor`从DOM中分离时，我们在`sortable`实例上调用`destroy`方法，以防止内存泄漏。
- en: At this point, you can run the application, reorder the items for one of a contact's
    list properties, and save the form. In the details view, the items should appear
    in the new order in which you put them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，您可以运行应用程序，为联系人列表属性中的一个项目重新排序，并保存表单。在详细视图中，项目应该按照您放置的顺序出现。
- en: Drawing graphs with D3
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用D3绘制图表
- en: Presenting data as a graph is yet another common need in modern applications.
    When it comes to the Web, **D3.js** is a well-known library that offers a very
    powerful API to display data in the DOM.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以图形的形式呈现数据是现代应用程序中另一个常见的需要。当涉及到Web时，**D3.js**是一个众所周知的光库，它提供了一个非常强大的API，用于在DOM中显示数据。
- en: In the following section, we'll add a tree view to our contact-management application,
    which will display the contacts grouped by address parts. Taking all the addresses
    for all contacts, the first level of nodes will be the countries, then each country
    will have its states as children, then each its cities, and so on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向我们的联系人管理应用程序添加一个树视图，该视图将按地址部分显示联系人分组。取所有联系人的所有地址，节点的第一个层次将是国家，然后每个国家将有自己的州作为子节点，然后是每个城市，依此类推。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The tree view we will build in this section is only a simple, poor example of
    what can be achieved with D3\. Go to [https://d3js.org/](https://d3js.org/) and
    browse through the hundreds of samples to see for yourself the power of this library.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将要构建的树视图只是用D3能够实现功能的一个简单、拙劣的示例。访问[https://d3js.org/](https://d3js.org/)，浏览数百个示例，亲自体验这个库的强大功能。
- en: Installing the library
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装库
- en: 'Let''s first install the library by opening a console in the project directory
    and running the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在项目目录中打开控制台并运行以下命令来安装库：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As usual, we need to add it to the vendor bundle:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们需要将其添加到供应商包中：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At this point, D3 is ready to be used.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，D3已准备好使用。
- en: Prepping the application
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备应用程序
- en: Before creating the tree itself, let's start by prepping the application around
    it. We'll add a `route` component that will load the contacts using the gateway,
    inside which we'll display the tree. We'll also add a `route` for this component
    in the contacts `main`, then add links allowing navigation back and forth between
    the list and the tree.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建树本身之前，让我们先为它周围的应用程序做好准备。我们将添加一个`route`组件，使用网关加载联系人，在其中显示树。我们还将为这个组件在联系人`main`中添加一个`route`，然后添加允许在列表和树之间导航的链接。
- en: 'Let''s start with the `route`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从`route`开始：
- en: '`src/contacts/main.js`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/main.js`'
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we simply add a `route` named `contacts-by-address` matching the `by-address`
    path and leading to the `by-address` component, which we'll create in a minute.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们简单地添加了一个名为`contacts-by-address`的`route`，匹配`by-address`路径，并指向我们将在一分钟内创建的`by-address`组件。
- en: 'Next, let''s add to the list component a link leading to the yet-nonexistent
    tree component:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在列表组件中添加一个链接，该链接指向尚不存在的树组件：
- en: '`src/contacts/components/list.html`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/list.html`'
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You probably noticed that the `title` property of the new `route` and the text
    of the new link both use new translations, the addition of which I leave as an
    exercise for the reader. As always, this chapter's sample application can be used
    as a reference.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到新`route`的`title`属性和新链接的文本都使用了新的翻译，增加的内容留给读者作为练习。像往常一样，本章节的示例应用程序可以作为参考。
- en: Finally, we'll create the `by-address` component. In order to keep things as
    decoupled as possible, we'll isolate the D3-related code in a custom element named
    `contact-address-tree`. The `by-address` component's sole responsibility will
    be to connect this custom element with the rest of the application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建`by-address`组件。为了使事情尽可能解耦，我们将D3相关代码隔离在一个名为`contact-address-tree`的自定义元素中。`by-address`组件的唯一责任将是将这个自定义元素与应用程序的其他部分连接起来。
- en: 'Let''s start with the view-model:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从视图模型开始：
- en: '`src/contacts/components/by-address.js`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/by-address.js`'
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This view-model is pretty straightforward. When activated, it uses the injected
    gateway to retrieve the full list of contacts. It also exposes a method that triggers
    navigation to a given contact's details component. This method will be called
    when clicking on a contact node in the tree.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图模型相当直接。当激活时，它使用注入的网关检索联系人的完整列表。它还暴露了一个触发导航到给定联系人的详细信息组件的方法。当在树中点击一个联系节点时，将调用这个方法。
- en: 'The template is pretty simple, as you can imagine:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 模板相当简单，正如您所想象的：
- en: '`src/contacts/components/by-address.html`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/by-address.html`'
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This template simply declares a `contact-address-tree` element, binding the
    loaded `contacts`, and calling `navigateToDetails` when a contact node is clicked.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板简单地声明了一个`contact-address-tree`元素，绑定加载的`contacts`，并在点击联系节点时调用`navigateToDetails`。
- en: 'The CSS file simply sets the size of the `contact-address-tree` element:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: CSS文件简单地设置了`contact-address-tree`元素的大小：
- en: '`src/contacts/components/by-address.css`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/by-address.css`'
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating the contact-address-tree custom element
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`contact-address-tree`自定义元素
- en: Now that everything is ready to use our new element, let's create it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪，我们可以使用我们新的元素了，现在让我们创建它。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since we're adding more contact-specialized custom elements, I suggest we create
    a new `elements` directory in the `contacts` feature, move the contact `form`
    to it, and create those new elements in it. This chapter's completed application
    sample can be used as a reference.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在添加更多专门针对联系人的自定义元素，我建议我们在`contacts`特性中创建一个新的`elements`目录，将联系人`form`移动到那里，并在其中创建这些新元素。本章完成的应用程序示例可以作为参考。
- en: 'We''ll start by laying out some CSS rules, which will style various tree parts,
    such as branch nodes, leaf nodes, and links:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过一些CSS规则来布局，这些规则将样式化树的各个部分，如分支节点、叶节点和链接：
- en: '`src/contacts/elements/address-tree.css`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-tree.css`'
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since the rendering of the tree view will be handled by the D3 API, the custom
    element doesn''t need a template. As such, it will be declared with the `noView`
    decorator, to which the path to the CSS file will be passed, so it is loaded as
    a resource:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于树视图的渲染将由D3 API处理，自定义元素不需要模板。因此，它将被声明为带有`noView`装饰器，传递CSS文件的路径给它，以便作为资源加载：
- en: '`src/contacts/elements/address-tree.js`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-tree.js`'
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Additionally, the view-model's constructor will be injected into the DOM element
    itself, so the D3 API can use it as a viewport to render the tree. It also exposes
    a `contacts` and a `click` bindable property.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，视图模型的构造函数将被注入到DOM元素本身，因此D3 API可以用它作为视口来渲染树。它还暴露了一个`contacts`和一个`click`可绑定属性。
- en: 'This is for the Aurelia part. Now, let''s add an `attached` method, which will
    render the tree inside the element. The code inside this method will be completely
    ignorant of Aurelia, and will simply work with the `d3` API and the DOM `element`
    itself:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Aurelia部分的内容。现在，我们添加一个`attached`方法，它将在元素内部渲染树。这个方法里面的代码将完全不知道Aurelia，只是简单地与`d3`
    API和DOM `element`本身一起工作：
- en: '`src/contacts/elements/address-tree.js`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-tree.js`'
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code is a simplified adaptation of Mike Bostock's sample, found at [https://bl.ocks.org/mbostock/4339083](https://bl.ocks.org/mbostock/4339083).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是Mike Bostock示例的简化改编，可以在[https://bl.ocks.org/mbostock/4339083](https://bl.ocks.org/mbostock/4339083)找到。
- en: It is way beyond the scope of this book to explain in detail how the `d3` API
    works. However, the inline comments in the previous code snippet can give you
    a good idea of how it works.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 详细解释`d3` API如何工作超出了本书的范围。然而，前一个代码片段中的内联注释可以让你对它如何工作有一个大致的了解。
- en: 'Chances are that you noticed some missing pieces: the `createAddressTree` and
    the `onNodeClicked` methods don''t exist yet.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了一些缺失的部分：`createAddressTree`和`onNodeClicked`方法还没有存在。
- en: 'The latter is pretty simple:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 后者相当简单：
- en: '`src/contacts/elements/address-tree.js`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-tree.js`'
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method simply makes sure that the clicked node is a contact node, and that
    the `click` property was properly bound before calling it with the clicked `contact`
    object. This will execute the expression bound using the `.call` command to the
    `click` property, passing to it the node's contact as a `contact` argument.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是确保被点击的节点是联系人节点，并且`click`属性已经被正确绑定，然后用被点击的`contact`对象调用它。这将执行用`.call`命令绑定到`click`属性的表达式，把它作为`contact`参数传递给属性。
- en: 'The former is a little more complicated. Its job is to transform a list of
    contacts into a tree data structure that will act as the data source for the `d3`
    API:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前者要稍微复杂一点。它的任务是将联系人列表转换为树数据结构，这将作为`d3` API的数据源：
- en: '`src/contacts/elements/address-tree.js`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-tree.js`'
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the `createAddressTree` method starts by creating a root node with an
    empty list of `children`. It then loops over every contact's `addresses` and,
    for each of them, creates a path of nodes for the address, starting from the country
    and drilling down to the street number. Nodes for the whole path or for a part
    of it that already exists are not created again but simply retrieved. Finally,
    a leaf node for the contact itself is appended to the last node in the path, which
    is the one for the street number.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`createAddressTree`方法首先创建一个带有空`children`列表的根节点。然后，它遍历每个联系人的`addresses`，为每个地址创建一个节点路径，从国家开始，一直深入到街道号码。整个路径或其中一部分如果已经存在，就不会再次创建节点，而是简单地检索。最后，一个代表联系人的叶节点被附加到路径中的最后一个节点，即街道号码节点。
- en: At this point, if you run the application and go to the address tree view, you
    should see the contacts show up, laid out in a tree.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，如果你运行应用程序并前往地址树视图，你应该能看到联系人显示出来，以树状布局。
- en: Using Polymer components
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Polymer组件
- en: '**Polymer** is a popular library, which is heavily biased towards web components.
    Its community offers a wide range of components, among them a `google-map` element that
    encapsulates the Google Maps API in order to display a map declaratively in HTML.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**Polymer**是一个流行的库，严重倾向于web组件。它的社区提供了各种各样的组件，其中包括一个`google-map`元素，它封装了Google
    Maps API，以便在HTML中声明性地显示地图。'
- en: Aurelia offers an integration library named `aurelia-polymer`, which allows
    the use of Polymer components inside an Aurelia application. In the following
    section, we'll integrate it into our contact-management application. In the details
    component, we'll display a small map showing the contact's address.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia提供了一个名为`aurelia-polymer`的集成库，它允许在Aurelia应用程序中使用Polymer组件。在下一节中，我们将将其集成到我们的联系人管理应用程序中。在详细信息组件中，我们将显示一个显示联系人地址的小地图。
- en: Installing the libraries
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装库
- en: 'Polymer and its libraries are typically installed using **Bower**. Bower and
    NPM can be used side by side without any problem, so let''s first install it,
    if you don''t already have it on your development environment, by opening a console
    and running the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Polymer及其库通常使用**Bower**进行安装。Bower和NPM可以毫无问题地并行使用，因此让我们首先安装它，如果你还没有在开发环境中安装它，那么通过打开一个控制台并运行以下命令：
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Bower is yet another package manager for web libraries, which can be found at
    [https://bower.io/](https://bower.io/).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Bower是另一个用于网络库的包管理器，可以在[https://bower.io/](https://bower.io/)找到。
- en: 'Once this is done, let''s create Bower''s project file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些之后，让我们创建Bower的项目文件：
- en: '`bower.json`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`bower.json`'
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This file is pretty similar to `package.json`. It describes the project's dependencies
    managed by Bower. Here, we include Polymer and the Google Maps components.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件与`package.json`非常相似。它描述了由Bower管理的项目的依赖关系。在这里，我们包括了Polymer和Google Maps组件。
- en: We also include `webcomponentjs`, which is a polyfill for various web components'
    APIs, such as the Custom Elements API and the HTML Imports API. Since those two
    APIs are required by Polymer, this polyfill is required if the browsers you target
    don't support those natively.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了`webcomponentjs`，这是各种web组件API的polyfill，例如自定义元素API和HTML Imports API。由于这两个API是Polymer所必需的，如果目标浏览器不支持这些API，则需要这个polyfill。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can check if your favorite browser supports the required APIs here: [http://caniuse.com/#feat=custom-elementsv1](http://caniuse.com/#feat=custom-elementsv1)
    and [http://caniuse.com/#feat=imports](http://caniuse.com/#feat=imports).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里检查你最喜欢的浏览器是否支持所需的API：[http://caniuse.com/#feat=custom-elementsv1](http://caniuse.com/#feat=custom-elementsv1)和[http://caniuse.com/#feat=imports](http://caniuse.com/#feat=imports)。
- en: 'Just like NPM, the packages listed in the project file must be installed. As
    such, open a console in the project directory and run the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 就像NPM一样，项目文件中列出的包必须被安装。因此，在项目目录中打开一个控制台并运行以下命令：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once this is done, the last thing we need to install is the bridge between
    Polymer and Aurelia, which is done by opening a console in the project directory
    and running the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些之后，我们需要安装的最后一样东西是Polymer和Aurelia之间的桥梁，通过在项目目录中打开一个控制台并运行以下命令来完成：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Configuring the application
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: Now that everything is installed, we need to configure our application so it
    can load Polymer components.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都安装好了，我们需要配置我们的应用程序，使其可以加载Polymer组件。
- en: 'Let''s start by adding the `aurelia-polymer` library to the vendor bundle:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将`aurelia-polymer`库添加到供应商捆绑包中：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Of course, with this library being an Aurelia plugin, we need to load it into
    our application''s main `configure` function:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于这个库是一个Aurelia插件，我们需要将其加载到我们应用程序的主要`configure`函数中：
- en: '`src/main.js`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`'
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As mentioned earlier, Polymer relies on HTML Imports. At the time of writing,
    CLI-based Aurelia applications don''t support using HTML Imports to load views.
    As such, we won''t be able to load components in the templates that need them.
    We have no choice but to load them in the `index.html` file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Polymer依赖于HTML Imports。在撰写本文时，基于CLI的Aurelia应用程序不支持使用HTML Imports加载视图。因此，我们将无法在需要它们的模板中加载组件。我们别无选择，只能将它们加载到`index.html`文件中：
- en: '`index.html`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we first load the Web Components API polyfill. This line can be removed
    if you don't need the polyfill. Next, we import Polymer and the `google-map` components.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先加载Web Components API polyfill。如果不需要polyfill，可以删除这一行。接下来，我们导入Polymer和`google-map`组件。
- en: 'In a production-ready application, importing Polymer and each component separately
    is sub-optimal. It is strongly suggested to vulcanize the components into a single
    bundle, which can be loaded in the `index.html` file: [https://github.com/Polymer/vulcanize](https://github.com/Polymer/vulcanize).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个准备生产的应用程序中，分别导入Polymer和每个组件是不理想的。强烈建议将组件进行融合，生成一个单一的包，在`index.html`文件中加载：
    [https://github.com/Polymer/vulcanize](https://github.com/Polymer/vulcanize)。
- en: At this point, integration with Polymer is up and running. The `google-map`
    element is ready to be used.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，与Polymer的集成已经运行起来。`google-map`元素已经可以使用。
- en: Displaying a Google map
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示Google地图
- en: 'Let''s start by making sure everything works by creating a custom element that
    we''ll use to display a map with a single address pinned on it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先确保一切都能正常工作，通过创建一个自定义元素来显示一个带有单个地址标记的地图：
- en: '`src/contacts/elements/address-map.html`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-map.html`'
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `google-map` Polymer component loads the Google Maps API behind the scenes.
    In order for it to load correctly, you'll need a Google Maps API key. You can
    create one by following the instructions found at [https://developers.google.com/maps/documentation/javascript/get-api-key#key](https://developers.google.com/maps/documentation/javascript/get-api-key#key).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`google-map` Polymer组件在幕后加载了Google Maps API。为了使其正确加载，你需要一个Google Maps API密钥。你可以通过遵循在
    [https://developers.google.com/maps/documentation/javascript/get-api-key#key](https://developers.google.com/maps/documentation/javascript/get-api-key#key)
    找到的说明来创建一个。'
- en: Here, we first add a button that toggles the value of the `isMapVisible` property.
    Next, we add a `google-map` Polymer element. Its `api-key` attribute should be
    set to your own Google Maps API key.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先添加一个切换`isMapVisible`属性的按钮。接下来，我们添加一个`google-map` Polymer元素。其`api-key`属性应该设置为你的Google
    Maps API密钥。
- en: 'As for the view-model, it will be almost empty for now:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 至于视图模型，现在几乎为空：
- en: '`src/contacts/elements/address-map.js`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-map.js`'
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we need to add this `address-map` element to the contact''s `details`
    component:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将这个`address-map`元素添加到联系人的`details`组件中：
- en: '`src/contacts/components/details.html`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/details.html`'
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, if you run the application and navigate to a contact's details,
    you should see a button beneath every address. If you click on it, a map should
    show up.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果你运行应用程序并导航到一个联系人的详情，你应该看到每个地址下都有一个按钮。如果你点击它，应该会弹出一个地图。
- en: Geocoding addresses
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址编码
- en: 'In order to display the address as a marker on the map, we need to get the
    geographical coordinates of the address. As such, we''ll create a new service
    named `Geocoder`, which will use **Nominatim**, a search service based on `OpenStreetMap`
    data ([http://www.openstreetmap.org/](http://www.openstreetmap.org/)), to find
    the latitude and longitude of a given address:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在地图上显示地址作为标记，我们需要获取该地址的地理坐标。因此，我们将创建一个名为`Geocoder`的新服务，它将使用基于`OpenStreetMap`数据的搜索服务**Nominatim**（[http://www.openstreetmap.org/](http://www.openstreetmap.org/)），以找到给定地址的纬度和经度：
- en: '`src/contacts/services/geocoder.js`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/services/geocoder.js`'
- en: '[PRE51]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This class starts by creating an `HttpClient` instance, using Nominatim's URL
    and the standard configuration. It then exposes a `search` method, which expects
    an `Address` object as a parameter to send a request to the Nominatim endpoint
    and return the resulting `Promise`. This `Promise` is either resolved with `null`
    if the address is not found, or with an object containing the matching position's
    `latitude` and `longitude`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类首先创建一个`HttpClient`实例，使用Nominatim的URL和标准配置。然后暴露一个`search`方法，该方法期望一个`Address`对象作为参数，向Nominatim端点发送请求并返回结果`Promise`。这个`Promise`如果找不到地址就解决为`null`，或者包含匹配位置的`latitude`和`longitude`的对象。
- en: Displaying a marker
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示标记
- en: 'Now that we can geocode the address, let''s update our `address-map` element
    to display a marker for it:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在可以进行地址编码，那就让我们更新一下`address-map`元素，显示一个标记：
- en: '`src/contacts/elements/address-map.js`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-map.js`'
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we start by injecting a `Geocoder` instance into the view-model. We also
    add a bindable `address` property. When the element is attached to the DOM, we
    geocode the address, and if its coordinates are found, we set the value of the
    `latitude` and `longitude` properties. We also set `isGeocoded` to `true`. This
    flag is initially set to `false`, and will be used to disable the toggle button
    if the address can't be localized. If the address can't be found, we hide the
    map, disable the toggle button, and reset `latitude` and `longitude` to `null`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将一个`Geocoder`实例注入到视图模型中。我们还添加了一个可绑定的`address`属性。当元素附加到DOM时，我们进行地理编码，如果找到其坐标，我们设置`latitude`和`longitude`属性的值。我们还设置`isGeocoded`为`true`。这个标志最初设置为`false`，如果地址无法定位，我们将用来禁用切换按钮。如果找不到地址，我们隐藏地图，禁用切换按钮，并将`latitude`和`longitude`重置为`null`。
- en: We also geocode each time the `address` changes after the element has been attached
    to the DOM, to keep the `latitude` and `longitude` properties up-to-date.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在元素附加到DOM之后，每次`address`发生变化时，我们还进行地理编码，以保持`latitude`和`longitude`属性的最新。
- en: 'As for the template, we don''t need to change much:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 至于模板，我们不需要做太多更改：
- en: '`src/contacts/elements/address-map.html`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-map.html`'
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we start by disabling the toggle button when `isGeocoded` is `false`.
    Next, we bind the `google-map` element's `latitude` and `longitude`, and set its
    `zoom` to `15` so it is centered on the address's location.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先在`isGeocoded`为`false`时禁用切换按钮。接下来，我们将`google-map`元素的`latitude`和`longitude`进行绑定，并将它的`zoom`设置为`15`，以便它显示在地址位置的中心。
- en: Finally, we add a `google-map-marker` element inside the `google-map` element.
    We also bind this marker's `latitude` and `longitude`, and set its `open` property
    to `true` so its info window is opened upon rendering. Inside the marker, we display
    the full address as text, which will be rendered inside the info window.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`google-map`元素内部添加一个`google-map-marker`元素。我们还绑定这个标记的`latitude`和`longitude`，并将其`open`属性设置为`true`，以便在渲染时打开其信息窗口。在标记内部，我们显示完整的地址作为文本，它将在信息窗口内渲染。
- en: You may wonder where this `google-map-marker` element comes from. In fact, the
    HTML Imports mechanism allows the loading of multiple components from a single
    file. When we imported the `bower_components/google-map/google-map.html` file
    in `index.html`, many components were registered to Polymer, among which were
    the map and the marker.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇这个`google-map-marker`元素是从哪里来的。实际上，HTML Imports机制允许从单个文件中加载多个组件。当我们 在`index.html`中导入`bower_components/google-map/google-map.html`文件时，许多组件被注册到Polymer中，其中就包括地图和标记。
- en: If you run the application at this point, navigate to a contact's details, and
    click on an address's **View map** button, a map should show up with a marker
    at the proper location and an info window displaying the full address.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候运行应用程序，导航到联系人的详细信息，然后点击地址的**查看地图**按钮，应该会出现一个带有标记在正确位置的地图，并且一个信息窗口会显示完整的地址。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'The integration of a UI library into an Aurelia application almost always follows
    the same process: you create a custom element or attribute around it. By leveraging
    Aurelia''s two-way data binding, it is not too complicated most of the time.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个UI库集成到Aurelia应用程序中几乎总是遵循相同的流程：你围绕它创建一个自定义元素或属性。利用Aurelia的双向数据绑定，大多数时候并不太复杂。
- en: This is particularly true for libraries that follow good practices and community
    standards such as supporting common module loaders, exposing data-change events,
    and having a destructor in its public API. Libraries that are older, or that do
    not follow those standards, can be more painful to integrate. Aurelia, for its
    part, makes it as easy as it can.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于遵循良好实践和社区标准库来说尤其如此，比如支持常见模块加载器、暴露数据变更事件，并在其公共API中有一个析构器。那些较老，或者不遵循这些标准的库，集成就更痛苦。Aurelia在这方面尽其所能简化。
