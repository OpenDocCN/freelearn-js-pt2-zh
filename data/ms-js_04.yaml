- en: Chapter 4. Object-Oriented JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。面向对象的JavaScript
- en: 'JavaScript''s most fundamental data type is the Object data type. JavaScript
    objects can be seen as mutable key-value-based collections. In JavaScript, arrays,
    functions, and RegExp are objects while numbers, strings, and Booleans are object-like
    constructs that are immutable but have methods. In this chapter, you will learn
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最基本的数据类型是对象数据类型。JavaScript对象可以被视为可变的基于键值对的集合。在JavaScript中，数组、函数和RegExp都是对象，而数字、字符串和布尔值是类似对象的构造，是不可变的，但具有方法。在本章中，你将学习以下主题：
- en: Understanding objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象
- en: Instance properties versus prototype properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例属性与原型属性
- en: Inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Getters and setters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: Understanding objects
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象
- en: Before we start looking at how JavaScript treats objects, we should spend some
    time on an object-oriented paradigm. Like most programming paradigms, **object-oriented
    programming** (**OOP**) also emerged from the need to manage complexity. The main
    idea is to divide the entire system into smaller pieces that are isolated from
    each other. If these small pieces can hide as many implementation details as possible,
    they become easy to use. A classic car analogy will help you understand this very
    important point about OOP.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始研究JavaScript如何处理对象之前，我们应该先花些时间来了解一下面向对象范式。像大多数编程范式一样，**面向对象编程**（**OOP**）也是为了解决复杂性而产生的。主要思想是将整个系统划分为更小的、相互隔离的部分。如果这些小部分能隐藏尽可能多的实现细节，它们就变得容易使用了。一个经典的汽车类比将帮助你理解OOP的非常重要的一点。
- en: When you drive a car, you operate on the interface—the steering, clutch, brake,
    and accelerator. Your view of using the car is limited by this interface, which
    makes it possible for us to drive the car. This interface is essentially hiding
    all the complex systems that really drive the car, such as the internal functioning
    of its engine, its electronic system, and so on. As a driver, you don't bother
    about these complexities. A similar idea is the primary driver of OOP. An object
    hides the complexities of how to implement a particular functionality and exposes
    a limited interface to the outside world. All other systems can use this interface
    without really bothering about the internal complexity that is hidden from view.
    Additionally, an object usually hides its internal state from other objects and
    prevents its direct modification. This is an important aspect of OOP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你驾驶汽车时，你在操作界面——转向、离合器、刹车和油门。你使用汽车的视角被这个界面所限制，这使得我们能够驾驶汽车。这个界面本质上隐藏了所有真正驱动汽车复杂的系统，比如它的发动机内部运作、电子系统等等。作为一名驾驶员，你不需要关心这些复杂性。这是面向对象编程（OOP）的主要驱动力。一个对象隐藏了实现特定功能的所有复杂性，并向外界暴露了一个有限的接口。所有其他系统都可以使用这个接口，而无需真正关心被隐藏的内部复杂性。此外，一个对象通常会隐藏其内部状态，不让其他对象直接修改。这是OOP的一个重要方面。
- en: In a large system where a lot of objects call other objects' interfaces, things
    can go really bad if you allow them to modify the internal state of such objects.
    OOP operates on the idea that the state of an object is inherently hidden from
    the outside world and it can be changed only via controlled interface operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型系统中，如果许多对象调用其他对象的接口，而允许它们修改这些对象的内部状态，事情可能会变得非常糟糕。OOP的基本理念是，对象的内部状态 inherently
    hidden from the outside world，并且只能通过受控的接口操作来更改。
- en: 'OOP was an important idea and a definite step forward from the traditional
    structured programming. However, many feel that OOP is overdone. Most OOP systems
    define complex and unnecessary class and type hierarchies. Another big drawback
    was that in the pursuit of hiding the state, OOP considered the object state almost
    immaterial. Though hugely popular, OOP was clearly flawed in many areas. Still,
    OOP did have some very good ideas, especially hiding the complexity and exposing
    only the interface to the outside world. JavaScript picked up a few good ideas
    and built its object model around them. Luckily, this makes JavaScript objects
    very versatile. In their seminal work, *Design Patterns: Elements of Reusable
    Object-Oriented Software*, the *Gang of Four* gave two fundamental principles
    of a better object-oriented design:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一个重要的想法，也是从传统的结构化编程向前迈出的明确一步。然而，许多人认为OOP做得过头了。大多数OOP系统定义了复杂且不必要的类和类型层次结构。另一个大的缺点是，在追求隐藏状态的过程中，OOP几乎将对象状态视为不重要。尽管OOP非常流行，但在许多方面显然是有缺陷的。然而，OOP确实有一些非常好的想法，尤其是隐藏复杂性并只向外部世界暴露接口。JavaScript采纳了一些好想法，并围绕它们构建了其对象模型。幸运的是，这使得JavaScript对象非常多功能。在他们开创性的作品中，《设计模式：可重用面向对象软件的元素》，*四人帮*给出了更好的面向对象设计两个基本原则：
- en: Program to an interface and not to an implementation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向接口编程，而不是面向实现
- en: Object composition over class inheritance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象组合优于类继承
- en: 'These two ideas are really against how classical OOP operates. The classical
    style of inheritance operates on inheritance that exposes parent classes to all
    child classes. Classical inheritance tightly couples children to its parents.
    There are mechanisms in classical inheritance to solve this problem to a certain
    extent. If you are using classical inheritance in a language such as Java, it
    is generally advisable to *program to an interface, not an implementation*. In
    Java, you can write a decoupled code using interfaces:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个想法实际上是与经典OOP的运作方式相反的。经典继承的运作方式是基于继承，将父类暴露给所有子类。经典继承紧密耦合了子类和其父类。经典继承中有机制可以在一定程度上解决这个问题。如果你在像Java这样的语言中使用经典继承，通常建议*面向接口编程，而不是面向实现*。在Java中，你可以使用接口编写松耦合的代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead of programming to an implementation, you can perform the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编程到实现，你可以执行以下操作：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'How does programming to an interface help? When you program to the `List` interface,
    you can call methods only available to the `List` interface and nothing specific
    to `ArrayList` can be called. Programming to an interface gives you the liberty
    to change your code and use any other specific child of the `List` interface.
    For example, I can change my implementation and use `LinkedList` instead of `ArrayList`.
    You can change your variable to use `LinkedList` instead:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编程到一个接口有什么帮助？当你编程到`List`接口时，你只能调用`List`接口独有的方法，不能调用`ArrayList`特定的方法。编程到一个接口给你自由改变你的代码并使用`List`接口的任何其他特定子类。例如，我可以改变我的实现并使用`LinkedList`而不是`ArrayList`。你可以将你的变量更改为使用`LinkedList`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The beauty of this approach is that if you are using the `List` at 100 places
    in your program, you don't have to worry about changing the implementation at
    all these places. As you were programming to the interface and not to the implementation,
    you were able to write a loosely coupled code. This is an important principle
    when you are using classical inheritance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，如果你在你的程序中100次使用`List`，你根本不需要担心在所有这些地方改变实现。因为你是面向接口编程，而不是面向实现，所以你能够编写松耦合的代码。当你使用经典继承时，这是一个重要的原则。
- en: 'Classical inheritance also has a limitation where you can only enhance the
    child class within the limit of the parent classes. You can''t fundamentally differ
    from what you have got from the ancestors. This inhibits reuse. Classical inheritance
    has several other problems as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 经典继承也有一个限制，即你只能在父类范围内增强子类。你不能根本区别于从祖先那里得到的东西。这阻碍了重用。经典继承还有其他几个问题，如下：
- en: Inheritance introduces tight coupling. Child classes have knowledge about their
    ancestors. This tightly couples a child class with its parent.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承引入了紧密耦合。子类对其祖先有所了解。这种紧密耦合了一个子类与其父类之间的关系。
- en: 'When you subclass from a parent, you don''t have a choice to select what you
    want to inherit and what you don''t. *Joe Armstrong* (the inventor of **Erlang**)
    explains this situation very well—his now famous quote:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你从父类继承时，你无法选择继承什么和不继承什么。*Joe Armstrong*（**Erlang**的发明者）很好地解释了这种情况——他那如今著名的名言：
- en: '*"The problem with object-oriented languages is they''ve got all this implicit
    environment that they carry around with them. You wanted a banana but what you
    got was a gorilla holding the banana and the entire jungle."*'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"面向对象语言的问题在于，它们携带的所有这些隐式环境。你想要一根香蕉，但你所得到的是一个拿着香蕉和整个丛林的大猩猩。"*'
- en: Behavior of JavaScript objects
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript对象的行为
- en: 'With this background, let''s explore how JavaScript objects behave. In broad
    terms, an object contains properties, defined as a key-value pair. A property
    key (name) can be a string and the value can be any valid JavaScript value. You
    can create objects using object literals. The following snippet shows you how
    object literals are created:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些背景知识，让我们来探讨一下JavaScript对象的行为。从广义上讲，一个对象包含属性，这些属性定义为键值对。属性键（名称）可以是字符串，值可以是任何有效的JavaScript值。你可以使用对象字面量来创建对象。以下片段展示了对象字面量是如何创建的：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A property''s name can be any string or an empty string. You can omit quotes
    around the property name if the name is a legal JavaScript name. So quotes are
    required around `first-name` but are optional around `firstname`. Commas are used
    to separate the pairs. You can nest objects as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的名称可以是任何字符串或空字符串。如果属性名是合法的JavaScript名称，你可以省略属性名周围的引号。所以`first-name`周围需要引号，但`firstname`周围可以省略引号。逗号用于分隔这些对。你可以像下面这样嵌套对象：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Properties of an object can be accessed by using two notations: the array-like
    notation and dot notation. According to the array-like notation, you can retrieve
    the value from an object by wrapping a string expression in `[]`. If the expression
    is a valid JavaScript name, you can use the dot notation using `.` instead. Using
    `.` is a preferred method of retrieving values from an object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用两种表示法来访问对象的属性：数组表示法和点表示法。根据数组表示法，你可以通过将字符串表达式包裹在`[]`中来从对象中检索值。如果表达式是一个有效的JavaScript名称，你可以使用点表示法使用`.`代替。使用`.`是从对象中检索值的首选方法：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will get an `undefined` error if you attempt to retrieve a non-existent
    value. The following would return `undefined`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试获取一个不存在的值，你会得到一个`undefined`错误。以下将返回`undefined`：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A useful trick is to use the `||` operator to fill in default values in this
    case:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的技巧是使用`||`运算符在这种情况下填充默认值：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can update values of an object by assigning a new value to the property:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将新值赋给属性来更新对象的值：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you observe closely, you will realize that the object literal syntax that
    you see is very similar to the JSON format.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会意识到你看到的对象字面量语法与JSON格式非常相似。
- en: 'Methods are properties of an object that can hold function values as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的方法是对象的属性，可以持有函数值，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Prototypes
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型
- en: Apart from the properties that we add to an object, there is one default property
    for almost all objects, called a **prototype**. When an object does not have a
    requested property, JavaScript goes to its prototype to look for it. The `Object.getPrototypeOf()`
    function returns the prototype of an object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们添加到对象上的属性外，几乎所有对象都有一个默认属性，称为**原型**。当一个对象没有请求的属性时，JavaScript会去它的原型中查找。`Object.getPrototypeOf()`函数返回一个对象的
    prototype。
- en: Many programmers consider prototypes closely related to objects' inheritance—they
    are indeed a way of defining object types—but fundamentally, they are closely
    associated with functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员认为原型与对象的继承密切相关——它们确实是一种定义对象类型的方式——但从根本上说，它们与函数紧密相关。
- en: 'Prototypes are used as a way to define properties and functions that will be
    applied to instances of objects. The prototype''s properties eventually become
    properties of the instantiated objects. Prototypes can be seen as blueprints for
    object creation. They can be seen as analogous to classes in object-oriented languages.
    Prototypes in JavaScript are used to write a classical style object-oriented code
    and mimic classical inheritance. Let''s revisit our earlier example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是用来定义将应用于对象实例的属性和函数的一种方式。原型的属性最终成为实例化对象的属性。原型可以被视为创建对象的蓝图。它们可以被视为面向对象语言中类的类似物。JavaScript中的原型用于编写经典风格的面向对象代码并模仿经典继承。让我们重新回顾一下我们之前的例子：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, we have a `player()` function that does nothing. We
    invoke it in two different ways. The first call of the function is as a normal
    function and second call is as a constructor—note the use of the `new()` operator
    in this call. Once the function is defined, we add a `usesBat()` method to it.
    When this function is called as a normal function, the object is not instantiated
    and we see `undefined` assigned to `crazyBob`. However, when we call this function
    with the `new` operator, we get a fully instantiated object, `swingJay`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，我们有一个`player()`函数，它什么也不做。我们以两种不同的方式调用它。第一个调用是作为普通函数，第二个调用作为构造函数——注意这个调用中使用了`new()`操作符。一旦函数被定义，我们向它添加了一个`usesBat()`方法。当这个函数作为普通函数调用时，对象没有被实例化，我们看到`undefined`被赋值给`crazyBob`。然而，当我们使用`new`操作符调用这个函数时，我们得到了一个完全实例化的对象，`swingJay`。
- en: Instance properties versus prototype properties
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例属性与原型属性对比
- en: 'Instance properties are the properties that are part of the object instance
    itself, as shown in the following example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属性是对象实例本身的一部分属性，如下例所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you run this example, you will see that **Instance method says - he is
    hired** is printed. The `isAvailable()` function defined in the `Player()` function
    is called an instance of `Player`. This means that apart from attaching properties
    via the prototype, you can use the this keyword to initialize properties in a
    constructor. When we have the same functions defined as an instance property and
    also as a prototype, the instance property takes precedence. The rules governing
    the precedence of the initialization are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个例子时，你会看到**实例方法说 - 他被雇佣了**被打印出来。在`Player()`函数中定义的`isAvailable()`函数被称为`Player`的实例。这意味着除了通过原型附加属性外，你还可以使用`this`关键字在构造函数中初始化属性。当我们实例属性和原型中都有相同的函数定义时，实例属性优先。决定初始化优先级的规则如下：
- en: Properties are tied to the object instance from the prototype
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性从原型绑定到对象实例。
- en: Properties are tied to the object instance in the constructor function
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性在构造函数中绑定到对象实例。
- en: 'This example brings us to the use of the `this` keyword. It is easy to get
    confused by the `this` keyword because it behaves differently in JavaScript. In
    other OO languages such as Java, the `this` keyword refers to the current instance
    of the class. In JavaScript, the value of `this` is determined by the invocation
    context of a function and where it is called. Let''s see how this behavior needs
    to be carefully understood:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子让我们了解了`this`关键字的用法。`this`关键字很容易让人混淆，因为它在JavaScript中的行为不同。在其他面向对象的编程语言（如Java）中，`this`关键字指的是类当前的实例。在JavaScript中，`this`的值由函数的调用上下文和调用位置决定。让我们看看这种行为需要如何仔细理解：
- en: 'When `this` is used in a global context: When `this` is called in a global
    context, it is bound to the global context. For example, in the case of a browser,
    the global context is usually `window`. This is true for functions also. If you
    use `this` in a function that is defined in the global context, it is still bound
    to the global context because the function is part of the global context:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在全局上下文中使用`this`：当在全局上下文中调用`this`时，它绑定到全局上下文。例如，在浏览器中，全局上下文通常是`window`。这也适用于函数。如果你在全局上下文中定义的函数中使用`this`，它仍然绑定到全局上下文，因为函数是全局上下文的一部分：
- en: '[PRE14]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When `this` is used in an object method: In this case, `this` is assigned or
    bound to the enclosing object. Note that the enclosing object is the immediate
    parent if you are nesting the objects:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象方法中使用`this`：在这种情况下，`this`被赋值或绑定到包含它的对象。注意，如果你们嵌套对象，包含对象是立即的父级：
- en: '[PRE15]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When there is no context: A function, when invoked without any object, does
    not get any context. By default, it is bound to the global context. When you use
    `this` in such a function, it is also bound to the global context.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有上下文的情况下：如果一个函数没有被任何对象调用，它不会获得任何上下文。默认情况下，它绑定到全局上下文。当你在这样一个函数中使用`this`时，它也绑定到全局上下文。
- en: 'When `this` is used in a constructor function: As we saw earlier, when a function
    is called with a `new` keyword, it acts as a constructor. In the case of a constructor,
    `this` points to the object being constructed. In the following example, `f()`
    is used as a constructor (because it''s invoked with a `new` keyword) and hence,
    `this` is pointing to the new object being created. So when we say `this.member
    = "f"`, the new member is added to the object being created, in this case, that
    object happens to be `o`:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在构造函数中使用`this`时：正如我们之前所看到的，当一个函数通过`new`关键字调用时，它充当构造函数。在构造函数的情况下，`this`指向正在构造的对象。在下面的例子中，`f()`被用作构造函数（因为它通过`new`关键字调用），因此，`this`指向正在创建的新对象。所以当我们说`this.member
    = "f"`时，新成员被添加到正在创建的对象中，在这个例子中，这个对象碰巧是`o`：
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We saw that instance properties take precedence when the same property is defined
    both as an instance property and prototype property. It is easy to visualize that
    when a new object is created, the properties of the constructor''s prototype are
    copied over. However, this is not a correct assumption. What actually happens
    is that the prototype is attached to the object and referred when any property
    of this object is referred. Essentially, when a property is referenced on an object,
    either of the following occur:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，当实例属性和原型属性同时定义同一个属性时，实例属性具有优先权。很容易想象，当创建新对象时，构造函数的原型属性会被复制过来。然而，这并不是一个正确的假设。实际发生的情况是，原型被附加到对象上，并在引用该对象的任何属性时引用它。本质上，当引用对象的属性时，以下情况之一会发生：
- en: The object is checked for the existence of the property. If it's found, the
    property is returned.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象是否具有该属性。如果找到，则返回该属性。
- en: The associated prototype is checked. If the property is found, it is returned;
    otherwise, an `undefined` error is returned.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查相关原型。如果找到属性，则返回该属性；否则，返回一个`undefined`错误。
- en: 'This is an important understanding because, in JavaScript, the following code
    actually works perfectly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的理解，因为在JavaScript中，以下代码实际上完全有效：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code is a slight variation of the earlier example. We are creating the
    object first and then attaching the function to its prototype. When you eventually
    call the `isAvailable()` method on the object, JavaScript goes to its prototype
    to search for it if it's not found in the particular object (`crazyBob`, in this
    case). Think of this as *hot code loading*—when used properly, this ability can
    give you incredible power to extend the basic object framework even after the
    object is created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是之前示例的稍微变体。我们首先创建一个对象，然后将其函数附加到原型上。当你最终在对象上调用`isAvailable()`方法时，如果在该对象中找不到它（在这个例子中是`crazyBob`），JavaScript会到其原型中寻找。你可以将其视为*热代码加载*——如果使用得当，这种能力可以在对象创建后为你提供巨大的扩展基本对象框架的权力。
- en: 'If you are familiar with OOP already, you must be wondering whether we can
    control the visibility and access of the members of an object. As we discussed
    earlier, JavaScript does not have classes. In programming languages such as Java,
    you have access modifiers such as `private` and `public` that let you control
    the visibility of the class members. In JavaScript, we can achieve something similar
    using the function scope as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉面向对象编程（OOP），你可能想知道我们是否能控制对象成员的可见性和访问权限。正如我们之前讨论的，JavaScript没有类。在像Java这样的编程语言中，你有访问修饰符，如`private`和`public`，可以让你控制类成员的可见性。在JavaScript中，我们可以使用函数作用域实现类似的功能：
- en: You can declare private variables using the `var` keyword in a function. They
    can be accessed by private functions or privileged methods.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在函数中使用`var`关键字声明私有变量。它们可以通过私有函数或特权方法访问。
- en: Private functions may be declared in an object's constructor and can be called
    by privileged methods.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有函数可以在对象的构造函数中声明，并且可以通过特权方法调用。
- en: Privileged methods can be declared with `this.method=function() {}`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权方法可以通过`this.method=function() {}`声明。
- en: Public methods are declared with `Class.prototype.method=function(){}`.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共方法通过`Class.prototype.method=function(){}`声明。
- en: Public properties can be declared with `this.property` and accessed from outside
    the object.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共属性可以用`this.property`声明，并从对象外部访问。
- en: 'The following example shows several ways of doing this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了几种实现方式：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s understand a few important concepts from this example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个例子中理解一些重要的概念：
- en: The `retirementAge` variable is a private variable that has no privileged method
    to get or set its value.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retirementAge`变量是一个私有变量，没有特权方法来获取或设置其值。'
- en: The `country` variable is a private variable created as a constructor argument.
    Constructor arguments are available as private variables to the object.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`country`变量是一个通过构造函数参数创建的私有变量。构造函数参数作为私有变量对对象可用。'
- en: When we called `cricketer.switchHands()`, it was only applied to the `cricketer`
    and not to both the players, although it's a prototype function of the `Player`
    itself.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用`cricketer.switchHands()`时，这个函数只应用于`cricketer`本身，而没有同时应用于两名球员，尽管它本身是`Player`对象的一个原型函数。
- en: Private functions and privileged methods are instantiated with each new object
    created. In our example, new copies of `isAvailable()` and `book()` would be created
    for each new player instance that we create. On the other hand, only one copy
    of public methods is created and shared between all instances. This can mean a
    bit of performance gain. If you don't *really* need to make something private,
    think about keeping it public.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有函数和特权方法随着每个新对象的创建而实例化。在我们的例子中，每次我们创建一个新的球员实例时，都会创建`isAvailable()`和`book()`的新副本。另一方面，只有公共方法的一个副本被创建，并在所有实例之间共享。这可能会带来一些性能提升。如果你*真的*不需要将某事设为私有，考虑将其设为公共。
- en: Inheritance
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'Inheritance is an important concept of OOP. It is common to have a bunch of
    objects implementing the same methods. It is also common to have an almost similar
    object definition with differences in a few methods. Inheritance is very useful
    in promoting code reuse. We can look at the following classic example of inheritance
    relation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程（OOP）的一个重要概念。通常会有许多实现相同方法的对象，也很常见几乎相似的对象定义，差异仅在于几个方法。继承在促进代码重用方面非常有用。我们可以看看以下继承关系的经典示例：
- en: '![Inheritance](img/00007.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/00007.jpeg)'
- en: Here, you can see that from the generic **Animal** class, we derive more specific
    classes such as **Mammal** and **Bird** based on specific characteristics. Both
    the Mammal and Bird classes do have the same template of an Animal; however, they
    also define behaviors and attributes specific to them. Eventually, we derive a
    very specific mammal, **Dog**. A Dog has common attributes and behaviors from
    an Animal class and Mammal class, while it adds specific attributes and behaviors
    of a Dog. This can go on to add complex inheritance relationships.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到从通用的**Animal**类中，我们派生出更具体的一些类，如**Mammal**和**Bird**，这些都是基于特定的特性。哺乳动物和鸟类班级都有动物类的同一个模板；然而，它们还定义了特定于它们自己的行为和属性。最后，我们派生出一个非常具体的哺乳动物，**Dog**。狗从动物类和哺乳动物类中继承了共同的属性和行为，同时它还增加了狗特有的属性和行为。这可以继续添加复杂的继承关系。
- en: Traditionally, inheritance is used to establish or describe an **IS-A** relationship.
    For example, a dog IS-A mammal. This is what we know as **classical inheritance**.
    You would have seen such relationships in object-oriented languages such as C++
    and Java. JavaScript has a completely different mechanism to handle inheritance.
    JavaScript is classless language and uses prototypes for inheritance. Prototypal
    inheritance is very different in nature and needs thorough understanding. Classical
    and prototypal inheritance are very different in nature and need careful study.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，继承被用来建立或描述**IS-A**关系。例如，狗是哺乳动物。这就是我们所说的**经典继承**。你可能会在面向对象的语言如C++和Java中看到这样的关系。JavaScript有一个完全不同的机制来处理继承。JavaScript是一种无类语言，使用原型进行继承。原型继承在本质上非常不同，需要深入理解。经典继承和原型继承在本质上非常不同，需要仔细研究。
- en: In classical inheritance, instances inherit from a class blueprint and create
    subclass relationships. You can't invoke instance methods on a class definition
    itself. You need to create an instance and then invoke methods on this instance.
    In prototypal inheritance, on the other hand, instances inherit from other instances.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典继承中，实例从类蓝图中继承，并创建子类关系。你不能在类定义本身上调用实例方法。你需要创建一个实例，然后在这个实例上调用方法。另一方面，在原型继承中，实例从其他实例中继承。
- en: As far as inheritance is concerned, JavaScript uses only objects. As we discussed
    earlier, each object has a link to another object called its prototype. This prototype
    object, in turn, has a prototype of its own, and so on until an object is reached
    with `null` as its prototype; `null`, by definition, has no prototype, and acts
    as the final link in this prototype chain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 至于继承，JavaScript只使用对象。如我们之前讨论的，每个对象都有一个链接到另一个对象的原型。这个原型对象，反过来，也有自己的原型，依此类推，直到找到一个其原型为`null`的对象；`null`，按定义，没有原型，作为原型链中的最后一个链接。
- en: 'To understand prototype chains better, let''s consider the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解原型链，让我们考虑以下示例：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we define a `Person` and then `Child`—a child IS-A person. We also copy
    the `cry` property of a `Person` to the `cry` property of `Child`. When we try
    to see this relationship using `instanceof`, we soon realize that just by copying
    a behavior, we could not really make `Child` an instance of `Person`; `aChild
    instanceof Person` fails. This is just copying or masquerading, not inheritance.
    Even if we copy all the properties of `Person` to `Child`, we won''t be inheriting
    from `Person`. This is usually a bad idea and is shown here only for illustrative
    purposes. We want to derive a prototype chain—an IS-A relationship, a real inheritance
    where we can say that child IS-A person. We want to create a chain: a child IS-A
    person IS-A mammal IS-A animal IS-A object. In JavaScript, this is done using
    an instance of an object as a prototype as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`Person`，然后是`Child`——一个孩子 IS-A 人。我们还把`Person`的`cry`属性复制给了`Child`的`cry`属性。当我们尝试使用`instanceof`来看这种关系时，我们很快意识到，仅仅通过复制行为，我们并不能真正使`Child`成为`Person`的实例；`aChild
    instanceof Person`失败。这只是复制或伪装，并不是继承。即使我们把`Person`的所有属性复制给`Child`，我们也不会从`Person`继承。这通常是一个糟糕的主意，这里只是为了说明目的。我们希望导出一个原型链——一个
    IS-A 关系，一个真正的继承，我们可以说是 child IS-A person。我们希望创建一个链：child IS-A person IS-A mammal
    IS-A animal IS-A object。在JavaScript中，这是通过使用一个对象的实例作为原型来完成的：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s modify the earlier example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的示例：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The changed line uses an instance of `Person` as the prototype of `Child`. This
    is an important distinction from the earlier method. Here we are declaring that
    child IS-A person.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的行使用了`Person`实例作为`Child`的原型。这与之前的方法有重要的区别。这里我们声明child IS-A person。
- en: 'We discussed about how JavaScript looks for a property up the prototype chain
    till it reaches `Object.prototype`. Let''s discuss the concept of prototype chains
    in detail and try to design the following employee hierarchy:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了JavaScript如何在一个属性直到它达到`Object.prototype`的原型链中寻找属性。让我们详细讨论原型链的概念，并尝试设计以下员工层次结构：
- en: '![Inheritance](img/00008.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/00008.jpeg)'
- en: This is a typical pattern of inheritance. A manager IS-A(n) employee. **Manager**
    has common properties inherited from an **Employee**. It can have an array of
    reportees. An **Individual Contributor** is also based on an employee but he does
    not have any reportees. A **Team Lead** is derived from a Manager with a few functions
    that are different from a Manager. What we are doing essentially is that each
    child is deriving properties from its parent (Manager being the parent and Team
    Lead being the child).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是继承的典型模式。经理 IS-A(n) 员工。**经理**从**员工**继承了共同的属性。它可以拥有一个报告人员的数组。一个**个人贡献者**也是基于一个员工，但他没有任何报告人员。一个**团队领导**从经理派生出来，有几个与经理不同的功能。我们本质上是在做每个孩子从它的父母那里导出属性（经理是父母，团队领导是孩子）。
- en: 'Let''s see how we can create this hierarchy in JavaScript. Let''s define our
    `Employee` type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在JavaScript中创建这个层次结构。让我们定义我们的`Employee`类型：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is nothing special about these definitions. The `Employee` object contains
    three properties—name, salary, and department. Next, we define `Manager`. This
    definition shows you how to specify the next object in the inheritance chain:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义没有什么特别之处。`Employee`对象包含三个属性—姓名、薪水、部门。接下来，我们定义`Manager`。这个定义展示了如何指定继承链中的下一个对象：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In JavaScript, you can add a prototypical instance as the value of the prototype
    property of the constructor function. You can do so at any time after you define
    the constructor. In this example, there are two ideas that we have not explored
    earlier. First, we are calling `Employee.call(this)`. If you come from a Java
    background, this is analogous to the `super()` method call in the constructor.
    The `call()` method calls a function with a specific object as its context (in
    this case, it is the given the `this` value), in other words, call allows to specify
    which object will be referenced by the `this` keyword when the function will be
    executed. Like `super()` in Java, calling `parentObject.call(this)` is necessary
    to correctly initialize the object being created.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以在定义构造函数后任何时候将原型实例添加到构造函数的prototype属性中。在这个例子中，我们还没有探索到两个想法。首先，我们调用`Employee.call(this)`。如果你来自Java背景，这与构造函数中的`super()`方法调用类似。`call()`方法用一个特定的对象作为其上下文（在这个例子中，是给定的`this`值）调用一个函数，换句话说，`call()`允许指定在函数执行时哪个对象将被`this`关键字引用。与Java中的`super()`类似，调用`parentObject.call(this)`是初始化正在创建的对象所必需的。
- en: The other thing we see is `Object.create()` instead of calling `new`. `Object.create()`
    creates an object with a specified prototype. When we do `new Parent()`, the constructor
    logic of the parent is called. In most cases, what we want is for `Child.prototype`
    to be an object that is linked via its prototype to `Parent.prototype`. If the
    parent constructor contains additional logic specific to the parent, we don't
    want to run this while creating the child object. This can cause very difficult-to-find
    bugs. `Object.create()` creates the same prototypal link between the child and
    parent as the `new` operator without calling the parent constructor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的另一点是使用`Object.create()`而不是调用`new`。`Object.create()`创建了一个具有指定原型的对象。当我们调用`new
    Parent()`时，会调用父类的构造逻辑。在大多数情况下，我们想要的是`Child.prototype`是一个通过原型链接到`Parent.prototype`的对象。如果父类构造函数包含特定于父类的额外逻辑，我们在创建子对象时不想运行这个逻辑。这可能会导致非常难以发现的错误。`Object.create()`创建了与`new`运算符相同的父子原型链接，而不会调用父类构造函数。
- en: 'To have a side effect-free and accurate inheritance mechanism, we have to make
    sure that we perform the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个无副作用且准确的继承机制，我们必须确保我们执行以下操作：
- en: Setting the prototype to an instance of the parent initializes the prototype
    chain (inheritance); this is done only once (as the prototype object is shared)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原型设置为父类的实例来初始化原型链（继承）；这只需要做一次（因为原型对象是共享的）
- en: Calling the parent's constructor initializes the object itself; this is done
    with every instantiation (you can pass different parameters each time you construct
    it)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用父类的构造函数初始化对象本身；这在每次实例化时都会进行（你可以在构造它时传递不同的参数）
- en: 'With this understanding in place, let''s define the rest of the objects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了这一点的基础上，我们来定义其余的对象：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Based on this hierarchy, we can instantiate these objects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个层次结构，我们可以实例化这些对象：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can see the following output for the preceding code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到以下代码片段的输出：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A generic `Employee` has a department assigned to `None` (as specified in the
    default value) and the rest of the properties are also assigned as the default
    ones.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的`Employee`对象分配给`None`的部门（如默认值中所指定），其余属性也分配为默认值。
- en: 'Next, we instantiate a manager; we can provide specific values as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化一个经理；我们可以像下面这样提供具体的值：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到以下输出：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For `TeamLead`, the `reports` property is derived from the base class (Manager
    in this case):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`TeamLead`，其`reports`属性是从基类（在这个例子中是Manager）派生出来的：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will see the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到以下的输出：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When JavaScript processes the new operator, it creates a new object and passes
    this object as the value of `this` to the parent—the `TeamLead` constructor. The
    constructor function sets the value of the `projects` property and implicitly
    sets the value of the internal `__proto__` property to the value of `TeamLead.prototype`.
    The `__proto__` property determines the prototype chain used to return property
    values. This process does not set values for properties inherited from the prototype
    chain in the `jason` object. When the value of a property is read, JavaScript
    first checks to see whether the value exists in that object. If the value does
    exist, this value is returned. If the value is not there, JavaScript checks the
    prototype chain using the `__proto__` property. Having said this, what happens
    when you do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript处理新的操作符时，它创建一个新对象，并将这个对象作为`this`的值传递给父对象——即`TeamLead`构造函数。构造函数设置`projects`属性的值，并隐式地将内部`__proto__`属性的值设置为`TeamLead.prototype`的值。`__proto__`属性决定了用于返回属性值的原型链。这个过程不会在`jason`对象中设置从原型链继承的属性值。当读取属性的值时，JavaScript首先检查该对象中是否存在这个值。如果值存在，这个值就被返回。如果值不存在，JavaScript使用`__proto__`属性检查原型链。说到这里，当你做以下操作时会发生什么：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It does not propagate to all the instances of `Employee`. This is because when
    you create an instance of the `Employee` object, this instance gets a local value
    for the name. When you set the `TeamLead` prototype by creating a new `Employee`
    object, `TeamLead.prototype` has a local value for the `name` property. Therefore,
    when JavaScript looks up the `name` property of the `jason` object, which is an
    instance of `TeamLead`), it finds the local value for this property in `TeamLead.prototype`.
    It does not try to do further lookups up the chain to `Employee.prototype`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会传播到`Employee`的所有实例中。这是因为当你创建一个`Employee`对象的实例时，这个实例获得了名字的局部值。当你通过创建一个新的`Employee`对象来设置`TeamLead`原型时，`TeamLead.prototype`拥有`name`属性的局部值。因此，当JavaScript查找`jason`对象（`TeamLead`的一个实例）的`name`属性时，它找到了`TeamLead.prototype`中的这个属性的局部值。它不会尝试进一步查找链中的`Employee.prototype`。
- en: 'If you want the value of a property changed at runtime and have the new value
    be inherited by all the descendants of the object, you cannot define the property
    in the object''s constructor function. To achieve this, you need to add it to
    the constructor''s prototype. For example, let''s revisit the earlier example
    but with a slight change:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在运行时改变属性的值，并且希望新值被对象的的所有后代继承，你不能在对象的构造函数中定义属性。要实现这一点，你需要将其添加到构造函数的原型中。例如，让我们稍稍修改一下先前的例子：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Though this is a very powerful technique, care should be taken not to overuse
    it. Refer to [http://perfectionkills.com/extending-native-builtins/](http://perfectionkills.com/extending-native-builtins/)
    to understand the pitfalls of extending native built-ins and what care should
    be taken if you intend to do so.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个非常强大的技术，但使用时应该小心，不要过度使用。参阅[http://perfectionkills.com/extending-native-builtins/](http://perfectionkills.com/extending-native-builtins/)以了解扩展原生内置对象的陷阱以及如果你打算这样做应该注意什么。
- en: Getters and setters
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问器和方法
- en: '**Getters** are convenient methods to get the value of specific properties;
    as the name suggests, **setters** are methods that set the value of a property.
    Often, you may want to derive a value based on some other values. Traditionally,
    getters and setters used to be functions such as the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问器方法**是获取特定属性值方便的方法；正如其名，**设置器方法**是设置属性值的方法。通常，你可能希望基于其他值派生一个值。传统上，访问器和方法通常是像下面的函数：'
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, `setLastName()`, `setFirstName()`, and `getFullName()` are functions
    used to do *get* and *set* of properties. `Fullname` is a derived property by
    concatenating the `firstname` and `lastname` properties. This is a very common
    use case and ECMAScript 5 now provides you with a default syntax for getters and
    setters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`setLastName()`、`setFirstName()`和`getFullName()`是用于属性*获取*和*设置*的函数。`Fullname`是通过连接`firstname`和`lastname`属性派生出的属性。这是一个非常常见的用例，ECMAScript
    5现在为您提供了访问器和方法的默认语法。
- en: 'The following example shows you how getters and setters are created using the
    object literal syntax in ECMAScript 5:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在ECMAScript 5中使用对象字面量语法创建访问器和方法：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Another way of declaring getters and setters is using the `Object.defineProperty()`
    method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 声明访问器和方法的另一种方式是使用`Object.defineProperty()`方法：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this method, you can call `Object.defineProperty()` even after the object
    is created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，即使对象已经被创建，你也可以调用`Object.defineProperty()`。
- en: 'Now that you have tasted the object-oriented flavor of JavaScript, we will
    go through a bunch of very useful utility methods provided by **Underscore.js**.
    We discussed the installation and basic usage of Underscore.js in the previous
    chapter. These methods will make common operations on objects very easy:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经尝到了JavaScript对象导向的味道，接下来我们将介绍由**Underscore.js**提供的一组非常有用的工具方法。我们在上一章讨论了Underscore.js的安装和基本使用。这些方法将使对对象的基本操作变得非常容易：
- en: '`keys()`: This method retrieves the names of an object''s own enumerable properties.
    Note that this function does not traverse up the prototype chain:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()`：这个方法检索对象自身可枚举属性的名称。请注意，这个函数不会遍历原型链：'
- en: '[PRE38]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`allKeys()`: This method retrieves the names of an object''s own and inherited
    properties:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allKeys()`: 这个方法会检索对象自身和继承的属性的名称：'
- en: '[PRE39]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`values()`: This method retrieves the values of an object''s own properties:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`：这个方法检索对象自身属性的值：'
- en: '[PRE40]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`mapObject()`: This method transforms the value of each property in the object:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapObject()`: 这个方法会将对象中每个属性的值进行转换：'
- en: '[PRE41]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`functions()`: This returns a sorted list of the names of every method in an
    object—the name of every function property of the object.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functions()`：这会返回一个排序好的列表，包含对象中每个方法的名称——对象每个函数属性的名称。'
- en: '`pick()`: This function returns a copy of the object, filtered to just the
    values of the keys provided:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pick()`：这个函数返回一个对象的副本，过滤出提供的键的值：'
- en: '[PRE42]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`omit()`: This function is an invert of `pick()`—it returns a copy of the object,
    filtered to omit the values for the specified keys.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`omit()`: 这个函数是`pick()`的逆操作——它返回一个对象的副本，过滤掉指定键的值。'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript applications can improve in clarity and quality by allowing for the
    greater degree of control and structure that object-orientation can bring to the
    code. JavaScript object-orientation is based on the function prototypes and prototypal
    inheritance. These two ideas can provide an incredible amount of wealth to developers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 允许JavaScript应用程序通过使用对象导向带来的更大控制和结构，从而提高代码的清晰度和质量。JavaScript的对象导向基于函数原型和原型继承。这两个概念可以为开发者提供大量的财富。
- en: In this chapter, we saw basic object creation and manipulation. We looked at
    how constructor functions are used to create objects. We dived into prototype
    chains and how inheritance operates on the idea of prototype chains. These foundations
    will be used to build your knowledge of JavaScript patterns that we will explore
    in the next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了基本的对象创建和操作。我们探讨了构造函数如何用于创建对象。我们深入研究了原型链以及如何在原型链上操作继承。这些基础将用于构建我们在下一章中探索的JavaScript模式的知识。
