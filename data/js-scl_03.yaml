- en: Chapter 3. Component Composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 组件组合
- en: Large-scale JavaScript applications amount to a series of communicating components.
    The focus of this chapter is on the composition of these components, while in
    the next chapter we will look at how these components communicate with one another.
    Composition is a big topic, and one that's relevant to scalable JavaScript code.
    When we start thinking about the composition of our components, we start to notice
    certain flaws in our design; limitations that prevent us from scaling in response
    to influencers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大规模的JavaScript应用程序可以看作是一系列相互通信的组件。本章的重点在于这些组件的组合，而下一章我们将探讨这些组件是如何彼此通信的。组合是一个很大的主题，也是与可扩展的JavaScript代码相关的。当我们开始考虑我们组件的组合时，我们会开始注意到我们设计中的一些缺陷；限制了我们根据影响者进行扩展的局限性。
- en: The composition of a component isn't random—there's a handful of prevalent patterns
    for JavaScript components. We'll begin the chapter with a look at some of these
    generic component types that encapsulate common patterns found in every web application.
    Understanding that components implement patterns is crucial for extending these
    generic components in a way that scales.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的组合不是随机的——有一些在JavaScript组件中普遍存在的模式。我们将从本章开始探讨一些这些通用的组件类型，它们封装了在每个网络应用程序中都能找到的常见模式。理解组件实现模式对于以可扩展的方式扩展这些通用组件至关重要。
- en: It's one thing to get our component composition right from a purely technical
    standpoint, it's another to easily map these components to features. The same
    challenge holds true for components we've already implemented. The way we compose
    our code needs to provide a level of transparency, so that it's feasible to decompose
    our components and understand what they're doing, both at runtime and at design
    time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的技术角度来看，正确地组合我们的组件是一回事，轻松地将这些组件映射到功能上是另一回事。对我们已经实现的组件来说，同样的挑战也成立。我们编写代码的方式需要提供一定程度的透明度，这样在运行时和设计时分解我们的组件并理解它们在做什么是可行的。
- en: Finally, we'll take a look at the idea of decoupling business logic from our
    components. This is nothing new—the idea of separation-of-concerns has been around
    for a long time. The challenge with JavaScript applications is that it touches
    on so many things—it's difficult to clearly separate business logic from other
    implementation concerns. The way in which we organize our source code (relative
    to the components that use them) can have a dramatic effect on our ability to
    scale.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨将业务逻辑与我们的组件解耦的想法。这并不是什么新想法——关注分离已经存在很长时间了。JavaScript应用程序的挑战在于它涉及很多东西——很难清楚地将与业务逻辑相关的其他实现关注区分开来。我们组织源代码的方式（相对于使用它们的组件）可以对我们的扩展能力产生巨大的影响。
- en: Generic component types
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用组件类型
- en: It's exceedingly unlikely that anyone, in this day and age, would set out to
    build a large scale JavaScript application without the help of libraries, a framework,
    or both. Let's refer to these collectively as tools, since we're more interested
    in using the tools that help us scale, and not necessarily which tools are better
    than other tools. At the end of the day, it's up to the development team to decide
    which tool is best for the application we're building, personal preferences aside.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今这个时代，没有人会不借助库、框架或两者就着手构建大规模的JavaScript应用程序，这是极不可能的。让我们将这些统称为工具，因为我们更关心使用帮助我们扩展的工具，而不是工具之间的优劣。归根结底，开发团队需要决定哪种工具最适合我们正在构建的应用程序，个人喜好暂且不论。
- en: Guiding factors in choosing the tools we use are the type of components they
    provide, and what these are capable of. For example, a larger web framework may
    have all the generic components we need. On the other hand, a functional programming
    utility library might provide a lot of the low-level functionality we need. How
    these things are composed into a cohesive feature that scales, is for us to figure
    out.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 选择我们使用的工具的指导因素是它们提供的组件类型以及它们的能力。例如，一个较大的网络框架可能拥有我们需要的所有通用组件。另一方面，一个函数式编程实用库可能提供我们需要的很多底层功能。如何将这些事物组合成一个可扩展的、连贯的功能，由我们来决定。
- en: The idea is to find tools that expose generic implementations of the components
    we need. Often, we'll extend these components, building specific functionality
    that's unique to our application. This section walks through the most typical
    components we'd want in a large-scale JavaScript application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是找到暴露我们需要的组件的通用实现的工具。通常，我们会扩展这些组件，构建我们应用程序特有的特定功能。本节将介绍在一个大规模JavaScript应用程序中我们最需要的典型组件。
- en: Modules
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Modules exist, in one form or another, in almost every programming language.
    Except in JavaScript. That's almost untrue though—ECMAScript 6, in its final draft
    status at the time of this writing, introduces the notion of modules. However,
    there are tools out there today that allow us to modularize our code, without
    relying on the `script` tag. Large-scale JavaScript code is still a relatively
    new thing. Things such as the `script` tag weren't meant to address issues like
    modular code and dependency management.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种编程语言都以一种形式或另一种形式存在模块。除了JavaScript。不过这几乎是不正确的——在撰写本文时，ECMAScript 6处于最终草案状态，引入了模块的概念。然而，如今市场上已经有了一些工具，可以让我们在不依赖`script`标签的情况下模块化代码。大规模的JavaScript代码仍然是一件相对较新的事情。像`script`标签这样的东西并不是为模块代码和依赖管理这类问题而设计的。
- en: RequireJS is probably the most popular module loader and dependency resolver.
    The fact that we need a library just to load modules into our front-end application
    speaks of the complexities involved. For example, module dependencies aren't a
    trivial matter when there's network latency and race conditions to consider.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS可能是最受欢迎的模块加载器和依赖解析器。我们需要一个库只是为了将模块加载到我们的前端应用程序中，这反映了涉及的复杂性。例如，当考虑到网络延迟和竞争条件时，模块依赖关系并不是一件简单的事情。
- en: Another option is to use a transpiler like **Browserify**. This approach is
    gaining traction because it lets us declare our modules using the CommonJS format.
    This format is used by NodeJS, and the upcoming ECMAScript module specification
    is a lot closer to CommonJS than to AMD. The advantage is that the code we write
    today has better compatibility with back-end JavaScript code, and with the future.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用像**Browserify**这样的转换器。这种方法越来越受欢迎，因为它允许我们使用CommonJS格式声明我们的模块。这种格式被NodeJS使用，即将到来的ECMAScript模块规范与CommonJS比与AMD更接近。优点是我们今天编写的代码与后端JavaScript代码的兼容性更好，也适应未来。
- en: Some frameworks, such as Angular or Marionette, have their own ideas of what
    modules are- albeit, more abstract ideas.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架，如Angular或Marionette，有自己的关于模块的想法——尽管是更抽象的想法。
- en: 'These modules are more about organizing our code, than they are about tactfully
    delivering code from the server to the browser. These types of modules might even
    map better to other features of the framework. For example, if there''s a centralized
    application instance that''s used to manage our modules, the framework might provide
    a mean to manage modules from the application. Take a look at the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块更多的是关于组织我们的代码，而不是巧妙地将代码从服务器传输到浏览器。这类模块甚至可能更好地映射到框架的其他功能。例如，如果有一个中心化的应用程序实例用来管理我们的模块，框架可能提供一种从应用程序管理模块的手段。请看下面的图表：
- en: '![Modules](img/4639_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![模块](img/4639_03_01.jpg)'
- en: A global application component using modules as it's building blocks. Modules
    can be small, containing only one feature, or large, containing several features
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块作为构建块的全局应用程序组件。模块可以很小，只包含一个功能，也可以很大，包含几个功能
- en: This lets us perform higher-level tasks at the module level (things such as
    disabling modules or configuring them with arguments). Essentially, modules speak
    for features. They're a packaging mechanism that allow us to encapsulate things
    about a given feature that the rest of the application doesn't care about. Modules
    help us scale our application by adding high-level operations to our features,
    by treating our features as the building blocks. Without modules, we'd have no
    meaningful way to do this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们能在模块级别执行更高级的任务（例如禁用模块或使用参数配置它们）。本质上，模块代表特性。它们是一种允许我们将关于给定特性的某些东西封装起来的包装机制。模块帮助我们对应用程序进行模块化处理，通过为我们的特性添加高级操作，将特性视为构建模块。没有模块，我们就找不到这种有意义的处理方式。
- en: The composition of modules look different depending on the mechanism used to
    declare the module. A module could be straightforward, providing a namespace from
    which objects can be exported. Or if we're using a specific framework module flavor,
    there could be much more to it. Like automatic event life cycles, or methods for
    performing **boilerplate** setup tasks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的组成根据声明模块的机制不同而有所不同。一个模块可能是简单的，提供一个命名空间，从中可以导出对象。如果我们使用特定的框架模块风味，它可能会有更多内容。例如自动事件生命周期，或者执行**
    boilerplate** 设置任务的方法。
- en: 'However we slice it, modules in the context of scalable JavaScript are a means
    to create larger building blocks, and a means to handling complex dependencies:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何划分，可扩展JavaScript中的模块是创建更大块状结构的方法，也是处理复杂依赖关系的方法：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While it's easier to build large-scale applications with module-sized building
    blocks, it's also easier to tear a module out of an application and work with
    it in isolation. If our application is monolithic or our modules are too plentiful
    and fine-grained, it's very difficult for us to excise problem-spots from our
    code, or to test work in progress. Our component may function perfectly well on
    its own. It could have negative side-effects somewhere else in the system, however.
    If we can remove pieces of the puzzle, one at a time and without too much effort,
    we can scale the trouble-shooting process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用模块大小的构建块来构建大型应用程序更容易，但是将模块从应用程序中抽离并独立工作也更简单。如果我们的应用程序是单块的，或者我们的模块太多且过于细粒度，我们很难从代码中切除问题区域，或者测试进行中的工作。我们的组件可能独立运行得很好。然而，它可能在系统的其他地方产生负面影响。如果我们能够一次抽离一个拼图块，而不需要太多的努力，我们可以扩展故障排除过程。
- en: Routers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: Any large-scale JavaScript application has a significant number of possible
    URIs. The URI is the address of the page that the user is looking at. They can
    navigate to this resource by clicking links, or they may be taken to a new URI
    automatically by our code, perhaps in response to some user action. The web has
    always relied on URIs, long before the advent of large-scale JavaScript applications.
    URIs point to resources, and resources can be just about anything. The larger
    the application, the more resources, and the more potential URIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大型JavaScript应用程序都有大量的可能的URI。URI是用户正在查看的页面的地址。用户可以通过点击链接导航到这个资源，或者他们可能会被我们的代码自动带到一个新的URI，也许是对某些用户操作的响应。网络一直依赖于URI，在大规模JavaScript应用程序出现之前就已经如此。URI指向资源，而资源可以是几乎任何东西。应用程序越大，资源越多，潜在的URI也越多。
- en: 'Router components are tools that we use in the front-end, to listen for these
    URI change events and respond to them accordingly. There''s less reliance on the
    back-end web servers parsing the URI, and returning the new content. Most web
    sites still do this, but there are several disadvantages with this approach when
    it comes to building applications:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器组件是我们在前端使用的工具，用于监听URI变化事件并相应地响应。我们不再依赖后端web服务器解析URI并返回新内容。大多数网站仍然这样做，但在构建应用程序时，这种方法有几个缺点：
- en: '![Routers](img/4639_03_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![路由器](img/4639_03_02.jpg)'
- en: The browser triggers events when the URI changes, and the router component responds
    to these changes. The URI changes can be triggered from the history API, or from
    `location.hash`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器在URI发生变化时触发事件，路由器组件响应这些变化。URI变化可以由历史API触发，或者由`location.hash`触发。
- en: The main problem is that we want the UI to be portable, as in, we want to be
    able to deploy it against any back-end and things should work. Since we're not
    assembling markup for the URI in the back-end, it doesn't make sense to parse
    the URI in the back-end either.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是我们希望UI是可移动的，也就是说，我们希望能够将其部署在任何后端，并且一切都能正常工作。由于我们不在后端组装URI的标记，所以在后端解析URI也没有意义。
- en: We declaratively specify all the URI patterns in our router components. We generally
    refer to these as, **routes**. Think of a route as a blueprint, and a URI as an
    instance of that blueprint. This means that when the router receives a URI, it
    can correlate it to a route. That, in essence, is the responsibility of router
    components. Which is easy with smaller applications, but when we're talking about
    scale, further deliberation on router design is in order.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明性地在路由器组件中指定所有的URI模式。我们通常将这些称为**路由**。把路由想象成一张蓝图，而URI则是该蓝图的一个实例。这意味着当路由器接收到一个URI时，它可以将其与一个路由相关联。这就是路由器组件的责任。这在小型应用中很简单，但当我们谈论规模时，对路由器设计进行进一步的思考是必要的。
- en: As a starting point, we have to consider the URI mechanism we want to use. The
    two choices are basically listening to hash change events, or utilizing the history
    API. Using hash-bang URIs is probably the simplest approach. The `history` API
    available in every modern browser, on the other hand, lets us format URI's without
    the hash-bang—they look like real URIs. The router component in the framework
    we're using may support only one or the other, thus simplifying the decision.
    Some support both URI approaches, in which case we need to decide which one works
    best for our application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，我们必须考虑我们想要使用的URI机制。这两个选择基本上是监听哈希变化事件，或者利用历史API。使用哈希-感叹号URI可能是最简单的方法。另一方面，现代浏览器都支持的`history`
    API允许我们格式化不带哈希-感叹号的URI——它们看起来像真正的URI。我们正在使用的框架中的路由器组件可能只支持其中之一，从而简化了决策。一些支持这两种URI方法，在这种情况下，我们需要决定哪一种最适合我们的应用程序。
- en: The next thing to consider about routing in our architecture is how to react
    to route changes. There are generally two approaches to this. The first is to
    declaratively bind a route to a callback function. This is ideal when the router
    doesn't have a lot of routes. The second approach is to trigger events when routes
    are activated. This means that there's nothing directly bound to the router. Instead,
    some other component listens for such an event. This approach is beneficial when
    there are lots of routes, because the router has no knowledge of the components,
    just the routes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们架构中路由的下一个考虑因素是如何响应路由变化。通常有两种方法。第一种是声明性地将路由绑定到回调函数。当路由器没有很多路由时，这是理想的。第二种方法是在路由被激活时触发事件。这意味着没有直接绑定到路由器上。相反，其他组件监听此类事件。当有大量路由时，这种方法有益，因为路由器不知道组件，只知道路由。
- en: 'Here''s an example that shows a router component listening to route events:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示路由器组件监听路由事件的示例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the code required to run these examples is omitted from the listings.
    For example, the `events.js` module is included in the code bundle that comes
    with this book, it's just not that relevant to the example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这些示例，有些必要的代码被省略了。例如，`events.js`模块包含在本书的代码包中，它与示例不是那么相关。
- en: Also in the interest of space, the code examples avoid using specific frameworks
    and libraries. In practice, we're not going to write our own router or events
    API—our frameworks do that already. We're instead using vanillaES6 JavaScript,
    to illustrate points pertinent to scaling our applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，代码示例避免了使用特定的框架和库。实际上，我们不会自己编写路由器或事件API——我们的框架已经做到了。我们 instead 使用纯ES6
    JavaScript，以说明与扩展我们的应用程序相关的要点。
- en: Another architectural consideration we'll want to make when it comes to routing
    is whether we want a global, monolithic router, a router per module, or some other
    component. The downside to having a monolithic router is that it becomes difficult
    to scale when it grows sufficiently large, as we keep adding features and routes.
    The advantage is that the routes are all declared in one place. Monolithic routers
    can still trigger events that all our components can listen to.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论路由时，我们还将考虑是否想要全局的、单块的路由器、每个模块的路由器，或其他组件。拥有单块路由器的缺点是，当它变得足够大时，它变得难以扩展，因为我们在不断添加功能和路由。优点是所有路由都在一个地方声明。单块路由器仍然可以触发所有组件可以监听的事件。
- en: 'The per-module approach to routing involves multiple router instances. For
    example, if our application has five components, each would have their own router.
    The advantage here is that the module is completely self-contained. Anyone working
    with this module doesn''t need to look elsewhere to figure out which routes it
    responds to. Using this approach, we can also have a tighter coupling between
    the route definitions and the functions that respond to them, which could mean
    simpler code. The downside to this approach is that we lose the consolidated aspect
    of having all our routes declared in a central place. Take a look at the following
    diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块的路由方法涉及多个路由实例。例如，如果我们的应用程序有五个组件，每个都有自己的路由器。这种方法的优势是模块完全自包含。任何与这个模块合作的人都不需要查看其他地方来弄清楚它响应哪些路由。采用这种方法，我们还可以使路由定义与响应它们的函数之间的耦合更紧密，这可能意味着代码更简单。这种方法的缺点是我们失去了将所有路由声明在中央位置的集中性。请看下面的图表：
- en: '![Routers](img/4639_03_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![路由器](img/4639_03_03.jpg)'
- en: The router to the left is global—all modules use the same instance to respond
    to URI events. The modules to the right have their own routers. These instances
    contain configuration specific to the module, not the entire application
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的路由器是全局的——所有模块都使用相同的实例来响应URI事件。右边的模块有自己的路由器。这些实例包含特定于模块的配置，而不是整个应用程序的配置。
- en: Depending on the capabilities of the framework we're using, the router components
    may or may not support multiple router instances. It may only be possible to have
    one callback function per route. There may be subtle nuances to the router events
    we're not yet aware of.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所使用的框架的功能，路由器组件可能支持也可能不支持多个路由器实例。可能只有一个回调函数每条路由来实现。我们对路由器事件可能还有些不清楚的细微差别。
- en: Models/Collections
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型/集合
- en: The API our application interacts with exposes entities. Once these entities
    have been transferred to the browser, we will store a model of those entities.
    Collections are a bunch of related entities, usually of the same type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序与之交互的API暴露实体。一旦这些实体被传输到浏览器，我们将存储这些实体的模型。集合是一组相关实体，通常是相同类型的。
- en: The tools we're using may or may not provide a generic model and/or collection
    components, or they may have something similar but named differently. The goal
    of modeling API data is a rough approximation of the API entity. This could be
    as simple as storing models as plain JavaScript objects and collections as arrays.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的工具可能提供通用模型和/或集合组件，也可能有类似但名称不同的东西。建模API数据的目标是对API实体的大致模拟。这可能像将模型存储为普通的JavaScript对象，将集合存储为数组一样简单。
- en: 'The challenge with simply storing our API entities as plain objects in arrays
    is that some other component is then responsible for talking to the API, triggering
    events when the data changes, and for performing data transformations. We want
    other components to be able to transform collections and models where needed,
    in order to fulfill their duties. But we don''t want repetitive code, and it''s
    best if we''re able to encapsulate the common things like transformations, API
    calls, and event life cycles. Take a look at the next diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将API实体简单地存储在数组中的对象中的挑战在于，然后另一个组件负责与API通信，在数据变化时触发事件，并执行数据转换。我们希望在需要时能够使其他组件能够转换集合和模型，以履行他们的职责。但我们不想有重复的代码，最好是我们能够封装像转换，API调用和事件生命周期这样的常见事物。看看下一个图表：
- en: '![Models/Collections](img/4639_03_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![模型/集合](img/4639_03_04.jpg)'
- en: Models encapsulate interaction with APIs, parsing data, and triggering events
    when data changes. This leads to simpler code outside of the models
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模型封装与API的交互，解析数据，以及在数据变化时触发事件。这使得模型外的代码更简单。
- en: Hiding the details of how the API data is loaded into the browser, or how we
    issue commands, helps us scale our application as we grow. As we add more entities
    to the API, the complexity of our code grows too. We can throttle this complexity
    by constraining the API interactions to our model and collection components.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏API数据如何加载到浏览器中，或者我们如何发出命令的细节，有助于我们在成长过程中扩展我们的应用程序。随着向API添加更多实体，我们代码的复杂性也在增长。我们可以通过将API交互限制在我们的模型和集合组件中来限制这种复杂性。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有Pact Publishing书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Another scalability issue we'll face with our models and collections is where
    they fit in the big picture. That is, our application is really just one big component,
    composed of smaller components. Our models and collections map well to our API,
    but not necessarily to features. API entities are more generic than specific features,
    and are often used by several features. Which leaves us with an open question—where
    do our models and collections fit into components?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型和集合上面临的另一个可扩展性问题就是它们在大局中的位置。也就是说，我们的应用程序实际上只是一个由较小组件组成的大型组件。我们的模型和集合很好地映射到我们的API，但不一定映射到功能。API实体比特定功能更通用，通常被几个功能使用。这让我们提出了一个问题——我们的模型和集合应该放入哪个组件中？
- en: 'Here''s an example that shows specific views extending generic views. The same
    model can be passed to both:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个具体视图扩展通用视图的例子。相同的模型可以传递给两者：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On one hand, components can be completely generic with regard to the models
    and collections they use. On the other hand, some components are specific with
    their requirements—they can directly instantiate their collections. Configuring
    generic components with specific models and collections at runtime only benefits
    us when the component truly is generic, and is used in several places. Otherwise,
    we might as well encapsulate the models within the components that use them. Choosing
    the right approach helps us scale. Because, not all our components will be entirely
    generic or entirely specific.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，组件可以完全与它们所使用的模型和集合相通用。另一方面，一些组件对于它们的要求是具体的——它们可以直接实例化它们的集合。在运行时配置通用组件与特定模型和集合只会对我们有利，当组件真正通用，并且在多个地方使用时。否则，我们不妨将模型封装在使用它们的组件内部。选择正确的方法有助于我们实现规模扩展。因为，我们并非所有的组件都完全通用或完全具体。
- en: Controllers/Views
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器/视图
- en: Depending on the framework we're using, and the design patterns our team is
    following, controllers and views can represent different things. There's simply
    too many MV* pattern and style variations to provide a meaningful distinction
    in terms of scale. The minute differences have trade-offs relative to similar
    but different MV* approaches. For our purpose of discussing large scale JavaScript
    code, we'll treat them as the same type of component. If we decide to separate
    the two concepts in our implementation, the ideas in this section will be relevant
    to both types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们使用的框架和团队遵循的设计模式，控制器和视图可以表示不同的事物。MV*模式和风格变化实在太多了，无法在规模上提供有意义的区分。微小的差异相对于类似但不同的MV*方法有相应的取舍。对于我们讨论大规模JavaScript代码的目的，我们将它们视为同一类型的组件。如果我们决定在我们的实现中分离这两个概念，本节中的想法将适用于这两种类型。
- en: Let's stick with the term views for now, knowing that we're covering both views
    and controllers, conceptually. These components interact with several other component
    types, including routers, models or collections, and templates, which are discussed
    in the next section. When something happens, the user needs to be notified about
    it. The view's job is to update the DOM.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时使用“视图”这个术语，知道我们从概念上涵盖了视图和控制器。这些组件与其他几种组件类型交互，包括路由器、模型或集合以及模板，这些将在下一节中讨论。当发生某些事情时，用户需要被告知。视图的工作是更新DOM。
- en: 'This could be as simple as changing an attribute on a DOM element, or as involved
    as rendering a new template:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能只是改变DOM元素的一个属性，或者涉及到渲染一个新的模板：
- en: '![Controllers/Views](img/4639_03_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![控制器/视图](img/4639_03_05.jpg)'
- en: A view component updating the DOM in response to router and model events
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个视图组件在路由和模型事件响应中更新DOM
- en: A view can update the DOM in response to several types of events. A route could
    have changed. A model could have been updated. Or something more direct, like
    a method call on the view component. Updating the DOM is not as straightforward
    as one might think. There's the performance to think about—what happens when our
    view is flooded with events? There's the latency to think about—how long will
    this JavaScript call stack run, before stopping and actually allowing the DOM
    to render?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个视图可以在多种事件发生时更新DOM。路由可能已经改变。模型可能已经被更新。或者更直接一点，比如视图组件上的方法调用。更新DOM并不像人们想象的那么简单。我们需要考虑性能问题——当我们的视图被事件淹没时会发生什么？我们需要考虑延迟问题——这个JavaScript调用堆栈会运行多久，在停止并实际允许DOM渲染之前？
- en: Another responsibility of our views is responding to DOM events. These are usually
    triggered by the user interacting with our UI. The interaction may start and end
    with our view. For example, depending on the state of something like user input
    or one of our models, we might update the DOM with a message. Or we might do nothing,
    if the event handler is **debounced**, for instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图的另一个职责是响应DOM事件。这些通常是由用户与我们的UI交互触发的。交互可能从我们的视图开始和结束。例如，根据用户输入或我们的某个模型的状态，我们可能会用一条消息更新DOM。或者如果事件处理程序被**去抖**（debounced），我们可能会什么都不做。
- en: 'A debounced function groups multiple calls into one. For example, calling `foo()`
    20 times in 10 milliseconds may only result in the implementation of `foo()` being
    called once. For a more detailed explanation, look at: [http://drupalmotion.com/article/debounce-and-throttle-visual-explanation](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation).
    Most of the time, the DOM events get translated into something else, either a
    method call or another event. For example, we might call a method on a model,
    or transform a collection. The end result, most of the time, is that we provide
    feedback by updating the DOM.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 防抖函数将多个调用合并成一个。例如，在10毫秒内调用`foo()` 20次可能只会导致`foo()`的实现被调用一次。要了解更详细的解释，请查看：[http://drupalmotion.com/article/debounce-and-throttle-visual-explanation](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)。大多数情况下，DOM事件被转换成其他东西，要么是一个方法调用，要么是另一个事件。例如，我们可能会调用模型的一个方法，或者转换一个集合。大多数情况下的最终结果是我们通过更新DOM来提供反馈。
- en: This can be done either directly, or indirectly. In the case of direct DOM updates,
    it's simple to scale. In the case of indirect updates, or updates through side-effects,
    scaling becomes more of a challenge. This is because as the application acquires
    more moving parts, the more difficult it becomes to form a mental map of cause
    and effect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以直接完成，也可以间接完成。在直接更新DOM的情况下，扩展起来很简单。而在间接更新，或者通过副作用更新的情况下，扩展变得更具挑战性。这是因为随着应用程序拥有更多的活动部件，形成原因和效果的心理地图变得越来越困难。
- en: Here's an example that shows a view listening to DOM events and model events.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，显示了一个视图监听DOM事件和模型事件。
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On the plus side to all this complexity, we actually get some reusable code.
    The view is agnostic as to how the model or router it's listening to is updated.
    All it cares about is specific events on specific components. This is actually
    helpful to us because it reduces the amount of special-case handling we need to
    implement.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些复杂性的好处是我们实际上得到了一些可重用的代码。视图对于它监听的模型或路由器是如何更新的是不关心的。它在意的只是特定组件上的特定事件。这实际上对我们有帮助，因为它减少了我们需要实现的特殊情况处理量。
- en: The DOM structure that's generated at runtime, as a result of rendering all
    our views, needs to be taken into consideration as well. For example, if we look
    at some of the top-level DOM nodes, they have nested structure within them. It's
    these top-level nodes that form the skeleton of our layout. Perhaps this is rendered
    by the main application view, and each of our views has a child-relationship to
    it. Or perhaps the hierarchy extends further down than that. The tools we're using
    most likely have mechanisms for dealing with these parent-child relationships.
    However, bear in mind that vast view hierarchies are difficult to scale.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时生成的DOM结构，由于渲染所有我们的视图而产生，也需要考虑。例如，如果我们查看一些顶级DOM节点，它们内部有嵌套结构。正是这些顶级节点构成了我们布局的骨架。也许这是由主应用程序视图渲染的，而我们的每个视图都有与其的子关系。或者层次结构可能比这更深。我们正在使用的工具很可能有处理这些父子关系的机制。然而，请注意，庞大的视图层次结构难以扩展。
- en: Templates
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Template engines used to reside mostly in the back-end framework. That's less
    true today, thanks largely to the sophisticated template rendering libraries available
    in the front-end. With large-scale JavaScript applications, we rarely talk to
    back-end services about UI-specific things. We don't say, "here's a URL, render
    the HTML for me". The trend is to give our JavaScript components a certain level
    autonomy—letting them render their own markup.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎曾经主要存在于后端框架中。现在这种情况越来越少见，这要归功于前端可用的复杂模板渲染库。在大型JavaScript应用程序中，我们很少与后端服务讨论UI特定的事情。我们不会说，“这是一个URL，为我渲染HTML”。趋势是赋予我们的JavaScript组件一定程度的自主权——让他们渲染自己的标记。
- en: Having component markup coupled with the components that render them is a good
    thing. It means that we can easily discern where the markup in the DOM is being
    generated. We can then diagnose issues and tweak the design of a large scale application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 组件标记与渲染它们的组件耦合是一件好事。这意味着我们可以轻松地判断DOM中的标记是如何生成的。然后我们可以诊断问题，调整大型应用程序的设计。
- en: Templates help establish a separation of concerns with each of our components.
    The markup that's rendered in the browser mostly comes from the template. This
    keeps markup-specific code out of our JavaScript. Front-end template engines aren't
    just tools for string replacement; they often have other tools to help reduce
    the amount of boilerplate JavaScript code to write. For example, we can embed
    things like conditionals and for-each loops in our markup, where they're suited.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模板有助于为我们每个组件建立关注点的分离。在浏览器中渲染的标记主要来自模板。这使得标记特定的代码不会出现在我们的JavaScript中。前端模板引擎不仅仅是字符串替换的工具；它们通常还有其他工具来帮助我们减少要编写的样板JavaScript代码量。例如，我们可以在标记中嵌入条件语句和for-each循环，这取决于它们是否适合。
- en: Application-specific components
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定于应用程序的组件
- en: The component types we've discussed so far are very useful for implementing
    scalable JavaScript code, but they're also very generic. Inevitably, during implementation
    we're going to hit a road block—the component composition patterns we've been
    following will not work for certain features. This is when it's time to step back
    and think about possibly adding a new type of component to our architecture.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止讨论的组件类型对于实现可扩展的JavaScript代码非常有用，但它们也非常通用。在实现过程中，我们不可避免地会遇到障碍——我们遵循的组件组合模式将不适用于某些功能。这时，我们应该退后一步，考虑可能需要向我们的架构中添加一种新类型的组件。
- en: For example, consider the idea of widgets. These are generic components that
    are mainly focused on presentation and user interactions. Let's say that many
    of our views are using the exact same DOM elements, and the exact same event handlers.
    There's no point in repeating them in every view throughout our application. Might
    it not be better if we were to factor it into a common component? A view might
    be overkill, so perhaps we need a new type of widget component?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑小部件的概念。这些都是主要关注呈现和用户交互的通用组件。假设我们的许多视图都在使用完全相同的DOM元素和完全相同的事件处理程序。在应用程序中的每个视图中重复它们是没有意义的。如果我们将其提取为公共组件，是不是会更好？一个视图可能过于复杂，所以也许我们需要一种新类型的小部件组件？
- en: Sometimes we'll create components for the sole purpose of composition. For example,
    we might have a component that glues together router, view, model/collection,
    and template components together to form a cohesive unit. Modules partially solve
    this problem but they aren't always enough. Sometimes we're missing that added
    bit of orchestration that our components need in order to communicate. We'll cover
    communicating components in the next chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会为了组件化而创建组件。例如，我们可能会有一个组件，它将路由器、视图、模型/集合和模板组件粘合在一起，形成一个协调一致的单元。模块部分解决了这个问题，但它们并不总是足够。有时我们缺少一点编导，以便我们的组件进行通信。我们在下一章讨论通信组件。
- en: Extending generic components
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展通用组件
- en: We often discover, late in the development process, that the components we rely
    on are lacking something we need. If the base component we're using is designed
    well, then we can extend it, plugging in the new properties or functionality we
    need. In this section, we'll walk through some scenarios where we might need to
    extend the common generic components used throughout our application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在开发过程的后期发现，我们依赖的组件缺少我们需要的东西。如果我们使用的基组件设计得很好，那么我们可以扩展它，插入我们需要的新的属性或功能。在本节中，我们将通过一些场景，了解在应用程序中使用的一些常见的通用组件。
- en: If we're going to scale our code, we need to leverage these base components
    where we can. We'll probably want to start extending our own base components at
    some point too. Some tools are better than others at facilitating the extension
    mechanism through which we implement this specialized behavior.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要扩展我们的代码，我们需要尽可能利用这些基本组件。我们可能也希望在某个时候开始扩展我们自己的基本组件。有些工具比其他工具更好地促进通过实现这种特殊行为来扩展机制。
- en: Identifying common data and functionality
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别共同的数据和功能
- en: Before we look at extending the specific component types, it's worthwhile to
    consider the common properties and functionality that's common across all component
    types. Some of these things will be obvious up-front, while others are less pronounced.
    Our ability to scale depends, in part, on our ability to identify commonality
    across our components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑扩展特定类型的组件之前，考虑所有组件类型中常见的属性和功能是有价值的。其中一些东西一开始就会很明显，而其他的则不那么明显。我们能否扩展在很大程度上取决于我们能否识别出组件之间的共性。
- en: 'If we have a global application instance, quite common in large JavaScript
    applications, global values and functionality can live there. This can grow unruly
    down the line though, as more common things are discovered. Another approach might
    be to have several global modules, instead of just a single application instance.
    Or both. But this doesn''t scale from an understandability perspective:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个全局应用程序实例，这在大型JavaScript应用程序中很常见，全局值和功能可以放在那里。然而，随着更多共同事物的发现，这可能会随着时间的推移变得不受控制。另一种方法可能是拥有几个全局模块，而不仅仅是一个单一的应用程序实例。或者两者都有。但从可理解性的角度来看，这种方法并不适用：
- en: '![Identifying common data and functionality](img/4639_03_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![识别常见数据和功能](img/4639_03_06.jpg)'
- en: The ideal component hierarchy doesn't extend beyond three levels. The top level
    is usually found in a framework our application depends on
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的组件层次结构不应超过三级。最高级别通常位于我们应用程序依赖的框架中
- en: As a rule-of-thumb, we should, for any given component, avoid extending it more
    than three levels down. For example, a generic view component from the tools we're
    using could be extended by our generic version of it. This would include properties
    and functionality that every view instance in our application requires. This is
    only a two-level hierarchy, and easy to manage. This means that if any given component
    needs to extend our generic view, it can do so without complicating things. Three-levels
    should be the maximum extension hierarchy depth for any given type. This is just
    enough to avoid unnecessary global data, going beyond this presents scaling issues
    because the hierarchy isn't easily grasped.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，我们应该避免在任何给定组件上扩展超过三级。例如，从我们正在使用的工具中扩展出通用视图组件的通用版本。这包括我们应用程序中每个视图实例都需要的属性和功能。这只是一个两级的层次结构，易于管理。这意味着如果任何给定组件需要扩展我们的通用视图，它可以在不复杂化事物的情况下做到这一点。三级应该是任何给定类型的最大扩展层次结构深度。这足以避免不必要的全局数据，超出这个范围会因为层次结构不易理解而出现扩展问题。
- en: Extending router components
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展路由组件
- en: Our application may only require a single router instance. Even in this case,
    we may still need to override certain extension points of the generic router.
    In case of multiple router instances, there's bound to be common properties and
    functionality that we don't want to repeat. For example, if every route in our
    application follows the same pattern, with only subtle differences, we can implement
    the tools in our base router to avoid repetitious code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可能只需要一个单一的路由器实例。即使在这种情况下，我们可能仍然需要重写通用路由器的某些扩展点。在有多个路由器实例的情况下，肯定会有我们不想重复的共同属性和功能。例如，如果我们应用程序中的每个路由都遵循相同的模式，只有细微的差别，我们可以在基础路由器中实现工具以避免重复代码。
- en: In addition to declaring routes, events take place when a given route is activated.
    Depending on the architecture of our application, different things need to happen.
    Maybe certain things always need to happen, no matter which route has been activated.
    This is where extending the router to provide our own functionality comes in handy.
    For example, we have to validate permission for a given route. It wouldn't make
    much sense for us to handle this through individual components, as this would
    not scale well with complex access control rules and a lot of routes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了声明路由外，当给定路由被激活时，还会发生事件。根据我们应用程序的架构，需要发生不同的事情。也许有些事情总是需要发生，无论哪个路由被激活。这就是扩展路由以提供我们自己的功能变得方便的地方。例如，我们必须验证给定路由的权限。对于我们来说，通过个别组件来处理这个问题并没有多大意义，因为这样在复杂的访问控制规则和大量路由的情况下，无法很好地扩展。
- en: Extending models/collections
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展模型/集合
- en: Our models and collections, no matter what their specific implementation look
    like, will share some common properties with one another- especially if they're
    targeting the same API, which is the common case. The specifics of a given model
    or collection revolve around the API endpoint, the data returned, and the possible
    actions taken. It's likely that we'll target the same base API path for all entities,
    and that all entities have a handful of shared properties. Rather than repeat
    ourselves in every model or collection instance, it's better to abstract the common
    data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型和集合，无论它们具体的实现方式如何，都将彼此共享一些共同属性-尤其是如果它们针对同一个API，这通常是常见情况。给定模型或集合的具体内容围绕API端点、返回的数据和可采取的可能行动展开。我们可能会为所有实体
    targeting 相同的基API路径，并且所有实体都有一些共享属性。与其在每一个模型或集合实例中重复自己，不如抽象出共同的属性。
- en: In addition to sharing properties among our models and collections, we can share
    common behavior. For instance, it's quite likely that a given model isn't going
    to have sufficient data for a given feature. Perhaps that data can be derived
    by transforming the model. These types of transformations can be common, and abstracted
    in a base model or collection. It really depends on the types of features we're
    implementing and how consistent they are with one another. If we're growing fast
    and getting lots of requests for "outside-the-box" features, then we're more likely
    to implement data transformations inside the views that require these one-off
    changes to the models or collections they're using.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在我们模型和集合之间共享属性，我们还可以共享通用行为。例如，某个给定的模型可能没有足够的数据来实现某个特性。也许这些数据可以通过转换模型得到。这类转换可能是通用的，并且可以抽象到基础模型或集合中。这真的取决于我们正在实现的特性的类型以及它们之间的相互一致性。如果我们发展迅速，并且有很多关于"非传统"特性的请求，那么我们更有可能在需要这些一次性更改的模型或集合的视图中实现数据转换。
- en: Most frameworks take care of the nuances for performing XHR requests to fetch
    our data or perform actions. That's not the whole story unfortunately, because
    our features will rarely map one-to-one with a single API entity. More likely,
    we will have a feature that requires several collections that are related to one
    another somehow, and a transformed collection. This type of operation can grow
    complex quickly, because we have to work with multiple XHR requests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数框架都处理了执行XHR请求以获取我们的数据或执行操作的细微差别。不幸的是，这还不是整个故事，因为我们的特性很少与单个API实体一对一映射。更有可能的是，我们将有一个需要多个相关集合和一个转换集合的特性。这种操作可以迅速变得复杂，因为我们必须处理多个XHR请求。
- en: We'll likely use promises to synchronize the fetching of these requests, and
    then perform the data transformation once we have all the necessary sources.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会使用承诺（promises）来同步这些请求的取回，然后在获得所有必要的来源后执行数据转换。
- en: 'Here''s an example that shows a specific model extending a generic model, to
    provide new fetching behavior:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，显示一个特定模型扩展通用模型，以提供新的取回行为：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Extending controllers/views
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展控制器/视图
- en: When we have a base model or base collection, there are often properties shared
    between our controllers or views. That's because the job of a controller or a
    view is to render model or collection data. For example, if the same view is rendering
    the same model properties over and over, we can probably move that bit to a base
    view, and extend from that. Perhaps the repetitive parts are in the templates
    themselves. This means that we might want to consider having a base template inside
    a base view, as shown in the following diagram. Views that extend this base view,
    inherit this base template.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个基础模型或基础集合中，常常会发现我们的控制器或视图之间有共享的属性。这是因为控制器和视图的职责就是渲染模型或集合数据。例如，如果同一个视图反复渲染相同的模型属性，我们可能可以把这部分内容移到一个基础视图中，然后从这个基础上扩展。那些重复的部分可能就在模板本身。这意味着我们可能需要考虑在基础视图中加入一个基础模板，如图所示。扩展这个基础视图的视图会继承这个基础模板。
- en: 'Depending on the library or framework at our disposal, extending templates
    in this way may not be feasible. Or the nature of our features may make this difficult
    to achieve. For example, there may not be a common base template, but there might
    be a lot of smaller views and templates that can plug-into larger components:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们可用的库或框架，以这种方式扩展模板可能并不可行。或者我们特性的性质可能使得这种实现变得困难。例如，可能没有通用的基础模板，但可能有很多更小的视图和模板可以插入到更大的组件中：
- en: '![Extending controllers/views](img/4639_03_07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![扩展控制器/视图](img/4639_03_07.jpg)'
- en: A view that extends a base view can populate the template of the base view,
    as well as inherit other base view functionalities
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展基础视图的视图可以填充基础视图的模板，同时继承其他基础视图的功能
- en: Our views also need to respond to user interactions. They may respond directly,
    or forward the events up the component hierarchy. In either case, if our features
    are at all consistent, there will be some common DOM event handling that we'll
    want to abstract into a common base view. This is a huge help in scaling our application,
    because as we add more features, the DOM event handling code additions is minimized.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图还需要响应用户交互。它们可能会直接响应，或者将事件传递给组件层次结构的上层。无论哪种情况，如果我们的特性在某种程度上是一致的，我们都会希望把一些通用的DOM事件处理抽象到一个通用的基础视图中。这对于扩展我们的应用程序非常有帮助，因为当我们添加更多特性时，DOM事件处理代码的增加量被最小化。
- en: Mapping features to components
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将特性映射到组件
- en: Now that we have a handle on the most common JavaScript components, and the
    ways we'll want to extend them for use in our application, it's time to think
    about how to glue those components together. A router on it's own isn't very useful.
    Nor is a standalone model, template, or controller. Instead, we want these things
    to work together, to form a cohesive unit that realizes a feature in our application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了最常见的JavaScript组件以及我们希望在应用程序中使用它们时的扩展方式，是时候考虑如何将这些组件粘合在一起了。一个单独的路由器没什么用。一个独立的模型、模板或控制器也是如此。相反，我们想要这些东西一起工作，形成一个实现我们应用程序中特性的连贯单位。
- en: To do that, we have to map our features to components. We can't do this haphazardly
    either—we need to think about what's generic about our feature, and about what
    makes it unique. These feature properties will guide our design decisions on producing
    something that scales.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须将我们的特性映射到组件上。我们也不能随意地进行这种映射——我们需要思考我们的特性中哪些是通用的，以及它们有哪些独特之处。这些特性属性将指导我们在生产可扩展性产品时的设计决策。
- en: Generic features
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用特性
- en: 'Perhaps the most important aspects of component composition are consistency
    and reusability. While considering the scaling influences our application faces,
    we''ll come up with a list of traits that all our components must carry: things
    such as user management, access control, and other traits unique to our application.
    This is along with the other architectural perspectives (explored in more depth
    throughout the remainder of the book), which form the core of our generic features:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 组件组合最重要的方面可能是一致性和可重用性。在考虑我们应用程序面临的可扩展性影响时，我们会列出一个所有组件必须具备的特性的清单：比如用户管理、访问控制以及其他我们应用程序特有的特性。这还包括其他架构视角（在本书的剩余部分会有更深入的探讨），它们构成了我们通用特性的核心：
- en: '![Generic features](img/4639_03_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![通用特性](img/4639_03_08.jpg)'
- en: A generic component, composed of other generic components from our framework
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由我们框架中的其他通用组件组成的通用组件
- en: The generic aspects of every feature in our application serve as a blueprint.
    They inform us in composing larger building blocks. These generic features account
    for the architectural factors that help us scale. And if we can encode these factors
    as parts of an aggregate component, we'll have an easier time scaling our application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中每个特性的通用方面都相当于一份蓝图。它们指导我们在构建更大的模块时如何组合。这些通用特性考虑到了帮助我们扩展的建筑因素。如果我们能将这些因素编码为聚合组件的一部分，我们将在扩展应用程序时更加得心应手。
- en: What makes this design task challenging is that we have to look at these generic
    components not only from a scalable architecture perspective, but also from a
    feature-complete perspective. If every feature behaved the same way, we'd be all
    set. If only every feature followed an identical pattern, the sky's the limit
    when it comes time to scale.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使这项设计任务具有挑战性的是，我们必须从可扩展性架构的角度以及特性完整性的角度来考虑这些通用组件。如果每个特性都表现得一样，那就没问题了。如果每个特性都遵循一个相同的模式，那么在扩展时，天空就是极限。
- en: But 100% consistent feature functionality is an illusion, more visible to JavaScript
    programmers than to users. The pattern breaks out of necessity. It's responding
    to this breakage in a scalable way that matters. This is why successful JavaScript
    applications will continuously revisit the generic aspects of our features to
    ensure they reflect reality.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是100%一致的特性功能是一种错觉，这一点对于JavaScript程序员来说比对于用户更加明显。这种模式之所以会崩溃，是出于必要的考虑。重要的是以一种可扩展的方式来应对这种崩溃。这就是为什么成功的JavaScript应用程序会不断地重新审视我们特性的通用方面，以确保它们反映现实。
- en: Specific features
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定特性
- en: When it's time to implement something that doesn't fit the pattern, we're faced
    with a scaling challenge. We have to pivot, and consider the consequences of introducing
    such a feature into our architecture. When patterns are broken, our architecture
    needs to change. This isn't a bad thing—it's a necessity. The limiting factor
    in our ability to scale in response to these new features, lies with generic aspects
    of our existing features. This means that we can't be too rigid with our generic
    feature components. If we're too demanding, we're setting ourselves up for failure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要实现某种不符合模式的功能时，我们面临的是一个可扩展性挑战。我们必须进行调整，并考虑向我们的架构引入此类功能所带来的后果。当模式被打破时，我们的架构需要改变。这不是一件坏事——这是必要的。我们扩展以适应这些新功能的能力的限制，在于我们现有特性的通用方面。这意味着我们不能对通用特性组件过于僵化。如果我们过于苛求，我们就是在为自己设置失败的局面。
- en: Before making any brash architectural decisions stemming from offbeat features,
    think about the specific scaling consequences. For example, does it really matter
    that the new feature uses a different layout and requires a template that's different
    from all other feature components? The state of the JavaScript scaling art revolves
    around finding the handful of essential blueprints to follow for our component
    composition. Everything else is up for discussion on how to proceed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出任何由于奇特功能而导致的草率建筑决策之前，想想具体的扩展后果。例如，新功能是否真的重要，它使用不同的布局，并需要与所有其他功能组件不同的模板？JavaScript扩展艺术的状态是围绕找到我们组件组合要遵循的几种基本蓝图。其他一切都取决于在如何进行上的讨论。
- en: Decomposing components
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解组件
- en: Component composition is an activity that creates order; larger behavior out
    of smaller parts. We often need to move in the opposite direction during development.
    Even after development, we can learn how a component works by tearing the code
    apart and watching it run in different contexts. Component decomposition means
    that we're able to take the system apart and examine individual parts in a somewhat
    structured approach.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 组件组合是一种创建秩序的活动；把小的部分组合成大的行为。在开发过程中，我们经常需要朝着相反的方向努力。即使开发完成后，我们也可以通过分解代码，观察它在不同上下文中运行来了解组件如何工作。组件分解意味着我们能够把系统拆开，以一种结构化的方式检查各个部分。
- en: Maintaining and debugging components
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护和调试组件
- en: Over the course of application development, our components accumulate abstractions.
    We do this to support a feature's requirement better, while simultaneously supporting
    some architectural property that helps us scale. The problem is that as the abstractions
    accumulate, we lose transparency into the functioning of our components. This
    is not only essential for diagnosing and fixing issues, but also in terms of how
    easy the code is to learn.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发的过程中，我们的组件积累了越来越多的抽象。我们这样做是为了更好地支持一个功能的需求，同时支持某些有助于我们扩展的建筑属性。问题在于，随着抽象的积累，我们失去了对组件运行情况的透明度。这不仅对于诊断和修复问题至关重要，而且也关系到代码学习的难易程度。
- en: For example, if there's a lot of indirection, it takes longer for a programmer
    to trace cause to effect. Time wasted on tracing code, reduces our ability to
    scale from a developmental point of view. We're faced with two opposing problems.
    First, we need abstractions to address real world feature requirements and architectural
    constraints. Second, is our inability to master our own code due to a lack of
    transparency.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果有很多间接调用，程序员就需要花更长的时间来追踪原因到效果。在追踪代码上浪费的时间，降低了我们从开发角度扩展的能力。我们面临着两个相反的问题。首先，我们需要抽象来解决现实世界的功能需求和建筑约束。其次，由于缺乏透明度，我们无法掌握自己的代码。
- en: 'Following is an example that shows a renderer component and a feature component.
    Renderers used by the feature are easily substitutable:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了渲染组件和特性组件。特性使用的渲染器很容易被替代：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A tactic that can help us cope with these two opposing scaling influencers is
    substitutability. In particular, the ease with which one of our components, or
    sub-components, can be replaced with something else. This should be really easy
    to do. So before we go introducing layers of abstraction, we need to consider
    how easy it's going to be to replace a complex component with a simple one. This
    can help programmers learn the code, and also help with debugging.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以帮助我们应对这两种相反的扩展影响因素的策略是可替代性。特别是我们组件或子组件可以多么容易地被其他东西替代。这应该是非常容易实现的。所以在我们引入层层抽象之前，我们需要考虑一下复杂组件能否很容易地被简单组件替代。这可以帮助程序员学习代码，也有助于调试。
- en: For example, if we're able to take a complex component out of the system and
    replace it with a dummy component, we can simplify the debugging process. If the
    error goes away after the component is replaced, we have found the problematic
    component. Otherwise, we can rule out a component and keep digging elsewhere.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们能够将一个复杂的组件从系统中取出来，用一个虚拟组件来替代，我们就可以简化调试过程。组件替换后错误消失，我们找到了有问题的组件。否则，我们可以排除一个组件，继续在其他地方寻找。
- en: Re-factoring complex components
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构复杂组件
- en: It's of course easier said than done to implement substitutability with our
    components, especially in the face of deadlines. Once it becomes impractical to
    easily replace components with others, it's time to consider re-factoring our
    code. Or at least the parts that make substitutability infeasible. It's a balancing
    act, getting the right level of encapsulation, and the right level of transparency.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，说到比做到容易，尤其是面对截止日期时，实现组件的可替代性。一旦无法轻松用其他组件替换组件，是时候考虑重构我们的代码了。至少是那些使得可替代性变得不可行的部分。找到正确的封装级别和正确的透明度级别，这是一个平衡的行为。
- en: Substitution can also be helpful at a more granular level. For example, let's
    say a view method is long and complex. If there are several stages during the
    execution of that method, where we would like to run something custom, we can't.
    It's better to re-factor the single method into a handful of methods, each of
    which can be overridden.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在更细粒度的层次上，替代也有帮助。例如，假设一个视图方法又长又复杂。如果在执行该方法的过程中有几个阶段，我们想运行一些自定义内容，我们做不到。把一个单一的方法重构成几个方法会更好，每个都可以被覆盖。
- en: Pluggable business logic
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可插拔的业务逻辑
- en: Not all of our business logic needs to live inside our components, encapsulated
    from the outside world. Instead, it would be ideal if we could write our business
    logic as a set of functions. In theory, this provides us with a clear separation
    of concerns. The components are there to deal with the specific architectural
    concerns that help us scale, and the business logic can be plugged into any component.
    In practice, excising business logic from components isn't trivial.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 并非我们所有的业务逻辑都需要在我们的组件内部，与外部世界隔离。相反，如果我们能将业务逻辑写成一组函数，那就更好了。从理论上讲，这为我们提供了关注点分离。组件在那里处理帮助我们扩展的具体架构问题，而业务逻辑可以插入到任何组件中。实际上，将业务逻辑从组件中分离出来并不简单。
- en: Extending versus configuring
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展与配置
- en: There are two approaches we can take when it comes to building our components.
    As a starting point, we have the tools provided by our libraries and frameworks.
    From there, we can keep extending these tools, getting more specific as we drill
    deeper and deeper into our features. Alternatively, we can provide our component
    instances with configuration values. These instruct the component on how to behave.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建组件时，可以采取两种方法。作为一个起点，我们有库和框架提供的工具。从那里，我们可以继续扩展这些工具，随着我们深入到特性的更深层次，变得更加具体。或者，我们可以为组件实例提供配置值。这些指导组件如何行为。
- en: The advantage of extending things that would otherwise need to be configured
    is that the caller doesn't need to worry about them. And if we can get by, using
    this approach, all the better, because it leads to simpler code- especially the
    code that's using the component. On the other hand, we could have generic feature
    components that can be used for a specific purpose, if only they support this
    configuration or that configuration option. This approach has the advantage of
    using simpler component hierarchies, and less overall components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展那些本来需要配置的东西的优势在于，调用者不需要担心它们。如果我们能通过使用这种方法来解决问题，那就更好了，因为它会导致更简单的代码-尤其是使用组件的代码。另一方面，我们可能会有通用的功能组件，如果它们支持这个配置或那个配置选项，可以用于特定目的。这种方法的优势在于使用更简单的组件层次结构，以及更少的总体组件。
- en: Sometimes it's better to keep components as generic as possible, within the
    realm of understandability. That way, when we need a generic component for a specific
    feature, we can use it without having to re-define our hierarchy. Of course, there's
    more complexity involved for the caller of that component, because they need to
    supply it with the configuration values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时保持组件尽可能通用，在其可理解范围内，会更好。这样，当我们需要为特定功能使用通用组件时，我们就可以使用它，而无需重新定义我们的层次结构。当然，这会让调用该组件的复杂性增加，因为他们需要为其提供配置值。
- en: This is all a trade-off that's up to us, the JavaScript architects of our application.
    Do we want to encapsulate everything, configure everything, or do we want to strike
    a balance between the two?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是我们，即我们应用程序的JavaScript架构师，需要权衡的。我们是希望封装一切，配置一切，还是希望在这两者之间找到平衡？
- en: Stateless business logic
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态的业务逻辑
- en: With functional programming, functions don't have side effects. In some languages,
    this property is enforced, in JavaScript it isn't. However, we can still implement
    side-effect-free functions in JavaScript. If a function takes arguments, and always
    returns the same output based on those arguments, then the function can be said
    to be stateless. It doesn't depend on the state of a component, and it doesn't
    change the state of a component. It just computes a value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数没有副作用。在某些语言中，这一特性被强制执行，在JavaScript中则不是。然而，我们仍然可以在JavaScript中实现无副作用的函数。如果一个函数接受参数，并且总是根据这些参数返回相同的输出，那么可以说这个函数是无状态的。它不依赖于组件的状态，也不会改变组件的状态。它只是计算一个值。
- en: If we can establish a library of business logic that's implemented this way,
    we can design some super flexible components. Rather than implement this logic
    directly in a component, we pass the behavior into the component. That way, different
    components can utilize the same stateless business logic functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能建立一个以这种方式实现的业务逻辑库，我们就能设计出非常灵活的组件。我们不是直接在组件中实现这些逻辑，而是将行为传递给组件。这样，不同的组件就可以利用相同的无状态业务逻辑函数。
- en: The tricky part is finding the right functions that can be implemented this
    way as it's not a good idea to implement these up-front. Instead, as the iterations
    of our application development progress, we can use this strategy to re-factor
    code into generic stateless functions that are shared by any component capable
    of using them. This leads to business logic that's implemented in a focused way,
    and components that are small, generic, and reusable in a variety of contexts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 找到可以以这种方式实现的正确函数是一个棘手的问题，因为一开始就实现这些并不是一个好主意。相反，随着我们应用程序开发的迭代进行，我们可以使用这种策略来重构代码，将其转化为任何可以使用它们的组件共享的通用无状态函数。这导致以集中方式实现业务逻辑，并且组件小、通用，在各种上下文中可重用。
- en: Organizing component code
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织组件代码
- en: In addition to composing our components in such a way that helps our application
    scale, we need to consider the structure of our source code modules too. When
    we first start off with a given project, our source code files tend to map well
    to what's running in the client's browser. Over time, as we accumulate more features
    and components, earlier decisions on how to organize our source tree can dilute
    this strong mapping.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以帮助我们的应用程序扩展的方式组合我们的组件外，我们还需要考虑我们源代码模块的结构。当我们刚开始一个项目时，我们的源代码文件往往很好地映射到客户浏览器中运行的内容。随着时间的推移，当我们积累更多功能和组件时，早期关于如何组织我们的源代码树的决定可能会稀释这种强烈的映射。
- en: 'When tracing runtime behavior to our source code, the less mental effort involved,
    the better. We can scale to more stable features this way because our efforts
    are focused more on the design problems of the day—the things that directly provide
    customer value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们追踪运行时行为到源代码时，涉及的心理努力越少越好。我们可以通过这种方式扩展到更稳定的功能，因为我们的精力更多地集中在当天的设计问题上——那些直接提供客户价值的事情：
- en: '![Organizing component code](img/4639_03_09.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![组织组件代码](img/4639_03_09.jpg)'
- en: The diagram shows the mapping component parts to their implementation artifacts
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图显示了将组件部分映射到其实现工件的图
- en: There's another dimension to code organization in the context of our architecture,
    and that's our ability to isolate specific code. We should treat our code just
    like our runtime components, which are self-sustained units that we can turn on
    or off. That is, we should be able to find all the source code files required
    for a given component, without having to hunt them down. If a component requires,
    say, 10 source code files—JavaScript, HTML, and CSS—then ideally these should
    all be found in the same directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的架构背景下，代码组织的另一个方面是我们的隔离特定代码的能力。我们应该将我们的代码看作是我们的运行时组件，它们是自给自足的单元，我们可以开启或关闭它们。也就是说，我们应该能够找到给定组件所需的全部源代码文件，而无需四处寻找。如果一个组件需要，比如说，10个源代码文件——JavaScript、HTML和CSS——那么理想情况下，这些都应该在同一个目录中找到。
- en: The exception, of course, is generic base functionality that's shared by all
    components. These should be as close to the surface as possible, then it's easy
    to trace our component dependencies; they all point to the top of the hierarchy.
    It's a challenge to scale the dependency graph when our component dependencies
    are all over the place.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，例外是所有组件都共享的通用基础功能。这些功能应该尽可能地靠近表面，这样很容易追踪我们的组件依赖关系；它们都指向层次结构的顶部。当我们的组件依赖关系到处都是时，扩展依赖图是一个挑战。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced us to the concept of component composition. Components
    are the building blocks of a scalable JavaScript application. The common components
    we're likely to encounter include things like modules, models/collections, controllers/views,
    and templates. While these patterns help us achieve a level of consistency, they're
    not enough on their own to make our code work well under various scaling influencers.
    This is why we need to extend these components, providing our own generic implementations
    that specific features of our application can further extend and use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了组件组合的概念。组件是可扩展的JavaScript应用程序的构建块。我们可能会遇到的常见组件包括模块、模型/集合、控制器/视图和模板等。尽管这些模式帮助我们实现了一定程度的一致性，但它们本身并不足以使我们的代码在各种缩放影响因素下运行良好。这就是为什么我们需要扩展这些组件，提供我们自己的通用实现，以便应用程序的具体功能可以进一步扩展和使用。
- en: Depending on the various scaling factors our application encounters, different
    approaches may be taken in getting generic functionality into our components.
    One approach is to keep extending the component hierarchy, and keep everything
    encapsulated and hidden away from the outside world. Another approach is to plug
    logic and properties into components when they're created. The cost is more complexity
    for the code that's using the components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们应用程序遇到的各种缩放因素，获取组件中通用功能的方法可能会有所不同。一种方法是不断扩展组件层次结构，并保持一切被封装和隐藏在外界之外。另一种方法是在创建组件时将逻辑和属性插入其中。后者的代价是使用这些组件的代码复杂度增加。
- en: We ended the chapter with a look at how we might go about organizing our source
    code; so that it's structure better reflects that of our logical component design.
    This helps us scale our development effort, and helps isolate one component's
    code from others'. In the next chapter, we'll look in more detail at the space
    in between our components. It's one thing to have well crafted components that
    stand by themselves. It's quite another to implement scalable component communication.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以查看如何组织源代码来结束本章，以便其结构更好地反映我们逻辑组件设计的情况。这有助于我们扩展开发工作，并将一个组件的代码与其他组件的代码隔离。在下一章中，我们将更详细地研究组件之间的空间。拥有独立站立的精心制作的组件是一回事，实现可扩展的组件通信是另一回事。
