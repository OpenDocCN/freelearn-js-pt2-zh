- en: Chapter 10. Testing and Debugging JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。测试和调试JavaScript
- en: In every software life cycle, testing and debugging play an important role.
    Thorough testing makes software flawless and good debugging techniques makes it
    easy to not only troubleshoot problems, but also helps to identify and fix any
    problems by reaching out to the exact point.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一个软件生命周期中，测试和调试都扮演着重要的角色。彻底的测试可以使软件无懈可击，而优秀的调试技术不仅可以帮助解决问题，还能帮助准确地识别并修复问题。
- en: Testing is the core essence of creating any robust application. However, there
    are different practices and frameworks used by the application to serve particular
    objective, and the architecture varies as per the nature of the application. Therefore,
    sometimes it becomes difficult for a developer to test client-side code, for example,
    if an application contains some JavaScript code on a page itself, such as inline
    event handlers, make it tightly coupled with the page. On the other hand, even
    when modularizing the JavaScript code into different modules bring some test suite
    limitations and become harder to execute the testing process of an application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是创建任何健壮应用程序的核心本质。然而，应用程序为了达到特定的目标，采用了不同的实践和框架，根据应用程序的性质，架构也会有所不同。因此，有时对于开发者来说，测试客户端代码会变得困难，例如，如果一个应用程序在其页面中包含一些JavaScript代码，如内联事件处理程序，这会使它与页面紧密耦合。另一方面，即使将JavaScript代码模块化，也会带来一些测试套件限制，并使应用程序的测试过程更难以执行。
- en: Debugging is the process of finding and fixing errors in an application. It
    is one of the most important and core skillset in software development. If developers
    have a solid grasp on the debugging tools and know the ins and outs of debugging,
    they can quickly identify the root cause and start fixing the errors. Debugging
    is a basic process in any software development life cycle. Whether application
    is a complex one or a simple one, to trace and rectify errors debugging plays
    an important role. It helps the developer to break the program execution through
    breakpoints and identify the program flow by stepping into the chain of program
    execution. Moreover, there is other useful information almost all debugging tools
    provide, such as watching the current state of the variables or objects being
    used within the program and watching them on every stage of the debugging life
    cycle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是查找和修复应用程序错误的过程。它是软件开发中最重要的核心技能之一。如果开发者能够熟练掌握调试工具并了解调试的方方面面，他们就可以快速识别根本原因并开始修复错误。调试是任何软件开发生命周期中的基本过程。无论应用程序是复杂的还是简单的，调试都起着重要的作用，以追踪和修正错误。通过设置断点并逐阶段地执行程序流，调试可以帮助开发者中断程序执行并识别程序流程。此外，几乎所有的调试工具都提供其他有用的信息，例如观察程序中正在使用的变量或对象的状态，并在调试生命周期的每个阶段观察它们。
- en: Testing the JavaScript code
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试JavaScript代码
- en: Normally, web applications go through different types of testing, such as **user
    interface** (**UI**) testing, which checks the functionality of the UI by making
    certain inputs to the form and verifies the behavior of an application. This type
    of testing is mostly done manually or through automated testing tools. The other
    type of testing is **load testing**, which is used mostly to check the performance
    of an application and by putting up some load on the application. In simple terms,
    it can be an example of signing in to an application with many number of users
    or doing some operations through automated routines to test how the application
    behaves. There are a few more testing types, but the most essential type of testing
    that ensures the functionality of the application and certifies whether the application
    complies with the requirements is unit testing. In this section, we will discuss
    about unit testing JavaScript code using Jasmine (a popular JavaScript unit test
    framework) and use it with Karma and Grunt to execute test cases in an ASP.NET
    application using Visual Studio 2015 IDE.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络应用程序会经历不同类型的测试，例如**用户界面**（**UI**）测试，通过向表单输入某些内容并验证应用程序的行为来检查UI的功能。这种类型的测试主要是手动完成或通过自动化测试工具完成。另一种测试类型是**压力测试**，主要用于检查应用程序的性能，通过对应用程序施加一些负载来进行。简单地说，它可以是登录应用程序的许多用户或通过自动化例程执行某些操作的示例，以测试应用程序的行为。还有几种其他类型的测试，但确保应用程序功能并验证应用程序是否符合要求的最重要的测试类型是单元测试。在本节中，我们将讨论使用Jasmine（一个流行的JavaScript单元测试框架）对JavaScript代码进行单元测试，并使用Karma和Grunt在ASP.NET应用程序中使用Visual
    Studio 2015 IDE执行测试用例。
- en: Unit testing
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is a method to test individual units of modules together with associated
    data and procedures to verify the application's functionality compliance to the
    requirements. Unit testing is done by developers, and it allows developers to
    test each use case of the application to guarantee that it meets the requirement
    and works as expected.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种测试模块中个别单元的方法，包括相关的数据和程序，以验证应用程序的功能符合要求。单元测试由开发者完成，它允许开发者测试应用程序的每个用例，以确保它满足需求并按预期工作。
- en: The basic advantage of unit testing is that it separates each part of the application
    into a smaller unit and helps developers to focus and identify the bug initially
    during the development cycle. Unit testing is the first testing any application
    endures and allow testers and developers to release the application for **user
    acceptance testing** (**UAT**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的基本优势在于，它将应用程序的每个部分分离成更小的单元，并帮助开发者在开发周期初期集中精力和识别错误。单元测试是任何应用程序承受的第一次测试，它允许测试人员和开发人员在**用户验收测试**（**UAT**）阶段发布应用程序。
- en: Writing unit tests
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: To test JavaScript code, there are many testing suites available. The most popular
    ones are Jasmine, Mocha, and QUnit. In this chapter, we will use Jasmine with
    Karma and Grunt.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试JavaScript代码，有许多测试套件可供选择。最受欢迎的是Jasmine，Mocha和QUnit。在本章中，我们将使用Jasmine与Karma和Grunt一起使用。
- en: Jasmine
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Jasmine
- en: Jasmine is a behavior-driven development framework for testing JavaScript code.
    This provides certain functions such as `it()`, `describe()`, `expect()`, and
    so on to write test scripts for the JavaScript code. The basic advantage of this
    framework is that it is very easy to understand and helps to write the test JavaScript
    code with very simple lines of code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个用于测试JavaScript代码的行为驱动开发框架。它提供了一些函数，如`it()`，`describe()`，`expect()`等，以编写JavaScript代码的测试脚本。这个框架的基本优势在于它非常容易理解，并帮助用非常简单的代码行编写测试JavaScript代码。
- en: 'For example, consider the following JavaScript code that sums up two numbers
    passed as parameters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下JavaScript代码，它计算作为参数传递的两个数字的和：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The test case for the preceding function will look similar to the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面函数的测试用例将类似于以下内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Karma
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Karma
- en: Karma is a test runner for JavaScript that can be integrated with other testing
    frameworks such as Jasmine, Mocha, and so on. It executes test cases defined through
    Jasmine or other test frameworks by providing a mock test environment and load
    browsers that executes the test JavaScript code according to the configuration.
    The Karma configuration file is known as `Karma.config.js`. Once the tests are
    executed, the results are displayed in the console window.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Karma是一个可以与Jasmine、Mocha等其他测试框架集成的JavaScript测试运行器。它通过提供一个模拟的测试环境并加载执行测试JavaScript代码的浏览器，来执行通过Jasmine或其他测试框架定义的测试用例。Karma配置文件被称为`Karma.config.js`。一旦执行测试，结果将显示在控制台窗口中。
- en: Grunt
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Grunt
- en: Grunt is equivalent to Gulp. It is used to execute tasks such as minification
    of CSS file or JavaScript files, concatenation and merging of multiple JavaScript
    file, and so on. Grunt has hundreds of plugins that can be used to automate specific
    tasks. Unlike the previous chapters, where we used Gulp, we will use Grunt and
    see what it provides with Karma (test runner) and Jasmine (testing suite). Grunt
    and Gulp are both renowned task runners for development. The reason for using
    Grunt here is to get an understanding of another task runner of JavaScript that
    is equally renowned and supported by Visual Studio 2015 and discuss the packages
    that it provides to perform testing using Karma and Jasmine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt相当于Gulp。它用于执行任务，如CSS文件或JavaScript文件的压缩，多个JavaScript文件的合并和合并等。Grunt有数百个插件可用于自动化特定任务。与前面章节中使用的Gulp不同，我们将使用Grunt，看看它与Karma（测试运行器）和Jasmine（测试套件）一起提供了什么。Grunt和Gulp都是知名的开发任务运行器。在这里使用Grunt的原因是为了了解另一个同样知名且受Visual
    Studio 2015支持的JavaScript任务运行器，并讨论它提供以使用Karma和Jasmine进行测试的包。
- en: Developing unit test using Jasmine, Karma, and Grunt
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Jasmine、Karma和Grunt开发单元测试
- en: In this section, we will develop a simple unit test to show how unit testing
    can be done in an ASP.NET Core application using Jasmine, Karma, and Grunt frameworks.
    To start with, create an ASP.NET Core application from Visual Studio 2015.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个简单的单元测试，以展示如何在ASP.NET Core应用程序中使用Jasmine、Karma和Grunt框架进行单元测试。首先，从Visual
    Studio 2015创建一个ASP.NET Core应用程序。
- en: Adding packages
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加包
- en: 'Open the `package.json` file in your ASP.NET Core application and add packages
    such as `grunt`, `grunt-karma`, `karma`, `karma-phantomjs-launcher`, `karma-jasmine`,
    `karma-spec-reporter`, and `karma-cli`, as shown in the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你ASP.NET Core应用程序中的`package.json`文件，添加如`grunt`、`grunt-karma`、`karma`、`karma-phantomjs-launcher`、`karma-jasmine`、`karma-spec-reporter`和`karma-cli`等包，如下所示：
- en: '![Adding packages](img/00119.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![添加包](img/00119.jpeg)'
- en: 'The following table shows the description of each package:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个包的描述：
- en: '| Package Name | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 包名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `grunt` | This configures and runs tasks |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `grunt` | 这配置和运行任务 |'
- en: '| `grunt-karma` | This is the Grunt plugin for the Karma test runner |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `grunt-karma` | 这是用于Karma测试运行器的Grunt插件 |'
- en: '| `karma` | This is the test runner for JavaScript |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `karma` | 这是JavaScript的测试运行器 |'
- en: '| `karma-phantomjs-launcher` | This is the Karma plugin to launch the PhantomJS
    browser |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `karma-phantomjs-launcher` | 这是Karma插件，用于启动PhantomJS浏览器 |'
- en: '| `karma-jasmine` | This is the Karma plugin for the Jasmine test suite |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `karma-jasmine` | 这是Karma插件，用于Jasmine测试套件 |'
- en: '| `karma-spec-reporter` | This is the Karma plugin to report test results to
    the console |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `karma-spec-reporter` | 这是Karma插件，用于将测试结果报告到控制台 |'
- en: '| `karma-cli` | This is the Karma command-line interface |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `karma-cli` | 这是Karma命令行界面 |'
- en: Adding the Grunt file
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加Grunt文件
- en: Add `Gruntfile.js` in your ASP.NET application to define Grunt tasks. `Gruntfile.js`
    is the main file where all the tasks are configured. Configured tasks can be seen
    in Visual Studio from the **Task Runner Explorer** window.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的ASP.NET应用程序中添加`Gruntfile.js`以定义Grunt任务。`Gruntfile.js`是所有任务配置的主文件。在Visual
    Studio的**任务运行器浏览器**窗口中可以看到配置的任务。
- en: Adding Karma specifications
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加Karma规格说明
- en: The `Gruntfile.js` file provides the main `initConfig()` method that is called
    when the Grunt is loaded. This is the starting point where we define the Karma
    specifications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gruntfile.js`文件提供了主要的`initConfig()`方法，在Grunt加载时调用。这是定义Karma规格说明的起点。'
- en: 'The following is the Karma specifications defined within the `initConfig()`
    method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`initConfig()`方法内定义的Karma规格说明：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding script, we first started by specifying the target platform
    for Karma. Inside `karma`, we will specify the unit that is used to run unit tests.
    Inside `unit`, we can define certain configuration attributes such as `frameworks`,
    `singleRun`, `browsers`, and `files`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，我们首先指定了一个Karma的目标平台。在`karma`内部，我们将指定用于运行单元测试的单元。在`unit`内部，我们可以定义一些配置属性，如`frameworks`、`singleRun`、`browsers`和`files`：
- en: '`frameworks`: This is an array of test frameworks that we want to use. In this
    exercise, we used Jasmine. However, other frameworks such as Mocha and QUnit can
    also be used.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frameworks`：这是一个我们要使用的测试框架数组。在这个练习中，我们使用了Jasmine。然而，也可以使用其他框架，如Mocha和QUnit。'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please note that when using any framework in Karma, an additional plugin/library
    of that framework has to be separately installed using **Node Package Manager**
    (**NPM**).
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，在使用Karma中的任何框架时，必须使用**Node包管理器**（**NPM**）单独安装该框架的附加插件/库。
- en: '`singleRun`: If this is set to `true`, Karma start capturing the configured
    browser(s) and executes tests on them. Once the tests are completed, it exits
    smoothly.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleRun`：如果这个设置为`true`，Karma将开始捕获配置的浏览器并在这些浏览器上执行测试。测试完成后，它会顺利退出。'
- en: '`browsers`: This is an array to define multiple browsers in a comma-separated
    value. We have used PhantomJS in our example, which is a headless browser and
    runs the test in background. Karma supports other browsers such as Chrome, Firefox,
    IE, and Safari, and these can be configured through this property.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browsers`：这是一个用逗号分隔的值定义多个浏览器的数组。在我们的示例中使用了PhantomJS，它是一个无头浏览器，在后台运行测试。Karma支持其他浏览器，如Chrome、Firefox、IE和Safari，这些可以通过这个属性进行配置。'
- en: '`files`: This contains all the test files, source files, and dependencies.
    For example, if we are using jQuery in our test scripts, or original source code,
    we can add the path to this library as well. In the preceding configuration, we
    used wildcard characters to load all the source files defined under the `js` folder,
    and tests files under the `tests` folder with a `test.js` suffix.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`: 这里包含所有的测试文件、源文件和依赖。例如，如果我们正在测试脚本中使用jQuery，或者原始源代码，我们也可以添加这个库的路径。在前面的配置中，我们使用了通配符来加载`js`文件夹下定义的所有源文件，以及`tests`文件夹下带有`test.js`后缀的测试文件。'
- en: 'There are many more attributes that can be used in the Karma configuration
    and it can be referred here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Karma配置中还可以使用更多的属性，可以在这里参考：
- en: '[http://karma-runner.github.io/0.13/config/configuration-file.html](http://karma-runner.github.io/0.13/config/configuration-file.html)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://karma-runner.github.io/0.13/config/configuration-file.html](http://karma-runner.github.io/0.13/config/configuration-file.html)'
- en: Load npm task
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加载npm任务
- en: 'To load the Karma test runner tool, we need to specify it in `Gruntfile.js`
    after the Karma configuration, as shown in the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载Karma测试运行工具，我们需要在`Gruntfile.js`中指定它，在前面的配置之后，如下所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Register task
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册任务
- en: 'Finally, we will add the Grunt task to register tasks. The first parameter
    is the task name, which will be available in the **Task Runner Explorer** in Visual
    Studio, and the second parameter takes an array to execute multiple tasks:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将向注册任务中添加Grunt任务。第一个参数是任务名称，它将出现在Visual Studio中的**任务运行器资源管理器**中，第二个参数接受一个数组以执行多个任务：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Source JavaScript file
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 源JavaScript文件
- en: In this example, we have a `product.js` file that contains a `saveProduct()`
    method, which will be invoked on the **Save** button's click event.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个`product.js`文件，它包含一个`saveProduct()`方法，该方法将在点击**保存**按钮的事件上被调用。
- en: 'Add this file to the `wwwroot/js` folder path:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件添加到`wwwroot/js`文件夹路径中：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a recommended approach to keep your JavaScript code separate from your
    HTML markup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将你的JavaScript代码与HTML标记分开。
- en: Adding unit test script file
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加单元测试脚本文件
- en: Here, we will add another JavaScript file under the `wwwroot/tests` folder and
    named it `product.test.js`. When writing tests, you can add the `*.test.js` suffix
    to make it uniquely identified, and separates it from the source JavaScript files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在`wwwroot/tests`文件夹下添加另一个JavaScript文件，并将其命名为`product.test.js`。在编写测试时，可以添加`*.test.js`后缀以使其唯一标识，并将其与源JavaScript文件分开。
- en: 'Here is the code for `product.test.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`product.test.js`的代码：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Jasmine framework provides certain keywords to define specific blocks that
    run on specific conditions, which are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine框架提供了一些特定的关键字来定义在特定条件下运行的特定块，如下所示：
- en: '`describe()`: This is a global Jasmine function that contains two parameters:
    a string and a function. The string is the name of the functionality that is going
    to be tested. The function contains the code that actually implements the Jasmine
    suite and contains logic of unit tests.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe()`：这是一个全局Jasmine函数，包含两个参数：字符串和函数。字符串是要测试的功能名称。函数包含实际实现Jasmine套件的代码，并包含单元测试的逻辑。'
- en: '`it()`: Here, specs are defined by calling the global Jasmine function `it()`.
    This also takes the string and function, where it contains the actual unit test
    name and the function block contains the actual logic of the code to be executed
    followed with the expected results.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it()`：在这里，通过调用全局Jasmine函数`it()`定义规格。这也需要字符串和函数，其中它包含实际的单元测试名称和函数块包含实际的代码逻辑以及预期结果。'
- en: '`expect()`: The expected results can be specified by using the `expect()` function
    that takes some value defined within the `it()` function. This is also chained
    with a matcher function, such as `toBe()` or `not.toBe()`, to match or unmatch
    the expected value.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect()`：可以使用`expect()`函数指定`it()`函数内定义的某些值的预期结果。这还与一个匹配函数（如`toBe()`或`not.toBe()`）相链式调用，以匹配或取消匹配预期值。'
- en: In .NET, it is equivalent to the **Arrange**, **Act**, and **Assert** pattern.
    Here, Arrange is used to initialize objects and set values of the data that is
    passed to the method under test. The Act pattern actually invokes the method under
    test, and Assert verifies that the method under test behaves as expected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，它等效于**准备**、**行动**和**断言**模式。在这里，准备用于初始化对象并设置传递给测试方法的数据的值。行动模式实际调用测试方法，断言验证测试方法如预期行为。
- en: Running test task
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行测试任务
- en: 'Running these tasks is straightforward, it can simply be run through the **Task
    Runner Explorer** window in Visual Studio 2015\. Here is the screenshot of the
    **Task Runner Explorer** window that shows the tasks defined in `Gruntfile.js`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些任务很简单，它可以通过Visual Studio 2015中的**任务运行器**窗口运行。以下是显示`Gruntfile.js`中定义的任务的**任务运行器**窗口截图：
- en: '![Running test task](img/00120.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试任务](img/00120.jpeg)'
- en: 'When we run the test task, it will show something similar to the following
    output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试任务时，它会显示类似以下输出：
- en: '![Running test task](img/00121.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试任务](img/00121.jpeg)'
- en: In our `product.test.js` test script, we have two tasks. One is to check whether
    passing the string values to one of the two elements such as `txtProdUnitPrice`
    and `txtProdQuantity` will return `0`. As our `product.js` file does not handle
    this condition, it will give an error.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`product.test.js`测试脚本中，有两个任务。一个是检查传递字符串值到两个元素中的一个（如`txtProdUnitPrice`和`txtProdQuantity`）是否会返回`0`。由于我们的`product.js`文件没有处理这个条件，它会给出一个错误。
- en: 'To fix this, we will modify our `product.js` and add these two lines to handle
    this logic to check whether the value is a number or not:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将修改我们的`product.js`，并添加这两行以处理此逻辑，检查值是否为数字：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, when we run our test again, we will get the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行我们的测试时，我们将得到以下输出：
- en: '![Running test task](img/00122.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试任务](img/00122.jpeg)'
- en: In the preceding example, we defined the HTML markup within the `beforeEach()`
    function in the `product.test.js` file. With simple applications, this may not
    be a cumbersome process to redefine the HTML markup as fixtures and use them to
    execute tests. However, most web applications are using some client-side frameworks
    such as Knockout, AngularJS, and so on, that separates the binding of controls
    specified in an HTML view to a ViewModel, and this ViewModel is responsible to
    read or write control values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们在`product.test.js`文件的`beforeEach()`函数内定义了HTML标记。对于简单的应用程序，重新定义HTML标记作为测试用例并使用它们来执行测试可能不是一个繁琐的过程。然而，大多数Web应用程序都使用一些客户端框架，如Knockout、AngularJS等，这些框架将HTML视图中的控件绑定到ViewModel，这个ViewModel负责读取或写入控件值。
- en: In the following example, we will use the Knockout JavaScript library that implements
    an Model-View-ViewModel pattern and see how unit tests can be written in this
    way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用实现Model-View-ViewModel模式的Knockout JavaScript库，并了解如何以这种方式编写单元测试。
- en: Implementing Model-View-ViewModel using Knockout and Run test
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Knockout实现模型-视图-视图模型并运行测试
- en: '**Model-View-ViewModel** (**MVVM**) is a design pattern for building user interfaces.
    It is divided into three parts, as show in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）是构建用户界面的设计模式。它分为三部分，如下面的图所示：'
- en: '![Implementing Model-View-ViewModel using Knockout and Run test](img/00123.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用Knockout和运行测试实现Model-View-ViewModel](img/00123.jpeg)'
- en: 'These three parts are described as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个部分如下所述：
- en: '**Model**: This contains the backend logic to invoke backend services and save
    or retireve data by communicating with the persistant storage.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这包含调用后端服务并通过与持久存储通信来保存或检索数据的后台逻辑。'
- en: '**ViewModel**: This contains the view-specific operations and data. It represents
    the model of the view to which the view elements binds to. For example, a form
    that contains some HTML elements will have a ViewModel, which is an object containing
    some properties to bind these controls with the data.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：这包含视图特定的操作和数据。它表示与视图元素绑定的视图模型。例如，包含一些HTML元素的表单将有一个ViewModel，这是一个包含一些要与这些控件绑定数据的属性的对象。'
- en: '**View**: This is the user interface to which the user interacts. It displays
    information from the ViewModel, raises events at the ViewModel, and updates it
    when the ViewModel changes.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是用户与之交互的用户界面。它显示来自ViewModel的信息，在ViewModel上引发事件，并在ViewModel更改时更新它。'
- en: Let's implement the MVVM pattern using the **Knockout** JavaScript library using
    the following steps.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**Knockout** JavaScript库按照以下步骤实现MVVM模式。
- en: Adding the Knockout package
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加Knockout包
- en: To start with, let's add Knockout.js in your ASP.NET Core application through
    `bower.json`. It can be added by making an entry in the dependencies section of
    the `bower.json` file, and Visual Studio automatically downloads the package and
    places it in the `wwwroot/lib/knockout` folder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过`bower.json`在你的ASP.NET Core应用程序中添加Knockout.js。可以通过在`bower.json`文件的依赖项部分添加条目来实现，Visual
    Studio会自动下载包并将其放置在`wwwroot/lib/knockout`文件夹中。
- en: 'The following statement can be added in the `bower.json` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句可以在`bower.json`文件中添加：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding ProductViewModel
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加ProductViewModel
- en: '`ProductViewModel` contains properties such as the product code, unit price,
    quantity, expiry, and total amount. Here is the code snippet of `ProductViewModel.js`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductViewModel`包含产品代码、单价、数量、到期日和总金额等属性。以下是`ProductViewModel.js`的代码片段：'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`ko` is basically the Knockout object that provides a complimentary way of
    linking an object model to the View, where `ko.observable()` is a Knockout function
    that makes the Model properties observable and sync with the View data. This means
    that when the ViewModel property''s value changes, View is updated; and when the
    control value is modified, the ViewModel property is updated.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko`基本上是提供一种补充方式的Knockout对象，将对象模型与视图链接起来，其中`ko.observable()`是一个Knockout函数，使Model属性变得可观察并与视图数据同步。这意味着当ViewModel属性值发生变化时，视图也会更新；当控件值被修改时，ViewModel属性也会更新。'
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`ko.applyBindings()` actually activates Knockout to perform the binding of
    the Model properties with the View elements.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.applyBindings()`实际上激活Knockout以执行Model属性与View元素的绑定。'
- en: Add the Product view
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加产品视图
- en: Knockout provides a very decent way of binding ViewModel properties to the control
    elements. Binding consist of two items, name and value, separated by a colon.
    To bind the ViewModel with the input elements, we can use the data-bind attribute
    and specify the value name followed with `:` and ViewModel's property name. Each
    control has a specific set of properties and it can be used to bind elements accordingly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout提供了一种非常合适的方式来将ViewModel属性绑定到控件元素上。绑定包括两部分，名称和值，由冒号分隔。为了将ViewModel与输入元素绑定，我们可以使用data-bind属性，并指定值名称后跟`:`和ViewModel的属性名称。每个控件都有一组特定的属性，可以根据需要进行元素绑定。
- en: 'For example, the `span` element can bind to the view model property using the
    text name as shown in the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是如何使用文本名称将`span`元素绑定到视图模型属性的示例：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the modified version of the Product view:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是产品视图的修改版本：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is all what we need to configure Knockout in the Product view. When the
    `btnSaveProduct` button is clicked, it will calculate the total amount and call
    the product service to save the record.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在产品视图中配置Knockout所需的所有内容。当点击`btnSaveProduct`按钮时，它会计算总金额并调用产品服务以保存记录。
- en: Modifying test configuration
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改测试配置
- en: 'Here is the modified version of `Gruntfile.js` created earlier. We added the
    `ProductViewModel.js` and the Knockout dependency in the `files` array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是之前创建的`Gruntfile.js`的修改版本。我们在`files`数组中添加了`ProductViewModel.js`和Knockout依赖项：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Modifying the product-testing script
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改产品测试脚本
- en: 'As we are not dependent on the HTML view directly, we can test our unit test
    cases through the Product view model. Here is the modified version of `product.test.js`
    that does not have any of the fixtures defined:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不直接依赖 HTML 视图，因此可以通过产品视图模型来测试我们的单元测试用例。以下是未定义任何固定装置的 `product.test.js` 修改版本：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following output will be generated when the test is run:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，将生成以下输出：
- en: '![Modifying the product-testing script](img/00124.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![修改产品测试脚本](img/00124.jpeg)'
- en: Debugging JavaScript
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 JavaScript
- en: JavaScript runs on client browsers, and almost all browsers, such as Internet
    Explorer, Microsoft Edge, Chrome, and Firefox, provide the integrated JavaScript
    debugger and **Developer Tools** window. With Visual Studio, we can also debug
    the JavaScript code by setting Internet Explorer as the default browser. Chrome
    is not supported out of the box, but with certain steps, its can be achieved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端浏览器上运行 JavaScript，几乎所有浏览器，如 Internet Explorer、Microsoft Edge、Chrome 和 Firefox，都提供集成的
    JavaScript 调试器和**开发者工具**窗口。使用 Visual Studio，我们还可以通过将 Internet Explorer 设置为默认浏览器来调试
    JavaScript 代码。Chrome 默认不支持，但通过某些步骤可以实现。
- en: Debugging options in Visual Studio 2015
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2015 年 Visual Studio 中的调试选项
- en: Visual Studio provides certain decent features to debug JavaScript and troubleshoot
    errors. JavaScript debugging in Visual Studio only works with Internet Explorer.
    Debugging can be started by starting the application in a debug mode and then
    placing some breakpoints in the JavaScript code. When the breakpoint is hit, we
    can use all sorts of debugging options in Visual Studio that we already know of
    and used in debugging the C# and VB.NET code. Options such as Step into (*F11*),
    Step over (*F10*), Step out (*Shift* + *F11*), conditional breakpoints, and watches,
    all work with the JavaScript code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 提供了某些相当不错的功能来调试 JavaScript 和解决错误。在 Visual Studio 中，只有与 Internet
    Explorer 一起使用时才能调试 JavaScript。通过以调试模式启动应用程序，然后在 JavaScript 代码中放置一些断点来开始调试。当达到断点时，我们可以使用在调试
    C# 和 VB.NET 代码时已经熟悉的 Visual Studio 中的所有调试选项，例如单步进入 (*F11*)，单步跳过 (*F10*)，单步退出 (*Shift*
    + *F11*)，条件断点，以及观察变量，所有这些选项都适用于 JavaScript 代码。
- en: Debugging from Visual Studio with Internet Explorer
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Internet Explorer 在 Visual Studio 中进行调试
- en: 'The default browser in Visual Studio for a particular web application project
    can be set from the **Web Browser (Internet Explorer)** | **Internet Explorer**
    option, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，可以为特定的网络应用程序项目设置默认浏览器，方法是选择**网络浏览器 (Internet Explorer)** |
    **Internet Explorer** 选项，如下面的屏幕截图所示：
- en: '![Debugging from Visual Studio with Internet Explorer](img/00125.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Internet Explorer 在 Visual Studio 中进行调试](img/00125.jpeg)'
- en: Debugging from Visual Studio with Google Chrome
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Google Chrome 在 Visual Studio 中进行调试
- en: Visual Studio 2015 does not provide out-of-the-box support to debug JavaScript
    applications, except with Internet Explorer. Alternatively, with Node.js, debugging
    works perfectly fine in Visual Studio, and as technically, both Node.js and Google
    Chrome are based on the V8 engine, there is no drawback.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年的 Visual Studio 不提供用于调试 JavaScript 应用程序的默认支持，除了与 Internet Explorer 一起使用的情况。作为
    Node.js 的技术基础与 Google Chrome 相同（都基于 V8 引擎），因此没有缺点。
- en: 'To start debugging with Chrome in Visual Studio, we have to run the Google
    `chrome.exe` file with a remote-debugger argument. The following command runs
    Google Chrome with remote debugging, and from Visual Studio, it can be attached
    by pointing to the same Chrome instance:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Visual Studio 中使用 Chrome 开始调试，我们必须使用远程调试器参数运行 Google 的 `chrome.exe` 文件。以下命令会使用远程调试运行
    Google Chrome，并且可以从 Visual Studio 指向相同的 Chrome 实例进行附加：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`9222` is the default port where Visual Studio connects on attaching to its
    process.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`9222` 是 Visual Studio 在附加到其进程时默认连接的端口。'
- en: From the Visual Studio, you can attach the process by hitting *Ctrl* + *Alt*
    + *P*, or by going to **Debug** | **Attach to Process** in menu bar and selecting
    the Chrome instance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Visual Studio 出发，您可以通过按下 *Ctrl* + *Alt* + *P*，或者通过在菜单栏中选择**调试** | **附加到进程**来附加进程，然后选择
    Chrome 实例。
- en: Developer Tools
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者工具
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The **Breakpoints** tab shows the list of all the breakpoints being used in
    the script, and the users can manage these breakpoints by enabling or disabling
    and deleting or adding new events:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**断点** 选项卡显示脚本中使用的所有断点列表，用户可以通过启用或禁用、删除或添加新事件来管理这些断点：'
- en: '![Debugging options in Microsoft Edge](img/00127.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Microsoft Edge 中的调试选项](img/00127.jpeg)'
- en: Debugging can only start if the **F12 Developers Tools** window is opened and
    this can be opened through the **…** | **F12 Developer Tools** window option from
    menu bar or by hitting the *F12* key. Once the window is opened, you can set breakpoints
    on the JavaScript code and take specific actions on the page.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当**F12开发者工具**窗口被打开时，调试才能开始，并且可以通过菜单栏的**…** | **F12开发者工具**窗口选项或按*F12*键来打开。窗口打开后，你可以在JavaScript代码上设置断点并对页面执行特定操作。
- en: 'The following table shows some important options available in the debugger
    toolbar:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了调试工具栏中一些重要的选项：
- en: '| Icon | Option | Shortcut Key | Description |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 图标 | 选项 | 快捷键 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ![Debugging options in Microsoft Edge](img/00128.jpeg) | Continue | *F5*
    or *F8* | This releases the break mode and continues till the next breakpoint.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00128.jpeg) | 继续 | *F5* 或 *F8* | 这将释放断点模式，并继续到下一个断点。|'
- en: '| ![Debugging options in Microsoft Edge](img/00129.jpeg) | Break | *Ctrl* +
    *Shift* + *B* | This breaks on the next statement. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00129.jpeg) | 断点 | *Ctrl* + *Shift* + *B* | 这将在下一条语句处设置断点。|'
- en: '| ![Debugging options in Microsoft Edge](img/00130.jpeg) | Step Into | *F11*
    | This steps into the function being called or the next statement. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00130.jpeg) | 步进 | *F11* | 这将步进到被调用函数或下一条语句。|'
- en: '| ![Debugging options in Microsoft Edge](img/00131.jpeg) | Step Over | *F10*
    | This steps over the function being called or the next statement. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00131.jpeg) | 单步跳过 | *F10* | 这将跳过被调用函数或下一条语句。|'
- en: '| ![Debugging options in Microsoft Edge](img/00132.jpeg) | Step Out | *Shift*
    + *F11* | This steps out of the current function and into the calling function.
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00132.jpeg) | 步出 | *Shift* + *F11* | 这将跳出当前函数，进入调用函数。|'
- en: '| ![Debugging options in Microsoft Edge](img/00133.jpeg) | Break on new worker
    | *Ctrl* + *Shift* + *W* | This breaks on the creation of a new web worker. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00133.jpeg) | 在新工作者创建时断点 | *Ctrl* + *Shift* +
    *W* | 这将在新web工作者创建时设置断点。|'
- en: '| ![Debugging options in Microsoft Edge](img/00134.jpeg) | Exception Control
    | *Ctrl* + *Shift* + *E* | This can be used to break on all exceptions or unhandled
    exceptions. By default, it is set to ignore exceptions. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00134.jpeg) | 异常控制 | *Ctrl* + *Shift* + *E* |
    这可用于在所有异常或未处理的异常处设置断点。默认情况下，它设置为忽略异常。|'
- en: '| ![Debugging options in Microsoft Edge](img/00135.jpeg) | Disconnect Debugger
    |   | This disconnects the debugger and no breakpoints run. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00135.jpeg) | 断开调试器 |   | 这将断开调试器，不再运行断点。|'
- en: '| ![Debugging options in Microsoft Edge](img/00136.jpeg) | Debug just my code
    | *Ctrl* + *J* | This ignores the third-party libraries from debugging. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00136.jpeg) | 只调试我的代码 | *Ctrl* + *J* | 这将忽略调试第三方库。|'
- en: '| ![Debugging options in Microsoft Edge](img/00137.jpeg) | Pretty print | *Ctrl*
    + *Shift* + *P* | This searches the minified version of the JavaScript block and
    makes it readible. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00137.jpeg) | 美丽打印 | *Ctrl* + *Shift* + *P* |
    这将搜索JavaScript块的压缩版本并使其可读。|'
- en: '| ![Debugging options in Microsoft Edge](img/00138.jpeg) | Word wrap | *Alt*
    + *W* | This wraps the sentence to adjust it as per the content pane size. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| ![Microsoft Edge中的调试选项](img/00138.jpeg) | 单词换行 | *Alt* + *W* | 这将根据内容窗体大小调整句子。|'
- en: 'Microsoft Edge provides the following five types of breakpoints:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Edge提供了以下五种断点类型：
- en: Standard
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准
- en: Conditional
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件
- en: Tracepoints
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪点
- en: XHR
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHR
- en: Events
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Standard breakpoints
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准断点
- en: 'These breakpoints can be set by simply selecting the statement from the script
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断点可以通过简单地从脚本代码中选择语句来设置：
- en: '![Standard breakpoints](img/00139.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![标准断点](img/00139.jpeg)'
- en: Conditional breakpoints
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件断点
- en: These type of breakpoints are hit when specific conditions are met or when the
    value of the variable reaches a specific state. For example, we can use this with
    a statement inside a loop and break the execution when the counter reaches a value
    of 10.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这类断点在满足特定条件或变量达到特定状态时会被触发。例如，我们可以在循环内的语句使用这个，当计数器达到10的值时中断执行。
- en: 'It can be set by clicking on the existing breakpoint and selecting **Condition...**
    from the **context** menu:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击现有断点并从**上下文**菜单选择**条件…** 来设置：
- en: '![Conditional breakpoints](img/00140.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![条件断点](img/00140.jpeg)'
- en: 'This option opens up the **Conditional breakpoint** window and the condition
    can be set as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将打开**条件断点**窗口，条件可以设置如下截图所示：
- en: '![Conditional breakpoints](img/00141.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![条件断点](img/00141.jpeg)'
- en: Once the condition is set, the icon changes to ![Conditional breakpoints](img/00142.jpeg)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了条件，图标将变为![条件断点](img/00142.jpeg)
- en: Tracepoints
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪点
- en: 'Tracepoints are used to write the message on the console when it passed through
    the statement where the tracepoint is configured. It can be set by clicking on
    the **Insert tracepoint** option from the **context** menu shown in the gutter
    by right-clicking:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪点用于在语句通过时在控制台写消息，跟踪点是通过点击以下选项设置的：**从**上下文菜单中点击**插入跟踪点**
- en: '![Tracepoints](img/00143.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪点](img/00143.jpeg)'
- en: 'Once the tracepoint is set, the icon changes, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了跟踪点，图标将发生变化，如下：
- en: '![Tracepoints](img/00144.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪点](img/00144.jpeg)'
- en: 'When the statement is executed, it will print the message on a console window
    as shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当语句执行时，它将在控制台窗口上打印如下截图中的消息：
- en: '![Tracepoints](img/00145.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪点](img/00145.jpeg)'
- en: Event
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: Microsoft Edge provides the option of registering event tracepoints and breakpoints
    from the **Breakpoints** pane. An event could be a mouse event, keyboard event,
    or timer event. This feature is heavily used in large or complex web applications
    where the exact location of specifying the breakpoint is not known. It is also
    more useful in cases where the event handlers are specified at multiple places.
    For example, if a page contains five button controls, and we need to break the
    execution whenever any button raises the click event, we can simply specify the
    mouse-click event through the breakpoint event; and whenever any button event
    is raised, the breakpoint will be executed and will focus on the statement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Edge提供了从**断点**面板注册事件跟踪点和断点的选项。事件可以是鼠标事件、键盘事件或定时器事件。这项功能在大型或复杂的网络应用程序中大量使用，在这些应用程序中，不知道确切的断点位置。在某些情况下，当事件处理程序在多个地方指定时，此功能更有用。例如，如果一个页面包含5个按钮控件，我们需要在任何一个按钮引发点击事件时中断执行，我们只需通过断点事件指定鼠标点击事件；每当任何按钮事件被引发时，断点将被执行并聚焦于该语句。
- en: Add event tracepoint
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加事件跟踪点
- en: 'A user can add event tracepoints with the help of the following option:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用以下选项添加事件跟踪点：
- en: '![Add event tracepoint](img/00146.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![添加事件断点](img/00146.jpeg)'
- en: 'The following window shows the registration of an event tracepoint when the
    mouse is clicked:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下窗口显示了当鼠标点击时事件跟踪点的注册情况：
- en: '![Add event tracepoint](img/00147.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![添加事件跟踪点](img/00147.jpeg)'
- en: Add event breakpoints
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加事件断点
- en: 'User can add event breakpoints with the help of the following option:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用以下选项添加事件断点：
- en: '![Add event breakpoints](img/00148.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![添加事件断点](img/00148.jpeg)'
- en: 'The following window shows the registration of an event breakpoint when the
    mouse is clicked:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下窗口显示了当鼠标点击时事件断点的注册情况：
- en: '![Add event breakpoints](img/00149.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![添加事件断点](img/00149.jpeg)'
- en: XHR
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XHR
- en: 'Just like events, XHR events can also be registered from the **Breakpoint**
    pane of browser. These events are invoked when any of the Ajax request is being
    made from the JavaScript code. A user can register the XHR event from the icon
    shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件类似，XHR事件也可以从浏览器的**断点**面板中注册。当从JavaScript代码中发起任何Ajax请求时，这些事件将被触发。用户可以从以下截图中的图标注册XHR事件：
- en: '![XHR](img/00150.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![XHR](img/00150.jpeg)'
- en: 'Once we click on this event, it will be added in the **Breakpoints** window,
    as shown in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击这个事件，它就会被添加到**断点**窗口中，如下截图所示：
- en: '![XHR](img/00151.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![XHR](img/00151.jpeg)'
- en: Debugging TypeScript
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试TypeScript
- en: In [Chapter 5](part0028_split_000.html#QMFO2-40dd2de0d2d94f79a49cd7a43c4b76e6
    "Chapter 5. Developing an ASP.NET Application Using Angular 2 and Web API"), *Developing
    an ASP.NET Application Using Angular 2 and Web API*, we already discussed TypeScript
    and how it transpiles into the JavaScript code that eventually runs on the browser.
    The developers write code in TypeScript, but on the browser, a generated JavaScript
    file is run. When the TypeScript file is transpiled to a JavaScript file, a mapping
    file is generated with a `*.map.js` extension. This file contains the information
    about the actual TypeScript file and the generated JavaScript file. Not only this,
    but the generated JavaScript file also contains one entry about the mapping file
    that actually tells the browsers to load the corresponding source TypeScript file
    by reading the mapping file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0028_split_000.html#QMFO2-40dd2de0d2d94f79a49cd7a43c4b76e6 "Chapter 5. Developing
    an ASP.NET Application Using Angular 2 and Web API") *使用Angular 2和Web API开发ASP.NET应用程序*中，我们已经讨论了TypeScript以及它如何转换成最终在浏览器上运行的JavaScript代码。开发人员用TypeScript编写代码，但在浏览器上运行的是生成的JavaScript文件。当TypeScript文件被转换成一个JavaScript文件时，会生成一个映射文件，其扩展名为`*.map.js`。这个文件包含了有关实际TypeScript文件和生成的JavaScript文件的信息。不仅如此，生成的JavaScript文件还包含了一个关于映射文件的条目，这个条目实际上告诉浏览器通过读取映射文件来加载相应的源TypeScript文件。
- en: 'Here is the entry that every generated JavaScript file contains when it is
    transpiled from TypeScript:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当TypeScript文件被转换成JavaScript文件时，每个生成的JavaScript文件都包含以下条目：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This can be configured from the `TSConfig.json` file through the `sourceMap`
    property. If the `sourceMap` property is `true`, it generates the mapping file
    and makes an entry in the generated JavaScript file. Also, when working in an
    ASP.NET Core application, all the static files have to be in the `wwwroot` folder.
    So, to debug the typescripts, all the corresponding typescript (`.ts`) files have
    to be moved to any folder under the `wwwroot` folder so that it can be accessible
    from the browser.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`TSConfig.json`文件中的`sourceMap`属性进行配置。如果`sourceMap`属性为`true`，它将生成映射文件，并在生成的JavaScript文件中创建一个条目。另外，在ASP.NET
    Core应用程序中工作的时候，所有的静态文件都必须放在`wwwroot`文件夹中。所以，为了调试TypeScript，所有相应的TypeScript (`.ts`)
    文件必须移动到`wwwroot`文件夹下的任何文件夹中，这样就可以通过浏览器访问了。
- en: 'Here is the debugger window, showing the list of TypeScript files on the left-hand
    side and the icon in the upper-right corner to toggle between the source file
    and compiled JavaScript version:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是有调试器窗口，它显示左侧的TypeScript文件列表和右上角的图标，可以切换源文件和编译后的JavaScript版本：
- en: '![Debugging TypeScript](img/00152.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![调试TypeScript](img/00152.jpeg)'
- en: Debugger keyword supported by all browsers
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有浏览器都支持`debugger`关键字
- en: 'We can also explicitly force to break the control at some point through the
    `debugger` keyword. If the breakpoint is not set, but the `debugger` keyword is
    specified, the debugging will be enabled and break the execution. It can be set
    from code as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过`debugger`关键字显式地在某个点上中断控制。如果没有设置断点，但是指定了`debugger`关键字，调试将启用并中断执行。它可以从代码中设置，如下面的屏幕截图所示：
- en: '![Debugger keyword supported by all browsers](img/00153.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![所有浏览器都支持`debugger`关键字](img/00153.jpeg)'
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed how JavaScript applications can be tested and
    debugged. For testing JavaScript applications, we discussed the Jasmine testing
    suite that can be easily plugged in with Karma, which is a test runner and can
    be used with Grunt to be executed from Visual Studio **Task Runner Explorer**
    window. We also discussed the basics of the MVVM pattern and how to implement
    it using the Knockout JavaScript library. We then modified the test case to work
    with the View model. For debugging, we discussed some tips and techniques of debugging
    JavaScript with Visual Studio and what Microsoft Edge offers through the **Developer
    Tools** window to make debugging easy. In the end, we also learned about the basic
    topics such as how Microsoft Edge enables debugging for TypeScript files and what
    configurations are required to achieve it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何测试和调试JavaScript应用程序。对于测试JavaScript应用程序，我们讨论了可以轻松与Karma（一个测试运行器）集成的Jasmine测试套件，它还可以与Grunt一起使用，从Visual
    Studio **任务运行器浏览器**窗口执行。我们还讨论了MVVM模式的基础知识以及如何使用Knockout JavaScript库来实现它。然后我们将测试用例修改为与视图模型一起工作。对于调试，我们讨论了使用Visual
    Studio调试JavaScript的一些技巧和技术，以及Microsoft Edge通过**开发者工具**窗口提供的内容，以使调试变得容易。最后，我们还学习了有关基本主题的知识，例如Microsoft
    Edge如何启用对TypeScript文件的调试以及实现此目的所需的配置。
