- en: Chapter 5. Using JSON with MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用MongoDB的JSON
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up MongoDB
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置MongoDB
- en: Installing the MongoDB database driver for Node.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Node.js安装MongoDB数据库驱动程序
- en: Installing the express module for Node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Node.js安装express模块
- en: Connecting to a MongoDB database using Node.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js连接MongoDB数据库
- en: Creating a document in MongoDB using Node.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js在MongoDB中创建文档
- en: Searching for a document in MongoDB with Node.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js在MongoDB中搜索文档
- en: Updating a document in MongoDB with Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js在MongoDB中更新文档
- en: Deleting a document in MongoDB using Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js在MongoDB中删除文档
- en: Using REST to search MongoDB
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST搜索MongoDB
- en: Using REST to create a document in MongoDB
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST在MongoDB中创建文档
- en: Using REST to update a document in MongoDB
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST更新MongoDB中的文档
- en: Using REST to delete a document in MongoDB
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST在MongoDB中删除文档
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we look at how you can use MongoDB as the backend storage for
    your web application. While not completely focused on JSON, as you'll see, this
    chapter's recipes give you a leg up in managing document creation, reading, updating,
    and deleting with MongoDB, first directly in Node.js, and then, using a REST server
    built for Node.js and MongoDB so that you can manage documents from a network
    client, such as a web application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用MongoDB作为Web应用程序的后端存储。虽然不是完全专注于JSON，但正如你所见，本章的食谱将帮助你管理使用MongoDB在Node.js中直接创建、读取、更新和删除文档，然后使用为Node.js和MongoDB构建的REST服务器，这样你就可以从网络客户端（如Web应用程序）管理文档。
- en: Setting up MongoDB
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置MongoDB
- en: Installing MongoDB varies by platform; on Linux, you may be able to use a package
    installer such as apt, while on Windows and Mac OS X (as well as on Linux, if
    you have a distribution that doesn't have a package manager with the MongoDB package),
    there are web downloads.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装MongoDB取决于平台；在Linux上，你可能可以使用像apt这样的包安装器，而在Windows和Mac OS X（以及如果你有没有包含MongoDB包的包管理器的Linux发行版）上，可以使用网页下载。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: On Mac OS X and Windows, it's as easy as going to [http://www.mongodb.org/](http://www.mongodb.org/)
    and follow the download link. At the time of writing, MongoDB is at version 2.6.7;
    there's a release candidate for version 3.0, which we won't discuss further here.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Mac OS X和Windows上，只需前往[http://www.mongodb.org/](http://www.mongodb.org/)并点击下载链接。在撰写本文时，MongoDB处于2.6.7版本；有一个3.0版本的候选发布，我们在这里不再进一步讨论。
- en: Mongo also provides packages for several common Linux distributions, including
    Debian and Fedora. There's also a package available for FreeBSD.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mongo还提供了针对几种常见Linux发行版的包，包括Debian和Fedora。还有一个适用于FreeBSD的包。
- en: Once you download and install Mongo, you need to make a place for MongoDB to
    store its database.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你下载并安装了Mongo，你需要为MongoDB提供一个存储数据库的地方。
- en: This varies by platform; on Windows, it's `c:\data\db.`
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这取决于平台；在Windows上，它是`c:\data\db.`
- en: Once you do this, you can start the database server by running `mongod`. You
    may also want to add the path to the MongoDB client and server binaries in your
    path so that you can access them easily from the command line.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你这样做，你可以通过运行`mongod`来启动数据库服务器。你可能还想将MongoDB客户端和服务器二进制文件的路径添加到你的路径中，这样你就可以从命令行轻松访问它们。
- en: 'When you run MongoDB''s server, you should see a bunch of log messages that
    read something like this:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行MongoDB服务器时，你应该会看到一堆类似于这样的日志消息：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll want to note the hostname (in this example, `KF6GPE-SURFACE`) on which
    the server is running, and the port number, which by default should be `27017`.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到服务器正在运行的主机名（在这个例子中，`KF6GPE-SURFACE`）和端口号，默认应该是`27017`。
- en: 'To connect to the MongoDB server directly, you can run `mongo` on the command
    line, like this:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要直接连接到MongoDB服务器，你可以在命令行上运行`mongo`，像这样：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To exit the `mongo` binary, hit *Ctrl* + *C* or type `exit`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出`mongo`二进制文件，请按*Ctrl* + *C*或输入`exit`。
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The double-clickable installer and Linux packages install the mongod binary,
    which is the database, as well as the Mongo command-line client.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 双击可执行安装程序和Linux包将安装mongod二进制文件，即数据库，以及Mongo命令行客户端。
- en: Installing the MongoDB database driver for Node.js
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装MongoDB数据库驱动程序（重复）
- en: You'll need to install database drivers for Node.js, so that Node.js can talk
    directly to the MongoDB server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为Node.js安装数据库驱动程序，这样Node.js就可以直接与MongoDB服务器通信。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'To get the database drivers, simply go to the project directory where you''ve
    got your Node.js files and run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数据库驱动程序，只需前往你拥有Node.js文件的项目的目录，并运行以下命令：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command will download the database drivers and install them for Node.js.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将下载数据库驱动程序并为Node.js安装它们。
- en: Installing the express module for Node.js
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Node.js安装express模块
- en: The express module for Node.js makes it easy to build Representational State
    Transfer (REST) server applications using Node.js. REST is a powerful paradigm
    in web programming that uses the HTTP methods `GET`, `POST`, `PUT`, and `DELETE`
    to manage the create, read, update, and delete (often abbreviated as CRUD) actions
    for document management in web services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的express模块使得使用Node.js构建表示状态转移（REST）服务器应用程序变得容易。REST是一种在网络编程中使用的强大范式，它使用HTTP方法`GET`、`POST`、`PUT`和`DELETE`来管理Web服务的文档管理的创建、读取、更新和删除（通常缩写为CRUD）操作。
- en: Using REST, the URLs are nouns representing what you want to manipulate, and
    the HTTP methods are verbs that perform the actions on those nouns.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST，URL是表示你想要操纵什么的名词，HTTP方法是动词，对那些名词执行动作。
- en: In the recipes that follow, we'll use node's express module to build a RESTful
    server that returns documents from Mongo, as well as supports the basic CRUD operations.
    Before you begin, you need to install three more modules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的食谱中，我们将使用Node.js的express模块构建一个RESTful服务器，该服务器从Mongo返回文档，并支持基本的CRUD操作。在开始之前，你需要安装三个额外的模块。
- en: How to do it…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去做…
- en: 'You''ll use `npm`, the Node.js package manager, to install the cross-object
    resource module to support cross-domain scripting, express module, and the body-parser
    module used by express. To do this, run in your project directory the following
    commands:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`npm`，Node.js的包管理器，来安装跨对象资源模块以支持跨域脚本，express模块，以及express使用的body-parser模块。为此，在你的项目目录中运行以下命令：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You also need a basic application, or skeleton, for your REST server, which
    consists of routes between URLs on the REST server, the HTTP methods, and the
    functions that perform the necessary database operations. This skeleton consists
    of two Node.js scripts that use the express module and an HTML document.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个基本的应用程序，或者骨架，用于你的REST服务器，它包括REST服务器之间的URL路由、HTTP方法以及执行必要数据库操作的函数。这个骨架包括使用express模块的两个Node.js脚本和一个HTML文档。
- en: 'The first Node.js script is the REST server itself, in `rest-server.js`, and
    it looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个Node.js脚本是REST服务器本身，位于`rest-server.js`中，它看起来像这样：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The package manager installs each of the modules, building them from source
    if needed. You''ll need all three modules: the CORS module to support cross-domain
    scripting requests, the express module for the REST server framework, and finally,
    the body-parser module to translate client object bodies from JSON to JavaScript
    objects.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器安装每个模块，如有需要，从源代码构建它们。你需要所有三个模块：CORS模块以支持跨域脚本请求、express模块用于REST服务器框架，最后，body-parser模块将客户端对象体从JSON转换为JavaScript对象。
- en: The skeleton script includes the express module, our *routes* file, which will
    define functions to handle each of the REST use cases, the CORS module, and the
    body-parser module needed by express to interpret object bodies sent by the client.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架脚本包括express模块、我们的*路由*文件，它将定义处理每个REST用例的函数、CORS模块以及express需要的body-parser模块来解释客户端发送的对象体。
- en: Once these are included, it defines an express module instance, named `app`,
    and configures it with CORS. This is necessary because by default, browsers won't
    make AJAX requests of servers at different domains than where their page content
    has come from, in order to prevent cross-side scripting attacks where servers
    are compromised and injected with malicious JavaScript. The CORS module sets up
    the necessary headers for the server to permit us to use our old Node.js server
    from the previous chapter on port `1337` to serve our content, and have our content
    access this REST server running on a different port.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包含这些，它定义了一个名为`app`的express模块实例，并用CORS对其进行配置。这是必要的，因为默认情况下，浏览器不会对页面的内容来源不同的域名服务器发起AJAX请求，以防止服务器被攻陷并注入恶意JavaScript的跨站脚本攻击。CORS模块为服务器设置必要的头，以便让我们可以使用上一章中的旧Node.js服务器在端口`1337`上提供内容，并让我们的内容访问在此不同端口上运行的REST服务器。
- en: 'Next, we get a reference to body-parser''s JSON parser, which we''ll use to
    parse the object bodies sent by the client for the insert and update requests.
    After this, we configure the Express app server instance with handlers for the
    top-level documents URL, which is used to access our MongoDB documents via REST.
    There are five possible operations at this URL:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取一个对body-parser的JSON解析器的引用，我们将用它来解析客户端为插入和更新请求发送的对象体。之后，我们用处理顶级文档URL的手动器配置Express应用服务器实例，该URL用于通过REST访问我们的MongoDB文档。在这个URL上有五种可能的操作：
- en: An HTTP GET of the URL `/documents` simply returns a list of all the documents
    in the database
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对URL `/documents`的HTTP GET simply returns a list of all the documents in the
    database
- en: An HTTP GET of the URL `/documents/<id>` returns the document with the given
    ID in the database
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对URL `/documents/<id>`的HTTP GET返回具有给定ID的数据库中的文档
- en: An HTTP POST to `/documents` with a document in the JSON format saves that document
    to the database
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`/documents`的HTTP POST，带有JSON格式的文档，将该文档保存到数据库中
- en: An HTTP PUT to `/documents/<id>` with a document in the JSON format updates
    the document with the given ID to have the contents that the client passes
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`/documents/<id>`的HTTP PUT，带有JSON格式的文档，更新具有给定ID的文档，使其包含客户端传递的内容
- en: An HTTP DELETE to `/documents/<id>` deletes the document with the given ID
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`/documents/<id>`的HTTP DELETE删除具有给定ID的文档
- en: Finally, the script starts the server listening on port `3000`, and logs the
    fact that the server has started.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，脚本在端口`3000`上启动服务器，并记录服务器已启动的事实。
- en: 'Of course, we need to define the functions in the documents object; we do this
    in the file `routes/documents.js`, which to begin with should look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要在文档对象中定义函数；我们是在文件`routes/documents.js`中完成的，该文件最初应看起来像这样：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code begins by importing the native MongoDB driver, setting variables
    to hold the server instance, database instance, and a converter interface that
    converts strings to MongoDB object IDs. Next, it creates an instance of the server
    connecting to our server instance (which must be running in order to succeed),
    and gets a reference to our database. Finally, it opens a connection to the database
    and inserts some sample data into the database if it's empty. (This code will
    be clearer after the first two recipes in this chapter, so if it seems a little
    confusing right now, just read along and you'll do fine!)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先通过导入本地MongoDB驱动程序开始，设置变量以保存服务器实例、数据库实例和一个转换器接口，该接口将字符串转换为MongoDB对象ID。接下来，它创建一个服务器实例，连接到我们的服务器实例（必须运行才能成功），并获得对我们数据库的引用。最后，它打开到数据库的连接，如果数据库为空，则在数据库中插入一些示例数据。（这个代码在阅读本章的前两个食谱后会更清晰，所以如果现在有些困惑，只需继续阅读，您会做得很好的！）
- en: The remainder of the `routes/documents.js` file defines functions to handle
    each of the REST use cases we wired up in the `rest-server.js` script. We'll flesh
    out each of the functions as we go along in our recipes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/documents.js`文件的其余部分定义了处理我们在这`rest-server.js`脚本中连接的每个REST用例的函数。我们将在食谱中逐步完善每个函数。'
- en: 'Finally, we need an HTML document that will access the REST server. Our document
    looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个HTML文档来访问REST服务器。我们的文档看起来像这样：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use a bit of jQuery to make the field access easier in the scripts (you'll
    see the scripts in the upcoming recipes for REST insertion, updating, removal,
    and querying). The HTML itself consists of three `div`, tags, one each for debugging,
    showing the raw JSON, and the result of each REST operation, and a form that lets
    you enter the fields you need to create, update, or delete records.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本中使用一些jQuery来使字段访问更加容易（您将在即将到来的REST插入、更新、删除和查询食谱中看到脚本）。HTML本身由三个`div`标签组成，分别用于调试、显示原始JSON和每个REST操作的结果，以及一个表单，让您输入创建、更新或删除记录所需的字段。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: For more information about the excellent Node.js express module, see [http://expressjs.com/](http://expressjs.com/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于卓越的Node.js express模块的更多信息，请参见[http://expressjs.com/](http://expressjs.com/)。
- en: 'MongoDB is a powerful document database, and there''s far more than we can
    cover here. For more information, check the Web, or look at the following resources
    from the PacktPub website:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个强大的文档数据库，这里涵盖的内容远远不够。更多信息，请上网搜索，或查看PacktPub网站上的以下资源：
- en: '*Instant MongoDB* by *Amol Nayak*.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Instant MongoDB* by *Amol Nayak*。'
- en: '*MongoDB Cookbook* by *Amol Nayak*.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MongoDB Cookbook* by *Amol Nayak*。'
- en: Connecting to a MongoDB database using Node.js
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js连接到MongoDB数据库
- en: Before your Node.js application can do anything with a MongoDB instance, it
    must connect to it over the network.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在你Node.js应用程序能够与MongoDB实例做任何事情之前，它必须通过网络连接到它。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The Node.js drivers for MongoDB contain all of the necessary network code to
    establish and break connections with MongoDB running on your local or remote machine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的Node.js驱动包含了所有必要的网络代码，用于与本地或远程机器上运行的MongoDB建立和断开连接。
- en: You need to include a reference to the native driver in your code and specify
    the URL of the database to connect to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在代码中包含对原生驱动的引用，并指定要连接的数据库的URL。
- en: 'Here''s a simple example that connects to the database and promptly disconnects:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的例子，它连接到数据库然后立即断开连接：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's break this down line by line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分解这个问题。
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first line includes the native driver implementation for Mongo in your Node.js
    application, and extracts a reference to the `MongoClient` object it defines.
    This object contains the basic interface you need to interact with the database
    over the network, defining the `connect` and `close` methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包括了Node.js应用程序中Mongo的本地驱动实现，并提取了它定义的`MongoClient`对象的引用。这个对象包含了与数据库通过网络交互所需的基本接口，定义了`connect`和`close`方法。
- en: 'The next line defines a string, `url`, that contains the URL of the database
    to connect to. The format of this URL is simple: it begins with the `mongodb`
    scheme to indicate that it''s a URL for the MongoDB server. Next is the hostname
    and port (in this case, we connect to the localhost on mongo''s default port,
    `27017`). Finally, we come to the name of the database to which you want to connect:
    in our case, `test`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行定义了一个字符串`url`，它包含了要连接的数据库的URL。这个URL的格式很简单：它以`mongodb`方案开始，以表示它是MongoDB服务器的URL。接下来是主机名和端口（在这个例子中，我们连接到本地主机的默认端口，即`27017`）。最后，我们来到你想要连接的数据库的名称：在我们的例子中，是`test`。
- en: 'If you''re using MongoDB''s user access control to control access to your database,
    you''ll need to specify a username and password, too. You do this just as you
    would for any other URL, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用MongoDB的用户访问控制来控制对数据库的访问，你还需要指定一个用户名和密码。你这样做的方式和你对任何其他URL的做法一样，像这样：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Whether to secure your database or not, of course, depends on your network topology
    and deployment; it's probably a good idea to do so in general.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，是否保护你的数据库取决于你的网络结构和部署；通常来说，这样做是个好主意。
- en: 'We pass this URL to the mongo object''s `connect` method, along with a function
    that the MongoDB native driver will call back once a connection has been successfully
    established, or if the connection failed. The driver invokes the callback function
    with two arguments: the first is an error code in the case of an error (or `null`
    on success), and a reference to a database object encapsulating the connection
    to the database you specified (which may be `null` if an error occurred establishing
    the connection).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个URL传递给mongo对象的`connect`方法，同时提供一个函数，当连接成功建立，或者连接失败时，MongoDB原生驱动会回调这个函数。驱动会以两个参数调用回调函数：第一个是出现错误时的错误代码（成功时为`null`），第二个是一个包含对你指定的数据库连接的数据库对象引用（如果建立连接时出现错误，则可能为`null`）。
- en: Our callback function is very straightforward; it prints a message containing
    the value of the error code passed and then we disconnect from the database using
    `close`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的回调函数非常直接；它打印一个包含传递给它的错误代码值的消息，然后我们使用`close`断开与数据库的连接。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Always call `close` on your database object when you're done using it to ensure
    that the native driver can successfully clean up after itself and disconnect from
    the database. If you don't, you run leaking connections to the database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用完数据库对象时，总是调用其`close`方法，以确保原生驱动能够成功清理自身并从数据库断开连接。如果你不这么做，你可能会导致数据库连接泄露。
- en: See also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见 also
- en: For more information about the native MongoDB driver for Node.js, see [http://docs.mongodb.org/ecosystem/drivers/node-js/](http://docs.mongodb.org/ecosystem/drivers/node-js/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为Node.js设计的MongoDB原生驱动的更多信息，请参阅[http://docs.mongodb.org/ecosystem/drivers/node-js/](http://docs.mongodb.org/ecosystem/drivers/node-js/)。
- en: Creating a document in MongoDB using Node.js
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js在MongoDB中创建文档
- en: The MongoDB database organizes its documents in *collections*, which are typically
    groups of documents that are related in some way (such as representing the same
    kinds of information). Because of this, your primary interface to documents is
    through a collection. Let's see how to get a collection and add a document to
    it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB数据库通过*集合*来组织其文档，这些集合通常是相关联的一组文档（例如表示相同种类信息的文档）。由于这个原因，您与文档交互的主要界面是通过一个集合。让我们看看如何获取一个集合并向其中添加一个文档。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A collection is a little like a table in relational databases, but there's no
    imposition that all documents in a collection have the same fields or the same
    types for each field. Think of it as an abstraction you can use to group similar
    kinds of documents.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 集合在关系型数据库中类似于一个表，但并没有规定集合中的所有文档必须具有相同的字段或每个字段相同的类型。可以将其视为一个用于分组类似文档的抽象概念。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做...
- en: 'Here''s a function that inserts two static items into the collection named
    `documents` in our test database, which we put in its own file and run using Node.js:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个函数，它使用Node.js在我们的测试数据库中名为`documents`的集合中插入两个静态条目：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I''ve broken the code up into two pieces to make the callback structure clear:
    the insert function, which actually performs the insertions, and the connection
    callback, which calls the insertion function.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我把代码分成两部分，以便使回调结构更清晰：实际执行插入的`insert`函数和连接回调，该回调调用插入函数。
- en: Let's take a closer look.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看。
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The code begins in the same way, by getting a reference to the `MongoClient`
    object it uses to talk to the database. The connection code is essentially the
    same, too; the URL is the same, and the only change is the call to the database's
    `collection` method, passing the name of the collection we're interested in. The
    collection method returns a `collection` object, which offers methods for the
    CRUD operations we'll use on the collection of documents.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的开始方式是一样的，通过获取一个对`MongoClient`对象的引用，它用这个对象与数据库通信。连接代码基本上也是一样的；URL是一样的，唯一的改变是对数据库的`collection`方法的调用，传递我们感兴趣的集合的名称。`collection`方法返回一个`collection`对象，该对象提供了我们对文档集合执行CRUD操作的方法。
- en: The `insert` function does a few things. It takes a collection on which you
    want to operate and a callback it will invoke when the insertion operation finishes
    or fails.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`函数做几件事情。它接收一个您想要操作的集合和一个回调函数，当插入操作完成或失败时，它将调用这个回调函数。'
- en: First, it defines a couple of static items to insert in the database. Note that
    these are plain old JavaScript objects; pretty much anything you can express as
    a JavaScript object, you can store in MongoDB. Next, it calls the collection's
    insert method, passing the objects to store and a callback the driver invokes
    after attempting the insertion.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它定义了要在数据库中插入的一对静态条目。请注意，这些只是普通的旧JavaScript对象；基本上，任何您可以表示为JavaScript对象的东西，您都可以存储在MongoDB中。接下来，它调用集合的`insert`方法，传递要存储的对象和一个回调函数，驱动程序在尝试插入后调用该函数。
- en: The driver calls the callback again, passing an error value (which is `null`
    on success) and the JavaScript objects *as they were inserted* into the collection.
    Our callback function logs the results to the console, and calls back the insertion
    function's callback, which closes the database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序再次调用回调函数，传递一个错误值（在成功时为`null`）和作为它们被插入到集合中的JavaScript对象。我们的回调函数将结果日志记录到控制台，并调用回调插入函数的回调，关闭数据库。
- en: 'What does an inserted record look like? Here''s an example from my console,
    once I ensure that we are running MongoDB as well:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的记录看起来是什么样子呢？以下是从我的控制台获取的示例，确保我们正在运行MongoDB：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the objects have the same fields, but they also have an additional
    `_id` field, which is the unique id of the object in the database. In the next
    section, you will learn how to query on that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些对象有相同的字段，但它们还有一个额外的`_id`字段，这是对象在数据库中的唯一标识符。在下一节中，您将学习如何针对该字段进行查询。
- en: There's more
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: What happens if you insert the same object multiple times into the database?
    Try it! You'll see that you get multiple copies of the object in the database;
    the fields aren't used to specify uniqueness (the exception is the _`id` field,
    which is unique across the database). Note that you can't specify an `_id` field
    yourself, unless you're assured that it's unique. To update an existing element,
    use the update method, which I described in the recipe *Updating a document in
    MongoDB with Node.js* in this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次将同一个对象插入数据库，会发生什么？试试看！你会发现数据库中有该对象的多个副本；字段不用于指定唯一性（例外是`_id`字段，它在整个数据库中是唯一的）。注意你不能自己指定一个`_id`字段，除非您确信它是唯一的。要更新现有元素，请使用更新方法，我在本章的*使用Node.js在MongoDB中更新文档*菜谱中描述了该方法。
- en: 'By default, MongoDB insertions operate quickly and might fail (say, if there''s
    a transitory network problem, or if the server is temporarily overloaded). At
    the cost of performance, you can pass `{ safe: true }` as the second argument
    to insert or to force the operation to wait for a successful operation or return
    an error if the operation fails.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，MongoDB的插入操作很快，可能会失败（比如说，如果网络存在临时问题，或者服务器暂时过载）。为了保证安全，你可以将`{ safe: true
    }`作为插入操作的第二个参数，或者等待操作成功，或者在操作失败时返回一个错误。'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: Refer to [http://docs.mongodb.org/manual/reference/method/db.collection.insert/](http://docs.mongodb.org/manual/reference/method/db.collection.insert/)
    for documentation about how to insert documents into MongoDB collections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[http://docs.mongodb.org/manual/reference/method/db.collection.insert/](http://docs.mongodb.org/manual/reference/method/db.collection.insert/)获取有关如何将文档插入MongoDB集合的文档。
- en: Searching for a document in MongoDB with Node.js
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js在MongoDB中搜索文档
- en: Being able to insert documents wouldn't do you much good if you didn't have
    a way to search for documents. MongoDB lets you specify a template on which to
    match, and returns objects matching that template.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能搜索文档，那么能够插入文档也帮助不大。MongoDB允许你指定一个模板进行匹配，并返回匹配该模板的对象。
- en: As with insertions and updates, you'll work with a collection of documents,
    invoking the collection's `find` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入和更新操作一样，你将处理一个文档集合，调用集合的`find`方法。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Here''s an example that finds all documents in the test collection with a call
    of `kf6gpe-7` and prints them to the console:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，它找到test集合中所有`kf6gpe-7`的文档，并将它们打印到控制台：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After connecting to the database, we invoke `find` in the collection, which
    returns a cursor you can use to iterate through the found values. The `find` method
    takes a JavaScript object that acts as a template indicating the fields that you
    want to match; our example matches records with a slot named `call` equal to `kf6gpe-7`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库后，我们在集合中调用`find`，它返回一个游标，您可以使用它遍历找到的值。`find`方法接受一个JavaScript对象，作为模板指示您想要匹配的字段；我们的例子匹配名为`call`的字段等于`kf6gpe-7`的记录。
- en: We don't iterate over the cursor but instead turn the entire collection of found
    values into a single array by using the cursor's `toArray` method. This is fine
    for our example because there aren't very many results, but be careful doing this
    with a database that has a lot of items! Fetching more than you really need from
    the database at once uses RAM and CPU resources better allocated to other parts
    of your application. It's better to iterate across the collection, or use paging,
    which we will discuss next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是遍历游标，而是通过使用游标的`toArray`方法，将找到的所有值转换成一个单一的数组。这对于我们的例子来说是可以的，因为结果并不多，但是在具有很多项的数据库上这样做要小心！一次性从数据库中获取比你实际需要更多的数据，会使用到应该分配给应用程序其他部分的RAM和CPU资源。最好是遍历集合，或者使用分页，我们接下来会讨论。
- en: There's more
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: 'The cursor has several methods you can use to iterate across your search results:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 游标有几种方法可供您遍历搜索结果：
- en: The `hasNext` method returns `true` if the cursor has another item that can
    be returned
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNext`方法如果游标还有其他可以返回的项，则返回`true`。'
- en: The `next` method returns the next matching item from the cursor
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`方法返回游标中的下一个匹配项。'
- en: The `forEach` iterator takes a function and calls the function on each item
    of the cursor's results sequentially
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`迭代器接收一个函数，按顺序对游标的每个结果调用该函数。'
- en: When iterating over a cursor, it's best to use a while loop with `hasNext` and
    call next, or use `forEach`; don't just convert the results to an array and loop
    across the list! Doing so requires the database to fetch all of the records at
    once, which can be very memory-intensive.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历游标时，最好使用带有`hasNext`的while循环并调用next，或者使用`forEach`；不要只是将结果转换为数组并在列表上循环！这样做需要数据库一次性获取所有记录，可能会非常占用内存。
- en: At times, there may be still too many items to deal with; you can limit the
    number of returned items using the cursor methods `limit` and `skip`. The `limit`
    method limits the search to the number of items you pass as an argument; the `skip`
    method skips the number of items you specify.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能仍然有太多的项目需要处理；您可以使用游标方法`limit`和`skip`来限制返回的条目数量。`limit`方法将搜索限制为您传递的参数数量的条目；`skip`方法跳过您指定的条目数量。
- en: 'In practice, the find method actually takes two arguments: a JavaScript object
    that is the criteria of the request and an optional JavaScript object defining
    the projection of the result set to new JavaScript objects.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，find方法实际上接受两个参数：一个JavaScript对象是请求的准则，一个可选的JavaScript对象定义了结果集的投影，以新的JavaScript对象形式返回。
- en: 'The criteria can be an exact match criteria, as you''ve seen in the previous
    example. You can also perform matching using the special operations `$gt` and
    `$lt`, which let you filter the given fields by cardinal order as well. For example,
    you might write:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 条件可以是精确匹配条件，正如你在上一个例子中看到的那样。你还可以使用特殊操作`$gt`和`$lt`进行匹配，这些操作允许你按基数顺序过滤给定字段。例如，你可能这样写：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will return all records with a `lng` field with a scalar value greater
    than 122.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有`lng`字段值大于122的记录。
- en: 'The projection is a list of fields that you''re interested in receiving from
    the database, each set to `true` or `1`. For example, the following code returns
    JavaScript objects containing only the `call` and `_id` fields:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 投影是一个你感兴趣的从数据库接收的字段列表，每个字段设置为`true`或`1`。例如，以下代码返回只包含`call`和`_id`字段的JavaScript对象：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See [http://docs.mongodb.org/manual/reference/method/db.collection.find/](http://docs.mongodb.org/manual/reference/method/db.collection.find/)
    for documentation on the MongoDB find method, which the native driver makes available
    to your Node.js application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[http://docs.mongodb.org/manual/reference/method/db.collection.find/](http://docs.mongodb.org/manual/reference/method/db.collection.find/)关于MongoDB
    find方法的文档，该方法是原生驱动程序使Node.js应用程序可用的。
- en: Updating a document in MongoDB with Node.js
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js在MongoDB中更新文档
- en: Updating a document in a collection is easy; simply use the collection's `update`
    method and pass the data you want to update.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中更新一个文档很容易；只需使用集合的`update`方法并传递您想要更新的数据。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s a simple example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The pattern of this is identical to the `insert` method; `update` is an asynchronous
    method that invokes a callback with an error code and a result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式与`insert`方法相同；`update`是一个异步方法，它调用一个带有错误代码和结果的回调。
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `update` method takes a template to match a document on and updates the
    first matching document with the field values you pass in the `$set` frame of
    the replacing JavaScript object. Note that you can add new fields to the document,
    too, as we did here; we add a new field `another` with a value of `true`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法采用一个模板来匹配文档，并用传递给`$set`的JavaScript对象的值更新第一个匹配的文档。注意，你也可以向文档中添加新字段，就像我们在这里做的那样；我们添加了一个名为`another`的新字段，其值为`true`。'
- en: You can specify a precise match to a specific document by passing an ID of the
    document in the `_id` field of the template you pass to update. The template you
    pass to `update` is a standard search query template, just like you'd pass to
    `find`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递文档的ID来指定与特定文档的精确匹配，该ID位于传递给update的模板的`_id`字段中。传递给`update`的模板是一个标准的查询模板，就像你会传递给`find`的那样。
- en: There's more…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'By default, `update` updates the first matching document. If you want it to
    update all the documents matching your template, pass the JavaScript object `{
    multi: true }` as the (optional) third argument to update. You can also have `update`
    perform an *upsert*, that is, an update on a match, and an insertion if the match
    doesn''t succeed. To do this, pass the JavaScript object `{ upsert: true }` as
    the third argument to update. These can be combined to match more than one document
    and upsert; if none are found, pass.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，`update`更新第一个匹配的文档。如果您想要它更新与您的模板匹配的所有文档，请在更新中传递一个可选的第三个参数，即JavaScript对象`{
    multi: true }`。您还可以让`update`执行*upsert*，即在匹配成功时进行更新，如果匹配不成功则进行插入。为此，在更新的第三个参数中传递JavaScript对象`{
    upsert: true }`。这些可以组合使用以匹配多个文档和执行upsert；如果没有找到，则传递。'
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Like insert, you can also pass `safe: true` in this option''s argument to ensure
    that the update attempts to succeed before returning at the cost of performance.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '类似于插入操作，您还可以在这个选项的参数中传递`safe: true`，以确保在返回之前update尝试成功，但这样做会牺牲性能。'
- en: The `update` method passes the number of updated documents as its result to
    your callback.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法将更新的文档数作为其结果传递给您的回调。'
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: See the MongoDB native driver documentation for update at [https://github.com/mongodb/node-mongodb-native](https://github.com/mongodb/node-mongodb-native)
    or the MongoDB update method documentation at [http://docs.mongodb.org/manual/reference/method/db.collection.update/](http://docs.mongodb.org/manual/reference/method/db.collection.update/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 参见MongoDB原生驱动程序文档中的update部分[https://github.com/mongodb/node-mongodb-native](https://github.com/mongodb/node-mongodb-native)或MongoDB
    update方法文档[http://docs.mongodb.org/manual/reference/method/db.collection.update/](http://docs.mongodb.org/manual/reference/method/db.collection.update/)。
- en: Deleting a document in MongoDB using Node.js
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js在MongoDB中删除文档
- en: At some point, you may want to delete a document in a collection using Node.js.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您可能希望使用Node.js在集合中删除文档。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'You do this using the `remove` method, which removes matching documents from
    the collection you specify. Here''s an example of how to call `remove`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用`remove`方法来实现，该方法会从您指定的集合中移除匹配的文档。以下是调用`remove`方法的示例：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: This code removes documents that have a call field with the value `kf6gpe-7`.
    As you may have guessed, the search criteria used for `remove` can be anything
    you'd pass to find. The `remove` method removes *all* documents matching your
    search criteria, so be careful! Calling `remove({})` removes all of the documents
    in the current collection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码移除了字段`call`值为`kf6gpe-7`的文档。正如您可能猜到的那样，`remove`的搜索条件可以是您会传递给find的任何东西。`remove`方法会移除*所有*与您的搜索条件匹配的文档，所以要小心！调用`remove({})`会移除当前集合中的所有文档。
- en: The `remove` method returns a count of the number of items removed from the
    collection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`方法返回从集合中删除的项目的数量。'
- en: See also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: For more information about MongoDB's remove method, see its documentation at
    [http://docs.mongodb.org/manual/reference/method/db.collection.remove/](http://docs.mongodb.org/manual/reference/method/db.collection.remove/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于MongoDB的remove方法，请参阅其文档[http://docs.mongodb.org/manual/reference/method/db.collection.remove/](http://docs.mongodb.org/manual/reference/method/db.collection.remove/)。
- en: Using REST to search MongoDB
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST搜索MongoDB
- en: By now, that you might be wondering where JSON comes into play when using MongoDB.
    When you access a MongoDB database instance using a RESTful interface such as
    mongo-rest, the documents are transferred to the client using JSON. Let's see
    how to get a list of documents from MongoDB.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能想知道在使用MongoDB时JSON扮演什么角色。当您使用像mongo-rest这样的RESTful接口访问MongoDB数据库实例时，文档会使用JSON传输到客户端。让我们看看如何从MongoDB获取文档列表。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Using REST with Node.js and MongoDB takes several steps.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js、MongoDB和REST需要几个步骤。
- en: Be sure you've set up the REST server as we discussed in the introduction. You'll
    need to have created the files `rest-server.js`, `routes/documents.js`, and `mongo-rest-example.html`
    with the UI for our RESTful application, and run both the REST server and the
    document server with Node.js.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已经按照介绍中的讨论设置了REST服务器。您需要创建`rest-server.js`、`routes/documents.js`和`mongo-rest-example.html`这些文件，其中包含我们RESTful应用的UI，并用Node.js同时运行REST服务器和文档服务器。
- en: Second, be sure that you're running MongoDB.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，确保您正在运行MongoDB。
- en: 'Next, to process the REST `GET` request, we need to define the function `exports.findAll`
    in `documents.js`, which should look like this:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了处理REST `GET`请求，我们需要在`documents.js`中定义函数`exports.findAll`，它应该如下所示：
- en: '[PRE17]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After this, we need the `doGet` script in the `mongo-rest-example.html` file,
    which makes an AJAX `GET` request to the REST server for the documents in the
    database. This code performs an AJAX `GET` request to the server''s `/documents/
    URL`, placing the resulting JSON in the `div` with the `id` json, and constructs
    an HTML table with one row for each resulting document in the result, providing
    columns for each document''s ID, call sign, latitude, and longitude:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要`mongo-rest-example.html`文件中的`doGet`脚本，它对REST服务器上的数据库文档发起AJAX `GET`请求。这段代码向服务器的`/documents/`
    URL发起AJAX `GET`请求，将返回的JSON放入具有`id`为json的`div`中，并构建一个HTML表格，每个结果文档的结果有一行，提供每个文档的ID、呼号、纬度和经度等列：
- en: '[PRE18]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `findAll` method is a straightforward query of the database, matching all
    documents in the database using `find` in our collection. You can extend it to
    take a query template as a URL argument and then pass that as a URL-encoded argument
    to the GET URL.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`findAll`方法是对数据库的直接查询，它使用`find`在我们的集合中匹配所有的文档。你可以扩展它以接受一个查询模板作为URL参数，然后将该参数作为URL编码的参数传递给GET
    URL。'
- en: You can also add additional arguments, such as arguments to limit and skip,
    which you should consider doing if you're processing a lot of data. Note that
    the Express module knows that it needs to JSON encode the JavaScript object to
    JSON before sending it to the client.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加其他参数，例如限制和跳过的参数，如果你处理的数据量很大，你应该考虑这样做。请注意，Express模块知道它需要将JavaScript对象JSON编码以JSON的形式发送给客户端。
- en: The `doGet` JavaScript is even simpler; it's a pure AJAX call, followed by a
    loop to unwrap the resulting returned JSON array into objects and present each
    object as a row in a table.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`doGet` JavaScript代码更简单；它是一个纯粹的AJAX调用，后面跟着一个循环，将返回的JSON数组解包为对象，并将每个对象作为表格中的一行呈现。'
- en: There's more
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'A good REST interface also provides an interface to query a specific item by
    ID because typically you''ll want to query the collection, find something interesting
    in it, and then maybe do something with that specific ID. We define the method
    `findById` to take an ID in the incoming URL, convert the ID to a MongoDB object
    `id`, and then perform a `find` on just that ID, like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的REST接口还提供了一个通过ID查询特定项目的接口，因为通常你希望查询集合，在其中找到一些有趣的内容，然后可能需要对这个特定的ID做些什么。我们定义了`findById`方法来接收来自URL的ID，将ID转换为MongoDB对象`id`，然后仅对该ID执行`find`，如下所示：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using REST to create a document in MongoDB
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST在MongoDB中创建文档
- en: 'In principle, using REST to create a document is simple: create the JavaScript
    object on the client, encode it as JSON, and `POST` it to the server. Let''s see
    how this works in practice.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，使用REST创建文档是简单的：在客户端创建JavaScript对象，将其编码为JSON，并`POST`到服务器。让我们看看这个在实际中是如何工作的。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'There are two pieces to this: the client piece and the server piece.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两部分：客户端部分和服务器部分。
- en: 'On the client side, we need some way to get the data for our new MongoDB document.
    In our example, it''s the fields of the form on the HTML page, which we wrap up
    and `POST` to the server using the client-side (in the HTML) method `doUpsert`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端，我们需要一种方式来获取我们新MongoDB文档的数据。在我们的例子中，它是HTML页面上的表单字段，我们将它们包装起来，并使用客户端（在HTML中）的`doUpsert`方法`POST`到服务器：
- en: '[PRE20]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The server accepts the posted document, automatically converts it from JSON
    using the body-parser module, and performs an insertion in the database, in the
    file documents.js:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接受提交的文档，自动使用body-parser模块将其从JSON转换，并在documents.js文件中执行数据库插入：
- en: '[PRE21]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The client code is used by both the insert and update buttons in the UI, which
    is why it's a little more complicated than you might first think. However, the
    only difference between an insert and an update in REST is the URL and the HTTP
    method (`POST` versus `PUT`), so it makes sense to use one method for both.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码被UI中的插入和更新按钮共同使用，这就是它比你可能最初想的要复杂一点的原因。然而，在REST中，插入和更新之间的唯一区别是URL和HTTP方法（`POST`与`PUT`），因此使用一个方法来处理两者是合理的。
- en: 'The client code begins by fetching the field values from the form using jQuery,
    and then sets the type of the request to `POST` for an update. Next, it constructs
    the REST URL, which should just be the base document''s URL because there''s no
    ID for a new document. Finally, it uses `POST` to send the JSON of the document
    to the server. The server code is straightforward: take the object body passed
    as a part of the request and insert it into the documents collection of the database,
    returning the result of the insertion to the client (this is a good pattern to
    follow, in case the client was the id of the newly created document for anything).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码首先使用jQuery从表单中获取字段值，然后将请求类型设置为`POST`以进行更新。接下来，它构建REST URL，这应该只是基本文档的URL，因为新文档没有ID。最后，它使用`POST`将文档的JSON发送到服务器。服务器代码很简单：取请求的一部分作为对象体，并将其插入到数据库的文档集合中，将插入的结果返回给客户端（这是一个很好的模式，以防客户端是新创建文档的ID用于任何事情）。
- en: 'On the server side, JSON decoding is handled automatically because we registered
    our handler for the `POST` request using the `jsonParser` instance from the body-parser
    module like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，因为我们在使用body-parser模块的`jsonParser`实例注册`POST`请求的处理程序时，JSON解码是自动处理的。
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you forget to pass a JSON parser to the routes registration, the request
    body field won't even be defined! So if you're inserting null documents in your
    database using Express, be sure to check that.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在路由注册时忘记传递JSON解析器，请求体字段甚至不会被定义！所以如果你在使用Express向数据库插入空文档，一定要检查这一点。
- en: Using REST to update a document in MongoDB
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST在MongoDB中更新文档
- en: Updating is identical to insertion, except that it needs a document ID and the
    client signals an update request with a HTTP `POST` request, rather than a `PUT`
    request.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 更新与插入相同，不同之处在于它需要一个文档ID，并且客户端使用HTTP `POST`请求而不是`PUT`请求来信号更新请求。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The client code is exactly the same as the previous recipe; only the server
    code changes because it needs to extract the ID from the URL and perform an update
    instead of an insert:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码与上一个食谱完全相同；只有服务器代码会更改，因为它需要从URL中提取ID并执行更新而不是插入：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's look at that in more detail.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看。
- en: How it works…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Returning to the client implementation for a moment in the previous recipe,
    you see that for an update, we included the ID in the URL. The `updateDocuments`
    method gets the ID from the request parameters and converts it to a MongoDB object
    `id` object, and then calls `update` with the document that the client passes
    with the `POST` request.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 回到前面食谱中的客户端实现，你看到对于更新，我们在URL中包含了ID。`updateDocuments`方法从请求参数中获取ID，并将其转换为MongoDB对象`id`对象，然后调用`update`，客户端通过`POST`请求传递的文档。
- en: Using REST to delete a document in MongoDB
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST在MongoDB中删除文档
- en: Like updating, deletion takes an object `id`, which we pass in the URL to the
    HTTP `DELETE` request.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与更新一样，删除需要一个对象`id`，我们将它在URL中传递给HTTP `DELETE`请求。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The `doRemove` method gets the object `id` from the `id` field in the form,
    and posts a `DELETE` message to the server at a URL consisting of the base URL
    plus the object `id`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`doRemove`方法从表单中的`id`字段获取对象`id`，并向由基本URL加上对象`id`组成的URL发送一个`DELETE`消息：'
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The deletion message handler on the server extracts the ID from the URL and
    then performs a `remove` operation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的删除消息处理程序从URL中提取ID，然后执行`remove`操作：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: On the client side, the flow is similar to the update flow; we get the ID from
    the `id` form element, and if it's null, it pops up an error dialog instead of
    doing the AJAX post. We make an AJAX post using the HTTP `DELETE` method, passing
    the `id` as the document name in the URL to the server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，流程与更新流程相似；我们从`id`表单元素中获取ID，如果它是null，它将弹出错误对话框而不是执行AJAX post。我们使用HTTP `DELETE`方法进行AJAX
    post，在URL中将`id`作为文档名称传递给服务器。
- en: On the server side, we get the ID from the request parameters, convert it to
    a MongoDB native object ID, and then pass it to the collection's remove method
    to remove the document. We then return either success or an error to the client.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们从请求参数中获取ID，将其转换为MongoDB本地对象ID，然后将其传递给集合的`remove`方法以删除文档。然后将成功或错误返回给客户端。
