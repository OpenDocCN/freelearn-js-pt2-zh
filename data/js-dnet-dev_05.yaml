- en: Chapter 5. Developing an ASP.NET Application Using Angular 2 and Web API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用Angular 2和Web API开发ASP.NET应用程序
- en: In this chapter, we will develop a complete application on ASP.NET Core using
    MVC 6 for MVC views and Web API for web services. For the client side, we will
    use Angular 2, which is one of the most popular frameworks for client-side development.
    Angular 2 is written in TypeScript, but it provides the option to write code in
    JavaScript and Dart. In this chapter, we will use TypeScript because it adheres
    to the ECMAScript 6 standard, with a provision to generate JavaScript when you
    build your project in ECMAScript 3, ECMAScript 4, and ECMAScript 5 standards.
    TypeScript is a superset of JavaScript and most of the things are common to both;
    in fact, TypeScript provides some features that in JavaScript are not implemented
    by many browsers, except Mozilla Firefox.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用MVC 6在ASP.NET Core上开发一个完整的应用程序，使用Web API进行网络服务。对于客户端，我们将使用Angular
    2，这是客户端开发中最受欢迎的框架之一。Angular 2是用TypeScript编写的，但它提供了用JavaScript和Dart编写代码的选项。在本章中，我们将使用TypeScript，因为它遵循ECMAScript
    6标准，并在构建项目时提供生成ECMAScript 3，ECMAScript 4和ECMAScript 5标准的JavaScript的能力。TypeScript是JavaScript的超集，两者的大部分内容是相同的；实际上，TypeScript提供了一些在许多浏览器中（除了Mozilla
    Firefox）没有实现的JavaScript特性。
- en: This chapter focuses on the basic concepts and takes you through a sample application
    to learn how Angular 2 can be used with ASP.NET Core and MVC 6.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍基本概念，并通过一个示例应用程序来介绍如何使用Angular 2与ASP.NET Core和MVC 6一起使用。
- en: TypeScript
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript
- en: TypeScript is a language developed by Microsoft and is a superset of JavaScript.
    TypeScript transpiles into JavaScript at compile time. Visual Studio 2015 automatically
    builds the TypeScript into JavaScript files and places them inside a folder configured
    with the `TypeScript.tsconfig` configuration file. It provides a lot more than
    JavaScript provides, but developers can still use some of the types and objects
    in TypeScript that they use in JavaScript. However, TypeScript generates cleaner
    and more optimized code, which is then run by the Angular 2 framework. So, when
    the TypeScript compiles, it generates JavaScript and stores a map file to handle
    debugging scenarios. Suppose you want to debug your TypeScript code from Visual
    Studio 2015; this mapping file contains the mapping information of the source
    TypeScript file and generated JavaScript file being run inside your Angular page
    and the break points can be set on your TypeScript file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软开发的一种语言，是JavaScript的超集。TypeScript在编译时转换成JavaScript。Visual Studio
    2015会自动将TypeScript构建成JavaScript文件，并将其放在配置了`TypeScript.tsconfig`配置文件的文件夹中。它提供的功能远超过JavaScript，但开发者仍然可以使用在TypeScript中使用的JavaScript中的某些类型和对象。然而，TypeScript生成的代码更干净、更优化，然后由Angular
    2框架执行。所以，当TypeScript编译时，它会生成JavaScript并存储一个映射文件以处理调试场景。假设你想从Visual Studio 2015调试你的TypeScript代码；这个映射文件包含了源TypeScript文件和生成的JavaScript文件在Angular页面中运行的映射信息，并且可以在TypeScript文件上设置断点。
- en: Compilation architecture of TypeScript
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript的编译架构
- en: The TypeScript compiler goes through several stages to compile TypeScript files
    and generate JavaScript files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器通过几个阶段来编译TypeScript文件并生成JavaScript文件。
- en: The compilation process starts with a pre-processor, which determines what files
    need to be included by following reference `/// <reference path=…/>` tags and
    `import` statements. Once the files are identified, the parser parses and tokenizes
    the source code into an **Abstract Syntax Tree** (**AST**).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程从预处理器开始，该预处理器通过遵循`/// <reference path=…/>`标签和`import`语句来确定需要包含哪些文件。一旦确定了文件，解析器就会解析和标记源代码到一个抽象语法树（AST）。
- en: An AST represents the syntactical structure of the source code in a tree format
    that consists of nodes. The binder then passes over the AST nodes and generates
    and binds symbols. One symbol is created for each named entity and if there are
    multiple entities with the same name, they will have the same symbol.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个抽象语法树（AST）以树状节点的格式表示源代码的语法结构。绑定器然后遍历AST节点并生成和绑定符号。每个命名实体创建一个符号，如果有多个具有相同名称的实体，它们将具有相同的符号。
- en: Symbols represent named entities and merge multiple files if several declarations
    are found. To represent a global view of all the files, a program is build. A
    program is the main entry point to the type system and code generation. Once the
    program is created, a type checker and an emitter can be created.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 符号代表命名实体，如果找到多个声明，它会合并多个文件。为了表示所有文件的全局视图，构建了一个程序。程序是类型系统和代码生成的入口点。一旦创建了程序，就可以创建类型检查器和发射器。
- en: A type checker is the core part of the TypeScript system, consolidates all the
    symbols from multiple files into a single view, and builds a symbol table. This
    symbol table contains the types of each symbol identified and merged into a common
    symbol. A type checker contains complete information about which symbol belongs
    to which node, the type of a particular symbol, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器是 TypeScript 系统的核心部分，它将多个文件中的所有符号集中到一个视图中，并构建一个符号表。这个符号表包含了每个识别并合并成一个公共符号的符号的类型。类型检查器包含关于哪个符号属于哪个节点、特定符号的类型等完整信息。
- en: 'Finally, an emitter is used by the TypeScript compiler, through a program,
    to generate the output file: `.js`, `.js.map`, `.jxs`, or `d.ts`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过程序，TypeScript 编译器使用发射器（emitter）来生成输出文件：`.js`、`.js.map`、`.jxs` 或 `d.ts`。
- en: Advantages of TypeScript
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 的优点
- en: The following are some core benefits of using TypeScript with Angular 2\.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用 TypeScript 配合 Angular 2 的核心好处。
- en: Superset of JavaScript
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 的超集
- en: TypeScript is a typed superset of JavaScript that compiles to JavaScript. The
    basic advantage of being a superset is that it provides the latest features of
    JavaScript that many browsers do not support yet. Developers use features such
    as async functions, decorators, and others during application development, which
    then compile into a JavaScript file that targets the ECMAScript 4 or ECMAScript
    3 versions, which browsers can easily understand and interpret.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是 JavaScript 的一个带类型超集，可以编译成 JavaScript。作为超集的基本优势在于，它提供了许多浏览器尚不支持的
    JavaScript 最新特性。开发者在应用程序开发过程中使用诸如异步函数（async functions）、装饰器（decorators）等特性，这些特性编译后形成针对
    ECMAScript 4 或 ECMAScript 3 版本的 JavaScript 文件，浏览器可以轻松理解和解释。
- en: Support for classes and modules
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持类和模块
- en: Typescript supports `class`, `interface`, `extends`, and `implements` keywords.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持 `class`、`interface`、`extends` 和 `implements` 关键字。
- en: 'Here is how you can define class in TypeScript:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 TypeScript 中如何定义类的示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the transpiled version of TypeScript in JavaScript:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 TypeScript 编译成 JavaScript 的版本：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Static type checking
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类型检查
- en: 'The main benefit of using TypeScript is static type checking. When you build
    your project, the TypeScript compiler checks the semantics and gives errors at
    compile time to avoid runtime errors. For example, the following code will give
    an error at compile time:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript 的主要好处是静态类型检查。当你构建你的项目时，TypeScript 编译器会检查语义，并在编译时给出错误以避免运行时错误。例如，以下代码将在编译时给出错误：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is another example that extends the `Person` class and gives a type mismatched
    error at compile type:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在编译时扩展 `Person` 类并给出类型不匹配错误的示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ECMAScript 6 feature support
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 ECMAScript 6 特性
- en: At the time of writing, most browsers still do not support ECMAScript 6 completely,
    but with TypeScript, we can write code and use ECMAScript 6 features. As ECMAScript
    6 supports backward compatibility, we can set the target version through the TypeScript
    configuration file, which generates the JavaScript based on the version specified.
    This helps developers to write code using ECMAScript 6 features and the output
    JS files will be generated in ECMAScript 3, ECMAScript 4, or ECMAScript 5 standards.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，大多数浏览器仍然不支持 ECMAScript 6 完全，但是有了 TypeScript，我们可以编写代码并使用 ECMAScript 6
    特性。由于 ECMAScript 6 支持向后兼容，我们可以通过 TypeScript 配置文件设置目标版本，根据所指定的版本生成 JavaScript。这帮助开发者使用
    ECMAScript 6 特性编写代码，生成的 JS 文件将基于 ECMAScript 3、ECMAScript 4 或 ECMAScript 5 标准。
- en: Optional typing
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选类型
- en: TypeScript supports strict typing and validates types at compile type, but using
    strict typing is not mandatory. You can even declare a variable without specifying
    its type and it will be resolved when the value is assigned.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持严格类型检查，并在编译时验证类型，但使用严格类型不是强制的。你甚至可以不指定变量的类型，在赋值时会解决它。
- en: Declaring types in TypeScript
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 TypeScript 中声明类型
- en: 'Here is an example of declaring a variable without its type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是没有声明变量类型的声明示例：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is an example of declaring a variable with types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是声明具有类型的变量的示例：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Core elements of TypeScript
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 的核心元素
- en: 'This section discusses the core elements of TypeScript:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论 TypeScript 的核心元素：
- en: Declaring variables
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明变量
- en: Types
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Classes and interfaces
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和接口
- en: Functions
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Iterators
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Modules and namespaces
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和命名空间
- en: Declaring variables
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明变量
- en: Variable declaration is equivalent to what we do in JavaScript. However, as
    TypeScript follows the ECMAScript 6 standard, it provides strong types as well.
    Strong types can be declared by naming a variable followed by a colon (`:`) and
    its type.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明与我们在 JavaScript 中做的相当。然而，由于 TypeScript 遵循 ECMAScript 6 标准，它也提供了强类型。强类型可以通过在变量名后加上冒号
    (`:`) 和其类型来声明。
- en: 'Here is a simple variable declaration in JavaScript:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 JavaScript 中的一个简单变量声明：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It can be declared in TypeScript as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在 TypeScript 中如下声明：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Variables can be initialized in TypeScript as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以通过以下方式在 TypeScript 中初始化：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Types
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: 'Most of the types available in TypeScript are equivalent to JavaScript types.
    The following table contains a list of all available types, with a code snippet
    for using them:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中大多数类型与 JavaScript 类型相当。以下表格包含所有可用类型的列表，以及使用它们的代码片段：
- en: '| Type | Description | Code snippet |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 | 代码片段 |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Number | TypeScript provides a number type that holds all types of decimal,
    hexadecimal, binary, and octal values. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | TypeScript 提供了一个数字类型，可以持有所有类型的十进制、十六进制、二进制和八进制值。 |'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| String | It''s the same as we use in any other language. String values can
    be surrounded with single or double quotes. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 这与我们在其他任何语言中使用的一样。字符串值可以用单引号或双引号括起来。 |'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Array | TypeScript supports simple arrays, and generic arrays as well. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | TypeScript 支持简单数组和泛型数组。 |'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Tuple | Through tuples, we can define an array whose element types are known.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 元组 | 通过元组，我们可以定义一个元素类型已知的数组。 |'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Enum | Used to give names to the numerical values. By default, the first
    value specified is `0` but can be set explicitly to any number. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | 用以给数值命名。默认情况下，指定的第一个值是 `0`，但可以显式设置为任何数字。 |'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Any | This type can be used in cases where the type is not known and is dependent
    on an assignment. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 任何 | 这个类型可以在不知道类型并且依赖于赋值的情况下使用。 |'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Classes and interfaces
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类和接口
- en: The following are the ways of defining interfaces, deriving classes and interfaces,
    and writing generic classes in TypeScript.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 TypeScript 中定义接口、派生类和接口以及编写泛型类的方法。
- en: Defining interfaces
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义接口
- en: Just like C#, TypeScript allows you to define interfaces that can be implemented
    in TypeScript classes and force the implementer class to implement all the members
    defined in the interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 C# 一样，TypeScript 允许你定义接口，这些接口可以在 TypeScript 类中实现，并强制实现类实现接口中定义的所有成员。
- en: 'Here is the code to define an interface in TypeScript:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 TypeScript 中定义接口的代码：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deriving classes and interfaces
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 派生类和接口
- en: 'Like C#, classes and interfaces can be extended by deriving from base classes
    or interfaces. To extend any class, we can use the `extends` keyword, and for
    an interface we can use implements, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 C# 一样，类和接口可以通过从基类或接口派生来扩展。要扩展任何类，我们可以使用 `extends` 关键字，而对于接口，我们可以使用 implements，如下所示：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, we have implemented the `IPerson` interface in the `Person` class, and
    finally derived the `Employee` class from `Person` and implemented the `IEmployee`
    interface. If you have noticed, as the `Person` class already implements the `IPerson`
    interface, we do not have to implement it again and only implement the properties,
    such as `empCode` and `designation` in the `Employee` class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `Person` 类中实现了 `IPerson` 接口，最后从 `Person` 派生了 `Employee` 类并实现了 `IEmployee`
    接口。如果你注意到了，由于 `Person` 类已经实现了 `IPerson` 接口，我们不需要再次实现它，只需要在 `Employee` 类中实现属性，比如
    `empCode` 和 `designation`。
- en: Generic classes
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 泛型类
- en: Generic classes are useful to define a particular class whose type is generic
    and determined when it is called. Generic classes can be defined by using `<T>`
    followed by the class name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类用于定义一个类型是泛型的特定类，并在调用时确定它的类型。泛型类可以通过使用 `<T>` 加上类名来定义。
- en: 'Here is a simple example that shows the generic class process, which can work
    as per the type specified during initialization. The `getTypeInfo()` method will
    print a specific message based on the type of object initialized:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单示例，展示了泛型类的过程，可以根据初始化时指定的类型工作。`getTypeInfo()` 方法将根据初始化的对象类型打印特定的消息：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Functions
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions can be defined in the same way as JavaScript. TypeScript supports
    both named and anonymous functions. In TypeScript, function parameters can be
    typed parameters, as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以像JavaScript一样定义。TypeScript支持命名和匿名函数。在TypeScript中，函数参数可以是类型参数，如下所示：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Functions can also have optional parameters and can be declared by using `(?)`
    as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以有可选参数，并且可以使用`(?)`来声明，如下所示：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this option, we can call the function by passing two parameters or three
    parameters because the third parameter is optional.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个选项，我们可以通过传递两个参数或三个参数来调用函数，因为第三个参数是可选的。
- en: Generic functions
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 泛型函数
- en: 'TypeScript allows you to define generic functions, which accept any type of
    argument or return type. Generic functions can be defined by specifying the `<T>`
    after the function name, as shown in the following code, and the arguments or
    returned type can also be generic and refer to the same `T` type. This is useful
    to define a particular function that accepts all types of arguments and works
    as expected. The following example shows the process function based on the type
    of argument concatenated or added:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许你定义泛型函数，它接受任何类型的参数或返回类型。泛型函数可以通过在函数名后指定`<T>`来定义，如下面的代码所示，参数或返回类型也可以是泛型的，并引用相同的`T`类型。这对于定义接受所有类型参数并按预期工作的特定函数很有用。以下示例展示了基于参数类型进行字符串拼接或相加的函数过程：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Iterators
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Apart from standard loops such as for, `while`, TypeScript also provides two
    types of for statements, `for..of` and `for..in`. Both statements iterate on collections.
    The difference between these is that the `for..of` statement returns the keys
    of the object whereas `for..in` returns the values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了for、`while`等标准循环，TypeScript还提供了两种for语句，`for..of`和`for..in`。这两种语句都用于遍历集合。这两种之间的区别在于，`for..of`语句返回对象的键，而`for..in`返回值：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Modules and namespaces
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块和命名空间
- en: ECMAScript 6 introduces the concept of modules. Modules can be thought of as
    logical containers that have their own scope. Any class, variable, or method declared
    inside a module is scoped within its own container and accessible to other modules
    only if it is allowed explicitly. In TypeScript, any file containing imports or
    exports at a top level are considered modules. Modules import one another using
    a module loader, and at runtime the module loader is responsible for loading all
    the dependencies of the module defined within it. Modules can be exported using
    the `export` keyword and other modules can import it using the `import` keyword.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6引入了模块的概念。模块可以被看作是具有自己作用域的逻辑容器。模块内部声明的任何类、变量或方法都局限于其自己的容器范围内，只有显式允许时才能被其他模块访问。在TypeScript中，任何包含导入或导出声明的文件都被视为模块。模块通过模块加载器相互导入，运行时模块加载器负责加载模块内定义的所有依赖项。模块可以通过使用`export`关键字导出，其他模块可以通过使用`import`关键字导入。
- en: 'Here is an example of defining and exporting a module in TypeScript:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在TypeScript中定义和导出一个模块的示例：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To use the module in some other area requires you to use the `import` keyword,
    as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他区域使用模块需要使用`import`关键字，如下所示：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Modules can be imported by using the `import` keyword. When importing any module,
    you have to use the `import` keyword, followed by the class name in brackets `{}`,
    followed by the actual filename that contains the class. For example, the following
    code shows the way of importing `ServiceManager` into `Main.ts`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`import`关键字导入模块。导入任何模块时，你必须使用`import`关键字，后面跟着类名的大括号`{}`，后面跟着包含类的实际文件名。例如，以下代码展示了将`ServiceManager`导入到`Main.ts`的方式：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also give a friendly name to the class, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以给类起一个友好的名字，如下所示：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Namespaces, on the other hand, are the logical modules to categorize classes,
    methods, and so on. Just like C#, they can be defined by using a `namespace` keyword.
    One namespace can be split across different TypeScript files and this gives developers
    a handy way of categorizing specific files to a single namespace. The following
    example shows the way to categorize TypeScript files into a single namespace and
    using them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，命名空间是用来分类类、方法等的逻辑模块。就像C#一样，它们可以使用`namespace`关键字来定义。一个命名空间可以跨越不同的TypeScript文件，这为开发者提供了一种方便的方式来将特定的文件分类到单个命名空间中。以下示例展示了如何将TypeScript文件分类到单个命名空间中并使用它们：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you notice, we have used a triple-slash directive, which is used to refer
    to the dependent files before executing the code in the TypeScript file. Therefore,
    as these files persist somewhere else, we have to explicitly reference them in
    the preceding code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，我们使用了三斜线指令，它用于在执行TypeScript文件中的代码之前引用依赖文件。因此，由于这些文件存在于其他地方，我们不得不在前面的代码中显式引用它们。
- en: To summarize, namespaces are a better method to use than modules as they categorize
    files logically by providing a friendly name, and allow developers to structure
    code properly when working with medium-to-large-sized projects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，命名空间是比模块更好的使用方法，因为它们通过提供友好名称来逻辑地分类文件，并在处理中到大型项目时允许开发者正确地组织代码。
- en: 'We can also give a shortened name to a namespace if it''s unfriendly by using
    an `import` keyword as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以给一个不友好的命名空间一个简短的名字，使用`import`关键词如下所示：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So this winds up the core topics of TypeScript. To learn more about TypeScript,
    you can refer to [http://www.typescriptlang.org/](http://www.typescriptlang.org/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这总结了TypeScript的核心主题。要了解更多关于TypeScript的信息，你可以参考[http://www.typescriptlang.org/](http://www.typescriptlang.org/)。
- en: Introduction to Angular 2
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2简介
- en: Angular 2 is a client-side framework to build web applications. It is very flexible
    in terms of being used with both mobile and web platforms. The basic advantage
    of using Angular is that it follows the ECMAScript 6 standard and developers can
    do object-oriented programming, define classes and interfaces, implement classes,
    and define data structures using **Plain Old JavaScript Objects** (**POJO**) for
    binding data. Another big advantage in terms of performance is the unidirectional
    data flow. Unlike Angular 1.x, Angular 2 provides both the option of doing two-way
    data binding or unidirectional data binding. In certain cases, unidirectional
    binding is good for performance. For example, when submitting a form, two way
    bindings with controls may be overkill.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2是一个用于构建网络应用程序的客户端框架。在移动端和网络平台的使用上非常灵活。使用Angular的一个基本优势在于它遵循ECMAScript
    6标准，开发者可以进行面向对象编程，定义类和接口，实现类，并使用**普通旧JavaScript对象**（**POJO**）来绑定数据定义数据结构。在性能方面，单向数据流是一个很大的优势。与Angular
    1.x不同，Angular 2提供了双向数据绑定或单向数据绑定的选项。在某些情况下，单向绑定对性能有利。例如，提交表单时，与控件的双向绑定可能过于复杂。
- en: Angular 2 architecture
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2架构
- en: 'Angular2 consist of a number of components. Each component can be bound to
    the page by either a selector, for example `<my-app> </my-app>`, or a routing
    module. Each component has a selector, template HTML or template reference link,
    directives, providers, and a controller class whose properties and methods can
    be accessed in the associated view. When the web application first starts, `System.import`
    loads the main component of the application, which bootstraps the root component.
    Here is a sample main component bootstrapping an Angular app:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Angular2包含许多组件。每个组件可以通过选择器绑定到页面，例如`<my-app> </my-app>`，或者路由模块。每个组件都有一个选择器，模板HTML或模板引用链接，指令，提供程序，和一个控制器类，其属性和方法可以在关联视图中访问。当网络应用程序第一次启动时，`System.import`加载应用程序的主要组件，引导根组件。这是一个引导Angular应用的主组件示例：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Providers can be defined inside square brackets. There are various providers
    available, which we will discuss in a later chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 提供程序可以在方括号内定义。有各种可用的提供程序，我们将在后面的章节中讨论。
- en: 'This `bootstrap` object is in `angular2/platform/browser`, which can be imported
    into the TypeScript file with the `import` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`bootstrap`对象在`angular2/platform/browser`中，可以用`import`命令导入TypeScript文件：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This `bootstrap` object directs Angular to load the component defined in it.
    When the component is loaded, all the attributes or metadata defined for the component
    are evaluated. Each component should have the `@Component` annotation, some properties
    to define metadata about the component, and one or more classes termed as component
    controllers that contain properties and methods accessible by the template defined
    in the `@Component template` or `templateUri` properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`bootstrap`对象指导Angular加载其中定义的组件。当组件被加载时，组件的所有属性或元数据都被评估。每个组件都应该有`@Component`注解，一些定义组件元数据的属性，以及一个或多个被称作组件控制器的类，它们包含可以通过定义在`@Component模板`或`templateUri`属性中的模板访问的属性和方法。
- en: 'Here is a sample `app.component.ts` that contains a selector, a template, and
    a class, `AppComponent`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含选择器、模板和类的`app.component.ts`示例，类名为`AppComponent`：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Events of component life cycle
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件生命周期事件
- en: 'When the component initializes, it goes through several events and has a very
    structured life cycle process. We can implement these events to do specific operations.
    The following table shows the list of events we can use in our component controller
    class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件初始化时，它会经历几个事件，并有一个非常结构化的生命周期过程。我们可以实现这些事件来执行特定的操作。下面的表格展示了我们可以在组件控制器类中使用的
    Events 列表：
- en: '| Event | Description |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ngOnInit()` | It is called after the component is initialized and the controller
    constructor is executed. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnInit()` | 组件初始化后且控制器构造函数执行时调用。 |'
- en: '| `ngOnDestroy()` | It is used to clean up resources when the component is
    disposed of. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnDestroy()` | 用于在组件被销毁时清理资源。 |'
- en: '| `ngDoCheck()` | It is used to override the default change detection algorithm
    for a directive. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `ngDoCheck()` | 用于覆盖指令的默认变更检测算法。 |'
- en: '| `ngOnChanges(changes)` | It is invoked when any of the component selector
    property values get modified. (Custom properties of the selectors can be defined
    through inputs.) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnChanges(changes)` | 当组件选择器属性值中的任何一项被修改时调用。(选择器的自定义属性可以通过输入定义。) |'
- en: '| `ngAfterContentInit()` | It is invoked when the directive''s content is initialized.
    (Directives are defined later.) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterContentInit()` | 当指令的内容被初始化时调用。(指令稍后定义。) |'
- en: '| `ngAfterContentChecked()` | It is invoked every time the directive''s content
    is checked. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterContentChecked()` | 每次检查指令的内容时都会被调用。 |'
- en: '| `ngAfterViewInit()` | It is invoked when the view is completely initialized.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterViewInit()` | 当视图完全初始化时调用。 |'
- en: '| `ngAfterViewChecked()` | It is invoked on every check of your component''s
    view. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterViewChecked()` | 在每次检查组件视图时调用。 |'
- en: Modules
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: 'A module represents a container that contains classes, interfaces, and more,
    to export functionality, so other modules can be imported using the `import` statement.
    For example, here is `math.ts`, used to perform different arithmetic operations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 模块代表一个包含类、接口等内容的容器，用于导出功能，以便其他模块可以使用`import`语句导入。例如，这是用于执行不同算术操作的 `math.ts`：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Components
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: 'A component is a combination of the `@Component` annotation to define metadata
    properties and the associated controller class that contains the actual code,
    such as the class constructor, methods, and properties. The `@Component` annotation
    contains the following metadata properties:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是`@Component`注解定义元数据属性和相关控制器类的组合，该控制器类包含实际的代码，如类构造函数、方法和属性。`@Component`注解包含以下元数据属性：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Core properties of Angular 2 components
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 组件的核心属性
- en: 'When defining a component, we can specify various properties, as listed previously.
    Here we will see some of the core properties that are often required when creating
    Angular 2 components:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义组件时，我们可以指定各种属性，如前所述。在这里，我们将看到一些在创建 Angular 2 组件时通常需要的核心属性：
- en: Templates and selectors
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板和选择器
- en: Inputs and outputs
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出
- en: Directives
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令
- en: Providers
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供商
- en: Templates and selectors
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板和选择器
- en: 'The following real example contains the template and the selector defined in
    the component class. When the button is clicked, it will call the `logMessage()`
    method, which prints the message in the `<p>` element. If you notice, we have
    not used the `export` keyword with the class because we have already bootstrapped
    the component on the same file and this component does not need to be referenced
    anywhere else:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的真实示例包含了在组件类中定义的模板和选择器。当按钮被点击时，它会调用`logMessage()`方法，该方法打印`<p>`元素中的消息。如果你注意到了，我们没有使用与类一起的`export`关键字，因为我们已经在同一个文件中引导了组件，而这个组件不需要在其他任何地方引用：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The app selector can be used anywhere in the HTML or `index.cshtml` page if
    working on an ASP.NET project, and the template will be rendered inside it. Here
    is an example of using the custom tag `my-app`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应用选择器可以在 HTML 页面或 `index.cshtml` 页面中任何地方使用，如果是在 ASP.NET 项目中工作，并且模板将在其中渲染。以下是为自定义标签
    `my-app` 使用的一个示例：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the page runs, it will render the output with this generated source:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦页面运行，它将渲染以下生成的源输出的输出：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inputs and outputs
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入和输出
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the `ChildComponent` class that contains the `logToConsole` and `showAlert`
    Boolean variables. These variables actually hold the values supplied from the
    notification tag. Finally, we have the `logMessage()` method that will be invoked
    on a button click event and either log the message on the developer''s console
    or show an alert message based on the value that has been set by the parent component
    in the hierarchy:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是包含`logToConsole`和`showAlert`布尔变量的`ChildComponent`类。这些变量实际上持有从通知标签传递的值。最后，我们有一个`logMessage()`方法，当按钮点击事件发生时将被调用，并根据在层次结构中由父组件设置的值，在开发者的控制台日志消息或显示一个警告消息：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `app.component.ts` file, where we have the main `AppComponent` defined,
    we can use the child selector as shown in the following code. When defining the
    child selector, we can set the values for custom inputs defined in the `ChildComponent`,
    `logToConsole` and `showAlert`. This way the parent component can specify the
    values to the child component through inputs. Here is the complete code of `AppComponent`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.component.ts`文件中，我们定义了主要的`AppComponent`，我们可以像下面的代码那样使用子选择器。在定义子选择器时，我们可以为`ChildComponent`中定义的自定义输入`logToConsole`和`showAlert`设置值。这样，父组件就可以通过输入向子组件指定值。以下是`AppComponent`的完整代码：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `@Output` property lists `clickLogButton` as a custom event that `ChildComponent`
    can emit, which its parent `AppComponent` will receive.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Output`属性列出了`clickLogButton`作为`ChildComponent`可以发出的自定义事件，其父组件`AppComponent`将会接收。'
- en: We have added `EventEmitter` in the `import` statement. `EventEmitter` is a
    built-in class that ships with Angular and provides methods for defining and firing
    custom events. Once the `logMessage()` method is executed, it will execute the
    `clickLogButton.next()` method from the `ChildComponent`, which finally calls
    the event registered in the `AppComponent`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`import`语句中添加了`EventEmitter`。`EventEmitter`是随Angular一起提供的内置类，提供定义和触发自定义事件的方法。一旦执行了`logMessage()`方法，它将执行来自`ChildComponent`的`clickLogButton.next()`方法，最终调用`AppComponent`中注册的事件。
- en: 'We have added the `clickLogButton` in the `AppComponent`, as shown in the following
    code. In Angular 2, we can specify the event by specifying the event name in brackets
    `()` followed by the method that will be called when the event is raised. This
    is how the event is registered. Here, `logMessage` is the local method defined
    in the `AppComponent`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`AppComponent`中添加了`clickLogButton`，如图下的代码所示。在Angular 2中，我们可以通过在括号`()`中指定事件名称，后跟当事件被触发时将被调用的方法，来指定事件。这就是事件注册的方式。在这里，`logMessage`是在`AppComponent`中定义的本地方法：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `logMessage` method is the method that will be invoked when the event is
    raised from the `ChildComponent`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`logMessage`方法是在从`ChildComponent`触发事件时将被调用的方法。'
- en: Directives
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令
- en: 'Directives are custom tags that render the HTML at runtime but encapsulate
    the rendering content in the directive itself. We can relate it to the tag helpers
    in ASP.NET. There are three kinds of directives, components, structural directives,
    and attribute directives:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是自定义标签，在运行时渲染HTML，但将渲染内容封装在指令本身中。我们可以将其与ASP.NET中的标记帮助器相比较。指令分为三种：组件、结构型指令和属性指令：
- en: '**Components**: It is a directive with a template.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：这是一个带有模板的指令。'
- en: '**Structural directive**: It is a directive to add or remove DOM elements.
    There are some built-in structural directives that Angular provides. Directives
    such as `ngIf`, `ngSwitch`, and `ngFor` are structural directives.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型指令**：这是一个用于添加或删除DOM元素的指令。Angular提供了一些内置的结构型指令，如`ngIf`、`ngSwitch`和`ngFor`。'
- en: '**Attribute directive**: It changes the appearance of any DOM element.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性指令**：它改变任何DOM元素的外观。'
- en: Creating a simple Hello World directive
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个简单的Hello World指令
- en: Directives can be created in a simple way, as a component is created, and can
    be referenced in the calling component through its selector tag.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可以像创建组件一样简单地创建，并且可以通过其选择器标签在调用组件中引用。
- en: 'Here is an example of `HelloWorldComponent` that defines a simple directive
    to display a "`Hello world"` message in the heading format:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`HelloWorldComponent`的示例，它定义了一个简单的指令，以标题格式显示“`Hello world`”消息：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following example is the component that uses this directive. When using
    any directive, it has to be first imported through the `import` statement, then
    the `@Component` metadata property needs to be set to access it in the associated
    template:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例是使用此指令的组件。使用任何指令时，首先必须通过`import`语句导入，然后需要设置`@Component`元数据属性，才能在相关模板中访问它：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This directive can be used on the page as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令可以在页面上的使用如下：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Structural directives
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构指令
- en: 'Structural directives can be used to add or remove DOM elements. For example,
    we can add the list of countries as a table through `*ngFor`, as shown in the
    following code, and hide or unhide the div through the `*ngIf` directive:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令可以用来添加或移除DOM元素。例如，我们可以通过`*ngFor`添加一个国家列表作为表格，如下面的代码所示，并通过`*ngIf`指令隐藏或显示div：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is the backend `countries.component.ts`, which uses the HTTP module to
    call the ASP.NET Web API service. It returns a list of countries, which is assigned
    to the `countries` array. The `display` default value is set to `true`, which
    generates the table. By setting the `display` value to `false`, the table will
    not be generated:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是后端`countries.component.ts`文件，它使用HTTP模块调用ASP.NET Web API服务。它返回一个国家列表，分配给`countries`数组。`display`的默认值设置为`true`，生成表格。通过将`display`值设置为`false`，将不会生成表格：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is how structural directives can be used in Angular 2\. In the following
    chapter, we develop a sample application and discuss each artifact for making
    HTTP `GET` and `POST` requests using Angular 2.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何在Angular 2中使用结构指令。在下一章中，我们将开发一个示例应用程序，并讨论每个艺术品以使用Angular 2进行HTTP `GET`和`POST`请求。
- en: Attribute directive
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性指令
- en: 'An attribute directive requires building a controller class annotated with
    `@Directive` and defines a selector to identify the attribute associated with
    it. In the following example, we will develop a simple `myFont` directive that
    changes the text to italic when it is applied to any page elements. Here is the
    `font.directive.ts` file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令需要构建一个用`@Directive`注解标记的控制器类，并定义一个选择器来识别与它关联的属性。在下面的示例中，我们将开发一个简单的`myFont`指令，当它应用于任何页面元素时，会将文本更改为斜体。以下是`font.directive.ts`文件的内容：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On the page level, it can be used as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面级别，它可以如下使用：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Providers
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供者
- en: Providers are used to register the types that gets instantiated through the
    dependency injection framework of Angular 2\. When a component is initialized,
    Angular creates a dependency injector which registers all the types specified
    in the providers array. Then at the constructor level, if there is any type defined
    in the providers array, it will get initialized and injected into the constructor.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者用于注册通过Angular 2的依赖注入框架实例化的类型。当组件初始化时，Angular创建一个依赖注入器，它注册提供者数组中指定的所有类型。然后在构造函数级别，如果提供者数组中有任何类型，它将得到初始化并在构造函数中注入。
- en: 'The following example is `MathComponent`, which will be injected into the main
    app component constructor and call the sum method to add two numbers together:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例是`MathComponent`，它将被注入到主应用组件构造函数中，并调用sum方法将两个数字相加：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following example is `AppComponent`, showing how to import a `math` component,
    then defining the provider and injecting it at the constructor level:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子是`AppComponent`，展示了如何导入一个`math`组件，然后定义提供者并在构造函数级别注入它：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Other primitive types can also be injected in a slightly different way using
    the Inject Angular module. We can also define a type using the `provide` keyword,
    which takes a key and the value:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以用稍微不同的方式通过注入Angular模块注入其他基本类型。我们还可以使用`provide`关键字定义一个类型，它需要一个键和值：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding syntax can also be used when defining types in providers, as
    follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法也可以在提供程序中定义类型时使用，如下所示：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: One of the main benefits of defining `providers` with the `provide` keyword
    is when testing. When testing applications, we can replace the actual components
    with the mock or test components. For example, suppose we have a class that calls
    some SMS service to send SMS using some paid gateway, and in the testing cycle
    we don't want to use the production SMS gateway component, but rather we would
    like to have some custom test component that just inserts the SMS into a local
    database. In this case, we can associate some mock class, such as `SMSTestComponent`,
    to perform testing scenarios.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`providers`时使用`provide`关键字的一个主要好处是在测试时。在测试应用程序时，我们可以用模拟或测试组件替换实际组件。例如，假设我们有一个类，它通过某种付费网关调用短信服务发送短信，在测试周期中我们不想使用生产短信网关组件，而是希望有一个自定义的测试组件，它只是将短信插入到本地数据库中。在这种情况下，我们可以将某个模拟类，如`SMSTestComponent`，与测试场景关联。
- en: 'The following example injects the string value into the constructor. We need
    to add the Inject module as specified in the following code, and then use `@Inject`
    to inject the value associated to the key:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将字符串值注入到构造函数中。我们需要按照以下代码添加Inject模块，然后使用`@Inject`注入与键关联的值：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Dependency injection in Angular
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Angular中的依赖注入
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, here is the `ChildComponent` code, which does not have the `MathComponent`
    provider defined in the `providers` array:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是`ChildComponent`的代码，其中没有在`providers`数组中定义`MathComponent`提供者：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Routing in Angular
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular中的路由
- en: 'Routing has an essential role when working with large applications. Routing
    is used to navigate to different pages. Routing can be defined in three steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型应用程序时，路由起着至关重要的作用。路由用于导航到不同的页面。路由可以在三个步骤中定义：
- en: 'Define `@RouteConfig` at any component level:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何组件级别定义`@RouteConfig`：
- en: '[PRE62]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Use the `[routerLink]` attribute on the anchor HTML tag and specify the route
    name configured in `@RouteConfig`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在锚点HTML标签上使用`[routerLink]`属性，并指定在`@RouteConfig`中配置的路由名称。
- en: Finally, add the `<router-outlet>` tag to render the page on the current navigated
    route.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加`<router-outlet>`标签以在当前导航到的路劲上渲染页面。
- en: 'The following example contains two components, `Page1Component` and `Page2Component`,
    and the main `AppComponent` has routing defined like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例包含两个组件，`Page1Component`和`Page2Component`，主`AppComponent`定义了如下路由：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding code, first we imported the `RouteConfig` and `ROUTER_DIRECTIVES`
    from `angular2/router` and then defined the `RouteConfig` for page 1 and page
    2\. In the inline template, we placed the anchor tag and defined the route name
    for page 2\. When the application runs, page 1 is set as a default page on a root
    path `/`, so the page 1 content will be displayed in place of the router outlet.
    When the user clicks on the `Page2` link, the page 2 content will be rendered
    in the same place.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先从`angular2/router`导入`RouteConfig`和`ROUTER_DIRECTIVES`，然后为页面1和页面2定义`RouteConfig`。在内联模板中，我们放置了锚点标签并为页面2定义了路由名称。当应用程序运行时，页面1被设置为根路径`/`上的默认页面，因此将在路由出口处显示页面1内容。当用户点击`Page2`链接时，将在同一位置渲染页面2的内容。
- en: 'Here is the code of `page1.component.ts`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`page1.component.ts`的代码：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here is the code of `page2.component.ts`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`page2.component.ts`的代码：
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Developing a to-do application in ASP.NET Core
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中开发待办事项应用程序
- en: We have learned the core features of Angular 2 and how to write programs in
    TypeScript. Now it's time to develop a simple to-do application using Angular
    2 and ASP.NET Core. ASP.NET Core is the latest web development platform from Microsoft,
    which is more optimized and modular than previous versions of ASP.NET. It provides
    an option to use the machine-wide .NET Framework, or a new .NET Core which runs
    on an app-by-app basis and even contains the framework binaries in the published
    web application folder itself. With the new ASP.NET Core, we are not dependent
    for running our application on IIS, and there are several other servers provided
    to run cross-platform using Kestrel. To learn more about ASP.NET Core, please
    refer to [http://docs.asp.net](http://docs.asp.net).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了Angular 2的核心功能以及如何用TypeScript编写程序。现在该是用Angular 2和ASP.NET Core开发一个简单的待办事项应用程序的时候了。ASP.NET
    Core是微软最新的网络开发平台，它比之前的ASP.NET版本更加优化和模块化。它提供了一种使用全局.NET Framework的选项，或者是一个新的.NET
    Core，它基于应用程序运行，甚至包含在发布的Web应用程序文件夹中的框架二进制文件。使用新的ASP.NET Core，我们不再依赖IIS来运行我们的应用程序，还有其他几种服务器可供跨平台使用Kestrel。要了解更多关于ASP.NET
    Core的信息，请参考[http://docs.asp.net](http://docs.asp.net)。
- en: 'We will go through a step-by-step tutorial that leads to a working to-do application.
    The following screenshot show a snapshot of the main page. Once the user logs
    in, it will show a list of all the to-do items available. User can add a new to-do
    item by clicking a **Create Todo** button and deleting the existing one as well.
    We will not be covering the security authentication and authorization module in
    this chapter, instead focusing on how to use Angular 2 with ASP.NET Core:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个逐步教程来构建一个可用的待办事项应用程序。下面的屏幕截图展示了主页的一个快照。用户登录后，它会显示所有可用的待办事项列表。用户可以通过点击**创建待办事项**按钮来添加一个新的待办事项，也可以删除现有的待办事项。在本章中，我们不会涵盖安全认证和授权模块，而是专注于如何使用Angular
    2与ASP.NET Core：
- en: '![Developing a to-do application in ASP.NET Core](img/00040.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![在ASP.NET Core中开发待办事项应用程序](img/00040.jpeg)'
- en: 'In this application, we will have three projects. `TodoWebApp` calls the `TodoServiceApp`,
    and `Common` is used by Web API, which holds the entity models. The following
    diagram shows how to develop these three projects and configure and use Angular
    2:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将有三个项目。`TodoWebApp`调用`TodoServiceApp`，`Common`被Web API使用，包含实体模型。以下图表显示了如何开发这三个项目以及配置和使用Angular
    2：
- en: '![Developing a to-do application in ASP.NET Core](img/00041.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![在ASP.NET Core中开发待办事项应用程序](img/00041.jpeg)'
- en: Creating a Common project
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Common项目
- en: '`Common` projects hold the entities that will be used by the Entity framework
    to create a database. We will reference this assembly in the Web API project at
    a later stage:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Common`项目包含Entity framework将使用的实体，以便创建数据库。稍后我们在Web API项目中引用这个程序集：'
- en: Create a .NET Core Class Library project:![Creating a Common project](img/00042.jpeg)
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建.NET Core类库项目：![创建一个Common项目](img/00042.jpeg)
- en: 'Add a new folder, `Models`, and add a `TodoItem` class as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新文件夹`Models`，并添加一个`TodoItem`类如下：
- en: '[PRE66]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding `TodoItem` class contains the `Id` (primary key) and `Title`,
    `Description`, `DueDateTime`, and the `UserID` to save to-dos for a specific user.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的`TodoItem`类包含`Id`（主键）和`Title`、`Description`、`DueDateTime`以及`UserID`，用于为特定用户保存待办事项。
- en: Creating a TodoServiceApp project
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个TodoServiceApp项目
- en: 'In this project, we will create a web API that will reference the `Common`
    project which contains the `TodoItem` POCO model. In this project, we will expose
    services and create a database repository that will use Entity Framework Core
    to perform **Create, Read**, **Update**, **and Delete** (**CRUD**) operations
    in the Microsoft SQL Server database:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建一个Web API，它将引用包含`TodoItem` POCO模型的`Common`项目。在这个项目中，我们将公开服务并创建一个数据库仓库，该仓库将使用Entity
    Framework Core在Microsoft SQL Server数据库中执行**创建、读取**、**更新**和**删除**（**CRUD**）操作：
- en: Create a new Web API project, choosing ASP.NET Core template. Web API and ASP.NET
    MVC have been merged into one unified framework, so there is no separate project
    template for Web API. In this case, we will use the Empty Project Model available
    in the ASP.NET Core project templates.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Web API项目，选择ASP.NET Core模板。Web API和ASP.NET MVC已经合并为一个统一的框架，因此没有单独的Web
    API项目模板。在这种情况下，我们将使用ASP.NET Core项目模板中的空项目模型。
- en: 'Open `project.json` and add a reference to our `Common` assembly:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`project.json`并添加对我们的`Common`程序集的引用：
- en: '[PRE67]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Enabling MVC in a Web API project
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Web API项目中启用MVC
- en: 'In order to enable the MVC project, we have to call `AddMvc()` in the `ConfigureServices`
    method, and `UseMvc()` in the `Configure` method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用MVC项目，我们必须在`ConfigureServices`方法中调用`AddMvc()`，在`Configure`方法中调用`UseMvc()`：
- en: 'Add the MVC package in `project.json`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`project.json`中添加MVC包：
- en: '[PRE68]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Call `AddMvc()` from the `ConfigureServices` method:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ConfigureServices`方法中调用`AddMvc()`：
- en: '[PRE69]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, call `UseMvc()` from the `Configure` method:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从`Configure`方法中调用`UseMvc()`：
- en: '[PRE70]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Installing Entity Framework
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Entity Framework
- en: 'Here are the steps to install Entity Framework:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在项目中安装Entity Framework的步骤：
- en: 'Add two Entity Framework assemblies, `Microsoft.EntityFrameworkCore.SqlServer`
    and `Microsoft.EntityFrameworkCore.Tools`, as shown in the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个Entity Framework程序集，`Microsoft.EntityFrameworkCore.SqlServer`和`Microsoft.EntityFrameworkCore.Tools`，如下所示：
- en: '[PRE71]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Adding AppSettings to store a connection string
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加AppSettings以存储连接字符串
- en: 'ASP.NET Core provides various options for storing application settings. The
    default configuration file is now `appsettings.json`, which stores the data in
    a JSON format. However, there are other methods available as well to store data
    in the environment variables, XML, and INI formats as well. In this project, we
    will store the connection string in the `appsettings.json` file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core为存储应用程序设置提供了各种选项。默认的配置文件现在是`appsettings.json`，以JSON格式存储数据。然而，还有其他方法可用于将数据存储在环境变量、XML和INI格式中。在这个项目中，我们将把连接字符串存储在`appsettings.json`文件中：
- en: 'Add the ASP.NET configuration file `appsettings.json` and specify the connection
    string as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加ASP.NET配置文件`appsettings.json`并指定连接字符串如下：
- en: '[PRE72]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Add the following packages in `project.json:`
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`project.json`中添加以下包：
- en: '[PRE73]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Configuring AppSettings in the Startup class
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Startup类中配置AppSettings
- en: The new configuration system of ASP.NET Core is based on `System.Configuration`.
    To use settings in our project, we will instantiate a `Configuration` object in
    our `Startup` class and use the `Options` pattern to access individual settings.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core的新配置系统基于`System.Configuration`。为了在我们的项目中使用设置，我们将在我们的`Startup`类中实例化一个`Configuration`对象，并使用`Options`模式访问个别设置。
- en: 'The `Options` pattern converts any class into a settings class and then we
    can inject that class into the controllers through ASP.NET''s built-in dependency
    injection. Through the `options` class, the developer can access the settings
    keys and values, as shown in the following steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Options`模式将任何类转换为设置类，然后我们可以通过ASP.NET内置的依赖注入将该类注入到控制器中。通过`options`类，开发者可以访问设置键和值，如下所示：'
- en: 'In the `Startup` class constructor, we will add the `appsettings.json` file
    using the `ConfigurationBuilder` object. `ConfigurationBuilder` allows a provision
    to add different providers and have a build method that builds the configuration
    stores in different providers and returns the `IConfigurationRoot` instance:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup`类构造函数中，我们将使用`ConfigurationBuilder`对象添加`appsettings.json`文件。`ConfigurationBuilder`允许添加不同的提供程序，并有一个构建方法，该方法在不同提供程序中构建配置存储，并返回`IConfigurationRoot`实例：
- en: '[PRE74]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Tip
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If multiple providers have the same keys, the last one specified in the `ConfigurationBuilder`
    will be used.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果多个提供程序有相同的键，将使用在`ConfigurationBuilder`中指定的最后一个。
- en: 'Now we can use the `Configuration` property to access the connection string,
    as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`Configuration`属性来访问连接字符串，如下所示：
- en: '[PRE75]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Adding data access in Web API
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Web API中添加数据访问
- en: 'In this section, we will add a `TodoContext` and `TodoRepository` class to
    perform CRUD operations:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个`TodoContext`和`TodoRepository`类来执行CRUD操作：
- en: 'Add a new folder, `DataAccess`, and add the `TodoContext` class, which will
    be derived from the `DbContext` class. This is the main `TodoContext` class Entity
    Framework used to create the database:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新文件夹，`DataAccess`，并添加`TodoContext`类，该类将从`DbContext`类派生。这是Entity Framework用于创建数据库的主要`TodoContext`类：
- en: '[PRE76]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We have to now override the `OnConfiguring()` method and call the `UseSqlServer()`
    method of the `DbContextOptionsBuilder` object. The `OnConfiguring()` method is
    called every time the `Context` object is initialized and configures the options
    specified. The `UseSqlServer()` method takes the connection string that is defined
    in the `appsettings.json` file, which we have configured in the `Startup` class.
    Now we want to inject the app settings object into this class. In order to do
    so, we will use the `Options` pattern. As per the options pattern, we shouldn't
    use the `Configuration` property we have defined in the `Startup` class directly,
    and instead we will create a custom POCO class that contains the same keys we
    have in our app settings file and overload the default `TodoContext` constructor,
    which accepts `IOptions<T>`, where `T` is our custom POCO app settings class.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要覆盖`OnConfiguring()`方法，并调用`DbContextOptionsBuilder`对象的`UseSqlServer()`方法。每次`Context`对象被初始化时都会调用`OnConfiguring()`方法，它配置了指定的选项。`UseSqlServer()`方法接收在`appsettings.json`文件中定义的连接字符串，我们已在`Startup`类中对其进行了配置。现在我们想要将app设置对象注入到这个类中。为此，我们将使用`Options`模式。根据选项模式，我们不应该直接使用在`Startup`类中定义的`Configuration`属性，而是将创建一个包含我们app设置文件中相同键的定制POCO类，并重载默认的`TodoContext`构造函数，该构造函数接受`IOptions<T>`，其中`T`是我们的自定义POCO应用设置类。
- en: 'As the connection string is defined in a nested object, our `Data` class will
    be as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为连接字符串定义在一个嵌套对象中，所以我们的`Data`类将是这样的：
- en: '[PRE77]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the `Startup` class, we will call the `services.Configure()` method to populate
    this `Data` object with the keys specified in the `appsettings.json` file, and
    inject it in the repository we will be creating next.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup`类中，我们将调用`services.Configure()`方法，用`appsettings.json`文件中指定的键填充这个`Data`对象，并在我们接下来要创建的存储库中注入它。
- en: 'Create a `TodoRepository` class that contains an `ITodoRepository` interface
    and its implementation, `TodoRepository`. This class will use the `TodoContext`
    object to perform database operations. Here is the code snippet for the `TodoRepository`
    class:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TodoRepository`类，其中包含一个`ITodoRepository`接口及其实现，`TodoRepository`。这个类将使用`TodoContext`对象执行数据库操作。以下是`TodoRepository`类的代码片段：
- en: '[PRE78]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the `Startup` class, add the Entity Framework in the `ConfigureServices()`
    method, as shown the following code. Our Web API controllers will have an overloaded
    constructor that takes the `ITodoRepository` object. We will use the `services.AddScoped()`
    method to inject `TodoRepository` wherever `ITodoRepository` is required. Finally,
    call the `services.Configure()` method to populate the `Data` object with the
    keys specified in the `appsettings.json` file:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup`类中，在`ConfigureServices()`方法中添加实体框架，如下面的代码所示。我们的Web API控制器将有一个带参数的构造函数，接收`ITodoRepository`对象。我们将使用`services.AddScoped()`方法在需要`ITodoRepository`的地方注入`TodoRepository`。最后，调用`services.Configure()`方法，用`appsettings.json`文件中指定的键填充`Data`对象：
- en: '[PRE79]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Enabling CORS in the ASP.NET Web API
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在ASP.NET Web API中启用CORS
- en: 'We learned about CORS in the previous chapter; we have to enable CORS in our
    Web API project, so that from Angular services we can make a request to access
    the `TodoService` methods:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们学习了CORS；我们必须在我们的Web API项目中启用CORS，这样从Angular服务中我们就可以请求访问`TodoService`方法：
- en: 'Call `services.AddCors()` in the `ConfigureServices` method in the `Startup`
    class:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup`类的`ConfigureServices`方法中调用`services.AddCors()`：
- en: '[PRE80]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Call `app.UseCors()` in the `Configure` method in `Startup` class:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup`类的`Configure`方法中调用`app.UseCors()`：
- en: '[PRE81]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Running database migration
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行数据库迁移
- en: 'We are using the Entity Framework Code First model, so now we want to create
    a database in Microsoft SQL Server. To do so, we will first add the Entity Framework
    tool support in the `project.json` file of the `TodoServiceApp`, and then run
    .NET CLI commands to add migrations and create the database:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用实体框架代码优先模型，所以现在我们想在Microsoft SQL Server中创建一个数据库。为此，我们首先将在`TodoServiceApp`的`project.json`文件中添加实体框架工具支持，然后运行.NET
    CLI命令以添加迁移并创建数据库：
- en: 'Add `Microsoft.EntityFrameworkCore.Tools` in the `project.json` file, as shown
    here:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`project.json`文件中添加`Microsoft.EntityFrameworkCore.Tools`，如下所示：
- en: '[PRE82]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now we can run commands, create migrations, and update the database.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以运行命令，创建迁移并更新数据库。
- en: To create migrations, go to the command prompt and navigate to the `TodoServiceApp`
    project where `project.json` resides.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建迁移，请打开命令提示符，导航到包含`project.json`的`TodoServiceApp`项目中。
- en: Then, run `dotnet ef migrations add Initial`, where `Initial` is the name of
    the migration created. Running this command will add the `Migrations` folder and
    a class containing code about the DDL operations.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行`dotnet ef migrations add Initial`命令，其中`Initial`是创建的迁移的名称。运行此命令将在`Migrations`文件夹中添加一个包含有关DDL操作的代码的类。
- en: 'The following screenshot shows the `Migrations` folder created after running
    the preceding command, and the creation of the `20160405115641_Initial.cs` file
    that contains the actual migration code snippets to apply or remove migration
    from the database:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的屏幕快照显示了在运行前面的命令后创建的`Migrations`文件夹，以及创建的`20160405115641_Initial.cs`文件，该文件包含实际迁移代码片段，用于从数据库应用或移除迁移：
- en: '![Running database migration](img/00043.jpeg)'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![运行数据库迁移](img/00043.jpeg)'
- en: 'To create a database, we need to execute another command in the same folder
    where `project.json` resides in the `TodoServiceApp` project:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建数据库，我们需要在`TodoServiceApp`项目的`project.json`文件所在的同一目录中执行另一个命令：
- en: '[PRE83]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This will create a database, and we can now go through, adding a controller
    to handle different HTTP requests and access the database.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个数据库，然后我们可以添加一个控制器来处理不同的HTTP请求并访问数据库。
- en: Creating a controller
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'Follow these steps to create a controller:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个控制器：
- en: Add a new `Controllers` folder and add a class named `TodoController`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新的`Controllers`文件夹，并添加一个名为`TodoController`的类。
- en: 'Here is the code snippet for the `TodoController` class:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是对`TodoController`类的代码片段：
- en: '[PRE84]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now we have completed our `TodoService` project, so we will develop a todo web
    application project and configure Angular 2.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`TodoService`项目，接下来我们将开发一个待办事项网页应用程序项目，并配置Angular 2。
- en: Creating a TodoWebApp project
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建TodoWebApp项目
- en: 'We will develop a single-page application and use the MVC view to render it
    using Angular 2\. This application will have one main page that lists all the
    to-do items for a particular user, whereas to add a new to-do item, a new page
    will open in a modal dialog window:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个单页应用程序，并使用MVC视图用Angular 2渲染它。这个应用程序将有一个主要页面，列出特定用户的全部待办事项，而要添加一个新的待办事项，新的页面将在模态对话框窗口中打开：
- en: To start, let's create an empty project using the ASP.NET Core project template
    available in Visual Studio 2015, and name it `TodoWebApp`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用Visual Studio 2015中可用的ASP.NET Core项目模板创建一个空项目，并将其命名为`TodoWebApp`。
- en: 'Add an MVC reference in `project.json`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`project.json`中添加MVC参考：
- en: '[PRE85]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In the `Startup` class, add the `AddMvc()` method in the `ConfigureServices`
    method and the `UseMvc()` method in the `Configure` method. Here is the code snippet
    of the `Startup` class:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup`类中，在`ConfigureServices`方法中添加`AddMvc()`方法，在`Configure`方法中添加`UseMvc()`方法。以下是`Startup`类的代码片段：
- en: '[PRE86]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Configuring Angular 2 in the TodoWebApp project
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在TodoWebApp项目中配置Angular 2
- en: 'Angular 2 is part of the Node module, and we can add Node packages through
    the **Node Package Manager** (**NPM**) configuration file, `package.json`. In
    `package.json`, we can add packages through the `devDependencies` node and the
    `dependencies` node. The `devDependencies` node holds the packages that are used
    during development, such as `Gulp`, which can be used to concatenate and minify
    JavaScript and CSS files, TypeScript for developing Angular 2 components, and
    `rimraf` to delete the files. In the `dependencies` node, we will specify packages
    such as `angular2`, `systemjs`, `reflect-metadata`, `rxjs`, and `zone.js`, which
    will be used when the application runs:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2是Node模块的一部分，我们可以通过**Node包管理器**（**NPM**）配置文件`package.json`添加Node包。在`package.json`中，我们可以在`devDependencies`节点和`dependencies`节点添加包。`devDependencies`节点包含开发过程中使用的包，例如`Gulp`，它可以用来合并和压缩JavaScript和CSS文件，TypeScript用于开发Angular
    2组件，以及`rimraf`用于删除文件。在`dependencies`节点中，我们将指定如`angular2`、`systemjs`、`reflect-metadata`、`rxjs`和`zone.js`等包，这些包在应用程序运行时使用：
- en: 'Add a new `package.json` file from the Visual Studio project template option
    **NPM Configuration File** and add the following JSON snippet:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Visual Studio项目模板选项**NPM配置文件**中添加一个新的`package.json`文件，并添加以下JSON片段：
- en: '[PRE87]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Visual Studio automatically downloads and restores packages specified in the
    `package.json` file, creates a `node_modules` folder in the project itself, and
    places all the packages there. The `Node_modules` folder is basically hidden by
    default in Visual Studio, but can be made visible by enabling the `ShowAllFiles`
    option.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视觉工作室会自动下载并恢复`package.json`文件中指定的包，在项目本身创建一个`node_modules`文件夹，并将所有的包放在那里。`Node_modules`文件夹在视觉工作室中默认是隐藏的，但可以通过启用`ShowAllFiles`选项使其可见。
- en: Dependencies
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'The following is the list of dependencies with their descriptions:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有描述的依赖项列表：
- en: '`angular2`: It is the Angular 2 package.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular2`：这是Angular 2的包。'
- en: '`systemjs`: It provides `System.import` to hook up the main entry point of
    Angular.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemjs`：它提供了`System.import`来连接Angular的主入口点。'
- en: '`reflect-metadata`: It is a proposal to add decorators to ES7\. Through this,
    we can specify the metadata to our class in Angular 2.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect-metadata`：这是一个添加装饰器到ES7的提案。通过这个，我们可以在Angular 2中指定我们类的元数据。'
- en: '`rxjs`: It is a reactive streams library that allows working with asynchronous
    data streams.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxjs`：它是一个反应式流库，允许处理异步数据流。'
- en: '`zone.js`: It provides an execution context that persists across asynchronous
    tasks.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zone.js`：它提供了一个在异步任务之间持续存在的执行上下文。'
- en: Development dependencies
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开发依赖项
- en: 'The following is the list of development dependencies with their descriptions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开发依赖项及其描述的列表：
- en: '`gulp`: Used to copy the files to the `wwwroot` folder'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gulp`：用于将文件复制到`wwwroot`文件夹'
- en: '`typescript`: Used to write programs in TypeScript'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typescript`：用于编写TypeScript程序'
- en: Configuring TypeScript
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置TypeScript
- en: 'To configure TypeScript, perform the following steps:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 配置TypeScript，请执行以下步骤：
- en: Add the `Scripts` folder where all the TypeScript files reside. In the current
    version of ASP.NET, there is a restriction on naming this folder `Scripts`, and
    it should be added in the root of the project; otherwise, TypeScript files will
    not be transpiled to JavaScript files.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Scripts`文件夹，其中包含所有TypeScript文件。在当前版本的ASP.NET中，对命名此文件夹`Scripts`有一个限制，它应该添加到项目的根目录中；否则，TypeScript文件将不会被转换成JavaScript文件。
- en: 'After adding the `Scripts` folder, add the TypeScript configuration file (`tsconfig.json`)
    and add the following configuration to it:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Scripts`文件夹后，添加TypeScript配置文件（`tsconfig.json`）并在其中添加以下配置：
- en: '[PRE88]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Configurations defined within the `compilerOptions` node are used by Visual
    Studio when you build your project. Based on the configuration, the JavaScript
    files are generated and stored in the output directory. The following table shows
    the description of each property specified in the preceding code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`compilerOptions`节点中定义的配置在您构建项目时被Visual Studio使用。根据配置，JavaScript文件被生成并存储在输出目录中。以下表格展示了前述代码中每个属性的描述：'
- en: '| Compiler options | Description |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 编译器选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `noImplicitAny` | If `true`, then it warns the expression implied with `any`
    type |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `noImplicitAny` | 如果为`true`，则警告隐含`any`类型的表达式 |'
- en: '| `noEmitOnError` | If `true`, it does not generate JavaScript if any errors
    are present in the TypeScript |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `noEmitOnError` | 如果为`true`，则在TypeScript中存在错误时不会生成JavaScript |'
- en: '| `removeComments` | It `true`, removes comments when generating JavaScript
    files |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `removeComments` | 如果为`true`，在生成JavaScript文件时移除注释 |'
- en: '| `sourceMap` | If `true`, then generates the corresponding map file |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `sourceMap` | 如果为`true`，则生成相应的映射文件 |'
- en: '| `Target` | Sets the target ECMA script version, such as ES5 |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `Target` | 设置目标ECMA脚本版本，如 ES5 |'
- en: '| `modulez` | Specifies the module that generated the code, such as `commonjs`,
    `AMD`, or `system` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `modulez` | 指定生成代码的模块，如 `commonjs`、`AMD` 或 `system` |'
- en: '| `moduleResolution` | Specifies the module resolution strategy, such as node
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `moduleResolution` | 指定模块解析策略，如 node |'
- en: '| `outDir` | Path where the generated JavaScript files will be dumped |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `outDir` | 生成的JavaScript文件将被倾倒的路径 |'
- en: '| `mapRoot` | Path where the map files will be located |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `mapRoot` | 地图文件将位于的路径 |'
- en: '| `experimentalDecorators` | If `true`, it enables support for ES7 experimental
    decorators |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `experimentalDecorators` | 如果为`true`，则启用对ES7实验性装饰器的支持 |'
- en: '| `emitDecoratorMetadata` | If `true`, it emits design-type metadata for decorator
    declarations in source |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `emitDecoratorMetadata` | 如果为`true`，则在源中为装饰器声明发射设计类型的元数据 |'
- en: Configuring Gulp
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置 Gulp
- en: 'In this section, we will use Gulp to minify the JavaScript generated by the
    TypeScript compiler:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Gulp对TypeScript编译器生成的JavaScript进行压缩：
- en: Add the Gulp configuration file, `gulpfile.js`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Gulp配置文件`gulpfile.js`。
- en: Gulp is used to run tasks, and Visual Studio provides a task runner window that
    lists all the tasks specified in the `gulpfile.js`, and also allows us to bind
    those tasks to build events.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gulp用于运行任务，Visual Studio提供了一个任务运行窗口，列出了`gulpfile.js`中指定的所有任务，还允许我们将这些任务绑定到构建事件。
- en: 'Let''s add the following script in `gulpfile.js`:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gulpfile.js`中添加以下脚本：
- en: '[PRE89]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the preceding `gulpfile.js`, we have first declared the objects of Gulp.
    Then the paths variable defines the root folder (`./wwwroot`) for static files.
    In ASP.NET Core, all the static files should reside under the `wwwroot` folder;
    otherwise, they cannot be accessed. Now we need to copy the Angular and other
    related JavaScript files into the `wwwroot` folder. Therefore, we have added the
    task `build.lib` that calls `gulp.src()` and chains the `gulp.dest()` method to
    copy the files from the `node_modules/*` folder to the `wwwroot/lib` folder. Here
    is the screenshot of the `wwwroot` folder, which creates the `lib` folder when
    you run the preceding steps:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`gulpfile.js`中，我们首先声明了Gulp的对象。然后路径变量定义了静态文件的根目录（`./wwwroot`）。在ASP.NET Core中，所有静态文件都应该存放在`wwwroot`文件夹下；否则，它们无法被访问。现在我们需要将Angular和其他相关JavaScript文件复制到`wwwroot`文件夹。因此，我们添加了任务`build.lib`，调用`gulp.src()`，并链接了`gulp.dest()`方法，以从`node_modules/*`文件夹复制文件到`wwwroot/lib`文件夹。以下是`wwwroot`文件夹的截图，当你运行前面的步骤时，它创建了`lib`文件夹：
- en: '![Configuring Gulp](img/00044.jpeg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![配置 Gulp](img/00044.jpeg)'
- en: Tip
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Tasks can run through the task runner window in Visual Studio.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以通过Visual Studio中的任务运行窗口运行。
- en: Adding Angular components
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 Angular 组件
- en: 'We have installed the Angular packages and configured Gulp to copy the packaged
    JavaScript files to the `wwwroot` folder. Now we will add Angular components to
    define our main application selector and render the ASP.NET page inside it:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了Angular包并配置了Gulp以将打包的JavaScript文件复制到`wwwroot`文件夹。现在我们将向Angular组件中添加内容，以定义我们的主要应用选择器并在其中渲染ASP.NET页面：
- en: In the `Scripts` folder, create two folders, `app` and `services`. The `app`
    folder holds the components that we will use in the view, whereas the `services`
    folder holds the services that will be used to call the Web API methods.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中，创建两个文件夹，`app`和`services`。`app`文件夹包含我们将用在视图中的组件，而`services`文件夹包含用来调用Web
    API方法的服务。
- en: 'Add a main TypeScript file, which will bootstrap the main `TodoAppComponent`.
    Here is the code of `main.ts`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个主TypeScript文件，它将引导主要的`TodoAppComponent`。以下是`main.ts`的代码：
- en: '[PRE90]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Add a new TypeScript file and name it `todoapp.component.ts`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的TypeScript文件，并将其命名为`todoapp.component.ts`。
- en: 'Add the following code snippet for `TodoAppComponent`. In order to first test
    whether everything is configured properly, we will simply add a sample heading
    tag that shows `Hello World`:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TodoAppComponent`中添加以下代码片段。为了首先测试一切是否配置正确，我们将仅仅添加一个显示`Hello World`的示例标题标签：
- en: '[PRE92]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now we will add two files, `importer.js` and `angular_config.js`. `importer.js`
    calls `System.import` and points to the main file that bootstraps the application
    component. `angular_config.js` holds the configuration property to allow default
    JavaScript extensions to be set to `true`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加两个文件，`importer.js`和`angular_config.js`。`importer.js`调用`System.import`并指向引导应用程序组件的主文件。`angular_config.js`持有允许默认JavaScript扩展设置为`true`的配置属性。
- en: '[PRE93]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Here is the code for `angular_config.js`:'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是`angular_config.js`的代码：
- en: '[PRE95]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now we need to add the MVC layout page and add all the scripts. Add the following
    scripts:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加MVC布局页面并添加所有脚本。添加以下脚本：
- en: '[PRE96]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now let's add `HomeController` and view `Index.cshtml`.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来添加`HomeController`和视图`Index.cshtml`。
- en: 'In `Index.cshtml`, add the to-do selector `todo-app`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Index.cshtml`中，添加待办事项选择器`todo-app`：
- en: '[PRE97]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Build and run the application and it will show **Hello World**:![Adding Angular
    components](img/00045.jpeg)
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，它将显示**Hello World**：![添加Angular组件](img/00045.jpeg)
- en: Adding the to-do service component
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加待办事项服务组件
- en: 'We will now add the components inside the `services` folder that will be responsible
    for getting data by calling the `Todo` service:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加`services`文件夹内的组件，这些组件将负责通过调用`Todo`服务获取数据：
- en: 'First of all, add the `BaseService` component, which contains `baseURL`. All
    the service components will derive from `BaseService` so they can use the base
    URL property for making Ajax requests. Add a new TypeScript file and name it `baseservice.component.ts`.
    Here is the code snippet for `baseservice.component.ts`:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加`BaseService`组件，其中包含`baseURL`。所有服务组件都将从`BaseService`派生，以便它们可以使用基本URL属性进行Ajax请求。添加一个新的TypeScript文件，命名为`baseservice.component.ts`。以下是`baseservice.component.ts`的代码片段：
- en: '[PRE98]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now add `todoservice.component.ts`, which contains the methods to get all to-do
    items, add a new to-do item, and delete an existing to-do item. Here is the code
    snippet for `TodoService`:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加`todoservice.component.ts`，其中包含获取所有待办事项、添加新待办事项和删除现有待办事项的方法。以下是`TodoService`的代码片段：
- en: '[PRE99]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In `TodoAppComponent`, we have first added the `CreateTodoComponent` directive
    we will be using in the `Todo/Index.cshtml` page in a later step. We have implemented
    the `ngOnInit()` event handler that gets the list of to-dos and bound it to the
    `todos` array object. The `getTodoItems()` method calls the `TodoService` to get
    the list of to-do items, whereas `deleteTodoItem()` is used to delete the item.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`TodoAppComponent`中，我们首先添加了`CreateTodoComponent`指令，我们稍后在`Todo/Index.cshtml`页面中使用。我们实现了`ngOnInit()`事件处理程序，获取待办事项列表并将其绑定到`todos`数组对象。`getTodoItems()`方法调用`TodoService`获取待办事项列表，而`deleteTodoItem()`用于删除项目。
- en: Every request in Angular returns an `Observable` response object that provides
    a `map` method to tell Angular to parse the response in a specific format. The
    map also returns the `Observable` object, which can be used to subscribe to the
    data once it is parsed into the JSON format, as in our case. Finally, we have
    called the `subscribe` method and sent the JSON response data to the `todos` array.
    To handle errors, we can chain the call with the `err` method. The anonymous `expression()`
    method is invoked in every call, irrespective of the response status. That means
    whether the result is a success or an error, the code defined under the anonymous
    `expression()` method will be executed.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Angular中的每个请求都返回一个提供`map`方法的`Observable`响应对象，告诉Angular以特定格式解析响应。映射还返回`Observable`对象，可以用来在解析为JSON格式后订阅数据，正如我们的情况一样。最后，我们调用了`subscribe`方法，并将JSON响应数据发送到`todos`数组。为了处理错误，我们可以将调用与`err`方法链起来。无论响应状态是成功还是错误，都会调用匿名`expression()`方法。这意味着无论结果是成功还是错误，定义在匿名`expression()`方法下的代码都将执行。
- en: For creating new to-dos, we will create another `CreateTodoComponent` later,
    which will call the `handleRefresh()` method through the `Outputs` event to refresh
    the list and reflect the newly added item on the main page.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了创建新的待办事项，我们稍后会创建另一个`CreateTodoComponent`，它将通过`Outputs`事件调用`handleRefresh()`方法来刷新列表，并在主页上反映新添加的项目。
- en: Creating the main to-do page
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建主要待办事项页面
- en: We have created the Angular components that we will use in the MVC view. We
    have already bootstrapped the Angular components in the previous section and placed
    the `<todo-app>` tag in the `Home/Index.cshtml` page, which is the landing page
    of our application. Next, we will create a custom tag helper, then add a `TodoController`,
    and use this tag helper in the index page.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了将在 MVC 视图中使用的 Angular 组件。我们在上一节中已经引导了 Angular 组件，并在 `Home/Index.cshtml`
    页面（我们应用程序的登录页面）中放置了 `<todo-app>` 标签。接下来，我们将创建一个自定义标签帮助器，然后添加一个 `TodoController`，并在索引页中使用这个标签帮助器。
- en: Creating a custom to-do tag helper
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个自定义待办事项标签帮助器
- en: 'On the main page, we will list all the to-do items for a particular user. For
    this, we will create a custom tag helper in ASP.NET:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在主页上，我们将列出特定用户的全部待办事项。为此，我们将在 ASP.NET 中创建一个自定义标签帮助器：
- en: '![Creating a custom to-do tag helper](img/00046.jpeg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个自定义待办事项标签帮助器](img/00046.jpeg)'
- en: 'Perform the following steps to create this tag helper:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来创建此标签帮助器：
- en: 'Create a new controls folder in the root of the `TodoWebApp` project and add
    a `TodoTagHelper` class. Here is the code for `TodoTagHelper`, which uses Angular
    2 `ngControl` to bind values from Angular `TodoAppComponent` to the form:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TodoWebApp` 项目的根目录下创建一个新的 controls 文件夹，并添加一个 `TodoTagHelper` 类。以下是 `TodoTagHelper`
    的代码，它使用 Angular 2 `ngControl` 将 Angular `TodoAppComponent` 的值绑定到表单：
- en: '[PRE102]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Add the tag helper in `_ViewImports.cshtml`:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_ViewImports.cshtml` 中添加标签帮助器：
- en: '[PRE103]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Adding a to-do MVC controller
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个待办事项 MVC 控制器
- en: 'Add `TodoController` in the `TodoWebApp` project and specify two methods for
    the index view, which is the main view that displays all the items and creates
    a new to-do item:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TodoWebApp` 项目中添加 `TodoController` 并指定两个方法用于索引视图，这是显示所有项目的主要视图以及创建新的待办事项项：
- en: '[PRE104]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Generating views for the TodoController action methods
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为 TodoController 操作方法生成视图
- en: '[PRE105]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In the preceding HTML markup, we have first defined a button that opens up a
    modal dialog, `todoModal`. In the `todoModal` dialog markup, we have used the
    `createTodo` directive, which is defined in the `todoapp.component.ts` file associated
    with this page, and the link actually points to the `Todo/Create MVC` view, which
    will be rendered at the place of router-outlet. With the combination of the router
    link and the router outlet, we can render the template. In `todoapp.component.ts`,
    we will see how we can use routing in Angular. Finally, we have used the custom
    tag helper `<todo>` to display each item available in the to-do list.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 HTML 标记中，我们首先定义了一个按钮，该按钮会打开一个模态对话框 `todoModal`。在 `todoModal` 对话框的标记中，我们使用了
    `createTodo` 指令，该指令定义在与此页面关联的 `todoapp.component.ts` 文件中，并且该链接实际上指向了 `Todo/Create
    MVC` 视图，该视图将在路由出口处渲染。通过路由链接和路由出口的组合，我们可以渲染模板。在 `todoapp.component.ts` 中，我们将看到如何在
    Angular 中使用路由。最后，我们使用了自定义标签帮助器 `<todo>` 来显示待办事项列表中的每个项目。
- en: Developing the Create Todo component
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开发待办事项创建组件
- en: In this section, we will add the Angular component and name it `CreateTodoComponent`.
    This is needed because we will be opening a new MVC view in a modal dialog through
    a custom `createTodo` selector, and `CreateTodoComponent` has a method to save
    a new to-do in the database, as shown in the following code.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加 Angular 组件，并将其命名为 `CreateTodoComponent`。这是因为我们将通过自定义 `createTodo`
    选择器在一个模态对话框中打开一个新的 MVC 视图，并且 `CreateTodoComponent` 有一个保存数据库中新待办事项的方法，如下面的代码所示。
- en: 'Add a new `createtodo.component.ts` under the `Scripts>apps` folder, and then
    add the following code snippet:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Scripts>apps` 文件夹下添加一个新的 `createtodo.component.ts`，然后添加以下代码片段：
- en: '[PRE107]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`FormBuilder` and `Validator` are used to define properties with specific validators
    that can be bound to the HTML form using the `ngControl` directive. Lastly, we
    have the `addTodoItem` method, which will be invoked on form submission and make
    a to-do entry in the database by calling `TodoService`.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder` 和 `Validator` 用于定义具有特定验证器的属性，这些属性可以通过 `ngControl` 指令绑定到 HTML
    表单。最后，我们有一个 `addTodoItem` 方法，它将在表单提交时被调用，通过调用 `TodoService` 在数据库中添加一个待办事项。'
- en: 'Now let''s add the following code in `Create.cshtml`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在 `Create.cshtml` 中添加以下代码：
- en: '[PRE109]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the core components of TypeScript and writing
    programs using TypeScript. We also learned the core fundamentals and concepts
    of the Angular 2 framework and developed a simple to-do application using ASP.NET
    Core, Angular 2, MVC 6 for Web API, and Entity Framework Core for data access
    providers. In the next chapter, we will learn about **Windows JavaScript Library**
    (**WinJS**), developed by Microsoft, and see how we can access Windows runtime
    features, change the appearance of HTML controls, and other options available
    in this library.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了TypeScript的核心组件以及如何使用TypeScript编写程序。我们还了解了Angular 2框架的核心基础和概念，并使用ASP.NET
    Core、Angular 2、MVC 6（用于Web API）和Entity Framework Core（用于数据访问提供者）开发了一个简单的待办事项应用程序。在下一章中，我们将学习由微软开发的**Windows
    JavaScript Library**（**WinJS**），并了解我们如何可以访问Windows运行时特性，更改HTML控件的外观，以及这个库中可用的其他选项。
