- en: Chapter 1. Instant Testing with QUnit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 使用QUnit即时测试
- en: Welcome to Instant testing with QUnit!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用QUnit即时测试！
- en: For a long time, JavaScript wasn't taken seriously. However, with the advent
    of AJAX, it turned out that using JavaScript web pages can be brought to speed
    with the desktop software RIA Rich Internet application ([http://en.wikipedia.org/wiki/Rich_Internet_application](http://en.wikipedia.org/wiki/Rich_Internet_application)).
    The forthcoming server-side JavaScript proved that application can be written
    entirely in JavaScript. JavaScript-based applications started growing up and getting
    complex. Even if good developers work on them, any sophisticated software will
    still have defects. Test engineers do their best to catch these before the product
    is released, but it is hardly possible to detect all the flaws manually. Automated
    testing is the best way to increase the efficiency and coverage of software testing.
    Besides, it reveals any problem present in the early development stages, which
    cuts down the cost of fixing it drastically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间，JavaScript并没有被认真对待。然而，随着AJAX的出现，事实证明使用JavaScript可以使网页的速度达到桌面软件RIA富互联网应用程序（[http://en.wikipedia.org/wiki/Rich_Internet_application](http://en.wikipedia.org/wiki/Rich_Internet_application)）的水平。即将到来的服务器端JavaScript证明应用程序可以完全用JavaScript编写。基于JavaScript的应用程序开始成长并变得复杂。即使优秀的开发者从事它们，任何复杂的软件仍然会有缺陷。测试工程师尽最大努力在产品发布前捕捉到这些问题，但手动检测所有缺陷几乎是不可能的。自动化测试是提高软件测试效率和覆盖面的最佳方法。此外，它在早期开发阶段揭示任何问题，大大降低了修复成本。
- en: Regardless of the technologies used, the best development practices include
    automation of unit tests, integration tests, system tests, and functional tests.
    Unit tests verify if the smallest functional parts of the application work as
    intended in isolation. Integration tests check if the components of the project
    collaborate properly. System tests examine the whole application—usually for criteria
    such as usability, performance/load/stress, scalability, compatibility, and security—and
    functional tests validate that the application UI is fine from the user's perspective.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种技术，最佳的开发实践包括单元测试、集成测试、系统测试和功能测试的自动化。单元测试验证应用程序的最小功能部分是否如预期那样在孤立状态下工作。集成测试检查项目组件是否正确协作。系统测试检查整个应用程序—通常用于用户体验、性能/负载/压力、可伸缩性、兼容性和安全性等标准—而功能测试验证从用户的角度看应用程序UI是否正常。
- en: Currently, there are plenty of tools meant to achieve automated testing in JavaScript.
    One of the most popular testing frameworks is QUnit. It's sufficiently powerful,
    extremely flexible and, at the same time, surprisingly easy to start with.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有许多工具旨在实现JavaScript的自动化测试。最受欢迎的测试框架之一是QUnit。它足够强大，极其灵活，同时令人惊讶地容易上手。
- en: This is a practical book showing how to achieve a beneficial automated testing
    of your JavaScript applications with QUnit and its plugins, how to engage QUnit
    for automated cross-browser testing, and how to utilize QUnit in conjunction with
    developer automation and continuous integration tools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本实用的书，展示了如何使用QUnit及其插件对你的JavaScript应用程序进行有益的自动化测试，如何使用QUnit进行自动化的跨浏览器测试，以及如何将QUnit与开发自动化和持续集成工具结合使用。
- en: The book provides framework-agnostic Vanilla JS examples on all the contributed
    tasks that one can find easy to follow. The source code is categorized by the
    tasks and available for download at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    Thus, whatever your previous experience or whatever libraries you work with, you
    can master the tasks in no time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书为所有贡献的任务提供了框架不可知的Vanilla JS示例，这些任务之一可以很容易地跟随。源代码按任务分类，并可在[http://www.packtpub.com/support](http://www.packtpub.com/support)下载。因此，无论你以前的经验如何，无论你使用哪些库，你都可以很快掌握这些任务。
- en: Setting up QUnit (Simple)
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置QUnit（简单）
- en: In this recipe, we will download the QUnit testing framework components and
    create a test runner HTML. We will examine how the QUnit test runner reports on
    cases of both succeeded and failed tests. We will also consider some of the best
    practices of the framework fi le structure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将下载QUnit测试框架组件并创建一个测试运行器HTML。我们将研究QUnit测试运行器如何报告成功和失败的测试案例。我们还将考虑框架文件结构的一些最佳实践。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The framework consists of the QUnit JavaScript module, the test runner HTML,
    and the style sheet. Test runner is a test suite executer. It loads other QUnit
    components and generates the report page. We include our tests either directly
    in the test runner HTML or in an external file. The component model is illustrated
    as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架包括QUnit JavaScript模块、测试运行器HTML和样式表。测试运行器是一个测试套件执行器。它加载其他QUnit组件并生成报告页面。我们可以直接在测试运行器HTML中包含我们的测试，或者在一个外部文件中包含。组件模型如下所示：
- en: '![Getting ready](img/2173_01_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/2173_01_01.jpg)'
- en: 'We can simply copy-paste the test runner code from [www.qunitjs.com](http://www.qunitjs.com)
    as well as download the CSS and JavaScript components. In fact, it can work without
    downloading by using the following links to jQuery CDN in the test runner:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以简单地从[www.qunitjs.com](http://www.qunitjs.com)复制粘贴测试运行器代码，以及下载CSS和JavaScript组件。实际上，如果不下载，可以使用以下链接在测试运行器中使用jQuery
    CDN：
- en: '[http://code.jquery.com/qunit/qunit-git.css](http://code.jquery.com/qunit/qunit-git.css)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://code.jquery.com/qunit/qunit-git.css](http://code.jquery.com/qunit/qunit-git.css)'
- en: '[http://code.jquery.com/qunit/qunit-git.js](http://code.jquery.com/qunit/qunit-git.js)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://code.jquery.com/qunit/qunit-git.js](http://code.jquery.com/qunit/qunit-git.js)'
- en: How to do it
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: Well, how does it work?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它是如何工作的？
- en: 'Create an `index.html` file with the following content:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`index.html`文件，内容如下：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Load HTML in your browser. You will see something similar to the following screenshot![How
    to do it](img/2173_01_02.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中加载HTML。你会看到类似于以下屏幕截图的东西！[如何操作](img/2173_01_02.jpg)
- en: 'So, what is on the page? First the title that we assigned in the HTML. Underneath
    follows a bar that is in calming green if all the tests succeeded and alerting
    red if any failed. In case the tests fail, we will see something similar to the
    following screenshot:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么页面上有什么呢？首先是我们在HTML中分配的标题。下面是一个条，如果所有测试成功，它会是宁静的绿色；如果有任何失败，它会变成警告的红色。如果测试失败，我们将看到类似于以下屏幕截图的东西：
- en: '![How to do it](img/2173_01_03.jpg)'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/2173_01_03.jpg)'
- en: 'Further, we can see a toolbox. It contains the following options:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们可以看到一个工具箱。它包含了以下选项：
- en: The **Hide passed tests** checkbox, useful when you have plenty of tests running
    and want to focus only on those that failed.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐藏已通过的测试**复选框，当你运行大量测试并只想关注那些失败的时候非常有用。'
- en: The **Check for Globals** checkbox, which allows you to test if the global object
    was modified during testing.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查全局变量**复选框，它允许你在测试期间测试全局对象是否被修改。'
- en: The **No try-catch** checkbox, which triggers the running of the tests outside
    the try-catch block revealing native exceptions. This handy while debugging on
    legacy browsers.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不使用try-catch**复选框，它触发测试在try-catch块外运行，显示本地的异常。这在调试旧版浏览器时非常有用。'
- en: Right below the toolbox, QUnit displays the user agent details. After that,
    we have a report area with the overall statistics and a list of per test results.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在工具箱的正下方，QUnit显示了用户代理的详细信息。之后，我们有一个报告区域，展示了总体统计信息和每个测试的结果列表。
- en: How it works
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'You may like to know what really happens behind the scenes. While the QUnit
    JavaScript module is being processed, it subscribes a handler on the `window.onload`
    event. The handler initializes the `QUnit` object and populates the placeholders
    of the test runner layout with the elements required to build the report page.
    Towards the end, it calls the `QUnit.start` method, which actually runs tests
    available at that time. Thus, by default, QUnit tries to run tests as soon as
    the page DOM is ready. If you work with modular JavaScript such as AMD and CommonJS,
    all the modules, including tests, are loaded asynchronously. The case requires
    the test runner to be manually started, which can be performed by using a configuration
    option as described in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道幕后到底发生了什么。当QUnit JavaScript模块正在被处理时，它会在`window.onload`事件上订阅一个处理程序。该处理程序初始化`QUnit`对象，并将测试运行器布局的占位符用构建报告页所需的元素填充。最后，它调用`QUnit.start`方法，该方法实际上运行了当时可用的测试。因此，默认情况下，QUnit尝试在页面DOM就绪时运行测试。如果你使用模块化的JavaScript，如AMD和CommonJS，所有的模块（包括测试）都是异步加载的。这种情况下需要手动启动测试运行器，可以通过使用以下代码中描述的配置选项来完成：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's more
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: In the previous example, we placed the dummy test code straight into the test
    runner HTML. fine for a short example, but doesn't suit a real project with a
    lot of tests. You will have to come up with a decent file structure. I would recommend
    creating a dedicated subdirectory (tests) in your project's `wwwroot`. There you
    can add subdirectories per project module under test. These subdirectories contain
    the code for module tests and test-related files, if required.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们把伪测试代码直接放入测试运行器的HTML中。对于一个简短的例子来说，这是可以的，但对于一个有很多测试的真实项目来说，就不合适了。你必须想出一个合适的文件结构。我建议在你的项目`wwwroot`中创建一个专门的子目录（tests）。在那里，你可以为每个被测试的项目模块添加子目录。这些子目录包含模块测试的代码和必要的测试相关文件。
- en: Usually, test runner is simply named `index.html` as it aggregates all the QUnit
    tests of the project. I would encapsulate different kinds of tests into respective
    runners such as `unit-tests.html`, `functional-tests.html`, and `acceptance-tests.html`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试运行器简单地命名为`index.html`，因为它聚合了项目的所有QUnit测试。我会把不同类型的测试封装到各自的运行器中，如`unit-tests.html`、`functional-tests.html`和`acceptance-tests.html`。
- en: Thus, we can run fast unit tests with every commit (for example, by a Continuous
    Integration server) and run functional and acceptance tests before any deployment.
    It also improves test readability when you keep functional tests out of acceptance
    tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以每次提交代码时都快速运行单元测试（例如，通过持续集成服务器），并在任何部署之前运行功能和验收测试。当你把功能测试和验收测试分开时，也能提高测试的可读性。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Testing assertions (Simple)
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试断言（简单）
- en: Assertion is the main method used in testing. In this recipe, we will examine
    all the assertion methods that QUnit has. Besides, we will take a look at a few
    assertion methods provided by popular QUnit plugins.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是测试中使用的主要方法。在本食谱中，我们将查看QUnit拥有的所有断言方法。此外，我们还将查看一些由流行的QUnit插件提供的断言方法。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'It would be much more useful if while learning assertions, we test the real
    code. The following two helper functions are quite suitable to show discrete cases
    of the use of assertions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在学习断言的同时测试真实代码，那将更有用。以下两个辅助函数非常适合显示断言使用的离散案例：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first one is an analog of the PHP `trim` function. It removes any white
    spaces from the beginning and end of a supplied string. The second function implements
    class-based inheritance. So, you can create, for this function, a new class (`constructor`)
    by extending a given one (`SuperType`) with a specified object (`subType`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是PHP `trim`函数的模拟。它从所提供字符串的开始和结束移除任何空白字符。第二个函数实现基于类的继承。因此，你可以为这个函数创建一个新的类（`constructor`），通过扩展给定的类（`SuperType`）和一个特定的对象（`subType`）。
- en: How to do it
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Define the test scope with the required assertions as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下定义带有所需断言的测试范围：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the scope of the test is defined comprises one or more assertions. QUnit
    provides assertion methods such as `equal`, `notEqual`, `strictEqual`, `notStrictEqual`,
    `ok`, `deepEqual`, and `notDeepEqual`.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，测试的范围定义了一个或多个断言。QUnit提供了如`equal`、`notEqual`、`strictEqual`、`notStrictEqual`、`ok`、`deepEqual`和`notDeepEqual`的断言方法。
- en: Note
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may find plenty of examples made with the simplified interface on the Internet.
    QUnit methods are of course namespaced, but they are also exposed as shortcut
    functions on the global object. So, you can put the code in the following way:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会在互联网上找到大量使用简化接口的示例。QUnit方法当然是有命名空间的，但它们也作为全局对象的快捷方式函数暴露出来。所以，你可以按照以下方式放置代码：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, I would rather recommend against it. As you see, it's hardly short
    of code, but it may interfere with the global properties added by other scripts
    and you won't be able to access plugin assertions this way.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我建议不要这样做。正如你所见，它几乎不缺少代码，但它可能会干扰其他脚本添加的全局属性，并且你无法这种方式访问插件断言。
- en: Test `utils.trim` with equality assertions. If we pass a string as an argument
    to the `utils.trim` function from the preceding example, we expect this string
    with all leading and trailing whitespaces removed in the output. If the whitespaces
    still exist, the function doesn't work as intended. This can be tested by applying
    the common pattern as follows
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用等式断言测试`utils.trim`。如果我们给前一个示例中的`utils.trim`函数传递一个字符串作为参数，我们期望输出的字符串去掉所有的前导和尾随空白。如果空白还存在，那么这个函数就没有按预期工作。这可以通过应用以下常见的模式来测试
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Test `utils.trim` with strict equality assertions. Surely, we can''t test properly
    this function with only one or two assertions, but nevertheless the case shows
    you can use the `equal` and `notEqual` methods. The methods `strictEqual` and
    `notStrictEqual` act in the same way as the last two except that they check for
    equality more strictly (let''s say in a proper way). That''s all about the difference
    between `==` and `===` JavaScript comparison operators. The first one is known
    as bad part JavaScript (See *JavaScript: The Good Parts, Douglas Crockford, O''Reilly
    Media*) and should be avoided unless one really means /fals comparison. Thus,
    we rather rewrite the `utils.trim` test the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用严格相等断言测试`utils.trim`。当然，只用一两个断言是无法正确测试这个函数的，但无论如何这个例子展示了你可以使用`equal`和`notEqual`方法。`strictEqual`和`notStrictEqual`的方法与最后两个方法相同，只是它们检查相等性更加严格（比如说正确的方式）。这就是`==`和`===`JavaScript比较运算符之间的区别。第一个被称为糟糕的JavaScript部分（参见*JavaScript:
    The Good Parts, Douglas Crockford, O''Reilly Media*）并且应该避免，除非你真的意味着/fals比较。因此，我们最好重写`utils.trim`测试，如下面的代码：'
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Examine the risks of using weak equality assertions:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查使用弱相等断言的风险：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Test `utils.extendClass` with boolean assertions. First, we have to write a
    client code for the method. We define a pseudo class (constructor with some members
    added to the prototype) and pass it to `utils.extendClass`. We need to test it
    if the derived pseudo class makes an instance of what we extended. We cannot use
    equality assertion methods here, but QUnit provides the `ok` assertion method,
    which verifies if a supplied expression is true, and can likely be used.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用布尔断言测试`utils.extendClass`。首先，我们必须为该方法编写客户端代码。我们定义一个伪类（构造函数加上一些添加到原型上的成员）并将其传递给`utils.extendClass`。我们需要测试派生的伪类是否能够实例化我们扩展的内容。在这里我们不能使用相等性断言方法，但QUnit提供了`ok`断言方法，该方法验证提供的表达式是否为真，很可能被使用。
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Test the two identical objects with deep equality assertions. At this point,
    we have tried the entire core QUnit assertion methods. However, QUnit API also
    includes helper methods `deepEqual` and `notDeepEqual` that allow you to assert
    on the equality of complex types such as arrays, objects, regular expressions,
    dates, and functions. This is useful when you need to compare two identical objects.
    Equality methods (`equal`/`strictEqual`) will never confirm the identical objects
    unless these are not references to the same object. On the contrary, `deepEqual`
    recursively compares members of both the supplied types. The following code is
    an example of the assertion that two arrays are identical:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用深度相等断言测试两个相同的对象。至此，我们已经尝试了QUnit核心断言方法的全部。然而，QUnit API还包括辅助方法`deepEqual`和`notDeepEqual`，允许你对数组、对象、正则表达式、日期和函数等复杂类型的相等性进行断言。当你需要比较两个相同的对象时，这很有用。相等性方法（`equal`/`strictEqual`）除非引用相同的对象，否则永远不会确认相同的对象。相反，`deepEqual`递归比较两个提供的类型的成员。以下是比较两个数组是否相同的断言示例：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There's more
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: Besides QUnit core assertion methods, you can also use the methods provided
    by numerous QUnit plugins. We will examine the most popular ones here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了QUnit核心断言方法外，您还可以使用由众多QUnit插件提供的断言方法。在这里我们将查看最受欢迎的一些。
- en: Most xUnit frameworks have facilities for so-called **Parameterized Unit Tests**
    (**PUTs**). These tests are provided with a set of any number of test input values.
    During test exercising, these values are passed repeatedly as parameters to the
    test. Thus, the unit is tested with all the necessary input cases. The **Parameterize**
    plugin ([https://github.com/AStepaniuk/qunit-parameterize](https://github.com/AStepaniuk/qunit-parameterize))
    brings these facilities to QUnit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数xUnit测试框架都有所谓**参数化单元测试**（**PUTs**）的功能。这些测试提供了一组任意数量的测试输入值。在测试执行过程中，这些值会反复作为参数传递给测试。因此，单元会使用所有必要的输入案例进行测试。**Parameterize**插件（[https://github.com/AStepaniuk/qunit-parameterize](https://github.com/AStepaniuk/qunit-parameterize)）为QUnit带来了这些功能。
- en: 'Do you remember we were testing the `utils.trim` function? To make sure the
    string is trimmed correctly, in many cases we would need to write a lot of assertions
    repeating almost the same code all over the test scope. It can be simplified notably
    by using the Parameterize plugin. See the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们测试过`utils.trim`函数吗？为了确保字符串被正确地截断，在许多情况下我们需要写很多几乎相同的代码重复出现在测试范围内。这可以通过使用Parameterize插件显著简化。以下是一个示例：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you need to assert that two float numbers are equal to some degree, it would
    be not so easy to achieve this in JavaScript. That is another "bad" part of the
    language. Consider the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要断言两个浮点数在某种程度上是相等的，在 JavaScript 中实现这一点并不容易。这是语言的另一个“缺点”。考虑以下代码片段：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the other hand, the **Close** plugin ([https://github.com/JamesMGreene/qunit-assert-close](https://github.com/JamesMGreene/qunit-assert-close))
    provides a much more convenient way to do this as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**Close** 插件（[https://github.com/JamesMGreene/qunit-assert-close](https://github.com/JamesMGreene/qunit-assert-close)）提供了更方便的方式来做到这一点，如下代码所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here `actual` and `expected` are the float numbers we compare, `maxDifference`
    / `minDifference` are the degree to which we compare them, and `message` is an
    optional description of the assertion. So, the test may look like the following
    code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `actual` 和 `expected` 是我们比较的浮点数，`maxDifference` / `minDifference` 是我们比较它们的程度，`message`
    是一个可选项的断言描述。所以，测试可能看起来像以下代码：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sometimes, we have to make sure that functions are being invoked in a defined
    order for example, the AMD-compatible module loader works asynchronously but must
    resolve dependencies when they are sequenced. The **Step** plugin ([https://github.com/JamesMGreene/qunit-assert-step](https://github.com/JamesMGreene/qunit-assert-step))
    allows us to assert the proper sequence in which the code should perform. The
    following example verifies that the `bar` function is called prior to the `foo`
    function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们必须确保函数以定义好的顺序被调用，例如，兼容 AMD 的模块加载器异步工作，但在它们按顺序排列时必须解析依赖关系。**Step** 插件（[https://github.com/JamesMGreene/qunit-assert-step](https://github.com/JamesMGreene/qunit-assert-step)）允许我们断言代码应执行的正确顺序。以下示例验证
    `bar` 函数在 `foo` 函数之前被调用：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Nowadays, the canvas element is widely used to render diagrams, simple animation,
    and browser-based games. Obviously, it means a lot of code testing. However, any
    assertion on a canvas region doesn't seem an easy task. The **Canvas** plugin
    ([https://github.com/JamesMGreene/qunit-assert-canvas](https://github.com/JamesMGreene/qunit-assert-canvas))
    provides the assertion method to test individual pixel values in a canvas. In
    the following example, we define a canvas area on the page and draw a black rectangle.
    Then, we assert a dot on the rectangle that has black color.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，canvas 元素广泛用于渲染图表、简单的动画和基于浏览器的游戏。显然，这意味着大量的代码测试。然而，对 canvas 区域进行断言似乎并不是一件容易的任务。**Canvas**
    插件（[https://github.com/JamesMGreene/qunit-assert-canvas](https://github.com/JamesMGreene/qunit-assert-canvas)）提供了断言方法来测试
    canvas 中的单个像素值。在以下示例中，我们在页面定义一个 canvas 区域并绘制一个黑色矩形。然后，我们断言矩形上有黑色点的颜色。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'HTML5 tolerates HTML-like looseness such as non-closed elements and non-escaped
    attribute values. This makes it difficult to compare two different HTML strings
    that are treated equally by a browser. The HTML plugin ([https://github.com/JamesMGreene/qunit-assert-html](https://github.com/JamesMGreene/qunit-assert-html))
    solves the issue in the following way:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 容忍类似于 HTML 的宽松特性，比如未闭合的元素和非转义的属性值。这使得在浏览器中平等处理的两个不同的 HTML 字符串之间的比较变得困难。HTML
    插件（[https://github.com/JamesMGreene/qunit-assert-html](https://github.com/JamesMGreene/qunit-assert-html)）以下这种方式解决了问题：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Writing a custom assertion plugin (Advanced)
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义断言插件（高级）
- en: This recipe will guide you on the basis of creating QUnit plugins. We will create
    a custom assertion method and add it to the common QUnit assertion service.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将引导你基于创建 QUnit 插件。我们将创建一个自定义断言方法并添加到公共 QUnit 断言服务中。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: QUnit is easy to start with as it provides only a few necessary assertion methods.
    Nevertheless, you can have as many methods as you wish by using QUnit plugins.
    Plenty of plugins are already available on the Internet. Besides, you may need
    your own custom plugin. Luckily, QUnit has a Callback API, which makes it easy.
    You can simply register your own handler on the entry and exit points of every
    testing scope (test suite, module, and test) or subscribe a handler function to
    the event that happens every time assertion performed in a test; for instance,
    PhantomJS ([www.phantomjs.org](http://www.phantomjs.org)) is widely used to run
    QUnit tests in the console. However, the QUnit output test results as an HTML
    report in DOM, which doesn't work with the command line. The PhantomJS runner
    JavaScript (NodeJS) utility solves this issue by translating the QUnit output
    into a format compatible with the command-line interface. It registers a callback
    with the `QUnit.log` method to collect and store results on every assertion. It
    also subscribes a handler on the test suite complete event with `QUnit.done`,
    which outputs the accumulated results in the required way.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: QUnit 入门很容易，因为它只提供了几个必要的断言方法。然而，你可以通过使用 QUnit 插件拥有尽可能多的方法。互联网上已经有很多可用的插件。此外，你可能需要自己的自定义插件。幸运的是，QUnit
    有一个回调 API，这使得操作变得简单。你只需在每一个测试作用域（测试套件、模块和测试）的入口和出口点上注册自己的处理程序，或在每次在测试中执行断言时订阅一个处理函数；例如，PhantomJS（[www.phantomjs.org](http://www.phantomjs.org)）常被用来在控制台运行
    QUnit 测试。然而，QUnit 将测试结果作为 HTML 报告输出在 DOM 中，这使得在命令行中无法使用。PhantomJS 运行器 JavaScript（NodeJS）工具通过将
    QUnit 输出转换为与命令行界面兼容的格式来解决此问题。它使用 `QUnit.log` 方法注册回调来收集和存储每次断言的结果。它还在 `QUnit.done`
    中订阅了一个处理程序，在测试套件完成事件上输出所需的方式积累结果。
- en: However, if you write just an assertion method, you may do without the callbacks
    API in most cases. You can simply add your method in the `QUnit.assert` object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你只编写一个断言方法，在大多数情况下你可以不用回调 API。你只需在 `QUnit.assert` 对象中添加你的方法。
- en: How to do it
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到
- en: Write an assertion method. Imagine that we need a convenient method for asserting
    that a supplied element is visible. The method is very simple—it only checks if
    the element is hidden via style properties visibility and display.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个断言方法。想象一下，我们需要一个方便的断言方法来断言一个提供的元素是可见的。这个方法非常简单——它只是检查元素是否通过样式属性的 visibility
    和 display 隐藏。
- en: '[PRE18]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Extend the `QUnit.assert` object with this new method. As `QUnit` already provides
    the `extend` helper, we don't need to use a third party library or write our own
    helper for extending an object to do it.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `QUnit.assert` 对象扩展这个新方法。由于 `QUnit` 已经提供了 `extend` 助手，所以我们不需要使用第三方库或编写自己的助手来扩展对象。
- en: '[PRE19]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Save this code in the `qunit-assert-is-visible.js` file.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码保存到 `qunit-assert-is-visible.js` 文件中。
- en: 'Provide the test runner HTML as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供如下测试运行器 HTML：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Load the test runner in a browser, and examine the results shown in the following
    screenshot:![How to do it](img/2173_03_01.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中加载测试运行器，并检查以下屏幕截图中显示的结果：![如何做到](img/2173_03_01.jpg)
- en: Testing exceptions (Medium)
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异常（中等）
- en: In this recipe, we will learn how to handle the function's exceptional behavior,
    how to define custom exceptions, and how to test exceptions are really thrown
    for invalid input and these are exceptions of the intended types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何处理函数的异常行为，如何定义自定义异常，以及如何测试异常确实为无效输入和这些是预期类型的异常被抛出。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: We've learnt already how to test whether or not a function performs the intended
    business logic. But what about its exceptional behavior? Let's say we supply invalid
    input parameters. We expect the function to warn us about them. The best practice
    would be to check the parameters have been passed onto the function entry point
    and thrown exceptions if any of the parameters are invalid. We need a way to test
    this logic as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何测试一个函数是否执行了预期的业务逻辑。但是，它的异常行为又如何呢？比如说我们提供了无效的输入参数。我们期望这个函数能警告我们。最佳实践应该是检查参数是否已经传递到函数的入口点，并在任何参数无效时抛出异常。我们也需要一种测试这种逻辑的方法。
- en: 'Do you remember the `utils.trim` function example? We have to modify it now
    for checking the validity of the input parameters:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得 `utils.trim` 函数示例吗？我们现在必须修改它，以检查输入参数的有效性：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Well, the function throws exception whenever it detects an invalid input but
    these are custom exceptions that must be defined. This can be done by declaring
    new error object constructors that inherit from standard JavaScript errors. Please
    find the implementation for this in the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个函数在检测到无效输入时会抛出异常，但这些是必须定义的自定义异常。这可以通过声明从标准JavaScript错误继承的新错误对象构造函数来实现。请在本例中找到此实现的代码：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到
- en: 'Define the test scope and the assert expected exception is thrown. In this
    case, QUnit provides the `throws` method, which can be described with the following
    code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义测试范围和预期抛出异常的断言。在这种情况下，QUnit提供了`throws`方法，可以用以下代码描述：
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Test whether `utils.trim` validates the input parameters and throws the intended
    exceptions:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`utils.trim`是否验证输入参数并抛出预期的异常：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Load the test runner in a browser and examine the results shown in the following
    screenshot:![How to do it](img/2173_04_01.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中加载测试运行器，并检查以下屏幕截图显示的结果：![如何做到](img/2173_04_01.jpg)
- en: Testing asynchronous calls (Medium)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异步调用（中等）
- en: In this recipe, we will see how QUnit deals with asynchronous callbacks. We
    will write an assertion test for an asynchronously called function. We will also
    go through an example of testing the XHR-associated function by mocking the transfer
    method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将了解QUnit如何处理异步回调。我们将为异步调用的函数编写一个断言测试。我们还将通过模拟传输方法来测试与XHR相关联的函数的示例。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: 'One of the greatest features of JavaScript is its ability to call functions
    asynchronously. You can easily make multiple functions that execute simultaneously
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最伟大的特性之一是其异步调用函数的能力。你可以很容易地使多个函数同时执行，如下所示：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you understand, these functions cannot be tested the way we did before. We
    cannot assert on the function straight after it is launched. Otherwise, we risk
    asserting on the call before it is completed. We will encounter the same problem
    while testing handlers subscribed to events and even while using JavaScript objects
    associated with events;—for instance, XHR.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所理解的，这些函数不能像我们以前那样进行测试。我们不能在函数启动后直接对其进行断言。否则，我们可能会在函数完成之前就对其进行断言。测试订阅事件的事件处理程序和甚至使用与事件相关联的JavaScript对象时，我们也会遇到同样的问题；例如，XHR。
- en: How to do it
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到
- en: Define the test scope. For testing asynchronously called functions, QUnit provides
    the `asyncTest` method, which in contrast to the test method receives an additional
    parameter with a number of expected assertions. Thus, QUnit will set the test
    as complete only when the supplied number of assertions is performed.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义测试范围。对于异步调用函数的测试，QUnit提供了`asyncTest`方法，与测试方法相比，它接收一个额外的参数，该参数包含预期的断言数量。因此，QUnit只有在执行了提供的断言数量后，才会将测试设置为完成。
- en: '[PRE26]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Assert within the asynchronous callback. Since we assert asynchronously, we
    have to call the `QUnit.start` method as soon as the last assertion is done. This
    will let QUnit know when it can jump to the next test.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在异步回调中进行断言。由于我们异步地进行断言，因此一旦完成最后一个断言，我们就必须调用`QUnit.start`方法。这将让QUnit知道它可以在下一个测试上跳转。
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Load the test runner in a browser, and examine the results shown in the following
    screenshot:![How to do it](img/2173_05_01.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中加载测试运行器，并检查以下屏幕截图显示的结果：![如何做到](img/2173_05_01.jpg)
- en: There's more
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'The described approach works fine with the test-friendly code. I mean the code
    where the asynchronous call accepts test callback injection or fires an event
    on which a handler is subscribed. When you are working with black-box code, you
    have no way to assert on asynchronous calls except mock the transfer utility whose
    interface you are familiar with; for example, while unit-testing a function that
    relies on XHR, we have to mock the helper performing the request. We do it anyway
    as it includes an across network communication and gets out of the unit scope.
    Let''s say the function under test uses the jQuery.get method. We know its interface
    and can override it with our own method, which does nothing but report to QUnit.
    You can see this in the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所描述的方法对于测试友好的代码来说很好用。我的意思是接受测试回调注入或在其上注册事件的异步调用代码。当你与黑盒代码工作时，除非你模拟你熟悉的传输实用程序的接口，否则你无法对异步调用进行断言；例如，在单元测试依赖于XHR的函数时，我们必须模拟执行请求的帮助程序。无论如何，我们必须这样做，因为它包括跨网络通信，并超出单元范围。假设要测试的函数使用jQuery.get方法。我们知道它的接口，并可以用自己的方法覆盖它，该方法只向QUnit报告。您可以在以下示例中看到这一点：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `RSSFeed` constructor produces an object that can load data from a remote
    source. Data is being loaded asynchronously using `$.get`. To test the method,
    we override `$.get` with our own method. Our implementation invokes a supplied
    callback as expected from `jQuery.get` and does it asynchronously by using `setTimeout`.
    Towards the end, it makes the assertion and notifies QUnit that the test is complete.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`RSSFeed`构造函数产生一个可以从远程源加载数据的对象。数据通过使用`$.get`异步加载。为了测试这个方法，我们用我们自己的方法覆盖了`$.get`。我们的实现如预期的`jQuery.get`一样调用提供的回调，并通过使用`setTimeout`异步执行。最后，它进行断言并通知QUnit测试已完成。'
- en: Organizing test cases (Simple)
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织测试用例（简单）
- en: In this recipe, we will learn how to keep the tests logically organized by using
    the `QUnit.module` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何通过使用`QUnit.module`方法来保持测试逻辑上的组织。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'While working on a real project, the number of tests can be pretty huge; for
    example, the jQuery test suite contains about 6,000 tests shown in the following
    screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中工作时，测试的数量可能相当巨大；例如，jQuery测试套件包含大约6000个测试，如下面的屏幕截图所示：
- en: '![Getting ready](img/2173_06_01.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/2173_06_01.jpg)'
- en: Navigation on such lists without any grouping abilities would be a tough task.
    Luckily, QUnit provides the module method, which allows us to organize the tests
    and run a specific group of tests individually.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有分组能力的列表上进行导航将是一项艰巨的任务。幸运的是，QUnit提供了模块方法，它允许我们将测试组织成特定的测试组并单独运行。
- en: 'Imagine we have an application handles user interaction with the Sign In and
    Password Reset forms. We don''t need any implementation details for now, but a
    high-level concept as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个应用程序处理与登录表单和密码重置表单的用户交互。现在我们不需要任何实现细节，但以下是一个高级概念：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Thus, we have two object constructors and three methods each that must be tested.
    Let's split up the test into two groups, one for the SignIn form and one for Rest
    PasswordForm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两个对象构造函数和三个方法，每个都需要进行测试。让我们把测试分成两组，一组用于登录表单，一组用于重置密码表单。
- en: How to do it
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: Define a test group (`module`) for the `SignInForm` constructor.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SignInForm`构造函数定义一个测试组（`module`）。
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Put underneath all the tests relevant to the group.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有与组相关的测试放在下面。
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Load the test runner in a browser and examine the results shown in the following
    screenshot:![How to do it](img/2173_06_02.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中加载测试运行器，并检查下面屏幕截图中显示的结果：![如何操作](img/2173_06_02.jpg)
- en: Using a shared setup (Medium)
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享设置（中等）
- en: In this recipe, we will guide you on test group operations such as shared preliminary
    tasks and how to keep the testing environment clean between test executions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将指导您进行测试组操作，例如共享预先任务以及如何在测试执行之间保持测试环境清洁。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: While writing more and more tests, you will realize that to get clear results,
    you need to repeatedly set up the environment in a specific state before running
    a test and restore its original state afterwards. This is a time-consuming task
    that involves code duplication. Most testing frameworks, including QUnit, support
    the so-called shared setup code. Thus, you can define two callbacks for a group
    of tests. The first one (`setup`) takes responsibility for recreating the intended
    environment state prior to every test of the exercising group. The second (`teardown`)
    cleans up the changes made to the environment after every test is done.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写越来越多的测试时，您将意识到为了获得清晰的结果，您需要在运行每个测试之前反复将环境设置为特定的状态，并在运行测试后恢复其原始状态。这是一个耗时的任务，涉及到代码重复。包括QUnit在内的大多数测试框架都支持所谓的共享设置代码。因此，您可以为测试组定义两个回调。第一个（`setup`）负责在锻炼组的每个测试之前重新创建所需的的环境状态。第二个（`teardown`）在每项测试完成后清理对环境所做的更改。
- en: 'To consider the advantages of the approach, let''s take a sample module for
    testing:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑这种方法的优点，让我们拿一个测试模块的样本：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A constructor producing `SignInForm` can hide or show up. During initialization,
    the object (`SignInForm`) binds to the elements. An instance of `SignInForm` expects
    of HTML layout an element to bind to. The `SignInForm` methods are permitted to
    modify DOM within the bounding box element. Theoretically, every second test starts
    on a diverse DOM that may affect test results. We can prevent the problem by adding
    a clean bounding box to the DOM tree on the test setup and removing it with teardown.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 产生`SignInForm`的构造函数可以隐藏或显示。在初始化过程中，对象（`SignInForm`）绑定到元素。`SignInForm`的实例期待HTML布局中的一个元素来绑定。`SignInForm`方法被允许在边界框元素内修改DOM。从理论上讲，每秒第二次测试开始于不同的DOM，这可能会影响测试结果。我们可以通过在测试设置中添加一个干净的边界框到DOM树上并在拆卸时移除它来防止这个问题。
- en: How to do it
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Define a test group (`module`) for the `SignInForm` constructor as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个测试组（`module`）用于`SignInForm`构造函数，如下所示：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The second parameter `QUnit.module` of the module method expects an object called
    shared setup confi guration.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块方法的第二个参数`QUnit.module`期望一个称为共享设置配置的对象。
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the code appending the bounding box element to the DOM tree on setup and
    the code removing it on teardown as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将附加边界框元素的代码添加到DOM树中的设置，并在拆卸时从DOM树中移除代码，如下所示：
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Move the `SignInForm` instance creation code to the shared setup as it is repeatedly
    required by every test of the group.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SignInForm`实例创建代码移动到共享设置中，因为该代码组中的每个测试都会重复使用。
- en: '[PRE36]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Write tests to assert on the `SignInForm` methods.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试以断言`SignInForm`方法。
- en: '[PRE37]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Load the test runner in a browser and examine the results shown in the following
    screenshot:![How to do it](img/2173_07_01.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中加载测试运行器并检查以下屏幕截图显示的结果：![如何做到这一点](img/2173_07_01.jpg)
- en: Testing user actions (Medium)
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用户行为（中等）
- en: In this recipe, we will write a simple calculator widget. By testing, we will
    simulate end-user actions and assert the intended application behavior.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将编写一个简单的计算器小部件。通过测试，我们将模拟最终用户的行为并断言预期的应用程序行为。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before jumping on the test, we definitely need an application expecting user
    actions. Let it be a simple calculator that cannot do complex operations but will
    sum up two of the supplied numbers, as seen in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到测试之前，我们绝对需要一个期望用户行为的应用程序。让它成为一个简单的计算器，它不能进行复杂操作，但将两个提供的数字相加，如下面的屏幕截图所示：
- en: '![Getting ready](img/2173_08_01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/2173_08_01.jpg)'
- en: 'To make it work, we subscribe a handler to the `click` event on the **Calculate**
    button. The handler takes the values of the first and second fields, sums them
    up, and puts the result in the third field. The implementation of the code is
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们订阅了一个处理程序，用于处理**计算**按钮的`click`事件。处理程序获取第一和第二个字段的值，将它们相加，并将结果放在第三个字段中。代码的实现如下：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s save the source code into the `calc.js` file and load it from the HTML
    layout:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将源代码保存到`calc.js`文件中，并从HTML布局中加载它：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we run this HTML in a browser and test it manually. With numbers typed
    in, the button clicked, and the result received, we are now ready to write an
    automated test for the actions we just performed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在浏览器中运行这个HTML并手动测试它。输入数字，点击按钮，接收结果，我们现在准备好为刚刚执行的操作编写自动化测试。
- en: How to do it
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Subscribe a handler to the DOM-ready event and get references on the involved
    elements. To mimic a user typing numbers and clicking the button, we need to refer
    to the inputs and the button. However, elements will be available only when the
    DOM tree is built. So, we obtain references on the elements in the handler, which
    is called on the DOM-ready event. For that, we use the helper introduced in the
    sample application as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个处理程序到DOM就绪事件，并获取涉及的元素的引用。为了模仿用户输入数字并点击按钮，我们需要引用输入和按钮。然而，元素只有在DOM树构建后才可用。因此，我们在处理程序中获取元素的引用，该处理程序在DOM就绪事件中被调用。为此，我们使用样本应用程序中引入的帮助器如下：
- en: '[PRE40]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Define a test scope and simulate the user behavior. Within the scope, we assign
    test values to inputs and trigger the click event. Since the application responds
    to the click event immediately, we can synchronously assert that the value in
    the result field equals the sum of numbers we supplied.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个测试范围并模拟用户行为。在范围内，我们将测试值分配给输入并触发点击事件。由于应用程序立即对点击事件做出响应，我们可以同步断言结果字段中的值等于我们提供的数字之和。
- en: '[PRE41]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Load the test runner in a browser and examine the results shown in the following
    screenshot:![How to do it](img/2173_08_02.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中加载测试运行器并检查以下屏幕截图显示的结果：![如何做到这一点](img/2173_08_02.jpg)
- en: Running Qnit in the console (Advanced)
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在控制台运行QUnit（高级）
- en: In this recipe, we will run QUnit tests from the command line by using the PhantomJS
    headless browser.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用无头浏览器PhantomJS从命令行运行QUnit测试。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: We've learnt how to run QUnit in a browser and it's suitable in the beginning.
    However, in an advanced development cycle, the tests are being executed by a tool
    such as a piece of build automation software or a **VCS** (**version control system**).
    So, we need to run our tests in the console. That can be done with QUnit tests
    using a headless browser.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何在浏览器中运行QUnit，这在开始时是合适的。然而，在一个先进的发展周期中，测试正在被像构建自动化软件或**VCS**（**版本控制系统**）这样的工具执行。因此，我们需要在控制台运行我们的测试。这可以通过使用无头浏览器进行QUnit测试来实现。
- en: 'Let''s take **PhantomJS** ([https://github.com/ariya/phantomjs](https://github.com/ariya/phantomjs)).
    First of all, we have to install the package. That''s quite easy to do with a
    package manager in Mac OS or in Unix/Linux. For an instance using Homebrew on
    Mac OS, you can do it like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看**PhantomJS**（[https://github.com/ariya/phantomjs](https://github.com/ariya/phantomjs)）。首先，我们必须安装这个包。在Mac
    OS或Unix/Linux中使用包管理器来安装这个包是非常简单的。例如，在Mac OS上使用Homebrew，你可以这样做：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On Windows, you can simply download the executable file from [http://phantomjs.org/download.html](http://phantomjs.org/download.html)
    and add its location to the Windows path as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，你可以简单地从[http://phantomjs.org/download.html](http://phantomjs.org/download.html)下载可执行文件，并将其位置添加到Windows路径中：
- en: Hold *Win* and press *Pause*.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Win*和*Pause*。
- en: Click on **Advanced System Settings**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**高级系统设置**。
- en: Click on **Environment Variables**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**环境变量**。
- en: Append `C:\phantomjs` to the *Path* variable.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`C:\phantomjs`添加到*Path*变量。
- en: We will also need the PhantomJS Runner script ([https://github.com/ariya/phantomjs](https://github.com/ariya/phantomjs)),
    which plugs in to QUnit to translate the report output into command-line-compatible
    format.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要PhantomJS Runner脚本（[https://github.com/ariya/phantomjs](https://github.com/ariya/phantomjs)），它插件到QUnit，将报告输出转换为与命令行兼容的格式。
- en: How to do it
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: Install PhantomJS.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装PhantomJS。
- en: Download PhantomJS Runner and save it as `runner.js`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载PhantomJS Runner并将其保存为`runner.js`。
- en: 'Run the test suite with the following command:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行测试套件：
- en: '[PRE43]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Examine the results shown in the following screenshot:![How to do it](img/2173_09_01.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下屏幕截图中显示的结果：![如何做到这一点](img/2173_09_01.jpg)
- en: There's more
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: You may find plenty of projects on GitHub ([https://github.com](https://github.com))
    using the **Travis CI** ([https://travis-ci.org](https://travis-ci.org)) continuous
    integration server. Travis CI reports to the project members when somebody breaks
    the build. It means if you make some changes in the project code and use the push
    command to commit to GitHub, Travis CI can automatically check if the changed
    code still adheres to the style guide and linter requirements, if the unit test
    still passes, and so on. How does it work? With every code commit, Travis CI pulls
    down the project's working directory from GitHub and runs the **Grunt** task runner
    ([www.gruntjs.com](http://www.gruntjs.com)). Grunt performs the tasks supplied
    in the confi guration fi le (`Gruntfile.js`). Among other tasks, you can assign
    QUnit tests. Travis CI stores the test results in the build report and notifi
    es the commit if the build fails.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在GitHub（[https://github.com](https://github.com)）上找到许多使用**Travis CI**（[https://travis-ci.org](https://travis-ci.org)）持续集成服务器的项目。当有人破坏了构建时，Travis
    CI会向项目成员报告。这意味着如果你在项目代码中做了一些更改，并使用推送命令提交到GitHub，Travis CI可以自动检查更改后的代码是否仍然符合风格指南和代码审查要求，单元测试是否仍然通过，等等。它是如何工作的？每次代码提交时，Travis
    CI都会从GitHub拉取项目的 working directory，并运行**Grunt**任务运行器（[www.gruntjs.com](http://www.gruntjs.com)）。Grunt执行配置文件（`Gruntfile.js`）中提供的任务。在其他任务中，你可以分配QUnit测试。Travis
    CI将测试结果存储在构建报告中，并在构建失败时通知提交。
- en: 'Let''s see how we can take advantage of this approach:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何利用这种方法：
- en: 'Install Node.js. For Mac OS X, we can again recourse to Homebrew:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Node.js。对于Mac OS X，我们再次求助于Homebrew：
- en: '[PRE44]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Installation instructions for other platforms can be found on this page:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他平台安装说明可以在这一页找到：
- en: '[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)'
- en: 'Install Grunt. It can be easily done now that we have the `Node.js` package
    manager:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Grunt。现在我们有了`Node.js`包管理器，这很容易完成：
- en: '[PRE45]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Move to the project working directory.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到项目working directory。
- en: Configure the project with `package.json`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`package.json`配置项目。
- en: '[PRE46]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Install the required dependencies:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所需的依赖项：
- en: '[PRE47]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Set up the `Grunt` task to fire up the QUnit test runner in `test-suite.html`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Grunt`任务来在`test-suite.html`中启动QUnit测试运行器：
- en: '[PRE48]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Examine the results shown in the following screenshot:![There's more](img/2173_09_02.jpg)
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以下屏幕截图中显示的结果：![还有更多](img/2173_09_02.jpg)
- en: Cross-browser-distributed testing (Advanced)
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨浏览器分布式测试（高级）
- en: This recipe will guide you on automating client-side cross-platform/browser
    testing using the command-line tool **Bunyip**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将指导你使用命令行工具**Bunyip**来自动化客户端跨平台/浏览器测试。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: In contrast to the server-side software, JavaScript applications are being executed
    on the client side and therefore depend on the user browser. Normally, project
    specification includes the list of the browsers and platforms that the application
    must support. The longer the list, the harder is cross-browser-compatibility testing.
    For example, jQuery supports 13 browsers on different platforms. The project is
    fully tested in every declared environment with every single commit. That is possible
    thanks to the distributed testing tool TestSwarm ([swarm.jquery.org](http://swarm.jquery.org)).
    You may also hear of other tools such as Js TestDriver ([code.google.com/p/js-test-driver](http://code.google.com/p/js-test-driver))
    or Karma ([karma-runner.github.io](http://karma-runner.github.io)). We will take
    Bunyip ([https://github.com/ryanseddon/bunyip](https://github.com/ryanseddon/bunyip))
    as it has swiftly been gaining popularity recently.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器端软件相比，JavaScript应用程序在客户端执行，因此取决于用户浏览器。通常，项目规格包括应用程序必须支持浏览器和平台列表。列表越长，跨浏览器兼容性测试越困难。例如，jQuery支持不同平台上的13种浏览器。项目在每种声明的环境中每个提交都会完全测试。这得益于分布式测试工具TestSwarm（[swarm.jquery.org](http://swarm.jquery.org)）。你也可能听说过其他工具，如Js
    TestDriver（[code.google.com/p/js-test-driver](http://code.google.com/p/js-test-driver)）或Karma（[karma-runner.github.io](http://karma-runner.github.io)）。我们选择Bunyip（[https://github.com/ryanseddon/bunyip](https://github.com/ryanseddon/bunyip)），因为它最近迅速获得了人气。
- en: 'How does it work? You launch the tool for a test runner HTML and it provides
    the connect end-point (`IP:port`) and launches a locally installed browser if
    configured. As soon as you fire up the address in a browser, the client is captured
    by Bunyip and the connection is established. With your confirmation, Bunyip runs
    the tests in every connected browser to collect and report results. See the following
    figure:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？你启动测试运行器HTML的工具，它提供连接端点（`IP:端口`）并启动本地安装的浏览器（如果配置了）。一旦你在浏览器中启动地址，客户端就被Bunyip捕获，并建立连接。在你的确认下，Bunyip在每个连接的浏览器中运行测试，以收集和报告结果。请参考以下图表：
- en: '![Getting ready](img/2173_10_01.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![准备开始](img/2173_10_01.jpg)'
- en: Bunyip is built on top of the Yeti tool ([www.yeti.cx](http://www.yeti.cx))
    works with **YUI Test**, QUnit, **Mocha**, **Jasmine**, or DOH. Bunyip can be
    used in conjunction with BrowserStack. So, with a paid account at BrowserStack
    ([www.browserstack.com](http://www.browserstack.com)), you can make Bunyip run
    your tests on hundreds of remotely hosted browsers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Bunyip是建立在Yeti工具之上的（[www.yeti.cx](http://www.yeti.cx)），与**YUI Test**、QUnit、**Mocha**、**Jasmine**或DOH配合使用。Bunyip可以与BrowserStack配合使用。因此，拥有BrowserStack的付费账户（[www.browserstack.com](http://www.browserstack.com)），你可以让Bunyip在数百个远程托管的浏览器上运行你的测试。
- en: 'To install the tool type in the console as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 安装工具时，在控制台输入以下内容：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we recourse to the `Node.js` package manager is part of `Node.js`. So
    if you don''t have `Node.js` installed, find the installation instructions on
    the following page:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们求助于`Node.js`包管理器是`Node.js`的一部分。所以如果你没有安装`Node.js`，请找到以下页面的安装说明：
- en: '[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)'
- en: Now, we are ready to start using Bunyip.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好开始使用Bunyip了。
- en: How to do it
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行
- en: 'Add to the QUnit test suite (`test-suite.html`) the following configuration
    option to prevent it from auto-starting before the plugin callback is set up:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向QUnit测试套件（`test-suite.html`）添加以下配置选项，以防止在插件回调设置之前自动启动：
- en: '[PRE50]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Launch a Yeti hub on port 9000 (default configuration) and use `test-suite.html`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口9000上启动Yeti中心（默认配置）并使用`test-suite.html`。
- en: '[PRE51]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Copy the connector address (for example, `http://127.0.0.1:9000`) from the output
    and fire it up in diverse browsers. You can use Oracle VirtualBox ([www.virtualbox.org](http://www.virtualbox.org))
    to launch browsers in virtual machines set up on every platform you need.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中复制连接器地址（例如，`http://127.0.0.1:9000`），并在不同的浏览器中启动它。你可以使用Oracle VirtualBox([www.virtualbox.org](http://www.virtualbox.org))在每个需要的平台上启动虚拟机中的浏览器。
- en: Examine the results shown in the following screenshot:![How to do it](img/2173_10_02.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下屏幕截图中显示的结果：![如何做到这一点](img/2173_10_02.jpg)
- en: Building a web project (Advanced)
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Web项目（高级）
- en: While working with a JavaScript project build may sound odd, it's quite relevant
    here. Using build , we can perform a bunch of project-related tasks with a single
    command. It's common practice nowadays to run tasks such as JavaScript linting,
    code standard validation, CSS preprocessing, and API documentation update with
    a build script, manually or using continuous integration tools. This recipe shows
    how the QUnit testing task can be added to the project build script.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在JavaScript项目中进行构建可能听起来很奇怪，但在这里却是相当相关的。使用构建，我们可以用一条命令执行与项目相关的许多任务。现在常见的做法是使用构建脚本，手动或使用持续集成工具来运行诸如JavaScript校验、代码标准验证、CSS预处理和API文档更新的任务。这个食谱展示了如何将qUnit测试任务添加到项目构建脚本中。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: For this task, we will use **Apache Ant (** [http://ant.apache.org/](http://ant.apache.org/)
    **)** for build automating. On Mac OS X, Ant is available by default. On Unix/Linux,
    it is available in ports and you can use a package manager to install Ant. As
    for Windows you can find the installation instructions in the official manual
    at [ant.apache.org/manual/index.html](http://ant.apache.org/manual/index.html).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们将使用**Apache Ant（** [http://ant.apache.org/](http://ant.apache.org/)
    **）**进行构建自动化。在Mac OS X上，Ant是默认可用的。在Unix/Linux上，它可在端口上使用，你可以使用包管理器来安装Ant。至于Windows，你可以找到安装说明在官方手册中[ant.apache.org/manual/index.html](http://ant.apache.org/manual/index.html)。
- en: 'Since Ant runs QUnit tests on the command line, we will use PhantomJS as it
    is discussed in . However, if we are to satisfy third-party software executing
    the build script such as continuous integration tools, we need to make the QUnit
    report in a specific format. Most tools accept **JUnit XML**. We can translate
    the QUnit output to JUnit format with a plugin called **JUnit Logger** ([https://github.com/jquery/qunit-reporter-junit](https://github.com/jquery/qunit-reporter-junit)).
    So, we add to the test runner HTML the plugin JavaScipt module and the following
    configuration option:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ant在命令行上运行qUnit测试，我们将使用PhantomJS，如所讨论的。然而，如果要满足执行构建脚本的第三方软件，例如持续集成工具，我们需要将QUnit报告格式化为特定格式。大多数工具接受**JUnit
    XML**。我们可以使用名为**JUnit Logger**的插件（[https://github.com/jquery/qunit-reporter-junit](https://github.com/jquery/qunit-reporter-junit)）将QUnit输出翻译为JUnit格式。因此，我们在测试运行器HTML中添加了插件JavaScipt模块和以下配置选项：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: But here pops up another problem. The PhantomJS Runner script now breaks JUnit
    XML with its own report version. You can simply comment out `console.log` occurrences
    in the `QUnit.done` and `QUnit.testDone` callback functions at the end of `runner.js`
    and save it, say as `runner-muted.js`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里又出现了另一个问题。PhantomJS运行器脚本现在用其自己的报告版本打破了JUnit XML。你可以在`runner.js`的末尾简单地注释掉`QUnit.done`和`QUnit.testDone`回调函数中的`console.log`出现，并将其保存为`runner-muted.js`。
- en: How to do it
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Set up the build script as `build.xml` in the root of the project working directory:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目工作目录的根目录下设置构建脚本为`build.xml`：
- en: '[PRE53]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Extend it with the build target to run QUnit tests:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用构建目标扩展以运行qUnit测试：
- en: '[PRE54]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run Ant in the same directory where `build.xml` is located:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.xml`文件所在的相同目录中运行Ant：
- en: '[PRE55]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Examine the results shown in the following screenshot:![How to do it](img/2173_11_01.jpg)
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下屏幕截图中显示的结果：![如何做到这一点](img/2173_11_01.jpg)
- en: QUnit and CI – setting up Jenkins (Advanced)
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: qUnit和持续集成 - 设置Jenkins（高级）
- en: Continuous integration is the practice of automating predeployment-related tasks
    that allows team members to integrate their work into the project frequently..
    As an approach, CI doesn't require any particular tool but is most profitable
    when used with a Continuous Integration Server. You can find many open source
    servers available nowadays. Yet Jenkins (known as Hudson till 2011; [www.jenkins-ci.org](http://www.jenkins-ci.org))
    seems to be the most popular solution. It became known as the better alternative
    to **CruiseControl** (the first original implementation of the CI automation concept)
    and won many open source awards. Jenkins is quite easy to set up and has a huge
    repository of plugins that integrate the server with a wide range of third-party
    tools
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是一种自动化预部署相关任务的实践，使团队成员能够频繁地将工作整合到项目中。作为一种方法，CI不需要任何特定的工具，但与持续集成服务器一起使用时收益最大。你现在可以找到许多开源服务器。然而Jenkins（直到2011年称为Hudson；[www.jenkins-ci.org](http://www.jenkins-ci.org)）似乎是最受欢迎的解决方案。它已成为**CruiseControl**（第一个原始CI自动化概念的实现）的更好替代方案，并赢得了众多开源奖项。Jenkins非常容易设置，并拥有大量插件，可将服务器与各种第三方工具集成。
- en: We will now install a Jenkins CI server and set it up for a QUnit test runner
    job.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装一个Jenkins持续集成服务器，并为其设置一个QUnit测试运行器作业。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: 'The best way to explain CI is to show it in an example. Let''s assume you are
    one of the developers working on a project. You''re using a version control system
    so your collaboration on the code goes fine. Yet whenever a stable release is
    tagged, you inevitably run into problems (integration hell). You attempt to build
    the release and get surprised with the results. While working with the front end,
    "build" as a term may sound odd it is nonetheless quite relevant here. During
    release, a number of tasks must be performed: code quality analysis, code standard
    violation check, tests, CSS preprocessing, CoffeScript or TypeScript compilation,
    API documentation generation, image optimization, JS/CSS concatenation, and compression
    (see the article *H5bp Ant Build Script* at [https://github.com/h5bp/ant-build-script](https://github.com/h5bp/ant-build-script)).
    It gets even better on the server-side sources: project size is measured, software
    metrics are calculated, mess detection is performed, and code duplicates are identified
    (see *Template for Jenkins Jobs for PHP Projects* at [http://jenkins-php.org/index.html](http://jenkins-php.org/index.html)).
    That is what we call a build. We automate the build processing using special software,
    such as Apache Ant, Maven, Grunt, Phing, and Bash.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 解释持续集成的最佳方式就是通过一个例子来展示。假设你是项目中的一名开发者。你使用版本控制系统，因此你的代码协作进行得很顺利。然而每当打上稳定版本标签时，你不可避免地会遇到问题（集成地狱）。你尝试构建发布版本，并对结果感到惊讶。在与前端合作时，“构建”作为一个术语可能听起来很奇怪，但在这里却非常相关。在发布过程中，必须执行许多任务：代码质量分析，代码标准违规检查，测试，CSS预处理，CoffeScript或TypeScript编译，API文档生成，图像优化，JS/CSS合并和压缩（参见[H5bp
    Ant Build Script](https://github.com/h5bp/ant-build-script)一文）。在服务器端源代码方面更是如此：测量项目大小，计算软件度量，进行混乱检测，识别代码重复（参见[Jenkins
    PHP项目作业模板](http://jenkins-php.org/index.html)）。这就是我们所说的构建。我们使用特殊软件（如Apache Ant，Maven，Grunt，Phing和Bash）来自动化构建处理。
- en: CI server listens to the updates on the version control repository. Whenever
    you commit, the server pulls the working version of the project and runs the **build
    script**. It collects the reports of the tools performing the build tasks and
    lets you know by e-mail whether the build was successful or not. Thus, you know
    immediately if the changes you made cause any trouble during integration.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: CI服务器监听版本控制仓库的更新。无论何时你提交代码，服务器都会拉取项目的当前版本并运行**构建脚本**。它收集执行构建任务的工具的报告，并通过电子邮件让你知道构建是否成功。因此，你知道立即你所做的更改是否在集成过程中引起任何麻烦。
- en: To get a better grip on CI, we install Jenkins server and define a job running
    QUnit tests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地掌握CI，我们安装Jenkins服务器并定义一个运行QUnit测试的作业。
- en: How to do it
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到持续集成
- en: 'Install Jenkins. If you work under MacOS X, just run:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Jenkins。如果你在MacOS X下工作，只需运行：
- en: '[PRE56]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To install Jenkins on Unix/Linux, please find instructions at [https://wiki.jenkins-ci.org/display/JENKINS/Use+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Use+Jenkins)
    and for Windows at [https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+as+a+Windows+service](https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+as+a+Windows+service).
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要安装Jenkins在Unix/Linux上，请参阅[https://wiki.jenkins-ci.org/display/JENKINS/Use+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Use+Jenkins)的说明，以及Windows上的说明[https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+as+a+Windows+service](https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+as+a+Windows+service)。
- en: Create a dedicated user `Jenkins` for the server daemon.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务器守护进程创建一个专用用户`Jenkins`。
- en: Fire up `http://localhost:8080` (by default configuration) in your browser.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中启动`http://localhost:8080`（默认配置）。
- en: Examine the Jenkins dashboard page shown in the following screenshot:![How to
    do it](img/2173_12_01.jpg)
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查下面的屏幕截图中显示的Jenkins仪表板页面：![如何操作](img/2173_12_01.jpg)
- en: Enable the Git plugin.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Git插件。
- en: Navigate to **Jenkins** | **Manage Jenkins** | **Manage Plugins** | **Available**
    and select **Git plugin**.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Jenkins** | **管理Jenkins** | **管理插件** | **可用**，并选择**Git插件**。
- en: Confirm your choice by clicking on the **OK** button at the bottom of the page.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击页面底部的**确定**按钮确认您的选择。
- en: Add a new job to Jenkins.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向Jenkins添加新作业。
- en: Enter the **Jenkins Dashboard** page and click on the **Add new job** link.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Jenkins仪表板**页面，并点击**添加新作业**链接。
- en: Specify the project (`job`) name in the displayed form.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示的表单中指定项目（`job`）名称。
- en: Choose **Build a free-style software project** as shown in the following screenshot:![How
    to do it](img/2173_12_02.jpg)
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择如下屏幕截图所示的**构建自由风格软件项目**：![如何操作](img/2173_12_02.jpg)
- en: Examine the next screen as shown in the following screenshot:![How to do it](img/2173_12_03.jpg)
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以下屏幕截图中的下一个屏幕：![如何操作](img/2173_12_03.jpg)
- en: Choose the **Source Code Management** / **Git** section and type in your Git
    remote repository (for example, `git@dsheiko.local:repo/tree`)
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**源代码管理** / **Git** 部分，并输入您的Git远程仓库（例如，`git@dsheiko.local:repo/tree`）
- en: Select **Publish JUnit test result report** in the **Post-build Actions** combo-box,
    and specify the location of our build-generated report file (`build/qunit/qunit-results.xml`)
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建后操作**下拉框中选择**发布JUnit测试结果报告**，并指定我们构建生成的报告文件的位置（`build/qunit/qunit-results.xml`）
- en: Confirm changes by clicking on the **Save** button
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**保存**按钮确认更改。
- en: Come back to the **Jenkins Dashboard** page and click on the **Build Now** link.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回**Jenkins仪表板**页面，并点击**立即构建**链接。
- en: Find a new record added in the **Build History** block of the Jenkins sidebar
    menu.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jenkins侧边栏菜单的**构建历史**块中找到添加的新记录。
- en: Open the link and examine the **build details** page.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开链接并检查**构建详情**页面。
- en: Follow the **Test Result** link at the bottom to get report details.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部的**测试结果**链接以获取报告详情。
- en: Examine the rest of the results shown in the following screenshot:![How to do
    it](img/2173_12_04.jpg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以下屏幕截图中显示的其他结果：![如何操作](img/2173_12_04.jpg)
- en: Configure the job for continuous integration
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为持续集成配置作业
- en: Open the project page and click on **Configure**.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目页面并点击**配置**。
- en: Choose the build-required notification method in **Build Triggers** and specify
    a run schedule in the **Schedule** field as shown in the following screenshot:![How
    to do it](img/2173_12_05.jpg)
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建触发器**中选择需要的构建通知方法，并在**计划**字段中指定运行计划，如下面的屏幕截图所示：![如何操作](img/2173_12_05.jpg)
- en: Pick up **E-mail notification** from the **Post-build Actions** combo-box and
    type in your email address.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**构建后操作**下拉框中选择**电子邮件通知**，并输入您的电子邮件地址。
- en: Commit a change in your project and push it to the Git server and get automatically
    notified if the QUnit tests fail.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目中提交更改，并将其推送到Git服务器，如果QUnit测试失败，将自动通知您。
- en: There's more
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: If you are an authorized `jenkins` user at the Git server, you won't be able
    to make a build using the Git plugin. You need a pair of SSH keys to exchange
    between the `git` and `jenkins` users as described in the *Git Documentation*
    section ([http://git-scm.com/book/ch4-4.html](http://git-scm.com/book/ch4-4.html)).
    If you are on a Mac, the article *Setting up a Git Server on Mac OSX* ([http://blog.smitec.net/posts/setting-up-a-git-server-on-osx/](http://blog.smitec.net/posts/setting-up-a-git-server-on-osx/))
    will be of great help.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Git服务器上授权的`jenkins`用户，你将无法使用Git插件进行构建。你需要一对SSH密钥，以便在`git`和`jenkins`用户之间进行交换，具体请参考*Git文档*章节（[http://git-scm.com/book/ch4-4.html](http://git-scm.com/book/ch4-4.html)）。如果你使用的是Mac，文章*在Mac
    OSX上设置Git服务器*（[http://blog.smitec.net/posts/setting-up-a-git-server-on-osx/](http://blog.smitec.net/posts/setting-up-a-git-server-on-osx/)）将对你有很大帮助。
- en: 'In order to use the Jenkins Git plugin, under Unix/Linux, we login as `jenkins`
    and create a pair of RSA keys:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Unix/Linux下使用Jenkins Git插件，我们需要以`jenkins`用户登录并创建一对RSA密钥：
- en: '[PRE57]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Then, we copy derived the `jenkins_rsa.pub` file to the Git server.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`jenkins_rsa.pub`文件复制到Git服务器上。
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We also have to edit `~/.ssh/config` to configure the SSH client:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编辑`~/.ssh/config`文件以配置SSH客户端：
- en: '[PRE59]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, Jenkins is supposed to be automatically authorized on the Git server.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Jenkins应该可以在Git服务器上自动授权。
