- en: Chapter 4. Controlling the Data Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。控制数据流
- en: In the previous chapter, we learned how to store data in our database persistently.
    In this chapter, we will take a look at how we can tell Meteor what to send to
    the clients.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章节中，我们学习了如何将数据持久化地存储在我们的数据库中。在本章中，我们将了解如何告诉Meteor应该向客户端发送什么数据。
- en: Until now, this all worked magically because we used the `autopublish` package,
    which synced all of the data with every client. Now, we will control this flow
    manually, sending only the necessary data to the client.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些都是因为使用了`autopublish`包而神奇地工作的，该包将与每个客户端同步所有数据。现在，我们将手动控制这个流程，只向客户端发送必要的数据。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Synchronizing data with the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与服务器同步数据
- en: Publishing data to clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户端发布数据
- en: Publishing partial collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布部分集合
- en: Publishing only the specific fields of documents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只发布文档的特定字段
- en: Lazy loading more posts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟加载更多帖子
- en: Note
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to jump right into the chapter and follow the examples, download
    the previous chapter's code examples from either the book's web page at [https://www.packtpub.com/books/content/support/17713](https://www.packtpub.com/books/content/support/17713),
    or from the GitHub repository at [https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter3](https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter3).
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要直接进入章节并跟随示例，可以从书籍的网页 [https://www.packtpub.com/books/content/support/17713](https://www.packtpub.com/books/content/support/17713)
    或者从GitHub仓库 [https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter3](https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter3)
    下载前一章节的代码示例。
- en: These code examples will also contain all the style files, so we don't have
    to worry about adding CSS code along the way.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些代码示例还将包含所有样式文件，因此我们不需要在过程中担心添加CSS代码。
- en: Syncing data – the current Web versus the new Web
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据同步 – 当前的Web与新的Web
- en: In the current Web, most pages are either static files hosted on a server or
    dynamically generated by a server on a request. This is true for most server-side-rendered
    websites, for example, those written with PHP, Rails, or Django. Both of these
    techniques required no effort besides being displayed by the clients; therefore,
    they are called *thin* clients.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的Web中，大多数页面要么是托管在服务器上的静态文件，要么是由服务器在请求时生成的动态页面。这对于大多数服务器端渲染的网站来说是真的，例如用PHP、Rails或Django编写的网站。这两种技术除了被客户端显示外不需要任何努力；因此，它们被称为*薄*客户端。
- en: In modern web applications, the idea of the browser has moved from thin clients
    to *fat* clients. This means most of the website's logic resides on the client
    and the client asks for the data it needs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络应用程序中，浏览器的概念已经从薄客户端转移到*厚*客户端。这意味着网站的大部分逻辑都存在于客户端，并且客户端请求它需要的数据。
- en: Currently, this is mostly done via calls to an API server. This API server then
    returns data, commonly in JSON form, giving the client an easy way to handle it
    and use it appropriately.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这主要是通过调用API服务器实现的。这个API服务器然后返回数据，通常以JSON格式返回，给客户端一个轻松处理和使用数据的方式。
- en: Most modern websites are a mixture of thin and fat clients. Normal pages are
    server-side-rendered, where only some functionality, such as a chat box or news
    feed, is updated using API calls.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代网站都是薄客户端和厚客户端的混合体。普通页面是服务器端渲染的，只有如聊天框或新闻提要等功能通过API调用进行更新。
- en: Meteor, however, is built on the idea that it's better to use the calculation
    power of all clients instead of one single server. A pure fat client or a single-page
    app contains the entire logic of a website's frontend, which is send down on the
    initial page load.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor，然而，建立在这样一个理念上，即使用所有客户端的计算能力比使用一个单一服务器的计算能力要好。一个纯厚客户端或者一个单页应用包含了一个网站前端的所有逻辑，在初始页面加载时发送下来。
- en: The server then merely acts as a data source, sending only the data to the clients.
    This can happen by connecting to an API and utilizing AJAX calls, or as with Meteor,
    using a model called **publication/subscription**. In this model, the server offers
    a range of publications and each client decides which dataset it wants to subscribe
    to.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器随后仅仅作为数据源，只向客户端发送数据。这可以通过连接到API并利用AJAX调用实现，或者像Meteor一样，使用一种名为**发布/订阅**的模型。在这个模型中，服务器提供一系列发布物，每个客户端决定它想订阅哪个数据集。
- en: 'Compared with AJAX calls, the developer doesn''t have to take care of any downloading
    or uploading logic. The Meteor client syncs all of the data automatically in the
    background as soon as it subscribes to a specific dataset. When data on the server
    changes, the server sends the updated documents to the clients and vice versa,
    as shown in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与AJAX调用相比，开发者无需处理任何下载或上传逻辑。Meteor客户端在订阅特定数据集后自动后台同步所有数据。当服务器上的数据发生变化时，服务器将更新后的文档发送给客户端，反之亦然，如下面的图表所示：
- en: '![Syncing data – the current Web versus the new Web](img/00009.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![同步数据 - 当前的网络与新的网络](img/00009.jpeg)'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If this does sound insecure, be assured that we can set rules that filter changes
    on the server side. We will take a look at these possibilities in [Chapter 8](part0073_split_000.html#page
    "Chapter 8. Security with the Allow and Deny Rules"), *Security with the Allow
    and Deny Rules*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来确实不安全，请放心，我们可以设置规则，在服务器端过滤更改。我们将在[第8章](part0073_split_000.html#page "Chapter 8. Security
    with the Allow and Deny Rules")，*使用允许和拒绝规则进行安全设置*中查看这些可能性。
- en: Removing the autopublish package
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除autopublish包
- en: To work with Meteor's publications/subscriptions, we need to remove the `autopublish`
    package, which was added by default to our project.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Meteor的发布/订阅，我们需要移除`autopublish`包，这个包是我们项目默认添加的。
- en: This package is useful for rapid prototyping, but infeasible in production since
    all of the data in our database would be synced to all the clients. This is not
    only insecure but also slows down the data loading process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包适用于快速原型设计，但在生产环境中不可行，因为我们的数据库中的所有数据都将同步到所有客户端。这不仅不安全，而且还会减慢数据加载过程。
- en: 'We just run the following command from inside our `my-meteor-blog` folder on
    the terminal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在我们`my-meteor-blog`文件夹内的终端上运行以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we can run `meteor` again to start our server. When we check out the website,
    we will see that all our posts from the previous chapter are gone.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次运行`meteor`来启动我们的服务器。当我们检查网站时，我们会发现我们上一章的所有帖子都消失了。
- en: They are not really gone, however. The current server just didn't publish any
    yet, and the client just didn't subscribe to any; therefore, we can't see them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们实际上并没有消失。当前的服务器只是还没有发布任何内容，客户端也只是没有订阅任何内容；因此，我们看不到它们。
- en: Publishing data
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布数据
- en: In order to access the post on the client again, we need to tell the server
    to publish it to subscribing clients.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在客户端再次访问帖子，我们需要告诉服务器将其发布给订阅的客户端。
- en: 'To do so, we will create a file called `publications.js` inside the `my-meteor-blog/server`
    folder and add the following lines of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将在`my-meteor-blog/server`文件夹中创建一个名为`publications.js`的文件，并添加以下代码行：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Meteor.publish` function will create a publication called `all-posts` and
    return a cursor with all the posts from the `Post` collection in that publication.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meteor.publish`函数将创建一个名为`all-posts`的发布，并返回一个包含`Post`集合中所有帖子的游标。'
- en: Now, we only have to tell the client to subscribe to this publication and we
    will see our posts again.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需告诉客户端订阅这个发布，我们就会再次看到我们的帖子。
- en: 'We create a file called `subscriptions.js` inside the `my-meteor-blog/client`
    folder with the following content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`my-meteor-blog/client`文件夹中创建一个名为`subscriptions.js`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, when we check out our website, we can see that our blog posts have reappeared.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们检查我们的网站时，我们可以看到我们的博客文章已经重新出现。
- en: This happens because the client will subscribe to the `all-posts` publication
    when the `subsciptions.js` file is executed, which happens right before the page
    is fully loaded, as Meteor adds the `subsciptions.js` file automatically to the
    head of the document for us.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当执行`subsciptions.js`文件时，客户端会订阅`all-posts`发布，这发生在页面完全加载之前，因为Meteor自动将`subsciptions.js`文件添加到文档的头部为我们。
- en: This means that the Meteor server sends the website first and the JavaScript
    builds the HTML on the client; then, all the subscriptions get synced, which populate
    the client's collections, and the template engine, **Blaze**, can display the
    posts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Meteor服务器首先发送网站，然后JavaScript在客户端构建HTML；随后，所有订阅都会同步，填充客户端的集合，并且模板引擎**Blaze**能够显示帖子。
- en: Now that we have our posts back, let's see how we can tell Meteor to send only
    a subset of the documents from the collection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经恢复了我们的帖子，让我们看看我们如何告诉Meteor只发送集合中的一部分文档。
- en: Publishing only parts of data
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只发布数据的一部分
- en: To make our front page future-ready, we will need to limit the amount of posts
    shown on it, as we will probably have a lot of posts added with time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的首页更具未来感，我们需要限制在上面显示的文章数量，因为随着时间的推移，我们可能会添加很多文章。
- en: 'For this, we will create a new publication called `limited-posts`, where we
    can pass a `limit` option to the posts'' `find()` function and add it to our `publications.js`
    file, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将创建一个名为`limited-posts`的新发布，其中我们可以向文章的`find()`函数传递一个`limit`选项，并将其添加到我们的`publications.js`文件中，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We add a `sort` option, with which we sort the posts in descending order on
    the `timeCreated` field. This is necessary to ensure that we get the latest posts
    and then limit the output. If we only sort the data on the client, it might happen
    that we leave out newer posts, as the server publication would send only the first
    two documents it found, regardless of whether they are the latest ones or not.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个`sort`选项，通过它按`timeCreated`字段降序排列文章。这是必要的，以确保我们获取最新的文章并然后限制输出。如果我们只在客户端上对数据进行排序，可能会发生我们省略了较新的文章，因为服务器发布只会发送它找到的第一个文档，不管它们是否是最新的。
- en: 'Now we just have to go to `subscriptions.js` and change the subscription to
    the following line of code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需去到`subscriptions.js`文件，将订阅更改为以下代码行：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we check out our browser now, we will see that only the last two posts appear
    on our front page, since we only subscribed to two, as shown in the following
    screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看我们的浏览器，我们会看到只有最后两篇文章出现在我们的首页上，因为我们只订阅了两个，如下面的屏幕截图所示：
- en: '![Publishing only parts of data](img/00010.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![只发布数据的部分](img/00010.jpeg)'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must be aware that if we keep the code for the old subscription alongside
    the code for the new subscription, we will subscribe to both. This means Meteor
    merges both subscriptions and therefore keeps all the subscribed documents in
    our client-side collections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须意识到，如果我们保留旧订阅的代码并与新订阅的代码并列，我们将同时订阅两个。这意味着Meteor合并了两个订阅，因此在我们客户端集合中保留了所有订阅的文档。
- en: We need to either comment out the old subscription or remove it before adding
    the new one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新订阅之前，我们必须注释掉旧的订阅或删除它。
- en: Publishing specific fields
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布特定字段
- en: To improve publications, we can also determine which fields we want to publish
    from the document. For example, we can only ask for the `title` and `text` properties
    instead of all other properties.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化发布，我们还可以确定要从文档中发布哪些字段。例如，我们只要求`title`和`text`属性，而不是其他所有属性。
- en: This speeds up the synchronization of our subscriptions since we don't require
    the whole post but only the necessary data and short descriptions when listing
    posts on the front page.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以加快我们订阅的同步速度，因为我们不需要整个文章，只需要在首页上列出文章时必要的数据和简短描述。
- en: 'Let''s add another publication to our `publications.js` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`publications.js`文件中添加另一个发布：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As this is just an example, we pass an empty object as a query to find all the
    documents, and as the second parameter to `find()`, we pass an options object
    containing the `fields` object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个示例，我们传递一个空对象作为一个查询来查找所有文档，作为`find()`的第二个参数，我们传递一个包含`fields`对象的选项对象。
- en: Every field that we give a value of `1` will be included in the returned document.
    If we rather want to work by excluding fields, we can use the field name and set
    the value to `0`. However, we can't use both including and excluding fields, so
    we need to choose what fits better, depending on the document size.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给每个字段一个值为`1`的属性，该属性将被包含在返回的文档中。如果我们想通过排除字段来工作，我们可以使用字段名称并将值设置为`0`。然而，我们不能同时包含和排除字段，因此我们需要根据文档大小选择哪个更适合。
- en: 'Now we can simply change the subscription in our `subscriptions.js` file to
    the following line of code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`subscriptions.js`文件中简单地将订阅更改为以下代码行：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, when we open the browser, it will present us with a list of our posts.
    Only the titles are present and the description, time, and author fields are empty:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打开浏览器时，它将向我们展示一个文章列表。只有标题存在，而描述、时间和作者字段为空：
- en: '![Publishing specific fields](img/00011.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![发布特定字段](img/00011.jpeg)'
- en: Lazy loading posts
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载文章
- en: Now that we've gone through these simple examples, let's put them all together
    and add a nice lazy load feature to our posts' list on the front page.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经浏览了这些简单的示例，那么现在让我们将它们结合起来，并为首页上的文章列表添加一个优美的懒加载功能。
- en: 'Lazy loading is a technique that loads additional data only when the user desires
    it or when they scroll to the end. This can be used to increase page load, since
    the data to be loaded is limited. To do this, let''s perform the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是一种技术，只有在用户需要或滚动到末尾时才加载附加数据。这可以用来增加页面加载，因为要加载的数据是有限的。为此，让我们执行以下步骤：
- en: 'We need to add a lazy load button to the bottom of the list of posts on the
    front page. We go to our `home.html` file and add the following button at the
    end of our `home` template, right below the `{{#each postsList}}` block helper:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向首页文章列表的底部添加一个懒加载按钮。我们打开我们的`home.html`文件，在`home`模板的末尾，在我们`{{#each postsList}}`块助手下面添加以下按钮：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will add the publication that will send a flexible number of posts
    to our `publications.js` file, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的`publications.js`文件中添加一个发布，以发送灵活数量的文章，如下所示：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Basically, it's a combination of what we learned earlier.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这是我们之前学到的内容的组合。
- en: We used the `limit` option, but instead of setting a fixed number, we used the
    `limit` parameter, which we will later pass to this publication function.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了`limit`选项，但不是设置一个固定的数字，而是使用了`limit`参数，我们稍后将其传递给这个发布函数。
- en: Previously, we used the `fields` option and excluded the `text` field.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前，我们使用了`fields`选项并排除了`text`字段。
- en: 'We can just include `fields` to get the same result. This will be safer, as
    it ensures that we won''t get any extra fields in case the documents get extended:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以只包含`fields`来获得相同的结果。这将更安全，因为它确保我们在文档扩展时不会获取任何额外的字段：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We sorted the output to make sure we are always returning the latest posts.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对输出进行了排序，以确保我们总是返回最新的文章。
- en: Now that we have set our publication, let's add a subscription so that we can
    receive its data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的发布，让我们添加一个订阅，这样我们就可以接收其数据。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that we need to remove any other subscription beforehand so that we
    are not subscribing to any other publication.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要先删除任何其他订阅，这样我们就不会订阅任何其他发布。
- en: 'To do this, we need to make use of Meteor''s `session` object. This object
    can be used on the client side to set variables reactively. This means every time
    we change this session''s variable, it will run every function that uses it again.
    In the following example, we will use the session to increase our posts'' lists''
    number when clicking on the lazy load button:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要利用Meteor的`session`对象。这个对象可以在客户端用来设置反应性的变量。这意味着每次我们改变这个会话变量时，它都会再次运行使用它的每个函数。在下面的示例中，我们将使用会话来在点击懒加载按钮时增加文章列表的数量：
- en: 'First, in the `subscription.js` file, we add the following lines of code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`subscription.js`文件中，我们添加以下代码行：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we set the `lazyloadLimit` session variable to `2`, which will be the initial
    number of posts shown on the front page.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将`lazyloadLimit`会话变量设置为`2`，这将是我们前端页面最初显示的文章数量。
- en: Next, we create a `Tracker.autorun()` function. This function will run at the
    start time and later at any time when we change the `lazyloadLimit` session variable
    to another value.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`Tracker.autorun()`函数。这个函数将在开始时运行，后来在我们改变`lazyloadLimit`会话变量到另一个值时随时运行。
- en: Inside this function, we subscribe to `lazyload-posts`, giving the `lazyloadLimit`
    value as a second parameter. This way, every time the session variable changes,
    we change our subscription with a new value.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们订阅了`lazyload-posts`，将`lazyloadLimit`值作为第二个参数。这样，每次会话变量改变时，我们都用一个新的值改变我们的订阅。
- en: 'Now we only need to increase the session value by clicking on the lazy load
    button and the subscription will change, sending us additional posts. To do this,
    we add the following lines of code to our `home.js` file at the end:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要通过点击懒加载按钮来增加会话值，订阅就会改变，发送给我们额外的文章。为此，我们在`home.js`文件的末尾添加以下代码行：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will attach a `click` event to the lazy load button. Every time we
    click on this button, we get the `lazyloadLimit` session and it increases by two.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码将为懒加载按钮附加一个`click`事件。每次我们点击这个按钮时，我们都会获取`lazyloadLimit`会话，并增加两倍。
- en: When we check out our browser, we should be able to click on the lazy load button
    at the bottom of our posts list and it should add two more posts. This should
    happen every time we click on the button until we reach our five example posts.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们检查浏览器时，我们应该能够点击文章列表底部的懒加载按钮，它应该再添加两篇文章。每次我们点击按钮时，都应该发生这种情况，直到我们达到五个示例文章。
- en: This doesn't make much sense when we have only five posts, but when there are
    more than 50 posts, limiting the initially shown posts to 10 will noticeably speed
    up page loading time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只有五篇文章时，这看起来并不太有意义，但当文章超过50篇时，将最初显示的文章限制为10篇将显著提高页面加载时间。
- en: We then need to change only the session's default value to 10 and increase it
    by 10, and we have a nice lazy loading effect.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需要将会话的默认值更改为10并增加10，就可以实现一个很好的懒加载效果。
- en: Switching subscriptions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换订阅
- en: Now that we have the nice logic of lazy loading in place, let's take a look
    at what happens here under the hood.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了很好的懒加载逻辑，让我们来看看这里的底层发生了什么。
- en: The `.autorun()` function , which we created earlier, will run the first time
    the code gets executed, subscribing us to the `lazyload-posts` publication. Meteor
    then sends the first two documents of the `Posts` collection, as the `limit` we
    first sent is `2`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的`.autorun()`函数将在代码首次执行时运行，订阅`lazyload-posts`发布。Meteor然后发送`Posts`集合的最初两个文档，因为我们的第一个`limit`值是`2`。
- en: The next time we change the `lazyloadLimit` session, it changes the subscription
    by changing the limit to the value we passed to the publication function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们更改`lazyloadLimit`会话时，它通过更改发布函数中的限制值来更改订阅。
- en: Meteor then checks which documents exist in our client-side database in the
    background and requests to download the missing ones.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor然后在后台检查我们客户端数据库中存在的文档，并请求下载缺失的文档。
- en: This will also work the other way when we decrease the session value. Meteor
    removes the documents that don't match the current subscription/subscriptions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们减少会话值时，这个方法也会起作用。Meteor会删除与当前订阅/订阅不匹配的文档。
- en: 'So, we can try this; we open the console of our browser and set the session
    limit to `5`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以尝试这样做；我们打开浏览器控制台，将会话限制设置为`5`：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will immediately display all five example posts in our list. When we now
    set it back to a smaller value, we will see how they are removed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将立即在我们的列表中显示所有五个示例文章。现在如果我们将其设置为更小的值，我们将看到它们是如何被移除的：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To ensure that they are gone, we can query our local database to check, as
    follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它们已经消失，我们可以查询我们本地数据库，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will return us an array of two items, showing that Meteor removed the
    posts that we are not subscribing to anymore, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含两个项目的数组，显示Meteor已经删除了我们不再订阅的文章，如下图所示：
- en: '![Switching subscriptions](img/00012.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![切换订阅](img/00012.jpeg)'
- en: Some notes on data publishing
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于数据发布的一些说明
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To solve this, you can either publish posts and comments separately and connect
    them in the client or use a third-party package, which allows for reactive publications
    such as the great `reywood:publish-composite` package at [https://atmospherejs.com/reywood/publish-composite](https://atmospherejs.com/reywood/publish-composite).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以将文章和评论分开发布并在客户端连接它们，或者使用第三方包，如在[https://atmospherejs.com/reywood/publish-composite](https://atmospherejs.com/reywood/publish-composite)提供的允许有反应性发布的`reywood:publish-composite`包。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the only case where the `Meteor.publish()` function reruns is when
    the *current user* changes so that `this.userId` which is accessible in this function
    will change.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Meteor.publish()`函数重新运行的唯一情况是当前用户发生变化，使得`this.userId`在函数中可访问。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we created a few publications and subscribed to them. We used
    the `fields` and `limit` options to modify the number of published documents and
    created a simple lazy load logic for the front page of our blog.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了几篇发布文章并订阅了它们。我们使用了`fields`和`limit`选项来修改发布的文档数量，并为博客首页实现了一个简单的懒加载逻辑。
- en: 'To dig deeper into what we learned, we can take a look at [Chapter 3](part0035_split_000.html#page
    "Chapter 3. Storing Data and Handling Collections"), *Storing Data and Handling
    Collections*. While the following Meteor documentation will give us details about
    the options we can use in the collections `find()` functions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解我们学到的内容，我们可以查看[第3章](part0035_split_000.html#page "第3章 存储数据和处理集合"), *存储数据和处理集合*。以下Meteor文档将详细介绍我们可以在集合`find()`函数中使用的选项：
- en: '[https://www.meteor.com/livequery](https://www.meteor.com/livequery)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.meteor.com/livequery](https://www.meteor.com/livequery)'
- en: '[https://www.meteor.com/ddp](https://www.meteor.com/ddp)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.meteor.com/ddp](https://www.meteor.com/ddp)'
- en: '[https://docs.meteor.com/#/full/publishandsubscribe](https://docs.meteor.com/#/full/publishandsubscribe)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.meteor.com/#/full/publishandsubscribe](https://docs.meteor.com/#/full/publishandsubscribe)'
- en: '[https://docs.meteor.com/#/full/collections](https://docs.meteor.com/#/full/collections)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Meteor的集合，可以参考[https://docs.meteor.com/#/full/collections](https://docs.meteor.com/#/full/collections)。
- en: You can find this chapter's code examples at [https://www.packtpub.com/books/content/support/17713](https://www.packtpub.com/books/content/support/17713)
    or on GitHub at [https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter4](https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter4).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节代码示例的[https://www.packtpub.com/books/content/support/17713](https://www.packtpub.com/books/content/support/17713)找到，或者在GitHub上找到[https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter4](https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter4)。
- en: In the next chapter, we will give our app what makes a real app—different pages
    and routes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节，我们将给我们的应用添加一个真正应用的元素——不同的页面和路由。
