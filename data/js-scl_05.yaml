- en: Chapter 5. Addressability and Navigation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。可寻址性与导航
- en: Applications that live on the web rely on **addressable** resources. The URI
    is an essential internet technology. It eliminates a whole class of complexity,
    because we can encode bits of information about resources into URI strings. That's
    the *policy* part. The *mechanism* part is up to the browser, or our JavaScript
    code—looking up the requested resource and displaying it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在网络上的应用程序依赖于**可寻址**资源。URI是至关重要的互联网技术，它消除了一类复杂性，因为我们可以把关于资源的信息编码到URI字符串中。这是*策略*部分。*机制*部分则由浏览器或我们的JavaScript代码来完成——查找请求的资源并显示它。
- en: In the past, processing URIs took place in the backend. The browser's responsibility,
    when the user passed it a URI, was to send this request to the backend and display
    the response. With large-scale JavaScript applications, this responsibility has
    shifted mostly to the frontend. We have the tools to implement sophisticated routing
    in the browser, and with that, there's less reliance on backend-technologies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，处理URI是在后端进行的。当用户传递一个URI给浏览器时，浏览器的责任是将这个请求发送到后端并显示响应。随着大规模JavaScript应用程序的出现，这一责任主要转移到了前端。我们有了在浏览器中实现复杂路由的工具，有了这些工具，对后端技术的依赖就减少了。
- en: The benefits of frontend routing do come at a cost, however, once our software
    packs on features. This chapter takes a deep look into the routing scenarios that
    we're likely to encounter as our application architecture grows and matures. Most
    low-level implementation specifics of router components from frameworks, aren't
    important. We're more concerned with how well our router components adapt to scaling
    influencers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前端路由的好处确实是有代价的，一旦我们的软件增加了功能。本章深入探讨了在我们应用程序架构成长和成熟过程中可能遇到的路由场景。大多数路由器组件的底层实现细节并不重要。我们更关心的是我们的路由器组件如何适应规模影响因素。
- en: Approaches to routing
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由方法
- en: There are two approaches to routing in JavaScript. The first is using hash-based
    URIs. These are the URIs that begin with the `#` character and this is the more
    popular approach. The other less popular approach is to use the history API of
    the browser to generate more traditional URIs the web population is used to. This
    technique is more involved, and has only recently gained enough browser support
    to make it viable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有两种路由方法。第一种是使用基于哈希的URI。这些URI以`#`字符开头，这是更受欢迎的方法。另一种不太受欢迎的方法是使用浏览器的history
    API生成更传统的URI，网民们已经习惯了这种URI。这种技术更加复杂，直到最近才获得足够的浏览器支持，使其变得可行。
- en: Hash URIs
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希URI
- en: The hash portion of the URI was originally intended to point to a specific location
    in the document. So the browser would look at everything to the *left* of the
    `#` character, and send this information to the backend, asking for some page
    content. Only when the page arrived and was rendered did the *right* side of the
    `#` character become relevant. This is when the browser used the hash portion
    of the URI to find the locally relevant spot within the page.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: URI中哈希部分最初的意图是指向文档的特定位置。所以浏览器会查看`#`字符左侧的所有信息，并将这些信息发送到后端，请求一些页面内容。只有在页面到达并渲染后，`#`字符右侧才变得相关。这时，浏览器使用URI的哈希部分在页面上找到本地相关位置。
- en: Today, the hash portion of the URI is used differently. It's still used to avoid
    passing irrelevant data to the backend when the URI changes. The main difference
    is that today we're dealing with applications and features instead of web sites
    and static content. Since most of the application is already loaded into the browser
    when the address changes, it doesn't make sense to send unnecessary requests to
    backend. We only want the data that we need for the new URI, and that's usually
    accomplished with an API request in the background.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，URI中的哈希部分被用于不同的场景。它依旧用于URI变更时避免向后端传递无关数据。主要区别在于，现今我们处理的是应用程序和功能，而非网站和静态内容。由于在地址变更时大部分应用程序已经加载到浏览器中，向后端发送不必要的请求是没有意义的。我们只想要对新URI必要的数据，这通常通过后台的API请求来实现。
- en: When we talk about using the hash approach to URIs in JavaScript applications
    and changing the URI, it's usually only the hash portion that changes. This means
    that the relevant browser events will fire, notifying our code that the URI changed.
    But it won't automatically issue a request to the backend for new page content,
    and this is key. We can actually get a lot of performance and efficiency gains
    out of frontend routing like this, and that's one of the reasons we use this approach.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论在JavaScript应用程序中使用哈希方法来改变URI时，通常只是哈希部分发生变化。这意味着相关浏览器事件将会触发，通知我们的代码URI已经改变。但它不会自动向后端发出请求以获取新页面内容，这是关键。我们实际上可以通过这种方式的前端路由获得很多性能和效率上的提升，这也是我们使用这种方法的原因之一。
- en: Not only does it work well, but it's easy to implement. There's not a lot of
    moving parts in implementing a hash change event listener that executes logic
    to fetch the relevant data, and then updates the page with the relevant content.
    Further, the browser history changes are automatically handled for us.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅效果良好，而且实施起来也很简单。实现一个哈希变更事件监听器，以执行逻辑来获取相关数据，然后用相关内容更新页面，并没有很多复杂的部件。此外，浏览器历史的变更我们自己也会自动处理。
- en: Traditional URIs
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统的URI
- en: For some users and developers, the hash approach just feels like a hack. Not
    to mention the SEO challenges presented in a public internet setting. They prefer
    the look and feel of the more traditional slash-separated resource name format.
    That's generally possible to achieve now in all modern browsers, thanks to enhancements
    to the history API. Essentially, the routing mechanism can listen for states being
    pushed onto the history stack, and when that happens, it prevents the request
    from being sent to the backend, and instead processes it locally.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些用户和开发者来说，哈希方法看起来就像是黑客技术。更不用说在公共互联网环境中呈现的SEO挑战了。他们更喜欢更传统的用斜杠分隔的资源名格式的外观和感觉。现在在所有现代浏览器中，由于对历史API的增强，这通常是可能实现的。本质上，路由机制可以监听历史堆栈上推入的状态，当发生这种情况时，它防止请求发送到后端，而是本地处理它。
- en: There's obviously more code required for this approach to work, and more edge
    cases to think about. For example, the backend needs to support all the URIs that
    the frontend router does, because the user can feed any valid URI into the application.
    One technique to deal with this is a rewrite rule on the server that redirects
    404 errors back to the application index page, where our real route processing
    lives.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法需要更多的代码才能工作，也需要考虑更多的边缘情况。例如，后端需要支持前端路由器所支持的所有URI，因为用户可以将任何有效的URI输入到应用程序中。处理这种情况的一种技术是在服务器上使用重写规则，将404错误重定向回应用程序的索引页面，我们的真实路由处理就位于那里。
- en: That said, the router components found in most JavaScript application frameworks
    abstract the differences in approach and provide a means to seamlessly go in one
    direction or another. Does it matter which one is used, either for enhanced functionality
    or improved scalability? Not really. But in terms of scalability, it's important
    to acknowledge that there are in fact two main approaches, and that we don't want
    to commit ourselves entirely to one over the other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 话说回来，大多数JavaScript应用框架中找到的路由组件抽象了方法上的差异，并提供了一种无缝地朝一个方向或另一个方向过渡的手段。是使用哪一个更重要，是为了增强功能还是提高可扩展性？实际上并不重要。但在可扩展性方面，重要的是要认识到实际上有两种主要方法，我们不想完全承诺于其中之一。
- en: How routers work
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器是如何工作的
- en: Now it's time for us to dig a little deeper into routers. We want to know the
    responsibilities of a router, and what it's lifecycle looks like when the URI
    changes. Essentially, this amounts to the router taking the new URI and figuring
    out if it's something the router is interested in. If it is, then it triggers
    the appropriate route events with the parsed URI data as arguments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们深入研究路由器的时候了。我们想了解路由器的职责以及当URI发生变化时它的生命周期是什么样的。本质上，这相当于路由器取新的URI并判断它是否是路由器感兴趣的东西。如果是，那么它就会用解析后的URI数据作为参数触发适当的路线事件。
- en: Understanding the role of routers at a low-level is important for scaling our
    application because the more URIs we have, and the more components we have responding
    to these route events, the more potential for scaling issues. When we know what's
    happening with the router lifecycle, we can make the appropriate scaling trade-offs
    in response to scaling influencers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理解路由器在底层的角色对于扩展我们的应用程序很重要，因为我们有越多的URI和响应这些路由事件的组件，就有越多的扩展问题潜力。当我们知道路由器生命周期正在发生什么时，我们可以针对扩展影响因素做出适当的扩展权衡。
- en: Router responsibilities
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器职责
- en: 'A simplistic view of a router is just a map—there''s routes, string or regular
    expression pattern definitions, which map to callback functions. What''s important
    is that this process is fast, predictable, and stable. This is challenging to
    get right, especially as the number of URIs in our application grow. Here''s a
    rough approximation of what any router component needs to handle:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器的简化观点只是一个映射—有路由，字符串或正则表达式模式定义，它们映射到回调函数。重要的是这个过程快速、可预测且稳定。尤其是在我们应用程序中的URI数量增长时，正确实现这一过程具有挑战性。以下是任何路由组件需要处理的任何路由的大致概述：
- en: Storing a mapping of route patterns to their corresponding event names
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储路由模式与其相应事件名称的映射
- en: Listening to URI change events—*hash change* or *pop state*
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听URI变化事件—*哈希变化*或*弹出状态*
- en: Performing the route pattern lookup, comparing the new URI to each mapped pattern
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行路由模式查找，将新的URI与每个映射的模式进行比较
- en: When a match is found, to parse the new URI according to the pattern
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当找到匹配项时，根据模式解析新的URI
- en: Triggering the mapped route event, passing any parsed data
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发映射的路由事件，传递任何解析的数据
- en: Note
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The route lookup process involves a linear search through the route map to find
    a match. This can mean significant performance degradation when there's lots of
    routes defined. When the route mapping is an array of objects, it can also lead
    to inconsistent router performance. For example, if a route is at the end of the
    array, it means it's checked last and performs slowly. If it's at the beginning
    of the array, it performs better.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由查找过程涉及在路由映射中进行线性搜索以找到匹配项。当定义了大量的路由时，这意味着性能显著下降。当路由映射是一个对象数组时，它也可能导致路由性能不一致。例如，如果一个路由位于数组的末尾，这意味着它最后被检查并且执行缓慢。如果它位于数组的开头，执行效果会更好。
- en: To avoid performance degradation in frequently accessed URIs, we could extend
    the router so that it sorts the route map array by a priority property. Another
    approach would involve using a **trie** structure, to avoid linear lookups. Of
    course, only consider optimizations like these if there are so many routes that
    the router performance is measurably poor.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了避免频繁访问的URI的性能下降，我们可以扩展路由器，使其根据优先级属性对路由映射数组进行排序。另一种方法涉及使用**字典**结构，以避免线性查找。当然，只有当路由器性能如此差，以至于可以测量出性能下降时，才考虑这样的优化。
- en: The router has a lot to do when the URI changes, which is why it's important
    to understand the lifecycle of a given route, from the time the URI changes in
    the address bar, to the completion of all it's event handler functions. From a
    performance perspective, lots of routes can negatively impact our application.
    From a composition perspective, it's challenging to keep track of what components
    create and react to which routes. This is a little easier to handle when we know
    what the lifecycle of any given route looks like.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当URI发生变化时，路由器要做很多事情，这就是理解给定路由的生命周期很重要的原因，从地址栏中URI发生变化开始，到完成所有的事件处理函数。从性能角度来看，大量的路由可能会对我们的应用程序产生负面影响。从组成角度来看，跟踪哪些组件创建和响应哪些路由是具有挑战性的。当我们知道任何给定路由的生命周期看起来是什么样的时，处理起来会稍微容易一些。
- en: Router events
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器事件
- en: Once the router has found a match for the changed URI, and once it has parsed
    the URI according to its matching pattern, its final job is to trigger the route
    event. The event that's triggered is supplied as part of the mapping. The URI
    may encode variables, and these get parsed and passed to each router event handler
    as data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦路由器为改变后的URI找到了匹配项，并且一旦根据其匹配模式解析了URI，它的最后工作就是触发路由事件。触发的事件是映射的一部分。URI可能编码了变量，这些变量被解析并通过每个路由事件处理程序传递数据。
- en: '![Router events](img/4639_05_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![路由器事件](img/4639_05_01.jpg)'
- en: Route events provide an abstraction layer, which means that components that
    aren't routers can trigger route events
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 路由事件提供了一个抽象层，这意味着非路由器组件可以触发路由事件
- en: Most frameworks ship with router components that can directly call a function
    in response to a route change, instead of triggering a route event. This is actually
    easier, and is a more direct approach that makes sense with smaller applications.
    The indirection we get by triggering events from the router through the event
    triggering mechanism is that our components are loosely coupled to the router.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数框架附带可以直接在路由变化时调用函数的路由组件，而不是触发一个路由事件。实际上，这更简单，是一种更直接的方法，适合小型应用程序。通过路由器触发事件机制间接获得的间接性是我们组件与路由器之间松耦合的原因。
- en: This is beneficial because different components that have no knowledge of one
    another can listen to the same route event. As we scale, the same routes that
    have been in place for a while will need to take on new responsibilities, and
    it's easier to add new handlers than it is to keep building upon the same function
    code. There's also the abstraction benefit—the components that listen to route
    events don't care that the event is actually triggered by a router instance. This
    is useful when we need a component to trigger router-like behavior, without actually
    having to depend on the router.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有益的，因为不同组件之间如果没有相互了解，它们可以监听同一个路由事件。随着我们扩大规模，之前已经设立的同一路由将需要承担新的责任，而添加新处理程序比不断构建相同的函数代码要容易。还有抽象的好处——监听路由事件的组件不知道事件实际上是由路由实例触发的。当需要组件触发类似路由的行为，而不实际依赖路由时，这个特性很有用。
- en: URI parts and patterns
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uri 部分和模式
- en: With large scale JavaScript applications, a lot of thought goes into the router
    component. We also need to put a lot of thought into the URIs themselves. What
    are they composed of? Are they consistent throughout the application? What makes
    a bad URI? Veering in the wrong direction on any of these considerations makes
    scaling the addressability of our application difficult.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型 JavaScript 应用程序中，路由组件需要经过深思熟虑。我们还需要对 URI 本身进行深思熟虑。它们由什么组成？在整个应用程序中它们是否一致？什么是一个糟糕的
    URI？在这些考虑上走向错误的方向会使我们难以扩展应用程序的可寻址性。
- en: Encoding information
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码信息
- en: The point of a URI is that a client can just pass it to our application, and
    it contains enough information that something useful can be done with it. The
    simplest URI just points to a resource type, or a static location within an app—`/users`
    or `/home` are respective examples of these types of URIs. Using this information,
    our router can trigger a route event, and a callback function is triggered. These
    callbacks wouldn't even require any arguments—they just know what to do because
    there's no variability.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: URI 的作用在于，客户端可以将它传递给我们的应用程序，并且它包含了足够的信息，可以据此进行有用的操作。最简单的 URI 只是指向一种资源类型，或者是一个应用内的静态位置——`/users`
    或 `/home` 是这类 URI 的 respective 例子。利用这些信息，我们的路由器可以触发一个路由事件，并触发一个回调函数。这些回调甚至不需要任何参数——它们知道要做什么，因为不存在变异性。
- en: On the other hand, router callback functions may need a bit of context. This
    is when encoding information within a URI becomes important. The most common use
    for this is when the client asks for a specific instance of some resource, using
    a unique identifier. For example, `users/31729`. Here, the router will need to
    find a pattern that matches this string, and the pattern will also specify how
    to extract the `31729` variable. This is then passed to the callback function,
    which now has enough context information to perform it's task.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，路由回调函数可能需要一些上下文。这时在 URI 中编码信息就变得很重要。最常见的用途是当客户端要求某个资源的具体实例时，使用唯一标识符。例如，`users/31729`。在这里，路由需要找到与这个字符串匹配的模式，并且该模式还将指定如何提取
    `31729` 变量。然后将其传递给回调函数，现在回调函数有足够的信息来执行其任务。
- en: URIs can grow large and complex if we try to encode lots of information in them.
    An example of this would be encoding query parameters for a page that displays
    a grid of resources. Trying to specify all the possibilities in the route pattern
    is difficult and error-prone. There are bound to be changes, and unanticipated
    edge-cases concerning the combinations used with the variables. Some will likely
    be optional.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: URI 可能会变得很大且复杂，如果我们试图在它们中编码很多信息。这个例子就是编码显示资源网格的页面的查询参数。尝试在路由模式中指定所有可能性是困难且容易出错的。肯定会有变化，以及关于变量组合使用的不预期的边缘情况。其中一些可能是可选的。
- en: When a given URI has this much potential for complexity, it's best to keep the
    encoding options out of the URI pattern that's passed to the router. Instead,
    have the callback function look at the URI and perform further parsing to figure
    out the context. That keeps the route specifications neat and tidy, and the odd
    complex handler isolated from everything else.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个给定的URI有如此多的潜在复杂性时，最好将编码选项保持在传递给路由器的URI模式之外。相反，让回调函数查看URI并进一步解析以确定上下文。这样可以保持路由规格整洁，将奇异的复杂处理程序与其他一切隔离。
- en: For common queries, we may want to provide a simple URI for our users, especially
    if it's presented as a link. For example, recent posts would link to `/posts/recent`.
    The handler for this URI has a few things that it needs to figure out that would
    otherwise need to be encoded in the URI—such as ordering and the number of resources
    to fetch. Sometimes these things don't need to be included in the URI, and decisions
    like these can benefit both the user experience and the scalability of our code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见的查询，我们可能希望为用户提供一个简单的URI，尤其是如果它以链接的形式呈现。例如，最近的帖子链接到`/posts/recent`。这个URI的处理程序需要确定一些事情，否则这些事情需要编码在URI中——比如排序和要获取的资源数量。有时这些事情不需要包含在URI中，而这些决策对用户体验和代码的可扩展性都有好处。
- en: Designing URIs
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计URI
- en: Resource names are a good inspiration for the URIs we create. If the URI links
    to a page that displays events, it should probably start with `events`. Sometimes,
    however, the resources exposed by the backend have anything but intuitive names.
    Or, as an organization or an industry, we like to abbreviate certain terms. These
    should be avoided as well, except in the case where the context of the application
    provides meaning.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 资源名是我们创建URI的好灵感。如果URI链接到一个显示事件的页面，它可能应该以`events`开始。然而，有时后端暴露的资源名并不直观。或者，作为一个组织或行业，我们喜欢缩写某些术语。这些也应该避免，除非应用程序的上下文提供了意义。
- en: The inverse is true as well—adding too much meaning in the URI can actually
    cause confusion, if it's too verbose. This can be too verbose from the individual
    word point of view, or from the number of URI components point of view. To help
    convey structure and make it easier for human eyes to parse, URIs are usually
    broken down into parts. For example, the type of thing, followed by the identifier
    of the thing. It's not really helpful to the user to encode categorical or other
    tangential information in the URI—it can certainly be displayed in the UI though.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来说也是正确的——URI中包含太多意义实际上可能会导致混淆，如果它太冗长。这可以从这个单词的角度看过于冗长，或者从URI组件的数量的角度看过于冗长。为了帮助传达结构，并使人类眼睛更容易解析，通常会将URI分解为部分。例如，事物类型，后面是事物标识符。实际上，对于用户来说，将分类或其他辅助信息编码在URI中并不真正有帮助——尽管它当然可以在UI中显示。
- en: Where we can, we should be consistent. If we're limiting the number of characters
    for a resource name, they should all follow the same limit. If we're using slashes
    to separate URI parts, it should be done the same everywhere. The whole idea behind
    this is that it scales nicely for our users when there are a lot of URIs, as they
    can eventually guess what a URI for something is, without having to click on a
    link.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够做到的地方，我们应该保持一致。如果我们限制资源名的字符数，它们都应该遵循相同的限制。如果我们使用斜杠来分隔URI部分，到处都应该这样做。这个想法的整个出发点是，当有很多URI时，它能够很好地扩展，因为用户最终可以猜测出某个东西的URI，而不必点击链接。
- en: While being consistent, we sometimes want certain types of URIs to stand out.
    For example, when we visit a page that puts a resource in a different state, or
    requires input from the user, we should prefix the action with a different symbol.
    Let's say we're editing a task—the URI might be `/tasks/131:edit`. We're being
    consistent everywhere in our application, separating our URI components with slashes.
    So we could have done something like `/tasks/131/edit`. However, this makes it
    seem as though it's a different resource when really, it's the same resource as
    `tasks/131`. Only now, the UI controls are in a different state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持一致性的同时，我们有时希望某些类型的URI能够突出显示。例如，当我们访问一个将资源置于不同状态的页面，或需要用户输入的页面时，我们应该用不同的符号前缀动作。假设我们正在编辑一个任务——URI可能是`/tasks/131:edit`。在我们应用程序的各个地方保持一致性，用斜杠分隔URI组件。所以我们本可以做成类似`/tasks/131/edit`。然而，这会让它看起来像一个不同的资源，而实际上，它和`tasks/131`是同一个资源。只是现在，UI控件处于不同的状态。
- en: 'Following is an example that shows some regular expressions used to test routes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示用于测试路由的正则表达式的例子：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Mapping resources to URIs
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将资源映射到URI
- en: It's time to look at URIs in action. The most common form we'll find URIs in,
    are as links inside our application. At least, that's the idea; to have an application
    that's well connected. While the router understands what to do with URIs, we are
    yet to look at all the places where these links need to be generated and inserted
    into the DOM.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看URI在实际应用中的样子了。我们最常发现URI的形式，就是在我们应用程序中的链接。至少，这是理念所在——拥有一个良好互联的应用程序。虽然路由器理解如何处理URI，但我们还需要查看所有这些链接需要生成并插入DOM中的地方。
- en: There are two approaches to generate links. The first is a somewhat manual process
    that requires the help of template engines and utility functions. The second takes
    a more automated approach in an attempt to scale the manageability of many URIs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 生成链接有两种方法。第一种是一种相对手动的过程，需要模板引擎和实用函数的帮助。第二种尝试自动化，以扩展许多URI的可管理性。
- en: Building URIs manually
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动构建URI
- en: If a component renders content in the DOM, it potentially builds URI strings
    and adds them to link elements. This is easy enough to do when there's only a
    handful of pages and URIs. The scaling issue here is that the page count and URI
    count found in JavaScript applications are complimentary—lots of URIs means lots
    of pages and vice-versa.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件在DOM中渲染内容，它可能会构建URI字符串并将它们添加到链接元素中。当只有少数页面和URI时，这样做是足够简单的。这里的扩展问题在于，JavaScript应用程序中的页面计数和URI计数是互补的——大量的URI意味着大量的页面，反之亦然。
- en: We can use the router pattern mapping configuration, the structure that specifies
    what URIs look like and what happens when they're activated, as a reference when
    implementing our views. With the help of a template engine, which most frameworks
    use in one form or another, we can use the template features to dynamically render
    links as required. Or, lacking template sophistication, we'll need a standalone
    utility that can generate these URI strings for us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用路由模式映射配置，该结构指定URI的外观以及它们被激活时会发生什么，作为实现视图时的参考。借助大多数框架以一种形式或另一种形式使用的模板引擎，我们可以使用模板特性来动态渲染所需的链接。或者，如果缺乏模板复杂性，我们需要一个独立的实用程序来为我们生成这些URI字符串。
- en: This gets to be challenging when there are a lot of URIs to link, and a lot
    of templates. We have at least some help from the template syntax, which makes
    building these links a little less painful. But it's still time consuming and
    error-prone. Additionally, we'll start to see duplicative template content, thanks
    to the static nature of how we build links in the templates. We need to hard-code,
    at the very least, the type of resource we're linking to.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当有很多URI需要链接，有很多模板时，这变得具有挑战性。模板语法为我们提供了一些帮助，使得构建这些链接稍微不那么痛苦。但这仍然耗时且容易出错。此外，我们将开始看到模板内容的重复，感谢我们在模板中构建链接的静态性质。我们至少需要硬编码，在模板中链接到的资源类型。
- en: Automating resource URIs
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化资源URI
- en: The vast majority of the resources we link to are actual resources from the
    API, and are represented by a model or collection in our code. That being the
    case, it would be nice if instead of leveraging template tools to build URIs for
    these resources, we could use the same function on every model or collection to
    build the URI. That way, any duplication in our templates associated with building
    URIs goes away because we only care about the abstract `uri()` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链接的大部分资源都是来自API的实际资源，并在我们的代码中由模型或集合表示。既然如此，如果我们不是利用模板工具为这些资源构建URI，而是可以在每个模型或集合上使用相同的函数来构建URI，那会很好。这样，因为我们只关心抽象的`uri()`函数，所以与构建URI相关的模板中的任何重复都会消失。
- en: This approach, while simplifying the templates, introduces a challenge with
    synchronizing the model with the router. For example, the URI string that's generated
    by the model needs to match the pattern that the router is expecting to see. So
    either, the implementer needs to be disciplined enough to keep the URI generation
    of the model in sync with the router, or the model somehow needs to base how it
    generates the URI string on the pattern.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然简化了模板，但引入了与路由器同步模型的挑战。例如，模型生成的URI字符串需要与路由器期望看到的模式匹配。所以要么，实现者需要足够自律，以保持模型生成的URI与路由器同步，要么模型需要基于模式来生成URI字符串。
- en: If the router uses some kind of simplified regular expression syntax for building
    URI patterns, it's possible to keep the `uri()` function implemented by the model
    automatically synced by the route definition. The challenge there is that the
    model needs to know about the router—which can present a dependency scaling issue—we
    sometimes want models and not necessarily the router. What if our model stored
    the URI pattern that gets registered with the router? Then it could use this pattern
    to generate URI strings, and it's still only ever changed in one place. Another
    component would then register the pattern with the router, so there's no tight
    coupling with the model.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由器使用某种简化的正则表达式语法来构建URI模式，那么可以通过路由定义自动同步模型中实现的`uri()`函数。那里的挑战是模型需要了解路由器——这可能会导致依赖性规模问题——我们有时希望使用模型，而不一定是路由器。如果我们的模型存储了与路由器注册的URI模式呢？然后它可以使用这个模式来生成URI字符串，而且它仍然只在一个地方更改。另一个组件然后将模式注册到路由器，所以没有与模型的紧密耦合。
- en: 'Following is an example that shows how the URI strings can be encapsulated
    in models, away from other components:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了如何将URI字符串封装在模型中，远离其他组件：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Triggering routes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发路由
- en: The most common route trigger is in the form of a user clicking a link within
    our application. As discussed in the preceding section, we need to equip our link
    generating mechanism to handle many pages, and many URIs. Another dimension of
    this scaling influencer is the actual triggering actions themselves. For instance,
    with smaller applications, there are obviously fewer links. So this also translates
    to fewer click events from the user—more navigation choices means higher event
    triggering frequency.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的路由触发形式是用户在我们的应用程序中点击一个链接。如前一部分所述，我们需要让我们的链接生成机制能够处理许多页面和许多URI。这种规模影响因素的另一个维度是实际的触发动作本身。例如，对于较小的应用程序，显然链接会较少。这也意味着用户点击事件较少——更多的导航选择意味着更高的事件触发频率。
- en: It's also important to consider the lesser known navigation actors. These include
    redirecting the user in response to some backend task completing, or just a straight-up
    work-around, to get from point A to point B.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑较少为人所知的导航参与者也很重要。这些包括在某些后端任务完成后重定向用户，或者只是一个直接的绕道，从点A到点B。
- en: User actions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户操作
- en: When the user clicks a link in our application, the browser picks this up and
    changes the URI. This includes the entry point into our application—maybe from
    another web site or from a bookmark. This is what makes links and URIs so flexible,
    they can come from anywhere and point to anything. It makes sense to utilize links
    where we can because it means that our application is well connected, and processing
    a URI change is something our router excels at and can handle with ease.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在我们的应用程序中点击一个链接时，浏览器会捕捉到这一动作并更改URI。这包括进入我们应用程序的入口点——可能来自另一个网站或书签。正是这种灵活性使得链接和URI能够来自任何地方并指向任何事物。在我们能够利用链接的地方是有意义的，因为这意味着我们的应用程序连接良好，而处理URI更改是路由器擅长并且能够轻松处理的事情。
- en: But there're other ways to trigger URI changes and the subsequent router workflow.
    For example, let's say we're on a `create` event form. We submit the form, and
    the response comes back successful—do we want to leave the user at the `create`
    event page? Or do we want to take them to the page that shows the list of events,
    so they can see the event they just added? In the latter case, manually changing
    the URI makes sense and is very easy to implement.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是还有其他触发URI更改和随后路由工作流程的方法。例如，假设我们正在一个`create`事件表单上。我们提交表单，响应回来后成功——我们想让用户留在`create`事件页面吗？还是想带他们到显示事件列表的页面，这样他们就可以看到他们刚刚添加的事件？在后一种情况下，手动更改URI是有意义的，而且实现起来非常简单。
- en: '![User actions](img/4639_05_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![用户操作](img/4639_05_02.jpg)'
- en: The different ways our application can change the address bar
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可以改变地址栏的不同方式
- en: Redirecting users
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向用户
- en: Redirecting users to a new route as the result of a successful API response
    is a good example of manually triggering the router. There are several other scenarios
    where we would want to redirect the user from where they currently are to a new
    page that coincides with the activity they're performing, or to make sure they're
    simply observing the correct information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在API响应成功后重定向用户到一个新的路由是手动触发路由的一个好例子。还有其他几个场景，我们希望能够将用户从他们当前的位置重定向到一个与他们正在执行的活动相符的新页面，或者确保他们只是在观察正确的信息。
- en: Not all heavy processing need happen in the backend—we could be faced with a
    local JavaScript component that runs a process, and upon completion, we want to
    take the user to another page within our app.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的重处理都需要在后端进行——我们可能会面临一个本地的JavaScript组件运行一个进程，完成后，我们想将用户带到我们应用中的另一个页面。
- en: The key idea here is that the effect is more important than the cause—we don't
    care so much about what causes the URI change. What really matters is the ability
    to use the router in unforeseen ways. As our application scales, we'll be faced
    with scenarios where the way out is usually by a quick and simple router hack.
    Having total control over the navigation of our application gives us much more
    control over the way our application scales.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键思想是效果比原因更重要——我们并不太关心是什么原因导致了URI的变化。真正重要的是能够以意想不到的方式使用路由器。随着我们的应用程序扩展，我们通常会面临通过快速简单的路由器黑客手段来解决问题的场景。能够完全控制我们应用程序的导航，让我们对应用程序的扩展方式有了更多的控制权。
- en: Router configuration
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Router配置
- en: The mapping of our routes to their events is often lager than the router implementation
    itself. That's because as our application grows and acquires more route patterns,
    the list of possibilities gets bigger. A lot of the time, this is an unavoidable
    consequence of an application that's meeting its scaling demands. The trick is
    to not let a large number of route declarations collapse under their own weight,
    and this can happen in a number of ways.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由与它们的事件映射通常比路由实现本身要大。这是因为随着我们的应用程序增长并拥有更多的路由模式，可能性列表会变得更大。很多时候，这是应用程序满足其扩展需求不可避免的后果。关键是不要让大量的路由声明因自身重量而崩溃，而这可以通过多种方式发生。
- en: There's more than one approach to configuring the routes that a given router
    instance responds to. Depending on the framework we're using, the router component
    may have more flexibility in how they're configured than others. Generally speaking,
    there's the static route approach, or the event registration approach. We'll also
    want to consider the router's ability to disable a given route at any given time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 配置给定路由器实例响应的路线有不止一种方法。根据我们使用的框架，路由器组件在配置上可能比其他组件有更多的灵活性。一般来说，有静态路由方法，或者事件注册方法。我们还想要考虑路由器随时禁用给定路线的能力。
- en: Static route declarations
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态路由声明
- en: Simple applications usually configure their routers with a static declaration.
    This usually means a mapping of route patterns to callback functions, all at router
    creation time. What's nice about this approach is the relative locality of all
    the route patterns. At a glance, we can see what's happening with our route configuration,
    and we don't have to go hunting for specific route. However, this doesn't work
    is when there are lots of routes because we have to search for them. Also, there's
    no separation of concerns, and this doesn't play well with developers trying to
    do their thing independently of each other.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的应用程序通常使用静态声明配置它们的路由器。这意味着在路由创建时，将路由模式映射到回调函数。这种方法的好处是所有路由模式的相对局部性。一眼就能看出我们的路由配置情况，我们不需要去寻找特定的路由。然而，当有大量路由时，这种方法行不通，因为我们必须去搜索它们。此外，这种方法没有关注点的分离，这不利于开发者独立于彼此尝试做他们的事情。
- en: Registration events
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册事件
- en: When there are a lot of routes to define, the focus should be on encapsulated
    routes—which components need these routes, and how do they tell the router about
    them? Well, most routers will allow us to simply call a method that lets us add
    a new route configuration. Then we just need to include the router and add the
    routes from the component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当有大量路由需要定义时，应该关注封装的路由——哪些组件需要这些路由，它们是如何告诉路由器的？嗯，大多数路由器会允许我们调用一个让我们添加新路由配置的方法。然后我们只需要包含路由器并从组件中添加路由。
- en: This is definitely a step in the right direction; it allows us to keep the route
    declarations in the components that need them, rather than kludging together an
    entire applications' worth of route configurations into a single object. However,
    we can take this scalability a step further.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是正确的方向；它允许我们将路由声明保留在需要它们的组件中，而不是将整个应用程序的路由配置组合成一个对象。然而，我们可以进一步扩展这种可扩展性。
- en: Rather than having our components directly depend on a router instance, why
    not trigger an add route event? This will get picked up by any router that's listening
    for the event. Perhaps our application is using multiple router instances, each
    of which have their own specializations—logging, say—and they can all listen for
    added routes based on specific criteria. The point is, our components shouldn't
    have to care about the router instance, only that something is going to trigger
    route events when a given pattern matches against a URI change.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与其让我们的组件直接依赖路由实例，不如触发一个添加路由事件？这将被任何监听该事件的 router 所接收。也许我们的应用程序正在使用多个 router
    实例，每个实例都有自己的专业化功能——比如日志记录——它们都可以基于特定条件监听添加的路由。关键是，我们的组件不应该关心路由实例，只需要知道当某个模式与 URI
    变化匹配时，会触发路由事件。
- en: '![Registration events](img/4639_05_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![注册事件](img/4639_05_03.jpg)'
- en: How to keep components isolated from routers by using events
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如何通过使用事件使组件与路由器隔离
- en: Deactivating routes
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用路由
- en: After we've configured a given route, do we assume that it'll always be a viable
    route throughout the duration of the session? Or, should the router have some
    means to deactivate a given route? It depends on how we look at specific cases
    from a responsibility perspective.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置好一个给定的路由之后，我们是否假设它在会话期间始终是一个有效的路由？或者，路由器是否应该有一种方法来禁用一个给定的路由？这取决于我们从责任角度如何看待具体案例。
- en: For example, if something has happened, and some route should no longer be accessible—trying
    it just results in a user-friendly error—the route handler function can check
    whether the route is accessible or not. However, this adds complexity to the callback
    functions themselves, and this complexity will be sprinkled throughout the application
    in callbacks, rather than being self-contained in one place.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果发生了某些事情，且某个路径不再可访问——尝试它只会得到一个用户友好的错误——路由处理函数可以检查该路径是否可访问。然而，这增加了回调函数本身的复杂性，这种复杂性将散布在应用程序的回调中，而不是集中在某一个地方。
- en: An alternative approach would be to have some sanity-checking component that
    deactivates routes when components enter states that warrant doing so. This same
    component would also enable routes when the state changes into something the route
    can handle.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是有一个检查组件，当组件进入需要这样做的状态时，该组件会禁用路由。当状态变为路由可以处理的内容时，该组件也会启用路由。
- en: A third approach would be to add a guard function as an option when the route
    is first registered. When the route is matched, it runs through this function,
    and if it passes the guard, then it is activated normally, otherwise, it fails.
    This approach scales best because the state that's checked; is tightly coupled
    with the relevant route, and there's no need to toggle between enabled/disabled
    states for routes. Think of a guard function as part of the matching criteria
    for routes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是在路由首次注册时添加一个守卫函数作为选项。当路由匹配时，它会运行这个函数，如果守卫通过，则正常激活，否则失败。这种方法最适合扩展，因为检查的状态与相关路由紧密耦合，无需为路由启用/禁用状态。将守卫函数视为路由匹配条件的一部分。
- en: 'Following is an example that shows a router that accepts guard condition functions.
    Route events aren''t triggered if this guard function exists and returns false:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了接受守卫条件函数的路由器。如果存在这个守卫函数并且返回`false`，则不会触发路由事件：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Troubleshooting routers
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试路由器
- en: Once our routers grow to a sufficiently large size, we'll have to troubleshoot
    complex scenarios. If we know what the likely issues are beforehand, we'll be
    better equipped to deal with them. We can also build troubleshooting tools into
    our router instances to aid in the process. Scaling the addressability of our
    architecture means responding to issues quickly and predictably.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的路由器增长到足够大的规模，我们将不得不解决复杂的情况。如果我们事先知道可能出现的问题，我们将更好地应对它们。我们还可以将故障排除工具集成到我们的路由器实例中，以帮助这个过程。扩展我们架构的可寻址性意味着能够快速、可预测地响应问题。
- en: Conflicting routes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冲突的路由
- en: Conflicting routes can cause a massive headache because they can be really tricky
    to track down. A conflicting pattern is a general or similar version of more specific
    patterns added to the router later on. The more general pattern conflicts, because
    it's matched against the most specific URIs, which should have been matched by
    the more specific patterns. However, they're never tested because the general
    route is executed first.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突路由可能引起巨大的头痛，因为它们可能非常难以追踪。冲突模式是后来添加到路由器中的更具体模式的通用或类似版本。更通用的模式发生冲突，因为它与最具体的URI相匹配，这些URI应该已经被更具体模式匹配。然而，它们永远不会被测试，因为通用路由是首先执行的。
- en: When this happens, it may not be apparent at all that there's an issue with
    the routing because the incorrect route handler will run perfectly fine, and in
    the UI, everything will seem normal—except for one thing that's slightly off.
    If routes are processed in FIFO order, specificity matters. That is, if the more
    general route patterns are added first, then they'll always match against the
    more specific URI strings, as they're activated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，可能根本看不出来路由存在问题，因为错误的路由处理程序运行得非常好，在UI上，一切看起来都很正常——除非有一点不对劲。如果按FIFO顺序处理路由，特定性很重要。也就是说，如果首先添加更通用的路由模式，那么当它们被激活时，它们总是与更具体的URI字符串匹配。
- en: The challenge with ordering URIs like this when there's lots of them, is that
    it's time-consuming work. We have to compare the ordering of any new routes we
    may add to the patterns of existing routes. There's also the potential for conflicts
    between developer commitments if they're all being added to the same place. This
    is another advantage of separating routes by component. It makes potentially conflicting
    routes a lot easier to spot and deal with, because the component likely has a
    small number of similar URI patterns.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当有大量URI需要排序时，按照这种方式排序的挑战是，这是一项耗时的工作。我们必须比较新添加的路由与现有路由的模式。如果它们都被添加到同一个地方，开发人员之间的承诺也可能存在冲突。这是将路由按组件分离的另一个优点。这样做使得可能发生冲突的路由更容易被发现和处理，因为组件很可能具有少量类似的URI模式。
- en: 'Following is an example that shows a router component with two conflicting
    routes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示具有两个冲突路由的路由组件的示例：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Logging initial configuration
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录初始配置
- en: Routers shouldn't start listening to URI change events until they're configured
    with all the relevant routes. For example, if individual components configure
    the router with the routes required by that component, we wouldn't want the router
    to start listening for URI change events until the component has a chance to configure
    its routes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器应该在配置了所有相关路由之后才开始监听URI变化事件。例如，如果个别组件用对该组件必要的路由配置路由器，我们不希望路由器在组件有机会配置其路由之前就开始监听URI变化事件。
- en: The main application component that initializes its subordinate components would
    probably bootstrap this process, and when completed, tell the router to start.
    When individual components have their own routes encapsulated within, it can be
    difficult, during development, to grasp the router configuration in its entirety.
    For this, we need an option in our router that will log its entire configuration—the
    patterns, and the events they trigger. This helps us scale because we don't have
    to sacrifice modular routes to get the big picture.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化其下级组件的主要应用组件可能会引导这个过程，并在完成后告诉路由器开始工作。当个别组件有自己的路由封装在内时，在开发过程中，理解路由器的整体配置可能很困难。为此，我们需要在我们的路由器中有一个选项，用于记录其整个配置——模式及其触发的事件。这有助于我们进行扩展，因为我们不必牺牲模块化路由就能了解整体情况。
- en: Logging route events
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录路由事件
- en: In addition to logging the initial route configuration, it's helpful if the
    router can log the lifecycle that takes place when a URI change event is triggered.
    This is different from the event mechanism logging that we discussed in the preceding
    chapter—these events will log after the router triggers a route event.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了记录初始路由配置之外，如果路由器能够在触发URI变化事件的生命周期中进行日志记录也是很有帮助的。这与我们在前一章中讨论的事件机制日志不同——这些事件将在路由触发路由事件之后记录。
- en: If we're building a large-scale JavaScript architecture with lots of routes,
    we'll want to know everything about our router, and how it behaves at runtime.
    The router is so fundamental to the scalability of our application that we'll
    want to invest in the minute details here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在构建一个大规模的JavaScript架构，拥有许多路由，我们就想了解关于我们的路由器的一切，以及它在运行时是如何行为的。路由器对于我们应用的可扩展性是如此的基础，以至于我们在这里要投入对细节的关注。
- en: For example, it can be useful to get an idea of what the router is doing as
    it's walking through the available routes, looking for a match. It's also useful
    to see the result of what's parsed out of the URI string by the router, so that
    we can compare that to what's seen by the route event handlers downstream. Not
    all router components will support this level of logging. If it turns out that
    we need it, some frameworks will provide sufficient entry points into their components,
    along with good extension mechanisms.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，了解路由器在遍历可用路由、寻找匹配项时的行为可能很有用。了解路由器从URI字符串解析出来的结果也很有用，这样我们就可以将其与下游的路由事件处理程序所看到的内容进行比较。并非所有的路由组件都支持这种级别的日志记录。如果我们发现需要它，一些框架将提供足够的入口点进入它们的组件，并附有优秀的扩展机制。
- en: Handling invalid resource states
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理无效资源状态
- en: Sometimes, we forget that the router is stateless; it takes a URI string as
    input, and triggers events based on pattern-matching criteria. A scaling problem
    related to addressability isn't with the router state, but the state of components
    that listen to routes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们忘记路由是无状态的；它接受一个URI字符串作为输入，并根据模式匹配条件触发事件。与可寻址性相关的一个可扩展性问题并不在于路由器状态，而在于监听路由的组件状态。
- en: For example, imagine we navigate away from one resource to another. While we're
    visiting this new resource, a lot can happen with that first resource. Well, it's
    easy for it to change in ways that make it illegal for this particular user to
    visit, meanwhile, it's in their history and all they need to do is hit the back
    button.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象我们从一项资源导航到另一项资源。在我们访问这个新资源时，第一项资源会发生很多变化。很容易出现这样的情况：它以这样一种方式改变，使得这个特定用户无法访问，同时它还保存在用户的历史记录中，他们只需要点击后退按钮。
- en: It's edge cases like these that routers and addressability can introduce into
    our application. It's not, however, the responsibility of the router to handle
    these edge cases. They happen due to a combination of lots of URIs, lots of components,
    and complex business rules that tie them all together. The router is just a mechanism
    to help us cope with large-scale policies, not a place to implement policies.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器和可寻址性可能会将这类边缘情况引入我们的应用程序。然而，处理这些边缘情况并不是路由器的责任。这些问题是由许多URI、许多组件以及将它们全部联系在一起的复杂业务规则共同造成的。路由器只是一个帮助我们应对大规模政策的机制，而不是实施政策的场所。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter went into detail on addressability, and how to achieve this architectural
    property as our application scales.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了如何随着应用程序的扩展实现可寻址性这一架构特性。
- en: We began our discussion of routing and addressability with a look at the different
    approaches to routing—the hash change event and utilizing the history API available
    in modern browsers. Most frameworks abstract the differences away for us. Next,
    we looked at the responsibilities of routers, and how they should be decoupled
    from other components through triggering events.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从路由和可寻址性的讨论开始，首先查看了不同的路由方法——hash变化事件和利用现代浏览器中可用的历史API。大多数框架为我们抽象了这些差异。接下来，我们探讨了路由器的职责，以及它们应该如何通过触发事件与其它组件解耦。
- en: The design of URIs themselves also plays a role in the scalability of our software,
    because they need to be consistent and predictable. Even the users can use this
    predictability to help themselves scale the use of our software. URIs encode information
    which is then relayed to our handlers that respond to routes; this also needs
    to be taken into consideration.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: URI本身的设计也在我们软件的可扩展性中扮演了角色，因为它们需要保持一致和可预测。用户甚至可以利用这种可预测性来帮助他们扩展对我们软件的使用。URI编码信息，然后传递给响应路由的事件处理程序；这也需要考虑。
- en: We then looked at the various ways in which routes are triggered. The standard
    approach here is to click a link. If our application is well connected, it's going
    to have links all over the place. To help us scale lots of links, we need a way
    to generate URI strings automatically. Next, we're going to look at the metadata
    our components need in order to function. These are the user preferences and default
    values for our components.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们查看了路由被触发的各种方式。这里的标准方法是点击一个链接。如果我们的应用程序连接良好，它将到处都是链接。为了帮助我们管理众多链接，我们需要一种自动生成URI字符串的方法。接下来，我们将查看组件运行所需要的中间数据。这些包括用户偏好和我们组件的默认值。
