- en: '*Chapter 9*: Deploying a Deno Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*9*章：部署Deno应用程序
- en: Deployment is a crucial part of any application. We might build a great application,
    follow best practices, and write tests, but at the end of the day, when it gets
    to the user, this is where it will prove its value. As we want this book to be
    a journey through all the different phases of an application, we'll use this chapter
    about application deployment to close the cycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是任何应用程序的关键部分。我们可能构建了一个伟大的应用程序，遵循最佳实践，并编写测试，但最终，当它到达用户手中时，它将在这里证明其价值。由于我们希望这本书能带领读者经历应用程序的所有不同阶段，因此我们将使用关于应用程序部署的这一章节来结束整个周期。
- en: Note that we didn't—and will not—mention deployment as the final phase of software
    development, but as one phase of a cycle that will run multiple times. We truly
    believe that deployments shouldn't be events that everyone is afraid of. Rather,
    we see them as exciting moments whereby we're shipping features to our users.
    That's how most companies look at deployments in modern software projects, and
    we're true advocates of that. Deployments should be something regular, automated,
    and easy to do. They're the first step in getting features to our users, not the
    final step.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有—也不会—将部署视为软件开发的最后阶段，而是视为将多次运行的周期中的一个阶段。我们坚信部署不应该是一个让大家害怕的事件。相反，我们认为它们是我们向用户发送功能的高兴时刻。这是大多数公司在现代软件项目中看待部署的方式，我们确实是这种观点的忠实倡导者。部署应该是定期、自动化且容易执行的事情。它们是我们将功能带给用户的第一步，而不是最后一步。
- en: To enable this type of agility of processes and speed of iteration in applications,
    this chapter will focus on learning about containers and how to deploy a Deno
    application using them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使流程具有这种灵活性并在应用程序中实现快速迭代，本章将重点学习有关容器以及如何使用它们部署Deno应用程序的知识。
- en: We'll take advantage of the benefits of containerization to create an isolated
    environment to install, run, and distribute our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用容器化的好处，创建一个隔离的环境来安装、运行和分发我们的应用程序。
- en: As the chapter proceeds, we will learn how to use Docker together with `git`
    to create an automated workflow to deploy our Deno application in a cloud environment.
    Then, we'll tweak the way our application loads configurations to support having
    different configurations depending on the environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着章节的进行，我们将学习如何使用Docker和`git`创建一个自动化工作流程，以在云环境中部署我们的Deno应用程序。然后，我们将调整应用程序加载配置的方式，以支持根据环境不同而有不同的配置。
- en: By the end of this chapter, we'll have the application running in a cloud environment
    and an automated process in place that enables us to ship iterations of it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们的应用程序将在云环境中运行，并有一个自动化过程，使我们能够发送它的迭代版本。
- en: 'In this chapter, you''ll get comfortable with the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将熟悉以下主题：
- en: Preparing the environment for the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序准备环境
- en: Creating a `Dockerfile` for the Deno application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Deno应用程序创建一个`Dockerfile`
- en: Building and running the application in Heroku
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Heroku中构建和运行应用程序
- en: Configuring the application for deployment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应用程序以进行部署
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code used in this chapter can be found at the following GitHub link:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在以下GitHub链接中找到：
- en: '[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter09](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter09)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter09`'
- en: Preparing the environment for the application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序准备环境
- en: The environment where an application runs always has a big impact on it. It
    is one of the big causes of the so-common statement, *"it works on my machine"*.
    Over the years, developers have been creating solutions that try to minimize this
    as much as possible. These solutions can go from automatically provisioning new
    clean instances for the application to run, to creating more complete packages
    where everything the application depends on is included.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行的环境总是对其产生很大影响。这是导致常见说法“*在我的机器上工作*”的其中一个重要原因。多年来，开发者一直在创造尽可能减少这种影响的解决方案。这些解决方案可以从为应用程序自动提供新的干净实例，到创建更完整的包，其中包含应用程序依赖的一切。
- en: 'We can refer to **virtual machines** (**VMs**) or containers as ways to achieve
    this goal. Both are different solutions to the same problem but have one big thing
    in common: resource isolation. Both try to isolate an application from the environment
    around it. There are many reasons for this, from security, to automation, to reliability.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将**虚拟机**（**VMs**）或容器视为实现这一目标的途径。两者都是为同一问题提供的不同解决方案，但有一个很大的共同点：资源隔离。两者都试图将应用程序与周围的环境隔离。这有许多原因，从安全、自动化到可靠性。
- en: Containers are a modern way of providing a package for an application. Modern
    software projects use them to provide a single container image that has pretty
    much all it takes for an application to run.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是提供应用程序包的一种现代方式。现代软件项目使用它们来提供一个包含应用程序运行所需的大多数内容的单一容器镜像。
- en: 'If you''re not aware of what a container is, I''ll provide you with a definition
    from Docker''s (a container engine) official website:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不清楚容器是什么，我给你提供一下来自Docker（一个容器引擎）官方网站的定义：
- en: '*"A container is a standard unit of software that packages up code and all
    its dependencies so the application runs quickly and reliably from one computing
    environment to another."*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是“一种标准的软件单元，它将代码及其所有依赖打包在一起，使得应用程序能够从一个计算环境快速、可靠地运行到另一个计算环境。”
- en: In our path to make our application easily deployable, we will create this layer
    of isolation for our Deno application using Docker.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使应用程序容易部署的路径中，我们将使用Docker为我们的Deno应用程序创建这一层隔离。
- en: The end goal is to create an image that developers can use to deploy and test
    a specific version of the application. To do this with Docker, we need to configure
    the runtime where our application will run. This is defined in a file called a
    `Dockerfile`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是创建一个开发者可以用来部署和测试应用程序特定版本的镜像。要使用Docker完成这个目标，我们需要配置应用程序将运行的运行时。这个配置定义在一个叫做`Dockerfile`的文件中。
- en: That's what we'll learn about next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们接下来要学习的内容。
- en: Creating a Dockerfile for the Deno application
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Deno应用程序创建Dockerfile
- en: A `Dockerfile` will allow us to specify what is required to create a new Docker
    image. This image will provide an environment containing all dependencies of the
    application, which can be used both for development purposes and for production
    deployments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`将允许我们指定创建新Docker镜像所需的内容。这个镜像将提供包含应用程序所有依赖的环境，既可用于开发目的，也可用于生产部署。'
- en: What we'll do in this section is learn how to create a Docker image for the
    Deno application. Docker provides a base image that is pretty much just the container
    runtime with isolation, called `alpine`. We could use that image, configure it,
    install all the tools and dependencies we need (namely Deno), and so on. However,
    I believe that we shouldn't be reinventing the wheel here, thus we're using a
    community Docker image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为Deno应用程序创建Docker镜像。Docker提供了一个基本上只包含容器运行时和隔离的基镜像，叫做`alpine`。我们可以使用这个镜像，配置它，安装所有需要的工具和依赖（即Deno），等等。然而，我认为我们在这里不应该重新发明轮子，因此我们使用一个社区Docker镜像。
- en: Even though this image solves many of our problems, we still need to tweak it
    to our use case. Dockerfiles can be composed, which means they can extend other
    Docker images' functionality, and that's what we'll use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个镜像解决了许多我们的问题，我们仍然需要调整它以适应我们的用例。Dockerfile可以组合，这意味着它们可以扩展其他Docker镜像的功能，我们将使用这个特性。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As you might imagine, we'll not go deep in the fundamentals of Docker, as that
    would be a book in itself. If you're interested in Docker, you can start with
    the *Getting started* guide on the official documentation ([https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)).
    However, don't worry if you aren't currently very comfortable with Docker as we'll
    explain it enough for you to understand what we're doing here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想象的，我们不会深入讲解Docker的基础知识，因为那将是一本书的内容。如果你对Docker感兴趣，你可以从官方文档的*入门指南*开始([https://docs.docker.com/get-started/](https://docs.docker.com/get-started/))。然而，如果你目前对Docker不是非常熟悉，也不用担心，我们会解释足够让你理解我们在这里做什么的内容。
- en: 'Before we start, make sure you install Docker Desktop on your machine by following
    the steps listed in the following link: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    After you have installed and started it, we have everything it takes to create
    our first Docker image! Let''s create it by following these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保通过以下链接中列出的步骤在您的机器上安装了Docker Desktop：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。安装并启动它之后，我们就有了创建我们第一个Docker镜像所需的一切。让我们通过以下步骤来创建它：
- en: Create a `Dockerfile` at the root of our project.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录下创建一个`Dockerfile`。
- en: As mentioned, we'll use an image from the community that already has Deno installed—`hayd/deno`
    ([https://hub.docker.com/r/hayd/deno](https://hub.docker.com/r/hayd/deno)).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如提到的，我们将使用一个社区中已经安装了Deno的镜像——`hayd/deno` ([https://hub.docker.com/r/hayd/deno](https://hub.docker.com/r/hayd/deno))。
- en: 'This image is versioned in the same way as Deno, thus we''ll use version `1.7.5.`
    The `FROM` command from Docker allows us to extend an image, specifying its name
    and version tag, as illustrated in the following code snippet:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此图像的版本管理方式与Deno相同，因此我们将使用版本`1.7.5`。Docker的`FROM`命令允许我们扩展一个镜像，指定其名称和版本标签，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The next thing we need to do is to define, inside the container, the folder
    we'll be working on.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是在容器内部定义我们将工作的文件夹。
- en: 'Docker containers provide a Linux filesystem, and the default `workdir` is
    the root of it (`/`). The `WORKDIR` command from Docker will allow us to work
    from a folder inside this same filesystem, making things a little bit tidier.
    The command can be seen here:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Docker容器提供了一个Linux文件系统，默认的`workdir`是它的根（`/`）。Docker的`WORKDIR`命令将允许我们在这个文件系统内的同一个文件夹中工作，使事情变得更有条理。该命令可在此处查看：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we''ll need to copy some files into our container image. With the help
    of the `COPY` command, we''ll copy only the files we need for the installation
    step. In our case, these are the `src/deps.ts` and `lock.json` files, as illustrated
    in the following snippet:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将一些文件复制到我们的容器镜像中。在`COPY`命令的帮助下，我们将只复制安装步骤所需的文件。在我们的案例中，这些是`src/deps.ts`和`lock.json`文件，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Having the files inside the container, we now need to install the application
    dependencies. We''ll use `deno cache` to do this, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内部拥有文件后，我们现在需要安装应用程序的依赖项。我们将使用`deno cache`来完成此操作，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Dependencies installed, we now need to copy the application''s code into the
    container. One more time, we''ll use Docker''s `COPY` command for that, as shown
    here:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖项安装完成后，我们现在需要将应用程序的代码复制到容器中。再一次，我们将使用Docker的`COPY`命令来完成此操作，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last thing we''ll need to do for our image to work out of the box is introduce
    a command that will run whenever someone "executes" this image. We''ll use Docker''s
    `CMD` command to do this, as illustrated in the following snippet:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的镜像做最后一件事情，以便它能够即插即用，那就是引入一个在任何人都“执行”这个镜像时都会运行的命令。我们将使用Docker的`CMD`命令来完成此操作，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command takes an array of commands and parameters that will be executed
    when someone tries to run our image.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令接受一个命令和参数数组，当有人尝试运行我们的镜像时将被执行。
- en: And that should be all we need to define our Deno application's Docker image!
    Having these capabilities in place will enable us to run our code locally in the
    same way it runs in production, a great advantage when it comes to debugging and
    investigating production issues.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们定义我们Deno应用程序的Docker镜像所需要的一切！拥有这些功能将使我们可以像在生产环境中一样在本地上运行我们的代码，这对于调试和调查生产问题来说是一个很大的优势。
- en: The only thing we're missing is the actual step to generate the artifact.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一缺少的是生成工件的实际步骤。
- en: 'We''ll use the `build` command from the Docker `-t` flag to set the tag. Follow
    these steps to generate the artifact:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Docker `-t`标志的`build`命令来设置标签。按照以下步骤生成工件：
- en: 'Inside the project folder, run the following command to generate the tag for
    the image:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹内，运行以下命令为镜像生成标签：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: museums-api:0.0.1. We could now publish it in a private image registry or use
    a public one such as Docker Hub. The continuous integration (CI) pipeline we'll
    set up later will be configured to perform this build step automatically.What
    we can do now is run this image locally to verify that everything is working as
    expected.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: museums-api:0.0.1。我们现在可以在私有镜像仓库中发布它，或者使用公共的，比如Docker Hub。我们稍后设置的持续集成（CI）管道将配置为自动执行这个构建步骤。我们现在可以做的就是在本地下载这个镜像，以验证一切是否按预期工作。
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To run the image locally, we'll use the Docker CLI `run` command.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在本地运行镜像，我们将使用Docker CLI的`run`命令。
- en: 'As we''re dealing with a web application, we need to expose the port it is
    running on (set in the application''s `configuration` file). We''ll tell Docker
    to bind the container port to our machine''s port by using the `-p` flag, as illustrated
    in the following code snippet:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在处理一个网络应用程序，我们需要暴露它正在运行的端口（在应用程序的`configuration`文件中设置）。我们将通过使用`-p`标志告诉Docker将容器端口绑定到我们机器的端口，如下代码段所示：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll later use this image definition in a CI system that will create an image
    whenever the code changes and push it to production.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将使用这个镜像定义在CI系统中，每当代码更改时，它都会创建一个镜像并将其推送到生产环境。
- en: 'Having a Docker image containing an application can serve multiple purposes.
    One of them is this chapter''s objective: deploying it; however, this same Docker
    image can also be used to run and debug an application at a specific version.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个包含应用程序的Docker镜像可以服务于多个目的。其中之一就是本章的目标：部署它；然而，这个同样的Docker镜像也可以用来在特定版本上运行和调试一个应用程序。
- en: Let's learn how we can run a Terminal in a specific version of an application,
    a very common debug step.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在特定版本的某个应用程序中运行一个终端，这是一个非常常见的调试步骤。
- en: Running a Terminal inside a container
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器内运行终端
- en: Another useful thing we can do with a Docker image is execute a Terminal inside
    of it. This might be useful for debugging purposes or to try out something in
    a specific version of an application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Docker镜像在容器内执行一个终端。这可能在调试或尝试特定应用程序版本的某事物时很有用。
- en: We can do that by using the same command as previously, together with a couple
    of different flags.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用之前相同的命令和几个不同的标志来实现这一点。
- en: 'We''ll use the `-it` flag, which will allow us to have an interactive connection
    to a Terminal inside the image. We''ll also send, as a parameter, the name of
    the command we want to execute first inside the image. In this case it is `sh`,
    the standard Unix shell, as you can check in the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`-it`标志，这将允许我们有一个与镜像内的终端的交互式连接。我们还将发送一个参数，即我们希望在镜像内首先执行的命令的名称。在这个例子中是`sh`，标准的Unix外壳，正如你在以下示例中可以看到的：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will run the `museums-api:0.0.1` image, bind its `8080` port to the `8080`
    port on the host machine, and execute the `sh` command inside of it with an interactive
    Terminal, as illustrated in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行`museums-api:0.0.1`镜像，将其`8080`端口绑定到宿主机的`8080`端口，并在带有交互式终端的其中执行`sh`命令，如下代码段所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the folder where the shell is initially open is the one we've defined
    as our `WORKDIR` and that all our files are there. In the preceding example, we're
    also executing the `ls` command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，初始打开的目录是我们定义为`WORKDIR`的目录，我们的所有文件都在那里。在前面的例子中，我们还执行了`ls`命令。
- en: 'As we have an interactive shell attached to this container, we can use it to
    run a Deno command, for instance, as illustrated in the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个容器上附加了一个交互式外壳，我们可以用它来运行Deno命令，例如，如下代码段所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This enables a full set of possibilities in terms of development and debugging,
    as we'll have the ability to check how the application is running in a specific
    version.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们在开发和调试方面具备一整套可能性，因为我们将有能力查看应用程序在特定版本上的运行情况。
- en: We've got to the end of this section. Here, we have explored containerization,
    introducing Docker and how it enables us to create an "application package". This
    package will take care of the environment around the application, making sure
    that it will run wherever there's a Docker runtime.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这一节的讨论。在这里，我们探讨了容器化，介绍了Docker以及它是如何让我们创建一个“应用程序包”的。这个包将负责应用程序周围的环境，确保它无论在何处只要有Docker运行时就可以运行。
- en: In the next section, we'll be using this same package to deploy an image we
    built locally in a cloud environment. Let's go!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用这个相同的包，在云环境中部署我们本地构建的镜像。让我们开始吧！
- en: Building and running the application in Heroku
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Heroku中构建和运行应用程序
- en: As we mentioned when the chapter started, our initial objective was to have
    an easy, automated, and replicable way to deploy the application. In the previous
    section, we created our container image that will work as a basis for that. The
    next step is to create the pipeline that builds and deploys our code anytime there's
    an update. We'll use `git` as our source of truth and mechanism to trigger the
    pipeline builds.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在章节开始时提到的，我们的初步目标是有一种简单、自动化且可复制的部署应用程序的方法。在上一节中，我们创建了将作为该基础的容器镜像。下一步是创建一个管道，以便在有更新时构建和部署我们的代码。我们将使用`git`作为我们的真相来源和触发管道构建的机制。
- en: The platform where we'll deploy our code is Heroku. This is a platform that
    aims to simplify tasks for developers and companies in the deployment process
    by providing a set of tools that removes common obstacles, such as provisioning
    machines and setting up big CI infrastructures. By using a platform such as this,
    we can be more focused on the application and on Deno, which is the purpose of
    this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码部署的平台是Heroku。这是一个旨在通过提供一套工具简化开发人员和公司部署过程的平台，这些工具消除了诸如配置机器和设置大型CI基础架构等常见障碍。使用这样的平台，我们可以更专注于应用程序以及Deno，这是本书的目的。
- en: Here, we'll use the `Dockerfile` that we previously created and set it up so
    that it is deployed and runs on Heroku. We'll see how easy it is to set up an
    application to run there, and later we'll also explore how we can define configuration
    values via environment variables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用我们之前创建的`Dockerfile`，并设置它在Heroku上部署并运行。我们将了解如何轻松地在那里设置应用程序，稍后我们还将探索如何通过环境变量定义配置值。
- en: 'Before we start, make sure you''ve created an account and installed the Heroku
    CLI before we proceed to the step-by-step guide, by following the two links provided
    here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保您已经创建了账户并安装了Heroku CLI，然后按照这里提供的两个链接进行步骤指南：
- en: 'Create an account: [https://signup.heroku.com/dc](https://signup.heroku.com/dc).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建账户：[https://signup.heroku.com/dc](https://signup.heroku.com/dc)。
- en: 'Install the CLI: [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装CLI：[https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)。
- en: Now that we have created an account and installed the CLI, we can start to set
    up our project in Heroku.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了账户并安装了CLI，我们可以开始在Heroku上设置我们的项目。
- en: Creating the application in Heroku
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Heroku上创建应用程序
- en: Here, we will go through the steps needed to authenticate and create the application
    in Heroku. We're almost ready to start, but there's another thing we have to make
    clear first.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将了解在Heroku上进行身份验证并创建应用程序所需的步骤。我们几乎准备好了，但还有一件事我们必须先弄清楚。
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As Heroku uses `git` as source of truth, you'll *not* be able to do the following
    procedure inside the book's files repository, as it is already a Git repository
    containing multiple stages of the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Heroku使用`git`作为真相来源，您将*无法*在书籍的文件仓库内执行以下过程，因为它已经是一个包含应用程序多个阶段的Git仓库。
- en: What I recommend you do is copy the application files to a different folder,
    *outside the book's repository*, and start the process from there.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您将应用程序文件复制到另一个不同的文件夹中，*位于书籍仓库外部*，并从那里开始这个过程。
- en: You can copy the latest version of the working application from [*Chapter 8*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178),
    *Testing – Unit and Integration* ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)),
    which is the one we'll use here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[*第8章*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178)，*测试 – 单元和集成*([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api))复制最新版本的运行中应用程序，这是我们将在这里使用的版本。
- en: 'Now that the files are copied into a new folder (outside the main repository),
    let''s deploy the `Dockerfile` and run it on Heroku by following these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件已经被复制到了一个新的文件夹（主仓库外部），接下来通过以下步骤在Heroku上部署`Dockerfile`并运行它：
- en: 'The first thing we''ll do is log in with the CLI, running `heroku login`. This
    should open a browser window where you can insert your username and password,
    as illustrated in the following code snippet:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的就是使用CLI登录，运行`heroku login`。这应该会打开一个浏览器窗口，您可以在其中输入您的用户名和密码，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As Heroku deployments are based on `git`, and since we''re now in a folder
    that is not a Git repository, we''ll need to initialize it, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Heroku部署是基于`git`的，而我们现在在一个不是Git仓库的文件夹中，我们需要初始化它，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we will create our application in Heroku by using `heroku create`, as
    follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过使用`heroku create`来创建Heroku上的应用程序，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you go to the Heroku Dashboard after running the preceding commands, you'll
    notice there's a new application living there. When the application is created,
    Heroku prints a URL on the console; however, as we haven't configured anything,
    our application is not available yet.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行前面的命令后访问Heroku仪表板，您会发现那里有一个新的应用程序。当应用程序创建时，Heroku在控制台打印一个URL；然而，由于我们还没有配置任何内容，我们的应用程序目前还不可用。
- en: The next thing we'll need to do it to configure Heroku so that it knows it should
    build and execute our image in every deployment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是配置Heroku，以便它在每次部署时知道它应该构建和执行我们的镜像。
- en: Building and running the Docker image
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行Docker镜像
- en: By default, Heroku just tries to make your application available by running
    the code. This is possible to do with many languages and you'll find guides for
    it in the Heroku documentation. As we want to use a container to run our application,
    the process needs a little more configuration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Heroku试图通过运行代码使您的应用程序可用。这对于许多语言来说都是可能的，您可以在Heroku文档中找到相关指南。由于我们想要使用容器来运行我们的应用程序，因此该过程需要一些额外的配置。
- en: 'Heroku provides a set of features that allow us to define what happens when
    there are changes in the code, via a file named `heroku.yml`. That''s what we''ll
    create now, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku提供了一组功能，允许我们定义当代码发生更改时会发生什么，通过一个名为`heroku.yml`的文件。我们现在将创建该文件，如下所示：
- en: 'Create a `heroku.yml` file at the root of your repository and add the following
    lines of code there so that it builds our image using Docker, using the `Dockerfile`
    we created in the previous section:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仓库根目录下创建一个`heroku.yml`文件，并添加以下代码行，以便使用我们在上一节中创建的`Dockerfile`使用Docker构建我们的镜像：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, in the same file, add the following lines of code to define the command
    that will be executed by Heroku to run the application:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一个文件中，添加以下代码行以定义Heroku将执行以运行应用程序的命令：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next thing we''ll have to do is to set the application type to `container`,
    informing Heroku that''s how we want this application to run. The code for this
    is shown in the following snippet:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要做的就是将应用程序类型设置为`container`，告知Heroku我们希望应用程序以这种方式运行。以下代码片段显示了此操作的代码：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add all the files to make sure that `git` is tracking them:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有文件以确保`git`正在跟踪它们：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Commit all the files with a message, as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交所有文件，并附上如下信息：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, it's a matter of pushing the files to the `heroku` remote.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关键是要把文件推送到`heroku`远程。
- en: 'This should trigger the build process of the Docker image, as you can check
    in the logs. This image is then pushed into Heroku''s internal image registry
    in the last phase, as illustrated in the following code snippet:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该触发Docker镜像的构建过程，您可以在日志中进行检查。然后，在最后阶段，这个镜像被推送到Heroku的内部镜像注册表中，如下代码片段所示：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'remote: === Pushing web (Dockerfile)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'remote: === 正在推送web (Dockerfile)'
- en: 'remote: Tagged image "5c154f3fcb23f3c3c360e16e929c22b62847fcf8" as "registry.heroku.com/boiling-dusk-18477/web"'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'remote: 标记镜像 "5c154f3fcb23f3c3c360e16e929c22b62847fcf8" 为 "registry.heroku.com/boiling-dusk-18477/web"'
- en: 'remote: Using default tag: latest'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'remote: 使用默认标签: latest'
- en: 'remote: The push refers to repository [registry.heroku.com/boiling-dusk-18477/web]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'remote: 推送指的是仓库 [registry.heroku.com/boiling-dusk-18477/web]'
- en: 'remote: 6f8894494a30: Preparing'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'remote: 6f8894494a30: 正在准备'
- en: 'remote: f9b9c806573a: Preparing'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'remote: f9b9c806573a: 正在准备'
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember that our application depends on the configuration, and that part of
    the configuration is coming from the environment. There's no way Heroku couldn't
    have known which configuration values we needed. There are still some settings
    we need to configure to get our application working, and that's what we'll do
    next.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的应用程序依赖于配置，而配置的一部分来自环境。Heroku不可能不知道我们需要哪些配置值。还有一些设置我们需要配置以使我们的应用程序运行，接下来我们就做这件事。
- en: Configuring the application for deployment
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为部署配置应用程序
- en: We now have an application that, when code is pushed to `git`, starts the process
    of building an image and deploying it. Our application currently gets deployed
    but it's not actually working, and this is happening because it is lacking configuration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个应用程序，当代码推送到`git`时，它会启动构建镜像并部署它。我们目前的应用程序已经部署了，但实际上并没有运行，这是因为缺少配置。
- en: The first thing you probably noticed is that our application is always loading
    the configuration file from development, `config.dev.yml`, and it shouldn't.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能首先注意到的是，我们的应用程序总是从开发环境加载配置文件，`config.dev.yml`，它不应该这样做。
- en: When we first implemented this, we thought that different environments would
    have different configurations, and we were right. At the time, we didn't need
    to have configurations for more than one environment, and we used `dev` as a default.
    Let's fix that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次实现这个功能时，我们以为不同的环境会有不同的配置，我们是对的。当时，我们不需要为多个环境设置配置，所以我们使用了`dev`作为默认值。让我们解决这个问题。
- en: Remember that when we created the function that loads the configuration, we
    explicitly used an argument for the environment? We didn't use it at the time,
    but we left a default value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们创建加载配置文件的函数时，明确使用了环境参数吗？当时我们没有使用它，但我们留下了一个默认值。
- en: 'Look at the following code snippet from `src/config/index.ts`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`src/config/index.ts`中的以下代码片段：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What we''ll need to do is change this so that it supports multiple environments.
    So, let''s do that by following these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是将此更改为支持多个环境。所以，让我们按照以下步骤来做到这一点：
- en: 'Go back into `src/index.ts` and make sure we''re sending the environment variable
    named `DENO_ENV` to the `load` function, as illustrated in the following code
    snippet:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/index.ts`，确保我们将名为`DENO_ENV`的环境变量发送到`load`函数，如下所示：
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create the production configuration file, `config.production.yml`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建生产配置文件，`config.production.yml`。
- en: 'For now, it shouldn''t be much different than `config.dev.yml`, with the exception
    of the `port`, for now. Let''s get it running at port `9001` in production, as
    follows:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，它应该与`config.dev.yml`没有太大区别，除了`port`。让我们在生产环境中以端口`9001`运行它，如下所示：
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To test this locally, we can run the application with the `DENO_ENV` variable
    set to `production`, like this:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在本地测试这一点，我们可以使用`DENO_ENV`变量设置为`production`来运行应用程序，像这样：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With what we just implemented, we're now able to control which configuration
    values are loaded based on the environment. This is something we already tested
    locally, but something we haven't done on Heroku.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们刚刚实现的内容，我们现在可以根据环境控制加载哪些配置值。这是我们已经在本地测试过的，但在Heroku上还没有做过。
- en: We've solved part of the problem—we're loading a different configuration file
    depending on the environment, but there are other configuration values that our
    application depends on that are coming from the environment. Those are secret
    values such as the **JSON Web Token** (**JWT**) key or the MongoDB credentials.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了部分问题——我们根据环境加载不同的配置文件，但我们的应用程序依赖的其他配置值来自环境。这些是诸如**JSON Web Token**（**JWT**）密钥或MongoDB凭据等秘密值。
- en: 'There are many ways to do this, and all cloud providers provide a solution
    for that. In Heroku, we can do this by using the `config` command, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以做到这一点，所有云服务提供商都提供了相应的解决方案。在Heroku上，我们可以通过使用`config`命令来实现，如下所示：
- en: 'Define the MongoDB credential variables, the JWT key, and the environment using
    the `heroku config:set` command, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`heroku config:set`命令定义MongoDB凭据变量、JWT密钥和环境，如下所示：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: …
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: 'mongoDb:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'MongoDB:'
- en: 'clusterURI: <add your cluster url>'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '集群URL: <添加您的集群URL>'
- en: 'database: <add your database name>'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '数据库: <添加您的数据库名称>'
- en: '[PRE27]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once again, we''ll add our changes to `git`, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将我们的更改添加到`git`中，如下所示：
- en: '[PRE28]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And then, we''ll push the changes to Heroku to trigger the deployment process,
    as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将更改推送到Heroku以触发部署过程，如下所示：
- en: '[PRE29]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And it should be working. If we now go to the Heroku Dashboard ([https://dashboard.heroku.com/](https://dashboard.heroku.com/)),
    then into our application's dashboard ([https://dashboard.heroku.com/apps/boiling-dusk-18477](https://dashboard.heroku.com/apps/boiling-dusk-18477),
    in my case) and click the **Open Application** button, it should open our application,
    right?
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后它应该能正常工作。如果我们现在前往Heroku控制台([https://dashboard.heroku.com/](https://dashboard.heroku.com/)），然后进入我们应用程序的控制台([https://dashboard.heroku.com/apps/boiling-dusk-18477](https://dashboard.heroku.com/apps/boiling-dusk-18477)，在我的案例中)并点击**打开应用程序**按钮，它应该能打开我们的应用程序，对吧？
- en: Not yet, but we're almost there—we still need to sort out one more thing.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还不是，但我们快了——我们还需要解决一件事情。
- en: Getting the application port from the environment
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从环境中获取应用程序端口
- en: Heroku has some particularities when it comes to running Docker images. It doesn't
    allow us to set the port where the application is running. What it does is assign
    a port where the application should run, and then redirect **HyperText Transfer
    Protocol** (**HTTP**) and **HyperText Transfer Protocol Secure** (**HTTPS**) traffic
    from the application URL there. If this still feels strange, no worries—we'll
    get there.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku在运行Docker镜像时有一些特别之处。它不允许我们设置应用程序运行的端口。它所做的是分配一个应用程序应该运行的端口，然后将来自应用程序URL的**超文本传输协议**（**HTTP**）和**安全的超文本传输协议**（**HTTPS**）流量重定向到那里。如果这听起来仍然很奇怪，不用担心——我们会搞定的。
- en: As you know, we explicitly defined the port our application was going to run
    on in the `config.production.yml` file. We need to adapt this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，我们明确地在`config.production.yml`文件中定义了应用程序将要运行的端口。我们需要适应这个。
- en: 'The way Heroku defines which port an application should run on is by setting
    the `PORT` environment variable. This is documented at the following link:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku定义应用程序应该运行在哪个端口的方式是通过设置`PORT`环境变量。这在以下链接中有文档记录：
- en: '[https://devcenter.heroku.com/articles/container-registry-and-runtime#dockerfile-commands-and-runtime](https://devcenter.heroku.com/articles/container-registry-and-runtime#dockerfile-commands-and-runtime)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[Heroku容器注册表和运行时](https://devcenter.heroku.com/articles/container-registry-and-runtime#dockerfile-commands-and-runtime)'
- en: You'll probably know from the title what we're doing next. We're going to change
    our application so that the web server port coming from the environment overrides
    the one defined in the configuration file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从标题中知道我们接下来要做什么。我们要更改我们的应用程序，以便来自环境的Web服务器端口覆盖配置文件中定义的那个。
- en: 'Go back to `src/config/index.ts` in the application and make sure it is reading
    the `PORT` variable from the environment, overriding the configuration coming
    from the file. The code can be seen in the following snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 回到应用程序中的`src/config/index.ts`，确保它正在从环境中读取`PORT`变量，覆盖来自文件的配置。代码可以在以下片段中看到：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This way, we make sure that we're reading the variable from the `PORT` environment
    variable, using the value in the configuration file as a default.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们确保我们从`PORT`环境变量中读取变量，使用配置文件中的值作为默认值。
- en: And this should be all it takes to get our application running smoothly in Heroku!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该就足够让我们的应用程序在Heroku中顺利运行了！
- en: Once again, we can test this by going to the Heroku Dashboard ([https://dashboard.heroku.com/apps/boiling-dusk-18477](https://dashboard.heroku.com/apps/boiling-dusk-18477))
    and clicking the **Open App** button, or you can do this by going directly to
    the URL—in my case, it's [https://boiling-dusk-18477.herokuapp.com/](https://boiling-dusk-18477.herokuapp.com/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以通过访问Heroku仪表板（[https://dashboard.heroku.com/apps/boiling-dusk-18477](https://dashboard.heroku.com/apps/boiling-dusk-18477)）并点击**打开应用**按钮来测试这一点，或者你可以直接访问URL——在我的情况下，它是[https://boiling-dusk-18477.herokuapp.com/](https://boiling-dusk-18477.herokuapp.com/)。
- en: Important note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using MongoDB Atlas, as we did in [*Chapter 6*](B16380_06_Final_JM_ePub.xhtml#_idTextAnchor141),
    *Adding Authentication and Connecting to the Database*, and want to allow your
    application to access the database, you have to configure it so that it enables
    connections from "anywhere". This isn't recommended practice if you're exposing
    an application to your users, and it only happens because we're using Heroku's
    Free Tier. As it runs in a shared cluster, we have no way of knowing what the
    fixed **Internet Protocol** (**IP**) address is of the machine running the application,
    and we need to do it this way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用MongoDB Atlas，正如我们在[第6章](B16380_06_Final_JM_ePub.xhtml#_idTextAnchor141)中*添加身份验证并连接到数据库*所做的那样，并且想要允许你的应用程序访问数据库，你必须配置它使其能够从"任何地方"进行连接。这不是一个推荐的做法，如果你将应用程序暴露给你的用户，而且这只发生因为我们正在使用Heroku的免费层。由于它在共享集群中运行，我们没有办法知道运行应用程序的机器的固定的**互联网协议**（**IP**）地址是什么，我们只能这样做。
- en: 'The following link demonstrates how can you configure network access to the
    database: [https://docs.atlas.mongodb.com/security/ip-access-list](https://docs.atlas.mongodb.com/security/ip-access-list).
    Make sure you click **ALLOW ACCESS FROM ANYWHERE** in the MongoDB Atlas network
    access screen.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接展示了如何配置数据库的网络访问： [https://docs.atlas.mongodb.com/security/ip-access-list](https://docs.atlas.mongodb.com/security/ip-access-list)。确保你在MongoDB
    Atlas网络访问屏幕上点击**允许从任何地方访问**。
- en: 'This is what the network access screen looks like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 网络访问屏幕就是这样子的：
- en: '![Figure 9.1 – MongoDB Atlas network access screen'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – MongoDB Atlas网络访问屏幕'
- en: '](img/Figure_9.1_B16380.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B16380.jpg)'
- en: Figure 9.1 – MongoDB Atlas network access screen
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – MongoDB Atlas网络访问屏幕
- en: 'After this, our application should work as expected; you can try to perform
    a request to register a user (that connects to the database) and check that everything''s
    fine, as demonstrated in the following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们的应用程序应该按预期工作；您可以尝试执行一个注册用户的请求（该请求连接到数据库）并检查一切是否正常，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you got a response that's similar to the preceding one, you're all set! We
    managed to configure and deploy our application in a cloud environment and created
    an automated way to ship updates to our users.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您得到的响应与前面的类似，那就大功告成了！我们成功地在云环境中配置并部署了我们的应用程序，并创建了一种自动化的方式将更新推送给我们的用户。
- en: 'To do a final test to check whether the code is being deployed successfully,
    we can try to change part of the code and trigger the deployment process again.
    Let''s do it! Proceed as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行最后的测试，以确认代码是否成功部署，我们可以尝试更改代码的一部分并再次触发部署过程。让我们这样做！按照以下步骤进行：
- en: 'Change our `"Hello World"` message in `src/web/index.ts` to `"Hello Deno World!"`,
    as illustrated in the following code snippet:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`src/web/index.ts`中的`"Hello World"`消息更改为`"Hello Deno World!"`，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add this change to version control, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤将此更改添加到版本控制中：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Push it into Heroku''s `git` remote repository, like this:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其推送到Heroku的`git`远程仓库，如下所示：
- en: '[PRE34]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we now access the application URL (which is [https://boiling-dusk-18477.herokuapp.com/](https://boiling-dusk-18477.herokuapp.com/),
    in our case), you should get the `Hello Deno World` message.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在访问应用程序的URL（在我们的情况下是[https://boiling-dusk-18477.herokuapp.com/](https://boiling-dusk-18477.herokuapp.com/)），您应该会看到`Hello
    Deno World`消息。
- en: This means that our application was successfully deployed. Since we're using
    a cloud platform that provides more than what we learned here, we can explore
    other Heroku features, such as logging.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的应用程序已成功部署。由于我们使用的是提供比这里学到的更多功能的云平台，我们可以探索Heroku的其他功能，例如日志记录。
- en: 'Next to the **Open app** button on the Heroku Dashboard ([https://dashboard.heroku.com/](https://dashboard.heroku.com/)),
    you have a **More** button. One of the options is **View logs**, as you can see
    in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Heroku控制面板上的**打开应用**按钮旁边，有一个**更多**按钮。其中一个选项是**查看日志**，正如您在下面的屏幕截图中所看到的：
- en: '![Figure 9.2 – More application options in the Heroku Dashboard'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – Heroku控制面板中的应用更多选项](img/Figure_9.3_B16380.jpg)'
- en: '](img/Figure_9.2_B16380.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B16380.jpg)'
- en: Figure 9.2 – More application options in the Heroku Dashboard
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – Heroku控制面板中的应用更多选项
- en: If you click there, an interface that shows the logs in real time will appear.
    You can try it out by opening your application in a different tab (by clicking
    the **Open app** button).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击那里，将出现一个实时显示日志的界面。您可以尝试通过点击**打开应用**按钮在另一个标签页中打开您的应用程序来尝试它。
- en: 'You''ll see that the logs instantly update, and something like this should
    appear there:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到日志立即更新，那里应该会出现类似这样的内容：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is of great use when you want to have a very light monitoring of how your
    application is running. The Logging feature is provided in the Free Tier, but
    there are many more features you can explore, such as the **Metrics** one, which
    we'll not do here.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于您想要对应用程序的运行情况进行非常轻量级的监控非常有用。日志记录功能在免费层中提供，但还有许多其他功能供您探索，例如我们在这里不会进行的**指标**功能。
- en: 'If you want to have a detailed look at when and by whom your application was
    deployed, you can also use the **Activity** section from the Heroku Dashboard,
    as illustrated in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想详细了解您的应用程序何时以及由谁部署，您还可以使用Heroku控制面板的**活动**部分，如下面的屏幕截图所示：
- en: '![Figure 9.3 – Heroku Dashboard application options](img/Figure_9.3_B16380.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – Heroku控制面板应用程序选项](img/Figure_9.3_B16380.jpg)'
- en: Figure 9.3 – Heroku Dashboard application options
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – Heroku控制面板应用程序选项
- en: 'You''ll then see a log of your most recent deployments, another very interesting
    feature of Heroku, as illustrated in the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到您最近部署日志的记录，这是Heroku的另一个非常有趣的功能，如下面的屏幕截图所示：
- en: '![Figure 9.4 – Activity tab in the Heroku Dashboard application'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – Heroku控制面板应用程序的活动标签](img/Figure_9.4_B16380.jpg)'
- en: '](img/Figure_9.4_B16380.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B16380.jpg)'
- en: Figure 9.4 – Activity tab in the Heroku Dashboard application
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – Heroku控制面板应用程序的活动标签
- en: This wraps up our section on deploying the application in a cloud environment.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们在云环境中部署应用程序的部分。
- en: We focused on the application and on topics that can and will be reused independent
    of the platform on which your code is running. We've iterated the application
    logic that loaded the configuration so that it could load different configurations
    depending on the environment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的是应用程序以及可以在您的代码运行的平台独立重复使用的主题。我们迭代了加载配置的应用程序逻辑，使其能够根据环境加载不同的配置。
- en: Then, we learned how we could send environment variables with secret configuration
    values to our application, and we wrapped up by exploring logging on the platform
    of choice for this example, Heroku—and that was it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何将包含机密配置值的环境变量发送到我们的应用程序，最后我们探索了在Heroku这个示例选择的平台上进行日志记录——就此结束。
- en: We managed to get our application to run, and we created a whole infrastructure
    around it that will enable future iterations to be easily shipped to our users.
    Hopefully, we went through some of the phases you'll also go through next time
    you decide to deploy a Deno application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功让我们的应用程序运行起来，并且围绕它建立了一个完整的架构，这将使未来的迭代能够轻松地部署给我们的用户。希望我们经历了一些你们下次决定部署Deno应用程序时也会遇到阶段。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: And we're pretty much done! This chapter completes the cycle of development
    phases in our application by deploying it. We went from building a very simple
    application, to adding features to it, to adding tests, and—finally—to deploying
    it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 差不多完成了！本章通过部署完成了我们应用程序开发阶段的循环。我们从构建一个非常简单的应用程序开始，到向其中添加功能，到添加测试，最后——部署它。
- en: Here, we learned how we can use some of the benefits of containerization in
    our applications. We started learning about Docker, our container runtime of choice,
    and rapidly moved on to creating an image for our application. Learning about
    some Docker commands as we moved through the process, we also experienced how
    easy it is to prepare a Deno application to be deployed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们学习了如何在我们的应用程序中使用一些容器化的好处。我们开始了解Docker，我们选择的容器运行时，并迅速地创建了我们应用程序的镜像。在学习的过程中了解一些Docker命令，我们也体验了准备Deno应用程序部署是多么的容易。
- en: Creating this Docker image enabled us to have a replicable way of installing,
    running, and distributing our application, creating a package with everything
    the applications needs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个Docker镜像使我们能够有一种可复现的方式来安装、运行和分发我们的应用程序，创建一个包含应用程序所需一切的包。
- en: As the chapter proceeded, we started to explore how we can use this application
    package to deploy it in a cloud environment. We started by configuring the cloud
    platform of choice for this step-by-step guide, Heroku, so that it would rebuild
    and run our application's code every time it changed, and we very easily made
    it with the help of `git` and Heroku's documentation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当章节进行时，我们开始探索如何使用这个应用程序包将其部署在云环境中。我们首先配置了本指南的分步指南选择的云平台Heroku，使其每次发生变化时都会重新构建并运行我们应用程序的代码，在`git`和Heroku文档的帮助下，我们非常容易地实现了它。
- en: As the automated pipeline was configured, we understood the need to send configuration
    values to our application. These same configuration values, which we previously
    implemented in earlier chapters, needed to be sent to the application in two different
    ways, via a configuration file and via the environment. We tackled each one of
    those needs, first by iterating the application code so that it loaded different
    configurations depending on the environment, and later by learning how to set
    configuration values in an application living on Heroku.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置自动化流水线时，我们理解了需要将配置值发送到我们的应用程序。我们之前在早期章节中实现的一些相同的配置值，需要以两种不同的方式发送到应用程序，通过配置文件和通过环境变量。我们逐一解决了这些需求，首先通过迭代应用程序代码使其根据环境加载不同的配置，后来学习如何在Heroku上设置配置值。
- en: 'We finally got our application to run flawlessly and completed the objective
    of the chapter: to have a replicable, automated way to deploy code to our users.
    In the meantime, we learned a bit about Docker and the benefits of containerization
    and automation when it comes to releasing code.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们让我们的应用程序无缝运行，并完成了本章的目标：拥有一个可复现、自动化的方式将代码部署给我们的用户。与此同时，我们了解了一些关于Docker以及当涉及到发布代码时容器化和自动化的好处。
- en: This pretty much wraps it up on the book's objective. We decided to make this
    a journey of building an application, separately going through all its phases
    and addressing them as needed. This was the last phase—deploying it, which hopefully
    closes the cycle for you in terms of going from the first line of code to deployment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的内容基本上已经讲到这里了。我们决定让这个过程成为一个建立应用程序的旅程，分别经历它的所有阶段并在需要时解决它们。这是最后一个阶段——部署，希望这能为您从编写第一行代码到部署的整个周期画上句号。
- en: The next chapter will focus on what's next when it comes to Deno, both for the
    runtime and for you personally. I hope this has made you a Deno enthusiast and
    that you are as excited as I am about it and the world of possibilities it opens
    up.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点关注Deno接下来的发展，包括运行时和您个人方面。我希望这能让您成为Deno的爱好者，并且您对它以及它所开启的无限可能世界像我一样充满热情。
