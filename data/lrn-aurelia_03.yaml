- en: Chapter 3. Displaying Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 显示数据
- en: 'To render views, Aurelia relies on two core libraries: `aurelia-templating`,
    which provides a rich and extensible templating engine, and `aurelia-binding`,
    which is a modern and adaptive data binding library. Since the templating engine
    relies on an abstraction for data binding, which means other data binding libraries
    can be used instead of Aurelia''s, the `aurelia-templating-binding` library acts
    as a bridge between the two. Additionally, `aurelia-templating-resources` builds
    on top of the templating engine and defines a set of standard behaviors and components.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染视图，Aurelia依赖于两个核心库：`aurelia-templating`，它提供了一个丰富且可扩展的模板引擎，以及`aurelia-binding`，它是一个现代且适应性强的数据绑定库。由于模板引擎依赖于数据绑定的抽象，这意味着可以使用Aurelia之外的数据绑定库，`aurelia-templating-binding`库充当了两者之间的桥梁。此外，`aurelia-templating-resources`建立在模板引擎之上，定义了一组标准行为和组件。
- en: In this chapter, we will cover data binding and the basics of templating. We
    will see the standard behaviors that Aurelia offers out-of-the-box and how to
    use them in views.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍数据绑定和模板的基础知识。我们将了解Aurelia提供的标准行为以及如何在视图中使用它们。
- en: Before rendering any data, it must first be obtained. Most of the time, single-page
    web applications rely on some kind of web service. Therefore, we will see what
    the Fetch API is, how to use Aurelia's Fetch client, and how to configure it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染任何数据之前，首先必须获取它。大多数时候，单页网络应用程序依赖于某种类型的网络服务。因此，我们将了解Fetch API是什么，如何使用Aurelia的Fetch客户端，以及如何配置它。
- en: Lastly, before closing this chapter, we will put our new knowledge into practice
    on our contact management application by adding views to display a list of contacts
    and the details of a contact.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在关闭本章之前，我们将把我们新学到的知识应用到我们的联系人管理应用程序中，通过添加视图来显示联系人列表和联系人的详细信息。
- en: Templating basics
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板基础
- en: A template is an HTML file whose root element is a `template` element. It must
    be valid HTML, as the templating engine relies on the browser to parse the file
    and build a DOM tree out of it, which the engine will walk through, analyze, and
    enrich with behaviors.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一个根元素为`template`元素的HTML文件。它必须是有效的HTML，因为模板引擎依赖于浏览器解析该文件并从中构建一个DOM树，然后引擎将遍历、分析和丰富行为。
- en: 'This means that the limitations applying to an HTML file apply to any Aurelia
    template. For example, a `table` element can contain only certain types of element
    as children, such as `thead`, `tbody`, or `tr`. As such, the following template
    is illegal in most browsers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着适用于HTML文件的限制也适用于任何Aurelia模板。例如，`table`元素只能作为子元素包含某些类型的元素，如`thead`、`tbody`或`tr`。因此，以下模板在大多数浏览器中是非法的：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we would like to use the `compose` element, which we will cover in a later section,
    to insert a view containing the table head. Since `compose` is not a valid child
    for `table`, most browsers will discard it when parsing the HTML file, so the
    templating engine won't be able to see it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要使用在后面小节中介绍的`compose`元素，以插入包含表头的视图。由于`compose`不是`table`的有效子元素，大多数浏览器在解析HTML文件时会忽略它，因此模板引擎无法看到它。
- en: 'To get around such limitations, Aurelia looks for a special `as-element` attribute.
    This attribute acts as an alias of the element''s name for the templating engine:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些限制，Aurelia寻找一个特殊的`as-element`属性。这个属性作为元素名称的别名供模板引擎使用：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, changing the name of the element from `compose` to `thead` makes it a
    legitimate HTML snippet, and adding the `as-element="compose"` attribute tells
    Aurelia's templating engine to see this `thead` element as a `compose` element.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将元素名称从`compose`更改为`thead`使其成为一个合法的HTML片段，并添加`as-element="compose"`属性告诉Aurelia的模板引擎将这个`thead`元素视为一个`compose`元素。
- en: View resources
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图资源
- en: View resources are artifacts that are made available to the templating engine,
    so they can be used by templates. For example, a custom element or a value converter
    is a resource.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 视图资源是可供模板引擎使用的工件，因此它们可以被模板使用。例如，自定义元素或值转换器是资源。
- en: Like we saw in previous chapters, resources can be loaded globally, for example
    by the application `configure` method, by a plugin, or by a feature. Such resources
    are made available for every template in the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中看到的那样，资源可以全局加载，例如通过应用程序的`configure`方法、通过插件或通过特性。这样的资源对应用程序中的每个模板都可用。
- en: Locally loading resources
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地加载资源
- en: 'In addition to global resources, each template has its own set of resources.
    A template that needs to use a resource that is not globally available must load
    it first. This is done using the `require` element:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了全局资源外，每个模板都有自己的资源集。一个需要使用一个在全球范围内不可用的资源的模板必须首先加载它。这通过使用`require`元素来实现：
- en: '`src/some-module/some-template.html`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/some-module/some-template.html`'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `from` attribute must be the path of the resource to load. In the previous
    example, the path is relative to the code root, which would normally be the `src`
    directory. This means that `some-resource` is expected to sit directly in `src`.
    The path can, however, be made relative to the directory the current template
    file is in, by using the `./` prefix:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`属性必须是要加载的资源的路径。在前一个示例中，路径是相对于代码根目录的，通常是指向`src`目录。这意味着`some-resource`预期直接位于`src`中。然而，路径也可以通过使用`.`前缀来使其相对于当前模板文件所在的目录：'
- en: '`src/some-module/some-template.html`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/some-module/some-template.html`'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, `some-resource` is expected to sit in the `src/some-module`
    directory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`some-resource`预期位于`src/some-module`目录中。
- en: 'Additionally, an `as` attribute can be specified. It is used to change the
    local name of the resource, to solve a name conflict with another resource, for
    example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以指定`as`属性。它用于更改资源的本地名称，以解决与其他资源的名字冲突，例如：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `some-resource` is made available as `another-resource` in
    the template.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`some-resource`作为`another-resource`在模板中可用。
- en: Resource types
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源类型
- en: By default, a resource is expected to be a JS file, in which case the path should
    exclude the `.js` extension. For example, to load a value converter exported from
    the `sort.js` file, a template would simply require `sort`. This is true no matter
    the type of resource, value converter, binding behavior, custom element, and so
    on, except for templates used as custom elements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，预期资源是一个JS文件，在这种情况下，路径应该排除`.js`扩展名。例如，要加载从`sort.js`文件导出的值转换器，模板只需要求`sort`。无论资源类型是什么，值转换器、绑定行为、自定义元素等等，除了用作自定义元素的模板之外，都是正确的。
- en: We'll see later how to create custom elements. We'll also see how to create
    template-only components, without a view-model, when a component has no behavior.
    In such a case, when loaded as a resource, the template-only component must be
    referred to using its full filename, including its extension. For example, to
    load a template-only component named `menu.html`, we need to require `menu.html`
    and not simply `menu`. Otherwise, the templating engine won't know that it is
    looking for an HTML file and not a JS file, and will try to load `menu.js`. We
    will see real examples of this when we start breaking our application into components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将看到如何创建自定义元素。我们还将看到在没有视图模型的情况下如何创建仅包含模板的组件，当一个组件没有行为时。在这种情况下，作为资源加载时，仅包含模板的组件必须使用其完整文件名（包括其扩展名）来引用。例如，要加载一个名为`menu.html`的仅包含模板的组件，我们需要要求`menu.html`，而不仅仅是`menu`。否则，模板引擎将不知道它在寻找一个HTML文件而不是一个JS文件，并尝试加载`menu.js`。当我们开始将应用程序拆分为组件时，我们将看到这个的真实示例。
- en: Loading CSS
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载CSS
- en: 'In addition to locally loading a template resource, the `require` element can
    be used to load a style sheet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本地加载模板资源外，`require`元素还可以用来加载样式表：
- en: '`src/my-component.html`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/my-component.html`'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the `my-component.css` style sheet will be loaded and added
    to the head of the document.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`my-component.css`样式表将被加载并添加到文档的头部。
- en: 'Additionally, the `as="scoped"` attribute can be used to scope the style sheet
    to the component:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用`as="scoped"`属性将样式表的作用域限定在组件内：
- en: '`src/my-component.html`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/my-component.html`'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this second example, if `my-component` uses the ShadowDOM and if the browser
    supports it, the style sheet will be injected in the ShadowDOM root. Otherwise,
    it will be injected into the component's view and the `scoped` attribute will
    be set to the `style` element.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个例子中，如果`my-component`使用ShadowDOM，并且浏览器支持它，样式表将被注入到ShadowDOM根部。否则，它将被注入到组件的视图中，并将`scoped`属性设置到`style`元素。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The ShadowDOM is an API that allows us to create isolated subtrees in the DOM.
    Such subtrees can load their own style sheets and JavaScript in isolation, without
    any risk of conflicts with the surrounding document. This technology is central
    to pain-free web component development but, at the time of writing, it is still
    not widely supported by browsers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 影子DOM是一个API，它允许我们在DOM中创建孤立的子树。这样的子树可以加载它们自己的样式表和JavaScript，并与周围文档的冲突风险无关。这项技术对于无痛开发Web组件至关重要，但在撰写本文时，它仍然没有得到广泛浏览器的支持。
- en: The `scoped` attribute on a `style` element tells the browser to restrict the
    scope of the style sheet to the containing element and its descendants. This prevents
    styles from interfering with the rest of the document, without having to use a
    ShadowDOM root. It is a useful alternative to the ShadowDOM, but is still not
    widely supported by browsers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style`元素上的`scoped`属性告诉浏览器将样式表的作用域限制在包含元素及其后代元素上。这防止样式与其他文档部分发生冲突，而无需使用ShadowDOM根。它是ShadowDOM的有用替代品，但仍然没有得到广泛浏览器的支持。
- en: Data binding
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Data binding is the action of linking template elements, using expressions,
    to a data model, which is a JS object. This data model is called a binding context.
    This context is used by Aurelia to expose, for example, the properties and methods
    of a component's view-model to its template. Additionally, some of the behaviors
    described in the following sections add information to their binding context.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是将模板元素使用表达式与数据模型链接起来的动作，数据模型是一个JS对象。这个数据模型称为绑定上下文。这个上下文由Aurelia用于例如，暴露组件视图模型的属性和方法给其模板。此外，以下部分描述的一些行为会在其绑定上下文中添加信息。
- en: Binding modes
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定模式
- en: 'Data binding supports three different modes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定支持三种不同的模式：
- en: '**One-way**: The expression is initially evaluated and the instruction is applied
    and rendered in the view. The expression is observed so, whenever its value changes,
    it can be re-evaluated and the instruction can update the view. It changes flow
    only one way, from the model to the view.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向**：该表达式最初被评估，并且应用了说明并在视图中渲染。该表达式被观察，因此，无论其值如何变化，都可以重新评估，说明可以更新视图。它的变化只流向一个方向，从模型流向视图。'
- en: '**Two-way**: Similar to one-way, but the updates flow both ways: if the template
    element, such as an `input`, changes from user interaction, the model is updated.
    It changes flow both ways, from the model to the view, and from the view to the
    model.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向**：与单向类似，但更新既可以从模型流向视图，也可以从视图流向模型：如果模板元素（如`input`）通过用户交互发生变化，模型就会被更新。它的变化是双向的，从模型流向视图，以及从视图流向模型。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, two-way binding restricts the kinds of expression that can be bound
    to. Only assignable expressions (typically, expressions that can be used on the
    left side of an equal (`=`) operator in a JavaScript assignation instruction)
    can be used for two-way binding. For example, you cannot two-way bind to a conditional
    ternary expression or a method call.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，双向绑定限制了可以绑定的表达式的种类。只有可赋值表达式（通常是可以在JavaScript赋值指令的等号（`=`）操作符左侧使用的表达式）可以用于双向绑定。例如，你不能双向绑定到一个条件三元表达式或一个方法调用。
- en: '**One-time**: The expression is initially evaluated and the instruction is
    applied, but the expression is not observed, so any changes to the model occurring
    after the initial rendering won''t be reflected on the view. Binding flows only
    once, from the model to the view, when the view is rendered.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性**：该表达式最初被评估，并且应用了说明，但该表达式不会被观察，因此任何在初始渲染后发生的模型变化都不会在视图中反映出来。绑定只会在视图渲染时从模型流向视图，只有一次。'
- en: String interpolation
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串插值
- en: 'The most basic need when building a template is to display text. This can be
    achieved using string interpolation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模板时最基本的需求是显示文本。这可以通过使用字符串插值来实现：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Similar to ES2015's string interpolation, such an instruction in an Aurelia
    template evaluates the expression between `${` and `}`, and inserts the result
    in the DOM as text.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与ES2015的字符串插值类似，Aurelia模板中的此类说明在`${`和`}`之间评估表达式，并将结果作为文本插入到DOM中。
- en: 'String interpolation works with more complex expressions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值可以与更复杂的表达式一起使用：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we use the ternary expression to display the user's name if a user is
    defined on the binding context, or a generic message otherwise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用三元表达式在绑定上下文中定义用户时显示用户的名字，否则显示通用信息。
- en: 'It can also be used inside an attribute:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用在属性内部：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we use a ternary expression to conditionally assign the `emphasis`
    CSS class to the `h1` element, only when the model's `isFirstTime` property is
    truthy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用三元表达式在`model`的`isFirstTime`属性为真时，有条件地将`emphasis` CSS类分配给`h1`元素。
- en: By default, a string interpolation instruction is bound one-way. This means
    that, whenever the value of the expression changes, it will be re-evaluated and
    updated in the document.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，字符串插值指令被绑定单向。这意味着，无论表达式的值如何变化，它都将被重新评估并在文档中更新。
- en: Data binding commands
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定命令
- en: 'When analyzing an element in a template, the templating engine looks for attributes
    with data binding commands. A data binding command is suffixed to an attribute
    and separated by a dot. It instructs the engine to perform some kind of data binding
    on this attribute. It has the following form: `attribute.command="expression"`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析模板中的一个元素时，模板引擎会寻找带有数据绑定命令的属性。数据绑定命令是附加在属性后面，由点分隔的。它指导引擎对这个属性执行某种数据绑定。它有以下形式：`attribute.command="expression"`。
- en: Let's walk through the various binding commands that Aurelia offers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Aurelia提供的各种绑定命令。
- en: bind
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定（bind）
- en: 'The `bind` command interprets the value of the attribute as an expression and
    binds this expression to the attribute itself:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`命令将属性的值解释为表达式，并将这个表达式绑定到属性本身：'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the value of the `url` property on the binding context will
    be bound to the `href` attribute of the `a` element.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，绑定上下文中`url`属性的值将被绑定到`a`元素的`href`属性上。
- en: 'The `bind` command is adaptive. It chooses its binding mode based on its target
    element and attribute. By default, it uses one-way binding, except when the target
    attribute can be changed by user interaction: the `value` of an `input`, for example.
    In such cases, `bind` performs two-way binding, so changes caused by the user
    are reflected on the model.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`命令是自适应的。它根据其目标元素和属性选择其绑定模式。默认情况下，它使用单向绑定，除非目标属性可以通过用户交互更改：例如`input`的`value`。在这种情况下，`bind`执行双向绑定，因此用户引起的变化会在模型上得到反映。'
- en: One-way
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单向（One-way）
- en: Similar to `bind`, this command performs data binding, but doesn't adapt to
    its context; the binding is forced as one-way, no matter the type of target.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`bind`，这个命令执行数据绑定，但不适应其上下文；绑定被强制为单向，无论目标类型如何。
- en: Two-way
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向（Two-way）
- en: Similar to `bind`, this command performs data binding, but doesn't adapt to
    its context, the binding is forced as two-way, no matter the type of target. Of
    course, applying this command to an attribute that cannot be updated on its own
    is useless.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`bind`，这个命令执行数据绑定，但不适应其上下文，绑定被强制为双向，无论目标类型如何。当然，将这个命令应用于自身无法更新的属性是毫无意义的。
- en: One-time
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次性（One-time）
- en: Similar to `bind`, this command performs data binding, but forces a one-time
    binding, meaning that any change to the model occurring after the initial rendering
    is not reflected on the view.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`bind`，这个命令执行数据绑定，但强制进行一次性绑定，意味着在初始渲染之后模型中的任何变化都不会在视图中反映出来。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意（Note）
- en: You may have already deduced that one-time binding is much lighter than real-time
    binding, as provided by one-way and two-way binding. Indeed, since real-time binding
    requires observation, it is more CPU and memory consuming. In a large application
    with hundreds of data binding instructions, using one-time bindings whenever possible
    can make a huge difference on a performance level. That's why it is considered
    a good practice to stick to one-time binding as much as possible and to use real-time
    binding only when necessary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经推断出一次性绑定比提供的实时绑定（单向和双向绑定）要轻量得多。确实，因为实时绑定需要观察，所以它更消耗CPU和内存。在一个大型应用程序中，如果有很多数据绑定指令，尽可能使用一次性绑定会在性能上产生巨大的不同。这就是为什么尽可能坚持使用一次性绑定，并在必要时才使用实时绑定被认为是一个好习惯。
- en: trigger
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发器（trigger）
- en: 'The `trigger` command binds an event to an expression, which will be evaluated
    each time the event is triggered. The `Event` object is available to the expression
    as an `$event` variable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`trigger`命令将事件绑定到表达式，每次事件被触发时该表达式将被评估。`Event`对象作为`$event`变量可供表达式使用：'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `click` event of `button` will trigger a call to the binding
    context's `open` method, which will be passed the `Event` object. Of course, using
    `$event` is purely optional; here the click handler could be `open()`, in which
    case the `Event` object would simply be ignored.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`button` 的 `click` 事件将触发对绑定上下文的 `open` 方法的调用，并将 `Event` 对象传递给它。当然，使用
    `$event` 是完全可选的；在这里，点击处理器可以是 `open()`，在这种情况下，`Event` 对象将被简单忽略。
- en: 'Note that the event name is spelled without any `on` prefix: the attribute
    is named `click`, not `onclick`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，事件名称不带 `on` 前缀：属性名称为 `click`，而不是 `onclick`。
- en: delegate
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: delegate
- en: While the `trigger` command attaches an event handler directly on the target
    element, `delegate` leverages event delegation by attaching a single handler to
    the document or the nearest ShadowDOM root. This handler will dispatch events
    to their rightful target so the bound expression is evaluated.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接在目标元素上附加事件处理器的 `trigger` 命令不同，`delegate` 利用事件委托，通过将一个处理程序附加到文档或最近的 ShadowDOM
    根元素上来实现。这个处理程序会将事件分派到它们正确的目标，以便评估绑定的表达式。
- en: Just like `trigger`, the `Event` object is available to the expression as an
    `$event` variable, and the `on` prefix must be omitted in the attribute name.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `trigger` 一样，`Event` 对象作为 `$event` 变量 available给表达式，属性名中必须省略 `on` 前缀。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Event delegation, as compared to event handlers directly attached to target
    elements, consumes much less memory. Just like one-time binding versus real-time
    binding, using delegation is mostly unnoticeable in smaller applications, but
    it can make a difference to the memory footprint as the size of an application
    grows. On the other hand, attaching event handlers directly to the element is required
    in some scenarios, especially when firing custom events with disabled bubbling.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接附加到目标元素的事件处理程序相比，事件委托消耗的内存要少得多。就像一次性绑定与实时绑定一样，在小型应用程序中使用委托几乎不会注意到任何差异，但随着应用程序的大小增长，它可能会对内存足迹产生影响。另一方面，直接将事件处理程序附加到元素上是某些场景所必需的，尤其是当禁用冒泡时要触发自定义事件。
- en: call
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: call
- en: The `call` command is used to bind a function wrapping an expression to a custom
    attribute or the property of a custom element. Those custom behaviors can then
    call that function to evaluate the wrapped expression when a certain event occurs
    or a given condition is fulfilled.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`call` 命令用于将一个包含表达式的函数绑定到自定义属性或自定义元素的结构。当发生特定事件或满足给定条件时，这些自定义行为可以调用该函数来评估包装的表达式。'
- en: 'Additionally, a parameter object can be passed by the custom behavior, and
    each property on this object will be made available as a variable in the context
    of the expression:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，自定义行为可以传递一个参数对象，此对象上的每个属性都将在此表达式的上下文中作为变量可用：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can imagine having a `person-form` custom element with a `save` property.
    In this template, we bind the `save` property of `person-form` to a function wrapping
    a call to the model's `createPerson` method, passing to it the value of a `person`
    variable on the expression scope.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以想象有一个带有 `save` 属性的 `person-form` 自定义元素。在这个模板中，我们将 `person-form` 的 `save`
    属性绑定到一个包含对模型 `createPerson` 方法的调用的函数，并向其传递表达式作用域上 `person` 变量的值。
- en: 'The `person-form` view-model would then call this function at some point. The
    parameter object passed to this function will then be made available to the underlying
    expression:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `person-form` 视图模型会在某个时刻调用这个函数。传递给这个函数的参数对象将在此表达式的上下文中可用：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `person-form` view-model calls the function bound on the `save` property,
    passing to it a `person` parameter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`person-form` 视图模型调用绑定在 `save` 属性上的函数，并向其传递一个 `person` 参数。
- en: Obviously, this command is useless with native HTML elements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个命令在与原生 HTML 元素一起使用时是没有用的。
- en: We will see more concrete examples of this when we cover making custom elements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们覆盖自定义元素的制作时，我们会看到这个命令更具体的例子。
- en: ref
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ref
- en: The `ref` command can be used to assign a reference of an HTML element or a
    component part to the binding context. It can be useful if either the template
    or the view-model needs access to an HTML element or some part of a component
    used in the template.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref` 命令可用于将 HTML 元素或组件部分的引用分配给绑定上下文。如果模板或视图模型需要访问模板中使用的 HTML 元素或组件的某部分，这可能很有用。'
- en: 'In the following example, we first use `ref` to assign the `input` element
    on the model as `nameInput`, and then use string interpolation to display in real
    time the `value` of this `input`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们首先使用 `ref` 将模型上的 `input` 元素分配为 `nameInput`，然后使用字符串插值实时显示这个 `input`
    的 `value`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ref` command must be used on a set of specific attributes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`命令必须用于一组特定的属性：'
- en: '`element.ref="someProperty"` (or the `ref="someProperty"` shorthand) will create
    a reference to the HTML element as a property named `someProperty` on the binding
    context'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element.ref="someProperty"`（或`ref="someProperty"`的简写）将在绑定上下文中创建一个名为`someProperty`的属性，引用一个HTML元素'
- en: When put on an element having a `some-attribute` custom attribute, `some-attribute.ref="someProperty"`
    will create a reference to this custom attribute's view-model as a property named
    `someProperty` on the binding context
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当放在具有`some-attribute`自定义属性的元素上时，`some-attribute.ref="someProperty"`将在绑定上下文中创建一个属性，名为`someProperty`，引用这个自定义属性的视图模型
- en: When put on a custom element, `view-model.ref="someProperty"` will create a
    reference to the custom element's view-model as a property named `someProperty`
    on the binding context
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当放在自定义元素上时，`view-model.ref="someProperty"`将在绑定上下文中创建一个属性，名为`someProperty`，引用自定义元素的视图模型
- en: When put on a custom element, `view.ref="someProperty"` will create a reference
    to the custom element's `view` instance as a property named `someProperty` on
    the binding context
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当放在自定义元素上时，`view.ref="someProperty"`将在绑定上下文中创建一个属性，名为`someProperty`，引用自定义元素的`view`实例
- en: When put on a custom element, `controller.ref="someProperty"` will create a
    reference to the custom element's `Controller` instance as a property named `someProperty`
    on the binding context
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当放在自定义元素上时，`controller.ref="someProperty"`将在绑定上下文中创建一个属性，名为`someProperty`，引用自定义元素的两个`Controller`实例
- en: Binding literals
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定字面量
- en: The templating engine interprets the values of all attributes not having any
    command as strings. For example, a `value="12"` attribute will be interpreted
    as a `'12'` string.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎将所有没有命令的属性的值解释为字符串。例如，一个`value="12"`属性将被解释为一个`'12'`字符串。
- en: Some components may have attributes requiring specific value types, such as
    Booleans, numbers, or even arrays or objects. In such cases, you should use data
    binding to force the templating engine to interpret the expression as the appropriate
    type, even if the expression is a literal value that will never change. For example,
    a `value.bind="12"` attribute will be interpreted as the number `12`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件可能具有需要特定值类型的属性，例如布尔值、数字，甚至是数组或对象。在这种情况下，您应该使用数据绑定强制模板引擎将表达式解释为适当的类型，即使该表达式是一个字面值，且永远不会改变。例如，一个`value.bind="12"`属性将被解释为数字`12`。
- en: 'Similarly, an `options="{ value: 12 }"` attribute will be interpreted as a
    `''{ value: 12 }''` string, while the `options.bind="{ value: 12 }"` attribute
    will be interpreted as an object having a `value` property containing the number
    `12`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '类似地，一个`options="{ value: 12 }"`属性将被解释为一个`''{ value: 12 }''`字符串，而`options.bind="{
    value: 12 }"`属性将被解释为一个包含`value`属性的数字`12`的对象。'
- en: Of course, when data binding to literal values, it is better to use `one-time`
    instead of `bind` in order to reduce the memory footprint of the application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当数据绑定到字面值时，最好使用`one-time`而不是`bind`，以减少应用程序的内存占用。
- en: Using built-in binding context properties
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置绑定上下文属性
- en: 'Every binding contexts expose two properties which can be useful in some scenarios:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绑定上下文都公开了两个可能在某些场景中有用的属性：
- en: '`$this`: A self-referencing property. It contains a reference on the context
    itself. It can be useful, for example, to pass the whole context to a method or
    to inject it in a component during composition.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this`: 一个自引用的属性。它包含对上下文本身的引用。它可能很有用，例如，将整个上下文传递给一个方法，或者在组合时将其注入到组件中。'
- en: '`$parent`: A property that references the parent binding context. It can be
    useful, for example, inside the scope of a `repeat.for` attribute to access a
    property on the parent context that is overridden by the child context. It can
    be chained to go higher up the binding context tree. For example, calling `$parent.$parent.$parent.name`
    will try to access the `name` property of the great-grandparent context.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$parent`: 一个引用父级绑定上下文的属性。它可能很有用，例如，在`repeat.for`属性的作用域内访问被子上下文覆盖的父上下文的一个属性。它可以通过链式调用向上追溯到绑定上下文树更高层。例如，调用`$parent.$parent.$parent.name`将尝试访问曾祖上下文的`name`属性。'
- en: Binding to DOM properties
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定到DOM属性
- en: Some standard DOM properties are exposed as attributes by Aurelia, so they can
    be data-bound.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准DOM属性通过Aurelia暴露为属性，因此它们可以进行数据绑定。
- en: innerhtml
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`innerhtml`'
- en: 'The `innerhtml` attribute can be used to data-bind to the element''s `innerHTML`
    property:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`innerhtml`属性可用于数据绑定到元素的`innerHTML`属性：'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we can imagine that the model's `htmlContent` property will
    contain HTML code, which, being data-bound to the `innerHTML` property of , will
    be displayed inside the `div`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以想象模型的`htmlContent`属性将包含HTML代码，这些代码与`div`的`innerHTML`属性数据绑定，将在`div`内部显示。
- en: However, this HTML is not considered a template, so it won't be interpreted
    by the templating engine. If it contains binding expressions or requires instructions,
    for example, they won't be evaluated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这HTML不被认为是模板，所以它不会被模板引擎解释。如果它包含绑定表达式或需要指令，例如，它们不会被评估。
- en: Displaying user-generated HTML is a well-known security risk, as it could contain
    malicious scripts. It is strongly recommended to sanitize such HTML before displaying
    it to any user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 显示用户生成的HTML是一个众所周知的安全风险，因为它可能包含恶意脚本。强烈建议在向任何用户显示之前对这种HTML进行消毒。
- en: '`aurelia-templating-resources` ships with a simple value converter (we will
    see later in this chapter what a value converter is), named `sanitizeHTML`, which
    serves this purpose. You are, however, strongly encouraged to use a more complete
    sanitizer, such as `sanitize-html`, which can be found at [https://www.npmjs.com/package/sanitize-html](https://www.npmjs.com/package/sanitize-html).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-templating-resources`附带一个简单的值转换器（我们将在本章后面看到值转换器是什么），名为`sanitizeHTML`，它用于这个目的。然而，强烈建议使用更完整的消毒器，如`sanitize-html`，可以在[https://www.npmjs.com/package/sanitize-html](https://www.npmjs.com/package/sanitize-html)找到。'
- en: textcontent
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: textcontent
- en: 'The `textcontent` attribute can be used to data-bind to the element''s `textContent`
    property:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`textcontent`属性可用于数据绑定到元素的`textContent`属性：'
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we can imagine that the model's `text` property will contain
    some text, which, being data-bound to the `textContent` property of `div`, will
    be displayed inside the `div`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以想象模型的`text`属性将包含一些文本，这些文本与`div`的`textContent`属性数据绑定，将在`div`内部显示。
- en: Similarly to `innerhtml`, the text bound to `textcontent` is not considered
    a template, so it won't be interpreted by the template engine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与`innerhtml`类似，绑定到`textcontent`的文本不被认为是模板，所以它不会被模板引擎解释。
- en: 'As mentioned earlier, the `bind` command tries to detect which binding mode
    it should use. As such, if the element''s `contenteditable` attribute is set to
    `true`, `bind` commands on `textcontent`, if any, will use two-way binding:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`bind`命令试图检测它应该使用哪种绑定模式。因此，如果元素的`contenteditable`属性设置为`true`，则`textcontent`上的`bind`命令将使用双向绑定：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the model's `text` property will be bound to the `textContent`
    property of `div` and displayed inside the `div`. Additionally, since the content
    of `div` is editable, any change to this content done by the user will be reflected
    on the model's `text` property.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，模型的`text`属性将被绑定到`div`的`textContent`属性并在`div`内部显示。另外，由于`div`的内容是可编辑的，用户对这部分内容所做的任何更改都将反映在模型的`text`属性上。
- en: style
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: style
- en: 'The `style` attribute can be used to data-bind to the element''s `style` property.
    It can be bound to either a string or an object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`属性可用于数据绑定到元素的`style`属性。它可以绑定到一个字符串或一个对象：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Additionally, the `style` attribute can be used with string interpolation.
    However, because of some technical limitations, it is not supported by Internet
    Explorer. To work around this, and to make sure the application is compatible
    with IE, the `css` alias should be used when using string interpolation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`style`属性可以使用字符串插值。然而，由于一些技术限制，它不支持Internet Explorer。为了解决这个问题，并确保应用程序与IE兼容，在使用字符串插值时应使用`css`别名：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the `div` would have its `color` and `background-color` styles data-bound
    to the model's `color` and `bgColor` properties.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`div`将把其`color`和`background-color`样式与模型的`color`和`bgColor`属性数据绑定。
- en: scrolltop
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: scrolltop
- en: The `scrolltop` attribute can be used to bind to the element's `scrollTop` property.
    Being bound two-way by default, this attribute can be used to either change the
    horizontal scroll position of an element, or to assign its position to a property
    on the context so it can be used.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrolltop`属性可用于绑定到元素的`scrollTop`属性。默认支持双向绑定，该属性可用于更改元素的的水平滚动位置，或者将其位置分配给上下文中的属性以便使用。'
- en: scrollleft
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: scrollleft
- en: The `scrollleft` attribute can be used to bind to the element's `scrollLeft`
    property. Being bound two-way by default, this attribute can be used to either
    change the vertical scroll position of an element, or to assign its position to
    a property on the context so it can be used.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrollleft`属性可以用来绑定到元素的`scrollLeft`属性。默认双向绑定，这个属性可以用来更改元素的垂直滚动位置，或者将其位置分配给上下文中的一个属性以便使用。'
- en: Using built-in behaviors
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置行为
- en: The core library, `aurelia-templating-resources`, provides a set of standard
    behaviors, built on top of `aurelia-templating`, which can be used in any Aurelia
    template.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 核心库`aurelia-templating-resources`提供了一组标准行为，基于`aurelia-templating`构建，可以在Aurelia模板中使用。
- en: show
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: show
- en: 'The `show` attribute controls the visibility of the element, based on the value
    of the expression it is bound to:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`属性根据它所绑定的表达式的值来控制元素的可见性：'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, the `p` element will be visible only when the model's `hasError`
    property is truthy.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只有当模型的`hasError`属性为truthy时，`p`元素才会可见。
- en: This attribute works by injecting a CSS class either in the document head or
    in the nearest ShadowDOM root, and by adding this CSS class on the element whenever
    it should be hidden. This CSS class simply sets the `display` property to `none`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性通过在文档头部或最近的ShadowDOM根中注入CSS类，并在元素应该隐藏时添加这个CSS类来工作。这个CSS类简单地将`display`属性设置为`none`。
- en: hide
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hide
- en: 'This is similar to `show`, but with an inverted condition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`show`类似，但条件是倒置的：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, the `p` element will be hidden when the model's `isValid` property
    is truthy.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当模型的`isValid`属性为truthy时，`p`元素将隐藏。
- en: Other than the inverted condition, this attribute works exactly like `show`
    and uses the same CSS class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了倒置条件之外，这个属性的工作方式与`show`完全一样，并使用相同的CSS类。
- en: if
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if
- en: The `if` attribute is very similar to `show`. The main difference is that, instead
    of simply hiding the element when the bound expression evaluates to a `false`
    value, it completely removes the element from the DOM.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`属性与`show`非常相似。主要区别在于，当绑定的表达式评估为`false`值时，它不是简单地隐藏元素，而是完全将元素从DOM中移除。'
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the `if` attribute being a template controller, it is possible to put
    it directly on a nested `template` element to control the visibility of multiple
    elements:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`if`属性是一个模板控制器，因此可以直接放在嵌套的`template`元素上，以控制多个元素的可见性：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, both the `i` element and the text following it will be removed
    from the DOM when `hasError` is `false`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`hasError`为`false`时，`i`元素及其后面的文本将从DOM中移除。
- en: Actually, when the condition is falsey, the element on which it is, won't be
    just removed from the DOM, its own behaviors and its children's will be unbound.
    This is a very important distinction, as it has major performance implications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当条件为falsey时，它所附加的元素不仅会被从DOM中移除，它自己的行为和其子元素的行为也会被解绑。这是一个非常重要的区别，因为它有重大的性能影响。
- en: For the following example, let's imagine that `some-component` is huge, displays
    lots of data, has many bindings, and is very memory and CPU consuming.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中，假设`some-component`非常大，显示大量数据，有许多绑定，并且非常耗内存和CPU。
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we replace `if` with `show` here, the bindings for the whole component's
    hierarchy would still exist, consuming memory and CPU even when it is not visible.
    When using `if`, the component is unbound when `isVisible` becomes `false`, reducing
    the number of active bindings in the application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里用`show`替换`if`，整个组件层次结构的数据绑定仍然存在，即使它不可见也会消耗内存和CPU。当使用`if`时，当`isVisible`变为`false`，组件将解绑，减少应用程序中的活动绑定数量。
- en: On the other hand, this means that, when the condition becomes truthy, the element
    and its descendants must be re-bound. In a scenario where the condition is often
    toggled on and off, it can be better to use `show` or `hide`. Choosing between
    `if` and `show`/`hide` is mainly a matter of balancing priorities between performance
    and user experience, and should be backed with real performance tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这意味着当条件变为truthy时，元素及其后代必须重新绑定。在条件经常开关的场景中，使用`show`或`hide`可能更好。选择`if`和`show`/`hide`之间的主要问题是平衡性能和用户体验的优先级，并且应该有真实的性能测试支持。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A template controller is an attribute that transforms the element it is on into
    a template. It can then control how this template is rendered. The standard attributes
    `if` and `repeat` are template controllers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 模板控制器是一个属性，它将所作用的元素转换成模板，并控制这个模板的渲染方式。标准的属性`if`和`repeat`是模板控制器。
- en: repeat.for
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: repeat.for
- en: 'The `repeat` attribute, when used with the special `for` binding command, can
    be used to repeat an element for a sequence of values:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`属性与特殊的`for`绑定命令一起使用时，可以用来为一系列值重复一个元素：'
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the `li` element will be repeated and data-bound to each item
    in the `items` array.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`li`元素将被重复并绑定到`items`数组中的每个项目：
- en: Instead of an array, a `Set` object can also be data-bound too.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: instead of an array, a `Set` object can also be data-bound too.
- en: 'Being a template controller, `repeat` actually transforms the element it is
    on into a template. This template is then rendered for each item in the bounded
    sequence. For each item, a child binding context is created, on which the item
    itself is made available using the name at the left of the `of` keyword in the
    binding expression. This means two things: you can name the item variable however
    you want, and you can use it in the context of the item itself:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个模板控制器，`repeat`实际上将所作用的元素转换成一个模板。然后为绑定序列中的每个项目渲染这个模板。对于每个项目，将创建一个子绑定上下文，在该上下文中，通过绑定表达式中`of`关键字左边的名称来使用项目本身。这意味着两件事：您可以随意命名项目变量，而且您可以在项目的上下文中使用它：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, a `li` element will be inserted in the `ul` element for each
    item in the `people` array. For each `li` element, a child context will be created,
    exposing the current item as a `person` property, and an `important` CSS class
    will be set on the `li` if the corresponding `isImportant` property of `person`.
    Each `li` element will contain the `fullName` of its `person`, as text.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`li`元素将被插入到`ul`元素中，为`people`数组中的每个项目。对于每个`li`元素，将创建一个子上下文，将当前项目作为`person`属性暴露出来，如果对应的`person`的`isImportant`属性，那么`li`上会设置一个`important`
    CSS类。每个`li`元素将包含其`person`的`fullName`，作为文本。
- en: 'Additionally, the children contexts created by `repeat` inherit from the surrounding
    context, so any property available outside the `li` element is available inside
    it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由`repeat`创建的子上下文从周围上下文继承，所以`li`元素外的任何可用属性在内部都是可用的：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, the root binding context exposes two properties: a `people` array and `selectedPerson`.
    When each `li` element is rendered, each child context has access to the current
    `person` in addition to the parent context. That''s how the `li` element for `selectedPerson`
    will have the `active` CSS class.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，根绑定上下文暴露了两个属性：一个`people`数组和`selectedPerson`。当每个`li`元素被渲染时，每个子上下文都可以访问当前的`person`以及父上下文。这就是`li`元素对于`selectedPerson`将具有`active`
    CSS类的原因。
- en: 'The `repeat` attribute uses one-way binding by default, which means that the
    bounded array will be observed, and any change made to it will be reflected on
    the view:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`属性默认使用单向绑定，这意味着绑定数组将被观察，对其进行的任何更改都将反映在视图中：'
- en: If an item is added to the array, the template will be rendered into an additional
    view and inserted at the appropriate position in the DOM.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向数组中添加一个项目，模板将被渲染成一个额外的视图，并插入到DOM中的适当位置。
- en: If an item is removed from the array, the corresponding view element will be
    removed from the DOM.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从数组中删除一个项目，相应的视图元素将被从DOM中删除。
- en: Binding to a map
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定到地图
- en: 'The `repeat` attribute is able to work with `map` objects, using a slightly
    different syntax:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`属性能够与`map`对象一起使用，使用稍微不同的语法：'
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the `repeat` attribute will create, for each entry in the `map`, a child
    context having `key` and a `value` properties, respectively matching the `map`
    entry's `key` and `value`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`repeat`属性将为`map`中的每个条目创建一个分别具有`key`和`value`属性的子上下文，分别与`map`条目的`key`和`value`匹配。
- en: It is important to remember that this syntax works only for `map` objects. In
    the previous example, if `map` were anything else but a `Map` instance, the `key`
    and `value` properties wouldn't be defined on the child binding context.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，这种语法只适用于`map`对象。在前一个示例中，如果`map`不是`Map`实例，那么在子绑定上下文中就不会定义`key`和`value`属性。
- en: Repeat n times
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复n次
- en: 'The `repeat` attribute is also able to repeat a template a given number of
    times, using the standard syntax, when binding to a number value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`属性还可以在绑定到数值时使用标准语法重复一个模板给定次数：'
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, assuming the `pageCount` is a number, the `li` element will
    be repeated a number of times equal to `pageCount`, with `i` going from `0` to
    `pageCount - 1` inclusively.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设 `pageCount` 是一个数字，`li` 元素将被重复多次，次数等于 `pageCount`，`i` 从 `0` 到 `pageCount
    - 1` 包括在内。
- en: Repeating templating
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复模板
- en: 'If what needs to be repeated is composed of multiple elements without a single
    container for each item, `repeat` can be used on a `template` element:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要重复的元素由多个没有每个项目单一容器的元素组成，可以在 `template` 元素上使用 `repeat`：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the rendered DOM will be a `div` element containing alternating `i` and
    `p` elements.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，渲染后的 DOM 是一个包含交替 `i` 和 `p` 元素的 `div` 元素。
- en: Contextual variables
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文变量
- en: 'In addition to the current item itself, `repeat` adds other variables to the
    child binding context:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当前项目本身，`repeat` 还在子绑定上下文中添加了其他变量：
- en: '`$index`: The index of the item in the array'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$index`：项目在数组中的索引'
- en: '`$first`: `true` if the item is the first in the array; `false` otherwise'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$first`：如果项目是数组的第一个，则为 `true`；否则为 `false`'
- en: '`$last`: `true` if the item is the last in the array; `false` otherwise'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$last`：如果项目是数组的最后一个，则为 `true`；否则为 `false`'
- en: '`$even`: `true` if the item''s index is an even number; `false` otherwise'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$even`：如果项目的索引是偶数，则为 `true`；否则为 `false`'
- en: '`$odd`: `true` if the item''s index is an odd number; `false` otherwise'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$odd`：如果项目的索引是奇数，则为 `true`；否则为 `false`'
- en: The with attribute
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`with` 属性'
- en: The `with` attribute creates a child binding context using the expression it
    is bound to. It can be used to re-scope part of a template, to prevent long access
    paths.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 属性通过它绑定的表达式创建一个子绑定上下文。它可以用来重新作用域模板的一部分，以防止访问路径过长。'
- en: 'For example, the following template does not use `with`, and `person` is traversed
    multiple times when its properties are accessed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下模板没有使用 `with`，在访问其属性时 `person` 被多次遍历：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By re-scoping the top `div` element to `person`, the access to its properties
    can be simplified:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将顶层的 `div` 元素重新作用域为 `person`，可以简化对其属性的访问：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding example is short, but you can imagine how a bigger template can
    benefit from this.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子很短，但你可以想象一个更大的模板如何从中受益。
- en: Additionally, since `with` creates a child context, all variables available
    to the outer scope will be accessible inside the inner scope.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 `with` 创建了一个子上下文，外层作用域中所有可用的变量都将可在内层作用域中访问。
- en: The focus attribute
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 焦点属性
- en: The `focus` attribute can be used to data-bind an element's ownership of the
    document's focus to an expression. It uses two-way binding by default, which means
    that the variable it is bound to will be updated when the element gains or loses
    `focus`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`focus` 属性可用于将元素的所有权与文档的焦点绑定到表达式。它默认使用双向绑定，这意味着当元素获得或失去 `focus` 时，它所绑定的变量将被更新。'
- en: 'The following code snippet is an excerpt of `samples/chapter-3/binding-focus`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段摘自 `samples/chapter-3/binding-focus`：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the previous example, the `input` will get focused upon rendering if `hasFocus`
    is `true`. When `hasFocus` changes to a `false` value, the `input` will lose `focus`.
    Additionally, if the user gives `focus` to the `input`, `hasFocus` will be set
    to `true`. Similarly, if the user moves away from the `input`, `hasFocus` will
    be set to `false`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 previous example，如果 `hasFocus` 是 `true`，则在渲染时 `input` 将会获得焦点。当 `hasFocus`
    变为 `false` 值时，`input` 将会失去 `focus`。此外，如果用户将 `focus` 给予 `input`，`hasFocus` 将被设置为
    `true`。类似地，如果用户将焦点从 `input` 移开，`hasFocus` 将被设置为 `false`。
- en: The compose element
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合元素
- en: Composition is the action of instantiating a component and inserting it in a
    view. The `aurelia-templating-resources` library exports a `compose` element,
    allowing us to dynamically compose a component inside a view.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是将组件实例化并插入视图中的动作。`aurelia-templating-resources` 库导出一个 `compose` 元素，允许我们在视图中动态组合组件。
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code snippets in the following sections are excerpts of `samples/chapter-3/composition`.
    While you read this section, you can run the sample application in parallel so
    you can view live examples of composition.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节中的代码片段摘自 `samples/chapter-3/composition`。在阅读本节时，你可以并行运行示例应用程序，这样你就可以查看组合的实时示例。
- en: Rendering a view-model
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染视图模型
- en: 'A component can be composed using the path of the JS file exporting its view-model:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以通过引用其视图模型的 JS 文件路径来组合：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, when rendered, the `compose` element will load the `some-component` view-model,
    instantiate it, locate its template, render the view, and insert it in the DOM.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当渲染时，`compose` 元素将加载 `some-component` 的视图模型，实例化它，定位其模板，渲染视图，并将其插入到 DOM 中。
- en: 'Of course, the `view-model` attribute can be bound to or use string interpolation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`view-model`属性可以绑定或使用字符串插值：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, the `compose` element will display a component sitting inside
    the `widgets` directory, based on the value of the `currentWidgetType` property
    on the current binding context. Of course, this means that compose will swap the
    component when `currentWidgetType` changes (unless a one-time binding is used).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`compose`元素将根据当前绑定上下文中的`currentWidgetType`属性的值，显示位于`widgets`目录中的组件。当然，这意味着当`currentWidgetType`发生变化时，compose将交换组件（除非使用了一次性绑定）。
- en: 'Additionally, the `view-model` attribute can be bound to an instance of a view-model:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`view-model`属性可以绑定到视图模型的实例：
- en: '`src/some-component.js`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/some-component.js`'
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here a component imports and instantiates the view-model of another component.
    In its template, the `compose` element can then be bound directly to the instance
    of `AnotherComponent`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个组件导入并实例化了另一个组件的视图模型。在其模板中，`compose`元素可以直接绑定到`AnotherComponent`的实例：
- en: '`src/some-component.html`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/some-component.html`'
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Of course, this means that, if `anotherComponent` is assigned a new value, the
    `compose` element will react accordingly and replace the previous component's
    view with the new one.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着，如果`anotherComponent`被分配了一个新值，`compose`元素将相应地反应，并用新的一个替换掉之前的组件视图。
- en: Passing activation data
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递激活数据
- en: When rendering a component, the composition engine will try to call an `activate`
    callback method on the component, if it exists. Similar to the router's screen
    activating life cycle methods, this method can be implemented by components so
    they can act when they are rendered. It can also be used to inject activation
    data into the component.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染组件时，组合引擎将尝试调用组件上存在的`activate`回调方法。与路由器的屏幕激活生命周期方法类似，这个方法可以被组件实现，以便在它们被渲染时可以行动。它还可以用来将激活数据注入组件。
- en: The `compose` element also supports a `model` attribute. This attribute's value
    will be passed to the component's `activate` callback method, if any.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose`元素也支持`model`属性。如果有的话，这个属性的值将被传递给组件的`activate`回调方法。'
- en: 'Let''s imagine the following component:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下以下的组件：
- en: '`src/some-component.js`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/some-component.js`'
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When composed without any `model` attribute, this component would display `<p>Activation
    data: none</p>`. However, it would display `<p>Activation data: Some parameter</p>`
    when composed like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '当没有任何`model`属性时，这个组件将显示`<p>Activation data: none</p>`。然而，当像这样组成时，它会显示`<p>Activation
    data: Some parameter</p>`：'
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Of course, `model` can use string interpolation or can be data-bound too, so
    a complex object can be passed to the component's `activate` method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`model`可以使用字符串插值，也可以进行数据绑定，因此可以将复杂对象传递给组件的`activate`方法。
- en: When used with a component that does not implement the `activate` method, the
    `model` attribute's value is simply ignored.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当与未实现`activate`方法的组件一起使用时，`model`属性的值将被直接忽略。
- en: Rendering a template
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染模板
- en: 'The `compose` element can also simply render a template, using the current
    binding context:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose`元素还可以简单地渲染一个模板，使用当前的绑定上下文：'
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, `some-template.html` would be rendered into a view using the surrounding
    binding context. This means that any variable available around the `compose` element
    would also be available to `some-template.html`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`some-template.html`将使用周围的绑定上下文渲染成一个视图。这意味着`compose`元素周围的任何变量也将对`some-template.html`可用。
- en: When used with the `view-model` attribute, the `view` attribute will override
    the component's default template. It can be useful to reuse a view-model's behaviors
    with a different template.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`view-model`属性一起使用时，`view`属性将覆盖组件的默认模板。它可以在使用不同模板时复用视图模型的行为。
- en: Value converters
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值转换器
- en: In the data-binding world, it is fairly common to have to transform data between
    the view-model and the view during display, or to convert back user inputs when
    a two-way binding updates the model.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据绑定的世界里，经常需要将数据在视图模型和视图之间进行转换，或者在双向绑定更新模型时将用户输入转换回来。
- en: One of the ways this can be done is to use computed properties in the view-model
    to perform transformation of another property's value back and forth. The downside
    of this solution is that it is not reusable across view-models.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种方法的一种方式是在视图模型中使用计算属性，以执行另一个属性值的来回转换。这种解决方案的缺点是，它不能跨视图模型复用。
- en: In Aurelia, value converters address this need. A value converter is an object
    that can be plugged around a binding expression. Each time the binding needs to
    either evaluate the expression to render its result or update the model in the
    case of a two-way binding, the converter acts as an interceptor and can convert
    the value.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在Aurelia中，值转换器解决了这个需求。值转换器是一个可以插入绑定表达式的对象。每次绑定需要评估表达式以渲染其结果，或者在双向绑定情况下更新模型时，转换器都作为拦截器，可以转换值。
- en: Using value converters
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值转换器
- en: Value converters are view resources. Like all view resources in Aurelia, in
    order to be used in a template, it must be loaded, either globally by a `configure`
    function or locally by a `require` element.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器是视图资源。和Aurelia中的所有视图资源一样，为了在模板中使用，它必须被加载，要么通过一个`configure`函数全局加载，要么通过一个`require`元素局部加载。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See the *Templating basics* section if you don't remember how to load a resource.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不记得如何加载资源，请参阅*模板基础*部分。
- en: 'In a template, a value converter can be wrapped around a data binding expression
    using the pipe (`|`) operator:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，可以使用管道（`|`）操作符将值转换器包裹在一个数据绑定表达式周围：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we use the built-in `sanitizeHTML` value converter in the binding
    of the `innerhtml` attribute. This value converter will be piped in the binding
    process, and will clear any potentially dangerous elements from the bound value.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了内置的`sanitizeHTML`值转换器来绑定`innerhtml`属性。这个值转换器会在绑定过程中被管道使用，并将会清除绑定值中的任何潜在危险元素。
- en: Value converters don't actually change the binding context value they operate
    on. They simply act as interceptors and provide a replacement value for the binding
    to use for rendering.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器实际上并不改变它们操作的绑定上下文值。它们仅仅作为拦截器，为绑定提供了一个用于渲染的替代值。
- en: Passing a parameter
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递一个参数
- en: Value converters can accept parameters, in which case they must be specified
    in the binding expression using the colon (`:`) separator.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器可以接受参数，在这种情况下，它们必须在绑定表达式中使用冒号（`:`）分隔符指定。
- en: 'Let''s imagine a value converter named `truncate`, which acts on a string value
    and additionally expects a `length` parameter. During evaluation, it truncates
    the provided value to the provided length, if longer, and returns the result.
    Here''s how this converter would be used:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个名为`truncate`的值转换器，它对字符串值起作用，同时期望一个`length`参数。在评估期间，它将提供的值截断到提供的长度（如果更长），并返回结果。这个转换器将如何使用：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, the `title` will be truncated to 20 characters if it is longer. Otherwise,
    it will be displayed unchanged.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`title`超过20个字符，它将被截断到20个字符。否则，它将保持不变。
- en: Passing multiple parameters
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递多个参数
- en: 'Multiple parameters can be passed to a value converter. Simply keep using the
    colon (`:`) separator. For example, if `truncate` could accept a second parameter
    being the ellipsis appended to the truncated string, it would be passed like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向值转换器传递多个参数。只需继续使用冒号（`:`）分隔符。例如，如果`truncate`可以接受第二个参数，即在截断后的字符串后添加省略号，它将像这样传递：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Passing context variables as parameters
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递上下文变量作为参数
- en: 'Variables from the binding context can also be used as parameters, in which
    case the binding expression will be re-evaluated when any of those variables change.
    For example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定上下文中的变量也可以作为参数使用，在这种情况下，当这些变量中的任何一个发生变化时，绑定表达式将会重新评估。例如：
- en: '`some-component.js`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`some-component.js`'
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, the value of the string interpolation will depend on the view-model's
    `title` and `maxTitleLength` properties. Whenever one of them changes, the expression
    will be re-evaluated, the `truncate` converter will be re-executed, and the view
    will be updated.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，字符串插值的价值取决于视图模型的`title`和`maxTitleLength`属性。每当它们中的一个发生变化时，表达式将会重新评估，`truncate`转换器将会重新执行，视图将会更新。
- en: Chaining
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 串联
- en: 'Value converters can be chained. In such a case, the value is piped through
    the chain of converters, from left to right when evaluating the expression value,
    and from right to left when updating the model:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器可以被串联。在这种情况下，值通过转换器链进行管道，当评估表达式值时从左到右，当更新模型时从右到左：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, the `title` would first be truncated, then capitalized before
    being rendered.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`title`首先会被截断，然后首字母大写后渲染。
- en: Implementing a value converter
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个值转换器
- en: 'A value converter is a class that must implement at least one of the following
    methods:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器是一个必须实现至少以下方法之一的类：
- en: '`toView(value: any [, ...args]): any`: This is called after evaluating the
    bound expression, before rendering the result. The `value` parameter is the value
    of the bound expression. The method must return the converted value, which will
    either be passed to the next converter or rendered on the view.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toView(value: any [, ...args]): any`：在评估绑定表达式后、渲染结果之前调用。`value`参数是绑定表达式的值。该方法必须返回转换后的值，它将传递给下一个转换器或渲染到视图中。'
- en: '`fromView(value: any [, ...args]): any`: This is called when updating the model
    with the value of the binding target, before assigning the value to the model.
    The `value` parameter is the value of the binding target. The method must return
    the converted value, which will either be passed to the next converter or assigned
    to the model.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromView(value: any [, ...args]): any`：当更新模型的绑定目标值时调用，在将值分配给模型之前。`value`参数是绑定目标的值。该方法必须返回转换后的值，它将传递给下一个转换器或分配给模型。'
- en: 'If the value converter is used with parameters, they will be passed as additional
    parameters to the methods. For example, let''s imagine the following usage of
    a value converter:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值转换器使用参数，它们将以附加参数的形式传递给方法。例如，让我们想象一下值转换器的以下使用方式：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In such a case, the `truncate` value converter''s `toView` method is expected
    to look like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`truncate`值转换器的`toView`方法预计会像这样：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, the `truncate` value converter's `toView` method expects, in addition
    to the `value` on which it applies, a `length` parameter. It also accepts a third
    parameter named `ellipsis`, which has a default value. If the provided `value`
    is longer than the provided `length`, the method will truncate it, append the
    `ellipsis` to it, and then return this new value. If the `value` is not too long,
    it simply returns it unchanged.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`truncate`值转换器的`toView`方法除了它应用的`value`之外，还期望有一个`length`参数。它还接受一个名为`ellipsis`的第三个参数，有一个默认值。如果提供的`value`比提供的`length`长，该方法将截断它，附上`ellipsis`，然后返回这个新值。如果`value`不太长，它简单地返回它不变。
- en: By default, Aurelia considers that any class loaded as a resource whose name
    ends with `ValueConverter` is a value converter. The name of the value converter
    will be the class name, without the `ValueConverter` suffix, camel-cased. For
    example, a class named `OrderByValueConverter` will be made available to templates
    as the `orderBy` value converter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Aurelia认为任何以`ValueConverter`结尾的作为资源加载的类都是一个值转换器。值转换器的名称将是类名，不包含`ValueConverter`后缀，驼峰命名。例如，一个名为`OrderByValueConverter`的类将作为`orderBy`值转换器提供给模板。
- en: 'However, when creating a converter that will be included inside a reusable
    plugin or library, you should not rely on this convention. In such a case, the
    class should be decorated with the `valueConverter` decorator:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当创建一个将包含在可重用插件或库中的转换器时，你不应依赖这个约定。在这种情况下，类应该用`valueConverter`装饰器装饰：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This way, even if your plugin's users change the default naming convention,
    your class will still be identified by Aurelia as a value converter.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，即使你的插件用户改变了默认的命名约定，你的类仍然会被Aurelia识别为值转换器。
- en: Binding behaviors
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定行为
- en: Binding behaviors are view resources, similar to value converters in that they
    are applied to expressions. They, however, intercept the binding operation itself
    and have access to the whole binding instruction, so they can modify it. This
    opens many possibilities.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定行为是视图资源，与值转换器相似，它们应用于表达式。然而，它们拦截绑定操作本身并访问整个绑定说明，因此可以修改它。这开辟了许多可能性。
- en: Using binding behaviors
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用绑定行为
- en: 'To decorate a binding expression with a binding behavior, it must be appended
    at the end of the expression, using the `&` separator:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个绑定表达式添加绑定行为，它必须紧跟在表达式的末尾，使用`&`分隔符：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Of course, just like value converters, binding behaviors can be chained, in
    which case they will be executed from left to right:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，就像值转换器一样，绑定行为可以链接，在这种情况下，它们将从左到右执行：
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the expression also uses value converters, the binding behaviors must come
    after them:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式还使用值转换器，绑定行为必须放在它们之后：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Passing parameters
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'Just like value converters, binding behaviors can be passed arguments, using
    the same syntax:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 就像值转换器一样，绑定行为也可以传递参数，使用相同的语法：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The behavior and its parameters must be separated by a colon (:), and the parameters
    must be separated from each other in the same way:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 行为及其参数必须用冒号（:）分隔，参数之间也必须以同样的方式分隔：
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Built-in binding behaviors
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置绑定行为
- en: The `aurelia-templating-resources` library ships with many binding behaviors.
    Let's discover them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-templating-resources`库附带了许多绑定行为。让我们去发现它们。'
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code snippets in the following sections are excerpts from `samples/chapter-3/binding-behaviors`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分中的代码片段摘自`samples/chapter-3/binding-behaviors`。
- en: oneTime
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`oneTime`'
- en: 'The `oneTime` behavior makes a binding go one-way only. It can be used on string
    interpolation expressions:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`oneTime`行为使绑定变为单向 only。它可以用在字符串插值表达式上：'
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, the view-model's `quote` property won't be observed, so the text won't
    be updated if it changes.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，视图模型的`quote`属性不会被观察，所以如果它发生变化，文本不会被更新。
- en: 'Additionally, Aurelia ships with binding behaviors for the other binding modes:
    `oneWay` and `twoWay`. They can be used exactly like `oneTime`.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Aurelia还附带了其他绑定模式的绑定行为：`oneWay`和`twoWay`。它们可以像`oneTime`一样使用。
- en: throttle
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节流
- en: The `throttle` binding behavior can be used to limit the rate at which the view-model
    is updated for two-way bindings or the rate at which the view is updated for one-way
    bindings. Put another way, a binding that is throttled by 500 milliseconds will
    wait at least 500 milliseconds between two update notifications.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttle`绑定行为可用于限制视图模型更新的速率对于双向绑定或视图更新的速率对于单向绑定。换句话说，一个被500毫秒节流的绑定将至少在两个更新通知之间等待500毫秒。'
- en: '[PRE55]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we see an example of those two scenarios. The first `throttle` is applied
    on a string interpolation expression, which is one-way by default, and will throttle
    the update of the text in the view when the view-model's `title` property changes.
    The second one is applied on the binding of a `value` attribute of `input`, which
    is two-way by default, and will throttle the update of the view-model's `value`
    property when the `value` changes for `input`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了这两个场景的例子。第一个`throttle`应用于字符串插值表达式，默认是单向的，当视图模型的`title`属性发生变化时，将节流视图中的文本更新。第二个应用于`input`元素的`value`属性的绑定，默认是双向的，当`input`的`value`发生变化时，将节流视图模型的`value`属性的更新。
- en: The `throttle` behavior can take as an argument the time gap between updates,
    expressed as milliseconds. This argument can, however, be omitted, and 200 milliseconds
    will be used by default.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttle`行为可以接受一个参数，表示更新之间的时差，以毫秒表示。然而，这个参数可以省略，默认使用200毫秒。'
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we have the same example as before, but the bindings will be throttled
    by 800 milliseconds.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个与之前相同的示例，但是绑定将被800毫秒节流。
- en: 'Events can also be throttled. Whether it is used in a `trigger` or a `delegate`
    binding command, the dispatching of events to the view-model will be throttled
    accordingly:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 事件也可以被节流。无论它是在`trigger`还是`delegate`绑定命令中使用，将事件分发到视图模型的节流将相应地节流：
- en: '[PRE57]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, the handler of the `div` element's `mousemove` event will assign the `Event`
    object to the view-model's `position` property. However, this handler will be
    throttled, so the `position` will be updated only once every 800 milliseconds.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`div`元素的`mousemove`事件的处理程序将事件对象分配给视图模型的`position`属性。然而，这个处理程序将被节流，所以`position`将每800毫秒更新一次。
- en: You can see some examples of the `throttle` behavior in `samples/chapter-3/binding-behaviors`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`samples/chapter-3/binding-behaviors`中看到`throttle`行为的一些示例。
- en: debounce
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`debounce`'
- en: The `debounce` binding behavior is also a rate-limiting behavior. It makes sure
    that no update is sent until a given delay has passed without any changes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounce`绑定行为也是一种速率限制行为。它确保在给定延迟过去且没有更改的情况下不发送任何更新。'
- en: 'A common use case is a search input that automatically triggers calls to a
    search API. To call such an API after every keystroke would be inefficient and
    resource-consuming at best. It would be much better to wait a given time interval
    after the user stopped typing before calling the search API. This can be done
    using `debounce`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是一个搜索输入，它会自动触发搜索API的调用。在用户每次输入后调用这样的API将是效率低下且消耗资源的。最好在用户停止输入后等待一段时间再调用搜索API。这可以通过使用`debounce`来实现：
- en: '[PRE58]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, the view-model would observe the `searchTerms` property and
    trigger a search each time it changes. The `debounce` behavior would ensure that
    `searchTerms` gets updated only after the user has stopped typing for 200 milliseconds.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，视图模型将观察`searchTerms`属性，并在每次更改时触发搜索。`debounce`行为将确保在用户停止输入200毫秒后`searchTerms`才得到更新。
- en: 'This means that, when applied to a two-way binding, `debounce` limits the update
    rate of the view-model. However, when applied to a one-way binding, it limits
    the update rate of the view:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，当应用于双向绑定时，`debounce`限制了视图模型的更新速率。然而，当应用于单向绑定时，它限制了视图的更新速率：
- en: '[PRE59]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, `debounce` is applied to the string interpolation expression, so the displayed
    text is updated only after the user has stopped typing in the input for 500 milliseconds.
    The distinction is important here. The `text` property will still be updated in
    real time. Only the string interpolation binding will be delayed.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`debounce`应用于字符串插值表达式，所以只有当用户在输入中停止打字500毫秒后，显示的文本才会更新。这里的区别很重要。`text`属性仍然会实时更新。只有字符串插值绑定会被延迟。
- en: 'Just like `throttle`, `debounce` can be applied to events, using either the
    trigger or delegate binding commands:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`throttle`一样，`debounce`也可以应用于事件，使用触发器或委托绑定命令：
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, the handler of the `div` element's `mousemove` event will assign the `Event`
    object to the view-model's `position` property. However, this handler will be
    debounced, so the `position` will be updated only when the mouse has stopped moving
    on the `div` for 800 milliseconds.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`div`元素的`mousemove`事件的处理程序将事件对象分配给视图模型的`position`属性。然而，这个处理程序将被防抖，所以只有在鼠标在`div`上停止移动800毫秒后，`position`才会更新。
- en: You probably noticed in the previous examples that, like `throttle`, `debounce`
    can take the delay, expressed in milliseconds, as a parameter. When omitted, the
    delay also defaults to 200 milliseconds.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在之前的例子中，`throttle`和`debounce`都可以接受延迟，以毫秒表示，作为参数。省略时，延迟也默认为200毫秒。
- en: updateTrigger
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: updateTrigger
- en: The `updateTrigger` binding behavior is used to change the events triggering
    a view-model update. Implicitly, this means that it can be used only with two-way
    bindings, and only on attributes of elements supporting two-way binding, such
    as `value` of `input`, `value` of `select`, or the `textcontent` attribute of
    a `div` with `contenteditable="true"`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateTrigger`绑定行为用于改变触发视图模型更新的事件。这意味着它只能与双向绑定一起使用，只能用于支持双向绑定的元素的属性，如`input`的`value`、`select`的`value`或具有`contenteditable="true"`的`div`的`textcontent`属性。'
- en: 'When used, it expects the names of the events as parameters, and requires at
    least one:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时，它期望事件名称作为参数，至少需要一个：
- en: '[PRE61]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, the view-model's `title` property will be updated each time the `input`
    triggers a `change` or `input` event.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，视图模型的`title`属性将在每次`input`触发`change`或`input`事件时更新。
- en: Actually, the `change` and `input` events are the default triggers in Aurelia.
    In addition to those two, the `blur`, `keyup`, and `paste` events can also be
    used as triggers.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`change`和`input`事件在Aurelia中是默认的触发器。除了这两个，`blur`、`keyup`和`paste`事件也可以用作触发器。
- en: signal
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: signal
- en: The signal binding behavior allows programmatically triggering a binding update.
    This is especially useful when the bound value is not observable, or must be refreshed
    at specific time intervals.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 信号绑定行为允许程序化地触发绑定更新。这对于不可观察的绑定值或在特定时间间隔内必须刷新时特别有用。
- en: Let's imagine a value converter named `timeInterval` that takes a `Date` object
    in, calculates the interval between the input and the current date and time, and
    outputs this time interval as a user-friendly string, such as `a minute ago`,
    `in 2 hours`, or `3 years ago`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个名为`timeInterval`的值转换器，它接收一个`Date`对象，计算输入日期和当前日期之间的时间间隔，并将这个时间间隔输出为用户友好的字符串，如`a
    minute ago`、`in 2 hours`或`3 years ago`。
- en: 'Since the result depends on the current date and time, it will quickly get
    outdated if it is not refreshed periodically. The `signal` behavior can be used
    to do that:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果取决于当前日期和时间，如果不定期刷新，它将很快过时。可以使用`signal`行为来实现这一点：
- en: '`src/some-component.html`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/some-component.html`'
- en: '[PRE62]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this template, `lastUpdatedAt` is displayed using the `timeInterval` value
    converter, and its binding is decorated by a `signal` named `now`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，`lastUpdatedAt`使用`timeInterval`值转换器显示，其绑定被一个名为`now`的`signal`装饰。
- en: '`src/some-component.js`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/some-component.js`'
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the view-model, after injecting a `BindingSignaler` instance and storing
    it in an instance variable, the `activate` method creates an interval loop that
    will trigger a signal named `now` every 5 seconds. Each time the signal is triggered,
    the string interpolation binding in the template will be updated, making the displayed
    time interval at the most 5 seconds later than the current time. Of course, to
    prevent memory leaks, the interval handle is stored in an instance variable and
    destroyed using the `clearInterval` function when the component is deactivated.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图模型中，在注入一个`BindingSignaler`实例并将其存储在实例变量中后，`activate`方法创建一个间隔循环，每5秒触发一个名为`now`的信号。每次触发信号时，模板中的字符串插值绑定都将更新，使得显示的时间间隔最多比当前时间晚5秒。当然，为了防止内存泄漏，间隔处理程序存储在实例变量中，并在组件停用时使用`clearInterval`函数销毁。
- en: 'Multiple signal names can be passed as parameters to a `signal`. In such a
    case, the binding will be refreshed each time any one of the signals is triggered:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将多个信号名称作为参数传递给`signal`。在这种情况下，每次触发任何一个信号时，绑定都会刷新：
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Additionally, it can only be used on string interpolations and property bindings;
    it makes no sense to signal a `trigger`, a `call`, or a `ref` expression.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它只能用于字符串插值和属性绑定；信号一个`trigger`、`call`或`ref`表达式是没有意义的。
- en: Computed properties
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性
- en: Efficient data binding is a complex matter. Aurelia's data binding library is
    adaptive and uses a variety of techniques to observe view-models and DOM elements
    as efficiently as possible. It leverages things such as DOM events and the Reflect
    API when possible before falling back on dirty checking when no other strategy
    is applicable.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的数据绑定是一个复杂的问题。Aurelia的数据绑定库是适应性强的，并使用多种技术尽可能高效地观察视图模型和DOM元素。它在可能的情况下利用DOM事件和Reflect
    API，在没有其他策略适用时才回退到脏检查。
- en: Note
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Dirty checking is an observation mechanism that uses a timeout loop to recurrently
    evaluate an expression, check if its value has changed since its last evaluation,
    and update the associated binding if it has.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 脏检查是一种使用超时循环反复评估表达式的观察机制，检查其值自上次评估以来是否发生变化，如果发生变化，则更新相关绑定。
- en: 'One of the scenarios where dirty checking is often used is computed properties.
    Take this example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是脏检查经常使用的一种场景。看这个例子：
- en: '[PRE65]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When applying a binding to `fullName`, Aurelia has no way to know how its value
    is calculated, and must rely on dirty checking to detect changes. In this example,
    the getter for `fullName` is quick to evaluate, so dirty checking it is absolutely
    fine.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当对`fullName`应用绑定时，Aurelia无法知道其值是如何计算的，必须依赖脏检查来检测变化。在这个例子中，`fullName`的获取器评估速度很快，所以使用脏检查是绝对可以的。
- en: 'However, some computed properties may end up doing heavy work: searching or
    aggregating data from a large array, for example. In such a scenario, relying
    on dirty checking means that the property will be evaluated several times every
    second, which can overburden the browser.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些计算属性可能会最终执行重工作：例如从一个大型数组中搜索或聚合数据。在这种情况下，依赖脏检查意味着属性将每秒评估几次，这可能会使浏览器过载。
- en: computedFrom
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算来自
- en: The `aurelia-binding` library exports a `computedFrom` decorator that can be
    used to solve this issue. When decorating a computed property, it informs the
    binding system of the dependencies on which the property relies to compute its
    result.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-binding`库导出一个`computedFrom`装饰器，可以用来解决这个问题。在装饰一个计算属性时，它通知绑定系统属性依赖于哪些依赖项来计算其结果。'
- en: '[PRE66]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, to observe `matchCount`, the binding system would observe `searchTerm`.
    Only when it changes would it re-evaluate `matchCount`. This is much more efficient
    than evaluating the property multiple times every second to check if its result
    has changed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了观察`matchCount`，绑定系统会观察`searchTerm`。只有当它发生变化时，它才会重新评估`matchCount`。这比每秒多次评估属性的结果以检查其是否已更改要高效得多。
- en: 'The `computedFrom` decorator accepts access paths as dependencies, which are
    relative to the instance of the class it is on:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`computedFrom`装饰器接受访问路径作为依赖项，这些路径相对于它所在的类的实例是相对的：'
- en: '[PRE67]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we can see that `matchCount` depends on the `searchTerm` property of the
    object stored as the view-model's `model` property.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`matchCount`依赖于作为视图模型`model`属性存储的对象的`searchTerm`属性。
- en: Of course, it expects at least one dependency to be passed as a parameter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它期望至少有一个依赖项作为参数传递。
- en: 'The `computedFrom` decorator observes properties, or paths. It is not able
    to observe the content of an array. This means that the following example wouldn''t
    work:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`computedFrom`装饰器观察属性或路径。它无法观察数组的内容。这意味着以下示例将无法工作：'
- en: '[PRE68]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, if `items` gets an item added or removed, `computedFrom` won't detect
    it and won't re-evaluate `matchCount`. The only thing it can detect is whether
    a whole new array is assigned to the `items` property.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`items`得到一个项目的添加或删除，`computedFrom`不会检测到它，也不会重新评估`matchCount`。它能检测到的唯一情况是一个全新的数组是否被分配给`items`属性。
- en: The `computedFrom` decorator is useful in very specific cases. It should not
    replace value converters, as those are the preferred way of transforming data.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`computedFrom`装饰器在非常特定的情况下很有用。它不应该替代值转换器，因为那些是转换数据的首选方式。'
- en: Fetching data from an endpoint
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从端点获取数据
- en: The Fetch API
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fetch API
- en: The Fetch API has been designed for fetching resources, including over the network.
    At the time of writing, its specification, although really promising, has still
    not been approved. However, many modern browsers such as Chrome, Edge, and Firefox
    already support it. For the others, a polyfill is required.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API已被设计用于获取资源，包括通过网络。在撰写本文时，尽管其规范非常有前途，但仍未获得批准。然而，许多现代浏览器如Chrome、Edge和Firefox已经支持它。对于其他浏览器，需要一个polyfill。
- en: The Fetch API relies on the notions of requests and responses. This allows for
    interception pipelines that can modify requests before they are sent and responses
    when they are received. It makes working with things such as authentication and
    CORS much easier.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API依赖于请求和响应的概念。这允许拦截管道在发送之前修改请求和接收时修改响应。它使得处理诸如认证和CORS之类的事情变得更容易。
- en: 'In the following sections, the terms `Request` and `Response` refer to the
    Fetch API''s classes. The Mozilla developer network has extensive documentation
    about this API: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，术语`Request`和`Response`指的是Fetch API的类。Mozilla开发者网络有关于这个API的详尽文档：[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。
- en: Using the Fetch client
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Fetch客户端
- en: Aurelia's Fetch client is a wrapper around the native or polyfilled Fetch API.
    It supports default request configuration, along with a pluggable interception
    mechanism. It consists of a class named `HttpClient`. This class exposes methods
    to fetch resources over HTTP.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia的Fetch客户端是一个围绕原生或polyfilled Fetch API的包装器。它支持默认请求配置，以及可插拔的拦截机制。它由一个名为`HttpClient`的类组成。这个类暴露了通过HTTP获取资源的方法。
- en: Configuration
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'The `HttpClient` class has a `configure` method. It expects as a parameter
    a callback function receiving a configuration object, which exposes methods that
    can be used to configure the client:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`类有一个`configure`方法。它期望的参数是一个回调函数，该函数接收一个配置对象，该对象暴露了可以用来配置客户端的方法：'
- en: '`withBaseUrl(baseUrl: string)`: This sets the base URL for the client. All
    requests to relative URLs will be made relative to this URL.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withBaseUrl(baseUrl: string)`：这为客户端设置了基础URL。所有相对URL的请求都将相对于这个URL进行。'
- en: '`withDefaults(defaults: RequestInit)`: This sets the default properties passed
    to the `Request` constructor.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withDefaults(defaults: RequestInit)`：这设置了传递给`Request`构造函数的默认属性。'
- en: '`withInterceptor(interceptor: Interceptor)`: This adds an `Interceptor` object
    to the interception pipeline.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withInterceptor(interceptor: Interceptor)`：这为拦截管道添加了一个`Interceptor`对象。'
- en: '`rejectErrorReponses()`: The `fetch` method returns a `Promise` of a `Response`
    object. This `Promise` is rejected only when a network error occurs, or when a
    similar scenario prevents the request from completing. Otherwise, whatever HTTP
    status the server may answer with, the `Promise` is resolved successfully with
    the `Response`. This method adds an interceptor that rejects `Promises` when the
    response''s status is not a success code. The HTTP success code is between `200` and `299`.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rejectErrorReponses()`：`fetch`方法返回一个`Response`对象的`Promise`。这个`Promise`只在发生网络错误或类似情况阻止请求完成时被拒绝。否则，无论服务器可能回答什么HTTP状态，`Promise`都会成功解决为`Response`。这个方法添加了一个拦截器，当响应的状态不是成功代码时拒绝`Promises`。HTTP成功代码在`200`到`299`之间。'
- en: '`useStandardConfiguration()`: The standard configuration includes the `same-origin`
    credentials setting (see the official Fetch API documentation to know more about
    this setting) and the rejection of error responses (see the preceding `rejectErrorResponses`
    method).'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useStandardConfiguration()`：标准配置包括`same-origin`凭据设置（有关此设置的更多信息，请参见官方Fetch
    API文档）和拒绝错误响应（请参阅前面的`rejectErrorResponses`方法）。'
- en: In addition to a callback configuration function, the `configure` method can
    be passed a `RequestInit` object directly. In such a case, this `RequestInit`
    object will be used as the default properties of all requests.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个回调配置函数外，`configure`方法还可以直接传递一个`RequestInit`对象。在这种情况下，这个`RequestInit`对象将被用作所有请求的默认属性。
- en: 'This means that, if we had a `RequestInit` object stored in a `defaultProperties`
    variable, the following two lines would do the exact same thing:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们有一个存储在`defaultProperties`变量中的`RequestInit`对象，下面的两行将执行完全相同的事情：
- en: '[PRE69]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'A `RequestInit` object corresponds to the second parameter expected by the
    Fetch API''s `Request` constructor. It is used to specify various properties for
    a `Request`. The most commonly used are:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestInit`对象对应于Fetch API的`Request`构造函数期望的第二个参数。它用于指定`Request`的各种属性。最常用的属性有：'
- en: '`method`: The HTTP method, for example GET, POST'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：HTTP方法，例如GET、POST'
- en: '`headers`: An object containing the HTTP headers for the request'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：包含请求的HTTP头的对象'
- en: '`body`: The body of the request, for example a `Blob`, `BufferSource`, `FormData`,
    `URLSearchParams`, or `USVString` instance'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：请求体，例如一个`Blob`、`BufferSource`、`FormData`、`URLSearchParams`或`USVString`实例'
- en: Note
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I will let you look at the official documentation for more details about the
    available `Request` properties.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我将让你查看官方文档以获取关于可用`Request`属性的更多详细信息。
- en: As you can see, a `RequestInit` object can be used to specify an HTTP method
    and a request body, so we will be able to perform POST and PUT requests to create
    and update `person` objects. We will see examples of this in the next chapter,
    when we start building forms.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一个`RequestInit`对象可以用来指定一个HTTP方法和请求体，因此我们将能够执行POST和PUT请求来创建和更新`person`对象。我们将在下一章看到这个例子，那时我们开始构建表单。
- en: A common pitfall
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个常见的陷阱
- en: As we saw in [Chapter 2](ch02.html "Chapter 2. Layout, Menu, and Getting Familiar"),
    *Layout, Menu, and Getting Familiar*, the DI container automatically registers
    all classes as application singletons by default. This means that, if your application
    contains multiple services, which have dependency on what should be distinct instances
    of `HttpClient` and configure their respective `HttpClient` differently, you'll
    run into strange problems.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第二章](ch02.html "Chapter 2. 布局、菜单和熟悉")中看到的，*布局、菜单和熟悉*，DI容器默认自动将所有类作为应用程序单例注册。这意味着，如果您的应用程序包含多个服务，它们依赖于应该是独立的`HttpClient`实例，并且各自配置其相应的`HttpClient`不同，您会遇到奇怪的问题。
- en: 'Let''s imagine the two following services:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下以下两个服务：
- en: '[PRE70]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we have two services, named `ContactService` and `AddressService`. They
    are both injected as an `HttpClient` instance in their constructor, and configure
    their own instance using different base URLs.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个服务，分别名为`ContactService`和`AddressService`。它们在其构造函数中都作为`HttpClient`实例注入，并使用不同的基础URL配置自己的实例。
- en: By default, the same `HttpClient` instance will be injected in both services,
    because it is considered an application singleton by default by the DI container.
    Do you see the problem? The second service to be created will override the base
    URL of the first one, so the first service will end up trying to perform HTTP
    calls to the wrong URL.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，相同的`HttpClient`实例将被注入到两个服务中，因为DI容器默认认为它是应用程序的单例。您看到问题了吗？第二个服务创建后，将覆盖第一个服务的基础URL，所以第一个服务最终将尝试对错误的URL执行HTTP调用。
- en: 'Such a scenario has many possible solutions. You can use the `NewInstance`
    resolver to force a new instance to be injected in each service:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景有很多可能的解决方案。您可以使用`NewInstance`解析器在每个服务中强制注入一个新的实例：
- en: '[PRE71]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Another solution would be to register the `HttpClient` class as transient in
    your application''s main `configure` method:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案可能是将`HttpClient`类作为您的应用程序主要`configure`方法中的瞬态注册：
- en: '[PRE72]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Interceptors
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拦截器
- en: 'Interceptors are objects which can intercept requests and responses at various
    times during an HTTP call. An `Interceptor` object can implement any of the following
    callback methods:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器是在HTTP调用过程中的不同时间截取请求和响应的对象。一个`Interceptor`对象可以实现以下任意回调方法：
- en: '`request(request: Request): Request|Response|Promise<Request|Response>`: This
    is called before the request is sent. It can modify the request, or return a new
    one in its place. It can also return a response to short-circuit the rest of the
    process. In such a case, the `request` method of the next interceptors will be
    skipped and the response will be used as if the request had been sent. `Promise`s
    are supported.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request(request: Request): Request|Response|Promise<Request|Response>`：在请求被发送之前调用。它可以修改请求，或者返回一个新的请求。它还可以返回一个响应来短路剩余的过程。在这种情况下，下一个拦截器的`request`方法将被跳过，并且将使用响应，好像请求已经被发送一样。支持`Promise`。'
- en: '`requestError(error: any): Request|Response|Promise<Request|Response>`: This
    is called when a previous interceptor''s `request` method throws an error. It
    may re-throw the error to propagate it, or return a new request or response to
    recover from the failure. `Promise`s are supported.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestError(error: any): Request|Response|Promise<Request|Response>`：当一个拦截器的`request`方法抛出错误时调用。它可能重新抛出错误以传播它，或者返回一个新的请求或响应以从失败中恢复。支持`Promise`。'
- en: '`response(response: Response, request?: Request): Response|Promise<Response>`:
    This is called after the response is received. It can modify the response, or
    return a new one in its place. `Promise`s are supported.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response(response: Response, request?: Request): Response|Promise<Response>`：在响应被接收之后调用。它可以修改响应，或者返回一个新的响应。支持`Promise`。'
- en: '`responseError(error: any, request?: Request): Response|Promise<Response>`:
    This is called when a previous interceptor''s `response` method throws an error.
    It may re-throw the error to propagate it, or return a new response to recover
    from the failure. `Promise`s are supported.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseError(error: any, request?: Request): Response|Promise<Response>`：当一个拦截器的`response`方法抛出错误时调用。它可能重新抛出错误以传播它，或者返回一个新的响应以从失败中恢复。支持`Promise`。'
- en: 'For example, we could define the following interceptor class:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义以下的拦截器类：
- en: '[PRE73]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This interceptor expects a `Bearer` authentication token to be passed to its
    constructor. When added to a Fetch client, it adds an `Authorization` header to
    every request, allowing an already authenticated user to access a secured endpoint.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个拦截器期望一个`Bearer`认证令牌在它的构造函数中被传递。当添加到一个Fetch客户端时，它会在每个请求中添加一个`Authorization`头，允许一个已经认证的用户访问一个受保护的端点。
- en: Our application
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应用程序
- en: 'At this point, we have covered everything we will need for the next step in
    our application: querying our HTTP endpoint, displaying the contact list, and
    allowing navigation to the details of a given contact.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经涵盖了我们将需要的应用程序的下一步：查询我们的HTTP端点、显示联系人列表以及允许导航到给定联系人的详细信息。
- en: 'To make our application a little sexier, we will leverage Font Awesome, a CSS
    library that offers scalable vector icons. Let''s first install it:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序更具吸引力，我们将利用Font Awesome，一个提供可缩放矢量图标的CSS库。让我们首先安装它：
- en: '[PRE74]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we need to include it in our application:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将其包含在我们的应用程序中：
- en: '`index.html`'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '[PRE75]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Our contact gateway
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的联系人网关
- en: We could go and make HTTP calls directly in our view-models. However, this would
    blur the boundary between responsibilities. The view-model would be responsible
    for making calls, parsing requests, handling errors, and eventually caching responses,
    all of this in addition to data display, which is its primary task.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在我们的视图模型中直接进行HTTP调用。然而，这样做会模糊责任之间的界限。视图模型除了要负责数据展示（其主要任务）之外，还要负责调用、解析请求、处理错误以及最终缓存响应。
- en: 'Instead, we will create a contact gateway class, which will be responsible
    for fetching the data from the endpoint, will be reusable, and will be able to
    evolve on its own:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将创建一个联系人网关类，它将负责从端点获取数据，将是可重用的，并且能够独立发展：
- en: '`src/contact-gateway.js`'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-gateway.js`'
- en: '[PRE76]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, we first declare a class whose constructor expects an instance of `HttpClient`,
    which is Aurelia's Fetch client. In this constructor, we configure the client
    so it uses the standard configuration, which we saw in the *Configuration* section,
    and we use the `environment` object's `contactsUrl` property as its base URL.
    This means that all requests with a relative URL will be made relative to this
    URL.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先声明一个构造函数期望一个`HttpClient`实例的类，这是Aurelia的Fetch客户端。在这个构造函数中，我们配置客户端，使其使用标准配置，我们在*配置*部分看到了这个配置，并使用`environment`对象的`contactsUrl`属性作为其基本URL。这意味着所有带有相对URL的请求都将相对于这个URL进行。
- en: 'Our contact gateway exposes two methods: one to get all contacts, and a second
    to get a single contact by its ID. They work by calling the client''s `fetch`
    method, which by default sends a GET request to the provided URL. Here, since
    the URLs are relative paths, they will be made relative to the base URL configured
    in the constructor.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的contact gateway暴露了两个方法：一个获取所有联系人，第二个通过其ID获取单个联系人。它们通过调用客户端的`fetch`方法来工作，该方法默认向提供的URL发送GET请求。在这里，由于URL是相对路径，它们将相对于在构造函数中配置的基URL进行转换。
- en: When the HTTP request is completed, the `Promise` returned by `fetch` is resolved,
    and the `json` method is called on the resolved `Response` object to deserialize
    the response body as JSON. The `json` method also returns a `Promise`, so when
    this second `Promise` resolves, we transform the untyped data transfer objects
    in instances of the `Contact` class, which we'll write later.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当HTTP请求完成后，`fetch`返回的`Promise`被解决，然后在解决后的`Response`对象上调用`json`方法来反序列化响应体为JSON。`json`方法也返回一个`Promise`，所以当这个第二个`Promise`解决时，我们将未类型的数据传输对象转换为稍后我们将编写的`Contact`类的实例。
- en: This means that, based on what the endpoints return, `getAll` returns a `Promise`
    of an array of `Contact` objects, and `getById` a `Promise` of a single `Contact`
    object.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，基于端点返回的内容，`getAll`返回一个`Contact`对象的数组`Promise`，而`getById`返回一个单个`Contact`对象的`Promise`。
- en: Prerequisites
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'For all of this to work, we need to do two things. First, we''ll install the
    Fetch client, by running the following command in a console after having moved
    to the application directory:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这一切正常工作，我们需要做两件事。首先，我们将安装Fetch客户端，通过在移动到应用程序目录后，在控制台中运行以下命令：
- en: '[PRE77]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the code written for this book has been run on Google Chrome. If you use
    another browser, you may need to install polyfills for various APIs, such as Fetch.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中编写的所有代码都在Google Chrome上运行过。如果你使用其他浏览器，你可能需要为各种API（如Fetch）安装polyfill。
- en: 'Additionally, you need to let the Aurelia bundler know about this library.
    In `aurelia_project/aurelia.json`, under `build`, then `bundles`, in the definition
    of the bundle named `vendor-bundle.js`, add `aurelia-fetch-client` to the `dependencies`
    array:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要让Aurelia打包器知道这个库。在`aurelia_project/aurelia.json`中，在`build`下的`bundles`中，在名为`vendor-bundle.js`的包定义中，将`aurelia-fetch-client`添加到`dependencies`数组中：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE78]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is required in order for the `aurelia-fetch-client` library to be bundled
    with the other vendor libraries so our application can use it.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了让`aurelia-fetch-client`库与其他库一起被捆绑，以便我们的应用程序可以使用它。
- en: 'Lastly, the `contactsUrl` property does not exist by default on the `environment`
    configuration object. We need to add it:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`contactsUrl`属性在`environment`配置对象中默认不存在。我们需要添加它：
- en: '`aurelia_project/environments/dev.js`'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/environments/dev.js`'
- en: '[PRE79]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here we assign the URL on which our endpoint runs by default to the `contactsUrl`
    property. In a real-world scenario, we would also set it in `stage.js` and `prod.js`,
    so our endpoint is configured for all environments. I will leave this as an exercise
    for the reader.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将默认在哪个URL上运行我们的端点的URL分配给`contactsUrl`属性。在现实世界中，我们还会将其设置在`stage.js`和`prod.js`中，因此我们的端点为所有环境配置。我将留下这个作为读者的练习。
- en: Displaying the contacts
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示联系人
- en: Let's now add some code in our empty `contact-list` component. We will leverage
    our new `ContactGateway` class to fetch the contact list and display it.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的空`contact-list`组件中添加一些代码。我们将利用我们新的`ContactGateway`类来获取联系人列表并显示它。
- en: '`src/contact-list.js`'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.js`'
- en: '[PRE80]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we first inject a `ContactGateway` instance in the view-model of our `contact-list`
    component. In the `activate` method, we use `getAll` contacts and, once the `Promise`
    resolves, we make sure to clear the contacts array; then we add the loaded contacts
    to it, so they are available for the template.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先在`contact-list`组件的视图模型中注入了一个`ContactGateway`实例。在`activate`方法中，我们使用`getAll`获取联系人，一旦`Promise`解决，我们确保清除联系人数组；然后我们将加载的联系人添加到其中，以便它们可供模板使用。
- en: In this case, mutating the array is considered a better practice than overwriting
    the whole `contacts` property, because the `repeat.for` binding in the view observes
    mutation of the array instance, but doesn't observe the property itself, so the
    view won't be refreshed if `contacts` is overwritten after the view is rendered.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，更改数组被视为比覆盖整个`contacts`属性更好的做法，因为视图中的`repeat.for`绑定观察数组实例的更改，但不观察属性本身，所以如果`contacts`在视图渲染后覆盖，视图不会刷新。
- en: You may have noticed how the `Promise` returned by `getAll` is returned by `activate`.
    This makes the call to the HTTP endpoint run as part of the screen activation
    life cycle. Without this, the navigation could end before the contacts are loaded,
    and the screen would display as empty. Here, we are guaranteed that the contacts
    are available when the components get rendered by the router.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到了`getAll`返回的`Promise`是如何在`activate`中返回的。这使得对HTTP端点的调用作为屏幕激活生命周期的一部分运行。如果没有这
- en: 'We also need to define the `Contact` class. It has computed properties that
    will be useful in the list and detailed views:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义`Contact`类。它在列表和详细视图中会有用的计算属性：
- en: '`src/models.js`'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/models.js`'
- en: '[PRE81]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This class has a static method called `fromObject`, which acts as a factory
    method. It expects a source object as its parameter, creates a new instance of
    `Contact`, and assigns all the properties of the source object to it. Additionally,
    it defines an `isPerson` property, which returns `true` if the contact has at
    least a first name or a last name and will be used in templates to distinguish
    people from companies. It also defines a `fullName` property, which will return
    either the first and last names, if the contact represents a person, or the company
    name if the contact is a company.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个名为`fromObject`的静态方法，它作为一个工厂方法。它期望一个源对象作为其参数，创建一个`Contact`的新实例，并将源对象的所有属性分配给它。此外，它定义了一个`isPerson`属性，如果联系人至少有一个名字或姓氏，则返回`true`，并在模板中用来区分人和公司。它还定义了一个`fullName`属性，如果联系人代表一个人，它将返回名字和姓氏，如果联系人是公司，它将返回公司名称。
- en: 'Now, the only thing missing is the `contact-list` template:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一缺少的是`contact-list`模板：
- en: '`src/contact-list.html`'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.html`'
- en: '[PRE82]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here we simply render the contacts as an unordered list.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们简单地将联系人渲染为无序列表。
- en: 'You can test it now:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以测试它：
- en: '[PRE83]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to launch the HTTP endpoint by running `npm start` in the `api`
    directory. Of course, if you have not run it before, you'll need to `npm install`
    its dependencies first.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记通过在`api`目录中运行`npm start`来启动HTTP端点。当然，如果你之前没有运行过，你首先需要运行`npm install`来安装其依赖项。
- en: If you didn't omit any step, you should see the contact list appear when you
    navigate to http://localhost:9000/ .
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有省略任何步骤，当你导航到http://localhost:9000/时，你应该看到联系人列表出现。
- en: Grouping and sorting the contacts
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对联系人进行分组和排序
- en: Right now, the contact list is lame. The contacts are displayed in a bullet
    list and are not even sorted. We could greatly enhance the usability of this screen
    by grouping the contacts by the first letter of their name and having those groups
    sorted alphabetically. This would make navigating through the list and finding
    a contact much easier.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，联系人列表很无聊。联系人以子弹列表的形式显示，甚至没有排序。我们可以通过按联系人名字的第一个字母分组并按字母顺序对这些组进行排序，大大提高这个屏幕的可使用性。这将使浏览列表和查找联系人变得更容易。
- en: 'To implement this, we have two possibilities: we can either group and then
    sort the contacts in the view-model, or we can isolate this logic in the value
    converters, so we can re-use them later. We''ll go with the latter, as it respects
    the single-responsibility principle and makes our code DRYer.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们有两个选择：我们可以在视图模型中先分组然后排序联系人，或者我们可以将此逻辑隔离在值转换器中，以便我们以后可以重新使用它们。我们将选择后者，因为它符合单一责任原则，并使我们的代码更加简洁。
- en: Creating the orderBy value converter
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建orderBy值转换器
- en: Our `orderBy` value converter will apply on an array and will expect as its
    first parameter the name of the property used to sort the items.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`orderBy`值转换器将应用于一个数组，并期望其第一个参数为用于排序项目的属性名称。
- en: Our value converter will also accept an optional second parameter, which will
    be the sort direction, as an `'asc'` or a `'desc'` string. When omitted, the sort
    order will be ascending.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的值转换器还可以接受一个可选的第二个参数，这将是一个排序方向，作为一个`'asc'`或`'desc'`字符串。省略时，排序顺序将升序。
- en: '`src/resources/value-converters/order-by.js`'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/value-converters/order-by.js`'
- en: '[PRE84]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One important bit is the call to `slice` before the call to `sort`. It makes
    sure a copy is taken of the array, because the `sort` method modifies the array
    on which it is called. Without the `slice` call, the original array would be modified.
    This would be bad; value converters should absolutely not modify their source
    value. It is not the expected behavior, so such a converter would be surprising,
    in a really bad way, to developers using it.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的部分是在调用`sort`之前调用`slice`。它确保对数组进行复制，因为`sort`方法会修改它调用的数组。如果没有`slice`调用，原始数组将被修改。这是不好的；值转换器绝不应该修改其源值。这不是预期行为，因此这样的转换器会让使用它的开发者感到非常惊讶。
- en: You should really pay close attention when designing a value converter to avoid
    such side-effects.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计值转换器时，你确实应该密切关注以避免此类副作用。
- en: 'To make this new converter available to templates, instead of having to manually
    `require` it each time we need it, let''s load it in the `resources` feature:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个新的转换器对模板可用，而不是每次需要时都手动`require`它，让我们在`resources`特性中加载它：
- en: '`src/resources/index.js`'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/index.js`'
- en: '[PRE85]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You can already test it by changing to the `repeat.for` instruction for `contact
    of contacts | orderBy:'fullName'` in the `contact-list` template.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`contact of contacts | orderBy:'fullName'`的`repeat.for`指令更改为`contact-list`模板中的新`firstLetter`属性来测试它。
- en: Creating the groupBy value converter
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建groupBy值转换器
- en: 'Next, our `groupBy` value converter will work in almost the same way; it will
    apply on an array, and expect a single parameter, which will be the name of the
    property used to group the items. It will return an array of objects, each of
    which will contain two properties: the value used to group as a `key`, and the
    items in the group as an `items` array:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的`groupBy`值转换器将以几乎相同的方式工作；它将应用于数组，并期望一个参数，这个参数将是用于分组项目的属性的名称。它将返回一个对象数组，每个对象都包含两个属性：用作`key`的分组值和作为`items`数组的分组项目：
- en: '`src/resources/value-converters/group-by.js`'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/value-converters/group-by.js`'
- en: '[PRE86]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This value converter also needs to be loaded in the `resources` feature's `configure`
    function. I'll let you do that on your own.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值转换器还需要在`resources`特性的`configure`函数中加载。这个你自己来吧。
- en: Updating the contact list
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新联系人列表
- en: 'To leverage our value converters, we will first need to add a new property
    to the `Contact` class:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用我们的值转换器，我们首先需要在`Contact`类中添加一个新属性：
- en: '`src/models.js`'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/models.js`'
- en: '[PRE87]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This new `firstLetter` property takes the first letter of the last name, the
    first name, or the company name of the contact. It will be used to group contacts
    together.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`firstLetter`属性取联系人的姓氏、名字或公司名字的第一个字母。它将用于将联系人分组在一起。
- en: 'Next, let''s throw away our previous template for the contact list and start
    over again:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们丢弃我们之前的联系人列表模板，重新开始：
- en: '`src/contact-list.html`'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.html`'
- en: '[PRE88]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, we first group the contacts by the value of their `firstLetter` property.
    The `groupBy` converter returns an array of group objects, which are then ordered
    by their `key` property and repeated into panels. For each group, the letter by
    which the contacts were grouped is rendered in a panel header, then the contacts
    of the group are sorted by their `fullName` property and rendered into a list
    group. For each contact, a link to its detailed view is rendered, with either
    its person or company name.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先按照它们的`firstLetter`属性的值将联系人分组。`groupBy`转换器返回一个组对象的数组，然后根据它们的`key`属性进行排序并重复到面板上。对于每个组，以该组分的字母显示在面板标题中，然后按`fullName`属性对组中的联系人进行排序并显示在列表组中。对于每个联系人，都会渲染一个到其详细视图的链接，显示其人员或公司名称。
- en: Filtering contacts
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 筛选联系人
- en: Even with the contacts being grouped and sorted, finding a given contact may
    be troublesome, especially if the user does not know the full name of the contact.
    Let's add a search box, which will be used to filter the list of contacts in real
    time.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 即使联系人被分组和排序，找到特定的联系人可能仍然很麻烦，特别是如果用户不知道联系人的全名。我们添加一个搜索框，用于实时过滤联系人列表。
- en: 'We will first need to create another value converter to filter the array of
    contacts:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建另一个值转换器来过滤联系人数组：
- en: '`src/resources/value-converters/filter-by.js`'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/value-converters/filter-by.js`'
- en: '[PRE89]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Our `filterBy` value converter expects a first parameter, which is the value
    to be searched for. Additionally, it considers the following parameters to be
    the properties on which the value will be searched for. Any contact for which
    none of the specified properties contains the searched value will be filtered
    out of the result.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`filterBy`值转换器期望一个第一个参数，这是要搜索的值。此外，它考虑以下参数是要搜索的属性。任何不在指定属性中包含搜索值的联系人将被过滤出结果。
- en: Note
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget to load the `filterBy` value converter in the `resources` feature's
    `configure` function.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`resources`特性的`configure`函数中加载`filterBy`值转换器。
- en: 'Next, we need to add the search box and apply our value converter in the `contact-list`
    template:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`contact-list`模板中添加搜索框并应用我们的值转换器：
- en: '`src/contact-list.html`'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.html`'
- en: '[PRE90]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here, we first add a search box, in the form of an `input` element whose `value`
    is bound to a `filter` property. This binding is debounced, so the property will
    be updated only after the user stops typing for 200 milliseconds.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先添加一个搜索框，形式为一个`input`元素，其`value`绑定到`filter`属性。这个绑定是去抖的，所以属性将在用户停止输入200毫秒后才会更新。
- en: Additionally, a button is displayed beside the `input` when `filter` is not
    empty. This button, when clicked, simply assigns an empty string to `filter`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，当`filter`不为空时，`input`旁边会显示一个按钮。点击这个按钮，简单地将`filter`分配为一个空字符串。
- en: Lastly, we apply `filterBy` to `contacts` in the `repeat.for` binding, passing
    `filter` as the searched value, followed by the names of the `firstName`, `lastName`,
    and `company` properties, which will be searched into.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`repeat.for`绑定中将对`contacts`应用`filterBy`，传递`filter`作为搜索值，随后是`firstName`、`lastName`和`company`属性的名称，这些属性将被搜索。
- en: Note
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An interesting thing to notice here is that we didn't even declare the `filter`
    property on our view-model. It is used only in the view. Since it is bound to
    an input element's value attribute, the binding will be two-way by default, and
    the binding will just assign its value to the view-model. The view-model doesn't
    need to know about this property.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的一点是，我们甚至没有在视图模型中声明`filter`属性。它只在视图中使用。由于它绑定到输入元素的值属性，默认情况下绑定是双向的，绑定只会将其值分配给视图模型。视图模型不需要知道这个属性。
- en: The contact detailed view
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联系人详细视图
- en: 'If you click on a contact, you should see an error in the browser console.
    The reason is simple: the route that should display the details of a contact refers
    to a `contact-details` component, which does not exist yet. Let''s correct this.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击一个联系人，你应该在浏览器控制台看到一个错误。原因很简单：应该显示联系人详情的路由指的是一个`contact-details`组件，而这个组件还不存在。让我们来纠正这个问题。
- en: The view-model
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图模型
- en: 'The view-model will leverage some of the classes we wrote previously:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型将利用我们之前编写的某些类：
- en: '`src/contact-details.js`'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-details.js`'
- en: '[PRE91]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This code is pretty straightforward. The view-model expects an instance of `ContactGateway`
    to be injected in its constructor, and implements the `activate` life cycle callback
    method. This method uses the `id` route parameter and asks the gateway for the
    proper contact object. It returns the gateway's `Promise`, so the navigation will
    complete only when the contact is loaded. When this `Promise` resolves, the contact
    object is assigned to the view-model's `contact` property. Additionally, the route
    `config` object is used to dynamically assign the document title to the contact's
    `fullName`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当直接。视图模型期望在其构造函数中注入`ContactGateway`的一个实例，并实现`activate`生命周期回调方法。这个方法使用`id`路由参数并向网关请求适当的联系人对象。它返回网关的`Promise`，所以导航只有在联系人加载完成后才会完成。当这个`Promise`解决时，联系人对象被分配给视图模型的`contact`属性。此外，路由`config`对象用于动态将文档标题分配给联系人的`fullName`。
- en: The template
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板
- en: The template for the contact details is large, so let's break it down into parts.
    You can follow this section and gradually build the template, step by step.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人详情的模板很大，所以让我们将其分解为部分。你可以按照这一节逐步构建模板。
- en: 'First, let''s add a header that will display the picture and the name of the
    contact:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个头，将显示联系人的图片和姓名：
- en: '[PRE92]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The rest of the template, which should be placed just before the closing `section`
    tag, is enclosed inside a `div` element with the `form-horizontal` class:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的其余部分，应该放在关闭`section`标签之前，被一个带有`form-horizontal`类的`div`元素包含：
- en: '[PRE93]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Inside this element, we''ll first display the date and time at which the contact
    was created and last modified:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个元素内部，我们首先显示联系人在创建和最后修改时的日期和时间：
- en: '[PRE94]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, we''ll display the contact''s birthday, but only if the contact has one:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果联系人有生日，我们将显示联系人的生日：
- en: '[PRE95]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'After that, we''ll display the contact''s phone numbers:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将显示联系人的电话号码：
- en: '[PRE96]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here, the block is enclosed in a template that is rendered only if the contact
    has at least one phone number. Each phone number is displayed with its type: home,
    office, or mobile, for example.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，块被包含在一个模板中，该模板仅当联系人至少有一个电话号码时才渲染。每个电话号码都显示其类型：家庭、办公室或移动电话等。
- en: 'The next blocks all follow the same pattern as the phone numbers. They''ll
    display the e-mail addresses, the geographical addresses, and the social profiles
    of the contact:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分都会遵循与电话号码相同的模式。它们将显示联系人的电子邮件地址、地理位置和社交媒体资料：
- en: '[PRE97]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Lastly, we''ll display the contact''s note, if any:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果有的话，我们将显示联系人的备注：
- en: '[PRE98]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Since the loaded contact never changes during the life cycle of the component,
    this template could be improved a lot by making its bindings one-time. This would
    mean replacing all `bind` commands with the `one-time` command, and decorating
    all string interpolations with the `oneTime` binding behavior. I'll leave this
    as an exercise to the reader.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在组件的生命周期中加载的联系人永远不会改变，可以通过将所有`bind`命令替换为`one-time`命令，并将所有字符串插值装饰为`oneTime`绑定行为来大大改进此模板。我将把这个作为读者的练习留给读者。
- en: Summary
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: As you can see, Aurelia's data binding language is clear and concise. It is
    pretty self-explanatory, making templates easy to understand, even for developers
    not familiar with Aurelia. Additionally, it is adaptive, making it as easy as
    possible to write performant applications.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Aurelia的数据绑定语言清晰简洁。它相当容易理解，即使对于不熟悉Aurelia的开发人员来说，模板也很容易理解。此外，它是适应性强的，使得编写高性能应用程序尽可能简单。
- en: In addition to the convenience of the Fetch client, those qualities combined
    with the flexibility and reusability of the value converter and binding behavior
    system make writing data-displaying components a breeze.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Fetch客户端的便利性，这些特质结合了值转换器和绑定行为系统的灵活性与可重用性，使得编写数据展示组件变得非常简单。
- en: Building forms to create and edit data is not much more complicated. We will
    see this, along with form validation, in the next chapter.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 构建用于创建和编辑数据的形式并不比这更复杂。我们将在下一章中看到这一点，其中包括表单验证。
