- en: '*Chapter 6*: Adding Authentication and Connecting to the Database'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*6章*：添加认证并连接到数据库
- en: In the previous chapter, we added an HTTP framework to our application, heavily
    simplifying our code. After that, we added the concept of users to the application
    and developed the register endpoint. In its current state, our application is
    already storing a couple of things, with the small gotcha that it's storing it
    in memory. We'll tackle this specific issue in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在应用程序中添加了一个HTTP框架，极大地简化了我们的代码。之后，我们在应用程序中添加了用户的概念，并开发了注册端点。目前为止，我们的应用程序已经存储了一些东西，唯一的缺点是它存储在内存中。我们将在本章解决这个问题。
- en: Another concept that we've used while implementing oak (the HTTP framework of
    choice) was middleware functions. We'll start this chapter by learning what middleware
    functions are, and why they are one of the *standards* in pretty much all Node.js
    and Deno frameworks when it comes to reusing code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现oak（HTTP框架的选择）时，我们使用的另一个概念是中间件函数。我们将从学习中间件函数是什么以及为什么它们几乎是所有Node.js和Deno框架中代码重用的*标准*开始本章。
- en: We'll then use middleware functions and implement login and authorization. Adding
    to that, we will learn how to use middleware to add standard features such as
    request logging and timing to the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用中间件函数并实现登录和授权。除此之外，我们还将学习如何使用中间件添加诸如请求日志和计时等标准功能到应用程序中。
- en: With our application very close to completeness in terms of requirements, we'll
    spend the rest of this chapter learning how to connect to a real persistence engine.
    For this book, we'll be using MongoDB. We'll use the abstractions we had previously
    built to make sure the transition is smooth. We'll then create a new users repository
    so that it can connect to a database the same way we can with an in-memory solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序在需求方面几乎完成，我们将用剩余的时间学习如何连接到一个真正的持久化引擎。在这本书中，我们将使用MongoDB。我们将使用之前构建的抽象确保过渡顺利。然后我们将创建一个新的用户存储库，以便它可以像我们使用内存解决方案一样连接到数据库。
- en: By the end of this chapter, we'll have a complete application with support for
    register and user login. After logging in, users can also get a list of museums.
    This is all done with the business logic from the HTTP and persistence implementation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有一个完整的应用程序，支持注册和用户登录。登录后，用户还可以获取博物馆列表。所有这些都是通过HTTP和持久化实现的业务逻辑完成的。
- en: After this chapter, we'll only come back to the application to add tests and
    deploy it, thus completing the full cycle of building an application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，我们将只回来添加测试并部署应用程序，从而完成构建应用程序的完整周期。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using middleware functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件函数
- en: Adding authentication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加认证
- en: Adding authorization with JWT
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JWT添加授权
- en: Connecting with MongoDB
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接MongoDB
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code required for this chapter is available at the following GitHub link:
    [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的代码可在以下GitHub链接中找到：[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06)。
- en: Using middleware functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件函数
- en: If you have used any HTTP framework, be it JavaScript or otherwise, you are
    probably familiar with the concept of middleware functions. If you are not, then
    no worries – that's what we'll explain in this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用过任何HTTP框架，无论是JavaScript还是其他框架，您可能都熟悉中间件函数的概念。如果您不熟悉，也没关系——这就是我们将在本节解释的内容。
- en: 'Let''s start with a definition borrowed from the Express.js documentation ([http://expressjs.com/en/guide/writing-middleware.html](http://expressjs.com/en/guide/writing-middleware.html)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Express.js文档中借用的一个定义开始：[http://expressjs.com/en/guide/writing-middleware.html](http://expressjs.com/en/guide/writing-middleware.html)
- en: '"Middleware functions are functions that have access to the request object (req),
    the response object (res), and the next middleware function in the application''s
    request-response cycle. The next middleware function is commonly denoted by a
    variable named next."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “中间件函数是具有访问请求对象(req)、响应对象(res)以及应用程序请求-响应周期中下一个中间件函数的函数。下一个中间件函数通常由一个名为next的变量表示。”
- en: 'Middleware functions intercept requests and have the ability to act on them.
    They can be used in many different use cases, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数拦截请求并具有对它们进行操作的能力。它们可以在许多不同的用例中使用，如下所示：
- en: Changing the request and response objects
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改请求和响应对象
- en: Ending the request-response life cycle (answering requests or skipping other
    handlers)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束请求-响应生命周期（回答请求或跳过其他处理程序）
- en: Calling the next middleware function
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用下一个中间件函数
- en: Middleware functions are commonly used in tasks such as checking authentication
    tokens and automatically responding according to the result, logging requests,
    adding a specific header to a request, enriching the request object with context,
    and error handling, among other things.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数通常用于诸如检查认证令牌、根据结果自动响应、记录请求、向请求中添加特定头、用上下文丰富请求对象和错误处理等任务。
- en: We'll implement some of these examples in the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序中实现一些这些示例。
- en: How does middleware work?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件是如何工作的？
- en: Middleware is processed as a stack, and each function can control the flow of
    the response with the ability to run the code before and after the rest of the
    stack executes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件作为堆栈处理，每个函数都可以通过运行代码在堆栈执行前后控制响应流程。
- en: In oak, middleware functions are registered by the `use` function. At this point,
    you might remember what we previously did with oak's router. What the `Router`
    object from oak does is create handlers for the registered routes and export two
    middleware functions with that behavior to be registered on the main application.
    These are called `routes` and `allowedMethods` ([https://github.com/PacktPublishing/Deno-Web-Development/blob/43b7f7a40157212a3afbca5ba0ae20f862db38c4/ch5/sections/2-2-handling-routes-in-an-oak-application/museums-api/src/web/index.ts#L38](https://github.com/PacktPublishing/Deno-Web-Development/blob/43b7f7a40157212a3afbca5ba0ae20f862db38c4/ch5/sections/2-2-handling-routes-in-an-oak-application/museums-api/src/web/index.ts#L38)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在oak框架中，中间件函数是通过`use`函数进行注册的。这个时候，你可能还记得我们之前是如何使用oak的路由器的。oak的`Router`对象所做的就是为注册的路由创建处理程序，并导出带有这种行为的中间件函数，以便在主应用程序上注册。这些被称为`routes`和`allowedMethods`
    ([https://github.com/PacktPublishing/Deno-Web-Development/blob/43b7f7a40157212a3afbca5ba0ae20f862db38c4/ch5/sections/2-2-handling-routes-in-an-oak-application/museums-api/src/web/index.ts#L38](https://github.com/PacktPublishing/Deno-Web-Development/blob/43b7f7a40157212a3afbca5ba0ae20f862db38c4/ch5/sections/2-2-handling-routes-in-an-oak-application/museums-api/src/web/index.ts#L38)).
- en: To better understand middleware functions, we'll implement a couple of them.
    We'll do this in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解中间件函数，我们将实现它们中的几个。我们将在下一节中这样做。
- en: Adding request timing via middleware
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过中间件添加请求计时
- en: Let's add basic logging to our requests using some middleware. Oak middleware
    functions ([https://github.com/oakserver/oak#application-middleware-and-context](https://github.com/oakserver/oak#application-middleware-and-context))
    receive two parameters. The first one is the context object, which is the same
    one that all the routes get, while the second one is the `next` function. This
    function can be used to execute other middleware in the stack, allowing us to
    control the application flow.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在请求中添加一些基本日志记录。oak中间件函数（[https://github.com/oakserver/oak#application-middleware-and-context](https://github.com/oakserver/oak#application-middleware-and-context)）接收两个参数。第一个是上下文对象，这是所有路由都得到的一个对象，而第二个是`next`函数。这个函数可以用来执行堆栈中的其他中间件，允许我们控制应用程序流程。
- en: 'The first thing we''ll do is add a middleware that adds the `X-Response-Time`
    header to the response. Follow these steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要添加一个中间件，为响应添加`X-Response-Time`头。按照以下步骤操作：
- en: Go to `src/web/index.ts` and register a middleware that executes the rest of
    the stack by calling `next`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/web/index.ts`，并注册一个通过调用`next`执行剩余堆栈的中间件。
- en: 'This adds a header to the response with the difference in milliseconds from
    the time the request started until it was handled:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这为响应添加了一个头，其值为从请求开始到处理完毕的毫秒差：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute the following code to get the server running:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码以启动服务器：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Perform a request and check whether the desired header is there:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发起一个请求，并检查是否有了所需的头：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With that, we've used middleware functions after completely understanding them
    for the first time. We used them to control the flow of the application, by using
    `next`, and to enrich the request with a header.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们首次完全理解后使用了中间件函数。我们用它们来控制应用程序的流程，通过使用`next`，并为请求添加了一个头。
- en: The next thing we'll do is compose on the middleware we just created and add
    logic to log what request is being made to the server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对刚刚创建的中间件进行组合并添加逻辑，以记录向服务器发起的请求。
- en: Adding request logging via middleware
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过中间件添加请求日志
- en: Now that we have the logic to calculate the request timing we've already built,
    we're in a great place to add request logging to our application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了计算请求时间的逻辑，我们处于向应用程序添加请求日志的好位置。
- en: 'The final goal is to have every request that is made to the application logged
    to the console with its path, HTTP method, and the time it took to answer; something
    like the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是让每个向应用程序发起的请求都记录在控制台上，包括其路径、HTTP方法和响应时间；像以下示例一样：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We could, of course, do this individually per request, but since this is something
    that we want to do cross-application, we'll add it as a piece of middleware to
    the `Application` object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以每个请求分别处理，但由于这是一件需要跨应用程序做的事情，我们将把它作为中间件添加到`Application`对象中。
- en: 'The middleware we wrote in the previous section requires the handlers (and
    middleware functions) to run for it to add the response time (it calls the next
    function before executing part of the logic). We''ll need to register the current
    logging middleware before the one we previously did, which added the timing to
    the request. Let''s get started:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节编写的 middleware 要求处理程序（以及中间件函数）运行，以便添加响应时间（它在执行部分逻辑之前调用 next 函数）。我们需要在之前注册当前的日志中间件，它将请求时间添加到请求中。让我们开始：
- en: 'Go to `src/web/index.ts` and add the code for logging the request method, the
    path, and the timing to the console:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/web/index.ts`并在控制台上添加记录请求方法、路径和时间戳的代码：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Execute the following code to get the server running:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码以启动服务器：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Perform a request to an endpoint:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对端点执行请求：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Check that the server process is logging the request to the console:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查服务器进程是否将请求记录到控制台：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And with that, we have our middleware functions working together!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们的中间件函数就可以协同工作了！
- en: Here, we've registered middleware functions directly on the main application
    object. However, it is also possible to do this on specific oak routers by calling
    the same `use` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在主要的应用程序对象上注册了中间件函数。然而，也可以通过调用相同的`use`方法在特定的oak路由上执行此操作。
- en: 'To give you an example, we''ll register a middleware that will execute only
    on the `/api` routes. We will do the exact same thing we did previously, but instead
    of the `Application` object, we''ll call the `use` method on the API `Router`
    object, as shown in the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您一个例子，我们将注册一个只会在`/api`路由来执行的中间件。我们将做与之前完全相同的事情，但这次调用的是API`Router`对象的`use`方法，如下例所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Middleware functions that want the application flow to proceed normally *must
    call the* `next` *function*. If this doesn't happen, the rest of the middleware
    in the stack and route handlers will not be executed, and thus the request will
    not be answered.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想要应用程序流程正常进行的中间件函数*必须调用*`next`函数。如果这种情况没有发生，堆栈中的其余中间件和路由处理程序将不会被执行，因此请求将无法得到响应。
- en: 'There''s yet another way of using middleware functions: by directly adding
    them before the request handlers.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中间件函数的另一种方法是将它们直接添加到请求处理程序之前。
- en: 'Imagine that we want to create a middleware that adds the `X-Test` header to
    some routes. We can either write that middleware on the application object or
    we can use it directly on the routes itself, as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个添加`X-Test`头的中间件。我们可以在应用程序对象上编写该中间件，或者我们可以在路由本身上直接使用它，如下代码所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To get the preceding code working, we''ll need to export the `RouterMiddleware`
    type in `src/deps.ts`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让之前的代码运行，我们需要在`src/deps.ts`中导出`RouterMiddleware`类型：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this middleware, whenever we want the `X-Test` header to be added, we just
    need to include `addTestHeaderMiddleware` before the route handler. It will execute
    before the handler's code. This is not exclusive to one piece of middleware, as
    multiple middleware functions can be registered.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个中间件，无论何时我们想要添加`X-Test`头，只需要在路由处理程序之前包含`addTestHeaderMiddleware`。它会在处理程序代码之前执行。这不仅仅适用于一个中间件，因为可以注册多个中间件函数。
- en: And that's it for middleware functions!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数就到这里结束！
- en: We've learned the basics that allow us to create and share functionality by
    using this very common feature of web frameworks. We'll keep using them as we
    move into the next section, where we'll handle authentication, validate tokens,
    and authorize users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了使用这种非常常见的web框架特性来创建和共享功能的基本知识。在我们进入下一部分时，我们将继续使用它们，在那里我们将处理认证、验证令牌和授权用户。
- en: Let's go and implement our application's authentication!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实现我们应用程序的认证！
- en: Adding authentication
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加认证
- en: In the previous chapter, we added the capability of creating new users to our
    application. This, by itself, is a cool feature, but it's not worth much if we
    can't use it for authentication. That's what we'll do here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向应用程序添加了创建新用户的功能。这个功能本身很酷，但如果我们不能用它来进行认证，那么它就值不了多少。这就是我们在这里要做的。
- en: We'll start by creating the logic that checks whether a username and password
    combination is correct, and then we'll implement an endpoint to do that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先来创建检查用户名和密码组合是否正确的逻辑，然后实现一个端点来完成这个任务。
- en: After this, we'll transition into the authorization topic by returning a token
    from the login endpoint, and later using that token to check if a user is authenticated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将通过从登录端点返回令牌来过渡到授权主题，然后使用该令牌来检查用户是否已认证。
- en: Let's go step by step, starting with the business logic and persistency layer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来，从业务逻辑和持久性层开始。
- en: Creating the login business logic
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录业务逻辑
- en: It's already a practice of ours to, when writing new functionality, start with
    the business logic. We believe this is intuitive, as you think "business" and
    user first, and only then proceed into the technical details. That's what we'll
    do here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一种实践是，在编写新功能时，首先从业务逻辑开始。我们认为这是直观的，因为你首先考虑“业务”和用户，然后才进入技术细节。这就是我们要在这里做的。
- en: 'We''ll start by adding the login logic, back in `UserController`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`UserController`中添加登录逻辑：
- en: 'Before we start, let''s add the `login` method to the `UserController` interface
    in `src/users/types.ts`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，让我们在`src/users/types.ts`中为`UserController`接口添加`login`方法：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Declare the `login` method on the controller; it should receive a username
    and a password:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器上声明`login`方法；它应该接收一个用户名和密码：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s stop and think about what the flow of the login should be:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们停下来思考一下登录流程应该是什么样子：
- en: The user sends their username and password.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户发送他们的用户名和密码。
- en: The application gets the user from their database by username.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序通过用户名从数据库中获取用户。
- en: The application encodes the user-sent password with the salt from the database.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序使用数据库中的盐对用户发送的密码进行编码。
- en: The application compares both salted passwords.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序比较两个加盐密码。
- en: The application returns a user and a token.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序返回一个用户和一个令牌。
- en: We won't worry about the token for now. However, the rest of the flow should
    set the requirements for the current section, helping us think about the code
    for the `login` method.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们不担心令牌。然而，流程的其余部分应该为当前部分设置要求，帮助我们思考`login`方法的代码。
- en: Just by looking at these requirements, we can understand that we'll need to
    have a method on `UserRepository` to get a user by username. Let's take a look
    at this.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单从这些要求来看，我们就可以理解我们需要在`UserRepository`上有一个通过用户名获取用户的方法。让我们来看看这个。
- en: 'In `src/users/types.ts`, add a `getByUsername` method to `UserRepository`;
    it should get a user from the database by username:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/types.ts`中，向`UserRepository`添加一个`getByUsername`方法；它应该通过用户名从数据库中获取用户：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement the `getByUsername` method in `src/users/repository.ts`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/repository.ts`中实现`getByUsername`方法：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use the `getByUsername` method from the repository inside the `login` method
    of `UserController`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserController`的`login`方法内部使用来自仓库的`getByUsername`方法：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a `comparePassword` method inside `UserController`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserController`内部创建一个`comparePassword`方法。
- en: 'It should receive a password and a `user` object. Then, it should compare the
    password that was sent by the user once it''s been salted and hashed with what
    is stored in the database:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该接收一个密码和一个`user`对象。然后，它应该将用户发送的密码一旦被加盐和哈希与数据库中存储的密码进行比较：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the `comparePassword` method on the `login` method of `UserController`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserController`的`login`方法上使用`comparePassword`方法：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And with that, we have the `login` method working!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了`login`方法的工作！
- en: It receives a username and a password, gets a user by username, compares the
    hashed passwords, and returns the user if everything goes according to plan.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收一个用户名和一个密码，通过用户名获取用户，比较哈希密码，如果一切按计划进行，则返回用户。
- en: We should now be ready to implement the login endpoint – one that will use the
    login method we just created.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该准备好实现登录端点——一个将使用我们刚刚创建的登录方法。
- en: Creating the login endpoint
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录端点
- en: 'Now that we''ve created the business logic and data fetching logic, we can
    start using it in our web layer. Let''s create the `POST /api/login` route, which
    should let the user log in with their username and password. Follow these steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了业务逻辑和数据获取逻辑，我们就可以开始在我们的网络层中使用它。让我们创建一个`POST /api/login`路由，该路由应该允许用户使用他们的用户名和密码登录。按照以下步骤操作：
- en: 'In `src/web/index.ts`, create the login route:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/web/index.ts`中创建登录路由：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Get the body of the request by using the `request.body` function ([https://doc.deno.land/https/raw.githubusercontent.com/oakserver/oak/main/request.ts#Request](https://doc.deno.land/https/raw.githubusercontent.com/oakserver/oak/main/request.ts#Request))
    and then send the username and password to the `login` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`request.body`函数获取请求体（[https://doc.deno.land/https/raw.githubusercontent.com/oakserver/oak/main/request.ts#Request](https://doc.deno.land/https/raw.githubusercontent.com/oakserver/oak/main/request.ts#Request))，然后将用户名和密码发送到`login`方法：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the login succeeds, it should return our `user`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果登录成功，它应该返回我们的`user`：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With that, we should have all it takes to log a user in! Let's try it out.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这些，我们应该拥有登录用户所需的一切！让我们试一试。
- en: 'Run the application by running the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，通过运行以下命令：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Perform a request to register the user at `/api/users/register`, and then try
    to log in with the created user at `/api/login`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`/api/users/register`发送请求以注册用户，然后尝试使用创建的用户登录到`/api/login`：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, try to log in with the created user:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用创建的用户登录：
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And it works! We're creating the user on the registry and are able to log in
    with them afterward.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而且它有效！我们在注册表上创建用户，并能够在之后使用他们登录。
- en: In this section, we learned how to add authentication logic to our application
    and implemented the `login` method, which allows users to log in with a registered
    user.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何向我们的应用程序添加认证逻辑，并实现了`login`方法，该方法允许用户使用注册的用户登录。
- en: In the next section, we'll learn how to use this authentication we've created
    to get a token that will allow us to handle authorization. We'll make the museums
    route only available for authenticated users, instead of being publicly available.
    For this, we will need to develop the authorization feature. Let's jump in!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用我们创建的认证来获取一个令牌，该令牌将允许我们处理授权。我们将使博物馆路线只对认证用户可用，而不是公开可用。为此，我们需要开发授权功能。让我们深入了解一下！
- en: Adding authorization with JWT
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT添加授权
- en: We now have an application that allows us to log in and return the logged in
    user. However, if we want to use the login in any API, we'll have to create an
    authorization mechanism. This mechanism should enable the users of the API to
    authenticate, get a token, and use that token to identify themselves and access
    resources.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个允许我们登录并返回已登录用户的应用程序。然而，如果我们想要在API中使用登录，我们必须创建一个授权机制。这个机制应该启用API的用户进行认证，获取一个令牌，并使用这个令牌来标识自己并访问资源。
- en: We're doing this as we want to close part of the application's routes so that
    they're only available to authenticated users.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为我们希望关闭应用程序的某些路由，使它们只对认证用户可用。
- en: We'll develop what's needed to integrate with token authentication by using
    **JSON Web Tokens** (**JWT**), which is pretty much a standard in APIs nowadays.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发所需内容，通过使用**JSON Web Tokens**（**JWT**），这是一种在API中相当标准的认证方式。
- en: 'If you are not familiar with JWT, I''ll leave you with an explanation from
    [jwt.io](http://jwt.io):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉JWT，我将留下一个来自[jwt.io](http://jwt.io)的解释：
- en: '"JSON Web Tokens are an open, industry standard RFC 7519 method for representing
    claims securely between two parties."'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"JSON Web Tokens是一种开放、行业标准的RFC 7519方法，用于在两个方之间安全地表示声明。"'
- en: It is mainly used when you want your clients to connect to an authentication
    service, and them provide your servers with the ability to verify if that authentication
    was issued by a service that you trust.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它主要用于当你希望你的客户端连接到一个认证服务，然后提供你的服务器验证该认证是否由一个你信任的服务发出。
- en: 'To avoid the risk of repeating what has already been very well-explained by
    [jwt.io](http://jwt.io), I''ll leave you with a link that explains what this standard
    is perfectly: [https://jwt.io/introduction/](https://jwt.io/introduction/). Make
    sure to give it a read; I''m sure you have all it takes to understand about how
    we''ll be using it next.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复[jwt.io](http://jwt.io)已经很好地解释过的风险，我将给你一个链接，完美地解释了这个标准是什么：`[https://jwt.io/introduction/](https://jwt.io/introduction/)`。确保阅读它；我相信你们都有足够的知识来理解我们接下来如何使用它。
- en: In this section, and due to the scope of this book, we will not implement the
    whole logic to generate and validate JWT tokens. The code for that is available
    in this book's GitHub repository ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/jwt-auth](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/jwt-auth)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，由于本书的范围，我们将不会实现生成和验证JWT令牌的全部逻辑。这段代码可以在本书的GitHub仓库中找到([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/jwt-auth](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/jwt-auth))。
- en: What we will do here is integrate our current application with a module that
    has functions for generating and validating JWT tokens, which is what matters
    for our application. Then, we'll use that token to decide whether we're letting
    the user access the museums route.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要在这里做的是将我们当前的应用程序与一个具有生成和验证JWT令牌功能的模块集成，这对我们的应用程序至关重要。然后，我们使用该令牌来决定是否允许用户访问博物馆路线。
- en: Let's go!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Returning a token from login
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从登录返回令牌
- en: In the previous section, we implemented the login functionality. We developed
    some logic that validates the combination of username and password, returning
    the user if it succeeds.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们实现了登录功能。我们开发了一些逻辑来验证用户名和密码的组合，如果成功就返回用户。
- en: In order to authorize a user and let them access private resources, we need
    to know who the authenticated user is. A common way to do this is via a token.
    There are various ways we can do this. They are alternatives such as basic HTTP
    authentication, sessions tokens, JWT tokens, and so on. We chose JWT as we believe
    it is a heavily used solution that you might have encountered in the industry.
    Don't worry if you haven't; it is simple enough to grasp.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了授权一个用户并让他们访问私有资源，我们需要知道认证的用户是谁。一个常见的做法是通过令牌来实现。我们有各种方法可以做到这一点。它们包括基本HTTP认证、会话令牌、JWT令牌等替代方案。我们选择JWT，因为我们认为它是业界广泛使用的解决方案，你们可能会在工作中遇到。如果你们没有遇到过，也不要担心；它是足够简单的。
- en: The first thing we will need to do is return a token to the user when they log
    in. Our `UserController` will have to return that token in conjunction with `userDto`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在用户登录时向用户返回令牌。我们的`UserController`将不得不在与`userDto`结合时返回该令牌。
- en: In the provided `jwt-auth` module ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/jwt-auth](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/jwt-auth)),
    you can check that we're exporting a Repository.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的`jwt-auth`模块中([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/jwt-auth](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/jwt-auth)),你可以检查我们导出了一个仓库。
- en: 'If we access the documentation, using Deno''s documentation website at [https://doc.deno.land/https/raw.githubusercontent.com/PacktPublishing/Deno-Web-Development/master/Chapter06/jwt-auth/repository.ts](https://doc.deno.land/https/raw.githubusercontent.com/PacktPublishing/Deno-Web-Development/master/Chapter06/jwt-auth/repository.ts),
    we can see that it exports two methods: `getToken` and `generateToken`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问文档，使用Deno的文档网站在[https://doc.deno.land/https/raw.githubusercontent.com/PacktPublishing/Deno-Web-Development/master/Chapter06/jwt-auth/repository.ts](https://doc.deno.land/https/raw.githubusercontent.com/PacktPublishing/Deno-Web-Development/master/Chapter06/jwt-auth/repository.ts)，我们可以看到它导出了两个方法：`getToken`和`generateToken`。
- en: Reading the method's documentation, we can understand that one gets a token
    for a user ID, and that the other generates a new token, respectively.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读方法的文档，我们可以理解，一个为用户ID获取令牌，另一个生成新令牌。
- en: 'Let''s use this method to generate a new token in our login use case by following
    these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个方法，按照以下步骤在我们的登录用例中生成新令牌：
- en: 'Start by adding the token to the return type of `UserController` in `src/users/types.ts`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src/users/types.ts`中的`UserController`返回类型中添加令牌：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Go to `src/deps.ts` and add the export for the `jwt-auth` module, running `deno
    cache` to update the lock file and download the dependencies:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`src/deps.ts`，为`jwt-auth`模块添加导出，运行`deno cache`以更新锁文件并下载依赖项：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the `AuthRepository` type to define the `UserController` constructor''s
    dependencies:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AuthRepository`类型定义`UserController`构造函数的依赖项：
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Go to the login method in `src/users/controller.ts` and use the `generateToken`
    method from `authRepository` to get a token and return it:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/users/controller.ts`中的登录方法，并使用`authRepository`中的`generateToken`方法来获取令牌并返回它：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Go back to `src/index.ts` and instantiate `AuthRepository` from `jwt-auth`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/index.ts`，从`jwt-auth`实例化`AuthRepository`：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can also check by the module's documentation, since it requires a `configuration`
    object to be sent with three properties; that is, `algorithm`, `key`, and `tokenExpirationInSeconds`.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以通过模块的文档来检查，因为它需要一个带有三个属性的`configuration`对象发送，即`algorithm`、`key`和`tokenExpirationInSeconds`。
- en: '`key` should be a secret value that is used to create and validate the JWT,
    `algorithm` is the crypto algorithm that the token will be encoded with (HS256,
    HS512, and RS256 supported), and `tokenExpirationInSeconds` is the time it takes
    for the token to expire.'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`key`应该是一个秘密值，用于创建和验证JWT，`algorithm`是令牌将编码的加密算法（支持HS256、HS512和RS256），`tokenExpirationInSeconds`是令牌过期的时间。'
- en: Regarding the values that are secret and shouldn't live in the code, such as
    the `key` variable that we just mentioned, we'll learn how to handle them in the
    next chapter, where we'll talk about application configuration.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于我们刚刚提到的`key`变量等不应存在于代码中的秘密值，我们将在下一章学习如何处理它们，那里我们将讨论应用程序配置。
- en: We now have an instance of `AuthRepository`! We should be able to send it to
    our `UserController` and get it working.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在有一个`AuthRepository`的实例！我们应该能够将其发送到我们的`UserController`并使其工作。
- en: 'In `src/index.ts`, send `authController` into the `UserController` constructor:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/index.ts`中，将`authController`发送到`UserController`构造函数中：
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, you should be able to run the application!
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你应该能够运行应用程序！
- en: Now, if you create a few requests to test it, you'll notice that the `POST /login`
    endpoint is still not returning the token. Let's fix this!
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你创建几个请求来测试它，你会注意到`POST /login`端点仍然没有返回令牌。让我们解决这个问题！
- en: 'Go to `src/web/index.ts` and, on the `login` route, make sure we''re getting
    `token` returned from the `login` method present in the response:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/web/index.ts`，在`login`路线上，确保我们从响应中的`login`方法返回`token`：
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''re almost done! We managed to finish our first objective: having the `login`
    endpoint return a token.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！我们成功完成了第一个目标：使`login`端点返回一个令牌。
- en: The next thing we want to implement is the logic that makes sure that a user
    is sending a token whenever they're trying to access an authenticated route.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的是确保用户在尝试访问认证路线时始终发送令牌的逻辑。
- en: Let's go and finish the authorization logic.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续完善认证逻辑。
- en: Making an authenticated route
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个认证路线
- en: Having the capacity to get users a token, we now want a guarantee that only
    logged in users are able to access the museums route.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有了向用户获取令牌的能力，我们现在希望确保只有登录的用户能够访问博物馆路线。
- en: Users will have to send the token in the `Authorization` header, as the JWT
    token standard defines. If the token is invalid or not present, the user should
    be presented with a `401 Unauthorized` status code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须将令牌发送到`Authorization`头中，正如JWT令牌标准所定义的。如果令牌无效或不存在，用户应显示`401 Unauthorized`状态码。
- en: Validating the token that's been sent by users on the request is a nice use
    case for middleware functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 验证用户在请求中发送的令牌是中间件函数的一个很好的用例。
- en: In order to do this, and since we're using `oak`, we'll be using a third-party
    module named `oak-middleware-jwt`. This is nothing more than a middleware that
    automatically validates the JWT token, based on a key, and provides functionality
    that will be useful to us.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，既然我们正在使用`oak`，我们将使用一个名为`oak-middleware-jwt`的第三方模块。这只是一个自动验证JWT令牌的中间件，基于密钥，并提供对我们有用的功能。
- en: You can check its documentation at [https://nest.land/package/oak-middleware-jwt](https://nest.land/package/oak-middleware-jwt).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看其文档在[https://nest.land/package/oak-middleware-jwt](https://nest.land/package/oak-middleware-jwt)。
- en: 'Let''s use this middleware in our web code to make the museums route only available
    to authenticated users. Follow these steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的网络代码中使用这个中间件，使博物馆路线只对认证用户可用。按照以下步骤操作：
- en: 'Add `oak-middleware-jwt` to the `deps.ts` file and export the `jwtMiddleware`
    function:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`deps.ts`文件中添加`oak-middleware-jwt`，并导出`jwtMiddleware`函数：
- en: '[PRE31]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Back in `src/web/index.ts`, use `jwtMiddleware` in the museums route, sending
    the key and the algorithm there.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/web/index.ts`，在博物馆路由中使用`jwtMiddleware`，在那里发送密钥和算法。
- en: 'Do not forget what we mentioned in previous section – that middleware functions
    can be used in any route by sending it before the route handler:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记我们在上一节中提到的内容——中间件函数可以通过在路由处理程序之前发送它，在任何路由中使用：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add `authorization` as a parameter inside `configuration` in the `createServer`
    function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createServer`函数中向`configuration`内部添加`authorization`作为参数：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, still in `src/web/index.ts`, use the `authorization` params to send the
    values that will be injected to `jwtMiddleware`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，仍然在`src/web/index.ts`中，使用`authorization`参数发送将被注入到`jwtMiddleware`中的值：
- en: '[PRE34]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The only thing we're missing is the ability to actually send the `authorization`
    value to the `createServer` function.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们唯一缺少的是实际上将`authorization`值发送到`createServer`函数的能力。
- en: 'In `src/index.ts`, extract the auth configuration into a variable so that we
    can reuse it:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/index.ts`中，将认证配置提取到一个变量中，以便我们可以重复使用：
- en: '[PRE35]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s reuse that same variable to send the required parameters to `createServer`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重复使用那个相同的变量来发送发送到`createServer`所需参数：
- en: '[PRE36]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And we're done! Let's test our application and see if it works as expected.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大功告成！让我们测试一下我们的应用程序，看看它是否按预期工作。
- en: Note that the desired behavior is that only an authenticated user can access
    the museums route and see all the museums.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，期望的行为是只有认证用户才能访问博物馆路由并看到所有的博物馆。
- en: 'Let''s run the application by running the following command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来运行应用程序：
- en: '[PRE37]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s register a user so that we can log in:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们注册一个用户，这样我们就可以登录了：
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s log in so that we can get our token:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们登录，这样我们就可以获得我们的令牌：
- en: '[PRE39]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, let''s try to access the museums route with the token that was returned
    from the previous request:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们尝试使用从前一个请求返回的令牌访问博物馆路由：
- en: '[PRE40]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Just to make sure it works as expected, let''s try to do the same request without
    the `Authorization` header, expecting an `unauthorized` response:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保它按预期工作，让我们尝试在不带`Authorization`头的相同请求中，期望一个`unauthorized`响应：
- en: '[PRE41]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That's it! With that, we've managed to make a route only accessible by authenticated
    users. This is something very common in any application that contains users.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！现在我们已经成功创建了一个仅限认证用户访问的路由。这在任何包含用户的应用程序中都非常常见。
- en: If we were to go deeper into this, we could have explored the JWT `refreshToken`,
    or even how to read the user information from the JWT token, but that's outside
    the scope of this book. This is something I'll let you explore on your own.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更深入地了解这个问题，我们可以探索JWT `refreshToken`，或者甚至如何从JWT令牌中读取用户信息，但这些都超出了本书的范围。这是我要让您自己探索的东西。
- en: In this section, we achieved our goal and looked at many different parts of
    an API.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现了我们的目标，并查看了API的许多不同部分。
- en: 'There''s one thing missing, though: a connection with a real persistence engine.
    That''s what we''re going to do next – connect our application to a NoSQL database!'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不过还有一件事缺失：与真实持久化引擎的连接。这就是我们接下来要做的——将我们的应用程序连接到NoSQL数据库！
- en: Connecting to MongoDB
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到MongoDB
- en: 'So far, we''ve implemented an application that lists museums, and contains
    users, allowing them to authenticate. These features are already in place, but
    they all have a catch: they''re all running against an in-memory database.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了一个列出博物馆的应用程序，并包含用户，允许他们进行认证。这些功能已经就位，但它们都有一个缺点：它们都在内存数据库上运行。
- en: We've decided to do it this way for the sake of simplicity. However, since most
    of our implementation doesn't depend on the delivery mechanism, it shouldn't change
    much if the database changes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这种方式是为了简化问题。然而，由于我们的大部分实现都不依赖于交付机制，如果数据库发生变化，它应该不会有多大变化。
- en: As you might have guessed by this section's title, we'll learn how to move one
    of the application entities to the database. We'll leverage the abstractions we've
    created in order to do this. The process will be very similar to all the entities,
    and thus we've decided on learning how to connect to a database just for the users'
    module.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一节的标题中，您可能已经猜到，我们将学习如何将应用程序的一个实体移动到数据库。我们将利用我们已经创建的抽象来实现这一点。这个过程将与所有实体非常相似，因此我们决定学习如何连接数据库，只为了用户模块。
- en: Later, if you are curious about how this would work if all the applications
    were connected to the database, you'll have the opportunity to check this book's
    GitHub repository.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，如果您好奇如果所有应用程序都连接到数据库，这会怎样工作，您将有机会检查这本书的GitHub仓库。
- en: To make sure we're all running against a similar database, we'll use MongoDB
    Atlas. Atlas is a product that provides a free MongoDB cluster that we can use
    to connect our application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们都对类似的数据库进行操作，我们将使用MongoDB Atlas。Atlas是一个提供免费MongoDB集群的产品，我们可以用来连接我们的应用程序。
- en: 'If you are not familiar with MongoDB, there''s here''s a "one-sentence explanation"
    from their website ([https://www.mongodb.com/](https://www.mongodb.com/)). Feel
    free to go there and learn a little more about it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉MongoDB，这里有一个来自他们网站的“一句话解释”（[https://www.mongodb.com/](https://www.mongodb.com/)）。请随意去那里了解更多：
- en: '"MongoDB is a general purpose, document-based, distributed database built for
    modern application developers and for the cloud era."'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '"MongoDB是一个通用目的、基于文档、分布式数据库，为现代应用程序开发人员和云时代而构建。"'
- en: Ready? Let's go!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？让我们开始吧！
- en: Creating a User MongoDB repository
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用户MongoDB存储库
- en: Our current `UserRepository` is the module that's responsible for connecting
    the user to the database. This is the one we want to change in order to make our
    application connect with a MongoDB instance, instead of an in-memory database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`UserRepository`是负责将用户与数据库连接的模块。这就是我们想要更改的，以便我们的应用程序连接到一个MongoDB实例，而不是一个内存数据库。
- en: We'll go through the steps of creating the new MongoDB repository, exposing
    it to the world, and connecting the rest of our application to it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建新的MongoDB存储库、将其暴露给世界、并将我们应用程序的其余部分连接到它的步骤。
- en: Let's start by creating the space for a new users repository to exist, by reorganizing
    the users module's internal folder structure.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过重新组织用户模块的内部文件结构，为新的用户存储库创建空间。
- en: Rearranging our users module
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新排列我们的用户模块
- en: Our users module was initially thought to have a single repository, and thus
    it doesn't have a folder for it; it's just a single `repository.ts` file. Now
    that we're thinking of adding more ways our users can be saved to a database,
    we need to create it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户模块最初设想只有一个存储库，因此它没有相应的文件夹；只是一个`repository.ts`文件。现在我们考虑将用户保存到数据库的更多方法，我们需要创建它。
- en: Remember when we first talked about architecture, and mentioned that it would
    keep evolving? That's what's happening here.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们第一次谈到架构时，提到了它将不断进化吗？这就是正在发生的事情。
- en: 'Let''s rearrange the users module so that it can handle multiple repositories
    and add a MongoDB repository, following the `UserRepository` interface we previously
    created:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新排列用户模块，以便它可以处理多个存储库并添加一个MongoDB存储库，遵循我们之前创建的`UserRepository`接口：
- en: 'Create a folder named `repository` inside `src/users` and move the actual `src/users/repository.ts`
    there, renaming it `inMemory.ts`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users`内创建一个名为`repository`的文件夹，并将实际的`src/users/repository.ts`移动到那里，将其重命名为`inMemory.ts`：
- en: '[PRE42]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Remember to fix the module imports inside `src/users/repository/inMemory.ts`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得修复`src/users/repository/inMemory.ts`内的模块导入：
- en: '[PRE43]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To keep the application running, let''s go to `src/users/index.ts` and export
    the correct repository:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持应用程序的运行，让我们前往`src/users/index.ts`并导出正确的存储库：
- en: '[PRE44]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s create our MongoDB repository. Call it `mongoDb.ts` and put it
    inside the `src/users/respository` folder:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个MongoDB存储库。将其命名为`mongoDb.ts`，并将其放入`src/users/respository`文件夹内：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Make sure it implements the `UserRepository` interface we defined previously.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保它实现了我们之前定义的`UserRepository`接口。
- en: This is where all the fun starts! Now that we have the MongoDB repository, we'll
    start writing it and connecting our application to it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是所有乐趣开始的地方！现在我们有了MongoDB存储库，我们将开始编写它并将其连接到我们的应用程序。
- en: Installing the MongoDB client library
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装MongoDB客户端库
- en: We already have a list of methods that our repository needs to have implemented.
    By following the interface, we can guarantee that our application will work, regardless
    of the implementation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个我们存储库需要实现的方法列表。遵循接口，我们可以保证我们的应用程序会工作，不管实现方式如何。
- en: 'There''s one thing that we know for sure, as we don''t want to keep reinventing
    the wheel: we''re going to use a third-party package to handle the connection
    with MongoDB.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事我们可以肯定，因为我们不想一直重新发明轮子：我们将使用第三方包来处理与MongoDB的连接。
- en: We will use the `deno-mongo` package for this ([https://github.com/manyuanrong/deno_mongo](https://github.com/manyuanrong/deno_mongo)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`deno-mongo`包进行此操作（[https://github.com/manyuanrong/deno_mongo](https://github.com/manyuanrong/deno_mongo)）。
- en: Important note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Deno's MongoDB driver uses the Deno plugins API, which is still in unstable
    mode. This means that we will have to run our application with the `--unstable`
    flag. As it is currently using APIs that are not yet considered stable, this shouldn't
    be used in production yet.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Deno的MongoDB驱动程序使用Deno插件API，该API仍处于不稳定状态。这意味着我们将不得不以`--unstable`标志运行我们的应用程序。由于它目前正在使用尚未被认为是稳定的API，因此暂时不应在生产环境中使用。
- en: 'Let''s have a look at the documentation''s example, where a connection to a
    MongoDB database is established:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看文档中的示例，其中建立了与MongoDB数据库的连接：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we can see that we will need to create a MongoDB client and connect it
    to a database, using a connection string that contains the host (which might contain
    the host's username and password).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将需要创建一个MongoDB客户端并使用包含主机（可能包含主机的用户名和密码）的连接字符串连接到数据库。
- en: After that, we need to get the client to access a specific database (`test`,
    in this example). Only then can we have the handler that will let us interact
    with the collection (`users`, in this example).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要让客户端访问一个特定的数据库（在这个例子中是`test`）。只有这样，我们才能拥有允许我们与集合（在这个例子中是`users`）交互的处理程序。
- en: 'First things first, let''s add `deno-mongo` to our dependencies list:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将`deno-mongo`添加到我们的依赖列表中：
- en: 'Go to your `src/deps.ts` file and add the exports for `MongoClient` there:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你的`src/deps.ts`文件，并在那里添加`MongoClient`的导出：
- en: '[PRE47]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, make sure you run the `cache` command to install the modules. We''ll have
    to run it with the `--unstable` flag as the plugin we''re installing requires
    unstable APIs on its installation too:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，确保运行`cache`命令以安装模块。我们将不得不使用`--unstable`标志运行它，因为我们要安装的插件在安装时也需要不稳定的API：
- en: '[PRE48]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With that, we have updated the `deps.ts` file with the package we just installed!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经用我们刚刚安装的包更新了`deps.ts`文件！
- en: Let's move on and actually use this package to develop our repository.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用这个包来开发我们的仓库。
- en: Developing the MongoDB repository
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发MongoDB仓库
- en: In the example we got from the documentation, we learned how to connect to the
    database and create the handlers for the user's collection that we want. We know
    that our repository needs to have access to this handler so that it can interact
    with the collection.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们从文档中获得的示例中，我们学会了如何连接到数据库并创建我们想要的用户集合的处理程序。我们知道我们的仓库需要访问这个处理程序，以便它可以与集合交互。
- en: Again, we could create the MongoDB client directly inside the repository, but
    that would make it impossible for us to test that repository without trying to
    connect to MongoDB.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以在仓库内部直接创建MongoDB客户端，但这将使我们无法在没有尝试连接到MongoDB的情况下测试该仓库。
- en: As we want the dependencies to be injected into the modules as much as possible,
    we'll pass the MongoDB client into our repository via its constructor, which is
    something very similar to what we did in other parts of the code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尽可能希望将依赖项注入到模块中，我们将通过其构造函数将MongoDB客户端传递给我们的仓库，这在代码的其他部分非常类似于我们做的。
- en: 'Let''s go back to our MongoDB repository and do this by following these steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的MongoDB仓库，并按照这些步骤进行操作：
- en: Create the `constructor` method inside the MongoDB repository.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MongoDB仓库内创建`constructor`方法。
- en: 'Make sure it receives an object with a property named `storage` of the `Database`
    type, which is exported by the `deno-mongo` package:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保它接收一个具有名为`storage`的`Database`类型的属性的对象，该属性是由`deno-mongo`包导出的：
- en: '[PRE49]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we have to go into the `src/deps.ts` file and export the `Database` and
    `Collection` types from `deno-mongo`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须进入`src/deps.ts`文件，并从`deno-mongo`中导出`Database`和`Collection`类型：
- en: '[PRE50]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, it's just a matter of developing the methods to satisfy the `UserRepository`
    interface.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这只是开发满足`UserRepository`接口的方法的问题。
- en: These methods will be very similar to the ones we developed for the in-memory
    database, with the difference that we're now interacting with a MongoDB collection
    instead of the JavaScript Map we were using previously.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法将非常类似于我们为内存数据库开发的那些方法，区别在于我们现在在与MongoDB集合交互，而不是我们之前使用的JavaScript Map。
- en: Now, we just need to implement some methods that will create, verify the existence
    of a user, and get it by username. These methods are available in the plugin documentation
    and very closely mimic MongoDB's native API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要实现一些方法，这些方法将创建用户、验证用户是否存在，并通过用户名获取用户。这些方法在插件文档中可用，非常接近MongoDB的本地API。
- en: 'This is what the final class is going to look like:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终类的样子：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We've highlighted the methods that use the `deno-mongo` plugin to access the
    database. Note how the logic is very similar to what we've previously done. We're
    adding the created at date to the `create` method, and then calling the `create`
    method from mongo. In the `exists` method, we're calling the `count` method, and
    converting it into a `boolean`. For the `getByUsername` method, we're using the
    `findOne` method from the mongo library, sending the username in.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们突出了使用`deno-mongo`插件访问数据库的方法。注意逻辑与我们之前做的非常相似。我们在`create`方法中添加了创建日期，然后从mongo调用`create`方法。在`exists`方法中，我们调用`count`方法，并将其转换为`boolean`。对于`getByUsername`方法，我们使用mongo库中的`findOne`方法，发送用户名。
- en: If you have any questions about how these APIs can be used, please check out
    deno-mongo's documentation ([https://github.com/manyuanrong/deno_mongo](https://github.com/manyuanrong/deno_mongo)).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对如何使用这些API有任何疑问，请查看deno-mongo的文档 ([https://github.com/manyuanrong/deno_mongo](https://github.com/manyuanrong/deno_mongo)).
- en: Connecting the application to MongoDB
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用程序连接到MongoDB
- en: 'Now, in order to expose the MongoDB repository that we''ve created, we need
    to go into `src/users/index.ts` and expose it as `Repository` (delete the highlighted
    line):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了暴露我们创建的MongoDB仓库，我们需要进入`src/users/index.ts`并将其作为`Repository`暴露（删除高亮显示的行）：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We should now have our editor and typescript compiler complaining that we're
    not sending the correct dependencies into `UserRepository` at the moment of its
    instantiation on `src/index.ts`, which is true. So, let's go there and fix it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该在我们的编辑器和typescript编译器中看到抱怨，抱怨我们在`src/index.ts`中实例化`UserRepository`时没有发送正确的依赖关系，这是正确的。所以，让我们去那里修复它。
- en: 'Before we send the database client into `UserRepository`, it needs to be instantiated.
    By looking at the documentation for `deno-mongo`, we can read the following example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据库客户端发送到`UserRepository`之前，它需要被实例化。通过查看`deno-mongo`的文档，我们可以看到以下示例：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We aren't connecting with the localhost, so we'll need to change the connection
    URI later.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有连接到localhost，所以我们需要稍后更改连接URI。
- en: 'Let''s follow the documentation''s example and write the code for connecting
    to a MongoDB instance. Follow these steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照文档的示例，编写连接到MongoDB实例的代码。按照以下步骤操作：
- en: 'After adding the export of `MongoClient` to the `src/deps.ts` file, import
    it in `src/index.ts`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将`MongoClient`的导出添加到`src/deps.ts`文件后，在`src/index.ts`中导入它：
- en: '[PRE54]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, call `connectWithUri`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`connectWithUri`：
- en: '[PRE55]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After that, get a database handler by calling the `database` method on the
    client:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过在客户端上调用`database`方法来获取一个数据库处理器：
- en: '[PRE56]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And that should be all we need in order to connect to MongoDB. The only thing
    missing is the code for sending the database handler into the `UserRepository`.
    So, let''s add this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是我们连接到MongoDB所需的所有内容。唯一缺少的是将数据库处理器发送到`UserRepository`的代码。所以，让我们添加这个：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: No warnings should be visible and we should be able to run our application now!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该有任何警告出现，我们应该现在能够运行我们的应用程序了！
- en: However, we still do not have a database to connect to. We'll look at this next.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然没有一个数据库可以连接。我们接下来会看看这个问题。
- en: Connecting to a MongoDB cluster
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到MongoDB集群
- en: Now, we need to connect to a real MongoDB instance. Here, we'll be using a service
    called Atlas. Atlas is a service from MongoDB that provides a cloud MongoDB database.
    Their free tier is quite generous and works well for our application. Create an
    account there. Once you've done that, we can create a MongoDB cluster.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要连接到一个真实的MongoDB实例。在这里，我们将使用一个名为Atlas的服务。Atlas是MongoDB提供的一个云MongoDB数据库服务。他们的免费层非常慷慨，非常适合我们的应用程序。在那里创建一个账户。完成后，我们可以创建一个MongoDB集群。
- en: Important Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you have any other MongoDB instance, local or remote, feel free to use it
    by skipping the next paragraph and going directly to inserting the database URI
    into the code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有其他任何MongoDB实例，无论是本地的还是远程的，都可以跳过下一段，直接将数据库URI插入代码中。
- en: 'The following link contains all the instructions needed to create a cluster:
    [https://docs.atlas.mongodb.com/tutorial/create-new-cluster/](https://docs.atlas.mongodb.com/tutorial/create-new-cluster/).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接包含创建一个集群所需的所有说明：[https://docs.atlas.mongodb.com/tutorial/create-new-cluster/](https://docs.atlas.mongodb.com/tutorial/create-new-cluster/)。
- en: Once the cluster has been created, we also need to create a user that has access
    to it. Go to [https://docs.atlas.mongodb.com/tutorial/connect-to-your-cluster/index.html#connect-to-your-atlas-cluster](https://docs.atlas.mongodb.com/tutorial/connect-to-your-cluster/index.html#connect-to-your-atlas-cluster)
    to learn how to get the connection string.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群被创建，我们还需要创建一个可以访问它的用户。前往[https://docs.atlas.mongodb.com/tutorial/connect-to-your-cluster/index.html#connect-to-your-atlas-cluster](https://docs.atlas.mongodb.com/tutorial/connect-to-your-cluster/index.html#connect-to-your-atlas-cluster)了解如何获取连接字符串。
- en: 'It should look something like the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像下面这样：
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now that we have the connection string, we just need to pass it to the code
    we created previously in `src/index.ts`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了连接字符串，我们只需要将其传递给之前在`src/index.ts`中创建的代码：
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And that should be all we need to get our application running. Let's do this!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 应该就是我们所需要的全部内容了，让我们开始吧！
- en: 'Keep in mind that since we''re using the plugins API to connect to MongoDB,
    and it''s still unstable, the following permissions are needed together with the
    `--unstable` flag:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于我们使用插件API连接到MongoDB，而且它仍然不稳定，所以需要以下权限以及`--unstable`标志：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, to test that our `UserRepository` is working and connected to the database,
    let''s try to register and log in and see if it works:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试我们的`UserRepository`是否运行正常并且与数据库连接，让我们尝试注册并登录看看是否可行：
- en: 'Perform a `POST` request to `/api/users/register` to register our user:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`/api/users/register`发送一个`POST`请求来注册我们的用户：
- en: '[PRE61]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, to make sure we are connecting to permanent storage, we can stop the application
    and run it again, before trying to log in:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了确保我们连接到永久存储，我们可以停止应用程序然后再次运行它，在尝试登录之前：
- en: '[PRE62]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s log in with that same user we just created:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用刚才创建的同一个用户登录：
- en: '[PRE63]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And we have our response! We managed to connect the application that was previously
    connected to an in-memory database to a real MongoDB database. If you used MongoDB,
    you can view the users that were created there on the Atlas interface by going
    to the **Collections** menu.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了响应！我们成功地将之前连接到内存数据库的应用程序连接到了一个真实的MongoDB数据库。如果你使用了MongoDB，你可以在Atlas界面的**集合**菜单中查看那里创建的用户。
- en: Did you notice how we didn't need to touch any of our business or web logic
    just to change the persistency mechanism? This proves that the layers and abstractions
    we initially created are now paying off, by allowing decoupling between different
    parts of the application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们为了更改持久性机制并没有触及到任何业务或网络逻辑了吗？这证明了我们最初创建的层和抽象现在正在发挥作用，通过允许应用程序不同部分之间的解耦。
- en: With that, we have completed this chapter and migrated our users to a real database.
    We could do the same for the other modules, but that would be mostly the same
    thing and will not add much to your learning experience. I'd like to challenge
    you on writing the other modules' logic so that it can connect to MongoDB.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们完成了这一章节并把我们的用户迁移到了一个真实的数据库。我们也可以对其他模块做同样的事情，但那将会是几乎相同的工作，并且不会为你的学习体验增加太多。我想挑战你编写其他模块的逻辑，使其能够连接到MongoDB。
- en: If you want to skip this but you're curious about what it will look like, then
    take a look at this book's GitHub repository.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跳过这部分但是好奇它会是怎样的，那么去看看这本书的GitHub仓库吧。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter pretty much wraps up our application in terms of logic. We'll come
    back later in [*Chapter 8*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178), *Testing
    – Unit and Integration*, to add tests and the single feature that we're missing
    – the ability to rate museums. However, most of this has already been done. In
    its current state, we have an application that has its domains divided into modules
    that can be used by themselves and don't depend on each other. We believe we achieved
    something that is both easy to navigate in the code and extendable.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节基本上已经涵盖了我们在逻辑方面对应用程序的封装。我们稍后会在[第8章](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178)
    *测试 - 单元和集成* 中添加测试以及我们所缺少的一个特性——对博物馆进行评分的能力。然而，这部分大多数已经完成。在其当前状态下，我们有一个应用程序，它的领域被划分为可以独立使用且彼此不依赖的模块。我们相信我们已经实现了一些既易于在代码中导航又可扩展的东西。
- en: This concludes the process of constantly reworking and refining the architecture,
    managing dependencies, and tweaking logic to make sure code is as decoupled as
    possible, and as easy to change in the future as possible. While doing all of
    this, we managed to create an application with a couple of features, trying to
    go around industry standards at the same time.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这一过程结束了不断重构和精炼架构、管理依赖项以及调整逻辑以确保代码尽可能解耦，同时尽可能容易地在未来进行更改。在完成所有这些工作时，我们设法创建了一个具有几个功能的应用程序，同时尝试绕过行业标准。
- en: We started this chapter by learning about middleware functions, something we'd
    previously used, even though we still hadn't learned about them. We understood
    how they work, and how they can be leveraged to add logic across applications
    and routes. To get a little more concrete, we went into specific examples and
    finished by implementing a few of them in the application. Here, we added common
    capabilities such as basic logging and request timing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习中间件函数开始了这一章，这是我们之前使用过，尽管我们还没有学习过它们的东西。我们理解了它们是如何工作的，以及它们如何被利用来在应用程序和路线中添加逻辑。为了更具体一点，我们进入了具体的例子，并以在应用程序中实现几个为例结束。在这里，我们添加了诸如基本日志记录和请求计时等常见功能。
- en: Then, we went on to finish our journey on authentication. After adding users
    and registration in the previous chapter, we started by implementing the capability
    to authenticate. We relied on an external package to manage our JWT tokens, which
    we used later for our authorization mechanism. After providing our users with
    a token, we had to make sure that the token was valid and only then let the user
    access the application. We added an authenticated route to the museums route,
    making sure it can only be accessed by authenticated users. Once again, middleware
    was used to check the token's validity and answer the request on error cases.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续完成认证的旅程。在上一章中添加了用户和注册功能后，我们开始实现认证功能。我们依赖一个外部包来管理我们的JWT令牌，我们稍后用于我们的授权机制。在向用户提供令牌后，我们必须确保令牌有效，然后才允许用户访问应用程序。我们在博物馆路线上添加了一个认证路线，确保它只能被认证用户访问。再次使用中间件来检查令牌的有效性并在错误情况下回答请求。
- en: 'We wrapped this chapter up by adding one more feature to the application: a
    connection to a real database. Before we did this, all our application modules
    were relying on an in-memory database. Here, we moved one of the modules, `users`,
    to a MongoDB instance. To do this, we leveraged the layers we previously created
    to separate business logic from our persistence and delivery mechanism. Here,
    we created and implemented what we called the MongoDB repository, ensuring the
    application is running smoothly but with a real persistence mechanism. We used
    MongoDB Atlas for this example.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向应用程序添加一个新功能来结束这一章：连接到真实数据库。在我们这样做之前，我们所有的应用程序模块都依赖于内存中的数据库。在这里，我们将其中一个模块，“用户”，移动到MongoDB实例。为了做到这一点，我们利用了之前创建的层来将业务逻辑与我们的持久化和交付机制分离。在这里，我们创建并实现了我们所谓的MongoDB存储库，确保应用程序运行顺利，但具有真正的持久化机制。我们为此示例使用了MongoDB
    Atlas。
- en: In the next chapter, we'll add a couple more things to our web application,
    namely the capability to manage secrets and configurations outside code, a well-known
    best practice. We'll also explore the possibilities of Deno when it comes to running
    code in the browser, among other things. The next chapter will wrap up this part
    of this book; that is, building the features of the application. Let's go!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向我们的网络应用程序添加一些内容，具体包括管理代码之外的秘密和配置的能力，这是一个众所周知的好实践。我们还将探索Deno在运行浏览器代码等方面的可能性，等等。下一章将结束这本书的这一部分；也就是说，构建应用程序的功能。让我们开始吧！
