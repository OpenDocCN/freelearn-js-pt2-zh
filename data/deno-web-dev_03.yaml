- en: '*Chapter 2*: The Toolchain'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 2 章*：工具链'
- en: Now that we're familiar with evented languages, Node's history, and the reasons
    that led to Deno, we're in good shape to start writing some code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如今我们熟悉了事件驱动语言，了解了 Node 的历史以及导致 Deno 产生的原因，我们就可以开始写一些代码了。
- en: In this chapter, the first thing we'll do is set up the environment and code
    editor. We'll proceed by writing our first Deno program and using the REPL to
    experiment with the runtime APIs. Then, we'll explore the module system and how
    Deno cache and module resolution works with practical examples. We'll understand
    versioning, and we'll also learn how to handle third-party dependencies. Then,
    we'll use the CLI to explore packages and their documentation, as well as how
    to install and reuse Deno scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先要做的是设置环境和代码编辑器。我们将通过编写我们的第一个 Deno 程序和使用 REPL 实验运行时 API 来继续。然后，我们将探讨模块系统以及
    Deno 缓存和模块解析如何通过实际示例工作。我们将了解版本控制，并将学习如何处理第三方依赖。然后，我们将使用 CLI 探索包及其文档，以及如何安装和重复使用
    Deno 脚本。
- en: After running and installing a few scripts, we'll dive into permissions by learning
    how the permission system works and how we can secure the code we run.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行和安装几个脚本之后，我们将深入研究权限，学习权限系统是如何工作的以及我们如何可以保障我们运行的代码的安全。
- en: On our journey of learning about the toolchain, we can't leave code formatting
    and linting out, so we'll also explore these topics in this chapter. We'll explore
    Deno's test suite by writing and running some simple tests, and we'll finish by
    presenting how Deno can bundle code into a self-sustainable binary or a single
    JavaScript file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解工具链的过程中，我们不能忽略代码格式化和验尸，所以我们在本章中也将探讨这些主题。我们将通过编写和运行一些简单的测试来探索 Deno 的测试套件，最后介绍
    Deno 如何将代码打包成一个自给自足的二进制文件或单个 JavaScript 文件。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up the environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Installing VS Code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 VS Code
- en: Hello World
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hello World
- en: The module system and third-party dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块系统和第三方依赖
- en: Running and installing scripts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和安装脚本
- en: Using the test command
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试命令
- en: Using permissions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用权限
- en: Formatting and linting code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化和验尸代码
- en: Bundling code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码打包
- en: Compiling to a binary
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译成二进制
- en: Using the upgrade command
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用升级命令
- en: Let's get started!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code present in this chapter can be found at [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter02](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter02).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中出现的所有代码都可以在 [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter02](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter02)
    找到。
- en: Setting up the environment
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: One of Deno's principles is to keep its single single executable as complete
    as possible. This decision, among others, dramatically facilitates the installation
    step. In this section, we'll install VS Code and the recommended plugins and learn
    how to install Deno on different systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 的一个原则是使其单一的可执行文件尽可能完整。这个决定，以及其他决策，大大简化了安装步骤。在本节中，我们将安装 VS Code 和推荐插件，并学习如何在不同的系统上安装
    Deno。
- en: Installing Deno
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Deno
- en: In the next few pages, we'll learn how to install Deno. To make sure everything
    written in this book runs smoothly, we'll be using version 1.7.5\.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将学习如何安装 Deno。为了确保本书中写的所有内容都能顺利运行，我们将使用版本 1.7.5。
- en: This is one of the rare parts of this book where things might differ, depending
    on your operating system. After the installation is complete, it doesn't make
    a difference how you installed Deno.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中为数不多的部分，根据您的操作系统，事情可能会有所不同。安装完成后，无论您如何安装 Deno，都没有区别。
- en: 'Let''s get practical and install Deno on our machines. The following bullet
    points show you how to install the runtime on different operating systems:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际操作并在我们的机器上安装 Deno。下面的子弹点展示了如何在不同的操作系统上安装运行时：
- en: '**Shell (Mac, Linux)**:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shell (Mac, Linux)**:'
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**PowerShell (Windows)**:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PowerShell (Windows)**:'
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, to make sure everything worked, let''s get the current Deno version by
    running the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了确保一切正常工作，让我们通过运行以下命令来获取当前的 Deno 版本：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We should get the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下输出：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have the correct versions of Deno installed, we can start writing
    and executing our programs. However, to make our experience smoother, we will
    install and configure our editor of choice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了正确版本的 Deno，我们可以开始编写和执行我们的程序了。然而，为了使我们的体验更加顺畅，我们将安装并配置我们选择的编辑器。
- en: Installing VS Code
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 VS Code
- en: VS Code is the editor we will be using throughout this book. This is mainly
    because it has an official Deno plugin. There are other editors that provide a
    pleasant experience with JavaScript and TypeScript, so feel free to use them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 是我们将在这本书中使用的编辑器。这主要是因为它有一个官方的 Deno 插件。还有其他提供 JavaScript 和 TypeScript
    愉悦体验的编辑器，所以您可以自由使用它们。
- en: 'These series of steps are not required for following the rest of this book
    flawlessly, so feel free to skip them. To install it, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤不是遵循本书剩余内容的必要步骤，所以请随意跳过它们。要安装它，请按照以下步骤操作：
- en: Go to [https://code.visualstudio.com/](https://code.visualstudio.com/) and click
    the **Download** button.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://code.visualstudio.com/](https://code.visualstudio.com/) 并点击 **下载**
    按钮。
- en: Once the download is complete, install it on your system.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，在您的系统上安装它。
- en: Once VS Code is installed, the last step is to install Deno's VS Code plugin.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 VS Code 后，最后一步是安装 Deno 的 VS Code 插件。
- en: 'In the `Deno` and install the Deno plugin authored by Denoland, which is the
    official one:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Deno` 上下文中，安装由 Denoland 编写的 Deno 插件，这是官方插件：
- en: '![Figure 2.1 – Plugin icon on VS Code''s left bar'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – VS Code 左侧栏的插件图标](img/Figure_2.1_B16380.jpg)'
- en: '](img/Figure_2.1_B16380.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.1_B16380.jpg)'
- en: Figure 2.1 – Plugin icon on VS Code's left bar
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – VS Code 左侧栏的插件图标
- en: 'This is what Deno''s VS Code plugin looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Deno 的 VS Code 插件的样子：
- en: '![Figure 2.2 – Deno extension on the VS Code Marketplace](img/Figure_2.2_B16380.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Deno 在 VS Code 市场中的扩展](img/Figure_2.2_B16380.jpg)'
- en: Figure 2.2 – Deno extension on the VS Code Marketplace
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Deno 在 VS Code 市场中的扩展
- en: 'To enable the Deno plugin in your projects, you must create a local VS Code
    folder where the workspace configuration files will live. To do that, we will
    create a folder named `.vscode` with a file inside it called `settings.json` and
    write the following in that file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你项目中启用 Deno 插件，你必须创建一个本地 VS Code 文件夹，该文件夹将包含工作区配置文件。为此，我们将创建一个名为 `.vscode`
    的文件夹，并在其中创建一个名为 `settings.json` 的文件，并在该文件中写入以下内容：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will make VS Code activate the extension inside the folder we're currently
    in. When using unstable features, we can also enable the `deno.unstable` setting,
    which is also mentioned in the plugin's documentation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 VS Code 激活当前文件夹内的扩展。在使用不稳定特性时，我们还可以启用 `deno.unstable` 设置，这也在插件文档中提到。
- en: Shell completions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 壳牌补全
- en: 'Deno also provides us with a way to generate shell completions. This way, we''ll
    be getting autocomplete suggestions when writing Deno commands on the Terminal.
    We can do this by running the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 还为我们提供了一种生成壳牌补全的方法。这样，在终端中编写 Deno 命令时，我们将获得自动完成建议。我们可以通过运行以下命令来实现：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The possible values for shell are `zsh`, `bash`, `fish`, `powershell`, and `elvish`.
    Make sure you choose the one you are using. This command will output the completions
    to stdout. You can then paste that into your shell profile ([https://deno.land/manual@v1.7.5/getting_started/setup_your_environment#shell-autocomplete](mailto:https://deno.land/manual@v1.6.0/getting_started/setup_your_environment#shell-autocomplete)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell` 的可能值有 `zsh`、`bash`、`fish`、`powershell` 和 `elvish`。确保你选择你正在使用的那个。此命令将输出补全内容到标准输出。然后你可以将内容粘贴到你的
    shell 配置文件中([https://deno.land/manual@v1.7.5/getting_started/setup_your_environment#shell-autocomplete](https://deno.land/manual@v1.6.0/getting_started/setup_your_environment#shell-autocomplete))。'
- en: With that, we've finished how to install it Deno. We also have the runtime and
    the editor installed and configured. Now, let's write a Hello World program with
    Deno!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了如何安装 Deno 的步骤。我们还安装并配置了运行时和编辑器。现在，让我们用 Deno 编写一个 Hello World 程序！
- en: Hello World
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: With everything in place, let's write our first program!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，让我们编写我们的第一个程序！
- en: 'First, we need to create a file named `my-first-deno-program.js` and write
    something that we''re familiar with. We''ll use the `console` API to write a message
    to the console:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个名为 `my-first-deno-program.js` 的文件，并写一些我们熟悉的内容。我们将使用 `console` API
    将消息写入控制台：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To execute this, let''s use the CLI we installed in the previous section. The
    command we must use to execute programs is called `run`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，让我们使用前面章节中安装的 CLI。我们必须使用名为 `run` 的命令来执行程序：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: All Deno CLI commands can be executed with the `--help` flag, which will detail
    all the command's possible behaviors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Deno CLI 命令都可以使用 `--help` 标志执行，这将详细说明命令的所有可能行为。
- en: At this point, we haven't really done anything we don't know what to do already.
    We just wrote a `console.log` file in the language that we're familiar with, JavaScript.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们实际上并没有做任何我们不知道该做什么的事情。我们只是用我们熟悉的 JavaScript 语言编写了一个 `console.log` 文件。
- en: The interesting thing is that we learned how to execute programs by using the
    `run` command. We'll explore this in more detail later in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们已经学会了使用`run`命令来执行程序。我们稍后在本书中详细探讨这个。
- en: REPL
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新加载
- en: The **Read Eval Print Loop**, also known as the **REPL**, is a tool that is
    commonly used in interpreted languages. It allows users to run lines of code and
    get their immediate output. Node.js, Ruby, and Python are a few examples of languages
    where it is heavily used. Deno is no exception.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**阅读-评估-打印循环**，也称为**REPL**，是在解释型语言中常用的工具。它允许用户运行代码行并获得即时输出。Node.js、Ruby和Python是几个大量使用它的语言例子。Deno也不例外。'
- en: 'To open it, you just need to run the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开它，你只需要运行以下命令：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can now spend some time exploring the language (hint: there''s tab completion).
    If you are curious about what APIs are available, you''re in the right place to
    try them out. We''ll deep dive into those later, but just to give you a few suggestions,
    you can look at the *Deno* namespace, Web API-compatible functions such as `fetch`,
    or objects such as `Math` or `window`, all of which are listed in Deno''s documentation
    ([https://doc.deno.land/builtin/stable](https://doc.deno.land/builtin/stable)).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以花些时间去探索这门语言（提示：有标签完成功能）。如果你好奇有哪些API可以使用，这里是尝试它们的好地方。我们稍后会深入那些内容，但为了给你一些建议，你可以看看*Deno*命名空间，与Web
    API兼容的函数如`fetch`，或者如`Math`或`window`的对象，这些都在Deno的文档中列出（[https://doc.deno.land/builtin/stable](https://doc.deno.land/builtin/stable)）。
- en: Try them out!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 试试它们吧！
- en: Eval
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估
- en: 'Another way to execute code that doesn''t live in a file is by using the `eval`
    command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种执行不在文件中的代码的方法是使用`eval`命令：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `eval` command can be useful to run simple, inline scripts.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`命令可以用来运行简单的内联脚本。'
- en: So far, the programs we've have written have been quite simple. We just logged
    values to the console in a few different ways. However, as we start getting closer
    to the real world, we know we'll write more complex logic. With more complex logic
    comes more bugs and thus the need to debug our code. That's what we'll learn about
    next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所编写的程序相当简单。我们只是以几种不同的方式将值输出到控制台。然而，当我们开始接近现实世界时，我们知道我们将编写更复杂的逻辑。更复杂的逻辑意味着更多的错误，因此需要调试我们的代码。这是我们接下来要学习的内容。
- en: Debugging code in Deno
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Deno中调试代码
- en: Even when we're following best practices and doing our best to write simple,
    clean code, any relevant program is very likely to need debugging once in a while.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们遵循最佳实践并尽力编写简单、干净的代码时，任何相关的程序都很有可能会偶尔需要调试。
- en: Mastering the ability to quickly run and debug code is one of the best ways
    to improve your learning curve for any technology. This skill makes it easy to
    test and understand how stuff works by trial and error and fast experimentation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握快速运行和调试代码的能力是提高任何技术学习曲线的最佳方法之一。这项技能使得通过尝试和错误以及快速实验来测试和理解事物变得容易。
- en: Let's learn how can we debug our code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习一下如何调试我们的代码。
- en: 'The first step is to create a second program. Let''s add a couple of variables
    that we can inspect later. The main objective of this program is to return the
    current time. We''ll be using the already known `Date` object to do this. Let''s
    call this file `get-current-time.js`, like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个第二个程序。让我们添加几个变量，稍后可以检查。这个程序的主要目标是返回当前时间。我们将使用已知的`Date`对象来完成这个任务。让我们将这个文件命名为`get-current-time.js`，像这样：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What if we want to debug the value of the `now` variable before it prints to
    the console? This is where debugging comes in useful. Let''s run the same program
    but with the `--inspect-brk` flag:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在它打印到控制台之前调试`now`变量的值，这就是调试发挥作用的地方。让我们用`--inspect-brk`标志运行同一个程序：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now open Google Chrome at `chrome://inspect/`. A remote target running
    on localhost called `deno` will be listed. By clicking on `inspect`, the Chrome
    DevTools inspector window will open and its execution will stop on the first line:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以打开Google Chrome浏览器，输入`chrome://inspect/`。在localhost上运行的远程目标 called `deno`
    将会列出。点击`inspect`后，Chrome DevTools检查器窗口将打开，并且执行将暂停在第一行：
- en: '![Figure 2.3 – Chrome stopping on the first line to be debugged'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – Chrome在要调试的第一行停止'
- en: '](img/Figure_2.3_B16380.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B16380.jpg)'
- en: Figure 2.3 – Chrome stopping on the first line to be debugged
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – Chrome在要调试的第一行停止
- en: At this point, we can add breakpoints, log certain values, inspect variables,
    and so on. It enables the same as what we can do when we're debugging on Node
    or in the browser.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们可以添加断点、记录某些值、检查变量等等。它使得我们可以像在Node上或浏览器中调试时做的那样做相同的事情。
- en: The `--inspect` flag could have also been used for this. However, we've used
    `--inspect-brk` here for convenience. Both have similar behaviors, but `inspect`
    requires a *debugger* to be present in the code. When the code executes and interprets
    the *debugger* keyword, it tries to connect to an already running inspector instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其实也可以使用`--inspect`标志来进行这个操作。然而，我们在这里使用了`--inspect-brk`以方便起见。这两个选项行为相似，但`inspect`需要在代码中存在一个*调试器*。当代码执行并解释*调试器*关键字时，它会尝试连接到一个已经运行的检查器实例。
- en: Now that we understand how to run and debug code, we can start writing our own
    programs. There's still much to learn, but we are already comfortable with the
    bare minimum.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了如何运行和调试代码，我们就可以开始编写自己的程序了。还有很多要学的，但我们已经熟悉了最基本的内容。
- en: As we start writing our programs and our code base grows, it is very likely
    that we'll start extracting logic into different modules. As these modules become
    reusable, we might extract them into packages so that they can be shared across
    projects. That's why we need to understand how Deno handles module resolution,
    which we'll do in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写程序并随着代码库的增长，我们很可能会开始将逻辑提取到不同的模块中。当这些模块变得可重用时，我们可能会将它们提取成包，以便它们可以在项目之间共享。这就是为什么我们需要了解Deno如何处理模块解析，我们将在下一节中进行了解。
- en: Modules and third-party dependencies
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和第三方依赖
- en: Deno uses ECMAScript modules and imports that are fully compatible with the
    browser. The path to a module is absolute, so it includes the file extension,
    which is also a standard in the *browser world*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Deno使用与浏览器完全兼容的ECMAScript模块和导入。模块的路径是绝对的，所以它包括文件扩展名，这也是浏览器世界中的一个标准。
- en: Deno takes the approach of being a *browser for scripts* quite seriously. One
    of the things it has in common with web browsers is that it deeply leverages URLs.
    They're one of the most flexible ways to share a resource and work beautifully
    on the web. Why not use them for module resolution? That's what browsers did.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Deno非常认真地采取了作为一个为脚本提供*浏览器*的方法。它与网络浏览器共有的一个特点是它深刻地利用了URL。它们是分享资源最灵活的方式，在网络上表现得很美丽。为什么不用它们进行模块解析呢？浏览器就是这么做的。
- en: The fact that the path for modules is absolute makes it possible not to depend
    on third-party entities such as npm, or complex module resolution strategies.
    With absolute imports, we can import code directly from GitHub, from a proprietary
    server, or even from a gist. The only requirement is that it has a URL.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模块路径是绝对的这个事实使得我们不需要依赖像npm这样的第三方实体，或者复杂的模块解析策略。有了绝对导入，我们可以直接从GitHub、私有服务器，甚至从一个gist导入代码。唯一的要求是它有一个URL。
- en: This decision enables a completely decentralized module distribution to be used
    and makes module resolution inside Deno simple and browser compatible. This is
    something that doesn't happen on Node.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定使得可以采用完全去中心化的模块分布，并使得Deno内部的模块解析简单且与浏览器兼容。这是在Node上不会发生的事情。
- en: 'Deno even leverages URLs for versioning. For instance, to import version 0.83.0
    the HTTP server from the standard library, we would use the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Deno甚至利用URL进行版本控制。例如，要导入标准库中0.83.0版本的HTTP服务器，我们将使用以下代码：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And that's how simple you can import a module. Here, the code is loading from
    [https://deno.land/](https://deno.land/), but modules can be loaded from anywhere
    else. The only requirement is that there's a link to it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是导入一个模块有多么简单。在这里，代码是从[https://deno.land/](https://deno.land/)加载的，但模块可以从任何其他地方加载。唯一的要求是有一个链接指向它。
- en: For instance, if you have your own server where the files are available via
    a URL, you can directly use them within Deno. Previously, we learned that Deno
    automatically installs and caches dependencies, so let's learn a little more about
    how that works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有自己的服务器，文件可以通过URL访问，您可以在Deno中直接使用它们。之前，我们了解到Deno会自动安装并缓存依赖项，那么让我们了解更多关于它是如何工作的。
- en: Locally cached dependencies
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地缓存的依赖项
- en: We already, we learned that Deno doesn't have conventions such as `node_modules`.
    For someone coming from Node, this might sound strange. Does this mean your code
    is always fetching modules from the internet? No. Can you still work offline?
    Yes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到Deno没有像`node_modules`这样的约定。对于来自Node的人来说，这可能听起来很奇怪。这意味着你的代码总是从互联网上获取模块吗？不是。你仍然可以离线工作吗？可以。
- en: Let's see this in practice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实践中看看这个。
- en: 'Create a file called `hello-http-server.js` and add the following code there:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`hello-http-server.js`的文件，并添加以下代码：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can probably guess, this program starts an HTTP server at port `8080`
    and responds to every request made with `Hello deno`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，这个程序在端口`8080`上启动一个HTTP服务器，并对每个请求响应`Hello deno`。
- en: If that still feels strange to you, don't worry – we will have a more in-depth
    look at the standard library in the next chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这仍然很奇怪，不用担心——我们将在下一章更深入地介绍标准库。
- en: 'Let''s run the program and pay attention to what Deno does before executing
    the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行程序，并注意Deno在执行代码之前做了什么：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What happened? Before it runs the code, Deno looks at the code's imports, downloads
    any dependencies, compiles them, and stores them in a local cache. There's still
    an error at the end, but we'll get to that later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么事？在运行代码之前，Deno查看代码的导入，下载任何依赖项，编译它们，并将它们存储在本地缓存中。最后仍然有一个错误，但我们稍后再解决这个问题。
- en: 'To understand what Deno does with the downloaded files, we''ll use another
    command named `info`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解Deno如何处理下载的文件，我们将使用另一个名为`info`的命令：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This prints information about Deno's installation. Note `DENO_DIR`, which is
    the path where Deno is storing its local cache. If we navigate there, we can access
    the `.js` files and respective source maps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印有关Deno安装的信息。注意`DENO_DIR`，这是Deno存储其本地缓存的路径。如果我们导航到那里，我们可以访问`.js`文件和相应的源映射。
- en: After downloading and caching the modules for the first time, Deno will not
    redownload them and will keep using the local cache until it is explicitly asked
    not to.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次下载并缓存模块之后，Deno将不会重新下载它们，并将一直使用本地缓存，直到明确要求它不要这样做。
- en: Caching without running the code
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不运行代码的缓存
- en: 'To make sure you have a local copy of your code''s dependencies without having
    to run it, you can use the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你有一个本地副本，而不必运行你的代码的依赖项，你可以使用以下命令：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will do the exact same thing that Deno does before running your code; the
    only difference is that it doesn't run. Due to this, we can establish some parallelism
    between the `deno cache` command and what `npm install` does on Node.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将做与Deno在运行你的代码之前完全相同的事情；唯一的区别是它不会运行。由于这个原因，我们可以建立`deno cache`命令和Node上`npm install`所做的操作之间的并行性。
- en: Reloading the cache
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新加载缓存
- en: 'The `cache` and `run` commands can use the `--reload` flag to force the dependencies
    to be downloaded. A comma-separated list of modules that must be reloaded can
    be sent as a parameter to the `--reload` flag:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache`和`run`命令可以使用`--reload`标志来强制下载依赖项。可以使用`--reload`标志的参数发送需要重新加载的模块的逗号分隔列表：'
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, only modules from [https://deno.land/std@0.83.0/http/server.ts](mailto:https://deno.land/std@0.64.0/http/server.ts)
    would be redownloaded, as we can confirm by looking at the command's output.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，只有来自[https://deno.land/std@0.83.0/http/server.ts](https://deno.land/std@0.83.0/http/server.ts)的模块会被重新下载，正如我们可以通过查看命令的输出确认的那样。
- en: Finally running the server
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最后运行服务器
- en: 'Now that the dependencies have been downloaded, we still have something preventing
    us from running the server, a `PermissionDenied` error:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然依赖项已经下载，那么阻止我们运行服务器的东西就是一个`PermissionDenied`错误：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For now, let''s follow the recommendation and add the `--allow-net` flag, which
    will grant our program full network access. We''ll get into permissions later
    in this chapter:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们遵循建议并添加`--allow-net`标志，这将授予我们的程序完全的网络访问权限。我们将在本章后面讨论权限：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip (Windows)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 提示（Windows）
- en: Keep in mind that, if you are using Windows, you might get Windows' native network
    authorization popup, informing you that a program (Deno) is trying to access the
    network. If you want this web server to be able to run, you should click **Allow
    access**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你使用的是Windows，你可能会遇到Windows本地的网络授权弹窗，通知你有一个程序（Deno）正在尝试访问网络。如果你想让这个Web服务器能够运行，你应该点击**允许访问**。
- en: 'Now, our server should be running. If we `curl` to port `8080`, it will show
    us `Hello` `Deno`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的服务器应该正在运行。如果我们用`curl`访问端口`8080`，它会显示`Hello` `Deno`：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This wraps up for our simplest web server; we'll come back to this in a few
    pages.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最简单的Web服务器的结束；我们将在几页后回到这个话题。
- en: Managing dependencies
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: If you have used other tools, or even Node.js itself, you might be feeling that
    it is not very intuitive to have URLs all around the code. We can also argue that,
    by directly writing URLs in our code, we might cause problems, such as having
    two different versions of the same dependency or having typos in the URL.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过其他工具，甚至是Node.js本身，你可能会觉得代码中到处都是URL不太直观。我们也可以争论说，通过直接在代码中写入URL，我们可能会造成一些问题，比如同一个依赖项有两个不同的版本，或者URL有拼写错误。
- en: Deno solved this problem by getting rid of complex module resolution strategies
    and using plain JavaScript and absolute imports instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Deno通过摒弃复杂的模块解析策略，使用plain JavaScript和绝对导入来解决这个问题。
- en: The proposed solution to keep track of dependencies, which is no more than a
    suggestion, is to use a file that exports all the required dependencies and place
    them in a single file that contains URLs. Let's see it in action.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪依赖项的提议解决方案，不过就是一个建议，那就是使用一个导出所有所需依赖项的文件，并将其放在一个包含URL的单一文件中。让我们看看它是如何工作的。
- en: 'Create a file called `deps.js` and add our dependencies there, exporting the
    ones we need:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`deps.js`的文件，并在其中添加我们的依赖项，导出我们需要的那些：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using the preceding syntax, we're importing the `serve` method from the standard
    library's HTTP server and exporting it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的语法，我们从标准库的HTTP服务器中导入了`serve`方法。
- en: 'Back in our `hello-http-server.js` file, we can now change the imports so that
    we can use the exported function from the `deps.js` file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`hello-http-server.js`文件，我们现在可以更改导入，以便我们可以从`deps.js`文件中使用导出的函数：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, every time we add a dependency, we can run `deno cache deps.js` to guarantee
    that we have a local copy of the module.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们添加一个依赖项时，我们可以运行`deno cache deps.js`来保证我们有一个模块的本地副本。
- en: This is Deno's way of managing dependencies. It is that simple – no magic, no
    complex standards, just a file that imports and exports symbols.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Deno管理依赖项的方式。就是这么简单——没有魔法，没有复杂的标准，只是一个导入和导出符号的文件。
- en: Integrity checking
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整性检查
- en: Now that you know how to import and manage third-party dependencies, you might
    be feeling that something is still missing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道了如何导入和管理第三方依赖项，你可能觉得还缺少了一些东西。
- en: '*What can guarantee that the next time we, a coworker, or even a CI tries to
    install the project that our dependencies haven''t changed?*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*怎样才能保证下次我们、同事，甚至是CI在尝试安装项目时，我们的依赖项没有发生变化呢？*'
- en: That's a fair question, and since it's a URL, this might happen.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个公平的问题，而且因为这是一个URL，这可能会发生。
- en: We'll can solve this by using integrity checking.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用完整性检查来解决这个问题。
- en: Generating a lock file
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成锁文件
- en: Deno has a feature that can store and check sub-resource integrity by using
    a JSON file, similar to the lock file approach that's used by other technologies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Deno具有一种可以通过使用JSON文件存储和检查子资源完整性的特性，这与使用锁文件方法的其他技术类似。
- en: 'To create our first lock file, let''s run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的第一个锁文件，请运行以下命令：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using the `--lock` flag, we select the name of the file, and by using `--lock-write`,
    we're giving Deno permission to create or update that same file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--lock`标志，我们选择文件的名称，通过使用`--lock-write`，我们正在给Deno创建或更新该文件的权限。
- en: 'Looking at the generated `lock.json` file, this is what we''ll find there:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的`lock.json`文件，我们会在那里找到以下内容：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It generates a JSON object where the keys are the paths to dependencies and
    the values are the hashes Deno uses to warrant resource integrity.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成一个JSON对象，其中键是依赖项的路径，值是Deno用来保证资源完整性的哈希值。
- en: This file should then be checked into your version control system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件应该随后被提交到你的版本控制系统。
- en: In the next section, we'll learn how to install dependencies and make sure everyone
    is running the exact same version of the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何安装依赖项，并确保每个人都运行着完全相同的代码版本。
- en: Installing dependencies with a lock file
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用锁文件安装依赖项
- en: 'Once the lock file has been created, anyone that wants to download the code
    can run the cache command with the `--lock` flag. This enables integrity checking
    while you''re downloading dependencies:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦锁文件被创建，任何想要下载代码的人都可以运行带有`--lock`标志的cache命令。这在你下载依赖项时启用完整性检查：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is also possible to use the `--lock` flag with the `run` command to enable
    runtime verification:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`run`命令的`--lock`标志来启用运行时验证：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Important note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When using the lock flags with the `run` command, code containing dependencies
    that haven't been cached yet will not be checked against the lock file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`run`命令的锁标志时，包含尚未缓存的依赖关系的代码将不会与锁文件进行核对。
- en: To make sure the new dependencies are checked at runtime, we can use the `--cached-only`
    flag.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在运行时检查新的依赖关系，我们可以使用`--cached-only`标志。
- en: This way, Deno will throw an error if any dependencies that are not in the `lock.json`
    file are used by our code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果任何不在`lock.json`文件中的依赖关系被我们的代码使用，Deno将会抛出一个错误。
- en: And that's all we need to do to make sure we're running the exact versions of
    the dependencies we want, eliminating any problems that might come out of version
    changes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们确保运行我们想要的依赖关系的确切版本，消除可能由于版本更改而出现的问题的所有工作。
- en: Import maps
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入映射
- en: Deno supports import maps ([https://github.com/WICG/import-maps](https://github.com/WICG/import-maps)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Deno支持导入映射（[https://github.com/WICG/import-maps](https://github.com/WICG/import-maps)）。
- en: 'If you are not familiar with what they are, I''ll explain them briefly for
    you: they are used to control JavaScript imports. If you''ve used JavaScript with
    code bundlers such as webpack before, then this is a feature similar to what you
    know as "aliases".'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉它们是什么，我会为你简要解释一下：它们用于控制JavaScript导入。如果你之前用过像webpack这样的JavaScript代码打包工具，那么这是一个类似于你所知的“别名”的功能。
- en: Important note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This feature is currently unstable, so it must be enabled using the `--unstable`
    flag.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性目前是不稳定的，因此必须使用`--unstable`标志来启用。
- en: Let's create a JSON file. The name doesn't matter here, but we'll name it `import-maps.json`
    for simplicity.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个JSON文件。这里文件的名字无关紧要，但为了简单起见，我们将它命名为`import-maps.json`。
- en: 'Inside this file, we''ll create a JavaScript object with the `imports` key.
    In this object, any keys will be the module names and any values will be the real
    import paths. Our first *import map* will be one that maps the `http` word to
    the standard library HTTP module''s root:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将创建一个带有`imports`键的JavaScript对象。在这个对象中，任何键将是模块名称，任何值将是真实的导入路径。我们第一个*导入映射*将是将`http`单词映射到标准库HTTP模块的根部的映射：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By doing this, we can now import the standard library''s HTTP module into our
    `deps.js` file, like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，我们现在可以在我们的`deps.js`文件中导入标准库的HTTP模块，像这样：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To run it, we will use the `--import-map` flag. By doing this, we can select
    the file where the import maps are. Then, because this feature is still unstable,
    we must use the `--unstable` flag:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它时，我们将使用`--import-map`标志。这样做时，我们可以选择包含导入映射的文件。然后，因为这个特性仍然不稳定，我们必须使用`--unstable`标志：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see, our code runs perfectly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的代码运行得非常完美。
- en: This is an easy way to customize module resolution that doesn't depend on any
    external tools. It's also been proposed as something to be added to browsers.
    Hopefully, this will be accepted in the near future.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个轻松定制模块解析，且不依赖于任何外部工具的方法。它也已经被提议作为添加到浏览器中的内容。希望这个功能能在不久的将来被接受。
- en: Inspecting modules
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查模块
- en: We just used the standard library's HTTP module to create a server. Don't worry
    if you are not very familiar with the standard library yet; we'll explain it in
    more detail in the next chapter. For now, all we need to know is that we can explore
    its modules on its website ([https://deno.land/std](https://deno.land/std)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用了标准库的HTTP模块来创建一个服务器。如果你还不是非常熟悉标准库，不用担心；我们将在下一章更详细地解释它。现在，我们只需要知道我们可以在其网站上探索它的模块（[https://deno.land/std](https://deno.land/std)）。
- en: Let's take a look at the module we used in the previous script, the HTTP module,
    and use Deno to find out more information about it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前一个脚本中使用的模块，HTTP模块，并使用Deno了解更多关于它的信息。
- en: 'We can use the `info` command to do this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`info`命令来完成这个：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command lists a great amount of information about the HTTP module. Let's
    break it down.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令列出了关于HTTP模块的大量信息。让我们逐一分析。
- en: On the first line, we get the path to the cached version of the script. On the
    line after that, we see the type of the file. We already know that the standard
    library was written in TypeScript, so this should be of no surprise to us. The
    next line is also a path, this time for the compiled version of the module, since
    TypeScript modules are compiled to JavaScript in the download step.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们获取脚本的缓存版本的路径。在那之后的一行，我们看到文件的类型。我们已经知道标准库是用TypeScript编写的，所以这应该不会让我们感到惊讶。下一行也是一个路径，这次是模块的编译版本的路径，因为TypeScript模块在下载步骤中编译为JavaScript。
- en: The last part of the command's output is the dependency tree. By looking at
    it, we can quickly identify that it just links to other modules in the standard
    library.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出的最后部分是依赖树。通过查看它，我们可以快速识别它只是链接到标准库中的其他模块。
- en: Tip
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We can use the `--unstable` and `--json` flags together with `deno` `info` to
    get a programmatically accessible JSON output.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`--unstable`和`--json`标志与`deno info`一起使用，以获得一个可以通过编程方式访问的JSON输出。
- en: When using third-party modules, more than knowing what they depend on, we need
    to know what functions and objects are made available by the module. We'll learn
    about this in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用第三方模块时，我们不仅需要知道它们依赖什么，还需要知道模块提供了哪些函数和对象。我们将在下一节学习这一点。
- en: Exploring the documentation
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索文档
- en: Documentation is a crucial aspect of any software project. Deno does a good
    job of keeping all the APIs well-documented, and TypeScript helps a lot with this.
    As the standard library and runtime functions are all written in TypeScript, most
    of the documentation is automatically generated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是任何软件项目的一个重要方面。Deno在这方面做得很好，所有API的文档都维护得很好，TypeScript在这方面提供了很大的帮助。由于标准库和运行时函数都是用TypeScript编写的，因此大部分文档都是自动生成的。
- en: The documentation is available at [https://doc.deno.land/](https://doc.deno.land/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可在[https://doc.deno.land/](https://doc.deno.land/)找到。
- en: If you don't have internet access and want to access the documentation of a
    module you have installed locally, Deno has got you covered.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能访问互联网并且想要访问你本地安装模块的文档，Deno可以为你提供帮助。
- en: Many editors, namely VS Code, allow you to do this, with the famous *Cmd/Ctrl*
    + click being an example. However, Deno doesn't depend on editor features for
    this as the `doc` command provides all the essential features you'll need.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编辑器，尤其是VS Code，允许你这样做，著名的*Cmd/Ctrl* + 点击就是一个例子。然而，Deno不依赖编辑器特性来实现这一点，因为`doc`命令提供了你将需要的所有基本功能。
- en: 'Let''s have a look at the documentation for the standard library''s HTTP module:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看标准库的HTTP模块的文档：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can now see the exposed methods and types.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到暴露的方法和类型。
- en: 'In one of our previous programs, we used the `serve` method. To find out more
    about this specific method, we can send the method (or any other symbol) name
    as a second argument:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的某个程序中，我们使用了`serve`方法。为了了解更多关于这个特定方法的信息，我们可以将方法（或任何其他符号）名称作为第二个参数发送：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a very useful feature that enables developers to navigate the documentation
    of the locally installed modules without having to depend on an editor.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的功能，它使开发者能够在不依赖编辑器的情况下浏览本地安装模块的文档。
- en: 'As we will learn in the next chapter, and as you probably noticed by using
    the REPL, Deno has a built-in API. To check out its documentation, we can run
    the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下一章将要学习的那样，通过使用REPL，你可能会注意到Deno有一个内置的API。要查看其文档，我们可以运行以下命令：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The output will be massive as it lists all the public methods and types.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的内容将会非常庞大，因为它列出了所有的公共方法和类型。
- en: 'In *nix systems, this can easily be piped into an application such as `less`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在*nix系统中，这可以很容易地通过管道传送到像`less`这样的应用程序：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similar to remote modules, it''s also possible to filter by method name. Take,
    for instance, the `writeFile` function that''s present in Deno''s namespace:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与远程模块类似，也可以通过方法名进行过滤。例如，Deno命名空间中存在的`writeFile`函数：
- en: '[PRE35]ts'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]ts'
- en: const encoder = new TextEncoder();
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: const encoder = new TextEncoder();
- en: const data = encoder.encode("Hello world\n");
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: const data = encoder.encode("Hello world\n");
- en: await Deno.writeFile("hello1.txt", data);  // overwrite "hello1.txt" or create
    it
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: await Deno.writeFile("hello1.txt", data);  // 覆盖"hello1.txt"或创建它
- en: 'await Deno.writeFile("hello2.txt", data, {create: false});  // only works if
    "hello2.txt" exists'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'await Deno.writeFile("hello2.txt", data, {create: false});  // 只有当"hello2.txt"存在时才有效'
- en: 'await Deno.writeFile("hello3.txt", data, {mode: 0o777});  // set permissions
    on new file'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'await Deno.writeFile("hello3.txt", data, {mode: 0o777});  // 设置新文件的权限'
- en: 'await Deno.writeFile("hello4.txt", data, {append: true});  // add data to the
    end of the file'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'await Deno.writeFile("hello4.txt", data, {append: true});  // 将数据添加到文件的末尾'
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `doc` command is a useful part of the development workflow. However, if
    you have internet access and want to access it in a more digestible and visual
    way, [https://doc.deno.land/](https://doc.deno.land/) is the place to go.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`doc`命令是开发工作流程中的一个有用部分。然而，如果你能访问互联网并且想要以更易消化和视觉化的方式访问它，应该去[https://doc.deno.land/](https://doc.deno.land/)。'
- en: You can use the documentation website to find out more about the built-in APIs
    or standard library modules. In addition, it also allows you to display the documentation
    for any module that's available. To do this, we just need to replace the `://`
    part of the module's URL with a single backslash, `/`, and prepend [https://doc.deno.land/](https://doc.deno.land/)
    to the URL.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用文档网站了解更多关于内置API或标准库模块的信息。此外，它还允许你显示任何可用的模块的文档。为此，我们只需将模块URL的`://`部分替换为一个反斜杠`\`，并在URL前加上[https://doc.deno.land/](https://doc.deno.land/)。
- en: For instance, to access the documentation of the HTTP module, the URL would
    be [https://doc.deno.land/https/deno.land/std@0.83.0/http/server.ts](mailto:https://doc.deno.land/https/deno.land/std@0.64.0/http/server.ts).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要访问HTTP模块的文档，URL将是 [https://doc.deno.land/https/deno.land/std@0.83.0/http/server.ts](https://doc.deno.land/https/deno.land/std@0.83.0/http/server.ts)。
- en: If you navigate to that URL, a clean interface will be displayed containing
    the module's documentation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到那个URL，将显示一个干净的界面，包含模块的文档。
- en: We now know how to use and explore third-party modules. However, as we start
    writing our applications, there might be some utilities that we want to share
    across projects. We may also want to have that specific package available everywhere
    in our system. The next section will help us do that.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用和探索第三方模块。然而，当我们开始编写我们的应用程序时，可能有一些工具我们要在各个项目中共享。我们可能还想让那个特定的包在我们系统的每个地方都可用。下一节将帮助我们做到这一点。
- en: Running and installing scripts
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和安装脚本
- en: 'In one of his first talks, and in Deno'' first version release notes ([https://deno.land/posts/v1#a-web-browser-for-command-line-scripts](https://deno.land/posts/v1#a-web-browser-for-command-line-scripts))
    Dahl used a sentence I like a lot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在他最早的几次演讲中，在Deno的第一个版本发布说明中（[https://deno.land/posts/v1#a-web-browser-for-command-line-scripts](https://deno.land/posts/v1#a-web-browser-for-command-line-scripts)），Dahl使用了我非常喜欢的一句话：
- en: '"Deno is like a web browser for command-line scripts."'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: “Deno是命令行脚本的网络浏览器。”
- en: Every time I use Deno, this sentence makes more and more sense to me. I'm sure
    it will also start to make sense for you as the book proceeds. Let's explore it
    a little further.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我使用Deno时，这句话变得越来越有意义。我确信随着本书的进行，它也会对你有意义。让我们更深入地探索一下。
- en: In a browser, when you access a URL, it runs the code that is there. It interprets
    the HTML and the CSS, and then executes some JavaScript.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，当你访问一个URL时，它会运行那里的代码。它解释HTML和CSS，然后执行一些JavaScript。
- en: Deno, by following its premise of being a browser for scripts, just needs a
    URL to run code. Let's see it in action.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Deno，遵循其作为脚本浏览器的前提，只需要一个URL来运行代码。让我们看看它是如何工作的。
- en: 'Honestly, it is not very different from what we''ve already done a couple of
    times already. As a refresher, the last time we executed our simple web server,
    we did the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，这与我们之前已经做过的事情并没有太大区别。作为复习，上次我们执行简单的Web服务器时，我们做了以下事情：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, `hello-http-server.js` was just a file in the current folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`hello-http-server.js`只是一个当前文件夹中的文件。
- en: Let's try to do the same but with a remote file – a file that is served through
    HTTP.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用一个远程文件来做同样的事情——一个通过HTTP提供服务的文件。
- en: 'We''ll execute an "echo server" from the Deno standard library''s set of examples.
    You can check out the code for this here ([https://deno.land/std@0.83.0/examples/echo_server.ts](mailto:https://deno.land/std@0.64.0/examples/echo_server.ts)).
    It is a server that echoes back whatever is sent to it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Deno标准库的示例集中执行一个“回声服务器”。你可以在这里查看这个代码([https://deno.land/std@0.83.0/examples/echo_server.ts](https://deno.land/std@0.83.0/examples/echo_server.ts))。这是一个回声服务器，无论发送给它什么都会回显：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Important note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you're using a Windows machine, it might not be possible to access `0.0.0.0:8080`;
    you should access `localhost:8080` instead. They both refer to the same thing
    in your local machine. However, when `0.0.0.0` appears throughout the rest of
    book, you should try to access `localhost` if you're running Windows.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows系统，可能无法访问`0.0.0.0:8080`；你应该访问`localhost:8080` instead. 它们都指的是你本地机器上的同一件事。然而，当`0.0.0.0`出现在本书的其他部分时，如果你正在运行Windows，你应该尝试访问`localhost`。
- en: As it happens, every time files are not cached, Deno downloads and executes
    them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 碰巧的是，每次文件没有被缓存时，Deno都会下载并执行它们。
- en: Does it differ that much from a web browser? I wouldn't say so. We gave it a
    URL, and it ran the code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它与网络浏览器区别有多大？我认为没有太大区别。我们给了它一个URL，它运行了代码。
- en: 'To make sure it is working, we can establish a Telnet ([https://en.wikipedia.org/wiki/Telnet](https://en.wikipedia.org/wiki/Telnet))
    connection and send a message that the server echoes back:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它正常工作，我们可以建立一个Telnet连接（[https://en.wikipedia.org/wiki/Telnet](https://en.wikipedia.org/wiki/Telnet)）并发送服务器回显的消息：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can do this with any available Telnet client; here, we're using a macOS
    client that we installed via Homebrew ([https://brew.sh/](https://brew.sh/)).
    The first "hello buddy" is the message we sent, while the latter is the one that
    was echoed back. With this, we can verify that the echo server is working.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何可用的Telnet客户端；在这里，我们使用了一个通过Homebrew（[https://brew.sh/](https://brew.sh/)）安装的macOS客户端。第一个“hello
    buddy”是我们发送的消息，而后一个是回显的消息。通过这个，我们可以验证回显服务器是否正常工作。
- en: Important note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If you are using any other telnet client, make sure you enable "Local line editing"
    setting. Some clients don't have this enabled by default and send characters as
    you type them, resulting in a message with duplicated characters. The image below
    shows you how can you configure that setting in PuTTY for Windows.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用任何其他的telnet客户端，请确保您启用了“本地行编辑”设置。一些客户端默认不启用此设置，并且在你输入字符时发送字符，导致消息中出现重复的字符。下面的图片展示了如何在Windows上的PuTTY中配置这个设置。
- en: '![Figure 2.4 – PuTTY local line editing setting'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – PuTTY本地行编辑设置'
- en: '](img/Figure_2.4_B16380.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.4_B16380.jpg)'
- en: Figure 2.4 – PuTTY local line editing setting
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – PuTTY本地行编辑设置
- en: 'This confirms what we previously stated, in that Deno uses the same approach
    to run code it uses to resolve modules: it treats local and remote codes in a
    similar way.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了我们之前所说的，即Deno用相同的方法运行代码和解决模块：它以类似的方式处理本地和远程代码。
- en: Installing utility scripts
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装实用脚本
- en: There are utility programs we write once and those that we use multiple times.
    Sometimes, to facilitate reusing them, we just copy those scripts from project
    to project. For others, we keep them in a GitHub repository and keep going there
    to get them. The ones we use the most might need to be wrapped in a shell script,
    added it `/usr/local/bin` (on *nix systems) and made usable across our system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有些实用程序我们写一次，而有些我们多次使用。有时，为了方便重用，我们只是将那些脚本从一个项目复制到另一个项目。对于其他的，我们保存在一个GitHub仓库中，并且一直去那里获取它们。我们最常使用的可能需要被包装在shell脚本中，添加到`/usr/local/bin`（在*nix系统上）并在我们的系统上使其可用。
- en: For this, Deno provides the `install` command.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Deno提供了`install`命令。
- en: 'This command wraps a program into a thin shell script and puts it into the
    installation bin directory. The permissions for the script are set at the time
    of its installation and never asked for again:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将一个程序包装在一个薄的壳脚本中，并将其放入安装的bin目录中。脚本的权限在安装时设置，此后不再询问：
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we used another module from the standard library called `file_server`.
    It creates an HTTP server that serves the current directory. You can see its code
    by accessing the import URL ([https://deno.land/std@0.83.0/http/file_server.ts](mailto:https://deno.land/std@0.64.0/http/file_server.ts)).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了标准库中的另一个模块叫做`file_server`。它创建了一个HTTP服务器来服务当前目录。您可以通过访问导入URL（[https://deno.land/std@0.83.0/http/file_server.ts](https://deno.land/std@0.83.0/http/file_server.ts)）看到它的代码。
- en: The installation command will make the `file_server` script available on your
    system.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 安装命令将在您的系统上使`file_server`脚本可用。
- en: 'To give it a name other than `file_server`, we can use the `-n` flag, like
    so:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给它一个除了`file_server`之外的名称，我们可以使用`-n`标志，如下所示：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s serve the current directory:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们服务当前目录：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we access `http://localhost:4507`, this is what we''ll get:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问`http://localhost:4507`，我们会得到以下内容：
- en: '![Figure 2.5 – Deno file server web page'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – Deno文件服务器网页'
- en: '](img/Figure_2.5_B16380.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.5_B16380.jpg)'
- en: Figure 2.5 – Deno file server web page
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – Deno文件服务器网页
- en: This works with remote URLs but can also work with local ones. If you have a
    program written in Deno that you want to transform into an executable, you can
    also use the `install` command to do so.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于远程URL，但也可以用于本地URL。如果您有一个用Deno编写的程序，您想要将其转换为可执行文件，您也可以使用`install`命令来完成。
- en: 'We can do this with our simple web server, for instance:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们简单的Web服务器来做这件事，例如：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By running the preceding code, a script called `hello-http-server` is created
    and available across our system.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的代码，创建了一个名为`hello-http-server`的脚本，并在我们的系统中可用。
- en: That's all we need to run in order to execute local and remote scripts. Deno
    makes this very easy because it treats imports and modules in a very straightforward
    way, very much like browsers do.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们执行本地和远程脚本所需的一切。Deno使这非常容易，因为它以非常直接的方式处理导入和模块，非常类似于浏览器。
- en: Previously, we've used permissions to allow scripts to access resources like
    network or the filesystem. In this section, we've used permissions with the `install`
    command, but we previously did this with the `run` command too.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们使用权限允许脚本访问网络或文件系统等资源。在本节中，我们使用权限与`install`命令一起使用，但我们之前也这样使用过`run`命令。
- en: By now, you probably understand how they work, but we'll look at them in more
    detail in the following section.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在，你可能已经理解了它们是如何工作的，但我们在下一节会更详细地了解它们。
- en: Permissions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限
- en: We came across Deno's permissions for the first time a few pages ago when we
    wrote our first HTTP server. At the time, we had to give our script permission
    to access the network. Since then, we've used them a few times without knowing
    too much about how they work.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们几页前编写我们的第一个HTTP服务器时，我们第一次遇到了Deno的权限。当时，我们必须给我们的脚本授予访问网络的权限。从那时起，我们多次使用它们，但并不太了解它们是如何工作的。
- en: In this section, we'll explore how permissions work. We'll learn what permissions
    exist and how to configure them.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨权限是如何工作的。我们将了解存在哪些权限以及如何配置它们。
- en: If we run `deno run --help`, we get the help output for the `run` command, which
    is where, among other things, certain permissions are listed. To make this easier
    for you, we will list all the existing permissions and provide a brief explanation
    of each.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`deno run --help`，我们将获得`run`命令的帮助输出，其中列出了某些权限。为了使这更方便您，我们将列出所有现有的权限并提供每个的简要说明。
- en: -A, --allow-all
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: -A, --allow-all
- en: This disables all permission checks. Running code with this flag means it will
    have access to everything the user has, quite similar to what happens with Node.js
    by default.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这关闭了所有权限检查。带有此标志运行代码意味着它将拥有用户所有的访问权限，与Node.js默认行为非常相似。
- en: Be careful when you run code with this, and be especially careful when the code
    is not yours.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此代码时请小心，尤其是当代码不是你自己的时候。
- en: --allow-env
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --allow-env
- en: This grants access to the environment. It's used so that programs can access
    environment variables.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这赋予了访问环境的能力。它用于程序可以访问环境变量。
- en: --allow-hrtime
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --allow-hrtime
- en: This grants access to high-resolution time management. It can be used for precise
    benchmarking. Giving this permission to the wrong scripts can allow for fingerprinting
    and timing attacks.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这赋予了访问高分辨率时间管理的能力。它可以用于精确的基准测试。给予错误的脚本这个权限可能会允许指纹识别和时序攻击。
- en: --allow-net=<domains>
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --allow-net=<域名>
- en: This grants access to the network. When used without arguments, it allows all
    network access. When used with arguments, it allows us to pass a comma-separated
    list of domains where network communication will be allowed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这赋予了访问网络的能力。如果没有参数，它允许所有的网络访问。如果有参数，它允许我们传递一个由逗号分隔的列表的域名，其中网络通信将被允许。
- en: --allow-plugin
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --allow-plugin
- en: This allows plugins to be loaded. Note that this is still an unstable feature.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许加载插件。请注意，这仍然是一个不稳定的特性。
- en: --allow-read=<paths>
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --allow-read=<路径>
- en: This grants read access to the filesystem. When used without arguments, it grants
    access to everything the user has access to. With arguments, this only allows
    access to the folders provided by a comma-separated list.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这赋予了文件系统的读取权限。如果没有参数，它授予用户可以访问的一切。如果有参数，这只允许访问由逗号分隔的列表提供的文件夹。
- en: --allow-run
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --allow-run
- en: This grants access to running subprocesses (for instance, with `Deno.run`).
    Keep in mind that subprocesses are not sandboxed and should be used with caution.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这赋予了运行子进程的能力（例如，使用`Deno.run`）。请记住，子进程不是沙盒化的，应该谨慎使用。
- en: --allow-write=<paths>
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --allow-write=<路径>
- en: This grants filesystem write access. When used without arguments, it grants
    access to everything the user has access to. With arguments, it only allows access
    to folders provided by a comma-separated list.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这赋予了文件系统的写入权限。如果没有参数，它授予用户可以访问的一切。如果有参数，它只允许访问由逗号分隔的列表提供的文件夹。
- en: Every time a program runs and it doesn't have the correct permissions, a `PermissionError`
    will be thrown.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每次程序运行且没有正确的权限时，都会抛出一个`PermissionError`。
- en: Permissions are used on the `run` and `install` commands. The only difference
    between them is the moment you give the permissions. For `run`, you have to give
    them when running, while for `install`, you give them when you install the script.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 权限在`run`和`install`命令中使用。它们之间的唯一区别是授予权限的时刻。对于`run`，您必须在运行时授予权限，而对于`install`，您在安装脚本时授予权限。
- en: There is another way for a Deno program to have permissions. It doesn't require
    the permissions to be given upfront, and instead will ask for them as they're
    needed. We'll explore this feature in the next chapter, where we'll learn about
    Deno's namespace.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Deno程序，还有一种获取权限的方式。它不需要预先授予权限，而是会在需要时请求它们。我们将在下一章中探讨这一特性，届时我们将学习Deno的命名空间。
- en: And that's it! There's really not much to add on permissions, except that they're
    a very important feature in Deno as it sandboxes our code by default and lets
    us decide on what should our code have access to. We'll keep using permissions
    on the applications we'll be writing throughout this book.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！除了权限之外，真的没有太多可以添加的内容，因为它是Deno中的一个非常重要的功能，它默认沙盒化我们的代码，并让我们决定我们的代码应该具有哪些访问权限。我们将在本书中编写应用程序时继续使用权限。
- en: So far, we've learned how to run, install, and cache modules, as well as how
    to use permissions. As we write and run more complex programs, the need to test
    them starts to arise. We can do this with the `test` command, as we'll learn in
    the next section.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何运行、安装和缓存模块，以及如何使用权限。随着我们编写和运行更复杂的程序，开始需要对它们进行测试。我们可以使用`test`命令来实现，正如我们将在下一节中学到的。
- en: Using the test command
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试命令
- en: Included as part of the main binary, Deno also provides a test runner. The command
    for it, not surprisingly, is called `test`. In this section, we'll explore it
    and run a couple of tests.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 作为主二进制文件的一部分，Deno还提供了一个测试运行器。这个命令的名字意料之中地叫做`test`。在本节中，我们将探索它并运行几个测试。
- en: In this section, we'll mainly explore the command itself and not the test syntax.
    We'll look at the syntax and best practices for it in more depth in a dedicated
    chapter later on the book.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将主要探索命令本身，而不是测试语法。我们将更详细地探讨该语法的语法和最佳实践，这将是在本书后面的一个专章中进行。
- en: The `test` command finds files to run based on the `{*_,*.,}test.{js,mjs,ts,jsx,tsx}`
    glob expression.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`命令根据`{*_,*.,}test.{js,mjs,ts,jsx,tsx}`通配符表达式查找要运行的文件。'
- en: Since glob expressions might not be too intuitive to read, we'll explain them
    briefly.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通配符表达式可能不太直观，我们将简要解释它们。
- en: It matches any files with the `js`, `mjs`, `ts`, `jsx`, and `tsx` extensions
    and that have `test` in their name preceded by an underscore (`_`) or a dot (`.`)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 它匹配任何具有`js`、`mjs`、`ts`、`jsx`和`tsx`扩展名的文件，并且文件名中包含`test`，前面有一个下划线（`_`）或点（`.`）
- en: 'A few examples of files that will match the expression and be considered tests
    are as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些将匹配表达式并被认为是要测试的文件示例：
- en: '`example.test.ts`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example.test.ts`'
- en: '`example_test.js`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example_test.js`'
- en: '`example.test.jsx`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example.test.jsx`'
- en: '`example_test.mjs`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example_test.mjs`'
- en: Deno tests also run inside the sandbox environment, so they need permissions.
    Take a look at the previous section to find out more about how to do this.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Deno测试也在沙盒环境中运行，因此它们需要权限。查看上一节以了解更多关于如何做到这一点的信息。
- en: When running tests, it is also possible to use the debugging commands we learned
    about earlier in this chapter.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试时，也可以使用我们在本章前面学到的调试命令。
- en: Filtering tests
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤测试
- en: A common need when you have a complete test suite is to run only a specific
    part of it. For this, the `test` command provides the `--filter` flag.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个完整的测试套件时，一个常见的需求是只运行其中的特定部分。为此，`test`命令提供了`--filter`标志。
- en: 'Imagine that we have the following file, with two tests defined:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个以下文件，其中定义了两个测试：
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we want to run just one of them, we can use the `--filter` flag and pass
    a string or pattern that will match the test names:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想运行其中的一个，我们可以使用`--filter`标志，并通过传递一个字符串或模式来匹配测试名称：
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code just ran the test that matched the filter. This feature becomes
    very useful when we're developing tests for a small part of the code base and
    we want to get quick feedback about the process.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只是运行了与过滤器匹配的测试。当我们在开发代码库的小部分测试时，这个特性非常有用，我们希望能够快速反馈关于这个过程的信息。
- en: Fail fast
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速失败
- en: In environments such as a continuous integration server, we might want to fail
    fast if it doesn't really matter how many tests are failing and we just want the
    testing phase to be over if any test fails.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如持续集成服务器等环境中，如果真的不关心有多少测试失败，我们可能希望快速失败，只要测试阶段结束即可。
- en: To do this, we can use the `--fail-fast` flag.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以使用 `--fail-fast` 标志。
- en: And that's all we need to know about testing for now. As we mentioned previously,
    we'll get back into testing in [*Chapter 8*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178)*,
    Testing - Unit and Integration*. We just wanted to become familiar with the CLI
    command here.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们现在所需要了解的所有关于测试的内容。正如我们之前提到的，我们将在[第8章](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178)*，测试
    - 单元和集成*中回到测试主题。我们只是想在这里熟悉一下CLI命令。
- en: We consider tests as a tool that guarantees that our code is working but also
    as a way to document our code's behavior. Tests are fundamental in any working
    and evolving code base, and Deno makes them first-class citizens by including
    a test runner in its binary. However, testing is just a part of a bigger toolset
    – one where developer needs such as linting and formatting are also covered.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为测试是一个保证我们的代码正在运行的工具，同时也是记录我们代码行为的手段。测试是任何正在运行和发展的代码库的基础，Deno 通过在其二进制文件中包含一个测试运行器，使它们成为一等公民。然而，测试只是更大工具集的一部分——一个包括诸如代码审查和格式化等开发者需求的部分。
- en: In the next section, we'll learn how Deno solves these problems.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解 Deno 如何解决这些问题。
- en: Formatting and linting
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查和格式化
- en: Linting and formatting are two capacities considered crucial for maintaining
    consistency and enforcing good practices in any code base. With this in mind,
    Deno has embedded the tools to enable both in its CLI. We'll get to know them
    in this section.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查和格式化是维护代码一致性和强制执行良好实践的两个被认为至关重要的能力。怀着这样的想法，Deno在其CLI中集成了这两个工具。我们将在这一节中了解它们。
- en: Formatting
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化
- en: To format Deno's code, the CLI provides the `fmt` command. This is an opinionated
    formatter that aims to solve any questions regarding code formatting. The main
    goal is for developers to not have to care about the format of their code – not
    when writing code nor when reviewing pull requests.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要格式化 Deno 的代码，CLI 提供了 `fmt` 命令。这是一个有观点的格式化器，旨在解决任何关于代码格式化的疑问。主要目标是让开发者在编写代码时不必关心代码的格式，在审查拉取请求时也不必关心。
- en: 'Running the following command with no argument formats all the files in the
    current directory:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令（无参数）将格式化当前目录中的所有文件：
- en: '[PRE46]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we want to format a single file, we can send it as an argument.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要格式化一个单独的文件，我们可以把它作为一个参数发送。
- en: To check files for formatting errors, we can use this together with the `--check`
    flag, which will output the errors that were found in our files to stdout.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查文件的格式化错误，我们可以使用这个与 `--check` 标志一起，它将把我们文件中找到的错误输出到 stdout。
- en: Ignoring lines and files
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略行和文件
- en: 'To make the formatter ignore a single line or a complete file, we can use the
    `ignore` comment:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要使格式化器忽略一行或整个文件，我们可以使用 `ignore` 注释：
- en: '[PRE47]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Using `deno-fmt-ignore` ignores the line right after the comment:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `deno-fmt-ignore` 忽略了注释后面的行：
- en: '[PRE48]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Using `deno-fmt-ignore-file` ignores the whole file.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`deno-fmt-ignore-file`将忽略整个文件。
- en: Lint
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查
- en: Still under the unstable flag, the `lint` command prints warnings and errors
    found in our code to stdout.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 unstable 标志下，`lint` 命令将我们在代码中找到的警告和错误打印到 stdout。
- en: 'Let''s see it in action by running the linter against a script called `to-lint.js`.
    You can run it against whatever you want. Here, we just a file that will throw
    an error since it contains a `debugger`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们通过运行名为 `to-lint.js` 的脚本的代码审查器来实际看看它。你可以对任何你想要的东西运行它。在这里，我们只是用一个会抛出错误的文件，因为它包含了一个
    `debugger`:'
- en: '[PRE49]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this section, we learned how do use the `fmt` and `lint` commands to enforce
    code consistency and best practices across a code base.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们学习了如何使用 `fmt` 和 `lint` 命令来维护代码一致性和最佳实践。
- en: These are two of the commands that are provided by the Deno CLI that will be
    used in our daily life when writing Deno programs. They both happen to be very
    opinionated, so there is no space to support different standards. This should
    be of no surprise since Deno is heavily inspired by *golang*, and this approach
    is in line with what can be done by tools such as *gofmt*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Deno CLI提供的命令之一，在我们编写Deno程序的日常生活中将会使用到。它们两个都碰巧是非常有观点的，所以没有空间支持不同的标准。这应该不足为奇，因为Deno深受*golang*的启发，这种方法与*gofmt*等工具所能做到的相一致。
- en: With that, we know how to format and check our code for best practices. Adding
    this to what we learned in the previous sections, there is nothing stopping us
    from running our code in production.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们知道如何格式化和检查我们的代码以遵循最佳实践。将这个添加到我们前几部分所学习的内容，没有什么能阻止我们在生产环境中运行我们的代码。
- en: When we get into production, we obviously want our servers to be as fast as
    possible. In the previous chapter, we learned that one of slowest parts of Deno
    is TypeScript parsing. When we write TypeScript code, we don't want to sacrifice
    time parsing it every time a new instance of the server starts up. At the same
    time, as we write clean, separate modules, we don't want to ship them separately
    into the production environment.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入生产环境时，我们显然希望我们的服务器尽可能快。在前一章节中，我们了解到Deno最慢的部分之一是TypeScript解析。当我们编写TypeScript代码时，我们不希望每次服务器启动时都牺牲时间去解析它。同时，由于我们编写干净、独立的模块，我们不希望将它们分别发送到生产环境。
- en: This is why Deno provides a feature that allows us to bundle code into a single
    file. We'll learn about this in the next section.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Deno提供了一个允许我们将代码捆绑到单个文件的功能。我们将在下一节了解这个功能。
- en: Bundling code
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捆绑代码
- en: In the previous chapter, when we presented Deno, we elected bundling code as
    an exciting feature for many reasons. This feature has enormous potential, and
    we will explore this in more detail in [*Chapter 7*](B16380_07_Final_JM_ePub.xhtml#_idTextAnchor165)*,
    HTTPS, Extracting Configuration, and Deno in the Browser*. But since we're exploring
    the CLI here, we'll get to know the appropriate command.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章节中，当我们介绍Deno时，我们选择了捆绑代码作为一个激动人心的特性，原因有很多。这个特性有巨大的潜力，我们将在[第7章](B16380_07_Final_JM_ePub.xhtml#_idTextAnchor165)中更详细地探索这个特性，*HTTPS、提取配置和Deno在浏览器中*。但由于我们现在正在探索CLI，我们将了解适当的命令。
- en: It is called `bundle`, and it bundles code into a single, self-contained ES
    module.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为`bundle`，它将代码捆绑成单个、自包含的ES模块。
- en: Bundled code that doesn't depend on the Deno namespace can also run in the browser
    with `<script type="module">` and in Node.js.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 不依赖于Deno命名空间的捆绑代码也可以在浏览器中使用`<script type="module">`和在Node.js中运行。
- en: 'Let''s use it to build our `get-current-time.js` script:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用它来构建我们的`get-current-time.js`脚本：
- en: '[PRE50]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can run the generated `bundle.js`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行生成的`bundle.js`：
- en: '[PRE51]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will print the current time.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印当前时间。
- en: 'We can also execute it with Node.js since it is ES6 compatible JavaScript (you
    need to have Node.js installed to be able to run the following command):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它兼容ES6的JavaScript（你需要安装Node.js才能运行下面的命令），我们也可以用Node.js来执行它：
- en: '[PRE52]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To use this same code in the browser, we can create a file named `index-bundle.html`
    and import our generated bundle:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在浏览器中使用同样的代码，我们可以创建一个名为`index-bundle.html`的文件，并导入我们生成的捆绑包：
- en: '[PRE53]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With the knowledge we gained from the previous section, we can run the standard
    library''s file server in the current folder:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前一部分所获得的知识，我们可以在当前文件夹中运行标准库的文件服务器：
- en: '[PRE54]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, if you navigate to `http://localhost:4507/index-bundle.html`, and open
    the browser console, you'll see that the current time has been printed..
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你导航到`http://localhost:4507/index-bundle.html`，并打开浏览器控制台，你会发现当前时间已经被打印出来了。
- en: Bundling is a very promising feature that we will explore later in [*Chapter
    7*](B16380_07_Final_JM_ePub.xhtml#_idTextAnchor165), *HTTPS, Extracting Configuration,
    and Deno in the Browser*. It allows us to create a single JavaScript file with
    our application.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑是一个非常有前途的功能，我们将在[第7章](B16380_07_Final_JM_ePub.xhtml#_idTextAnchor165)、*HTTPS、提取配置和Deno在浏览器中*中进一步探索。它允许我们将应用程序创建成单个JavaScript文件。
- en: We'll get back to this and show you what things it enables later on in this
    book. Bundling is a nice way to distribute your Deno applications, as we saw in
    this chapter. But what if you want to distribute your application so that it can
    run in places that are not your computer? Does the `bundle` command do this for
    us?
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到这个问题，并在本书的后面部分向你展示它所启发的功能。捆绑是一个很好的分发你的Deno应用程序的方式，正如我们在这个章节所看到的。但是如果你想要将你的应用程序分发到可以运行在非你的电脑上呢？`bundle`命令是否为我们实现了这个功能？
- en: Well, not really. It does this if the place where the code will be executed
    has Node, Deno, or a browser installed.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上并不是。如果代码将要执行的地方安装了Node、Deno或一个浏览器，它就会这样做。
- en: But what if it doesn't? That's what we'll learn about next.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果它没有呢？这就是我们接下来要学习的内容。
- en: Compiling to a binary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译成二进制
- en: When Deno was initially launched, Dahl stated that one of its objectives was
    to be able to ship Deno code as a single binary, something similar to what golang
    does, from day one. This is very similar from the work that nexe ([https://github.com/nexe/nexe](https://github.com/nexe/nexe))
    or pkg ([https://github.com/vercel/pkg](https://github.com/vercel/pkg)) do for
    Node.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当Deno最初推出时，Dahl表示其目标之一是能够将Deno代码作为单个二进制文件发货，类似于golang的做法，从第一天开始。这与nexe ([https://github.com/nexe/nexe](https://github.com/nexe/nexe))
    或 pkg ([https://github.com/vercel/pkg](https://github.com/vercel/pkg)) 的工作非常相似，后者为Node提供服务。
- en: This is different from the bundle feature, where a JavaScript file is generated.
    What happens when you compile Deno code to a binary is that all the runtime and
    code is included in that binary, making it self-sustainable. Once you've compiled
    it, you can just send this binary anywhere, and you'll be able to execute it.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这与捆绑功能不同，后者会生成一个JavaScript文件。当你将Deno代码编译成二进制文件时，所有的运行时和代码都包含在那个二进制文件中，使其自给自足。一旦你编译好了，你就可以把这个二进制文件发送到任何地方，然后就能执行它。
- en: Important note
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At the time of writing, this is still an unstable feature with many limitations,
    as mentioned in its release notes at https://deno.land/posts/v1.7#improvements-to-codedeno-compilecode.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，这仍然是一个具有许多限制的不稳定功能，如其在https://deno.land/posts/v1.7#improvements-to-codedeno-compilecode中所述。
- en: This process is very simple. Let's see how we can do this.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程非常简单。让我们看看我们是如何做到的。
- en: 'We just need to use the `compile` command. For this example, we''ll use the
    script we used in the previous section; that is, `get-current-time.js`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要使用`compile`命令。对于这个例子，我们将使用前面章节中使用的脚本，即`get-current-time.js`：
- en: '[PRE55]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This emits a binary named `get-current-time`, which we can now execute:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成一个名为`get-current-time`的二进制文件，我们可以现在执行它：
- en: '[PRE56]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It's working! This feature allows us to easily distribute the application. This
    is possible because it includes the code and all its dependencies, including the
    Deno runtime, making it self-sustainable.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这正在工作！这个功能使我们能够轻松地分发应用程序。这是可能的，因为它包括了代码及其所有依赖项，包括Deno运行时，使其自给自足。
- en: As Deno continues to evolve, new features, bug fixes, and improvements will
    be added. At its current pace of a few releases per quarter, it's very common
    that you might want to upgrade our version of Deno. The CLI also provides a command
    for this. We'll learn about this in the next section.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Deno的不断发展，新的功能、bug修复和改进将会被添加。以每个季度发布几个版本的速度，你可能会想要升级我们使用的Deno版本是非常常见的。CLI也提供了这个命令。我们将在下一节学习这个。
- en: Using the upgrade command
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用升级命令
- en: We started this chapter by learning how to install Deno, and we installed a
    single version of the runtime. But Deno is constantly shipping bug fixes and improvements
    – even more so in these early versions.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始这一章的学习是如何安装Deno，我们安装了运行时的单个版本。但Deno在不断地发布bug修复和改进——尤其是在这些早期版本中。
- en: 'When there are new updates, we can use the same package manager we used to
    install Deno to upgrade it. However, the Deno CLI provides a command it can use
    to upgrade itself. The command is called `upgrade` and can be used together with
    the `--version` flag to select the version we''re upgrading to:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当有新的更新时，我们可以使用安装Deno时使用的相同包管理器来升级它。然而，Deno CLI提供了一个命令，它可以用来升级自己。该命令称为`upgrade`，可以与`--version`标志一起使用，以选择我们要升级到的版本：
- en: '[PRE57]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If no version is provided, it defaults to the latest version. To install the
    newer version in another location, instead of replacing the current installation,
    you can use the `--output` flag, like so:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供版本，默认为最新版本。要在另一个位置安装新版本，而不是替换当前安装，可以使用`--output`标志，如下所示：
- en: '[PRE58]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: And that's it – `upgrade` is one more utility that follows the Deno philosophy
    of providing all we need to write and maintain applications, and part of that
    cycle is definitely updating our runtime.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——`upgrade`是遵循Deno哲学提供编写和维护应用程序所需的一切的另一个工具，而那个周期中肯定包括更新我们的运行时。
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, our main focus was to get to know the tools Deno provides,
    including those in its main binary. These tools will be heavily used in our daily
    life and throughout the rest of this book.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的主要焦点是了解Deno提供的工具，包括其主二进制文件中的那些工具。这些工具将在我们的日常生活中和本书的其余部分被大量使用。
- en: We started by getting our environment and editor in place and then deep dived
    into the toolchain.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安排了我们的环境和编辑器，然后深入了解了工具链。
- en: Then, we wrote and executed a `eval` command were presented as ways to enable
    experimentation and running code without a file. After that, we look at the module
    system. We not only imported and used modules, but we also looked under the hood
    and understood how Deno downloads and caches dependencies locally.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写了并执行了一个`eval`命令，作为启用实验和无需文件运行代码的方式。之后，我们查看了模块系统。我们不仅导入了并使用了模块，还深入了解了Deno如何下载并在本地缓存依赖。
- en: 'After become familiar with the module system, we learned about how to manage
    external dependencies, namely lock files and integrity checking. We couldn''t
    leave this section without speaking a little about a still unstable but promising
    feature: import maps.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了模块系统之后，我们学习了如何管理外部依赖，即锁文件和完整性检查。我们不得不在这个部分稍微提一下一个仍然不稳定但很有前景的功能：导入映射。
- en: After that, we explored some third-party modules and their code and dependencies
    with the help of the `info` command. The documentation wasn't left on the side
    by Deno, and we also learned how we can use the `documentation` command and the
    respective website to look at third-party's code documentation.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们利用`info`命令的帮助，探索了一些第三方模块及其代码和依赖。Deno没有忽视文档，我们还学会了如何使用`documentation`命令和相应的网站查看第三方代码文档。
- en: Since scripting is a first-class citizen in Deno, we explored the commands that
    enable us to reuse code by directly running code from a URL and installing utility
    scripts globally.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 由于脚本在Deno中是第一公民，我们探索了允许我们从URL直接运行代码并全局安装实用脚本的命令。
- en: Throughout this book, we've mentioned that permissions are one of Deno's highlights.
    In this chapter, we learned how to use permissions when running code to fine-tune
    its privileges.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书中，我们都提到了权限是Deno的一大特色。在这一章，我们学习了如何在运行代码时使用权限来微调其权限。
- en: Next, we learned about the test runner, and how to run and filter tests. Another
    feature we learned about was how to format and lint our code according to Deno's
    standards. We got to know the `fmt` and `lint` commands, two opinionated tools
    that ensure that developers don't have to be concerned about formatting and linting
    since they're handled automatically.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了测试运行器，以及如何运行和筛选测试。我们还了解了一个功能，即如何根据Deno的标准格式化和校对我们的代码。我们了解了`fmt`和`lint`命令，这两个带有观点的工具确保开发者不必担心格式化和校验，因为它们是自动处理的。
- en: Finally, we introduced the `bundle` and `compile` commands. We learned how we
    can bundle our code into a single JavaScript file, and how to generate a binary
    that includes our code and the Deno runtime, making it self-sustainable.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了`bundle`和`compile`命令。我们学会了如何将我们的代码打包成一个JavaScript文件，以及如何生成一个包含我们的代码和Deno运行时的二进制文件，使其自给自足。
- en: A lot of interesting ground was covered in this chapter. I promise you that
    what's next is even more exciting. In the next chapter, we'll get to know the
    standard library and write simple applications with it while we learn about Deno's
    APIs.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章涵盖了大量的有趣内容。我保证接下来会更令人兴奋。在下一章，我们将了解标准库，并学会使用它来编写简单的应用程序，同时了解Deno的API。
- en: Excited? Let's go!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 兴奋吗？让我们开始吧！
