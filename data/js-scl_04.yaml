- en: Chapter 4. Component Communication and Responsibilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。组件通信和职责
- en: The preceding chapter focused on the *what* of components—what are they composed
    of and *why*. This chapter focuses on the glue in between our JavaScript components—the
    *how*. If our components are designed with a particular purpose in mind, then
    they need to communicate with other components to realize larger behavior. For
    example, a router component is unlikely to update the DOM or talk to the API.
    We have components that are good at those tasks, so other components can ask them
    to perform them, by communicating with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章重点讨论了组件的*是什么*——它们由什么组成以及*为什么*。这一章则专注于我们JavaScript组件之间的粘合剂——*如何*。如果我们设计的组件有特定的目的，那么它们需要与其他组件通信来实现更大的行为。例如，一个路由组件不太可能更新DOM或与API通信。我们有擅长这些任务的组件，所以其他组件可以通过与它们通信来请求它们执行这些任务。
- en: We'll start the chapter off with a look at communication models prevalent in
    frontend development. It's highly unlikely that we'll develop our own framework
    for inter-component communication since there are lots of robust libraries that
    already do this. What we're more interested in, from a JavaScript scaling perspective,
    is how the chosen communication model in our application prevents us from scaling,
    and what can be done about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探讨前端开发中常见的通信模型开始这一章。我们不太可能为组件间通信开发自己的框架，因为已经有许多健壮的库已经实现了这一点。从JavaScript扩展的角度来看，我们更感兴趣的是我们应用程序中选择的通信模型如何阻止我们扩展，以及可以采取什么措施。
- en: The responsibilities of a given component influence how it communicates with
    our own components, as well as services beyond our control, like backend APIs
    and DOM APIs. Once we start implementing the components of our application, layers
    start to reveal themselves, and if stated explicitly, these are useful for visualizing
    communication flows. This allows us to anticipate future component communication
    scaling issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 给定组件的责任影响它与我们的组件以及我们无法控制的服务的通信，比如后端API和DOM API。一旦我们开始实现我们应用程序的组件，层次开始显现出来，如果明确指出，这些对于可视化通信流程很有用。这允许我们预见到未来组件通信扩展问题。
- en: Communication models
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信模型
- en: There are various communication models we can use to enable inter-component
    communication. The simplest would be method invocations, or function calls. This
    approach is the most direct and the easiest to implement. However, there's also
    a deep coupling between one component that directly invokes method of another.
    This can't scale beyond a couple components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种通信模型我们可以用来实现组件间的通信。最简单的就是方法调用，或者函数调用。这种方法最直接，实现起来也最容易。然而，一个直接调用另一个方法组件之间也有很强的耦合关系。这种耦合关系无法扩展到几个组件以上。
- en: Instead, we need a level of indirection between our components; something that
    mediates the communication from one component to another. This helps us to scale
    our inter-component communication because we're no longer communicating directly
    with other components. Instead, we're relying on our communication mechanism to
    fulfill message delivery. The two prevalent models for such a communication mechanism
    are message passing and event triggering. Let's compare the two approaches.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要在组件之间建立一个间接层；一种从一个组件到另一个组件调解通信的东西。这有助于我们扩展组件间的通信，因为我们不再直接与其他组件通信。相反，我们依赖我们的通信机制来完成消息传递。这种通信机制的两种流行模型是消息传递和事件触发。让我们比较一下这两种方法。
- en: Message-passing models
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息传递模型
- en: Message-passing communication models are commonplace in JavaScript applications.
    For example, messages can be passed from one process to another on a local machine;
    they can be passed from one host to another, or they can be passed around in the
    same process. Although message-passing is somewhat abstract, it's still a fairly
    low-level idea—there's much room for interpretation. It's the mechanism that sits
    in between two communicating components that provide high-level abstractions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递通信模型在JavaScript应用程序中非常普遍。例如，消息可以从一台机器上的一个进程传递到另一个进程；它们可以从一台主机传递到另一台主机，或者在同一个进程中传递。尽管消息传递有些抽象，但它仍然是一个相当低层次的概念——有很大的解释空间。它是在两个通信组件之间提供高级抽象的机制。
- en: For example, **publish-subscribe** is a more specific type of message-passing
    communication model. The mechanism that fulfills these messages is usually called
    a broker. A component will subscribe to messages of a particular topic, while
    other components will publish messages on that topic. The key design feature is
    that the components are unaware of one another. This promotes loose coupling between
    components, and helps us scale when there are lots of components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**发布-订阅**是消息传递通信模型的一个更具体类型。实现这些消息的机制通常称为经纪人。一个组件将订阅特定主题的消息，而其他组件将在该主题上发布消息。关键的设计特点是组件之间彼此不知晓。这促进了组件之间的松耦合，当组件很多时，有助于我们进行扩展。
- en: '![Message-passing models](img/4369_04_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![消息传递模型](img/4369_04_01.jpg)'
- en: This shows a publish-subscribe model, using a broker to deliver published messages
    to subscribers
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了一个使用经纪人将发布消息传递给订阅者的发布-订阅模型。
- en: Another type of message passing abstraction is **command-response**. Here, one
    component issues a command to another component and gets a response. The coupling
    in this scenario is a little tighter, because the caller is targeting a specific
    component to fulfill the command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种消息传递抽象是**命令-响应**。在这里，一个组件向另一个组件发出命令并获取一个响应。在这个场景中，耦合度稍微紧了一些，因为调用者是针对一个特定的组件来执行命令。
- en: However, this is still preferred over direct command invocation because we can
    still substitute both the caller and the receiver easily.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然比直接命令调用更受欢迎，因为我们仍然可以轻松地替代调用者和接收者。
- en: Event models
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件模型
- en: We often hear that user interface code is event-driven, that is, some event
    takes place, causing the UI to re-render a section. Or, the user performs some
    action in the UI, triggering an event that our code must interpret and act upon.
    From a communication perspective, UIs are just a bunch of declarative visual elements;
    events that are triggered, and the callback functions that respond to those events.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常听说用户界面代码是事件驱动的，也就是说，某个事件发生，导致UI重新渲染一个部分。或者，用户在UI上执行某些操作，触发一个事件，我们的代码必须解释并对其采取行动。从通信的角度来看，UI只是一堆声明性的视觉元素；被触发的事件以及响应这些事件的回调函数。
- en: This is why the publish-subscribe model fits well with UI development. Most
    components we develop will trigger one or more event types, while other components
    will subscribe to this type of event and run code in response to it's triggering.
    This, at a high level, is how most of our components will communicate with one
    another—through events, which is really just publish-subscribe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么发布-订阅模型非常适合UI开发。我们开发的大多数组件将触发一种或多种事件类型，而其他组件将订阅这种事件类型并在其触发时运行代码。在较高层次上，大多数组件之间的通信方式就是这样——通过事件，这实际上就是发布-订阅。
- en: Speaking in terms of events and triggering, instead of messages and publish-subscribe,
    makes sense because it's the more familiar terminology with JavaScript developers.
    For example, there's the DOM and it's whole event system found there. They are
    the asynchronous events associated with Ajax calls and `Promise` objects, then
    there's the homegrown event system used by the framework our application leverages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件和触发机制的角度来说，而不是消息和发布-订阅机制，是有道理的，因为这更符合JavaScript开发者的熟悉术语。例如，那里有DOM及其整个事件系统。它们是与Ajax调用和`Promise`对象相关联的异步事件，然后还有我们应用程序利用的框架自定义的事件系统。
- en: '![Event models](img/4369_04_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![事件模型](img/4369_04_02.jpg)'
- en: Events are triggered by one component while another component listening for
    that event executes a callback; this process is orchestrated by an event-broker
    mechanism
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是由一个组件触发的，而另一个监听该事件的组件执行回调；这个过程是由事件经纪人机制组织的。
- en: Needless to say, separate event systems that all trigger events through our
    application components make it difficult to mentally grasp what's actually happening
    in response to a given action. This is indeed a scaling problem, and the various
    sections throughout this chapter will dig into solutions that enable us to scale
    our component communication.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，所有通过我们的应用程序组件触发事件的独立事件系统使得难以心理上把握给定动作实际发生了什么。这确实是一个扩展问题，本章的各种部分将深入探讨使我们能够扩展组件通信的解决方案。
- en: Communication data schema
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信数据架构
- en: Event data isn't opaque—it has meaning that our callback functions use to make
    decisions on how to react. Sometimes, this data is unneeded and can be safely
    ignored by the callback function. However, we don't want to decide, early on,
    that some callback added later on isn't going to need this data. And that's something
    that helps our communication mechanism scale—providing the right data in the right
    place.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 事件数据并非是不可透明的—它包含着我们的回调函数用来做出决策的数据。有时，这些数据是不必要的，可以被回调函数安全地忽略。然而，我们不想一开始就决定后来添加的某些回调函数不需要这些数据。这是我们帮助通信机制扩展的东西—在正确的地方提供正确的数据。
- en: Not only does the data need to be there, readily available for consumption by
    each callback function, but it also needs to have a predictable structure. We'll
    look at approaches to establish naming conventions for the event names themselves,
    as well as the data that's passed along to the handler functions. We can make
    inter-component communication a little more transparent, and thus more scalable,
    by making sure that the required event data is present and unlikely to be misinterpreted.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据不仅需要准备好供每个回调函数消费，而且需要有一个可预测的结构。我们将探讨建立事件名称本身以及传递给处理程序函数的数据的命名约定的方法。通过确保所需的事件数据存在且不太可能被误解，我们可以使组件间的通信更加透明，从而更具扩展性。
- en: Naming conventions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: Coming up with meaningful names is hard, especially when there are a lot of
    things to name, as is the case with events. On the one hand, we want the event
    name to carry meaning. This helps us scale because by just looking at the event
    name and nothing else, there's meaning to be found. On the other hand, if try
    to overload the event name with too much meaning, the benefit of quickly deciphering
    event names is lost.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 提出有意义的名称是困难的，尤其是当有很多东西需要命名，就像事件一样。一方面，我们希望事件名称具有含义。这有助于我们扩展，因为仅仅通过查看事件名称和其他什么也不做，就能找到意义。另一方面，如果我们试图给事件名称加载过多的意义，那么快速解读事件名称的好处就会丧失。
- en: The primary focus of having good, short, and meaningful event names is on the
    developers who work with these events. The idea is that as their code is reacting
    to events, they can quickly put together a mental map of event flow. Mind you,
    this is just one small practice that contributes to the overall scalable event
    architecture, but nonetheless it is an important one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有良好、简短且有意义的事件名称的主要关注点是那些处理这些事件的开发者。想法是，当他们的代码在反应事件时，他们可以快速地构建出一个事件流程的心理地图。请注意，这只是有助于整体可扩展事件架构的众多小实践之一，但无论如何它都是重要的。
- en: For example, we might have a base event type, and a more specific version of
    that event. We could have several of these base event types, and several more
    specific instances of them to cover the more direct scenarios. If we have too
    much specificity with our event-names and types, it means we can't really reuse
    them. It also means there are more events for developers to reason with.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能有一个基本事件类型，以及该事件的更具体版本。我们可以有这些基本事件类型的几个，还有几个更具体的实例来覆盖更直接的场景。如果我们的事件名称和类型过于具体，这意味着我们实际上无法重用它们。这也意味着开发者需要处理更多的事件。
- en: Data format
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据格式
- en: Apart from the event name itself, there's the event payload. This should always
    contain data about the event that's triggered, and possibly data about the components
    that trigger them. The most important thing to keep in mind about event data is
    that it should always have data that's pertinent to the handlers that subscribe
    to these types of events. Often, a callback function may decide to do nothing
    and ignore the event, based on the state of a property in the event data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事件名称本身，还有事件载荷。这应该总是包含有关触发的事件的数据，以及可能有关触发它们的组件的数据。关于事件数据最重要的记忆点是，它应该总是包含与订阅这些类型事件的处理程序相关的数据。通常，回调函数可能会根据事件数据中的某个属性的状态决定什么都不做，忽略该事件。
- en: For example, it's not really scalable if in every callback function we have
    to perform lookups on components, just to get the data we need to make a decision
    or perform further actions. It's not easy, of course, to guess what data is going
    to be required. If we knew this, we would just call the function directly, and
    save the hassle of having an event triggering mechanism to begin with. The idea
    is to loosen coupling, but at the same time, provide data that's predictable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在每个回调函数中我们都要对组件进行查找，只是为了获取做出决策或执行进一步操作所需的数据，那么这实际上并不是可扩展的。当然，猜测需要什么数据并不容易。如果我们知道这些数据，我们就可以直接调用函数，省去一开始就需要事件触发机制的麻烦。这个想法是为了松耦合，但同时也要提供可预测的数据。
- en: 'Here''s a simplified example of what event data might look like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是事件数据可能的样子的一个简化示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A useful exercise for trying to figure out which data is relevant for a given
    event when it's triggered, is to think about what can be derived from within the
    handler, and what the handler almost never needs. For example, it's not advised
    to compute event data, and then pass it around. If the handler can compute it,
    it should probably bear that responsibility. If we start seeing repetitive code,
    then that's a different story and it's time to start thinking about common event
    data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试确定触发事件时与给定事件相关的数据时，一个有用的练习是思考在处理程序内部可以导出什么，以及处理程序几乎永远不需要什么。例如，不建议计算事件数据，然后到处传递。如果处理程序可以计算它，它应该承担这个责任。如果我们开始看到重复的代码，那么这就是另一个故事，是时候开始考虑常见的事件数据了。
- en: Common data
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见数据
- en: Event data will always contain data from the component that triggered the event—possibly
    a reference to the component itself. That's always a good bet, since all we know
    today is that the event was triggered—we have no idea what callbacks are going
    to want to do in response to this event later on. So it's good to give our callback
    functions lots of data, so long as it's not confusing or misleading.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事件数据将始终包含触发事件的组件的数据—可能是对组件本身的引用。这是一个不错的选择，因为我们今天所知道的一切就是事件被触发了—我们不知道随后的回调函数会想要对这一事件做什么。所以，只要不造成混淆或误导，给我们的回调函数传递很多数据是好的。
- en: So if we know that the same type of component will always trigger the same types
    of events, we can design our callbacks accordingly with the expectation that the
    same data will always be there. We can get even more generic with our event data,
    and supply the callbacks with data about the event itself. For example, there
    are things like time stamps, event-state, and so on—these have nothing to do with
    the component, and more to do with the event.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们知道同一类型的组件将始终触发相同类型的事件，我们可以相应地设计我们的回调，期望同样的数据总是存在。我们可以使事件数据更加通用，并向回调函数提供有关事件本身的数据。例如，有像时间戳、事件状态等东西—这些与组件无关，而与事件有关。
- en: 'Here''s an example that shows a base event that defines the common data for
    all events that extend it with additional properties:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了定义所有扩展它的事件的常见数据的基本事件：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Again, don't try to be clever about data reuse upfront. Let the repetitiveness
    happen, and then deal with it. The better approach would be to create a base event
    structure, so that it's easy to move repetitive properties into the common structure
    once they've been 'found.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，不要一开始就试图在数据重用上表现得很聪明。让重复发生，然后处理它。更好的方法是创建一个基本事件结构，这样一旦找到重复的属性，就很容易将它们移到公共结构中。
- en: Traceable component communication
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可追踪的组件通信
- en: Perhaps the biggest challenge with large-scale JavaScript applications is keeping
    a mental-model of where events start and where they end, in other words, tracing
    the event as it flows through our components. Untraceable code puts the scalability
    of our software at risk because we cannot predict what will happen in response
    to a given event.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大型JavaScript应用程序最大的挑战之一是保持一个关于事件开始和结束的心理模型，换句话说，就是追踪事件在我们组件中的流动。不可追踪的代码使我们的软件的可扩展性面临风险，因为我们无法预测给定事件发生后会发生什么。
- en: There are a number of tactics we can use during development to ease the pain
    of figuring out our event flow, perhaps even modifying the design to simplify
    things. Simplicity scales, and we can't simplify what we don't understand.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们可以使用多种策略来减轻确定事件流程的痛苦，甚至可能修改设计来简化事情。简洁性是可以扩展的，我们无法简化我们不理解的事物。
- en: Subscribing to events
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅事件
- en: One nice aspect of the publish-subscribe messaging model is that we can jump
    in and add a new subscription. This means that if we're not sure about how something
    works, we can throw event callback functions at the problem from various angles,
    until we have a better idea of what's actually happening. This is a hacker tool,
    and tools that support hacking our software help us scale because we're empowering
    developers to take matters into their own hands. If something isn't clear, they're
    more likely to figure it out on their own when the code is easy to hack.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅消息模型的一个好处是我们可以介入并添加一个新的订阅。这意味着如果我们不确定某事如何工作，我们可以从各个角度向问题抛出事件回调函数，直到我们更好地了解实际发生的情况。这是一个黑客工具，支持黑客攻击我们软件的工具帮助我们扩展，因为我们在赋予开发者自行解决问题的权力。如果某件事不清晰，当代码容易受到攻击时，他们更有可能自己找出答案。
- en: '![Subscribing to events](img/4369_04_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![订阅事件](img/4369_04_03.jpg)'
- en: Subscribing to events at specific points, or in a specific order, can alter
    the lifecycle of the event. It's important to have this ability, but if it is
    overused, it can lead to unnecessary complexity
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定点或按特定顺序订阅事件可以改变事件的生命周期。拥有这种能力很重要，但如果过度使用，会导致不必要的复杂性。
- en: In drastic cases, we might even need to use this subscriber approach to fix
    something that's broken in a production system. For example, say that a callback
    function is able to stop an event from executing, canceling any further handlers
    from running. It's good to have these types of entry points in the events that
    trigger throughout our code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在极端情况下，我们甚至可能需要使用这种订阅方法来修复生产系统中的某个故障。例如，假设一个回调函数能够停止一个事件的执行，取消任何进一步的处理程序的运行。在我们的代码中触发的事件具有这些类型的入口点是件好事。
- en: Globally-logging events
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局日志事件
- en: The callback functions that execute in response to triggered events can log
    messages from within. There are times, however, when we need logging from the
    perspective of the event mechanism itself. For example, if we're dealing with
    some tricky code, and we need to know when our callback function is being called,
    relative to other callback functions. The event triggering mechanism should have
    an option to handle lifecycle logging.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 响应触发事件的回调函数可以在内部记录消息。然而，有时我们需要从事件机制本身的角度进行日志记录。例如，如果我们正在处理一些复杂的代码，我们需要知道我们的回调函数相对于其他回调函数何时被调用。事件触发机制应该有一个选项来处理生命周期日志。
- en: This means that for any given event that's triggered, we can see information
    logged about the event, independent of the code that runs in response to the event.
    We'll call these meta-events—events about events. For example, the trigger time
    before the callback runs, after the callback runs, and when there are no more
    callbacks. This gives the logging we implement in our callbacks some much-needed
    context for tracing our code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于任何触发的事件，我们可以看到关于该事件的日志信息，与响应事件的代码无关。我们将这些称为元事件——关于事件的事件。例如，回调运行之前的触发时间、回调运行之后的触发时间以及没有更多回调时的触发时间。这为我们在回调中实现的日志记录提供了一些急需的上下文，以追踪我们的代码。
- en: 'Following is an example that shows an event broker with logging enabled:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个启用了日志的事件代理的示例：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Event lifecycle
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件生命周期
- en: Different event triggering mechanisms have different lifecycles for their events,
    and it's worthwhile trying to understand how each works, and how they can be controlled.
    We'll start by looking at DOM events. The DOM nodes in our UI form a tree structure,
    and any one of those nodes can trigger a DOM event. If there are handler functions
    for this event attached directly to the triggering node, they'll be executed.
    Then, the event will propagate upward, repeating the process of looking for handler
    functions, and then continuing up the tree until the document node is reached.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的事件触发机制具有不同的事件生命周期，理解每个机制如何工作以及如何控制它们是值得的。我们从查看DOM事件开始。我们UI中的DOM节点形成了一棵树结构，任何一个节点都可以触发一个DOM事件。如果这个事件有直接附着在触发节点上的处理函数，它们将被执行。然后，事件将向上传播，重复寻找处理函数的过程，然后继续向上直到达到文档节点。
- en: Our handler functions can actually change the default propagation behavior of
    DOM events.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理函数实际上可以改变DOM事件的默认传播行为。
- en: For example, if we don't want handlers further up in the DOM tree to run, handlers
    in lower tree nodes can stop the event from propagating.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们不想让DOM树中更高层次的处理程序运行，较低层次的处理程序可以阻止事件的传播。
- en: '![Event lifecycle](img/4369_04_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![事件生命周期](img/4369_04_04.jpg)'
- en: Contrasting the event processing approaches of the component event systems from
    various frameworks, and the DOM events as handled by the browser
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对比不同框架中的组件事件系统的事件处理方法，以及由浏览器处理的字符串事件（DOM事件）。
- en: The other major event triggering mechanism we'll want to pay attention to is
    that of the framework we're using. JavaScript, as a language, has no general purpose
    event triggering system, only specialized ones for DOM trees, Ajax calls, and
    Promise objects. Internally, these are all using the same task queues; they're
    just exposed in ways that make them seem as though they're separate systems. This
    is where the framework we're using steps in and provides the necessary abstraction.
    These types of event dispatchers are quite simple; subscribers for a given event
    are executed in FIFO order. Some of these event systems support more advanced
    lifecycle options discussed in this section, such as global event logging and
    early event termination.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的另一个重要的事件触发机制是我们正在使用的框架。JavaScript作为一种语言，没有通用的事件触发系统，只有针对DOM树、Ajax调用和Promise对象的专用系统。内部这些都是在使用相同的任务队列；它们只是以使它们看起来是独立系统的方式暴露出来。这就是我们正在使用的框架介入并提供必要抽象的地方。这类事件分发器相当简单；给定事件的订阅者按FIFO顺序执行。其中一些事件系统支持更高级的生命周期选项，在本节中讨论，如全局事件日志和早期事件终止。
- en: Communication overhead
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信开销
- en: One advantage of directly invoking a method on a component is that there's very
    little overhead involved. When all inter-component communication is brokered through
    an event triggering mechanism, there's no way to escape at least a little overhead.
    In fact, overhead associated with this indirection is hardly noticeable; it's
    other overhead factors that can cause scalability issues.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在组件上调用方法的一个优点是，涉及的开销非常小。当所有组件间的通信都通过事件触发机制来中介时，至少会有一点点开销。实际上，这种间接开销几乎注意不到；是其他开销因素可能导致可扩展性问题。
- en: In this section we'll look at event triggering frequency, callback execution,
    and callback complexity. Each of these has the potential to degrade the performance
    of our software to the point where it is unusable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将探讨事件触发频率、回调执行以及回调复杂度。这三个因素都可能使得软件性能下降到无法使用的地步。
- en: Event frequency
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件频率
- en: When our software has only a handful of components, there's a fundamental limit
    on the frequency of events. Where event frequency can quickly turn into a problem
    is when there are lots of components, some of which trigger events in response
    to events. This means that if the user is doing something quickly and efficiently,
    or if there are several Ajax responses arriving all at once, we need a way to
    prevent these events from blocking the DOM.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的软件只有少数几个组件时，事件频率有一个基本限制。事件频率可能迅速变成问题的是当有很多组件，其中一些对事件做出响应。这意味着，如果用户在快速而高效地做某事，或者有多个Ajax响应同时到达，我们需要一种防止这些事件阻塞DOM的方法。
- en: One challenge with JavaScript is that it's single-threaded. There are web workers,
    but those go way beyond the scope of this book because they introduce a whole
    new category of architectural issues. Let's say that the user has clicked something
    four times in under one second. Under normal circumstances, this is no big deal
    for our event system to process. But let's say they're doing this while there's
    an expensive Ajax response handler running. Eventually, the UI will become unresponsive.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的一个挑战是它是单线程的。有web workers，但那些远远超出了本书的范围，因为它们引入了一个全新的架构问题类别。假设用户在一秒内点击了四次某物。在正常情况下，这对我们的事件系统来说不是什么大问题。但是，假设在他们这样做的同时有一个昂贵的Ajax响应处理程序正在运行。最终，UI将变得无响应。
- en: To avoid unresponsive UIs, we can throttle our events. This means putting a
    cap on the callback execution frequency. So, instead of *done, onto the next one*,
    it's *done, rest for a few milliseconds, then onto the next one*. The advantage
    of throttling our callback functions like this is it gives pending DOM updates
    or pending DOM event callback functions a chance to run. The disadvantage is that
    our event lifecycle could be negatively impacted due to long-running updates,
    or other code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免UI变得无响应，我们可以对事件进行节流。这意味着对回调执行的频率加以限制。所以，不是一完成一个就进行下一个，而是完成一个后，休息几毫秒再进行下一个。这样节流的好处是，它给了待处理的DOM更新或者待处理的DOM事件回调函数运行的机会。缺点是，长运行的更新或其他代码可能会对我们的事件生命周期产生负面影响。
- en: 'Following is an example that shows an event broker that throttles triggered
    events to a specific time frequency:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了事件代理对触发的事件进行节流到特定时间频率的例子：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Callback execution time
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调执行时间
- en: While the event triggering mechanism has some level of control over when callback
    functions are executed, we don't necessarily control how long the callbacks will
    take to finish. From the event system's perspective, each callback function is
    a little black box that runs to completion, due to the single-threaded nature
    of JavaScript. If a disruptive callback function is thrown at the event mechanism,
    how do we know which callback is at fault, so that we can diagnose and fix it?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然事件触发机制在一定程度上可以控制回调函数何时执行，但我们并不一定能控制回调会花费多少时间完成。从事件系统的角度来看，每个回调函数都是一个运行到完成的单线程小黑盒——这是JavaScript的单线程特性所决定的。如果一个具有破坏性的回调函数被抛给事件机制，我们如何知道哪个回调出了问题，以便于我们可以诊断和修复它？
- en: There are two techniques that can be used to address this problem. As mentioned
    earlier in the chapter, the event triggering mechanism should probably have an
    easy means to turn on global event logging. From there, we can deduce the duration
    of any given callback that's running, assuming we have the start and complete
    timestamps. But this isn't exactly the most efficient way to enforce callback
    duration times.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有两种技术可以采用。如章节前面所提到的，事件触发机制应该有一个简单的方法来开启全局事件日志。从那里，我们可以推算出任何给定回调运行的时间，假设我们有开始和完成的时间戳。但这并不是强制回调时间的最有效方法。
- en: Another technique is to set a timeout function, once a given callback function
    starts running. When the timeout function runs, say after `1` second, it checks
    if the same callback is still running. If so, it can explicitly raise an exception.
    That way, the system explicitly fails when a callback takes too long.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是在给定回调函数开始运行时设置一个超时函数。当超时函数运行，比如说一秒后，它会检查相同的回调是否仍在运行。如果是，它可以明确地抛出一个异常。这样，当回调执行时间过长时，系统会明确地失败。
- en: There's still a problem with this approach—what if the callback is stuck in
    a tight loop? Our monitoring callback will never get an opportunity to run.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还有一个问题——如果回调卡在一个紧密循环中怎么办？我们的监控回调将永远没有机会运行。
- en: '![Callback execution time](img/4369_04_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![回调执行时间](img/4369_04_05.jpg)'
- en: Comparing short callbacks that don't take long to execute with longer callbacks,
    which don't provide much flexibility for updating the DOM, or processing queued
    DOM events
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 比较执行时间短的回调和执行时间长的回调，后者更新DOM或处理排队DOM事件的灵活性不大
- en: Callback complexity
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调复杂性
- en: When all else fails, it's up to us, the architects of the large-scale JavaScript
    application, to make sure that the complexity of event handlers is at an appropriate
    level. Too much complexity means the potential for performance bottlenecks and
    the freezing of the UI—a bad user experience. If the callback functions are too
    fine-grained, or the events themselves for that matter, we still face a performance
    problem because of the added overhead of the event triggering mechanism itself—more
    callbacks to process mean more overhead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有其他方法都失败时，我们作为大型JavaScript应用程序的架构师，需要确保事件处理器的复杂性处于适当水平。过多的复杂性意味着潜在的性能瓶颈和UI冻结——这是不好的用户体验。如果回调函数太细粒度，或者事件本身也是，我们仍然会面临性能问题，因为事件触发机制本身增加了开销——需要处理更多的回调意味着更多的开销。
- en: What's nice about the event systems that are found in most JavaScript frameworks
    that support inter-component communications is that they're flexible. The frameworks
    will, by default, trigger events that it feels are important. These can be ignored
    at no observable performance cost to us. However, they also allow us to trigger
    our own events as need be. So if we find that after a while, we've gotten carried
    away with the granularity of our events, we can scale them back a little.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数支持组件间通信的JavaScript框架中找到的事件系统的灵活性是一件好事。框架默认会触发它认为重要的事件。这些可以被忽略，而对我们没有可观测的性能损失。然而，它们也允许我们根据需要触发我们自己的事件。所以如果我们发现过了一段时间，我们过度细化了我们的事件，我们可以稍微回退一些。
- en: Once we have a grasp of what the right level of event granularity is for our
    application, we can adjust our callback functions to reflect it. We can even start
    writing our smaller callback functions in such a way that they can be used to
    compose higher-level functions that provide more course-grained functionality.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们掌握了应用程序中合适的事件粒度，我们可以调整我们的回调函数以反映这一点。我们甚至可以开始以这样的方式编写我们的小回调函数，使它们可以用来组合提供更粗粒度功能的高级函数。
- en: 'Here''s an example that shows callback functions that trigger other events,
    and other more focused functions listening to these events:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个显示触发其他事件的事件回调函数以及监听这些事件的更专注的函数的示例：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Areas of communication responsibility
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信责任区域
- en: When thinking about JavaScript component communication, it's helpful to look
    at the outside world, and the edges from which our application touches it. We've
    mostly been focused on inter-component communication thus far—how do our components
    talk to other components within the same JavaScript application? This inter-component
    communication doesn't initiate itself, nor does it end here. Scalable JavaScript
    code needs to consider the events that flow into and out of the application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考JavaScript组件通信时，查看外部世界以及我们的应用程序与之接触的边缘是有帮助的。到目前为止，我们主要关注的是组件间的通信——我们的组件是如何与同一JavaScript应用程序中的其他组件进行交流的？组件间的通信并不会自发产生，也不会就此结束。可扩展的JavaScript代码需要考虑流入和流出应用程序的事件。
- en: Backend API
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端API
- en: The obvious starting point is the backend API, since it defines the domain of
    our application. The frontend is really just a facade for the ultimate truth of
    the API. Of course, it's more than that, but the API data does ultimately constrain
    what we can and cannot do with our application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的起点是后端API，因为它定义了我们应用程序的领域。前端实际上只是API最终真相的伪装。当然，它不仅仅是那样，但API数据最终确实限制了我们应用程序可以和不可以做的事情。
- en: In terms of components and responsibilities, it's helpful to think about which
    ones are responsible for communicating directly with the backend. When the application
    needs data, it's these components that will initiate the API conversation, fetch
    this data, and let me know when it has arrived so that I can hand it off to another
    component. So there's actually quite a bit of inter-component communication that's
    indirectly related to components that talk to the API.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件和责任方面，思考哪些组件负责与后端直接通信是有帮助的。当应用程序需要数据时，这些组件将启动API对话，获取数据，并在到达时让我知道，这样我就可以将其转交给另一个组件。实际上，与直接与API通信的组件相关的组件间通信还是相当多的。
- en: For example, let's say we have a collection component, and to populate it, we
    have to call a method. Does the collection know that it needs to populate itself,
    or create itself for that matter? It's more likely that some other component kicked-off
    the creation of the collection, then asked it to fetch some data from the API.
    While we know that this initiating component doesn't directly talk to the API,
    we also know that it plays an important role in the communication.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个集合组件，为了填充它，我们必须调用一个方法。集合知道它需要填充自己，或者为自己创建吗？更有可能是其他组件启动了集合的创建，然后要求它从API中获取一些数据。虽然我们知道这个发起组件不会直接与API交谈，但我们还知道它在通信中扮演着重要的角色。
- en: This is important to think about when scaling to lots of components because
    they should all follow a predictable pattern.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展到许多组件时，考虑这一点很重要，因为它们都应该遵循一个可预测的模式。
- en: '![Backend API](img/4369_04_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![后端API](img/4369_04_06.jpg)'
- en: An event broker in the frontend, directly or indirectly, translates API responses
    and their data into events our components can subscribe to
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前端的事件经纪人，直接或间接地将API响应及其数据转换为组件可以订阅的事件
- en: Web socket updates
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket更新
- en: Web socket connections alleviate the need for long-polling in web applications.
    They're used more frequently now because there's strong browser support for the
    technology. There are a lot of libraries for backend servers to support web socket
    connections too. The challenging part is the book-keeping that allows us to detect
    a change and notify the relevant sessions by sending a message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket连接在Web应用程序中消除了长轮询的需要。现在它们被更频繁地使用，因为浏览器对这项技术有强烈的支持。为后端服务器支持WebSocket连接也有很多库。具有挑战性的部分是账本记录，它允许我们检测到变化并通过发送消息通知相关会话。
- en: Backend complexities aside, web sockets do solve a lot of soft real time update
    problems in the frontend. Web sockets are a bi-directional communication channel
    with the backend, but where they really shine is in receiving updates, that some
    model has changed state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 抛开后端复杂性，WebSocket确实在前端解决了很多软实时更新问题。WebSocket是与后端的双向通信通道，但它们真正闪耀的地方在于接收更新，即某个模型改变了状态。
- en: This allows any of our components that might be displaying data from this model
    to re-render itself.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们的任何组件在数据来自此模型时重新渲染自己。
- en: The challenging part is that in any given frontend session, we're only allowed
    one web socket connection. This means that our handler function that responds
    to these messages needs to figure out what to do with them. You may recall that,
    earlier in the chapter when we went over event data, and the meaningfulness of
    event names and the structure of their data. Web socket message events are a good
    example of why this matters. We need to figure out what to do with it, and there
    would be a lot of variation in the type of web socket messages we get.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战的部分是，在任何给定的前端会话中，我们只允许有一个WebSocket连接。这意味着我们的处理程序函数需要弄清楚如何处理这些消息。您可能还记得，在章节开头，当我们讨论事件数据，以及事件名称的意义和它们数据结构的软实时更新时。WebSocket消息事件是为什么这很重要的一个好例子。我们需要弄清楚如何处理它，我们收到的WebSocket消息类型会有很多变化。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since web socket connections are stateful, they can be dropped. This means that
    we will have to face the additional challenge of implementing code that reconnects
    dropped socket connections.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WebSocket连接是状态的，它们可能会断开。这意味着我们将不得不面对实现重新连接断开Socket连接的额外挑战。
- en: It would be a bad idea to let a single callback function handle all the processing
    of these web socket messages, right down to the DOM. One approach might be to
    have several handlers, one for each specific type of web socket update. This would
    get out of hand quickly because lots of callback functions would have to run,
    and in terms of responsibility, lots of components would have to be tightly coupled
    to the web socket connection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让一个回调函数处理所有这些WebSocket消息的处理，甚至到DOM，这是一个糟糕的主意。一种方法可能是拥有多个处理程序，每个处理程序针对每种特定的WebSocket更新类型。这将很快变得无法控制，因为会有很多回调函数需要运行，从责任上讲，很多组件将不得不与WebSocket连接紧密耦合。
- en: What if the component doesn't care that the updated data came from a web socket
    connection? All it cares about is that the data changed. Perhaps we need to introduce
    a new type of event for the components that care about data changes. Then, our
    web socket handler will just need to translate the message to those types of events.
    This is a scalable approach to web socket communication, because we could rip
    out web sockets entirely and it wouldn't actually touch a lot of the system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件不在乎更新数据是否来自WebSocket连接呢？它关心的只是数据发生了变化。也许我们需要为关心数据变化的组件引入一种新类型的事件。然后，我们的WebSocket处理程序只需要将消息转换为这些类型的事件。这是一种可扩展的WebSocket通信方法，因为我们可以完全移除WebSocket，而实际上不会影响系统的很多部分。
- en: '![Web socket updates](img/4369_04_07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![WebSocket更新](img/4369_04_07.jpg)'
- en: An event translates one type of web socket message into entity-specific events,
    so only the interested components need to subscribe
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 事件将一种WebSocket消息转换为实体特定的事件，因此只有感兴趣的组件需要订阅
- en: DOM updates
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新DOM
- en: Our components need to interact with the DOM. This goes without saying—it's
    a web application that runs in the browser. It's definitely worth thinking about
    components that touch the DOM, and those that don't. These are often the **view**
    components, since they translate the data of our application into something that
    is viewable by the user in their browser window.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件需要与DOM交互。这是不言而喻的——它是在浏览器中运行的Web应用程序。认真考虑一下与DOM交互的组件和那些不交互的组件是值得的。这些通常是**视图**组件，因为它们将我们应用程序的数据转换为用户可以在他们的浏览器窗口中查看的内容。
- en: These types of components are actually more of a challenge to scale, mostly
    due to the bi-directional nature of their event flows. Adding to this challenge
    is the fact that when there's any doubt about where some new piece of code should
    go, it's usually the view. Then, when our views get overloaded, we start putting
    code in controllers, or utilities, and who knows where else. There has to be a
    better way.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的组件实际上更难以扩展，主要是因为它们事件流的双向性质。增加这一挑战的是，当对一些新代码应该放在哪里有疑问时，通常会放在视图中。然后，当我们的视图过载时，我们开始在控制器或工具中放置代码，谁知道还会放在哪里。必须有更好的方法。
- en: Let's think about view event communication for a minute. First there are the
    incoming events. These tell the view that something has happened with our data
    and it should update the DOM. Obligingly, it does just that. This approach is
    actually really solid, and works well when the view listens to one component for
    events. As we scale our application to accommodate more features and enhancements,
    our views have to start figuring things out. Views work better when they're stupid.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟考虑视图事件通信。首先，有传入事件。这些事件告诉视图我们的数据发生了什么，它应该更新DOM。顺从地，它就这样做了。这种方法实际上非常可靠，当视图监听一个组件的事件时，它工作得很好。随着我们的应用程序扩展以适应更多功能和改进，我们的视图必须开始自己找出答案。当视图更愚蠢时，它们会工作得更好。
- en: For example, the view that initially had the responsibility of rendering one
    element in response to a data event, now has to do much more. After it's finished
    with this, it needs to compute some derived value, and update another element.
    This process of making views "smarter" spirals out of control until we can no
    longer scale.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，最初负责在数据事件响应中渲染一个元素的视图现在必须做更多的事情。在完成这件事之后，它需要计算一些派生值，并更新另一个元素。这样使视图“更智能”的过程逐渐失控，直到我们无法再扩展。
- en: From a communication perspective, we want to think of views as a simple one-to-one
    binding of data to DOM. If that principle is never violated, then it's a lot easier
    for us to predict what will happen when data changes, because we know which views
    will be listening to this data, and the DOM elements they're bound to.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从通信的角度来看，我们希望将视图视为数据与DOM的简单一对一绑定。如果这个原则从未被违反，那么当数据发生变化时，我们更容易预测会发生什么，因为我们知道哪些视图会监听这些数据，以及它们绑定的DOM元素。
- en: Now for binding in the other direction—listening for changes in the DOM. The
    challenge here, again, is that we tend to lean toward making our views smart.
    When there's an issue with our input data, we overload the view event handler
    that's triggered in response to a DOM event with responsibilities that should
    be fulfilled elsewhere. Views work better when they're stupid. They should translate
    DOM events into application-specific events that any other component can listen
    to, just like we do with web socket message events. Our "smarter" components that
    actually initiate some business process don't necessarily care that the cause
    for action was from the DOM. This helps us scale by creating a smaller number
    of generic components, that really don't do much.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下另一个方向上的绑定——监听DOM的变化。在这里，挑战再次出现，我们倾向于使我们的视图变得智能。当输入数据出现问题时，我们会在DOM事件触发的视图事件处理程序中加载本应在其他地方完成的责任。当视图更愚蠢时，它们会工作得更好。它们应该将DOM事件转换为任何其他组件都可以监听的应用特定事件，就像我们对待WebSocket消息事件一样。那些实际启动某些业务流程的“更智能”的组件并不关心动作的原因是否来自DOM。这有助于我们通过创建更少的通用组件来扩展，这些组件实际上并不做太多的事情。
- en: Loosely-coupled communication
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松耦合通信
- en: When inter-component communication is loosely coupled, we can more easily adapt
    to scaling influencers when they arise. First and foremost, a good inter-component
    communication design that's event-driven allows us to move components around.
    We can take a faulty or under-performing component out, and replace it with another.
    Not being able to substitute components this way means that we would have to fix
    the component in-place; a larger risk for delivering software and a scaling bottleneck
    from a development perspective.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件间的通信耦合度较低时，在遇到需要扩展的影响因素时，我们可以更容易地进行适应。首先，一个良好的事件驱动的组件间通信设计使我们能够移动组件。我们可以移除一个有故障或表现不佳的组件，并将其替换为另一个。不能这样替换组件意味着我们将不得不在原地修复组件；这对于软件交付来说风险更大，从开发角度来看，这也是一个扩展瓶颈。
- en: Another beneficial side-effect of loosely coupled inter-component communication
    is that we can isolate problematic components when something goes wrong. We can
    prevent exceptions that occur in one component from leaving other components in
    a bad state, which just leads to further problems when the user tries to do something
    else. Isolating problems like this helps us scale our responses to fix faulty
    components.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 松耦合的组件间通信的另一个好处是，当出错时，我们可以隔离有问题的组件。我们可以防止一个组件中发生的异常影响到其他组件的状态，当用户尝试做其他事情时，这会导致更多的问题。像这样隔离问题有助于我们扩展响应以修复有问题的组件。
- en: Substituting components
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换组件
- en: Based on the events a given component triggers and responds to, we should have
    an easy time substituting a component with a different version. We still need
    to figure out the inner workings of the component, because it's unlikely we want
    to change it completely. But that's the easier part—the difficult part of implementing
    components is wiring them together. Scalable component implementation means making
    this wiring as approachable and coherent as possible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据给定组件触发和响应的事件，我们应该能够轻松地将组件替换为不同版本。我们仍然需要弄清楚组件的内部工作原理，因为很可能我们并不想完全改变它。但这是更容易的部分——实现组件的难点在于将它们相互连接。可扩展的组件实现意味着使这种连接尽可能易于接近和一致。
- en: But why is it so important that components be substitutable? We would think
    that stable code, consisting of a handful of wired-together components wouldn't
    have to change all that often, if at all. From this point of view, of course substitutability
    is devalued—why worry about it if you don't use it? The only problem with this
    mindset is that if we take scaling our JavaScript code seriously, we can't apply
    principles to some components while neglecting others.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，组件可替代性为什么如此重要呢？我们会认为，由几个相互连接的组件组成的稳定代码不需要频繁更改，如果需要更改的话。从这种观点来看，当然可替代性被降低了——如果你不使用它，为什么还要担心呢？这种思维方式的问题在于，如果我们认真对待扩展JavaScript代码的规模，我们不能对一些组件应用原则而忽视其他组件。
- en: In fact, the reluctance to re-factor stable code isn't necessarily a good thing.
    For example, it could actually hold us back if we have some new ideas that would
    require us to re-factor stable components. What substitutability across all our
    components buys us is scalability in implementing new ideas. If it's easy to experiment
    by pulling out stable components and putting in new implementations, then we're
    more likely to put improved design ideas into the product.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对稳定代码重构的抵触并不一定是一件好事。例如，如果我们有一些新想法，这些想法可能需要我们对稳定组件进行重构，那么这种抵触实际上可能会阻碍我们。我们所有组件之间的可替代性为我们带来的好处是在实施新想法时具有可扩展性。如果通过替换稳定组件并引入新实现来实验很容易，那么我们更有可能将改进的设计理念融入到产品中。
- en: Substituting components isn't just a design-time activity. We can introduce
    variability, where there will be a number of possible components that could fill
    a gap, and the right component will be chosen at runtime. This flexibility means
    that we can easily extend features to account for scaling influencers, such as
    new user roles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 替换组件不仅仅是设计时的活动。我们可以引入可变性，其中将有许多可能填充空白组件的可能性，然后在运行时选择正确的组件。这种灵活性意味着我们可以轻松扩展功能，以考虑规模影响因素，例如新的用户角色。
- en: Some roles get one component, others get a different but compatible component,
    or no component at all. The key is to support this flexibility.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一些角色获得一个组件，其他角色获得一个不同但兼容的组件，或者根本不获得组件。关键是要支持这种灵活性。
- en: '![Substituting components](img/4369_04_08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![替换组件](img/4369_04_08.jpg)'
- en: As long as components follow the same communication protocols, usually with
    event triggering and handling, developing experimental technology is easier
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 只要组件遵循相同的通信协议，通常是通过事件触发和处理，开发实验性技术就会更容易。
- en: Handling unexpected events
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理意外事件
- en: Loosely coupled components help us scale our ability to address defective components,
    mainly because when we're able to isolate the problem root to a single component,
    we can quickly pinpoint the problem and fix it. Additionally, in the case where
    the defective component is running in a production environment, we can limit the
    negative impact while we implement and deliver the fix.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 松耦合的组件有助于我们扩展处理有缺陷组件的能力，主要因为当我们能够将问题根源隔离到单个组件时，我们可以快速定位问题并修复它。此外，在有缺陷的组件在生产环境中运行的情况下，在我们实施并交付修复方案时，我们可以限制负面影响的范围。
- en: Defects happen—we need to accept this and design for it. We want to learn from
    defects when they happen so that we don't repeat them in the future. Given that
    we're on a tight schedule, releasing early and often, bugs will slip through the
    cracks. These are edge cases that we haven't tested for, or unique programming
    errors that slipped through our unit tests. Regardless, we need to design our
    component failure modes to account for these circumstances.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷是会发生的——我们需要接受这一点并为此设计。当缺陷发生时，我们希望从中学习，以便将来不再重复。由于我们的时间表很紧，需要尽早和频繁地发布，因此缺陷可能会遗漏。这些都是我们未测试过的边缘情况，或者是单元测试中遗漏的独特编程错误。无论如何，我们需要设计我们的组件故障模式以考虑这些情况。
- en: One approach to isolating defective components might be to wrap any event callback
    functions in a try/catch. If any unexpected exception happens, our callback simply
    notifies the event system about the component being in an error state. This gives
    the other handlers a chance to restore their states. If there's a faulty component
    in the event callback pipeline, we can safely display an error to the user about
    that particular action not working. Since the other components are all in a good
    state, thanks to the notification from the bad component, the user can safely
    use other features.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离有缺陷的组件的一种方法可能是将任何事件回调函数包裹在try/catch中。如果发生任何意外异常，我们的回调只需通知事件系统有关组件处于错误状态。这给了其他处理程序一个恢复它们状态的机会。如果在事件回调管道中有故障组件，我们可以安全地向用户显示一个关于特定操作无法工作的错误。由于其他组件都处于良好的状态，得益于不良组件的通知，用户可以安全地使用其他功能。
- en: 'Following is an example that shows an event broker capable of catching callback
    function errors:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示能够捕获回调函数错误的事件经纪人的示例：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Component layers
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件层
- en: There's a threshold within any sufficiently large JavaScript application, where
    the number of communicating components presents a scaling problem. The main bottleneck
    is the complexity we create, and our inability to understand it. To fight against
    this complexity, we can introduce layers. These are abstract categorical notions
    that help us visually understand what's happening at runtime.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何足够大的JavaScript应用程序中，都存在一个门槛，即通信组件的数量呈现出扩展问题。主要瓶颈是我们创造的复杂性以及我们理解复杂性的能力。为了对抗这种复杂性，我们可以引入层次。这些是帮助我们视觉上理解运行时发生情况的抽象分类概念。
- en: Event flow direction
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件流方向
- en: One of the first things designing with layers will reveal about our code, is
    the complexity of our inter-component communication in terms of event flow direction.
    For example, let's say our application has three layers. The top layer is concerned
    with routing, and other entry points into the UI. The middle layer has data and
    business logic spread throughout. The bottom layer is where our views are found.
    It's not about how many components are in these layers; while that's a factor,
    it's a minor one. What's important from this perspective is the types of arrows
    that cross into other layers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用层次设计时，首先揭示我们代码的是关于事件流方向组件间通信的复杂性。例如，假设我们的应用程序有三个层次。顶层关注路由和其他进入UI的入口点。中间层有数据和业务逻辑分散其中。底层是我们的视图所在。这些层中有多少组件并不重要；虽然这是一个因素，但它是次要的。从这种观点来看重要的是穿越其他层的箭头类型。
- en: 'For example, given the three-layered architecture described above, we would
    probably notice that the most straightforward layer connections are between the
    routers and the data/business logic layer. That''s because the events flow mostly
    in one direction: top down, from router to the layer directly beneath it. From
    there, there''s likely some communication that happens between some model and
    controller components, but then ultimately, the event flow keeps moving downward.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑到上述的三层架构，我们可能会注意到最直接的层连接是在路由器和数据/业务逻辑层之间。这是因为事件流主要是单向的：从上到下，从路由器到其下方的层。从那里开始，模型和控制器组件之间可能有一些通信，但最终事件流仍然向下移动。
- en: Between the data/logic layer and the view layer, the communication arrows start
    to look bi-directional and confusing. That's because the event flows in the code
    are also bi-directional and confusing. This isn't scalable because we can't easily
    grasp the effects of the events we're triggering. What's helpful for using the
    layered design approach is figuring out a way to remove bi-directional event flows.
    This probably means introducing a level of indirection, something that's responsible
    for brokering the event between a source and a target.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据/逻辑层和视图层之间，通信箭头开始看起来双向且令人困惑。这是因为代码中的事件流也是双向且令人困惑的。这不是可扩展的，因为我们不能轻易地掌握我们触发的事件的效应。使用分层设计方法的好处是找出一种消除双向事件流的方法。这可能意味着引入一个间接层，负责在源和目标之间调解事件。
- en: If we do this in a clever way, the additional moving part brings clarity instead
    of clutter to our layer diagram, and the performance impact is negligible.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们巧妙地这样做，额外的移动部件会给我们的层次图带来清晰而不是杂乱，性能影响可以忽略不计。
- en: '![Event flow direction](img/4369_04_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![事件流方向](img/4369_04_09.jpg)'
- en: A discernible event flow direction between component layers has a huge impact
    on scalability
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 组件层之间可识别的事件流向对可扩展性有巨大的影响
- en: Mapping to developer responsibilities
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射到开发者职责
- en: Layers are an aid, not a formal architecture specification artifact. This means
    that we can use them for whatever they might be helpful with. Different groups
    of people might have their own layers that they use for purposes that suit their
    needs in understanding complexity. However, it's more useful if the development
    team as a whole follows the same layers, and that they're kept extremely simple.
    Going beyond four or five layers defeats the purpose of using them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构是一种辅助工具，而不是正式架构规范的产物。这意味着我们可以将它们用于可能有助于我们的任何事情。不同的人群可能会有他们自己的层次结构，用于理解复杂性的目的。然而，如果整个开发团队遵循相同的层次结构，并且它们被保持得非常简单，那么这将更有用。超过四个或五个层次就失去了使用它们的初衷。
- en: Developers can use layers as a means of self-organization. They understand the
    architecture, and they have work to do for the upcoming sprint. Let's say we have
    two developers working on the same feature. They can use the layers of our component
    architecture to plan their implementation, and avoid interfering with each other's
    work. Things just come together seamlessly when there's a point of reference in
    the bigger picture, such as a layer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用层次结构作为自我组织的手段。他们理解架构，并且有即将到来的迭代的任务。比如说我们有两个开发者正在处理同一个功能。他们可以使用我们组件架构的层次结构来规划他们的实现，并避免相互干扰。当有一个更大的参考点，比如一个层次结构时，事情就会无缝地汇集在一起。
- en: Mentally mapping the code
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在心中绘制代码地图
- en: Even without diagrams, just knowing that the component code we're looking at
    belongs in a specific layer, helps us to mentally map what it's doing, and it's
    effect on the rest of the system. Knowing the layer we're working in gives us
    a subconscious context while we're coding—we know which components are our neighbors,
    and when our events cross layer boundaries.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有图表，只要知道我们正在查看的组件代码属于特定的层次，就能帮助我们心中绘制出它在做什么以及它对系统其他部分的影响。知道我们正在工作的层次在我们编码时会给我们一个潜意识上下文——我们知道哪些组件是我们的邻居，以及当我们的事件跨越层次边界时会发生什么。
- en: Framed in the context of a layer, new components will have glaringly obvious
    design problems, relative to existing components, and their communication patterns
    between layers. The existence of these layers, and the fact that they're frequently
    used as an informal aid by all developers, might be enough to squash design issues
    early on. Or maybe there's not really an issue, but the layers are enough to promote
    discussion on design. Some of the team might learn something, and some might walk
    away with self-assurance that the design is solid.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构的背景下，新组件与现有组件相比，在设计问题上会有明显的不足，以及它们层与层之间的通信模式。这些层次的存在，以及它们被所有开发者频繁作为非正式辅助工具的事实，可能足以在早期阶段消除设计问题。或者也许根本就没有问题，但是层次结构足以促进对设计进行讨论。团队中的一些人可能会学到一些东西，而另一些人可能会确信设计是坚固的。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The building blocks of our JavaScript applications are components. The glue
    that holds them together is the communication model used. At a low level, inter-component
    communication consists of one component passing a message to another, through
    a broker mechanism of some sort. This is often abstracted and simplified as an
    event system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们JavaScript应用程序的构建块是组件。将它们粘合在一起的是所使用的通信模型。在底层，组件间的通信包括一个组件通过某种中介机制向另一个组件传递消息。这通常被抽象和简化为事件系统。
- en: We looked at what actually gets passed around from one component to the next
    in the form of event data. This data needs to be consistent, predictable, and
    meaningful. We also looked at traceable events. That is, can we globally log events
    as they're triggered from the event triggering mechanism?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们审视了实际从一个组件传递到下一个组件的事件数据的形式。这些数据需要保持一致性、可预测性和意义性。我们还探讨了可追踪事件。也就是说，我们能否从事件触发机制中全局记录事件？
- en: The boundaries of our JavaScript code are communication endpoints. We looked
    at the various components with responsibilities of communication with external
    systems, like the DOM, Ajax calls, or local storage. We need to insulate our smart
    components from the edges of our system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript代码边界，是通信的端点。我们审视了具有与外部系统通信职责的各种组件，比如DOM、Ajax调用或本地存储。我们需要将我们智能组件与系统边缘隔离开来。
- en: Substitutability and layers are crucial concepts for scaling. Replacing components
    helps us scale by quickly developing new code with little risk. Layers help in
    a number of areas by keeping the bigger picture within reach. Incorrect design
    assumptions are exposed earlier on with layers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可替代性和层次结构是扩展的关键概念。通过快速开发新代码并降低风险来帮助我们扩展，层次结构在许多方面都有所帮助，通过保持更广阔的视野来触手可及。在层次结构中，错误的设计假设更早地被揭露。
- en: Now it's time for us to think about scaling the addressability of our application,
    and we'll see if the lessons from the last two chapters are of any value there.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们思考如何扩大应用的可达性的时候了，我们将会看到前两章的教训在那里是否有任何价值。
