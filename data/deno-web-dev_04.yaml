- en: '*Chapter 3*: The Runtime and Standard Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**第3章**：运行时和标准库'
- en: Now that we know enough about Deno, we're in a good place to write a few real
    applications with it. In this chapter, we'll be using no libraries as its primary
    purpose is to present the runtime APIs and the standard library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经足够了解Deno，那么我们就可以用它来编写一些真正的应用程序。在本章中，我们将不使用任何库，因为其主要目的是介绍运行时API和标准库。
- en: We will be writing small CLI utilities, web servers, and more, always leveraging
    the power of what the official Deno team created, with no external dependencies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写小型CLI工具、Web服务器等，始终利用官方Deno团队创建的力量，没有外部依赖。
- en: The Deno namespace will be our starting point as we believe it makes sense to
    explore what the runtime includes first. Following this idea, we'll also look
    at the Web APIs that Deno shares with the browser. We'll use `setTimeout` to `addEventListener`,
    `fetch`, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Deno命名空间开始，因为我们认为首先探索运行时包含的内容是有意义的。按照这个想法，我们还将查看Deno与浏览器共享的Web API。我们将使用`setTimeout`到`addEventListener`、`fetch`等。
- en: Still in the Deno namespace, we will get to know the program lifecycle, interact
    with the filesystem, and build small command-line programs. Later, we will get
    to know buffers and understand how they can be used to asynchronously read and
    write.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在Deno命名空间中，我们将了解程序的生命周期，与文件系统交互，并构建小型命令行程序。后来，我们将了解缓冲区，并理解它们如何用于异步读写。
- en: We will then take a quick turn into the standard library and we'll go through
    some useful modules. This chapter doesn't aim to replace the standard library's
    documentation; it will instead present you with some of its capabilities and use
    cases. We'll get to know it while we write small programs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍标准库，并浏览一些有用的模块。这一章并不旨在取代标准库的文档；它将展示标准库的一些功能和用例。在编写小型程序的过程中，我们将了解它。
- en: On this journey through the standard library, we will use modules that deal
    with the filesystem, ID generation, text formatting, and HTTP communication. Part
    of it will be an introduction to what we'll explore in more depth in later chapters.
    You'll finish this chapter by writing your first JSON API, and connecting to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在穿越标准库的旅程中，我们将使用与文件系统、ID生成、文本格式化和HTTP通信相关的模块。其中一部分将是我们稍后深入探索的介绍。您将通过编写您的第一个JSON
    API并连接到它来完成本章。
- en: 'The following are the topics that we will be covering in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中涵盖的主题：
- en: The Deno runtime
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deno运行时**'
- en: Exploring the Deno namespace
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Deno命名空间
- en: Using the standard library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库
- en: Building a web server using the HTTP module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP模块构建Web服务器
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code files of this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件可以在以下GitHub链接找到：[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03)。
- en: The Deno runtime
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**Deno运行时**'
- en: Deno provides a set of functions that are included in the runtime as globals
    in the `Deno` namespace. The runtime APIs are documented at [https://doc.deno.land/](https://doc.deno.land/)
    and can be used to do the most elementary, low-level things.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Deno提供了一组函数，这些函数作为全局变量包含在`Deno`命名空间中。运行时API在[https://doc.deno.land/](https://doc.deno.land/)上进行文档化，可以用来做最基本的、底层的事情。
- en: 'Two types of functions are available on Deno without any imports: Web APIs
    and the `Deno` namespace. Whenever there''s a behavior in Deno that also exists
    on the browser, Deno mimics the browser APIs – those are Web APIs. Since you come
    from the JavaScript world, you''re probably familiar with most of them. We''re
    speaking about functions such as `fetch`, `addEventListener`, `setTimeout`, and
    objects such as `window`, `Event`, `console`, among others.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Deno中，无需导入即可使用两种类型的函数：Web API和`Deno`命名空间。每当Deno中存在与浏览器中相同的行为时，Deno会模仿浏览器API——这些是Web
    API。由于您来自JavaScript世界，您可能对这些大部分都很熟悉。我们谈论的是诸如`fetch`、`addEventListener`、`setTimeout`等函数，以及`window`、`Event`、`console`等对象
    among others.
- en: Code written using Web APIs can be bundled and run in the browser with no transformations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web API编写的代码可以捆绑并在浏览器中运行，无需任何转换。
- en: The other big part of the APIs exposed by the runtime lives inside a global
    namespace named `Deno`. You can use the REPL and the documentation, two of the
    things we explored in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*, to explore it and get a quick grasp of what functions it includes.
    Later in this chapter, we'll also experiment with some of the most common ones.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时暴露的API的大部分位于一个名为`Deno`的全局命名空间中。你可以使用REPL和文档，这两者我们在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)中探讨过，*工具链*，来探索它并快速了解它包括哪些函数。在本章后面，我们还将尝试一些最常用的函数。
- en: If you want to access the documentation of all the symbols that are included
    in Deno, you can run the `doc` command with the `--builtin` flag.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要访问Deno中包含的所有符号的文档，你可以使用带有`--builtin`标志的`doc`命令。
- en: Stability
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定性
- en: The functions inside the `Deno` namespace are considered stable from version
    1.0.0 onwards. This means the Deno team will make an effort to support them across
    newer versions, and will do its best to keep them compatible with future changes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deno`命名空间内的函数从版本1.0.0开始被认为是稳定的。这意味着Deno团队将努力在 newer versions中支持它们，并将尽最大努力使它们与未来的变化保持兼容。'
- en: Features that are still not considered stable for production live under the
    `--unstable` flag, as you probably imagined, since we've used them in previous
    examples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仍不稳定 features live under the `--unstable` flag，正如你可能会想到的那样，因为我们已经在之前的示例中使用过它们。
- en: The documentation of unstable modules can be accessed by using the `--unstable`
    flag with the `doc` command or by accessing [https://doc.deno.land/builtin/unstable](https://doc.deno.land/builtin/unstable).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定模块的文档可以通过使用`doc`命令的`--unstable`标志或通过访问[https://doc.deno.land/builtin/unstable](https://doc.deno.land/builtin/unstable)来获取。
- en: The standard library is not yet considered stable by the Deno team and thus
    they have a different version from the CLI (at the time of writing, it is on version
    0.83.0).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库尚未被Deno团队认为是稳定的，因此它们的版本与CLI不同（在撰写本文时，它是版本0.83.0）。
- en: In contrast with the `Deno` namespace functions, the standard library doesn't
    normally need the `--unstable` flag to run, except if any module from the standard
    library is using unstable functions from the `Deno` namespace.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Deno`命名空间函数相比，标准库通常不需要`--unstable`标志来运行，除非标准库中的任何模块正在使用来自`Deno`命名空间的 unstable
    functions。
- en: Program lifecycle
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序生命周期
- en: Deno supports the browser compatible `load` and `unload` events that can be
    used to run setup and cleanup code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Deno支持浏览器兼容的`load`和`unload`事件，可以用来运行设置和清理代码。
- en: 'Handlers can be written in two different ways: with `addEventListener` and
    by overriding the `window.onload` and `window.onunload` functions. The `load`
    events can be asynchronous but the same is not true for `unload` events as they
    can''t be canceled.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器可以以两种不同的方式编写：使用`addEventListener`和通过重写`window.onload`和`window.onunload`函数。`load`事件可以是异步的，但`unload`事件却不能取消，因此这是不正确的。
- en: 'Using `addEventListener` enables you to register unlimited handles; for instance:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addEventListener`可以注册无限数量的处理器；例如：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we run the preceding code, we get the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们得到以下输出：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another way to schedule code to run on setup and teardown phases is by overriding
    the `onload` and `onunload` functions from the `window` object. These functions
    have the particularity that only the last to be assigned runs. This happens because
    they override one another; see the following code, for instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在设置和拆除阶段安排代码运行的方法是重写`window`对象的`onload`和`onunload`函数。这些函数的特点是只有最后一个分配的运行。这是因为它们互相覆盖；例如，请参见以下代码：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By running the preceding program, we got the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序后，我们得到了以下输出：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we then look at the initial code we wrote, we can understand that the first
    two declarations were overridden by the two declarations following them. That's
    what happens when we override `onunload` and `onload`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们然后查看我们最初编写的代码，我们可以理解前两个声明被跟在它们后面的两个声明覆盖了。当我们覆盖`onunload`和`onload`时，就会发生这种情况。
- en: Web APIs
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络API
- en: 'To demonstrate that we can use the Web APIs the exact same way we can use on
    the browser, we''ll write a rudimentary program that fetches the Deno website
    logo, converts it to base64, and prints to the console an HTML page with the base64
    of the image there. Let''s do this by following these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们可以像在浏览器中一样使用Web API，我们将编写一个简单的程序，获取Deno网站的标志，将其转换为base64，并在控制台打印一个包含图像base64的HTML页面。让我们按照以下步骤进行操作：
- en: 'Start with the request to [https://deno.land/logo.svg](https://deno.land/logo.svg):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://deno.land/logo.svg](https://deno.land/logo.svg)开始请求：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Convert it into `blob`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其转换为`blob`：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Get the text out of the `blob` object and convert it into `base64`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`blob`对象中获取文本并将其转换为`base64`：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Print to the console an HTML page with an image tag using the base64 image:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台打印一个包含图片标签的HTML页面，使用Base64图片：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run this, we get the expected output:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们得到了预期的输出：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, with the help of *nix output redirection features, we can create an HTML
    file with the output of our script:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，借助*nix的输出重定向功能，我们可以用我们脚本的输出创建一个HTML文件：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can now inspect the file, or open it directly in the browser to test that
    it works.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以检查这个文件，或者直接在浏览器中打开它来测试它是否有效。
- en: 'It is also possible to use your knowledge from the previous chapter and directly
    run a script from the Deno standard library to serve the current folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运用前一章的知识，直接从Deno标准库运行一个脚本来服务当前文件夹：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And then, by navigating to `http://localhost:4507/deno-logo.html`, we can check
    that the image is there and working:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过导航到`http://localhost:4507/deno-logo.html`，我们可以检查图像是否在那里并且有效：
- en: '![Figure 3.1 – Accessing a web page with the Deno.land logo as a base64 image'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 - 使用Base64图像的Deno.land网页'
- en: '](img/Figure_3.1_B16380.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B16380.jpg)'
- en: Figure 3.1 – Accessing a web page with the Deno.land logo as a base64 image
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 使用Base64图像的Deno.land网页
- en: Those are just examples of Web APIs that are supported in Deno. In this specific
    example, we've used `fetch` and `btoa` but more will be used throughout the chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是Deno支持的Web API的例子。在这个特定例子中，我们使用了`fetch`和`btoa`，但本章还将使用更多。
- en: Feel free to experiment with these already familiar APIs, either by writing
    simple scripts or by using the REPL. In the rest of the book, we'll be using known
    functions from the Web APIs. In the next section, we'll get to know the Deno namespace,
    the functions that only work inside Deno, and generally provide a more low-level
    behavior.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请随意实验这些熟悉的API， either by writing simple scripts or by using the REPL。在本书的其余部分，我们将使用来自Web
    APIs的已知函数。在下一节中，我们将了解Deno命名空间，那些只在内置Deno中工作的函数，以及通常提供更多低级行为的功能。
- en: Exploring the Deno namespace
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Deno命名空间
- en: All the functionality that is not covered by a Web API lives under the Deno
    namespace. This is functionality that is exclusive to Deno and that can't, for
    instance, be bundled to run in Node or the browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有未通过Web API覆盖的功能都位于Deno命名空间下。这些功能是Deno独有的，例如，不能被捆绑以在Node或浏览器中运行。
- en: In this section, we'll explore some of this functionality. We'll be building
    small utilities, mimicking some of the programs you use daily.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索一些这个功能。我们将构建一些小工具，模仿你每天使用的程序。
- en: If you want to explore the available functions before we get our hands dirty,
    they are available at [https://doc.deno.land/builtin/stable](https://doc.deno.land/builtin/stable).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在我们动手之前探索一下可用的函数，它们可以在[https://doc.deno.land/builtin/stable](https://doc.deno.land/builtin/stable)找到。
- en: Building a simple ls command
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个简单的ls命令
- en: If you've ever used a *nix system's Terminal or Windows PowerShell, you are
    probably familiar with the `ls` command. Briefly, it lists the files and folders
    inside a directory. What we will do is create a Deno utility that mimics some
    functionality of `ls`, that is, lists the files in a directory, and shows some
    details about them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过*nix系统的终端或者Windows PowerShell，你可能对`ls`命令不陌生。简而言之，它列出了一个目录内的文件和文件夹。我们将要做的就是创建一个Deno工具，模仿`ls`的一些功能，也就是列出目录中的文件，并显示它们的一些详细信息。
- en: The original command has a countless number of flags, which we will not implement
    here for brevity reasons.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 原始命令有无数的标志，出于简洁原因，我们在这里不会实现。
- en: 'The information we decided to show is the name, size, and last modified date
    of a file. Let''s get our hands dirty:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定显示的文件信息包括文件名、大小和最后修改日期。让我们开始动手：
- en: 'Create a file named `list-file-names.js` and use `Deno.readDir` to get a list
    of all files and folders in the current directory:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`list-file-names.js`的文件，并使用`Deno.readDir`获取当前目录中的所有文件和文件夹的列表：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will print the files in the current directory on different lines:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把当前目录中的文件打印在不同行上：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use `Deno.args` (https://doc.deno.land/builtin/stable#Deno.args) to get the
    command-line arguments. If no argument is sent, use the current directory as a
    default:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Deno.args`（https://doc.deno.land/builtin/stable#Deno.args）来获取命令行参数。如果没有发送参数，使用当前目录作为默认值：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We're leveraging array destructuring to get the first value of `Deno.args` and
    at the same time using default properties to set the default value of the `path`
    variable.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们利用数组解构来获取`Deno.args`的第一个值，同时使用默认属性来设置`path`变量的默认值。
- en: 'Navigate to the `demo-files` folder ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls/demo-files](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls/demo-files))
    and run the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`demo-files`文件夹（[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls/demo-files](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls/demo-files)）并运行以下命令：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It looks like it is working. It is getting the files from the folder it is currently
    in and listing them.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看起来它正在工作。它正在获取当前所在的文件夹中的文件并列出它们。
- en: We now need to get the file information so that we can display it.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们需要获取文件信息以便显示它。
- en: 'Use `Deno.stat` (https://doc.deno.land/builtin/stable#Deno.stat) to get information
    about the files:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Deno.stat`（[https://doc.deno.land/builtin/stable#Deno.stat](https://doc.deno.land/builtin/stable#Deno.stat)）来获取有关文件的信息：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: $ deno run --allow-read index.ts ./demo-files
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`deno run --allow-read index.ts ./demo-files`'
- en: 12   7/4  .hidden
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 12   7/4  .hidden
- en: 96   7/4  folder
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 96   7/4  folder
- en: 96   7/4  second-folder
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 96   7/4  second-folder
- en: 5    7/4  my-best-file
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5    7/4  my-best-file
- en: 20   7/4  .file1
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 20   7/4  .file1
- en: 0    7/4  .hidden-file
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0    7/4  .hidden-file
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And we get our list of files and folders in the `deno-files` directory we sent
    as a parameter, together with the size in bytes and the creation month and day.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了作为参数发送的`deno-files`目录中的文件和文件夹列表，以及字节大小和创建的月份和日期。
- en: Here, we're using the already known and required `--allow-read` flag to give
    Deno permissions to access the filesystem. However, in the previous chapter, we
    mentioned that there was a different way for Deno programs to ask for permissions,
    using what we called "dynamic permissions." That's what we'll learn about next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用已经知的必需的`--allow-read`标志来赋予Deno访问文件系统的权限。然而，在上一章中，我们提到了Deno程序请求权限的不同方式，我们称之为“动态权限”。接下来我们将学习这方面的内容。
- en: Using dynamic permissions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动态权限
- en: When writing Deno programs ourselves, it's very common that we know the required
    permissions beforehand. However, when writing or executing code that might or
    might not need some permissions or writing an interactive CLI utility, it might
    not make sense to ask for all permissions at once. That's what dynamic permissions
    are for.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们自己编写Deno程序时，我们通常事先知道所需的权限。然而，当编写可能需要或不需要的权限的代码，或者编写交互式CLI工具时，一次性请求所有权限可能没有意义。这就是动态权限的目的。
- en: Dynamic permissions allow programs to ask for permissions as they are needed,
    allowing whoever is executing the code to give or deny specific permissions interactively.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 动态权限允许程序在需要时请求权限，从而使得执行代码的人可以交互式地给予或拒绝特定的权限。
- en: This is a feature that is still unstable and thus its APIs can change, but I
    think it's still worth mentioning, because of the amount of potential it enables.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仍然不稳定的功能，因此其API可能会发生变化，但由于它所启用的潜在可能性，我认为它仍然值得提及。
- en: You can have a look at Deno's permissions API at [https://doc.deno.land/builtin/unstable#Deno.permissions](https://doc.deno.land/builtin/unstable#Deno.permissions).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://doc.deno.land/builtin/unstable#Deno.permissions](https://doc.deno.land/builtin/unstable#Deno.permissions)查看Deno的权限API。
- en: 'What we''ll do next is make sure that our `ls` program asks for filesystem
    read permissions. Let''s do it by following these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要确保我们的`ls`程序请求文件系统的读取权限。让我们按照以下步骤进行：
- en: 'Use `Deno.permissions.request` to ask for read permissions before executing
    the program:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用程序之前，使用`Deno.permissions.request`来请求读取权限：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This asks for permissions for the directory where the program is going to run.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这请求了对程序将要运行的目录的权限。
- en: 'Run the program and grant permissions on the current directory:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前目录下运行程序并授予权限：
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the program and deny read permissions on the current directory:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并在当前目录下拒绝读取权限：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And that's how dynamic permissions work!
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是动态权限的工作方式！
- en: Here, we've used them to control the filesystem read permissions, but they can
    be used to ask for access to all the available permissions (mentioned in [*Chapter
    2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056), *The Toolchain*) in the runtime.
    They're very useful when writing CLI applications, allowing you to interactively
    tune which permissions the running program has access to.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用它们来控制文件系统的读取权限，但它们也可以用来请求运行时所有可用的权限（如[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)
    *工具链*中所述）。在编写CLI应用程序时，它们非常有用，允许您交互式地调整正在运行的程序可以访问的权限。
- en: Using the filesystem APIs
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件系统API
- en: Accessing the filesystem is one of the basic needs we have when writing programs.
    As you have probably already seen in the documentation, Deno provides APIs to
    do these common tasks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 访问文件系统是我们编写程序时所需的基本需求之一。正如您在文档中可能已经看到的那样，Deno提供了执行这些常见任务的API。
- en: With a decision to standardize communication with the Rust core, all of these
    APIs return `Uint8Array` and the decoding and encoding should be made by their
    consumers. This is a substantial difference from Node.js, where some functions
    return converted formats, where others return blobs, buffers, and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 决定与Rust核心标准化通信后，所有这些API都返回`Uint8Array`，解码和编码应由其消费者完成。这与Node.js有很大的不同，在Node.js中，一些函数返回转换后的格式，而其他函数则返回blob、缓冲区等。
- en: Let's explore these filesystem APIs and read the contents of a file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些文件系统API并读取一个文件的内容。
- en: 'We''re going to read the example file available at [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/file-system/sentence.txt](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/file-system/sentence.txt),
    using the `TextDecoder` and `Deno.readFile` APIs, as the following script demonstrates:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`TextDecoder`和`Deno.readFile` API读取位于[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/file-system/sentence.txt](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/file-system/sentence.txt)的示例文件，如下脚本所示：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can note that we've used the `TextDecoder` class, another API that is present
    in the browser.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以注意到我们使用了`TextDecoder`类，这是浏览器中存在的另一个API。
- en: Do not forget to use the `--allow-read` permission when running the script so
    it can read from the filesystem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在运行脚本时使用`--allow-read`权限，以便它可以从文件系统中读取。
- en: 'If we want to write the content of this file to another file, we can use `writeFile`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将这个文件的内容写入另一个文件，我们可以使用`writeFile`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we don't need the `TextEncoder` anymore since we're using `Uint8Array`
    we got from `readFile` to send directly to the `writeFile` method. Remember to
    use the `--allow-write` flag when running it, since it's now writing to the filesystem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们使用从`readFile`获得的`Uint8Array`直接发送到`writeFile`方法，所以我们不再需要`TextEncoder`。记住在运行时使用`--allow-write`标志，因为它现在正在向文件系统写入。
- en: 'As you probably guessed or read in the documentation, Deno provides an API
    exactly for that, `copyFile`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的或在文档中读到的，Deno正好提供了这样一个API，即`copyFile`：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, you probably noticed we're always using `await` before the method calls
    on Deno namespace functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能注意到了，我们在调用Deno命名空间函数时总是使用`await`。
- en: All asynchronous operations on Deno return a promise, and that's the main reason
    we're doing this. We could use the equivalent `then` syntax and deal with the
    result there, but we find this to be more readable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Deno上的所有异步操作都返回一个承诺，这是我们这样做的主要原因。我们本可以使用等效的`then`语法在那里处理结果，但我们认为这样更易读。
- en: Other APIs for removing, renaming, changing permissions, and so on are also
    included in the Deno namespace, as you can find in the documentation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用于删除、重命名、更改权限等的API也包含在Deno命名空间中，您可以在文档中找到它们。
- en: Important note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Many of the asynchronous APIs in Deno have an equivalent *synchronous* API that
    can be used for specific use cases where you want to block the process and get
    a result (for example, `readFileSync`, `writeFileSync`, and so on).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Deno中的许多异步API都有一个等效的*同步*API，可以用于特定用例，在这些用例中，您希望阻塞进程并获取结果（例如，`readFileSync`、`writeFileSync`等）。
- en: Using buffers
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓冲区
- en: Buffers represent regions in memory that are used to store temporary binary
    data. They are commonly used to deal with I/O and network operations. As asynchronous
    operations are something where Deno excels, we'll be exploring buffers in this
    section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区代表用于存储临时二进制数据的内存区域。它们通常用于处理I/O和网络操作。由于异步操作是Deno的优势之一，因此我们将在本节中探索缓冲区。
- en: Deno buffers differ from Node buffers. This happens because when Node was created,
    and up until version 4, there was no support in JavaScript for `ArrayBuffers`.
    As Node optimized for asynchronous operations (where buffers really shine), the
    team behind it had to create a Node buffer to emulate the behavior of a native
    buffer. Later, `ArrayBuffers` were added into the language and the Node team migrated
    the existing buffer to leverage it. It currently isn't more than a subclass of
    `ArrayBuffers`. This same buffer was then deprecated in v10 of Node. As Deno was
    recently created, its buffer deeply leverages `ArrayBuffer`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Deno缓冲区与Node缓冲区不同。这是因为当Node被创建时，直到版本4，JavaScript中都没有对`ArrayBuffers`的支持。由于Node针对异步操作进行了优化（缓冲区真正闪耀的地方），其背后的团队不得不创建一个Node缓冲区来模拟本地缓冲区的行为。后来，`ArrayBuffers`被添加到语言中，Node团队将现有的缓冲区迁移到利用它。目前它只是一个`ArrayBuffers`的子类。这个相同的缓冲区然后在Node
    v10中被弃用。由于Deno是最近创建的，它的缓冲区深度利用了`ArrayBuffer`。
- en: Reading and writing from Deno.Buffer
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Deno.Buffer读写
- en: Deno provides a dynamic length buffer that is implemented on top of `ArrayBuffer`,
    a fixed memory allocation. Buffers provide functionality similar to a queue where
    data can be written and read by different consumers. As we initially mentioned,
    they are heavily used for jobs such as networking and I/O as they allow asynchronous
    reading and writing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Deno提供了一个动态长度的缓冲区，它是基于`ArrayBuffer`的固定内存分配实现的。缓冲区提供了类似队列的功能，其中数据可以被不同的消费者写入和读取。正如我们最初提到的，它们在网络和I/O等任务中得到了广泛应用，因为它们允许异步读写。
- en: To give an example, imagine you have an application that is writing some logs
    that you want to process. You can do it synchronously as they come, or you can
    have that application writing to a buffer and have a consumer processing them
    asynchronously.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你有一个正在写一些日志的应用程序，你想处理这些日志。你可以同步地处理它们，也可以让这个应用程序将日志写入一个缓冲区，然后有一个消费者异步地处理这些日志。
- en: Let's write a small program for that situation. We will write two short programs.
    The first one will emulate an application producing logs; the second will consume
    those logs by using a buffer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为那种情况写一个小的程序。我们将写两个简短的程序。第一个将模拟一个产生日志的应用程序；第二个将使用缓冲区来消费这些日志。
- en: 'We''ll start by writing code that emulates an application producing logs. At
    [https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/buffers/logs/example-log.txt](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/buffers/logs/example-log.txt),
    there''s a file that has some example logs we''ll use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写模拟应用程序产生日志的代码。在[https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/buffers/logs/example-log.txt](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/buffers/logs/example-log.txt)，有一个文件，里面有一些示例日志我们将使用：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code reads the content from the example file and splits it into lines.
    Then, it gets a random line number and every 100 ms writes that line into a buffer.
    This file then exports a function that we can call to start "generating random
    logs." We'll use this in the next script to mimic an application producing logs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从示例文件中读取内容并将其分割成行。然后，它获取一个随机的行号，每100毫秒将那一行写入一个缓冲区。这个文件然后导出一个函数，我们可以调用它来开始“生成随机日志”。我们将在下一个脚本中使用这个功能来模拟一个产生日志的应用程序。
- en: 'Now comes the interesting part: we''ll write our basic *log processor* by following
    these steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来到了有趣的部分：我们将按照这些步骤编写一个基本的*日志处理器*：
- en: 'Create a buffer and send it to the `start` function of the log producer we
    just wrote:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个缓冲区，并将其发送给我们刚刚编写的日志生产者的`start`函数：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the `processLogs` function to start processing the log entries present
    in the buffers:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`processLogs`函数来开始处理缓冲区中的日志条目：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the `processLogs` function would be called and nothing would
    happen, as we haven't implemented a program to do it yet.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所看到的，`processLogs`函数会被调用，但是什么也不会发生，因为我们还没有实现一个程序来执行它。
- en: 'Create an object type of `Uint8Array` inside the `processLogs` function and
    read the content of the buffer there:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`processLogs`函数内部创建一个`Uint8Array`对象类型，并在那里读取缓冲区的内容：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The documentation ([https://doc.deno.land/builtin/stable#Deno.Buffer](https://doc.deno.land/builtin/stable#Deno.Buffer))
    states that when there is something to read, the `read` function from `Deno.Buffer`
    returns the number of bytes read. When there is nothing to read, the buffer is
    empty and it returns null.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文档（[https://doc.deno.land/builtin/stable#Deno.Buffer](https://doc.deno.land/builtin/stable#Deno.Buffer)）指出，当有东西要读取时，`Deno.Buffer`的`read`函数返回读取的字节数。当没有东西可读时，缓冲区为空，它返回null。
- en: 'Now, inside `if`, we can just decode the content that was read, as we know
    it comes in `Uint8Array` format:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`if`内部，我们可以直接解码读取的内容，因为我们都知道它以`Uint8Array`格式存在：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To print the decoded value on the console, we can use the already known `console.log`.
    We can also do it differently, by using `Deno.stdout` ([https://doc.deno.land/builtin/stable#Deno.stdout](https://doc.deno.land/builtin/stable#Deno.stdout))
    to write to the standard output.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在控制台上打印解码值，我们可以使用已知的`console.log`。我们还可以用不同的方式来实现，通过使用`Deno.stdout`（[https://doc.deno.land/builtin/stable#Deno.stdout](https://doc.deno.land/builtin/stable#Deno.stdout)）向标准输出写入。
- en: '`Deno.stdout` is a `writer` object in Deno ([https://doc.deno.land/builtin/stable#Deno.Writer](https://doc.deno.land/builtin/stable#Deno.Writer)).
    We can use its `write` method to send text there:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Deno.stdout`是Deno中的一个`writer`对象([https://doc.deno.land/builtin/stable#Deno.Writer](https://doc.deno.land/builtin/stable#Deno.Writer))。我们可以使用它的`write`方法将文本发送到那里：'
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And with this, we're writing to `Deno.stdout`, the value we just read. We're
    also adding a line break at the end (`\n`) so that it becomes a little more readable
    on the console.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这样做，我们正在向`Deno.stdout`写入刚刚读取的值，并且在末尾添加一个换行符（`\n`），以便在控制台上更具可读性。
- en: If we leave it this way, this `processLogs` function will run only once. As
    we want this to run again and check if there are more logs in `buffer`, we'll
    need to schedule it to run again later.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们保持这种方式，这个`processLogs`函数将只运行一次。由于我们希望在稍后再次运行此函数以检查`buffer`中是否还有更多日志，我们需要安排它稍后再次运行。
- en: 'Use `setTimeout` to call the same `processLogs` function 100 ms from now:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setTimeout`在100毫秒后调用相同的`processLogs`函数：
- en: '[PRE29]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As an example, if we open the `example-log.txt` file, we can see that there
    are lines that contain dates in the following format: `Thu Aug 20 22:14:31 WEST
    2020`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们打开`example-log.txt`文件，我们可以看到包含以下格式的日期的行：`Thu Aug 20 22:14:31 WEST 2020`。
- en: 'Let''s imagine we just want to print logs that have `Tue` on them. Let''s write
    the logic to do that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们只是想打印出带有`Tue`的日志。让我们来写一下实现这个功能的逻辑：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we execute the program while inside the folder containing the `example-logs.txt`
    file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在包含`example-logs.txt`文件的文件夹内执行程序：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The log lines with the dates appear as they are read from the buffer and match
    our criteria.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 带有日期的日志行如实地从缓冲区中读取并符合我们的条件。
- en: This was a short demonstration of what can be done with buffers. We were able
    to asynchronously write and read from a buffer. This approach allows, for instance,
    a consumer to be working on a portion of a file while the application is reading
    other parts of it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于缓冲区可以做什么的简短演示。我们能够异步地从缓冲区读取和写入。这种方法允许，例如，消费者在应用程序读取其他部分的同时处理文件的一部分。
- en: The Deno namespace provides a lot more functionality than what we've tried here.
    In this section, we decided to pick a few parts and give you a glimpse of how
    much it enables.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Deno命名空间提供了比这里尝试的更多功能。在本节中，我们决定挑选几个部分给你一个启示，看看它启用了多少功能。
- en: We'll be using these functions, together with third-party modules and the standard
    library, when we write our web server, from [*Chapter 4*](B16380_04_Final_JM_ePub.xhtml#_idTextAnchor108),
    *Building a Web Application,* onwards.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16380_04_Final_JM_ePub.xhtml#_idTextAnchor108)，*构建Web应用程序*及以后，我们将使用这些函数，以及第三方模块和标准库来编写我们的Web服务器。
- en: Using the standard library
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准库
- en: In this section, we'll explore the behavior provided by Deno's standard library.
    It is currently not considered stable by the runtime and thus modules are separately
    versioned. At the time we're writing, the standard library is at *version 0.83.0*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨由Deno的标准库提供的行为。目前，这个标准库不被运行时认为是稳定的，因此模块是单独版本化的。在我们撰写本文时，标准库处于*版本0.83.0*。
- en: As we previously mentioned, Deno is very meticulous in what it adds to the standard
    library. The core team wants it to provide enough behavior, so people don't need
    to rely on millions of external packages to do certain things, but at the same
    time doesn't want to add too much of an API surface. This is a fine balance that
    is hard to strike.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Deno在向标准库添加内容方面非常慎重。核心团队希望它提供足够的行为，这样人们就不需要依赖数百万个外部包来完成某些事情，但同时也不想添加过多的API表面。这是一个难以达到的微妙平衡。
- en: With the assumed inspiration of golang, most of the Deno standard library functions
    mimic the language created by Google. This happens because the Deno team truly
    believes in the way *golang* evolved its standard library, one that is commonly
    known for being well polished. As a funny note, Ryan Dahl (Deno and Node creator)
    mentions in one of his talks that, when pull requests add new APIs to the standard
    library, the equivalent *golang* implementation is asked for.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 受到golang的启发，Deno标准库的大部分函数模仿了谷歌创建的语言。这是因为Deno团队真心相信*golang*如何发展其标准库，一个以打磨得非常好而闻名的库。作为一个有趣的注解，Ryan
    Dahl（Deno和Node的创建者）在他的某次演讲中提到，当拉取请求向标准库添加新的API时，会要求提供相应的*golang*实现。
- en: We'll not go over the whole library for the same reasons we didn't go over the
    whole Deno namespace. What we'll do is build a couple of useful programs with
    it while we learn what it enables. We'll go from stuff such as generating IDs,
    to logging, to HTTP communication, among other known use cases.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会遍历整个库，原因与我们没有遍历整个Deno命名空间一样。我们将通过构建一些有用的程序来学习它所能提供的功能。我们将从生成ID、日志记录、HTTP通信等知名用例开始。
- en: Adding colors to our simple ls
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的简单ls添加颜色
- en: A few pages ago, we built a very rough and simple "clone" of the `ls` command
    in *nix systems. At the time we listed the files, together with their size and
    modification date.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 几页之前，我们在*nix系统中构建了一个非常粗糙简单的`ls`命令的“克隆”。当时我们列出了文件，以及它们的大小和修改日期。
- en: To start exploring the standard library, we're going to add some coloring to
    the terminal output of that program. Let's make folder names be printed in red
    so we can easily differentiate them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始探索标准库，我们打算给该程序的终端输出添加一些着色。让我们使文件夹名称以红色打印，这样我们就可以轻松地区分它们。
- en: We'll create a file called `list-file-names-color.ts`. This time we will be
    using TypeScript as we'll get much better completion because the standard library
    and the Deno namespace functions were written with that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`list-file-names-color.ts`的文件。这次我们将使用TypeScript，因为我们将得到更好的补全功能，因为标准库和Deno命名空间函数都是为了这个目的而编写的。
- en: Let's explore the standard library functions that allow us to colorize our text
    (https://deno.land/std@0.83.0/fmt/colors.ts).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下标准库函数，它们允许我们给文本着色（https://deno.land/std@0.83.0/fmt/colors.ts）。
- en: If we want to look at a module's documentation, we can go directly to code,
    but we can also use the `doc` command or the documentation website. We'll use
    the latter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看一个模块的文档，我们可以直接查看代码，但我们也可以使用`doc`命令或文档网站。我们将使用后者。
- en: 'Navigate to https://doc.deno.land/https/deno.land/std@0.83.0/fmt/colors.ts.
    All the listed available methods are presented on the screen:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到https://doc.deno.land/https/deno.land/std@0.83.0/fmt/colors.ts。屏幕上列出了所有可用的方法：
- en: 'Import the method from the standard library''s formatting library that prints
    the text in red:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从标准库的格式化库中导入打印红色文本的方法：
- en: '[PRE32]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use it inside our `async` iterator that is going through our files in the current
    directory:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`async`迭代器中使用它，该迭代器正在遍历当前目录中的文件：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'By running it inside the `demo-files` folder ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls)),
    we get the folders printed in red (it is not possible to see this in the printed
    book, but you can run it locally):'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`demo-files`文件夹内运行它（[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls)），我们得到的文件夹以红色显示（这在打印的书里看不到，但你可以本地运行它）：
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We now have a better `ls` command that enables us to distinguish folders from
    files, using the coloring functions from the standard library. There are many
    other modules provided by the standard library that we'll have a look at during
    the course of the book. Some of them will be used when we start writing our own
    application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个更好的`ls`命令，它让我们能够通过标准库的着色函数区分文件夹和文件。在本书的过程中，我们将查看标准库提供的许多其他模块。其中一些将在我们开始编写自己的应用程序时使用。
- en: One module that we'll pay special attention to is the HTTP module, which we'll
    heavily use from the next section onwards.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别关注的一个模块是HTTP模块，从下一节开始我们将大量使用它。
- en: Building a web server using the HTTP module
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP模块构建Web服务器
- en: The main focus of this book, together with presenting Deno and how it can be
    used, is to learn how to use it to build web applications. Here, we'll create
    a simple JSON API to introduce you to the HTTP module.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要内容，以及介绍Deno以及如何使用它，是学习如何使用它来构建Web应用程序。在这里，我们将创建一个简单的JSON API来向您介绍HTTP模块。
- en: We'll build an API that will save and list notes. We will call these notes post-its.
    Imagine that this is the API that will feed your post-its board.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个API，用于保存和列出便签。我们将这些便签称为post-its。想象一下，这个API将喂养你的post-its板。
- en: We'll create a very simple routing system with the help of Web APIs and the
    functions from the Deno standard library's HTTP module. Keep in mind we're doing
    this to explore the APIs themselves and thus this is not production-ready code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Web API和Deno标准库HTTP模块中的函数创建一个非常简单的路由系统。记住，我们这样做是为了探索API本身，所以这并不是生产就绪的代码。
- en: Let's start by creating a folder named `post-it-api` and a file named `index.ts`
    inside. One more time, we will use TypeScript as we believe the autocomplete and
    type checking capabilities greatly improve our experience and reduce the number
    of possible errors.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个名为`post-it-api`的文件夹和一个名为`index.ts`的文件。再次，我们将使用TypeScript，因为我们相信自动完成和类型检查功能可以大大提高我们的体验并减少可能的错误数量。
- en: 'The final code for this section is available at [https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/steps/7.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/steps/7.ts):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最终的代码可以在[https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/steps/7.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/steps/7.ts)找到：
- en: 'Start by importing the standard library HTTP module into our file:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将标准库HTTP模块导入我们的文件中：
- en: '[PRE35]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Write the logic to handle requests by using `AsyncIterator`, as we did in previous
    examples:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AsyncIterator`编写处理请求的逻辑，就像我们之前的例子中所做的那样：
- en: '[PRE36]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we now run it, this is what we get. Keep in mind we need to use the `--allow-net`
    flag, mentioned in the Permissions section, for it to have network access:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们现在运行它，这就是我们会得到的。记住，为了让它具有网络访问权限，我们需要使用在权限部分提到的`--allow-net`标志：
- en: '[PRE37]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For clarity, we can extract the port and the server instance to a separate
    variable:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们可以将端口和服务器实例提取到单独的变量中：
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And we have our server working, as it was before, with the small difference
    that now the code looks (arguably) more readable with the configuration variables
    at the top of the file. We'll later learn how can we extract those from the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个运行中的服务器，和之前一样，唯一的区别是现在代码（可以说）因为将配置变量放在文件顶部而更加可读。我们稍后会学习如何从代码中提取这些变量。
- en: Returning a list of post-its
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回便签列表
- en: Our first requisite is that we have an API that returns a list of post-its.
    Those will be composed of the name, title, and the date created. Before we get
    there, and to enable us to have multiple routes, we need a routing system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个要求是我们有一个返回便签列表的API。这些便签将包括名称、标题和创建日期。在我们到达那里之前，为了使我们能够有多个路由，我们需要一个路由系统。
- en: For the purpose of this exercise, we'll build ours. This is our way of getting
    to know some of the APIs built into Deno. We'll later agree that when writing
    production applications, it is sometimes better to reuse tested and heavily used
    pieces of software than to keep reinventing the wheel. However, it is completely
    fine to *reinvent the wheel* for learning purposes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这个练习，我们将自己构建一个。这是我们了解Deno中一些内置API的方式。稍后我们会同意，在编写生产应用程序时，有时最好重用经过测试和广泛使用的软件，而不是不断重新发明轮子。然而，为了学习目的，完全重新发明轮子是可以的。
- en: To create our basic routing system, we will use some APIs that you probably
    know from the browser. Objects such as `URL`, `UrlSearchParams`, and so on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的基本路由系统，我们将使用一些您可能在浏览器中知道的API。例如`URL`、`UrlSearchParams`等对象。
- en: Our goal is to be able to define a route by its URL and path. Something like
    `GET /api/post-its` would be nice. Let's do it!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是能够通过其URL和路径定义一个路由。类似`GET /api/post-its`这样的东西会很好。让我们这样做！
- en: 'Start by creating a `URL` object ([https://developer.mozilla.org/en-US/docs/Web/API/URL](https://developer.mozilla.org/en-US/docs/Web/API/URL))
    to help us parse the URL and its parameters. We''ll extract `HOST` and `PROTOCOL`
    to a different variable, so we don''t have to repeat ourselves:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`URL`对象（[https://developer.mozilla.org/en-US/docs/Web/API/URL](https://developer.mozilla.org/en-US/docs/Web/API/URL)）来帮助我们解析URL和其参数。我们将`HOST`和`PROTOCOL`提取到另一个变量中，这样我们就不用重复了：
- en: '[PRE39]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the created `URL` object to do some routing. We''ll use a `switch case`
    for that. When no route matches, a `404` should be sent to the client:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的`URL`对象进行一些路由。我们将使用`switch case`来实现。当没有匹配的路由时，应该向客户端发送`404`：
- en: '[PRE40]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can use the `--unstable` and `--watch` flags together when running your
    script to restart it on file changes as follows: `deno run` `--allow-net` `--watch`
    `--unstable` `index.ts`.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以同时在运行脚本时使用`--unstable`和`--watch`标志，以在文件更改时重新启动它：`deno run --allow-net --watch
    --unstable index.ts`。
- en: Access `http://localhost:8080/api/post-its` and confirm we have the correct
    response. Any other routes will get a 404 response.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/api/post-its`，并确认我们得到了正确的响应。其他任何路由都会得到404响应。
- en: Note that we're using the `continue` keyword to make Deno jump out of the current
    iteration after responding to the request (remember we're inside a `for` loop).
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们使用`continue`关键字让Deno在响应请求后跳出当前迭代（记住我们正在`for`循环内）。
- en: You might have noticed that, at the moment, we're just routing by path and not
    by method. This means any request made to `/api/post-its`, either `POST` or `GET`,
    will get the same response. Let's fix that by moving ahead.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能已经注意到，目前我们只是按路径路由，而不是按方法路由。这意味着对`/api/post-its`的任何请求，无论是`POST`还是`GET`，都会得到相同的响应。让我们通过前进来解决这个问题。
- en: 'Create a variable that contains the request method and the pathname:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含请求方法和路径名的变量：
- en: '[PRE41]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now define our routes the way we desire, `GET /api/post-its`. Now that
    we have the basics of our routing system, we'll write the logic to return our
    post-its.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们想要的路线，`GET /api/post-its`。现在我们已经有了我们路由系统的基本知识，我们将编写返回便签的逻辑。
- en: 'Create the TypeScript interface that will help us maintain the structure of
    the post-its:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个TypeScript接口，以帮助我们保持便签的结构：
- en: '[PRE42]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Create a variable that will work as our *in-memory database* for this exercise.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，作为我们这次练习的*内存数据库*。
- en: 'We''ll use a JavaScript object where the keys are the IDs and values are the
    objects of the `PostIt` type we just defined:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用一个JavaScript对象，其中键是ID，值是刚刚定义的`PostIt`类型的对象：
- en: '[PRE43]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add a couple of fixtures to our database:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的数据库添加几个测试数据：
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we're *generating* the *IDs* by hand for now. Later, we'll use another
    module from the standard library to do it. Let's get back to our API and change
    the `case` that handles our route.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们目前是*手动生成*ID的。稍后，我们将使用标准库的另一个模块来完成。让我们回到我们的API，并更改处理路由的`case`。
- en: Change the `case` that will return all the post-its instead of the hardcoded
    message.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改返回所有便签的`case`，而不是硬编码的消息。
- en: 'As our database is a key/value store, we need to use `reduce` to build an array
    with all our post-its (delete the line highlighted in the code block):'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的数据库是一个键/值存储，我们需要使用`reduce`来构建一个包含所有便签的数组（删除代码块中高亮的行）：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the code and go to `/api/post-its`. We should have our post-its listed there!
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并访问`/api/post-its`。我们应该在那里看到我们的便签列表！
- en: You might have noticed that it is still not 100 percent correct, since our API
    is returning JSON, and its headers do not match the payload.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这仍然不是100%正确的，因为我们的API返回的是JSON，而其头部与载荷不匹配。
- en: 'We''ll add the `content-type` by using an API we know from the browser, the
    `Headers` object ([https://developer.mozilla.org/en-US/docs/Web/API/Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers)).
    Delete the line highlighted in the following code block:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过使用我们来自浏览器的API——`Headers`对象——来添加`content-type`（https://developer.mozilla.org/en-US/docs/Web/API/Headers）。删除以下代码块中高亮的行：
- en: '[PRE46]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've created an instance of the `Headers` object up there, and then we used
    it on the response, on `req.respond`. This way, our API is now more coherent,
    digestible, and following standards.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个`Headers`对象的实例，然后我们在`req.respond`上使用了它。这样，我们的API现在变得更加一致、易消化，并遵循标准。
- en: Adding a post-it to the database
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向数据库添加一个便签
- en: Now that we have a way to read our post-its, we will need a way to add new ones
    as it doesn't make much sense to have an API with completely static content. That's
    what we'll do.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了读取便签的方法，我们还需要一种添加新便签的方法，因为拥有一个完全静态内容的API并没有多大意义。这就是我们将要做的。
- en: 'We''ll use the *routing infrastructure* we created to add a route that allows
    us to *insert* records into our database. Since we''re following REST guidelines,
    that route will live on the same path as the one that lists `post-its`, but with
    a different method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们创建的*路由基础设施*来添加一个允许我们*插入*记录到我们数据库的路由。由于我们遵循REST指南，该路由将位于列出`post-its`的路径上，但方法不同：
- en: 'Define a route that always returns the `201` status code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个总是返回`201`状态码的路由：
- en: '[PRE47]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Testing it, with the help of `curl`, we can see it''s returning the correct
    status code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`的帮助，测试它，我们可以看到它返回了正确的状态码：
- en: '[PRE48]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Following the recommendation, read the value and print it to get a better understanding
    of it:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照建议，读取值并打印出来以更好地理解它：
- en: '[PRE49]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Make a request with `body`, with the help of `curl`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`的帮助，用`body`发送请求：
- en: '[PRE50]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Uint8Array(25) [
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Uint8Array(25) [
- en: 123,  34, 116, 105, 116, 108, 101,
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 123,  34, 116, 105, 116, 108, 101,
- en: 34,58,32,34,84,   101, 115,
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 34,58,32,34,84,   101, 115,
- en: 116,  32, 112, 111, 115, 116,  45,
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 116,  32, 112, 111, 115, 116,  45,
- en: 105, 116,  34, 125
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 105, 116,  34, 125
- en: ']'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE51]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use `TextDecoder` to get the request body as a readable value. After doing
    this, we''ll log the output again and we''ll make a new request:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TextDecoder`将请求体作为可读值获取。这样做之后，我们再次记录输出，然后我们将发送一个新的请求：
- en: '[PRE52]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is what the server printed to the console this time:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次服务器在控制台打印的内容如下：
- en: '[PRE53]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We're getting there!
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在取得进展！
- en: 'Since the body is a string, we need to parse it into a JavaScript object. We''ll
    use an old friend of ours, `JSON.parse`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于主体是一个字符串，我们需要将其解析为JavaScript对象。我们将使用我们的一位老朋友，`JSON.parse`：
- en: '[PRE54]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We now have the request body in a format we can act on, and that''s pretty
    much all it takes for us to create a new database record. Let''s create one by
    following these steps:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们的请求体以一种我们可以操作的格式存在，这就是我们创建新数据库记录所需要做的全部工作。让我们按照以下步骤创建一个：
- en: 'Use the `uuid` module ([https://deno.land/std@0.83.0/uuid](mailto:https://deno.land/std@0.67.0/uuid))
    from the standard library to generate a random UUID for our records:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准库中的`uuid`模块（[https://deno.land/std@0.83.0/uuid](https://deno.land/std@0.83.0/uuid)）为我们的记录生成一个随机的UUID：
- en: '[PRE55]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In our route''s switch case, we''ll create an `id` with the help of the `generate`
    method and insert it in the *database*, adding the `createdAt` date on top of
    what the user sent in the request payload. For the sake of this example, we''re
    skipping validation:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的路由的switch case中，我们将使用`generate`方法创建一个`id`并将其插入到*数据库*中，在用户在请求负载中发送的内容顶部添加`createdAt`日期。为了这个例子，我们省略了验证：
- en: '[PRE56]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that we''re using the same `headers` object we previously defined (in
    the `GET` route) so that our API responds with `Content-Type: application/json`.'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '注意我们在这里使用的是之前定义的同一个`headers`对象（在`GET`路由中），这样我们的API就会返回`Content-Type: application/json`。'
- en: Then again, as we follow the *REST* guidelines, we return the `201` `Created`
    code and the created record.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，再次遵循*REST*指南，我们返回`201` `Created`代码和创建的记录。
- en: 'Save the code, restart the server, and run it again:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存代码，重新启动服务器，再次运行它：
- en: '[PRE57]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: $ curl http://localhost:8080/api/post-its
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ curl http://localhost:8080/api/post-its
- en: '{"postIts":[{"title":"Read more","body":"PacktPub books","id":"3209ebc7-b3b4-4555-88b1-b64b33d507ab","createdAt":"2021-01-10T16:28:52.210Z"},{"title":"Finish
    book","body":"Deno Web Development","id":"a1afee4a-b078-4eff-8ca6-06b3722eee2c","createdAt":"2021-01-10T16:28:52.210Z"},{"title":"Buy
    groceries","body":"1 x Milk","id":"b35b0a62-4519-4491-9ba9-b5809b4810d5","createdAt":"2021-01-10T16:29:05.519Z"}]}'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{"postIts":[{"title":"Read more","body":"PacktPub books","id":"3209ebc7-b3b4-4555-88b1-b64b33d507ab","createdAt":"2021-01-10T16:28:52.210Z"},{"title":"Finish
    book","body":"Deno Web Development","id":"a1afee4a-b078-4eff-8ca6-06b3722eee2c","createdAt":"2021-01-10T16:28:52.210Z"},{"title":"Buy
    groceries","body":"1 x Milk","id":"b35b0a62-4519-4491-9ba9-b5809b4810d5","createdAt":"2021-01-10T16:29:05.519Z"}]}'
- en: '[PRE58]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: And it works! We now have an API that returns and adds post-its to a list.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 而且它奏效了！现在我们有一个API可以返回并添加post-its到列表中。
- en: This pretty much wraps up what we'll do in terms of APIs with the HTTP module
    for this chapter. As most of the APIs, like the one we wrote, are made to be consumed
    by a frontend application, we'll do that to wrap up this chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上结束了我们在这个章节中使用HTTP模块进行API所做的工作。像我们写的这个API一样，大多数API都是为了被前端应用程序消费而创建的，我们来做这件事来结束这个章节。
- en: Serving a frontend
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务于前端
- en: Since it is out of the scope of this book, we will not write the frontend code
    that interacts with this API. However, if you want to use it with a single-page
    application that fetches the post-its and displays them, I've included one in
    the book's files ([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/index.html](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/index.html)).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这超出了本书的范围，我们不会编写与该API交互的前端代码。然而，如果你想用它来获取便签并显示在一个单页应用程序上，我在书中的文件中包含了一个（[https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/index.html](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/index.html)）。
- en: 'What we''ll learn here is how can we use the web server we just built to serve
    an HTML file:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用我们刚刚构建的Web服务器来提供HTML文件：
- en: First, we need to create a route at the root of our server. Then, we need to
    set the correct `Content-Type` and return the file's content by using the already
    known filesystem APIs.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在服务器的根目录下创建一个路由。然后，我们需要设置正确的`Content-Type`，并使用已知的文件系统API返回文件内容。
- en: 'In order to get the path to the HTML file in reference to the current file,
    we''ll use the URL object together with the `import.meta` declaration from JavaScript
    ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta)),
    which contains the path to the current file:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了获取当前文件相对于HTML文件的路径，我们将使用URL对象和JavaScript的`import.meta`声明（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta)），其中包含当前文件的路径：
- en: '[PRE59]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order for us to be a little more secure, we will specify the exact folder
    the program can read, by sending it to the `--allow-read` flag:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们更安全，我们将指定程序可以读取的确切文件夹，通过将其传递给`--allow-read`标志：
- en: '[PRE60]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This will prevent us from any bugs that might allow malicious people to read
    from our filesystem.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将防止任何可能允许恶意人士读取我们文件系统的错误。
- en: 'Access the URL with the browser, and you should get to a page where we can
    see the fixture `post-its` we''ve added. To add a new one, you can also click
    the **Add a new post-it** text and fill in the form:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用浏览器访问该URL，你应该会来到一个可以看到我们添加的便签`post-its`的页面。要添加一个新的，你也可以点击**添加新便签**文字并填写表单：
- en: '![Figure 3.2 – The frontend consuming the post-it API'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 前端消费便签API](img/Figure_3.2_B16380.jpg)'
- en: '](img/Figure_3.2_B16380.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B16380.jpg)'
- en: Figure 3.2 – The frontend consuming the post-it API
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 前端消费便签API
- en: Important note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please keep in mind that, in many production environments, it is not a recommended
    practice to have your API serving your frontend code. Here, we did it for learning
    purposes, so we could understand some of the possibilities of the standard library
    HTTP module.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在许多生产环境中，不推荐API为前端代码提供服务。在这里，我们这样做是为了学习目的，这样我们才能理解标准库HTTP模块的一些可能性。
- en: In this section, we learned how can we use the modules provided by the standard
    library to our benefit. We made a simple version of a very common command, `ls`,
    and used the output formatting functions from the standard library to add some
    color to it. To finish the section, we made an HTTP API with a couple of endpoints
    that listed and persisted records. We went through different requirements and
    learned how Deno can be used to accomplish them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何利用标准库提供的模块。我们制作了一个`ls`命令的简单版本，并使用标准库的输出格式化函数给它添加了一些颜色。为了结束这一节，我们制作了一个具有几个端点的HTTP
    API，用于列出和持久化记录。我们讨论了不同的需求，并学习了Deno如何实现它们。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we go through the book, our knowledge of Deno gets more practical and we
    start to use it for use cases that are closer to the real world. That was what
    this chapter was about.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对本书的阅读，我们对Deno的了解变得更加实用，我们开始用它来处理更接近现实世界的用例。这一章就是关于这个的。
- en: We started the chapter by learning about some fundamental characteristics of
    the runtime, namely the program lifecycle, and how Deno sees module stability
    and versioning. We rapidly moved on to the Web APIs provided by Deno by writing
    a simple program that fetches the Deno logo from the website, converts it to base64,
    and puts it into an HTML page.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了运行时的基本特性，即程序生命周期，以及Deno如何看待模块稳定性和版本控制。我们很快转向了Deno提供的Web API，通过编写一个简单的程序，从网站上获取Deno徽标，将其转换为base64，并将其放入HTML页面中。
- en: Then, we got into the `Deno` namespace and explored some of its low-level functionality.
    We built a couple of examples with the filesystem API and ended up building a
    rudimentary copy of the `ls` command with it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入了`Deno`命名空间，探索了一些其底层功能。我们使用文件系统API构建了几个示例，并最终用它构建了一个`ls`命令的简化版。
- en: Buffers are things that are heavily used in the Node world, with their capabilities
    to perform asynchronous read and write behavior. As we know, Deno shares many
    use cases with Node.js, and that made it impossible to not talk about buffers
    in this chapter. We started by explaining how Deno buffers differ from Node.js'
    and ended the section by building a small application that handles reading and
    writing asynchronously from them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是在Node.js世界中大量使用的东西，它们能够执行异步读写行为。正如我们所知，Deno与Node.js有很多相同的用例，这使得在这一章节中不谈论缓冲区变得不可能。我们首先解释了Deno缓冲区与Node.js的区别，然后构建了一个小应用程序，它能够异步地从它们中读取和写入。
- en: To wrap up the chapter, we got closer to one of the main goals of this book,
    using Deno for web development. We created our first JSON API with Deno. In the
    process, we learned about multiple Deno APIs and we even built our basic routing
    system. We then proceeded by creating a couple of routes that listed and created
    records in our *data storage*. Getting closer to the end of this chapter, we learned
    how we can handle headers in our APIs and added those to our endpoints.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章节，我们更接近了这本书的主要目标之一，即使用Deno进行网络开发。我们使用Deno创建了第一个JSON API。在这个过程中，我们了解了多个Deno
    API，甚至构建了我们的基本路由系统。然后，我们创建了几个路由，列出并创建了我们的*数据存储*中的记录。在本章即将结束时，我们学习了如何处理API中的头部，并将其添加到我们的端点中。
- en: We finished the chapter by serving a single-page application directly from our
    web server; that same single-page application that consumed and interacted with
    our API.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们结束了这一章节，通过我们的网络服务器直接提供了一个单页应用程序；这个单页应用程序消费并与我们API进行了交互。
- en: This was a chapter where lots of ground was covered. We started building APIs
    that are now much closer to reality than what we previously did. We also got more
    of a grasp on what it is to develop with Deno, using permissions, and the documentation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章我们覆盖了很多内容。我们开始构建API，这些API现在比我们之前所做的更接近现实。我们还更清楚地了解了使用Deno开发、使用权限和文档的感觉。
- en: The current chapter wraps up our introductory journey and has hopefully left
    you curious about what is coming next.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当前章节结束了我们的入门之旅，希望它让你对接下来的内容感到好奇。
- en: In the next four chapters, we'll be building a web application and will explore
    all the decisions made in the process. Most of the knowledge you have learned
    so far will be used later, but there is also a ton of new, exciting stuff coming
    up. In the next chapter, we'll start creating an API that we'll be adding features
    to as the chapters progress.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的四章中，我们将构建一个网络应用程序，并探索在这一过程中所做的所有决定。到目前为止你所学的的大部分知识将在后面用到，但也有很多新的、令人兴奋的内容。在下一章，我们将开始创建一个API，随着章节的进行，我们将继续为其添加功能。
- en: I hope to have you on board!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能加入我们！
