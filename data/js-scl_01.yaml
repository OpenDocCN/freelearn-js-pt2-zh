- en: Chapter 1. Scale from a JavaScript Perspective
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章．从JavaScript视角看规模化
- en: JavaScript applications are getting bigger. That's because we can do more with
    the language—more than most thought possible. After all, JavaScript was conceived
    as a means to activate otherwise static web pages. A means by which to fill gaps
    in HTML, as it were. Year after year, more and more web sites started developing
    JavaScript code to improve the functionality of their pages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用程序正在变得更大。这是因为我们可以用这门语言做更多的事情——比大多数人想象的还要多。毕竟，JavaScript被设想为激活其他静态网页的手段。一种填充HTML空白的手段。年复一年，越来越多的网站开始开发JavaScript代码以提高其页面的功能性。
- en: Despite the frustrations of certain language idiosyncrasies, JavaScript popularity
    gained critical mass—today it's the most popular programming language on GitHub
    ([http://githut.info/](http://githut.info/)). From then onward, web sites started
    looking more like applications that a user would install on their desktop. Libraries
    and frameworks started popping up left right and center. Why? Because frontend
    JavaScript applications are large and complex.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管某些语言特色让人感到挫败，但JavaScript的流行度已经达到了临界质量——今天它成为了GitHub上最受欢迎的编程语言([http://githut.info/](http://githut.info/)).
    从那时起，网站开始看起来更像是在用户桌面上安装的应用程序。库和框架如雨后春笋般涌现。为什么？因为前端JavaScript应用程序很大且复杂。
- en: In the present day frontend development profession, there's a lot of tools at
    our disposal. The JavaScript language has evolved into something that's usable
    on its own; it's becoming less dependent on libraries to perform the most fundamental
    and basic programming tasks. This is especially true of the next iteration of
    the ECMAScript specification, where problems that have plagued developers for
    years are at least partially addressed by constructs added to the language. This,
    of course, doesn't negate the need for application frameworks. The frontend development
    environment and its supporting web standards are far from perfect, but they're
    improving.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的前端开发职业中，我们有大量的工具可供选择。JavaScript语言已经发展到了可以独立使用的程度；它越来越不依赖于库来执行最基本和最基础的编程任务。这尤其适用于ECMAScript规范的下一版，其中添加到语言中的构造部分解决了困扰开发者多年的问题。当然，这并不否定应用程序框架的必要性。前端开发环境和其支持的网络标准离完美还远，但它们正在改善。
- en: Something that's been missing from the frontend development picture for a long
    time is architecture. Frontend architectures have become prevalent in recent years
    due to the complexity of what's being implemented. Sophisticated tools, allow
    frontend developers to design an architecture that's able to scale with the problems
    we're trying to solve. And that's the crux of this book—JavaScript architectures
    that scale. But scale to what exactly? It's not your traditional scaling problem
    in computing, where you need to handle more load in a distributed server environment.
    Scaling in the frontend presents its own unique challenges and constraints. This
    chapter will define some of the scaling issues faced by JavaScript architectures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来在前端开发领域缺失的一环是架构。由于实施内容的复杂性，前端架构近年来变得普遍。复杂的工具允许前端开发者设计一种能够与我们要解决的问题一起扩展的架构。这本书的核心就是可扩展的JavaScript架构。但扩展到什么程度呢？这并不是传统计算领域中的扩展问题，在那里你需要在一个分布式服务器环境中处理更多的负载。前端扩展提出了它自己独特的挑战和约束。本章将定义JavaScript架构面临的一些扩展问题。
- en: Scaling influencers
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影响者规模化
- en: We don't scale our software systems just because we can. While it's common to
    tout scalability, these claims need to be put into practice. In order to do so,
    there has to be a reason for scalable software. If there's no need to scale, then
    it's much easier, not to mention cost-effective, to simply build a system that
    doesn't scale. Putting something that was built to handle a wide variety of scaling
    issues into a context where scale isn't warranted just feels clunky. Especially
    to the end user.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是仅仅因为能够扩展就扩展我们的软件系统。虽然可扩展性常常被吹嘘，但这些主张需要付诸实践。为了这样做，可扩展软件必须有它的理由。如果没有扩展的必要，那么简单地构建一个不可扩展的系统既简单又经济。把为处理各种扩展问题而构建的东西放入一个不需要扩展的上下文中，这只会让人感到笨拙。特别是对于最终用户来说。
- en: So we, as JavaScript developers and architects, need to acknowledge and understand
    the influences that necessitate scalability. While it's true that not all JavaScript
    applications need to scale, it may not always be the case. For example, it's difficult
    to say that we know this system isn't going to need to scale in any meaningful
    way, so let's not invest the time and effort to make it scalable. Unless we're
    developing a throw-away system, there's always going to be expectations of growth
    and success.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为JavaScript开发者和架构师，我们需要承认并理解那些需要可扩展性的影响因素。虽然并非所有JavaScript应用程序都需要扩展，但这并不总是绝对的。例如，很难说我们知道这个系统不会以任何有意义的方式需要扩展，因此我们不要投入时间和精力使其具有可扩展性。除非我们正在开发一个一次性的系统，否则总会对增长和成功有所期待。
- en: At the opposite end of the spectrum, JavaScript applications aren't born as
    mature scalable systems. They grow up, accumulating scalable properties along
    the way. Scaling influencers are an effective tool for those of us working on
    JavaScript projects. We don't want to over-engineer something straight from inception,
    and we don't want to build something that's tied-down by early decisions, limiting
    its ability to scale.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的另一端，JavaScript应用程序并非天生就是成熟的可扩展系统。它们随着时间成长，在此过程中积累可扩展的属性。影响因子是那些从事JavaScript项目工作的有效工具。我们不希望从构思阶段就开始过度工程化，也不希望构建的东西过早地被早期决策所束缚，限制其扩展能力。
- en: The need for scale
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展的需求
- en: Scaling software is a reactive event. Thinking about scaling influencers helps
    us proactively prepare for these scaling events. In other systems, such as web
    application backends, these scaling events may be brief spikes, and are generally
    handled automatically. For example, there's an increased load due to more users
    issuing more requests. The load balancer kicks in and distributes the load evenly
    across backend servers. In the extreme case, the system may automatically provision
    new backend resources when needed, and destroy them when they're no longer of
    use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展软件是一个反应性事件。考虑影响因子有助于我们主动为这些扩展事件做准备。在其他系统中，比如Web应用程序后端，这些扩展事件可能是短暂的峰值，并且通常会自动处理。例如，由于更多用户发出更多请求而增加了负载。负载均衡器介入，平均地将负载分配到后端服务器上。在极端情况下，当需要时系统可能会自动提供新的后端资源，并在不再需要时销毁它们。
- en: Scaling events in the frontend aren't like that. Rather, the scaling events
    that take place generally happen over longer periods of time, and are more complex.
    The unique aspect of JavaScript applications is that the only hardware resources
    available to them are those available to the browser in which they run. They get
    their data from the backend, and this may scale up perfectly fine, but that's
    not what we're concerned with. As our software grows, a necessary side-effect
    of doing something successfully, is that we need to pay attention to the influencers
    of scale.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前端发生的扩展事件并非如此。实际上，通常发生的扩展事件发生的时间更长，且更复杂。JavaScript应用程序的独特之处在于，它们可用的唯一硬件资源就是运行它们的浏览器中的资源。它们从后端获取数据，这可能扩展得很好，但这不是我们关心的。随着我们的软件的增长，成功执行某事的必要副作用是我们需要注意可扩展性的影响因子。
- en: '![The need for scale](img/4369_01_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![扩展的需求](img/4369_01_01.jpg)'
- en: The preceding figure shows us a top-down flow chart of scaling influencers,
    starting with users, who require that our software implements features. Depending
    on various aspects of the features, such as their size and how they relate to
    other features, this influences the team of developers working on features. As
    we move down through the scaling influencers, this grows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表向我们展示了从上至下的影响因子图表，从用户开始，他们要求我们的软件实现功能。根据功能的各种方面，比如它们的大小以及它们与其他功能的关系，这影响了负责功能开发的开发团队。随着影响因子的扩大，这种影响也在增长。
- en: Growing user base
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增长的用户基础
- en: We're not building an application for just one user. If we were, there would
    be no need to scale our efforts. While what we build might be based on the requirements
    of one user representative, our software serves the needs of many users. We need
    to anticipate a growing user base as our application evolves. There's no exact
    target user count, although, depending on the nature of our application, we may
    set goals for the number of active users, possibly by benchmarking similar applications
    using a tool such as [http://www.alexa.com/](http://www.alexa.com/). For example,
    if our application is exposed on the public internet, we want lots of registered
    users. On the other hand, we might target private installations, and there, the
    number of users joining the system is a little slower. But even in the latter
    case, we still want the number of deployments to go up, increasing the total number
    of people using our software.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅为一位用户构建应用。如果是这样，那就没有扩大努力的必要。虽然我们所构建的东西可能是基于一位用户代表的 requirements，但我们的软件服务于许多用户。我们需要预见我们应用发展过程中的不断增长的客户基础。尽管我们可能根据应用的性质设定活跃用户数量的目标，例如，通过使用像[http://www.alexa.com/](http://www.alexa.com/)这样的工具来参考类似应用。例如，如果我们的应用面向公众互联网，我们希望有很多注册用户。另一方面，我们可能会针对私有安装，在那里，系统中的用户加入速度可能会慢一些。但在后一种情况下，我们仍然希望部署数量增加，从而使使用我们软件的总人数增加。
- en: The number of users interacting with our frontend is the largest influencer
    of scale. With each user added, along with the various architectural perspectives,
    growth happens exponentially. If you look at it from a top-down point of view,
    users call the shots. At the end of the day, our application exists to serve them.
    The better we're able to scale our JavaScript code, the more users we'll please.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的前端互动的用户数量是影响扩展性的最大因素。每增加一个用户，以及随着各种架构视角的加入，增长是呈指数级的。如果你从自上而下的角度来看，用户掌握着主动权。归根结底，我们的应用是为了服务他们。我们越能有效地扩展JavaScript代码，我们就越能取悦更多用户。
- en: Building new features
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建新特性
- en: Perhaps the most obvious side-effect of successful software with a strong user
    base is the features necessary to keep those users happy. The feature set grows
    along with the users of the system. This is often overlooked by projects, despite
    the obviousness of new features. We know they're coming, yet, little thought goes
    into how the endless stream of features going into our code impedes our ability
    to scale up our efforts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的软件，尤其是拥有庞大用户基础的软件，最明显的副作用可能是为了保持用户满意度而必须添加的新特性。随着系统用户的增长，功能集合也在不断增加。尽管新特性显而易见，但这个方面常常被项目忽视。我们知道新特性正在路上，然而，却很少思考无休止的新特性如何妨碍我们扩大努力的规模。
- en: This is especially tricky when the software is in its infancy. The organization
    developing the software will bend over backwards to reel in new users. And there's
    little consequence of doing so in the beginning because the side-effects are limited.
    There's not a lot of mature features, there's not a huge development team, and
    there's less chance of annoying existing users by breaking something that they've
    come to rely on. When these factors aren't there, it's easier for us to nimbly
    crank out the features and dazzle existing/prospective users. But how do we force
    ourselves to be mindful of these early design decisions? How do we make sure that
    we don't unnecessarily limit our ability to scale the software up, in terms of
    supporting more features?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件还处于起步阶段时，这种情况尤其棘手。开发软件的组织会不遗余力地吸引新用户。在初期这样做似乎没有太大后果，因为副作用有限。没有很多成熟的功能，没有庞大的开发团队，也不太可能因为破坏了用户依赖的某项功能而惹恼现有用户。当这些因素不存在时，我们更容易灵活地推出新特性，让现有和潜在用户眼花缭乱。但我们如何迫使自己关注这些早期设计决策？我们如何确保自己不会不必要地限制我们扩展软件支持更多特性的能力？
- en: As we'll see throughout this book, new feature development, as well as enhancing
    existing features, is an ongoing issue with scalable JavaScript architecture.
    It's not just the number of features listed in the marketing literature of our
    software that we need to be concerned about . There's also the complexity of a
    given feature, how common our features are with one another, and how many moving
    parts each of these features has. If the user is the first level when looking
    at JavaScript architecture from a top-down perspective, each feature is the next
    level, and from there, it expands out into enormous complexity.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本书中看到的那样，新功能的开发以及现有功能的增强是可扩展的JavaScript架构持续面临的问题。我们不应该只关注我们软件市场营销文献中列出的功能数量。我们还需要考虑特定功能的复杂性，各个功能之间的通用性，以及每个功能有多少活动部分。从顶层视角来看，用户是第一层，每个功能是下一层，从那里开始，它会扩展到巨大的复杂性。
- en: It's not just the individual users who make a given feature complex. Instead,
    it's a group of users that all need the same feature in order to use our software
    effectively. And from there, we have to start thinking about personas, or roles,
    and which features are available for which roles. The need for this type of organizational
    structure isn't made apparent till much later on in the game; after we've made
    decisions that make it difficult to introduce role-based feature delivery. And
    depending on how our software is deployed, we may have to support a variety of
    unique use cases. For example, if we have several large organizations as our customers,
    each with their own deployments, they'll likely have their own unique constraints
    on how users are structured. This is challenging, and our architecture needs to
    support the disparate needs of many organizations, if we're going to scale.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让一个功能变得复杂不仅仅是单个用户的问题。相反，是一群都需要同一个功能才能有效使用我们的软件的用户。从那里开始，我们必须开始考虑人物角色，或者职责，以及哪些职责对哪些角色可用。这种组织结构的需求在游戏进行到很晚之后才会变得明显；在我们做出决定使引入基于角色的功能交付变得困难之后。而且，根据我们的软件是如何部署的，我们可能需要支持各种独特的用例。例如，如果我们有多个大型组织作为客户，每个组织都有自己的部署，他们很可能对用户结构有自己的独特限制。这是具有挑战性的，我们的架构需要支持许多组织的不同需求，如果我们想要扩展。
- en: Hiring more developers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 雇佣更多的开发者
- en: Making these features a reality requires solid JavaScript developers who know
    what they're doing, and if we're lucky, we'll be able to hire a team of them.
    The team part doesn't happen automatically. There's a level of trust and respect
    that needs to be established before the team members begin to actively rely on
    one another to crank out some awesome code. Once that starts happening, we're
    in good shape. Turning once again to the top-down perspective of our scaling influencers,
    the features we deliver can directly impact the health of our team. There's a
    balance that's essentially impossible to maintain, but we can at least get close.
    Too many features and not enough developers lead to a sense of perpetual inadequacy
    among team members. When there's no chance of delivering what's expected, there's
    not much sense in trying. On the other hand, if you have too many developers,
    and there's too much communication overhead due to a limited number of features,
    it's tough to define responsibilities. When there's no shared understanding of
    responsibilities, things start to break down.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些功能变为现实需要精通JavaScript的开发人员，他们知道自己在做什么，如果我们有幸，我们能够雇佣他们组成一个团队。团队的建设不是自动发生的。在团队成员开始积极依赖彼此输出一些精彩的代码之前，需要建立一定程度的信任和尊重。一旦开始发生这种情况，我们就处于良好的状态。再次从我们扩展的影响者的顶层视角来看，我们交付的功能可以直接影响我们团队的士气。维持一种平衡基本上是不可能的，但至少我们可以接近它。功能太多，开发者太少，会导致团队成员之间产生持续的不安全感。当没有机会交付预期中的东西时，尝试就没有多大意义了。另一方面，如果你有太多的开发者，由于功能有限，导致沟通成本过高，很难定义责任。当没有共享的责任理解时，事情开始崩溃。
- en: It's actually easier to deal with not enough developers for the features we're
    trying to develop, than having too many developers. When there's a large burden
    of feature development, it's a good opportunity to step back and think—"what would
    we do differently if we had more developers?" This question usually gets skipped.
    We go hire more developers, and when they arrive, it's to everyone's surprise
    that there's no immediate improvement in feature throughput. This is why it's
    best to have an open development culture where there are no stupid questions,
    and where responsibilities are defined.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，处理想要开发的功能却缺乏足够的开发者要比处理开发者过多要容易。当 feature 开发负担很重时，退一步思考—"如果我们有更多开发者，我们会怎么做
    differently?" 这个问题通常会被忽略。我们去招聘更多的开发者，他们到来之后，让大家都惊讶的是，features 的吞吐量并没有立即得到改善。这就是为什么拥有一个开放的开发生态文化很重要，在那里，没有人会问愚蠢的问题，责任定义明确。
- en: There's no one correct team structure or development methodology. The development
    team needs to apply itself to the issues faced by the software we're trying to
    deliver. The biggest hurdle is for sure the number, size, and complexity of features.
    So that's something we need to consider when forming our team initially, as well
    as when growing the team. This latter point is especially true because the team
    structure we used way back when the software was new isn't going to fit what we
    face when the features scale up.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种正确的团队结构或开发方法论。开发团队需要致力于解决我们试图交付的软件所面临的问题。最大的挑战无疑是功能的数量、大小和复杂性。因此，在组建团队时，我们需要考虑这个问题，以及在团队扩充时也是如此。尤其是后者，因为软件还处于初期阶段时我们所使用的团队结构，可能不适合功能扩展时我们所面临的挑战。
- en: Architectural perspectives
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构视角
- en: 'The preceding section was a sampling of the factors that influence scale in
    JavaScript applications. Starting from the top, each of these influencers affects
    the influencer below it. The number and nature of our users is the first and foremost
    influencer, and this has a direct impact on the number and nature of the features
    we develop. Further more, the size of the development team, and the structure
    of that team, are influenced by these features. Our job is to take these influencers
    of scale, and translate them into factors to consider from an architectural perspective:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分内容是对影响 JavaScript 应用程序扩展性的因素的采样。从顶部开始，每一个影响因素都会影响它下面的影响因素。我们的用户数量和性质是我们首先要考虑的影响因素，这对我们开发的功能数量和性质有直接影响。进一步地，开发团队的规模和结构也受到这些功能的影响。我们的任务是将这些扩展性的影响因素，转化为从架构视角考虑的因素：
- en: '![Architectural perspectives](img/4369_01_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![架构视角](img/4369_01_02.jpg)'
- en: Scaling influences the perspectives of our architecture. Our architecture, in
    turn, determines responses to scaling influencers. The process is iterative and
    never-ending throughout the lifetime of our software.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展性影响了我们的架构视角。我们的架构反过来又决定了对扩展性影响因素的响应。这个过程是迭代和无休止的，贯穿我们软件的整个生命周期。
- en: The browser is a unique environment
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器是一个独特的环境
- en: Scaling up in the traditional sense doesn't really work in a browser environment.
    When backend services are overwhelmed by demand, it's common to "throw more hardware"
    at the problem. Easier said than done of course, but it's a lot easier to scale
    up our data services these days, compared to 20 years ago. Today's software systems
    are designed with scalability in mind. It's helpful to our frontend application
    if the backend services are always available and always responsive, but that's
    just a small portion of the issues we face.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统意义上的扩展性在浏览器环境中实际上并不真正有效。当后端服务因需求过载而无法应对时，常见的做法是“堆砌更多硬件”来解决问题。当然，说起来容易做起来难，但与20年前相比，如今扩展我们的数据服务要容易得多。当今的软件系统都是设计为可扩展的。如果后端服务总是可用且总是有响应，这对我们的前端应用程序是有帮助的，但这只是我们面临的问题中的一部分。
- en: We can't throw more hardware at the web browsers running our code; given that;
    the time and space complexities of our algorithms are important. Desktop applications
    generally have a set of system requirements for running the software, such as
    OS version, minimum memory, minimum CPU, and so on. If we were to advertise requirements
    such as these in our JavaScript applications, our user base would shrink dramatically,
    and possibly generate some hate mail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能给运行我们代码的网络浏览器增加更多硬件；鉴于这一点，我们算法的时间和空间复杂性很重要。桌面应用程序通常有一组运行软件的系统要求，比如操作系统版本、最小内存、最小CPU等。如果我们在我们JavaScript应用程序中宣传这些要求，我们的用户基础会大幅减少，可能会引发一些仇恨邮件。
- en: 'The expectation that browser-based web applications be lean and fast is an
    emergent phenomenon. Perhaps, that''s due in part to the competition we face.
    There are a lot of bloated applications out there, and whether they''re used in
    the browser or natively on the desktop, users know what bloat feels like, and
    generally run the other way:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 期望基于浏览器的网络应用程序简洁且快速，这是一种新兴现象。也许，这在一定程度上是由于我们面临的竞争。有很多膨胀的应用程序 out there，无论它们是在浏览器中使用还是在本地下载，用户都知道膨胀的感觉是什么，通常会避开：
- en: '![The browser is a unique environment](img/4369_01_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器是一个独特的环境](img/4369_01_03.jpg)'
- en: JavaScript applications require many resources, all of different types; these
    are all fetched by the browser, on the application's behalf.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用程序需要许多资源，所有这些资源都有不同的类型；这些资源都由浏览器代表应用程序获取。
- en: 'Adding to our trouble is the fact that we''re using a platform that was designed
    as a means to download and display hypertext, to click on a link, and repeat.
    Now we''re doing the same thing, except with full-sized applications. Multi-page
    applications are slowly being set aside in favor of single-page applications.
    That being said, the application is still treated as though it were a web page.
    Despite all that, we''re in the midst of big changes. The browser is a fully viable
    web platform, the JavaScript language is maturing, and there are numerous W3C
    specifications in progress; they assist with treating our JavaScript more like
    an application and less like a document. Take a look at the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 增加我们麻烦的一个事实是，我们正在使用一个设计用来下载和显示超文本、点击链接并重复的平台。现在我们做的是同样的事情，只不过是用完整的应用程序。多页面应用程序正逐渐被单页面应用程序所取代。说到这里，应用程序仍然被当作一个网页来处理。尽管如此，我们正处在巨大的变革之中。浏览器是一个完全可行的网络平台，JavaScript语言正在成熟，还有许多W3C规范正在制定中；它们帮助我们的JavaScript更像一个应用程序，而不是一个文档。请看下面的图表：
- en: '![The browser is a unique environment](img/4369_01_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器是一个独特的环境](img/4369_01_04.jpg)'
- en: A sampling of the technologies found in the growing web platform
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 网络平台中发现的技术的样本
- en: We use architectural perspectives to assess any architectural design we come
    up with. It's a powerful technique to examine our design through a different lens.
    JavaScript architecture is no different, especially for those that scale. The
    difference between JavaScript architecture and architecture for other environments
    is that ours have unique perspectives. The browser environment requires that we
    think differently about how we design, build, and deploy applications. Anything
    that runs in the browser is transient by nature, and this changes software design
    practices that we've taken for granted over the years. Additionally, we spend
    more time coding our architectures than diagramming them. By the time we sketch
    anything out, it's been superseded by another specification or another tool.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用架构视角来评估我们提出的任何架构设计。这是一种强大的技术，通过不同的镜头检查我们的设计。JavaScript架构也不例外，尤其是对于那些可扩展的架构。JavaScript架构与其他环境架构的区别在于我们有独特的视角。浏览器环境要求我们以不同的方式思考设计、构建和部署应用程序。在浏览器中运行的任何东西本质上都是短暂的，这改变了我们多年来认为理所当然的软件设计实践。此外，我们花在编码架构上的时间比画图更多。等到我们画出任何东西时，它已经被另一个规范或工具所取代。
- en: Component design
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件设计
- en: At an architectural level, components are the main building blocks we work with.
    These may be very high-level components with several levels of abstraction. Or,
    they could be something exposed by a framework we're using, as many of these tools
    provide their own idea of "components". For our purposes in this book, components
    sit somewhere in the middle—not too abstract, and not too implementation-specific.
    The idea being that we need to be thoughtful of our application composition, without
    worrying too much about the specifics.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构层面，组件是我们工作的主要构建块。这些可能是具有多级抽象的高级组件。或者，它们可能是我们正在使用的框架暴露的内容，因为许多这些工具都提供它们自己的“组件”概念。在本书中，组件位于中间位置——不是太抽象，也不是太具体实现。这里的想法是我们需要对我们的应用程序组成进行深思熟虑，而无需过于担心具体实现。
- en: 'When we first set out to build a JavaScript application with scale in mind,
    the composition of our components began to take shape. How our components are
    composed is a huge limiting factor in how we scale, because they set the standard.
    Components implement patterns for the sake of consistency, and it''s important
    to get those patterns right:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次着手构建一个考虑可扩展性的JavaScript应用程序时，组件的组成开始成形。组件如何组合是我们扩展的关键限制因素，因为它们设定了标准。组件实现模式以保持一致性，正确地获得这些模式非常重要：
- en: '![Component design](img/4369_01_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![组件设计](img/4369_01_05.jpg)'
- en: Components have an internal structure. The complexity of this composition depends
    on the type of component under consideration
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 组件具有内部结构。这种组合的复杂性取决于考虑中的组件类型。
- en: As we'll see, the design of our various components is closely-tied to the trade-offs
    we make in other perspectives. And that's a good thing, because it means that
    if we're paying attention to the scalable qualities we're after, we can go back
    and adjust the design of our components in order to meet those qualities.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，我们各种组件的设计与其他视角中我们做出的权衡紧密相关。这是件好事，因为它意味着如果我们关注所需的扩展特性，我们可以回顾并调整组件的设计以满足这些特性。
- en: Component communication
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件通信
- en: 'Components don''t sit in the browser on their own. Components communicate with
    one another all the time. There''s a wide variety of communication techniques
    at our disposal here. Component communication could be as simple as method invocation,
    or as complex as an asynchronous publish-subscribe event system. The approach
    we take with our architecture depends on our more specific goals. The challenge
    with components is that we often don''t know what the ideal communication mechanism
    will be, till after we''ve started implementing our application. We have to make
    sure that we can adjust the chosen communication path:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 组件不会在浏览器中单独存在。组件一直在相互通信。我们有多种通信技术可供选择。组件通信可能简单到方法调用，也可能复杂到异步发布-订阅事件系统。我们采取的架构方法取决于我们更具体的目标。组件的挑战在于，我们通常在开始实现应用程序之后才知道理想的通信机制是什么。我们必须确保我们可以调整所选的通信路径：
- en: '![Component communication](img/4369_01_06.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![组件通信](img/4369_01_06.jpg)'
- en: The component communication mechanism decouples components, enabling scalable
    structures
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 组件通信机制使组件解耦，实现可扩展的结构。
- en: Seldom will we implement our own communication mechanism for our components.
    Not when so many tools exist, that solve at least part of the problem for us.
    Most likely, we'll end up with a concoction of an existing tool for communication
    and our own implementation specifics. What's important is that the component communication
    mechanism is its own perspective, which can be designed independently of the components
    themselves.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少为组件实现自己的通信机制。既然有许多工具可以为我们解决至少部分问题，何必如此呢。很可能，我们最终会得到一种混合了现有通信工具和我们自己实现特定内容的混合物。重要的是，组件通信机制是其自身的视角，可以独立于组件本身进行设计。
- en: Load time
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载时间
- en: JavaScript applications are always loading something. The biggest challenge
    is the application itself, loading all the static resources it needs to run, before
    the user is allowed to do anything. Then there's the application data. This needs
    to be loaded at some point, often on demand, and contributes to the overall latency
    experienced by the user. Load time is an important perspective, because it hugely
    contributes to the overall perception of our product quality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用程序总是在加载一些东西。最大的挑战是应用程序本身，在用户可以执行任何操作之前，它需要加载所有必要的静态资源。然后还有应用程序数据。这需要在某个时刻加载，通常按需加载，并导致用户体验到的整体延迟。加载时间是一个重要的视角，因为它极大地影响到我们产品整体质量的感知。
- en: '![Load time](img/4369_01_07.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![加载时间](img/4369_01_07.jpg)'
- en: The initial load is the user's first impression and this is where most components
    are initialized; it's tough to get the initial load to be fast without sacrificing
    performance in other areas
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 初始加载是用户的第一次印象，大多数组件都在这里初始化；要让初始加载速度快，而不牺牲其他方面的性能，是非常困难的。
- en: There's lots we can do here to offset the negative user experience of waiting
    for things to load. This includes utilizing web specifications that allow us to
    treat applications and the services they use as installable components in the
    web browser platform. Of course, these are all nascent ideas, but worth considering
    as they mature alongside our application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以做很多事情来抵消用户等待事物加载的负面体验。这包括利用Web规范，使我们能够将应用程序及其使用的服务作为可在Web浏览器平台上安装的组件来处理。当然，这些想法都还处于初级阶段，但随着它们和我们的应用程序一起成熟，值得考虑。
- en: Responsiveness
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应性
- en: The second part of the performance perspective of our architecture is concerned
    with responsiveness. That is, after everything has loaded, how long does it take
    for us to respond to user input? Although this is a separate problem from that
    of loading resources from the backend, they're still closely-related. Often, user
    actions trigger API requests, and the techniques we employ to handle these workflows
    impact user-perceived responsiveness.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们架构性能视角的第二部分关注的是响应性。也就是说，在一切加载完成后，我们响应用户输入需要多长时间？虽然这个问题与从后端加载资源的问题不同，但它们仍然密切相关。通常，用户操作会触发API请求，我们用来处理这些工作流程的技术影响用户感知的响应性。
- en: '![Responsiveness](img/4369_01_08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![响应性](img/4369_01_08.jpg)'
- en: User-perceived responsiveness is affected by the time taken by our components
    to respond to DOM events; a lot can happen in between the initial DOM event and
    when we finally notify the user by updating the DOM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用户感知到的响应性受到我们组件对DOM事件响应所需时间的影响；在DOM事件初始发生和我们最终通过更新DOM来通知用户之间，很多事情都有可能发生。
- en: Because of this necessary API interaction, user-perceived responsiveness is
    important. While we can't make the API go any faster, we can take steps to ensure
    that the user always has feedback from the UI and that feedback is immediate.
    Then, there's the responsiveness of simply navigating around the UI, using cached
    data that's already been loaded, for example. Every other architectural perspective
    is closely-tied to the performance of our JavaScript code, and ultimately, to
    the user-perceived responsiveness. This perspective is a subtle sanity-check for
    the design of our components and their chosen communication paths.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必要的API交互，用户感知的响应性很重要。虽然我们无法使API更快，但我们可以采取措施确保用户总是从UI获得反馈，并且反馈是即时的。然后，还有简单地在UI中导航的响应性，例如使用已经加载的缓存数据。除了其他架构视角外，所有视角都与我们的JavaScript代码性能紧密相关，最终，也与用户感知的响应性相关。这个视角对我们组件设计和它们选择的通信路径的合理性进行检查。
- en: Addressability
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可寻址性
- en: 'Just because we''re building a single-page application doesn''t mean we no
    longer care about addressable URIs. This is perhaps the crowning achievement of
    the web— unique identifiers that point to the resource we want. We paste them
    in to our browser address bar and watch the magic happen. Our application most
    certainly has addressable resources, we just point to them differently. Instead
    of a URI that''s parsed by the backend web server, where the page is constructed
    and sent back to the browser, it''s our local JavaScript code that understands
    the URI:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为我们正在构建单页应用程序，并不意味着我们不再关心可寻址的URI。这或许是Web的巅峰之作——指向我们想要资源的唯一标识符。我们将它们粘贴到浏览器地址栏中，然后见证奇迹发生。我们的应用程序肯定有可寻址的资源，我们只是以不同的方式指向它们。不是后端Web服务器解析的URI，在那里页面被构建并发送回浏览器，而是我们的本地JavaScript代码理解URI：
- en: '![Addressability](img/4369_01_09.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![地址可访问性](img/4369_01_09.jpg)'
- en: Components listen to routers for route events and respond accordingly. A changing
    browser URI triggers these events.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 组件监听路由器的路由事件并相应地响应。变化的浏览器URI触发这些事件。
- en: Typically, these URIs will map to an API resource. When the user hits one of
    these URIs in our application, we'll translate the URI into another URI that's
    used to request backend data. The component we use to manage these application
    URIs is called a router, and there's lots of frameworks and libraries with a base
    implementation of a router. We'll likely use one of these.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些URI将映射到API资源。当用户在我们的应用程序中点击这些URI时，我们会将URI翻译成另一个用于请求后端数据的URI。我们用来管理这些应用程序URI的组件称为路由器，有许多框架和库带有基本的路由器实现。我们可能会使用其中的一个。
- en: The addressability perspective plays a major role in our architecture, because
    ensuring that the various aspects of our application have an addressable URI complicates
    our design. However, it can also make things easier if we're clever about it.
    We can have our components utilize the URIs in the same way a user utilizes links.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 地址可访问性视角在我们的架构中扮演着重要角色，因为确保我们应用的各个方面都有可访问的统一资源标识符（URI）会复杂化我们的设计。然而，如果我们聪明地处理，它也可以让事情变得更容易。我们的组件可以使用URI，就像用户使用链接一样。
- en: Configurability
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可配置性
- en: 'Rarely does software do what you need it to straight out of the box. Highly-configurable
    software systems are touted as being good software systems. Configuration in the
    frontend is a challenge because there''s several dimensions of configuration,
    not to mention the issue of where we store these configuration options. Default
    values for configurable components are problematic too—where do they come from?
    For example, is there a default language setting that''s set until the user changes
    it? As is often the case, different deployments of our frontend will require different
    default values for these settings:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 软件很少能直接按照你的需求来工作。高度可配置的软件系统被认为是好的软件系统。前端配置是一个挑战，因为配置有多个维度，更不用说存储这些配置选项的问题了。可配置组件的默认值也是一个问题——它们从哪里来？例如，是否有设置默认语言，直到用户更改它？像往常一样，我们前端的不同部署需要这些设置的不同默认值：
- en: '![Configurability](img/4369_01_10.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![可配置性](img/4369_01_10.jpg)'
- en: Component configuration values can come from the backend server, or from the
    web browser. Defaults must reside somewhere
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 组件配置值可以来自后端服务器，或者来自网页浏览器。默认值必须存在于某个地方。
- en: Every configurable aspect of our software complicates its design. Not to mention
    the performance overhead and potential bugs. So, configurability is a large issue,
    and it's worth the time spent up-front discussing with various stakeholders what
    they value in terms of configurability. Depending on the nature of our deployment,
    users may value portability with their configuration. This means that their values
    need to be stored in the backend, under their account settings. Obviously decisions
    like these have backend design implications, and sometimes it's better to get
    away with approaches that don't require a modified backend service.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们软件的每个可配置方面都会复杂其设计。更不用说性能开销和潜在的错误。因此，可配置性是一个大问题，花时间讨论不同利益相关者认为的可配置性价值是值得的。根据我们部署的性质，用户可能重视配置的可移植性。这意味着他们的值需要存储在后台，在他们的账户设置中。显然，这样的决定对后台设计有影响，有时最好采用不需要修改后台服务的做法。
- en: Making architectural trade-offs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做出架构性权衡
- en: There's a lot to consider from the various perspectives of our architecture,
    if we're going to build something that scales. We'll never get everything that
    we need out of every perspective simultaneously. This is why we make architectural
    trade-offs—we trade one aspect of our design for another more desirable aspect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想构建可扩展的东西，我们必须从我们架构的各种角度考虑很多问题。我们不可能同时从每个角度获得我们需要的所有东西。这就是我们为什么要做出架构性权衡——我们用一个设计方面换取另一个更受欢迎的方面。
- en: Defining your constants
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义你的常量
- en: Before we start making trade-offs, it's important to state explicitly what cannot
    be traded. What aspects of our design are so crucial to achieving scale that they
    must remain constant? For instance, a constant might be the number of entities
    rendered on a given page, or a maximum level of function call **indirection**.
    There shouldn't be a ton of these architectural constants, but they do exist.
    It's best if we keep them narrow in scope and limited in number. If we have too
    many strict design principles that cannot be violated or otherwise changed to
    fit our needs, we won't be able to easily adapt to changing influencers of scale.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始做出权衡之前，明确指出哪些是不能交易的非常重要。我们的设计中有哪些方面对于实现扩展至关重要，以至于它们必须保持不变？例如，一个常数可能是特定页面渲染的实体数量，或者是函数调用**间接性**的最大级别。这些架构常数不应该有很多，但它们确实存在。最好是我们保持它们范围狭窄且数量有限。如果我们有太多不能违反或更改以适应我们需求的严格设计原则，我们将无法轻松适应规模变化的驱动因素。
- en: Does it make sense to have constant design principles that never change, given
    the unpredictability of scaling influencers? It does, but only once they emerge
    and are obvious. So this may not be an up-front principle, though we'll often
    have at least one or two up-front principles to follow. The discovery of these
    principles may result from the early refactoring of code or the later success
    of our software. In any case, the constants we use going forward must be made
    explicit and be agreed upon by all those involved.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑到扩展影响因素的不确定性时，是否有意义坚持永远不变的设计原则呢？是有意义的，但仅当这些原则出现并变得明显时。所以这可能不是一个一开始就需要遵循的原则，尽管我们通常至少会有一两个一开始就需要遵循的原则。这些原则的发现可能源于代码的早期重构，或我们软件的后期成功。无论如何，我们今后使用的常数必须是明确并得到所有相关人员的一致同意。
- en: Performance for ease of development
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能对于开发便捷性的影响
- en: Performance bottlenecks need to be fixed, or avoided in the first place where
    possible. Some performance bottlenecks are obvious and have an observable impact
    on the user experience. These need to be fixed immediately, because it means our
    code isn't scaling for some reason, and might even point to a larger design issue.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 性能瓶颈需要被修复，或者在可能的情况下避免。一些性能瓶颈很明显，并对用户体验产生可观察的影响。这些需要立即修复，因为这意味着我们的代码由于某些原因没有实现扩展，甚至可能指向一个更大的设计问题。
- en: Other performance issues are relatively small. These are generally noticed by
    developers running benchmarks against code, trying by all means necessary to improve
    the performance. This doesn't scale well, because these smaller performance bottlenecks
    that aren't observable by the end user are time-consuming to fix. If our application
    is of a reasonable size, with more than a few developers working on it, we're
    not going to be able to keep up with feature development if everyone's fixing
    minor performance problems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其他性能问题相对较小。通常开发者会运行针对代码的基准测试，尽一切可能改善性能。这种方法扩展性不佳，因为这些对最终用户不可见的较小性能瓶颈修复起来耗时较长。如果我们的应用程序规模合理，有多个开发者参与开发，如果每个人都修复小的性能问题，我们将无法跟上功能开发的速度。
- en: These micro-optimizations introduce specialized solutions into our code, and
    they're not exactly easy reading for other developers. On the other hand, if we
    let these minor inefficiencies go, we will manage to keep our code cleaner and
    thus easier to work with. Where possible, trade off optimized performance for
    better code quality. This improves our ability to scale from a number of perspectives.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些微优化将特定的解决方案引入我们的代码中，对其他开发者来说并不是很容易阅读。另一方面，如果我们对这些微小的低效之处视而不见，我们就能保持代码的清洁，从而使其更易于处理。在可能的情况下，用更好的代码质量换取优化的性能。这从多个方面提高了我们扩展的能力。
- en: Configurability for performance
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能的可配置性
- en: 'It''s nice to have generic components where nearly every aspect is configurable.
    However, this approach to component design comes at a performance cost. It''s
    not noticeable at first, when there are few components, but as our software scales
    in feature count, the number of components grows, and so does the number of configuration
    options. Depending on the size of each component (its complexity, number of configuration
    options, and so forth) the potential for performance degradation increases exponentially.
    Take a look at the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有几乎每个方面都可配置的通用组件是件好事。然而，这种组件设计方法是以性能为代价的。在最开始，组件还很少时，这种代价可能不明显，但随着我们软件在功能上的扩展，组件的数量增加，配置选项的数量也随之增加。根据每个组件的大小（其复杂性、配置选项的数量等）性能退化的潜力呈指数增长。看看下面的图表：
- en: '![Configurability for performance](img/4369_01_11.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Configurability for performance](img/4369_01_11.jpg)'
- en: The component on the left has twice as many configuration options as the component
    on the right. It's also twice as difficult to use and maintain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的组件的配置选项是右边组件的两倍。它也更难使用和维护。
- en: We can keep our configuration options around as long as there're no performance
    issues affecting our users. Just keep in mind that we may have to remove certain
    options in an effort to remove performance bottlenecks. It's unlikely that configurability
    is going to be our main source of performance issues. It's also easy to get carried
    away as we scale and add features. We'll find, retrospectively, that we created
    configuration options at design time that we thought would be helpful, but turned
    out to be nothing but overhead. Trade off configurability for performance when
    there's no tangible benefit to having the configuration option.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只要没有性能问题影响到我们的用户，我们可以保留我们的配置选项。只需记住，为了消除性能瓶颈，我们可能不得不移除某些选项。配置的可变性不太可能成为我们性能问题的主要来源。随着我们的扩展和添加新特性，我们很容易过分追求。我们会在事后的回顾中意识到，在设计时我们创造了我们认为会有帮助的配置选项，但最终成了负担。如果没有实际的配置选项好处，就把可配置性换成性能。
- en: Performance for substitutability
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代性的性能
- en: A related problem to that of configurability is substitutability. Our user interface
    performs well, but as our user base grows and more features are added, we discover
    that certain components cannot be easily substituted with another. This can be
    a developmental problem, where we want to design a new component to replace something
    pre-existing. Or perhaps we need to substitute components at runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与配置的可变性相关的问题就是替代性。我们的用户界面表现良好，但随着用户基础的增长和更多特性的添加，我们会发现某些组件不能轻易地被其他组件替代。这可能是发展问题，我们希望设计一个新的组件来替换预先存在的某个组件。或者也许我们需要在运行时替换组件。
- en: Our ability to substitute components lies mostly with the component communication
    model. If the new component is able to send/receive messages/events the same as
    the existing component, then it's a fairly straightforward substitution. However,
    not all aspects of our software are substitutable. In the interest of performance,
    there may not even be a component to replace.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们替换组件的能力主要取决于组件通信模型。如果新的组件能够像现有的组件一样发送/接收消息/事件，那么它就是一个相对直接的替代。然而，我们软件的许多方面并不是可替代的。为了性能，可能甚至没有可替换的组件。
- en: As we scale, we may need to re-factor larger components into smaller components
    that are replaceable. By doing so, we're introducing a new level of indirection,
    and a performance hit. Trade off minor performance penalties to gain substitutability
    that aids in other aspects of scaling our architecture.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的扩展，我们可能需要将更大的组件重构为更小、可替换的组件。这样做，我们引入了新的间接级别，以及性能损失。权衡小的性能损失，以获得有助于我们架构扩展的其他方面的可替代性。
- en: Ease of development for addressability
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址可寻性的开发便利性
- en: Assigning addressable URIs to resources in our application certainly makes implementing
    features more difficult. Do we actually need URIs for every resource exposed by
    our application? Probably not. For the sake of consistency though, it would make
    sense to have URIs for almost every resource. If we don't have a router and URI
    generation scheme that's consistent and easy to follow, we're more likely to skip
    implementing URIs for certain resources.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中为资源分配可寻址的URI确实使实现功能变得更加困难。我们实际上需要为应用程序暴露的每个资源都分配URI吗？可能不是。然而，为了保持一致性，几乎为每个资源分配URI是有意义的。如果我们没有一个一致且易于遵循的路由和URI生成方案，我们更有可能跳过为某些资源实现URI。
- en: It's almost always better to have the added burden of assigning URIs to every
    resource in our application than to skip out on URIs. Or worse still, not supporting
    addressable resources at all. URIs make our application behave like the rest of
    the Web; the training ground for all our users. For example, perhaps URI generation
    and routes are a constant for anything in our application—a trade-off that cannot
    happen. Trade off ease of development for addressability in almost every case.
    The ease of development problem with regard to URIs can be tackled in more depth
    as the software matures.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是比省略URI更好，为应用中的每个资源分配URI，更糟糕的是，根本不支持可寻址资源。URI使我们的应用表现得像网络上的其他应用；所有用户的大本营。例如，也许URI生成和路由是我们应用中任何事物的常数——一个不可能发生的权衡。在几乎所有情况下，权衡开发便捷性与可寻址性。关于URI的开发便捷性问题可以在软件成熟时更深入地解决。
- en: Maintainability for performance
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护性对性能的影响
- en: The ease with which features are developed in our software boils down to the
    development team and it's scaling influencers. For example, we could face pressure
    to hire entry-level developers for budgetary reasons. How well this approach scales
    depends on our code. When we're concerned with performance, we're likely to introduce
    all kinds of intimidating code that relatively inexperienced developers will have
    trouble swallowing. Obviously, this impedes the ease of developing new features,
    and if it's difficult, it takes longer. This obviously does not scale with respect
    to customer demand.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中功能开发的便捷性归根结底是开发团队及其扩展影响因素。例如，我们可能面临因预算原因招聘初级开发人员的压力。这种方法扩展的好坏取决于我们的代码。当我们关注性能时，我们可能会引入各种令人望而生畏的代码，相对缺乏经验的开发者将难以接受。显然，这阻碍了新功能开发的便捷性，如果困难，耗时更长。这显然不符合客户需求。
- en: Developers don't always have to struggle with understanding the unorthodox approaches
    we've taken to tackle performance bottlenecks in specific areas of the code. We
    can certainly help the situation by writing quality code that's understandable.
    Maybe even documentation. But we won't get all of this for free; if we're to support
    the team as a whole as it scales, we need to pay the productivity penalty in the
    short term for having to coach and mentor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者不必总是为理解我们为解决代码特定区域的性能瓶颈所采取的非正统方法而挣扎。我们当然可以通过编写可理解的优质代码来帮助解决这个问题。也许甚至是文档。但我们不会不劳而获；如果我们想要支持团队整体在扩展过程中的发展，我们需要在短期内为培训和指导付出生产力代价。
- en: Trade off ease of development for performance in critical code paths that are
    heavily utilized and not modified often. We can't always escape the ugliness required
    for performance purposes, but if it's well-hidden, we'll gain the benefit of the
    more common code being comprehensible and self-explanatory. For example, low-level
    JavaScript libraries perform well and have a cohesive API that's easy to use.
    But if you look at some of the underlying code, it isn't pretty. That's our gain—having
    someone else maintain code that's ugly for performance reasons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键的、经常使用且不经常修改的代码路径上，权衡开发便捷性与性能。我们无法总是逃避性能所需的可憎之处，但如果隐藏得当，我们将会因为更常见的代码易于理解和自解释而受益。例如，低级JavaScript库表现良好，具有易于使用的连贯API。但你如果看看一些底层代码，它们并不美观。那是我们收获——让其他人维护因性能原因而丑陋的代码。
- en: '![Maintainability for performance](img/4369_01_12.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![维护性对性能](img/4369_01_12.jpg)'
- en: Our components on the left follow coding styles that are consistent and easy
    to read; they all utilize the high-performance library on the right, giving our
    application performance while isolating optimized code that's difficult to read
    and understand.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的我们的组件遵循一致且易读的编码风格；它们都使用右侧的高性能库，从而在隔离难以阅读和理解的优化代码的同时，为我们的应用提供性能。
- en: Less features for maintainability
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了维护性而减少功能
- en: When all else fails, we need to take a step back and look holistically at the
    featureset of our application. Can our architecture support them all? Is there
    a better alternative? Scrapping an architecture that we've sunk many hours into
    almost never makes sense—but it does happen. The majority of the time, however,
    we'll be asked to introduce a challenging set of features that violate one or
    more of our architectural constants.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他方法都失败时，我们需要退一步，全面审视我们应用的功能集。我们的架构能支持它们全部吗？有更好的替代方案吗？放弃我们投入了无数小时的架构几乎是没有意义的——但这种情况确实会发生。然而，大多数时候，我们会被要求引入一组具有挑战性的特性，这些特性违反了我们的一项或多项架构常数。
- en: When that happens, we're disrupting stable features that already exist, or we're
    introducing something of poor quality into the application. Neither case is good,
    and it's worth the time, the headache, and the cursing to work with the stakeholders
    to figure out what has to go.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，我们正在破坏已经存在的稳定特性，或者我们在应用程序中引入了质量较差的东西。这两种情况都不好，而且与利益相关者合作找出必须去掉的内容是值得的，即使这会花费时间、让人头痛和咒骂。
- en: If we've taken the time to figure out our architecture by making trade-offs,
    we should have a sound argument for why our software can't support hundreds of
    features.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们花时间通过做出取舍来确定我们的架构，我们应该有一个站得住脚的理由，说明为什么我们的软件不能支持数百个特性。
- en: '![Less features for maintainability](img/4369_01_13.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![为了可维护性减少功能](img/4369_01_13.jpg)'
- en: When an architecture is full, we can't continue to scale. The key is understanding
    where that breaking threshold lies, so we can better understand and communicate
    it to stakeholders.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个架构达到极限时，我们无法继续扩展。关键是要理解那个临界点在哪里，这样我们才能更好地理解和与利益相关者沟通它。
- en: Leveraging frameworks
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用框架
- en: Frameworks exist to help us implement our architecture using a cohesive set
    of patterns. There's a lot of variety out there, and choosing which framework
    is a combination of personal taste, and fitness based on our design. For example,
    one JavaScript application framework will do a lot for us out-of-the-box, while
    another has even more features, but a lot of them we don't need.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的存在是为了帮助我们使用一套连贯的模式来实现我们的架构。市面上有许多不同的框架，选择哪个框架取决于个人喜好和我们的设计需求。例如，某个JavaScript应用框架提供了大量的开箱即用功能，而另一个框架虽然功能更多，但我们可能并不需要其中大部分。
- en: JavaScript application frameworks vary in size and sophistication. Some come
    with batteries included, and some tend toward mechanism over policy. None of these
    frameworks were specifically designed for our application. Any purported ability
    of a framework needs to be taken with a grain of salt. The features advertised
    by frameworks are applied to a general case, and a simple one at that. Applied
    in the context of our architecture is something else entirely.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用框架在大小和复杂性上各不相同。一些框架附带了完整的工具，而一些更倾向于机制而非政策。这些框架没有一个是为我们特定的应用而设计的。任何框架声称的能力都需要打折扣。框架宣传的功能适用于一般情况，而且非常简单。将其应用于我们架构的上下文是完全不同的。
- en: That being said, we can certainly use a given framework of our liking as input
    to the design process. If we really like the tool, and our team has experience
    using it, we can let it influence our design decisions. Just as long as we understand
    that the framework does not automatically respond to scaling influencers—that
    part is up to us.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 话说回来，我们当然可以使用我们喜欢的某个框架作为设计过程的输入。如果我们真的很喜欢这个工具，而且我们的团队有使用它的经验，我们可以让它影响我们的设计决策。只要我们明白框架不会自动响应扩展影响因素——这部分取决于我们。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's worth the time investigating the framework to use for our project because
    choosing the wrong framework is a costly mistake. The realization that we should
    have gone with something else usually comes after we've implemented lots of functionality.
    The end result is lots of re-writing, re-planning, re-training, and re-documenting.
    Not to mention the time lost on the first implementation. Choose your frameworks
    wisely, and be cautious about being framework-coupling.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间研究我们项目要使用的框架是值得的，因为选择错误的框架是一个代价高昂的错误。我们通常在实现了许多功能之后才意识到我们应该选择其他方案。最终结果是大量的重写、重规划、重培训和重文档化。更不用说第一次实现时浪费的时间。明智地选择你的框架，并警惕框架耦合。
- en: Frameworks versus libraries
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架与库的比较
- en: Why use a mash-up of smaller libraries when there's a monolithic framework out
    there with everything that we need? Libraries are our tools, and if they fulfill
    a need in our architecture, by all means use them. Some developers shy away from
    low-level tools because of the dependency-chaos that ensues. In practice, this
    happens anyway, even if we're leveraging an all-encompassing framework.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然有一个拥有我们所需一切的单体框架，为什么还要使用小型库的混合呢？库是我们的工具，如果它们满足我们架构的需求，那么当然可以使用它们。一些开发者因为低级工具带来的依赖性混乱而避开低级工具。实际上，即使我们利用的是涵盖一切的框架，这种情况也会发生。
- en: At the end of the day, the distinction between frameworks and libraries doesn't
    really matter to us. Creating a third-party dependency nightmare doesn't scale
    well. Neither does sticking with one tool exclusively and maintaining a lot of
    code ourselves. It's about finding the right fit between depending heavily on
    other projects and reinventing the wheel ourselves.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，框架和库之间的区别对我们来说并不重要。创建一个第三方依赖噩梦不会很好地扩展。同样，独家使用一个工具并维护大量我们自己编写的代码也不会扩展得好。关键在于找到在依赖其他项目和自己重新发明轮子之间合适的平衡点。
- en: Implementing patterns consistently
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致地实现模式
- en: The tools we use to help implement our architecture do so by exposing patterns
    common throughout JavaScript applications. And they do so consistently. As our
    application scales in size due to a growing featureset, we can apply the same
    framework components over and over. Frameworks also promote consistency in the
    patterns we implement ourselves. If we look at the internals of any framework,
    we will see that it has its own generic components; these are extended to provide
    us with usable components.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来帮助实现架构的工具，通过暴露出JavaScript应用程序中常见的模式来实现这一点。并且它们是一致地这样做。由于不断增加的功能集，我们的应用程序规模也在增长，我们可以一次又一次地使用相同的框架组件。框架还促进了我们自己实现的一致性模式。如果我们查看任何框架的内部实现，我们都会看到它有自己的通用组件；这些组件被扩展来为我们提供可用的组件。
- en: Performance is built in
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能是内置的
- en: Open source frameworks have the most developers looking at the code, and the
    most projects using the framework in production. They get lots of feedback from
    the community of users, and these include performance enhancements. Third-party
    tools are the right place to focus on performance, because they're likely the
    most utilized code in a given application. Leaving all performance outcomes up
    to browser vendors and JavaScript libraries isn't smart. Leveraging the performance
    behind components we use all the time is smart.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 开源框架拥有最多的开发者查看代码，以及最多的项目在生产中使用该框架。它们从用户社区获得大量反馈，包括性能改进。第三方工具有正确的关注点，因为它们很可能是给定应用程序中使用最多的代码。将所有的性能结果都留给浏览器供应商和JavaScript库是不明智的。利用我们经常使用的组件背后的性能是明智的。
- en: Leverage community wisdom
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用社区智慧
- en: Successful JavaScript frameworks have strong communities surrounding them. This
    is more powerful than having robust documentation because we can ask questions
    as they arise. Odds are, someone else is trying to do something similar in their
    project, using the same framework as us. Open source projects are like a knowledge
    engine; even if the exact answer we need isn't out there, we can often find enough
    through the wisdom of the community to figure it out ourselves.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的JavaScript框架周围都有强大的社区支持。这比拥有健壮的文档更有效，因为我们可以随时提出问题。很可能，在我们自己的项目中，有人正在尝试做类似的事情，并且使用的是与我们相同的框架。开源项目就像一个知识引擎；即使我们需要的确切答案还没有出来，我们通常可以通过社区的智慧找到足够的信息来自行解决问题。
- en: Frameworks don't scale out-of-the-box
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架无法开箱即扩展
- en: Saying one framework scales better than another isn't justified. Writing a **TODO**
    application as a benchmark for how well the framework scales is hardly useful.
    We write TODO applications to get a feel for the framework, and how it compares
    to others. If we're unsure about which framework fits our style, a TODO application
    is a good start.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个框架比另一个框架扩展得更好是没有根据的。将**TODO**应用程序作为衡量框架扩展能力的一个基准几乎没有用处。我们编写TODO应用程序是为了熟悉框架，以及它与其他框架的比较。如果我们不确定哪个框架符合我们的风格，TODO应用程序是一个不错的开始。
- en: Our goal is to implement something that scales well in response to influencers.
    These are unique and unknown upfront. The best we can do is make predictions about
    what scaling influencers we'll likely be hit with in the future. Based on these
    likely influencers, and the nature of the application we're building, some frameworks
    are better candidates than others. Frameworks help us scale, but they don't scale
    for us.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是实现能够响应影响因素而良好扩展的东西。这些因素是独特且事先未知的。我们所能做的是预测未来可能遭遇的缩放影响因素。基于这些可能的影响因素以及我们正在构建的应用程序的性质，有些框架比其他框架更适合。框架帮助我们扩展，但它们不会为我们扩展。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Scaling a JavaScript application isn't the same as scaling other types of applications.
    Although we can use JavaScript to create large-scale backend services, our concern
    is with scaling the applications our users interact with in the browser. And there're
    a number of influencers that guide our decision making process on producing an
    architecture that scales.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展JavaScript应用程序并不像扩展其他类型的应用程序那样。尽管我们可以使用JavaScript创建大规模的后端服务，但我们的关注点是在浏览器中与用户交互的应用程序的扩展。在产生一个可扩展架构的决策过程中，有一些指导我们决策过程的影响因素。
- en: We reviewed some of these influencers, and how they flow in a top-down fashion,
    creating challenges unique to frontend JavaScript development. We examined the
    effect of more users, more features, and more developers; we can see that there's
    a lot to think about. While the browser is becoming a powerful platform, onto
    which we're delivering our applications, it still has constraints not found on
    other platforms.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了其中一些影响因素，以及它们自上而下流动的方式，为前端JavaScript开发创造了独特的挑战。我们研究了用户更多、功能更多、开发者更多所带来的影响；我们可以看到有很多需要考虑的东西。虽然浏览器正在成为一个强大的平台，我们将我们的应用程序交付给它，但它仍然具有其他平台不具备的限制。
- en: Designing and implementing a scalable JavaScript application requires having
    an architecture. What the software must ultimately do is just one input to that
    design. The scaling influencers are key as well. From there, we address different
    perspectives of the architecture under consideration. Things such as component
    composition and responsiveness come into play when we talk about scale. These
    are observable aspects of our architecture that are impacted by influencers of
    scale.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和实现一个可扩展的JavaScript应用程序需要有一个架构。软件最终必须完成的事情只是设计的一个输入。缩放影响因素也很关键。从那里开始，我们解决考虑中的架构的不同视角。诸如组件组合和响应性等事情在我们的讨论中涉及到扩展时就会发挥作用。这些都是我们架构受到缩放影响因素影响的可观察方面。
- en: As these scaling factors change over time, we use architectural perspectives
    as tools to modify our design, or the product to align with scaling challenges.
    The focus of the next chapter will be to look into these scaling influencers in
    more detail. Understanding them and putting together a checklist will empower
    us to implement a JavaScript that scales in response to these events.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些缩放因子的随时间变化，我们使用架构视角作为工具来修改我们的设计，或产品以适应缩放挑战。下一章的重点将放在更详细地研究这些缩放影响因素。理解它们并制定出一个检查清单，将使我们能够实施一个能够响应这些事件的JavaScript。
