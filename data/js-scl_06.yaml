- en: Chapter 6. User Preferences and Defaults
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。用户偏好和默认值
- en: Any sufficiently large JavaScript application needs to configure its components.
    The scope and nature of our component configuration varies on an application-by-application
    basis. There are a number of scaling factors that need to be considered when configuring
    our components, and we'll address these throughout the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何足够大的JavaScript应用程序都需要配置其组件。我们组件配置的范围和性质根据应用程序的不同而有所变化。在配置组件时，需要考虑许多扩展因素，我们将在整章中讨论这些因素。
- en: We'll start of by identifying the types of preferences we'll have to deal with,
    and the remainder of the chapter will walk through specific scaling issues concerning
    these preferences and how to work around them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先确定我们必须处理的偏好类型，然后本章的其余部分将讨论这些偏好相关的具体扩展问题以及如何解决它们。
- en: Preference types
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏好类型
- en: There're three main types of preferences we're concerned with when designing
    large-scale JavaScript architectures. These are locales, behavior, and appearance.
    In this section we'll provide a definition for each of the preference categories.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计大型JavaScript架构时，关心的三种主要偏好类型是：地区、行为和外观。在本节中，我们将为每个偏好类别提供定义。
- en: Locales
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地区
- en: Applications today can't support just a single locale, if they're going to succeed
    on a global scale. Because of globalization and the internet, demand for applications
    created in another part of the world is the new norm. Therefore, we have to design
    our JavaScript architectures in a way that accommodates many locales, seamlessly.
    Users in one locale should be able to use our application with the same ease and
    confidence as users in any other locale.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的应用程序不能只支持一个单一的地区，如果它们要在全球范围内取得成功的话。由于全球化以及互联网，来自世界其他地区的应用程序需求已成为新的常态。因此，我们必须以一种能够无缝容纳许多地区的方式设计我们的JavaScript架构。一个地区的用户应该能够像其他任何地区的用户一样轻松、自信地使用我们的应用程序。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The process of enabling components to use any locale is called **internationalization**.
    Then, the process of creating locale-specific data for our application is called
    **localization**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使组件能够使用任何地区的过程称为**国际化**。然后，为我们的应用程序创建特定地区的数据的过程称为**本地化**。
- en: What makes internationalization/localization so difficult is that it touches
    every visual aspect of the user interface. This can amount to quite a lot, despite
    the fact that there are many components that don't care about locales—like controllers
    or collections. For example, any string labels that would otherwise be hard-coded
    in a template somewhere, now need to pass through a locale-aware translation mechanism.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化/本地化之所以困难，是因为它触及了用户界面的每一个视觉方面。尽管有很多组件不关心地区（如控制器或集合），但这仍然可能相当多。例如，任何原本在模板某处硬编码的字符串标签，现在需要通过一个地区感知翻译机制。
- en: The language translations are hard enough on their own. But locale data consists
    of anything and everything that's pertinent to a given culture that's using our
    software. For example, the formats used for date/time or currency values. These
    are just the most common and straightforward elements. Things can vary right down
    to how quantities are measured, or right up to the layout of the entire page.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 语言翻译本身就已经够困难了。但是地区数据包括与我们软件中使用的任何一种文化相关的任何和一切内容。例如，用于日期/时间或货币值的形式。这些只是最常见和最直接的元素。事物可以一直变化到如何度量数量，或者一直到整个页面的布局。
- en: Behavior
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为
- en: Most behavioral aspects of our components reside in the code, and are unchanging.
    Behavioral changes that happen in response to different preferences are subtle,
    yet important. When there're many interacting components, there's bound to be
    an incompatible combination that causes issues.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件的大部分行为都存在于代码中，并且是不变的。由于不同偏好而发生的行为变化是微妙而又重要的。当有多个互动组件时，必然会有一种不兼容的组合会引起问题。
- en: For example, a function found within the implementation of our component might
    get a value it uses to compute something from a configuration value. This could
    be a user preference, or it could be something we've put in place for the sake
    of maintainability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们组件的实现中可能有一个函数，它从一个配置值中获取一个值，用这个值来计算某物。这可能是一个用户偏好，或者可能是我们为了可维护性而设置的东西。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout the remainder of the chapter, we'll refer to individual configuration
    values as preferences. We'll refer to the aggregate effect of all preferences
    within a given component as configuration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将把个别配置值称为偏好。我们将把给定组件内所有偏好的聚合效果称为配置。
- en: Behavioral preferences can have varied effects on what the user sees. A simple
    example would be turning the component off, or, disabling it. This preference
    would result in the component no longer rendering in the UI. Another preference
    would determine how many elements are displayed. A common example here would be
    a user telling the application how many search results they want to see per page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 行为偏好可能会对用户看到的内容产生不同的影响。一个简单的例子就是关闭组件，或者禁用它。这个偏好会导致组件在UI中不再渲染。另一个偏好将决定显示多少元素。一个常见的例子是用户告诉应用程序他们希望在每页看到多少搜索结果。
- en: These types of preferences don't always map directly to the end user. That is,
    a component may have certain preferences that aren't directly exposed to the user.
    It could be there for the sole purpose of developer flexibility, to reduce the
    amount of code we write. Configurable components take many forms, and it's from
    this perspective that we need to make sure we address them accordingly, to help
    scale our software.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的偏好并不总是直接映射到最终用户。也就是说，组件可能有一些不是直接暴露给用户的偏好。这可能是为了提高开发人员的灵活性，减少我们编写的代码量。可配置的组件有多种形式，从这种角度来看，我们需要确保相应地处理它们，以帮助我们的软件实现扩展。
- en: It's not just the frontend components we need to think about either, as a given
    preference may change backend behavior. This could be as simple as a query parameter
    preference, or another preference that results in a different API endpoint being
    used. All these seemingly innocuous preferences add up to far-reaching consequences,
    across the application, possibly impacting other users of the system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的不仅仅是前端组件，因为给定偏好可能会改变后端行为。这可能简单到一个查询参数偏好，或者另一个偏好导致使用不同的API端点。所有这些看似无害的偏好加起来会产生深远的影响，跨越整个应用程序，可能会影响系统中的其他用户。
- en: Appearance
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外观
- en: If a modern JavaScript application is going to scale across audience demographics,
    its appearance needs to be configurable. This requirement can range anywhere from
    a configurable logo, to interchangeable themes that have the potential to drastically
    alter the look and feel of the UI.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个现代JavaScript应用程序要跨越受众人口统计数据进行扩展，它的外观需要是可配置的。这一要求可以从可配置的标志，到具有潜在能力彻底改变UI外观和感觉的可互换主题不等。
- en: Generally speaking, changes in appearance are centered around CSS properties
    like fonts, colors, widths, border radiuses, and so on. While it's true that the
    majority of the CSS implementation isn't touched by the majority of JavaScript
    developers, we still need to be conscious of theme boundaries.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，外观变化主要围绕CSS属性，如字体、颜色、宽度、边框半径等。虽然确实大多数CSS实现并未被大多数JavaScript开发者触及，但我们仍然需要关注主题边界。
- en: For instance, if we're flexible with our appearance and how it's configured,
    we may let our users select their own theme at runtime. So we'll need to implement
    a theme-switching mechanism with which the user interacts. Further, themed UIs
    mean that the preference will need to be stored and loaded somewhere.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们对外观以及如何配置它持灵活态度，我们可能会让用户在运行时选择自己的主题。因此，我们需要实现一个用户可以与之交互的主题切换机制。此外，主题化的用户界面意味着偏好需要被存储和加载。
- en: So that's coarse-grained themes—what about fine-grained appearance configuration?
    The former is more prevalent however, configuring specific styles of individual
    components isn't out of the question. The appearance granularity level coincides
    with other scaling influencers, like where our software is deployed, and the capabilities
    of our configuration APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这就是粗粒度主题——那细粒度外观配置又是怎样的呢？然而，粗粒度更为常见，对特定组件风格的配置并非不可能。外观粒度级别与其他扩展影响因素一致，比如我们的软件部署在哪里，以及我们配置API的能力如何。
- en: Supporting locales
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持本地化
- en: Having internationalization support throughout all our components is a good
    idea. In fact, there're a lot of JavaScript tools out there to aid with this task.
    Some are more stand-alone, and some are more tailored for specific frameworks.
    Using these tools is easy, but there's a lot more to localization that needs to
    be taken into consideration, especially in a scaling context.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有对我们所有组件的国际化支持是一个好主意。实际上，有很多JavaScript工具可以帮助我们完成这项任务。有些工具比较独立，而有些则更针对特定的框架。使用这些工具很简单，但还有很多其他与本地化相关的工作需要考虑，特别是在扩展的情况下。
- en: Deciding on locales to support
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定支持哪些区域
- en: Once we have software with internationalization support that's in production
    use, the next step is to decide which locales to support. When we go through the
    first step of ensuring that all our components are internationalized, we do so
    with just one locale—the default locale. And that's fine at first, it may be years
    before our first secondary locale support requirement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有带有国际化支持并在生产环境中使用的软件，下一步就是决定支持哪些区域。当我们确保所有组件都进行国际化时，我们只支持一个区域——默认区域。一开始这样做是可以的，可能需要数年才能出现对第二个辅助区域支持的需求。
- en: This is generally what happens with newer software projects. We know that internationalization
    should be up there on our list of priorities, but it's easy to get sidetracked
    with everything else going on. The leading argument in favor of not spending effort
    on locale support is that it's not needed right away. The argument against this
    mindset is that internationalization is exceedingly difficult to implement after-the-fact,
    as our components grow. So it's yet another scale-related trade off to make. Do
    we want our application to scale across cultures, or is immediate time-to-market
    more important?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是新软件项目的情况。我们知道国际化应该是我们优先级列表上的重要事项，但在其他所有事情中很容易分心。不花费精力支持区域的主要论点是它目前是不需要的。反对这种心态的观点是，随着组件的增长，事后实施国际化是非常困难的。所以这又是需要考虑的与扩展相关的权衡。我们希望我们的应用程序能够跨文化扩展，还是认为立即上市更重要？
- en: Exceptional cases aside, we'll assume that internationalization is a must-have—we
    need to prioritize which locales we'll support, versus those that can wait. For
    example, it's a bad idea to aim for mass locale support before it's actually required.
    Locales occupy physical space, and someone needs to maintain these locales. So
    without a customer to pay the cost of this added scaling complexity, it's not
    worthwhile.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特殊情况外，我们假设国际化是必不可少的——我们需要确定我们首先要支持哪些区域，以及哪些可以等待。例如，在实际需要之前就寻求大规模区域支持是一个糟糕的主意。区域占用的物理空间，需要有人来维护这些区域。所以如果没有客户来承担这种增加的扩展复杂性的成本，这是不值得的。
- en: Instead, the chosen locales should be based solely on customer demand. If we
    have hundreds of people looking for support in one locale, with less than a dozen
    people asking about another, the priority should be obvious. It can be helpful
    if we prioritize locale support the same as we would feature support.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，所选的本地化区域应完全基于客户需求。如果我们有一个地方有数百人寻求支持，而只有不到十几个人询问另一个地方，优先级就很明显了。如果我们像优先支持功能一样优先支持区域，这将对我们有帮助。
- en: Maintaining locales
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护区域
- en: First and foremost, if we support a given locale, we'll need to translate the
    string messages that are displayed throughout the UI. Some of these are statically
    coded in template files while other strings are found in our JavaScript modules.
    If only it were a matter of locating these strings, and translating them once.
    But rarely do strings stay the same forever—there are often subtle tweaks to be
    had. Also, as our software grows and more components are added, so too are strings
    to be translated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们支持某个区域，我们将需要翻译在UI中显示的所有字符消息。其中一些是在模板文件中静态编码的，而其他字符串在我们的JavaScript模块中找到。如果只是找到这些字符串，并一次性翻译它们那该多好。但字符串很少会永远保持不变——经常会有微小的调整。此外，随着我们的软件增长和更多组件的添加，需要翻译的字符串也会增加。
- en: The scaling factor for just string translations alone is the number of locales
    we support—which is why we need to be conscientiously supporting only a limited
    number of locales while we can get away with it. The complexity doesn't end there.
    For example, some message strings are straightforward to map from source language
    to target language. Things like grammar inflection—how words take on different
    meanings based modifications—aren't so straightforward. In fact, these usages
    sometimes require specialized use of the internationalization library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仅字符串翻译的缩放因素就是我们支持的区域设置数量——这就是为什么我们需要谨慎地只支持有限数量的区域设置，只要我们能够做到。复杂性并没有就此结束。例如，一些消息字符串可以从源语言映射到目标语言。像语法屈折这样的东西——单词如何根据修改承担不同的意义——并不是那么直接。实际上，这些用例有时需要国际化的专用库。
- en: Other localizable data, like date/time formats, don't require much maintenance.
    There're one or two formats used throughout the application for a given locale.
    For formats like these, customers will likely be happy with the standard format
    used for their culture. Luckily, there's **Common Locale Data Repository** (**CLDR**)
    data we can use in our projects—a downloadable repository of common locale data.
    This is a good starting point, because this data is good enough most of the time,
    and is easy to override upon request.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可本地化的数据，如日期/时间格式，不需要太多维护。对于给定区域设置，应用程序中通常使用一两个格式。对于这些格式，客户可能会对他们文化中使用的标准格式感到满意。幸运的是，我们可以在我们的项目中使用**通用区域数据仓库**（**CLDR**）数据——一个可下载的通用区域数据仓库。这是一个良好的起点，因为大多数时候这些数据都是足够的，并且根据请求容易覆盖。
- en: Setting the locale
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置区域设置
- en: Once we have our internationalization library in place, and a couple of locales,
    we can start testing how our application behaves from the perspective of different
    cultures. There are a number of items to consider for this behavior. For example,
    we need to facilitate the locale selection for the user and we need to keep track
    of that selection.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了国际化库，并且有几个区域设置，我们就可以开始测试我们的应用程序在不同文化角度下的行为。对于这种行为，有许多需要考虑的项目。例如，我们需要为用户启用区域设置，并且我们需要跟踪这个选择。
- en: Choosing locales
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择区域设置
- en: There are two common approaches to locale selection in JavaScript applications.
    The first approach is using the `accept-language` request header. The second approach
    is a selector widget on a user settings page.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 应用程序中选择区域设置有两种常见方法。第一种方法是使用 `accept-language` 请求头。第二种方法是在用户设置页面上一个选择器小部件。
- en: The nice thing about the `accept-language` approach is that there's no user
    input involved. Our application is sent to the user's browser preference for language,
    and from there, we can set the locale. The challenge is that this approach can
    be too restrictive from a usability perspective, and from an implementation perspective.
    For example, users may not have control over their browser language preferences,
    or the browser may not have preferences for locales our application supports.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept-language` 方法的优点在于无需涉及用户输入。我们的应用程序会根据用户的浏览器语言偏好发送，从而我们可以设置区域设置。这种方法的挑战在于，从可用性的角度来看，它可能过于限制性，从实现角度来看也是如此。例如，用户可能无法控制他们的浏览器语言偏好，或者浏览器可能没有支持我们应用程序的区域设置偏好。'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another technical challenge with the `accept-language` request header approach
    is that there's no easy means to pass request headers from the browser to the
    JavaScript code—which is kind of insane since there're both in the browser! For
    example, if our JavaScript code needs to know the locale preference so it can
    load the appropriate locale data, it'll need access to the `accept-language` header.
    To do this, we need backend hacks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `accept-language` 请求头方法遇到的另一个技术挑战是，没有简单的方法将请求头从浏览器传递到 JavaScript 代码——这有点疯狂，因为它们都在浏览器中！例如，如果我们的
    JavaScript 代码需要知道区域设置偏好，以便它可以加载适当的区域设置数据，它将需要访问 `accept-language` 头部。为此，我们需要后端技巧。
- en: The more flexible approach is to present the user with a locale selector widget,
    and from there, it's made explicit which locale the user would like activated.
    However, we'll need to figure out a way to store this locale selection so that
    the user doesn't have to repeatedly select their locale.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 更加灵活的方法是向用户展示一个区域设置选择器小部件，然后从中明确用户想要激活哪个区域设置。然而，我们需要找到一种存储这个区域设置选择的方法，这样用户就不必重复选择他们的区域设置。
- en: Storing locale preferences
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储区域设置偏好
- en: The locale preference, once selected by the user, can be stored as a cookie
    value. The next time the application loads in the browser, we'll have the locale
    preference ready to go. Then we can mark the selector with the appropriate selection,
    as well as load the relevant locale data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择地区偏好，可以作为cookie值存储。下次应用程序在浏览器中加载时，我们将准备好地区偏好。然后我们可以标记选择器为适当的选择，以及加载相关地区数据。
- en: The problem with storing the locale preference in a cookie is that if the user
    moves to another browser, the same selection process will need to be repeated.
    This can be a real problem these days as users are more mobile than ever—changes
    made on one device should be reflected anywhere the application is used. And that's
    just not possible with cookies.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将地区偏好存储在cookie中的问题是，如果用户转到另一个浏览器，将需要重复相同的选择过程。这对于当今用户比以往任何时候都更加移动是一个真正的问题——在一个设备上所做的更改应该在任何应用程序被使用的地方反映出来。而这是通过cookie办不到的。
- en: If we use a backend API to store the locale preference, it'll be available everywhere
    for the user. The next challenge is loading the relevant locale data so that it's
    available for the rest of our components to use. Generally, we want this data
    ready before we start rendering data, so it's one of the first requests we'll
    make to the backend. Sometimes, all locales are served together, as one resource.
    This can be a problem if we support lots of locales, because of the up-front cost
    to load it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用后端API存储地区偏好，它将无处不在对用户可用。下一个挑战是加载相关地区数据，使其可供我们其他组件使用。通常，我们希望在此开始渲染数据之前准备好这些数据，因此这是我们向后端发出的第一个请求之一。有时，所有地区都作为单一资源一起提供。如果我们支持很多地区，这可能成为问题，因为加载它需要的前期成本很高。
- en: On the other hand, once we load the locale preference, we can load only the
    immediately required locale. This will boost the initial load-time, but the trade-off
    is that it's slower to switch to a new locale. This is unlikely to happen often,
    so it's probably best to not load locale data that's never used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一旦我们加载地区偏好，我们只能加载立即需要的地区。这将提高初始加载时间，但权衡是切换到新地区较慢。这可能不会经常发生，所以最好不要加载从未使用过的地区数据。
- en: '![Storing locale preferences](img/4639_06_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![存储地区偏好](img/4639_06_01.jpg)'
- en: The JavaScript application first loads the locale preference, then uses that
    to load the local data
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用程序首先加载地区偏好，然后使用该偏好加载本地数据
- en: Locales in URIs
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在URI中使用地区
- en: In addition to storing the local preference in the backend or as a cookie value,
    locales can be encoded as part of the URI. Often, they're expressed as a two character
    code—such as `en` or `fr`—and found at the beginning of the URI. The advantage
    of using this approach is that there's no storage required for the preference.
    We'd still likely want a selector for the user to choose their preferred locale,
    but this would result in a new URI instead of a preference value being stored
    somewhere.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在后台存储本地偏好或作为cookie值外，地区还可以编码为URI的一部分。通常，它们作为两个字符代码表示，例如`en`或`fr`，并位于URI的开头。使用这种方法的优点是不需要存储偏好。我们仍然可能需要一个选择器让用户选择他们偏好的地区，但这将导致新的URI，而不是将偏好值存储在某个地方。
- en: Encoding the preferred locale in URIs like this has the same drawbacks as the
    cookie-based approach. While we can bookmark a URI, or pass a URI along to someone
    else—they'll see the same locale we do—the problem is that this isn't a permanent
    preference. Mind you, we could always store the preference and update the URI
    when the application is loaded. But this won't scale well due to the added complexities
    around routing and URI generation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样在URI中编码首选地区的方法与基于cookie的方法有相同的缺点。虽然我们可以收藏一个URI，或将一个URI传递给其他人——他们会看到我们相同的地区——问题是这并不是一个永久的偏好。请注意，我们总是可以存储偏好并在应用程序加载时更新URI。但由于路由和URI生成的额外复杂性，这种方法扩展性不佳。
- en: Generic component configuration
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用组件配置
- en: As we saw in the preceding section on locale preferences, we need to load a
    preference value, which can then be used by each of our components. Or maybe just
    one component in the case of locales, but this preference value indirectly impacts
    all components. Looking beyond locales, there're a lot of other things we'll want
    to configure in our components. This section looks at the problem from a generic
    perspective. First we need to decide on which aspects of a given component are
    configurable, and then there are the mechanics of getting those preferences into
    the components at runtime.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节关于地区偏好的内容中看到的那样，我们需要加载一个偏好值，然后我们的每个组件都可以使用这个值。或者在地区的情况下，可能只有一个组件，但这个偏好值间接影响了所有组件。除了地区之外，我们还有许多其他想要在组件中进行配置的事物。本节从通用角度来探讨这个问题。首先我们需要决定给定组件的哪些方面是可配置的，然后是如何在运行时将这些偏好值传递给组件的机制。
- en: Deciding on configuration values
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定配置值
- en: The first step with component configuration is deciding on preferences—which
    aspects of the component need to be configurable, and which aspects can stay static?
    It's far from an exact science, as more often than not, we realize later on that
    something static should have been configurable. Trial and error is the best process
    for finding configurable preferences, especially as our software is just getting
    off the ground. Too much initial configurability deliberation is a scaling bottleneck.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 组件配置的第一步是决定偏好——组件哪些方面需要配置，哪些方面可以保持静态？这远非一门精确的科学，因为往往后来我们会意识到某些静态内容应该是可配置的。试错是找到可配置偏好的最佳过程，尤其是当我们的软件刚刚起步时。过多的初始可配置性考虑是可扩展性的瓶颈。
- en: When something isn't configurable, it has the advantage of simplicity. It's
    more structural, and less of a moving part. This removes potential edge cases
    and performance issues. Up-front justification for making the value configurable
    doesn't happen all that often. As our software matures though, we'll have a better
    perspective, having put some preferences in place, and we'll have a better idea
    of what to expect.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当某事物不可配置时，它具有简单性的优势。它更加结构化，且不是活动的部件。这消除了潜在的边缘案例和性能问题。为使值可配置而进行的前期论证并不经常发生。但随着我们的软件成熟，我们将有一个更好的视角，因为我们已经设定了一些偏好，并且我们将更好地了解预期会发生什么。
- en: For instance, we'll start seeing duplication across several of our components.
    They'll be largely the same, with only subtle variations. If we keep adding new
    types of components that differ minutely from one another, we're in for scaling
    trouble. Our code base will grow to an unmanageable size, and we'll confuse developers
    because the responsibilities of a given component will be blurred.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将开始在我们的多个组件中看到重复。它们将基本相同，只有微妙的差异。如果我们继续添加彼此之间只有细微差别的新的组件类型，我们将面临可扩展性问题。我们的代码库将增长到一个无法管理的规模，并且我们会让开发者困惑，因为给定组件的责任将变得模糊。
- en: This is where we leverage configurability to achieve scale. This is done by
    introducing preferences in favor of new component types. For example, say we need
    a new view that is identical to another view that's used in several places already,
    aside from the way it handles a DOM event. Rather than implement a new view type,
    we would enhance the existing view, to accept a new function value that overrides
    the default for this event.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们利用可配置性来实现规模的地方。这是通过引入对新组件类型的偏好来实现的。例如，假设我们需要一个新的视图，它除了处理DOM事件的方式与另一个已经在多个地方使用的视图相同外，其他方面都相同。我们不是实现一个新的视图类型，而是增强现有的视图，使其能够接受一个新的函数值，用于覆盖这个事件的默认值。
- en: On the flipside, we can't just go introducing component preferences willy-nilly.
    When we do that, we replace old scaling bottlenecks with new ones. There's performance
    to take into consideration, because it takes a hit with every new configurable
    preference we add. There's the code complexity—it's not as straightforward to
    use preferences as it is static values. There's the possibility of introducing
    preferences that are inconsistent with other preferences introduced during the
    same development cycle by other developers. Finally, there's the matter of keeping
    track and documenting all the various preferences available to a given component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们不能随意引入组件偏好。当我们这样做时，我们用新的瓶颈取代了旧的瓶颈。我们需要考虑性能，因为每增加一个新的可配置偏好都会受到影响。还有代码复杂性——使用偏好并不像使用静态值那么简单。还有可能引入与其他开发者在同一开发周期内引入的其他偏好不一致的偏好。最后，还需要跟踪和文档化给定组件可用的各种偏好。
- en: Stored and hard-coded default values
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和硬编码的默认值
- en: As far as components are concerned, preferences should be treated as closely
    to regular JavaScript variables as possible. This keeps our code flexible—replacing
    a preference with a static value shouldn't have a big impact. Regular variables
    are usually declared with an initial value, and preferences should be declared
    with a default value as well. That way, if we can't get at the preference that's
    stored in the backend for some reason, the software will continue to function
    using a sane default value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就组件而言，偏好应尽可能像普通的JavaScript变量一样处理。这使得我们的代码具有灵活性——用静态值替换偏好不应该产生很大的影响。普通变量通常声明有一个初始值，偏好也应该声明有一个默认值。这样，如果由于某种原因我们无法获取存储在后台的偏好值，软件将继续使用合理的默认值运行。
- en: There should always be a fallback default value for any preference, and these
    values should be documented somewhere. Ideally the default values used serve the
    common case, so not every preference needs to be tinkered with just in order to
    use the software. If for some reason we can't access the stored configuration
    values from the backend, the hard-coded default values keep the software running,
    albeit, using a less than ideal configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何偏好，都应该有一个回退默认值，并且这些值应该在某个地方进行文档化。理想情况下，使用的默认值服务于常见情况，因此不需要为了使用软件而调整每个偏好。如果我们由于某种原因无法从后端访问存储的配置值，硬编码的默认值会让软件继续运行，尽管是使用不那么理想的配置。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Sometimes, not having access to the configuration values is a non-starter and
    the software should fail-fast instead of using the hard-coded default values.
    While the software is fully-functional using the defaults, depending on our customers
    and their deployment, this mode may be worse than the software being unavailable.
    Something to consider when deploying large-scale JavaScript applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，无法访问配置值是一个不可逾越的障碍，软件应该快速失败，而不是使用硬编码的默认值。虽然软件完全可以通过默认值正常运行，但根据我们的客户和他们部署的情况，这种模式可能比软件不可用更糟糕。这在部署大规模JavaScript应用程序时需要考虑。
- en: Default preference values make it safe to delete modified preference values
    in the backend. Think of it as a reset to the factory settings action. In other
    words, if we introduce problems into the software by adjusting preference values,
    we can just remove our stored values. If there's no need to store default values
    in the backend, then there's no risk of overriding the defaults.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认偏好值的安全性使得在后台删除修改过的偏好值变得可能。把它看作是一个恢复出厂设置的动作。换句话说，如果我们通过调整偏好值引入了软件问题，我们只需删除我们存储的值即可。如果后台不需要存储默认值，那么就没有覆盖默认值的风险。
- en: '![Stored and hard-coded default values](img/4639_06_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![存储和硬编码的默认值](img/4639_06_02.jpg)'
- en: Defaults are always there, but can easily be overridden by preference values
    from the backend
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值总是存在，但很容易被后端偏好值覆盖
- en: Backend implications
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端影响
- en: If we're storing our preference values in the backend to provide portability
    for our users, then we need some mechanism that allows us to put new value preferences
    in the configuration store, as well as retrieve our preferences. Ideally, this
    would be an API that lets us define arbitrary key-value preferences, and lets
    us retrieve all our configuration with one request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将在后台存储偏好值以提供用户的便携性，那么我们需要某种机制，使我们能够在配置存储中放入新的值偏好，以及检索我们的偏好。理想情况下，这是一个允许我们定义任意键值偏好，并且让我们用一个请求检索所有配置的API。
- en: The reason this is so valuable to frontend development is that we can define
    new preferences for our components as we develop them, without being disruptive
    to the backend team. As far as the backend API is concerned, frontend configuration
    is arbitrary—the API works the same with or without a UI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对前端开发如此宝贵，是因为我们可以在开发组件的同时为其定义新偏好，而不会打扰到后端团队。对于后端API来说，前端配置是任意的——无论是否有UI，API都能正常工作。
- en: Sometimes, this can actually be more of a headache than it's worth. What if
    there's very little variation—only a handful of configuration values required
    throughout the application? If that's the case, we might consider maintaining
    a static JSON file that serves as our frontend configuration. It's arbitrary enough
    that we can define preferences ad-hoc, and it works the same as an API, as far
    as fetching the preference values goes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这实际上可能比想象的更有麻烦。如果变化非常小——整个应用程序中只需要少量的配置值呢？如果是这样，我们可能会考虑维护一个静态的JSON文件，作为我们的前端配置。它足够任意，我们可以随时定义偏好，对于获取偏好值来说，它与API一样好用。
- en: Where this doesn't work so well is when there are user-defined preferences.
    For example, the user's preferred locale. Our application might have a default
    locale specified, until the user changes it. They're changing the preference for
    themselves, not every user in the system. This is where we need the aforementioned
    configuration API. The way it stores these values, in a database most likely,
    needs to be user-sensitive. This isn't true of every preference value though;
    some are set by the deployment operators and users can't touch these.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户定义的偏好设置不适用时，例如，用户的首选语言。我们的应用程序可能有一个默认语言，直到用户更改它。他们是在为自己更改偏好，而不是系统中的每个用户。这时我们就需要前面提到的配置API。它存储这些值的方式，很可能是数据库，需要对用户敏感。但并非所有偏好值都需要这样；有些是由部署操作员设置的，用户无法更改这些。
- en: '![Backend implications](img/4639_06_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Backend implications](img/4639_06_03.jpg)'
- en: The current user session can be used to load preferences specific to that user;
    these are different from system settings, which don't vary by user
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当前用户会话可以用来加载特定于该用户的偏好设置；这些与系统设置不同，不会因用户而异。
- en: Loading configuration values
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Loading configuration values
- en: There're two approaches to loading configuration required by the frontend. The
    first approach is to load all configuration because anything is rendered in the
    UI. This means that before the router starts to process anything, we would wait
    for the configuration to be available. This generally means waiting on a promise
    that loads the configuration data. The obvious downside here is that the initial
    load time suffers. The upside is that we have everything we need going forward—no
    more configuration requests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 加载前端所需配置有两种方法。第一种方法是加载所有配置，因为UI中会渲染任何内容。这意味着在路由开始处理任何内容之前，我们会等待配置可用。这通常意味着等待一个加载配置数据的承诺。这里的明显缺点是初始加载时间变长。优点是我们拥有了后续所需的一切——不再需要配置请求。
- en: We can use local storage in the browser to cache preference values. They seldom
    change, and this tactic has the potential to boost initial-load performance. On
    the other hand, it adds complexity—so only consider this if there're a lot of
    configuration values and the time taken to load them is noticeable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器中使用本地存储来缓存偏好值。它们很少变化，这种策略有可能提高初始加载性能。另一方面，它增加了复杂性——所以只有在配置值很多且加载它们的时间明显时才考虑这种方法。
- en: Instead of loading all our configuration up-front, preference values can be
    loaded on demand. That is, when a component is about to be instantiated, a request
    is made for its configuration. This has the appeal of being efficient, but again,
    how much configuration could there possibly be to warrant such complexity? Strive
    toward loading all application configuration up-front where possible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: instead of loading all our configuration up-front, preference values can be
    loaded on demand. That is, when a component is about to be instantiated, a request
    is made for its configuration. This has the appeal of being efficient, but again,
    how much configuration could there possibly be to warrant such complexity? Strive
    toward loading all application configuration up-front where possible.
- en: '![Loading configuration values](img/4639_06_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Loading configuration values](img/4639_06_04.jpg)'
- en: A configuration component that communicates with the backend provides an abstraction
    for any components that get or set preference values
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与后端通信的配置组件为获取或设置偏好值的任何组件提供了抽象。
- en: Configuring behavior
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置行为
- en: The behavior of our components is largely self-contained, if implemented well.
    What they expose to the outside world are preferences that make subtle adjustments
    to their behavior. This could be something that's internally-focused—such as the
    type of model that's used, or the preferred algorithm. It could be something that's
    user-facing, such as enabling components, or setting display modes. It's these
    preferences that help us scale our components to work in a variety of contexts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现得当，我们组件的行为很大程度上是自包含的。它们向外部世界暴露的是对它们行为进行微调的偏好。这可能是一些内部关注的内容——比如使用的模型类型，或首选算法。它可能是一些面向用户的内容，比如启用组件，或设置显示模式。正是这些偏好帮助我们使组件能够在各种上下文中工作。
- en: Enabling and disabling components
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和禁用组件
- en: Once our software reaches a certain critical mass, not all features will be
    relevant to all users. The simple ability to toggle components between an enabled/disabled
    state is a powerful tool. Both for us, as a software vendor, and for our customers.
    For example, we know that some features are required by certain user roles in
    our software, but they're not the common case. To better optimize for the common
    user, we may choose to disable certain advanced features that aren't used as often.
    This can clean up the layout, improve performance, and so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的软件达到一定的临界质量，不是所有功能对所有用户都相关。简单地能够在启用/禁用状态之间切换组件是一个强大的工具。对我们作为软件供应商，以及我们的客户来说都是如此。例如，我们知道某些功能是我们软件中某些用户角色所必需的，但它们并不是常见情况。为了更好地优化常见用户，我们可能会选择禁用某些不经常使用的高级功能。这可以清理布局，提高性能等。
- en: On the other hand, we may have all our features turned on by default, but if
    components have the ability to be turned off, then that lets the user decide what's
    relevant to them. If they can arrange the UI to their liking, removing elements
    that are of no particular use to them, then it makes for a better user experience.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可能会默认开启所有功能，但如果组件有能力被关闭，那么这就让用户决定了哪些对他们来说是相关的。如果他们能够根据自己的喜好安排用户界面，移除对他们没有特别用处的元素，那么这将提升用户体验。
- en: In either case, there're implications as far as the layout as a whole is concerned.
    If we don't take the time to design our layouts in a scalable way, then toggling
    components really doesn't add any value. During the design of our layout, we need
    to walk through the various configuration scenarios that the user might use, or
    that we ourselves might use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，这对整体布局都有影响。如果我们不花时间设计可扩展的布局，那么切换组件实际上并没有任何价值。在设计我们的布局时，我们需要考虑用户可能会使用，或者我们自己可能会使用的各种配置场景。
- en: '![Enabling and disabling components](img/4639_06_05.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![启用和禁用组件](img/4639_06_05.jpg)'
- en: Disabling components on a page has the potential to update the layout; our styles
    need to by able to handle this
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上禁用组件有可能更新布局；我们的样式需要能够处理这种情况
- en: Changing quantities
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改数量
- en: The quantity of something displayed in the UI is something that's at best a
    guess made at design time. We hope that the number of items displayed in a list
    is the optimal number, and the user doesn't have to fuss with changing these types
    of preferences. The problem is that quantities are very subjective. It's more
    about the individual that's using our application to perform a task, and depending
    on what they're used to, what they're doing in conjunction with using our software,
    and a host of other factors, the quantity preference default may not be optimal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI中显示的数量在某一方面只是一个在设计时做出的猜测。我们希望列表中显示的项数量是最优的，用户不需要为此类型的偏好更改而烦恼。问题是数量是非常主观的。它更多的是关于使用我们的应用程序执行任务的个人，以及他们习惯于什么，他们使用我们的软件时正在做什么，还有许多其他因素，数量偏好默认可能不是最优的。
- en: A common quantity question is how many entities do I want displayed on my screen?
    The entities can be common grid widgets that're used throughout the application,
    a search results page, or anything else that renders a collection of things. We
    can opt for the efficient default of a smaller quantity to display, while allowing
    for larger quantities that suit the user's needs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的数量问题是我想在屏幕上显示多少个实体？这些实体可以是整个应用程序中常用的网格小部件，一个搜索结果页面，或者任何其他渲染事物集合的东西。我们可以选择显示较少数量的效率默认设置，同时允许更多数量以满足用户的需求。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's always a good idea to sanity-check the user provided preferences. One safeguard
    is to put a selection of allowable values in place, rather than accepting arbitrary
    user input. We shouldn't allow for 1,000 entities to be rendered in a grid, for
    instance. Although, the API that returns this data should sanity-check and cap
    quantity arguments as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 始终检查用户提供的偏好是一个好主意。一个保护措施是在放置允许的值的选择，而不是接受任意的用户输入。例如，我们不应该允许网格中渲染1,000个实体。尽管如此，返回这些数据的API也应该进行检查并限制数量参数。
- en: Another quantity consideration is which entity properties do we need displayed?
    In the case of grids, we may want to see certain columns while hiding others.
    Something like this is a preference that ought to be persistent, because if we
    go through the effort of setting up the data we want to see, we won't want to
    repeat that effort.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个数量考虑的是我们需要显示哪些实体属性？在网格的情况下，我们可能希望显示某些列而隐藏其他列。这样的偏好应该是持久的，因为如果我们设置了想要看到的数据，我们就不想重复那项工作。
- en: When we change quantity preferences, there're backend implications. In the case
    of how many entities to render, we probably want to pass this constraint along
    to the API when we're fetching the data—there's no point in fetching something
    we're not going to display. There may be model or collection implications as well.
    In the case of figuring out which data we want displayed in a particular UI region,
    we might ask the model or collection for only a subset of what they have.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们改变数量偏好时，会有后端影响。在决定渲染多少实体的情况下，我们可能希望在获取数据时将这个约束传递给API——获取我们不打算显示的东西是没有意义的。这也可能涉及到模型或集合的改变。在确定在特定UI区域显示哪些数据的情况下，我们可能要求模型或集合只提供他们拥有的一部分数据。
- en: Changing order
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改顺序
- en: The order in which a collection is rendered in the UI is another common behavioral
    preference, one that we'll most likely want to support. The biggest impact here
    is configuring the default order of something. For example, ordering every collection
    by the modified date, so that the most recent entities appear first, is a good
    default.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI中渲染集合的顺序是另一个常见的 behavioral 偏好，我们很可能会支持它。这里最大的影响是配置某物的默认顺序。例如，按修改日期对每个集合进行排序，这样最近的实体首先出现，这是一个好的默认设置。
- en: Many grid components will let the user toggle the ordering of a given column
    between ascending and descending. These are actions, not necessarily preferences.
    However, they can grow to be annoying actions if the default order is never what
    we want. So we may want to introduce a means for the user to provide a default
    ordering preference for any given grid, while retaining the ability click column
    headers to sort ad-hoc.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网格组件允许用户在给定列的升序和降序之间切换排序。这些都是操作，不一定偏好。然而，如果默认顺序从来不是我们想要的，它们可能会变得烦人。因此，我们可能需要为用户提供一种方式，为任何给定网格提供默认排序偏好，同时保留点击列标题进行临时排序的能力。
- en: More complex ordering preferences are possible, and clickable column headers
    don't always help here. For instance, what if we want to order by something that's
    not actually rendered in the UI, like relevance or best selling? There's probably
    a control we can use for this, but it's another potential preference—since it
    could help provide a better experience.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的更复杂的排序偏好是，点击列标题并不总是有帮助。例如，如果我们想按不在UI中渲染的东西排序，比如相关性或最佳销售？这里可能有一个控制可以用来实现这一点，但这又是另一个可能的偏好——因为它可能有助于提供更好的体验。
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Configuring notifications
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置通知
- en: When users perform some action in our application, like turning something on
    or off, we need to provide feedback on the state of that action. Did it succeed?
    Did it fail? Is it running? These are generally done through notifications, rendered
    as transient popups in the corner of the screen, or in a panel somewhere.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在我们的应用程序中执行某些操作，比如打开或关闭某些功能时，我们需要提供关于该操作状态的反馈。它成功了吗？失败了吗？正在运行吗？这通常通过通知完成，以屏幕角落的短暂弹出窗口或某个面板的形式呈现。
- en: The user may want to control certain aspects about how they're notified—there's
    nothing more irritating than getting spammed with information we don't care about.
    So one preference related to notifications might be a selection of notification
    topics. For example, we might want to opt out of notifications for irrelevant
    entity types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能希望控制他们通知方式的某些方面——没有比收到我们不关心的信息垃圾更让人恼火了。因此，与通知相关的的一个偏好可能就是通知主题的选择。例如，我们可能希望选择不接收不相关实体类型的通知。
- en: Another potential preference might be the duration that a given notification
    stays active on the screen. For example, should it stay where it is till we acknowledge
    it, or should it go away after three seconds? In the extreme case, the user may
    want to turn off notifications altogether if there's no other way to make them
    less annoying. There are always the action logs for convenient browsing later
    on if need be.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的偏好可能是给定通知在屏幕上保持活动状态的持续时间。例如，它应该在我们确认它之前一直停留原地，还是应该在三秒后消失？在极端情况下，如果没有什么其他办法能让它们不那么烦人，用户可能想要完全关闭通知。如果需要，以后可以随时方便地浏览操作日志。
- en: Inline options
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联选项
- en: How do we collect user preference input? For the less active, global application
    preferences, a settings page divided into categories probably makes sense. However,
    having to configure things specific to individual widgets on a settings page is
    kind of annoying. It's sometimes better to have inline options.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何收集用户偏好输入呢？对于不太活跃的全球应用程序偏好，一个按类别划分的设置页面可能是合适的。然而，必须在设置页面上为个别小部件配置特定事项有点儿烦人。有时，拥有内联选项会更好。
- en: Inline means that the user can set their preference using elements that are
    part of the UI in question. For example, choosing specific columns to display
    in a grid. It wouldn't make much sense to bury such a preference in a settings
    page somewhere. When preference controls are positioned relative to the thing
    they control, it requires less explanation. The user can generally figure out
    the meaning a lot easier when the control is contextual.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 内联意味着用户可以使用与相关UI部分相关的元素来设置他们的偏好。例如，在网格中选择特定的列显示。把这样的偏好埋在某个设置页面上并没有多大意义。当偏好控制与它们控制的元素相对位置时，通常需要更少的解释。当控制具有上下文意义时，用户通常更容易理解其含义。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The downside to contextual preference controls is that they have potential to
    clutter the UI. If there're a lot of components on the page, each of which has
    preferences controls on it, then we're most likely creating confusion instead
    of convenience.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文偏好控制的一个缺点是，它们有可能导致界面混乱。如果页面上有许多组件，每个组件上都有偏好控制，那么我们很可能会制造混乱而不是提供便利。
- en: Changing the look and feel
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改外观和感觉
- en: Today, it's less common for the look and feel of an application to be a static,
    unchanging aspect. Instead, they ship with a handful of themes the user can choose
    from. Or, the support to easily create themes is built into the software. This
    allows our customers to decide how our software should look for their users. In
    addition to packaged themes that update the look and feel of our application,
    individual style preferences may be set.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，应用程序的外观和感觉很少是静态的、不变的方面。相反，它们通常会附带几套用户可以选择的主题。或者，软件中内置了易于创建主题的支持。这允许我们的客户决定他们的软件应为他们的用户呈现何种外观。除了更新我们应用程序外观和感觉的预设主题外，还可以设置个别样式偏好。
- en: Theme tools
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[主题工具](#theme-tools)'
- en: If we want our application to have the ability to change themes upon request,
    we have to put a lot of design and architecture into our CSS and the markup that
    uses it. While this topic goes way beyond the scope of this book, it's worth looking
    at the tools available for assisting in generating themes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要我们的应用程序能够根据请求更换主题，我们必须在CSS及其使用的标记上投入大量的设计和架构工作。虽然这个话题远远超出了本书的范围，但研究一下有助于生成主题的工具还是值得的。
- en: The first tool at our disposal in this area is a CSS framework. Like JavaScript
    frameworks, CSS frameworks define consistent patterns and conventions. It's then
    up to us, the component authors, to figure out how to apply these CSS patterns
    to our components, and the markup they generate. Think of a theme as a bunch of
    style preferences. When the configuration is changed, the appearance is changed
    because of new preference values. What makes a CSS module a theme, is having the
    same properties defined as all the other themes used by the application—it's only
    the values of these properties that change.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这一领域中可用的第一个工具是一个CSS框架。与JavaScript框架类似，CSS框架定义了一致的模式和约定。接下来，就要我们这些组件作者来弄清楚如何将这些CSS模式应用到我们的组件以及它们生成的标记上。可以把一个主题看作是一系列样式偏好。当配置更改时，由于新的偏好值，外观也会发生变化。使一个CSS模块成为主题的原因是，它定义了与应用程序中所有其他主题相同的属性——只有这些属性的值会发生变化。
- en: Another tool we can use is part of the backend build process—CSS compilers.
    These tools take in files that use a dialect of CSS, and preprocess them. What's
    nice about these types of preprocessor languages is that we have much greater
    control of how style preferences are specified. For example, there's no such thing
    as variables in CSS, but preprocessors have them, and this is a really handy configurability
    feature to have.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用后端构建过程的一部分工具—CSS编译器。这些工具接收使用CSS方言的文件，并预处理它们。关于这些预处理器语言的好处是，我们能够更精确地控制样式偏好的指定方式。例如，CSS中没有变量这样的东西，但预处理器中有，这是非常方便的可配置性功能。
- en: Selecting a theme
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择主题
- en: Once we have a theme-able user interface, we need a way to load a specific theme
    instance. Even if we don't allow users to select a theme of their choice, it's
    still nice to be able to change the design by changing a preference value. When
    we decide to implement a new design, this certainly makes deployment into a production
    environment that much simpler.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了可定制的用户界面，我们需要一种加载特定主题实例的方法。即使我们不允许用户选择他们喜欢的主题，能够通过更改偏好值来改变设计也是很好的。当我们决定实现新设计时，这当然可以使部署到生产环境变得更加简单。
- en: Down the road, we may decide that we do want to let users select their own theme.
    For example, we might have acquired lots of users and there's now a demand for
    this ability. We can create the theme selector like any other preference value
    that's used in the system. We'd need to have some kind of theme selection widget
    in place, and the selection made by the user can map to a path, since this is
    likely all that's needed to swap one theme for another.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，我们可能会决定让用户选择自己的主题。例如，我们可能已经拥有大量用户，现在有这种需求。我们可以像系统中使用的任何其他偏好值一样创建主题选择器。我们需要有一种主题选择小部件，用户所做的选择可以映射到路径，因为这是交换一个主题到另一个主题所需的一切。
- en: Another possibility is to have different themes set as the default, based on
    the role of the user. For example, if an administrator logs in, it's helpful to
    have a different visual cue that you are in fact logged in as a specific type
    of user. This type of thing can help in scenarios where there're screenshots,
    and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是根据用户角色设置不同的主题作为默认主题。例如，如果管理员登录，具有不同的视觉提示实际上您以特定类型的用户登录是有帮助的。在截图等场景中，这类事情可以帮助。
- en: Individual style preferences
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人样式偏好
- en: The look and feel of an application can change at an individual element level.
    That is, if we want to change the width of something, we can change it on the
    screen. Or maybe we don't like the font face that's in use and we want to change
    that as well, but nothing else.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的外观和感觉可以逐个元素级别进行更改。也就是说，如果我们想改变某物的宽度，我们可以在屏幕上进行更改。也许我们不喜欢正在使用的字体样式，我们也想更改，但其他方面保持不变。
- en: These types of fine-grained style preferences should be avoided because they
    do not scale well. Our components have to be aware of specific style considerations,
    and that degrades the true purpose of the component in most cases. In some cases,
    picking a different layout for a screen doesn't hurt, because that usually means
    swapping one CSS class for another.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免此类细粒度的样式偏好，因为它们扩展性不佳。我们的组件必须了解特定的样式考虑，这通常会在大多数情况下降低组件的真正目的。在某些情况下，为屏幕选择不同的布局不会有害，因为这通常意味着将一个CSS类交换为另一个。
- en: Another possibility is using drag and drop interactions to set the size of something.
    But, it's best if these are kept as transient interactions, and not as persistent
    preferences. We want to optimize for the common configuration values, and there's
    nothing common about the resizing of elements to individual tastes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用拖放交互来设置某物的尺寸。但是，最好是将这些保留为短暂交互，而不是持久偏好。我们希望为常见的配置值优化，而针对个人口味调整元素大小并没有什么共同之处。
- en: Performance implications
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能影响
- en: We'll close the chapter out with an overview of the performance implications
    introduced by the various configuration areas discussed thus far. If we really
    need configuration values in one area because they add value, they may hurt performance
    overall—so we need to offset this cost somehow.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以概述由各种配置区域引入的性能影响来结束本章。如果我们确实需要在某一区域获取配置值，因为它们增加了价值，它们可能会影响整体性能—因此我们需要以某种方式抵消这种成本。
- en: Configurable locale performance
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可配置的区域性能
- en: By far the most noticeable performance bottleneck concerning locales is the
    initial load. That's because we have to load all the locale data before anything
    is actually rendered for the user. This includes string message translations,
    as well as all the other data necessary for localization. The performance during
    initialization is constrained further when there's more than one locale loaded
    up-front.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 说到语言环境，最显著的性能瓶颈就是初始加载。这是因为我们必须在实际为用户渲染任何内容之前加载所有语言环境数据。这包括字符串消息翻译，以及所有进行本地化的其他必要数据。当一次性加载多个语言环境时，初始化过程中的性能受到进一步限制。
- en: The best way to improve the load performance is to only load the locale that
    the user actually wants. Once they've set this preference, they're unlikely to
    change it frequently, so there's no real benefit to having other locale data nearby
    and ready.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 提高加载性能的最佳方法是只加载用户实际想要的语言环境。一旦他们设置了这个偏好，他们不太可能频繁更改，所以附近有其他语言环境数据并准备好并没有真正的好处。
- en: There's an unavoidable slow-down in rendering views, because much data needs
    to pass through the localization mechanism we're using. This alone isn't likely
    to cause performance issues because most operations are small and efficient—simple
    lookups, and string formatting. The additional overhead is there though, and needs
    to be accounted for.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染视图时不可避免地会有减速，因为大量数据需要通过我们使用的本地化机制。单凭这一点不太可能引起性能问题，因为大多数操作都是小而高效的——简单的查找和字符串格式化。尽管如此，额外的开销是存在的，需要予以考虑。
- en: Configurable behavior performance
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可配置行为性能
- en: Configuration that alters the behavior of a component also has minimal performance
    impact. In fact, the performance characteristics of configurable behavior are
    similar to those of configurable locales. The biggest challenge is the initial
    configuration load. After that, it's just a matter of performing lookups, which
    are fast.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 改变组件行为的配置对性能影响最小。实际上，可配置行为的性能特性与可配置语言环境的特性相似。最大的挑战是初始配置加载。在那之后，只需执行查找，这是快速的。
- en: The thing to look out for, is when we have lots of components we need to configure.
    While individual lookups are fast, performance takes a hit when there're lots
    of lookups. It'll take quite a while to reach this point, but the risk is there
    nonetheless.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当我们需要配置大量组件时。虽然单个查找很快，但当查找量很大时，性能会受到影响。达到这个点需要一段时间，但风险依然存在。
- en: 'The following is an example that shows how we can configure when a collection
    is sorted, impacting the performance of other operations that are order-dependent
    and are called frequently:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了我们可以配置集合何时排序，从而影响具有依赖顺序并且被频繁调用的其他操作的性能：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Behavioral preferences may be used to completely swap one function for another.
    They may have the same interface, but with different implementations. Deciding
    which function to use at runtime isn't expensive, but there's also the memory
    consumption to consider. For example, if there're many preferences throughout
    our application that support different functions, we'll have to store the default
    implementation, in addition to the function stored as a preference value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 行为偏好可能用于完全交换一个函数与另一个函数。它们可能有相同的接口，但实现不同。在运行时决定使用哪个函数并不昂贵，但还需要考虑内存消耗。例如，如果我们应用程序中有许多支持不同函数的偏好，我们将不得不存储默认实现，以及作为偏好值存储的函数。
- en: Configurable theme performance
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可配置主题性能
- en: The only real latency we can expect from configurable themes is the initial
    cost of figuring out which theme to use. Then there's the process of downloading
    it, and applying the styles to the markup—which isn't any different from an application
    with a single set of static styles. If we allow the user to switch themes, there's
    the additional latency of waiting for the new CSS and related static resources
    to download and render.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一可以预期的可配置主题的延迟就是确定使用哪个主题的初始成本。然后是下载它以及将样式应用到标记的过程——这与只有一个静态样式集的应用程序没有区别。如果我们允许用户切换主题，那么还需要等待新的CSS和相关静态资源下载和渲染的额外延迟。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the concept of configurability in large-scale JavaScript
    applications. The major configuration categories are locales, behavior, and appearance.
    Locales are a big part of web applications today because there's nothing stopping
    people, anywhere in the world, from using our application. There are scaling challenges
    associated with internationalization though. It adds complexity to our development
    lifecycle and there's the cost of maintaining locales.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了大规模JavaScript应用程序中可配置性的概念。主要的配置类别包括地区、行为和外观。地区是当今网络应用程序的一个重要部分，因为没有什么能阻止世界上任何地方的人使用我们的应用程序。然而，国际化带来了可扩展性的挑战。它增加了我们开发周期的复杂性，以及维护地区的成本。
- en: Preferences need to be stored somewhere. Storing them in the browser works,
    but there's no portability with this approach. It's much more appropriate to store
    preferences in the backend and load them when the application initializes. There're
    many challenges to scaling lots of preferences, including differentiating between
    user-defined and system preferences. It shouldn't matter if we've included sane
    hard-coded default values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 偏好需要存储在某个地方。将它们存储在浏览器中是可行的，但这种方法缺乏可移植性。将偏好存储在后端并在应用程序初始化时加载它们要更合适得多。扩展许多偏好面临许多挑战，包括区分用户定义和系统偏好。我们是否包含了合理的硬编码默认值并不重要。
- en: The styles of our application are another configurable dimension. There're frameworks
    and build-tools that help us build themes for the look and feel. Configurable
    components have minor performance considerations—the next chapter will look at
    performance challenges that crop up as we scale our software.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的风格是另一个可配置的维度。有框架和构建工具可以帮助我们构建外观和感觉的主题。可配置组件有一些小的性能考虑——下一章将探讨随着我们扩展软件而出现的性能挑战。
