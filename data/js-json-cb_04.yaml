- en: Chapter 4. Using JSON in AJAX Applications with jQuery and AngularJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章．使用jQuery和AngularJS在AJAX应用程序中使用JSON
- en: 'In this chapter, we''ll look at the part that JSON plays in asynchronous JavaScript
    and XML (AJAX) applications that provide better responsiveness than older web
    pages by dynamically loading bits of a web page on demand. In this chapter, you''ll
    find the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨JSON在提供比旧网页更好的响应性的异步JavaScript和XML（AJAX）应用程序中所起的作用。在本章中，您将找到以下食谱：
- en: Adding a dependency to jQuery to your web page
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的网页中添加jQuery依赖关系
- en: Requesting JSON content using jQuery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery请求JSON内容
- en: Sending JSON to your web server using jQuery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery将JSON发送到您的网络服务器
- en: Getting the progress of a request using jQuery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery获取请求的进度
- en: Parsing the returned JSON using jQuery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery解析返回的JSON
- en: Adding a dependency to AngularJS to your web page
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的网页中添加AngularJS依赖关系
- en: Requesting JSON content using AngularJS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AngularJS请求JSON内容
- en: Sending JSON to your web server using AngularJS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AngularJS将JSON发送到您的网络服务器
- en: Getting the progress of a request using AngularJS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AngularJS获取请求的进度
- en: Parsing the returned JSON using AngularJS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AngularJS解析返回的JSON
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the last chapter, you saw recipes that showed you how to use `XMLHttpRequest`
    to make AJAX requests that exchanged JSON. In practice, handling all of the special
    cases in different browsers makes this a pesky, error-prone job. Fortunately,
    most client-side JavaScript frameworks wrap this object for you, giving you a
    browser-independent way to do the same thing. Often, the interface is easier to
    use too—as you'll soon see, in the case of AngularJS, you don't need to do anything
    special to move objects back and forth using JSON; the framework even takes care
    of serializing and deserializing the JSON for you!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您看到了展示如何使用`XMLHttpRequest`来制作交换JSON的AJAX请求的食谱。在实际中，处理不同浏览器中的所有特殊情况使得这项工作变得繁琐且容易出错。幸运的是，大多数客户端JavaScript框架为您包装了这个对象，为您提供了一种与浏览器无关的方法来做同样的事情。通常，这个界面也更容易使用——正如您即将看到的，在AngularJS的情况下，您不需要做任何特别的事情就可以使用JSON在对象之间移动；该框架甚至为您处理JSON的序列化和反序列化！
- en: Both AngularJS and jQuery are client-side JavaScript frameworks that make developing
    web applications easier. jQuery was one of the first and is probably the most
    widely adopted framework; AngularJS is newer and has the additional advantage
    of providing you with the ability to structure your code using the **model-view-controller**
    (**MVC**) paradigm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: both AngularJS和jQuery都是使开发网络应用程序更简单的客户端JavaScript框架。jQuery是第一个也是最受欢迎的框架之一；AngularJS是较新的，并且具有提供使用**模型-视图-控制器**（**MVC**）范式的额外优势，使您的代码结构更加清晰。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'MVC is a design pattern that dates back decades, originally introduced as a
    part of Smalltalk in the 1970s. This pattern divides your code into three distinct
    segments: the model, which contains the data your user wants to manipulate, the
    view, which shows the contents of the model, and the controller, which accepts
    events and changes the model in response to the accepted events.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一种设计模式，可以追溯到几十年以前，最初是在20世纪70年代的Smalltalk中引入的。这种模式将您的代码分为三个不同的部分：模型，包含用户想要操作的数据；视图，显示模型的内容；控制器，接受事件并在接受的事件发生时更改模型。
- en: 'In this chapter, we will use the server in Node.js that we based last chapter''s
    recipes on, with an extension to support serving client-side JavaScript as well
    as HTML. Here''s the code for this, broken down step by step:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们在上一章的食谱中基于的Node.js服务器，并扩展支持提供客户端JavaScript以及HTML。以下是本节的代码，逐步分解如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These four lines include the interfaces our server needs—the modules to handle
    the HTTP server module, the file system module, the URL parsing module, and a
    simple module to make HTTP requests.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行包括了我们的服务器需要的接口——处理HTTP服务器模块、文件系统模块、URL解析模块以及一个简单的模块来发送HTTP请求。
- en: 'Next, we log that the server starts and create an HTTP server that accepts
    all requests with a single function callback:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们记录服务器启动的情况，并创建一个HTTP服务器，它用一个函数回调接受所有请求：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our server handles two kinds of requests: `POST` requests and `GET` requests.
    The `POST` request handler needs to read the incoming data that''s been posted
    to the server, which we do by concatenating it with an originally empty `body`
    buffer:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器处理两种类型的请求：`POST`请求和`GET`请求。`POST`请求处理程序需要读取被发送到服务器的传入数据，我们通过将其与一个最初为空的`body`缓冲区连接起来来实现：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We register a function that Node.js calls back when the HTTP post finishes,
    which parses the JSON and makes a `GET` request to the remote server for our data,
    simulating what a middleware server might do:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册了一个函数，当Node.js完成HTTP POST请求时会调用它，该函数解析JSON并对远程服务器发起`GET`请求以获取我们的数据，模拟中间件服务器可能会执行的操作：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This request itself has a callback, which parses the incoming JSON from the
    remote server, looks for the first element of the array in the result entries
    attribute, and constructs a JSON object to return to the web client. If we don''t
    get a valid response, we set an error value so the client can do something with
    the error. We return this by converting the JavaScript object to JSON and writing
    it to the client:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求本身有一个回调，它解析来自远程服务器的传入JSON，在结果条目属性中查找数组的第一个元素，并构造一个JSON对象以返回给Web客户端。如果我们没有得到有效的响应，我们设置一个错误值，以便客户端可以对错误做些什么。我们通过将JavaScript对象转换为JSON并将其写入客户端来返回这个：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If it''s not a `POST` request we''re handling, it might be a `GET` request.
    Here''s the new code from the last chapter. We need to determine whether the incoming
    URL indicates that the content to be fetched is an HTML file (whose suffix is
    `.html` or `.htm`) or a JavaScript file (whose suffix is `.js`). First, we see
    whether we''re getting a request for a favicon; Chrome always does this, and we
    just return an empty object body. Assuming that it''s not a favicon being requested,
    we check the incoming URL to see how it ends, so we can write the appropriate
    Content-Type header (either text/html or application/json). If it''s neither of
    those, we assume plaintext and send a text/plain Content-Type header:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的不是`POST`请求，那它可能是一个`GET`请求。以下是上一章的新代码。我们需要确定传入的URL是否表示要获取的内容是HTML文件（其扩展名为`.html`或`.htm`）还是JavaScript文件（其扩展名为`.js`）。首先，我们检查是否正在请求一个favicon；Chrome总是这样做，我们只是返回一个空的对象体。假设请求的不是favicon，我们检查传入的URL如何结束，以便我们可以写出适当的内容类型头（text/html或application/json）。如果不是这些，我们假设是纯文本，并发送一个text/plain内容类型头：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we read the content from the public directory below the Node.js server
    source and return it to the client:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从Node.js服务器源下面的公共目录中读取内容并返回给客户端：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, this big function gets registered as a listening HTTP server on port
    `1337` of the localhost, and we log that the server''s started:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个大函数作为监听HTTP服务器注册在本地主机的端`1337`上，我们记录服务器已启动：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A real server probably shouldn't guess the MIME type of the returned data by
    looking at the incoming URL, but actually sniff the outgoing data and make a determination
    as to the MIME type and use that. There's a Node.js module magic that does just
    this; if you're a little less paranoid, you could use the file name suffix on
    the disk and hope that the content provider was correctly naming files.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正的服务器可能不应该通过查看传入的URL来猜测返回数据的MIME类型，而应该实际上嗅探出去的数据并做出关于MIME类型的决定。有一个Node.js模块magic可以做到这一点；如果您稍微不那么偏执，可以使用磁盘上的文件名后缀，并希望内容提供商正确地命名文件。
- en: That's it for the server, which you'll find in the ZIP for the samples that
    accompany this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务器的内容，您可以在随书附带的样本ZIP文件中找到它。
- en: Adding a dependency to jQuery to your web page
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向您的网页添加jQuery依赖
- en: jQuery is a popular client-side framework for AJAX applications that gives you
    browser-independent support to search and manipulate the **Document Object Model**
    (**DOM**) and **Cascading Style Sheets** (**CSS**), perform AJAX queries, as well
    as include several HTML controls you can style using CSS. You need to include
    the source for jQuery in your page, either by pointing to a released version on
    the jQuery Content Delivery Network (CDN), or by going to [http://www.jquery.com](http://www.jquery.com)
    and downloading a copy of the framework for you to serve with your own application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个流行的客户端框架，用于AJAX应用程序，它为您提供了浏览器无关的支持，用于搜索和操作**文档对象模型**（**DOM**）和**层叠样式表**（**CSS**），执行AJAX查询，以及包括几个可以使用CSS样式的HTML控件。您需要在您的页面中包含jQuery的源代码，要么通过指向jQuery内容分发网络（CDN）上的发布版本，要么通过访问[http://www.jquery.com](http://www.jquery.com)并下载框架的副本，以便与您自己的应用程序一起使用。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You''ll need to include the jQuery library in your web page by starting a new
    json-example.html file, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要通过开始一个新的json-example.html文件来包含jQuery库，像这样：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: These two lines include two scripts containing the minified version of the jQuery
    client library from the jquery.com CDN. This is probably what you want to do for
    production applications; the minified jQuery implementation is smaller than the
    full-blown library, so it's faster for your clients to download, and using the
    version on the CDN provides performance that may well be faster than what you
    can provide, unless you're hosting multiple servers at a major cloud provider
    such as Amazon Web Services or Microsoft Azure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行包含了两个包含从jquery.com CDN获取的jQuery客户端库压缩版本的脚本。这可能正是你在生产应用程序中想要做的事情；压缩的jQuery实现比完整的库要小，所以客户端下载更快，使用CDN上的版本提供的性能可能比你自己能提供的性能还要快，除非你在像Amazon
    Web Services或Microsoft Azure这样的主要云服务提供商上托管多个服务器。
- en: There's more…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you don't want to include the minified versions—often the case when you're
    deep in your development cycle and want to debug your code—you can include the
    standard version served from your server. Just download the necessary files from
    [http://www.jquery.com/](http://www.jquery.com/) and serve them from your server.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想包含压缩版本——这通常在你深入开发周期并希望调试代码时发生——你可以从你的服务器上提供标准版本。只需从[http://www.jquery.com/](http://www.jquery.com/)下载必要的文件，并从你的服务器上提供它们。
- en: 'jQuery comes in two revisions: revision 1.x, which has support for older browsers,
    including Microsoft Internet Explorer 6 and above, and revision 2.x, which requires
    at least Microsoft Internet Explorer 9\. Our examples will use jQuery 1.x, but
    never fear; the APIs we discuss are the same for jQuery 2.x.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery有两个版本：1.x版本，支持较老的浏览器，包括Microsoft Internet Explorer 6及以上版本，而2.x版本至少需要Microsoft
    Internet Explorer 9。我们的示例将使用jQuery 1.x，但不用担心；我们讨论的API在jQuery 2.x中也是一样的。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Head over to [http://www.jquery.com](http://www.jquery.com) to download jQuery
    or learn more about it. If you're looking for a JavaScript framework, it's probably
    worth looking at the jQuery learning center at [http://learn.jquery.com/](http://learn.jquery.com/),
    or perhaps take a look at Packt Publishing's book, *Learning jQuery – Fourth Edition*,
    by *Jonathan Chaffer* and *Karl Swedberg*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[http://www.jquery.com](http://www.jquery.com)下载jQuery或了解更多关于它的信息。如果你正在寻找一个JavaScript框架，也许值得查看jQuery学习中心在[http://learn.jquery.com/](http://learn.jquery.com/)的内容，或者也许可以看看Packt
    Publishing的书籍，《学习jQuery – 第四版》，作者是Jonathan Chaffer和Karl Swedberg。
- en: Requesting JSON content using jQuery
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery请求JSON内容
- en: jQuery defines the variable `$`, which exposes methods for everything you want
    to do with the interface. (There are ways to rename that variable, say if you're
    working with another JavaScript environment that uses the same variable, but I
    don't recommend it). Among the methods `$` exposes is the `ajax` method, which
    you use to make AJAX queries. Let's see how.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery定义了变量`$`，暴露了你想要与界面做的所有方法的接口。（有一种方法可以重命名该变量，比如说如果你正在与其他使用相同变量的JavaScript环境一起工作，但我建议不要这样做）。`$`暴露的方法之一是`ajax`方法，你可以用它来发起AJAX查询。让我们来看看它是如何做到的。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s a whole page that makes an AJAX request. The AJAX code is in bold:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个整页的AJAX请求。AJAX代码是粗体的：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The HTML in this example is straightforward. It includes the jQuery modules,
    and then defines three `div` regions for the AJAX request to update when the request
    is complete. Let's look at the JavaScript function `doAjax` in more detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的HTML很简单。它包含了jQuery模块，然后为AJAX请求定义了三个`div`区域，在请求完成后更新。让我们更详细地看看JavaScript函数`doAjax`。
- en: How it works…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `doAjax` function, called when the page finishes loading, first sets the
    HTML contents of `div` named `debug` to the text "`loaded… executing.`". The `$()`
    syntax is the jQuery syntax to find an item in the DOM; you can find items by
    their ID by prefixing the name with a `#` (hash) symbol, such as a CSS selector.
    The value returned isn't the actual DOM element but a jQuery class that wraps
    the DOM element that exposes simple methods such as `html` to get or set the HTML
    contents of the item.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAjax`函数，在页面加载完成后调用，首先将名为`debug`的`div`的HTML内容设置为文本"`loaded… executing.`"。`$()`语法是jQuery用来在DOM中查找项目的语法；你可以通过在名称前加上`#`（哈希）符号来找到项目，就像CSS选择器一样。返回的值不是实际的DOM元素，而是一个包含简单方法如`html`以获取或设置项目HTML内容的jQuery类，该类包装了DOM元素。'
- en: Next, we define the JSON object that has the particulars of our request, as
    we did in the previous chapter's recipes. It has one attribute, `call`, containing
    the call sign of the station we're interested in.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个JSON对象，其中包含我们请求的详细信息，就像前章的食谱中所做的那样。它有一个属性，`call`，包含我们感兴趣的站的呼号。
- en: 'Next, we invoke the `ajax` method of `$`, passing a JavaScript object with
    the semantics of our request. It should have the following fields:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用$的`ajax`方法，传递一个具有我们请求语义的JavaScript对象。它应该包含以下字段：
- en: The `type` field, which indicates the HTTP method of the request (such as `POST`
    or `GET`).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`字段，表示请求的HTTP方法（如`POST`或`GET`）。'
- en: The `url` field, which indicates the URL to which the request should be submitted.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`字段，表示请求应提交的URL。'
- en: The `data` field, containing string data to be sent to the server for the request
    (if any). We'll see that used in the next recipe.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`字段，包含要发送到服务器的请求（如果有）的字符串数据。我们将在下一个食谱中看到它的使用。'
- en: The `dataType` field, indicating the type of data you're expecting from the
    server; an optional field, which can be `xml`, `json`, `script`, or `html`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataType`字段，表示你期望从服务器获得的数据类型；一个可选字段，可以是`xml`、`json`、`script`或`html`。'
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见 also
- en: Curious readers should consult the jQuery `ajax` method documentation available
    at [http://api.jquery.com/jQuery.ajax/](http://api.jquery.com/jQuery.ajax/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的读者应该查阅jQuery `ajax`方法文档，该文档可在[http://api.jquery.com/jQuery.ajax/](http://api.jquery.com/jQuery.ajax/)找到。
- en: Sending JSON to your web server using jQuery
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery将JSON发送到你的网络服务器
- en: Sending JSON to your server using jQuery is easy. Just get the data in the JSON
    format and specify it using the `ajax` method argument's `data` field.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery将JSON发送到你的服务器是很容易的。只需获取JSON格式的数据，并使用`ajax`方法参数的`data`字段指定它。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Let''s look at `doAjax` again, this time modified to send our request JSON:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看`doAjax`，这次修改以发送我们的JSON请求：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The magic line in the previous listing is highlighted; it''s the following
    line in the arguments passed to the `ajax` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上一列表中的魔法行被突出显示；它是传递给`ajax`方法的参数中的以下行：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, we use `JSON.stringify` to encode the JavaScript object as JSON before
    assigning it to the data field.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们使用`JSON.stringify`将JavaScript对象编码为JSON，然后将其分配给data字段。
- en: Getting the progress of a request using jQuery
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery获取请求进度的方法
- en: jQuery abstracts the various progress reporting mechanisms of the underlying
    `XMLHttpRequest` object in a platform-agnostic way, giving you the ability to
    determine whether your request succeeded or failed. You do this by registering
    functions that the jQuery AJAX handler will invoke when an error occurs or the
    results are successfully loaded.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery以一种与平台无关的方式抽象化了底层`XMLHttpRequest`对象的各个进度报告机制，赋予您确定您的请求是否成功或失败的能力。您通过注册函数来实现，这些函数将在发生错误或结果成功加载时由jQuery
    AJAX处理程序调用。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s `doAjax` rewritten to support getting notifications on failure, regardless
    of whether the event succeeds or fails:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`doAjax`重写以支持在失败时获取通知的代码，无论事件成功还是失败：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The new methods here are the `fail` and `always` methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新方法是`fail`和`always`方法。
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: jQuery uses a pattern called *chaining*, in which most of its methods return
    an instance of an object to which you can apply additional methods. So, methods
    such as `fail` and `always` operate on the same object, and return the same object,
    that encapsulates the return value from the `$.ajax` method call using chaining
    yields easier-to-read and easier-to-write code. In the case of `$.ajax`, what's
    returned is an instance of a jQuery `XMLHttpRequest` object, whose fields are
    a superset of the `XMLHttpRequest` object returned by the browser.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery使用一种称为*链式调用*的模式，其中大多数方法返回一个实例，您可以对该实例应用其他方法。因此，像`fail`和`always`这样的方法在同一个对象上操作，并返回相同的对象，该对象使用链式调用封装了`$.ajax`方法调用的返回值，使得代码更易读、更易写。在`$.ajax`的情况下，返回的是一个jQuery
    `XMLHttpRequest`对象的实例，其字段是浏览器返回的`XMLHttpRequest`对象的超集。
- en: 'Here, I''m setting two event handlers on the return value to `$.ajax`: one
    for the failure case, in which the request fails for some reason, and one for
    the always case. Note that thanks to chaining, I could have reversed these and
    put the handler for the always case first and the handler for the failure case
    second. It''s entirely up to you which you prefer.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我在`$.ajax`的返回值上设置了两个事件处理程序：一个是用于失败情况的，即请求因某些原因失败；另一个是用于始终情况的。请注意，由于链式调用的存在，我可以将这些处理程序颠倒过来，将始终情况的处理程序放在前面，将失败情况的处理程序放在后面。究竟哪个在前完全取决于你的个人喜好。
- en: The `always` and `failure` methods take a single function, which can take up
    to three arguments. In this case, I'm not using any of the available arguments
    and just appending some text to the HTML of the `div` region with the `id` debug.
    jQuery passes the `failure` event handler to the jQuery `XMLHttpRequest` object,
    a textual status message, and the error code associated with the failure, while
    it passes the `always` method to either those arguments on an error, or the data,
    a textual status message, and the jQuery `XMLHttpRequest` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`always`和`failure`方法都接受一个函数，该函数可以接受多达三个参数。在这种情况下，我没有使用任何可用的参数，只是将一些文本添加到具有`id`为debug的`div`区域的HTML中。当请求成功完成时，jQuery将`failure`事件处理程序传递给jQuery
    `XMLHttpRequest`对象，以及与失败相关的文本状态消息和错误代码，而将`always`方法传递给错误情况下的这些参数，或者传递给数据、文本状态消息和jQuery
    `XMLHttpRequest`对象。'
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you'd prefer, you can specify the fail event handler as a function in the
    attribute named error in the initial JavaScript object argument to `$.ajax`. Similarly,
    you can specify the always event handler as a function in the attribute named
    `complete` in the initial JavaScript object to `$.ajax`. While this puts all of
    the code in one place, I personally find that harder to read because the indentation
    can get unwieldy quickly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以在`$.ajax`的初始JavaScript对象参数的名为error的属性中指定失败事件处理程序作为一个函数。同样，你也可以在初始JavaScript对象的名为`complete`的属性中指定始终事件处理程序作为一个函数。虽然这样可以将在一个地方放置所有代码，但我个人认为这样更难读，因为缩进可能会很快变得难以控制。
- en: Parsing the returned JSON using jQuery
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery解析返回的JSON
- en: Finally, it's time to see how to get the returned JSON from the server and use
    it. You'll do this by registering an event handler on `$.ajax` to receive the
    resulting JavaScript object, which jQuery helpfully deserializes from JSON for
    you.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候看看如何从服务器获取返回的JSON并使用它了。你会通过在`$.ajax`上注册一个事件处理程序来接收结果的JavaScript对象，jQuery会为你从JSON中很乐意地反序列化这个对象。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'To get the result from the AJAX request, we need to add an event handler to
    the jQuery `XMLHttpRequest` object''s `done` event, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从AJAX请求中获取结果，我们需要在jQuery `XMLHttpRequest`对象的`done`事件上添加一个事件处理程序，如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: jQuery invokes the done event handler when the request successfully completes,
    passing the resulting data as an argument. Because we specified a data type of
    `json` in the initial call to `$.ajax`, jQuery helpfully uses `JSON.parse` to
    parse the return value, and passes the JavaScript object we're interested in,
    saving us the need to call `parse` on our own.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery在请求成功完成时调用`done`事件处理程序，并将结果数据作为参数传递。因为我们已经在对`$.ajax`的初始调用中指定了数据类型为`json`，jQuery很乐意使用`JSON.parse`来解析返回值，并传递我们感兴趣的JavaScript对象，从而省去了我们自己的`parse`调用。
- en: 'Our `done` event handler does two things: it puts the JSON of the object (as
    serialized by the browser, not as returned by the server) in the `div` field with
    the ID `json`, and updates the result `div` with the station''s call sign, latitude,
    and longitude from the resulting data. This gives us a web page that looks like
    this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`done`事件处理程序做两件事：它将对象的字符串化JSON（由浏览器串行化，而不是服务器返回）放入ID为`json`的`div`字段中，并将结果`div`更新为从结果数据中获取的电台呼号、纬度和经度。这样我们就得到了一个看起来像这样的网页：
- en: '![How it works…](img/B04206_04_01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04206_04_01.jpg)'
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you prefer, you can register the event handler for successful completion
    by passing it as the `success` field of the initial request to `$.ajax`. Like
    `fail` and `always`, I prefer using chaining to set it explicitly because I think
    it's more readable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以通过将事件处理程序作为初始请求的`success`字段传递给`$.ajax`来注册事件处理程序。像`fail`和`always`一样，我更喜欢使用链式调用来显式设置它，因为我认为这样更易读。
- en: Adding a dependency to AngularJS to your web page
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向你的网页添加AngularJS依赖项
- en: Just as another JavaScript framework, you need to include AngularJS in your
    HTML. As you'll see in this section, there are a few other things you do differently
    to get set up. First, be sure that you create a new HTML file, such as `json-example-angular.html`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他的JavaScript框架一样，您需要在您的HTML中包含AngularJS。正如您在本节中将要看到的，为了设置还需要做一些其他不同的事情。首先，确保您创建了一个新的HTML文件，比如`json-example-angular.html`。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s the HTML for our application in its entirety:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的应用程序的完整HTML：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's look more closely at this HTML and see what's different.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个HTML，看看有什么不同。
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, note that the `body` tag has the attribute `ng-app`, which is set to
    `aprsapp`. AngularJS applications are given defined names, and you reference those
    names in the JavaScript that implements the logic for your application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意`body`标签具有`ng-app`属性，其设置为`aprsapp`。AngularJS应用程序被赋予了定义好的名称，你在实现应用程序逻辑的JavaScript中引用这些名称。
- en: Next, note that the `div` region containing our UI has the attribute `ng-controller`,
    which identifies the specific controller module responsible for handling the events
    for that part of the UI. We'll see how that's linked to the JavaScript in a moment.
    In that `div` are other `div` regions, whose contents are contained in double
    brackets, defining a document template that Angular.js fills out for you. This
    is a variable in AngularJS; at the time the controller loads, these variables
    in HTML will be replaced by the contents set by the controller. Each is a *model*,
    containing data to show.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意包含我们UI的`div`区域具有`ng-controller`属性，它标识了负责处理该UI部分事件的具体控制器模块。我们马上就会看到它是如何与JavaScript相链接的。在那个`div`中有其他`div`区域，其内容包含在双括号中，定义了一个文档模板，Angular.js为您填充。这是AngularJS中的一个变量；在控制器加载时，HTML中的这些变量将被控制器设置的内容所替换。每个都是一个*模型*，包含要显示的数据。
- en: Finally, we need to include the AngularJS module itself, as well as our JavaScript.
    It's customary to keep the JavaScript for your application in a separate file
    when working with AngularJS because this helps you enforce good separation between
    the appearance of the web application (contained in your HTML and CSS) and the
    implementation (contained in your JavaScript).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要包含AngularJS模块本身以及我们的JavaScript。在使用AngularJS时，习惯上将您的应用程序的JavaScript保存在单独的文件中，因为这有助于您强制执行良好的应用程序外观（包含在您的HTML和CSS中）和实现（包含在您的JavaScript中）之间的分离。
- en: 'Now, let''s look at the skeleton of the JavaScript for our page, which we put
    in the file `json-examnple-angular.js`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们页面的JavaScript骨架，我们将其放在`json-examnple-angular.js`文件中：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code defines a single AngularJS application, `aprsapp`. Note that this
    name has to match the name given to the `ng-app` attribute in your body tag. The
    code then registers a single controller for the application, `AprsController`.
    A controller is a function that takes at least one argument, the scope of the
    controller, which is where you define your data models and other variables. In
    our controller''s scope, we set the initial values for two of our models: `json`
    and `message`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个单独的AngularJS应用程序，名为`aprsapp`。请注意，这个名字必须与您body标签中`ng-app`属性的名称相匹配。代码然后为应用程序注册了一个控制器，名为`AprsController`。控制器是一个函数，至少有一个参数，即控制器的范围，您在那里定义您的数据模型和其他变量。在我们的控制器范围内，我们设置了两个模型的初始值：`json`和`message`。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见 also
- en: To get started with AngularJS, see its website at [https://angularjs.org](https://angularjs.org)
    or the book *AngularJS Essentials* by *Rodrigo Branas* published by *Packt Publishing*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用AngularJS，请查看其网站[https://angularjs.org](https://angularjs.org)，或者由*Rodrigo
    Branas*编写、*Packt Publishing*出版的*AngularJS Essentials*一书。
- en: Requesting JSON content using AngularJS
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AngularJS请求JSON内容
- en: Angular defines a core object, `$http`, which you use to make HTTP requests
    of remote servers. It's passed to your controller when you initialize it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Angular定义了一个核心对象`$http`，您使用它对远程服务器进行HTTP请求。当你初始化它的时候，它会传递给你的控制器。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Let''s extend our controller to add a reference to the `$http` object and use
    it to make a request:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的控制器，以添加对`$http`对象的引用并使用它来发送请求：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we define a function `doAjax` in our scope that will perform the asynchronous
    HTTP request. It updates our models so that the `debug` model contains a status
    message, and the `json` and `message` models are empty strings. Let's look at
    the `$http` object in more detail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在我们的范围内定义了一个函数`doAjax`，它将执行异步HTTP请求。它更新了我们的模型，使`debug`模型包含一个状态消息，而`json`和`message`模型为空字符串。让我们更详细地看看`$http`对象。
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Looking at the controller definition function, you can see that we passed not
    just the scope for the controller, but the `$http` object as well. It defines
    a function that takes one argument, a JavaScript object that defines the parameters
    of the HTTP request to make. In our example, we ask to make a `POST` request to
    the root of our server by setting the `method` field to `POST` and the `url` field
    to `/`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 查看控制器定义函数，你可以看到我们不仅传递了控制器的范围，还传递了`$http`对象。它定义了一个函数，接受一个参数，一个定义HTTP请求参数的JavaScript对象。在我们的示例中，我们通过将`method`字段设置为`POST`并将`url`字段设置为`/`，请求向服务器的根发送一个`POST`请求。
- en: 'The argument to the `$http` method can include these attributes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`$http`方法的参数可以包括这些属性：'
- en: The `method` attribute, which indicates the HTTP method to use.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`属性，指示要使用的HTTP方法。'
- en: The `url` attribute, which indicates the URL the method should be sent to.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`属性，指示方法应该发送到的URL。'
- en: The `params` attribute, which is a map of strings or objects to send to the
    server; if the value is not a string, it will be encoded as JSON (more about that
    in the next recipe); the `params` attribute is appended to the URL.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`属性是一个字符串或对象的映射，用于发送到服务器；如果值不是字符串，它将被编码为JSON（关于这一点将在下一个食谱中详细介绍）；`params`属性被附加到URL上。'
- en: The `data` attribute, which is the data to be sent to the remote server.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`属性，是要发送到远程服务器的数据。'
- en: The `headers` attribute, which is a map of headers and header values to send
    to the remote server.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`属性，是一个要发送到远程服务器的标题和标题值的映射。'
- en: The `timeout` attribute, which indicates how long to wait for a response.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`属性，指示等待响应的时间长度。'
- en: The `$http()` method returns a *promise*, an object on which you will invoke
    other methods to register event handlers to detect errors and process data when
    it's been successfully sent. (We'll discuss the promise further in the recipes
    *Getting the progress of a request using AngularJS* and *Parsing the returned
    JSON using AngularJS*.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`$http()`方法返回一个*承诺*，当你成功发送数据时，你会在这个对象上调用其他方法来注册事件处理程序来检测错误和处理数据。（我们将在食谱《使用AngularJS获取请求进度》和《使用AngularJS解析返回的JSON》中进一步讨论承诺。）'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `$http` object also defines separate methods `get`, `post`, `put`, `delete`,
    and `patch`, which make the appropriate HTTP requests. You can use them instead
    of the `$http()` method if you want to, omitting the `method` attribute. Like
    `$http()`, they all return a promise.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`$http`对象还定义了单独的方法`get`、`post`、`put`、`delete`和`patch`，用于发出适当的HTTP请求。如果你愿意，你可以使用它们代替`$http()`方法，省略`method`属性。像`$http()`一样，它们都返回一个承诺。'
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For documentation on the `$http()` method and AngularJS support for AJAX, see
    [https://docs.angularjs.org/api/ng/service/$http](https://docs.angularjs.org/api/ng/service/$http).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`$http()`方法和AngularJS对AJAX的支持的文档，请参阅[https://docs.angularjs.org/api/ng/service/$http](https://docs.angularjs.org/api/ng/service/$http)。
- en: Sending JSON to your web server using AngularJS
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AngularJS向你的Web服务器发送JSON
- en: Sending JSON with AngularJS is as easy as providing a data attribute in the
    argument to your `$http()` method call. AngularJS will even encode the object
    as JSON on your behalf.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AngularJS发送JSON就像在`$http()`方法调用中提供`data`属性一样简单。AngularJS甚至会为你编码对象为JSON。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Like before, we''ll make an AJAX request. This time, we include a data attribute:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前一样，我们将发起一个AJAX请求。这次，我们包含了一个`data`属性：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We define the JavaScript object request as we have in past examples, with a
    single call attribute containing the call sign of the station we're interested
    in. By passing this value as the data attribute in our argument to `$http()`,
    AngularJS converts the object to JSON and sends it to the server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像过去例子中一样定义JavaScript对象请求，单个调用属性包含我们感兴趣的站的呼号。通过将这个值作为数据属性传递给`$http()`的参数，AngularJS将对象转换为JSON并发送给服务器。
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you use a method, such as `$http.post()`, pass the data as the second argument,
    like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`$http.post()`这样的方法，将数据作为第二个参数传递，像这样：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also pass an optional configuration argument as the third argument.
    Such a configuration object will contain the attributes I described in the previous
    recipe for the request object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过第三个参数传递一个可选的配置参数。这样的配置对象将包含我在前一个食谱中描述的请求对象的属性。
- en: Getting the progress of a request using AngularJS
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AngularJS获取请求进度
- en: The `$http()` method returns a promise, which is your way of determining what's
    happening with the request. It defines methods to which you can pass JavaScript
    functions that operate as event handlers when the underlying network transaction
    changes state.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`$http()`方法返回一个承诺，这是您确定请求状态的方式。它定义了方法，您可以将JavaScript函数传递给这些方法，当底层网络事务状态改变时，这些函数作为事件处理程序运行。'
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'The returned promise defines `success` and `error` methods, which take event
    handlers. To use them, we write the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的承诺定义了`success`和`error`方法，这些方法需要事件处理程序。要使用它们，我们编写以下代码：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: On success, AngularJS invokes the function you register with the promise using
    the `success` method, passing it the result data, HTTP status, HTTP headers, and
    the configuration associated with the request. Here's where you'll deal with the
    results of your network transaction, which we discuss more in the next recipe.
    On any kind of failure, AngularJS invokes the callback you register with `error`,
    passing it the same data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功时，AngularJS使用`success`方法调用您注册的承诺函数，并传递结果数据、HTTP状态、HTTP头和与请求关联的配置。在这里，您将处理网络事务的结果，我们将在下一个菜谱中更详细地讨论。在任何类型的失败时，AngularJS都会调用您用`error`方法注册的回调，并传递相同的数据显示。
- en: Note that `success` and `error` return the promise again, so you can chain these
    requests if you like.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`success`和`error`方法又返回了承诺，所以如果您愿意，可以链接这些请求。
- en: Parsing the returned JSON using AngularJS
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AngularJS解析返回的JSON
- en: Handling the returned data with AngularJS is easy because it parses the returned
    JSON for you and passes the resulting object to the event handler you registered
    with the promise's `success` method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AngularJS处理返回的数据很容易，因为它为您解析返回的JSON，并将结果对象传递给您注册的事件处理程序。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s the complete client-side code for our AngularJS application. The `success`
    promise''s callback just updates the models with the fields of the object we get
    as a result:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的AngularJS应用程序完整的客户端代码。`success`承诺的回调只是用我们从结果中获取的对象字段更新模型：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Because AngularJS handles the parsing of JSON, we can dereference the values
    in the resulting JSON directly when we populate the text in the message model.
    Note as well that we can assign the JSON model the result object, and when this
    is displayed, it'll show the JSON for the result object itself.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AngularJS处理JSON解析，因此在填充消息模型中的文本时，我们可以直接反引用的返回JSON中的值。注意，我们还可以将JSON模型分配给结果对象，当显示此对象时，它将显示结果对象本身的JSON。
- en: 'If you load up the HTML and JavaScript in Chrome and press the button that
    invokes `doAjax`, you should see something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Chrome中加载HTML和JavaScript并按下调用`doAjax`的按钮，您应该会看到类似这样的内容：
- en: '![How it works…](img/B04206_04_02.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04206_04_02.jpg)'
