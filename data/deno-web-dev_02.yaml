- en: '*Chapter 1*: What is Deno?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章*：Deno是什么？
- en: Deno is a secure runtime for JavaScript and TypeScript. I'll guess that you
    are probably getting that excitement of experimenting with a new tool. You have
    worked with JavaScript or TypeScript and have at least heard of Node.js. Deno
    will feel like it has the right amount of novelty for you and, at the same time,
    has some things that will sound familiar for someone working in the ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Deno是一个安全的JavaScript和TypeScript运行时。我猜你可能对这个实验新工具感到兴奋。你已经使用过JavaScript或TypeScript，至少听说过Node.js。Deno对你来说将感觉
    novelty正好合适，同时对于在生态系统中工作的人来说，有些东西听起来会很熟悉。
- en: Before we start getting our hands dirty, we'll understand how Deno was created
    and its motivations. Doing that will help us learn and understand it better.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始动手之前，我们将了解Deno是如何创建的以及它的动机。这样做将帮助我们更好地学习和理解它。
- en: We'll be focusing on practical examples throughout this book. We'll be writing
    code and then rationalizing and explaining the underlying decisions we've made.
    If you come from a Node.js background, some of the concepts might sound familiar
    to you. We will also explain Deno and compare it with its ancestor, Node.js.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将重点关注实际示例。我们将编写代码，然后解释我们做出的一些决策背后的原因。如果你来自Node.js背景，有些概念可能对你来说很熟悉。我们还将解释Deno并与它的祖先Node.js进行比较。
- en: Once the fundamentals are in place, we'll dive into Deno and explore its runtime
    features by building small utilities and real-world applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基础知识确立，我们将深入研究Deno，并通过构建小型工具和实际应用程序来探索其运行时功能。
- en: Without Node, there would be no Deno. To understand the latter well, we can't
    ignore its 10+ year-old ancestor, which is what we'll look at in this chapter.
    We'll explain the reasons for its creation back in 2009 and the pain points that
    were detected after a decade of usage.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Node，就没有Deno。要深入了解后者，我们不能忽视它的10多年的祖先，这就是我们将在本章中要探讨的。我们将解释它在2009年创建的原因以及在使用十年后检测到的痛点。
- en: After that, we'll present Deno and the fundamental differences and challenges
    it proposes to solve. We'll have a look at its architecture, some principles and
    influences of the runtime, and the use cases where it shines.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将介绍Deno及其解决的基本差异和挑战。我们将查看其架构、一些运行时的原则和影响以及它擅长的用例。
- en: After understanding how Deno came to life, we will explore its ecosystem, its
    standard library, and some use cases where Deno is instrumental.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解Deno是如何诞生的之后，我们将探讨它的生态系统、标准库以及Deno可以发挥重要作用的一些用例。
- en: Once you've read this chapter, you'll be aware of what Deno is and what it is
    not, why it is not the next version of Node.js, and what to think about when you're
    considering Deno for your next project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完这一章后，您将了解Deno是什么，它不是什么，为什么它不是Node.js的下一个版本，以及当您考虑将Deno用于下一个项目时应该考虑什么。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A little history
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一点历史
- en: Why Deno?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么是Deno？
- en: Architecture and technologies that support Deno
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Deno的架构和技术
- en: Grasping Deno's limitations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握Deno的限制
- en: Exploring Deno's use cases
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Deno的使用案例
- en: Let's get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: A little history
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点历史
- en: Deno's first stable version, v1.0.0, was launched on the May 13, 2020\.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Deno的第一个稳定版本，v1.0.0，于2020年5月13日发布。
- en: The first time Ryan Dahl – Node.js creator – mentioned it was in his famous
    talk, *10 things I regret about node.js* ([https://youtu.be/M3BM9TB-8yA](https://youtu.be/M3BM9TB-8yA)).
    Apart from the fact that it presents the first very alpha version of Deno, it
    is a talk worth watching as a lesson on how software ages. It is an excellent
    reflection on how decisions evolve, even when they're made by some of the smartest
    people in the open source community, and how they can end up in a different place
    than what they initially planned for.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 瑞安·达尔（Ryan Dahl）--Node.js的创建者--第一次提到它是在他著名的演讲《关于node.js我后悔的10件事》中（[https://youtu.be/M3BM9TB-8yA](https://youtu.be/M3BM9TB-8yA)）。除了它展示了Deno的第一个非常原始版本之外，这个演讲也是值得一看的，因为它是一堂关于软件如何衰老的课。它很好地反映了决策是如何随着时间演变，即使它们是由开源社区中最聪明的人做出的，并且最终可能会走向与最初计划不同的方向。
- en: After the launch, in May 2020 and due to its historical background, its core
    team, and the fact that it appeals to the JavaScript community, Deno has been
    getting lots of attention. That's probably one way you've heard about it, be it
    via blog posts, tweets, or conference talks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在2020年5月发布后，由于其历史背景、核心团队以及吸引JavaScript社区的事实，Deno受到了很多关注。这可能是你听说的其中一种方式，无论是通过博客文章、推文还是会议演讲。
- en: This enthusiasm is having positive consequences on its runtime, with lots of
    people wanting to contribute and use it. The community is growing due to its Discord
    channel ([https://discord.gg/deno](https://discord.gg/deno)) and the number of
    pull requests on Deno's repositories ([https://github.com/denoland](https://github.com/denoland)).
    It is currently evolving at a cadence of one minor version per month, with lots
    of bug fixes and improvements being shipped. The roadmap shows a vision for a
    future that is no less exciting than the present. With a well-defined path and
    set of principles, Deno has everything it takes to become more significant by
    the day.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种热情对其运行时产生了积极影响，许多人想要贡献和使用它。由于其 Discord 频道（[https://discord.gg/deno](https://discord.gg/deno)）和
    Deno 存储库的拉取请求数量（[https://github.com/denoland](https://github.com/denoland)），社区正在增长。目前，它以每月一个次要版本的速度发展，交付了大量修复和改进。路线图展示了一个未来，这同样令人兴奋。凭借明确定义的路径和原则，Deno
    拥有发展成为越来越重要角色的所有条件。
- en: Let's rewind a little and go back to 2009 and the creation of Node.js.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回溯一点，回到 2009 年 Node.js 的创建。
- en: At the time, Ryan started by questioning how most backend languages and frameworks
    were dealing with I/O (input/output). Most of the tools were looking at I/O as
    an synchronous operation, blocking the process until it is done, and only then
    continuing to execute the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，Ryan 开始质疑大多数后端语言和框架是如何处理 I/O（输入/输出）的。大多数工具将 I/O 视为一个同步操作，阻塞进程直到完成，然后继续执行代码。
- en: Fundamentally, it was this synchronous blocking operation that Ryan questioned.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，正是这种同步阻塞操作引起了 Ryan 的质疑。
- en: Handling I/O
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 I/O
- en: When you are writing servers that must deal with thousands of requests per second,
    resource consumption and speed are two significant factors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写必须处理每秒数千个请求的服务器时，资源消耗和速度是两个重要的因素。
- en: For such resource-critical projects, it is important that the base tools – the
    primitives – have an architecture that is accounting for this. When the time to
    scale arises, it helps that the fundamental decisions you made at the beginning
    support that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的资源关键项目，重要的是基本工具——原语——具有考虑这一点的架构。当扩展时间到来时，最初做出的基本决策支持这一点是有帮助的。
- en: Web servers are one of those cases. The web is a significant platform in today's
    world. It never stops growing, with more devices and new tools accessing the internet
    daily, making it accessible to more people. The web is the common, democratized,
    decentralized ground for people around the world. With this in mind, the servers
    behind those applications and websites need to handle giant loads. Web applications
    such as Twitter, Facebook, and Reddit, among many others, deal with thousands
    of requests per minute. So, scale is essential.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器就是这种情况之一。Web 是当今世界的一个重要平台。它从未停止增长，每天都有更多设备和新技术上网，使更多人可以访问它。Web 是世界各地人民的共同、民主、去中心化的基础。有了这个目标，这些应用程序和网站背后的服务器需要处理巨大的负载。像
    Twitter、Facebook 和 Reddit 这样的 Web 应用程序以及其他许多应用程序，每分钟处理数千个请求。因此，扩展是必不可少的。
- en: 'To kickstart a conversation about performance and resource efficiency, let''s
    look at the following graph, which is comparing two of the most used open-source
    web servers: Apache and Nginx:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激发关于性能和资源效率的讨论，让我们来看看以下图表，该图表比较了最常用的两个开源Web服务器：Apache和Nginx：
- en: '![Figure 1.1 – Requests per second versus concurrent connections – Nginx versus
    Apache'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 每秒请求数与并发连接数 – Nginx 对 Apache'
- en: '](img/Figure_1.1_B16380.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B16380.jpg)'
- en: Figure 1.1 – Requests per second versus concurrent connections – Nginx versus
    Apache
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 每秒请求数与并发连接数 – Nginx 对 Apache
- en: At first glance, this tells us that Nginx comes out on top pretty much every
    time. We can also understand that, as the number of concurrent connections increases,
    Apache's number of requests per second decreases. Comparatively, Nginx keeps the
    number of requests per second pretty stable, despite also showing an expected
    drop in requests per second as the number of connections grows. After reaching
    a thousand concurrent connections, Nginx gets close to double the number of Apache's
    requests per second.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这告诉我们 Nginx 几乎每次都能名列前茅。我们还可以理解，随着并发连接数目的增加，Apache 每秒请求数会下降。相比之下，Nginx 每秒请求数保持相对稳定，尽管随着连接数目的增加，每秒请求数也显示出预期的下降。达到一千个并发连接后，Nginx
    的每秒请求数几乎达到 Apache 的两倍。
- en: 'Let''s look at a comparison of the RAM memory consumption:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 RAM 内存消耗的比较：
- en: '![Figure 1.2 – Memory consumption versus concurrent connections – Nginx versus
    Apache'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – 内存消耗与并发连接数——Nginx与Apache的对比'
- en: '](img/Figure_1.2_B16380.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.2_B16380.jpg)'
- en: Figure 1.2 – Memory consumption versus concurrent connections – Nginx versus
    Apache
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 内存消耗与并发连接数——Nginx与Apache的对比
- en: Apache's memory consumption grows *linearly* with the number of concurrent connections,
    while Nginx's memory footprint is constant.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Apache的内存消耗随着并发连接数的*线性*增长，而Nginx的内存占用是恒定的。
- en: You might already be wondering why this happens.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在好奇这是为什么。
- en: This happens because Apache and Nginx have very different ways of dealing with
    concurrent connections. Apache spawns a new thread per request, while Nginx uses
    an event loop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以这样，是因为Apache和Nginx在处理并发连接的方式上有很大的不同。Apache每个请求都会创建一个新的线程，而Nginx则使用事件循环。
- en: In a *thread-per-request* architecture, it creates a thread every time a new
    request comes in. That thread is responsible for handling the request until it
    finishes. If another request comes while the previous one is still being handled,
    a new thread is created.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在*每个请求一个线程*架构中，每当有一个新请求进来时，它就会创建一个线程。那个线程负责处理请求直到完成。如果另一个请求在之前的请求还在处理时到来，将会创建一个新的线程。
- en: On top of this, handling networking on threaded environments is not known as
    something particularly easy to do. You can incur in file and resource locking,
    thread communication issues, and common problems such as deadlocks. Adding to
    the difficulties presented to the developer, using threads does not come for free,
    as threads by themselves have a resource overhead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在多线程环境中处理网络编程并不被认为是特别容易的事情。你可能会遇到文件和资源锁定、线程通信问题以及常见的死锁等问题。对于开发者来说，已经够棘手了，使用线程也不是免费的，因为线程本身就有资源开销。
- en: In contrast, in an event loop architecture, everything happens on a single thread.
    This decision dramatically simplifies the lives of developers. You do not have
    to account for the factors mentioned previously, which means more time to deal
    with your users' problems.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在事件循环架构中，一切都在单个线程上发生。这个决定极大地简化了开发人员的生活。你不需要考虑前面提到的因素，这意味着你可以有更多的时间来处理用户的问题。
- en: By using this pattern, the web server just sends events to the event loop. It
    is an asynchronous queue that executes operations when there are available resources,
    returning to the code asynchronously when these operations finish. For this to
    work, all the operations need to be non-blocking, meaning they shouldn't wait
    for completion and just send an event and wait for a response later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种模式，Web服务器只需将事件发送到事件循环。它是一个异步队列，当有可用资源时执行操作，在操作完成后异步返回代码。为了让这工作，所有操作都需要是非阻塞的，意味着它们不应该等待完成，只是发送一个事件并稍后等待响应。
- en: Blocking versus non-blocking
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻塞与非阻塞
- en: 'Take, for instance, reading a file. In a blocking environment, you would read
    the file and have the process waiting for it to finish until you execute the next
    line of code. While the operating system is reading the file''s contents, the
    program is in an idle state, wasting valuable CPU cycles:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以读取文件为例。在一个阻塞环境中，你会读取文件，并让进程等待它完成直到执行下一行代码。当操作系统读取文件内容时，程序处于空闲状态，浪费了宝贵的CPU周期：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The program will wait for the file to be read and only then it will continue
    executing the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会等待文件被读取，然后继续执行代码。
- en: 'The same operation using an event loop would be to trigger the "read the file"
    event and execute other tasks (for instance, handling other requests). When the
    file reading operation finishes, the event loop will call the callback function
    with the result. This time, the runtime uses the CPU cycles to handle other requests
    while the OS retrieves the file''s contents, making better use of the resources:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件循环执行相同操作的是触发“读取文件”事件并执行其他任务（例如，处理其他请求）。当文件读取操作完成后，事件循环将调用回调函数并返回结果。这次，运行时在操作系统检索文件内容时处理其他请求，更好地利用资源：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the task gets a callback assigned to it. When the job is complete
    (this might take seconds or milliseconds), it calls back the function with the
    result. When this function is called, the code inside runs linearly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，任务被分配了一个回调。当任务完成（这可能需要几秒或几毫秒）时，它会调用回调函数并返回结果。当这个函数被调用时，里面的代码是线性运行的。
- en: Why aren't event loops used more often?
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么事件循环没有被更广泛地使用呢？
- en: Now that we understand the advantages of event loops, this is a very plausible
    question. One of the reasons event loops are not used more, even though there
    are some implementations in Python and Ruby, is that they require all the infrastructure
    and code to be non-blocking. Being non-blocking means being prepared not to execute
    the code synchronously. It means triggering events and dealing with the result
    later, at some point in time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了事件循环的优势，这是一个非常合理的疑问。尽管在 Python 和 Ruby 中有一些实现，事件循环没有被更广泛地使用的原因之一是，它们需要所有基础架构和代码都是非阻塞的。非阻塞意味着不要同步执行代码。它意味着触发事件，并在稍后的某个时间点处理结果。
- en: On top of all of that, many of the commonly used languages and libraries do
    not provide asynchronous APIs. Callbacks are not present in many languages, and
    anonymous functions do not exist in programming languages such as C. Crucial pieces
    of today's software, such as `libmysqlclient`, do not support asynchronous operations,
    even though part of its internals might use asynchronous task execution. Asynchronous
    DNS resolution is another example that's also not a standard in many systems.
    As another example, you might take, for instance, the manual pages of operating
    systems. Most of them don't even provide us with a way to understand if a particular
    function does I/O or not. These are all evidences that the ability to make asynchronous
    I/O is not present in many of today's fundamental software pieces.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，许多常用的语言和库并不提供异步 API。许多语言中没有回调，像 C 这样的编程语言中也不存在匿名函数。当今软件的至关重要部分，例如 `libmysqlclient`，即使其内部部分可能使用异步任务执行，也不支持异步操作。异步
    DNS 解析也是许多系统并非标准的另一个例子。作为另一个例子，你可能认为操作系统的手动页面就是如此。其中大多数甚至不提供了解特定函数是否执行 I/O 的方法。这些都是当今许多基础软件组件中不存在异步
    I/O 能力的证据。
- en: Even the existing tools that provide these features require developers to have
    a deep understanding of asynchronous I/O patterns to use event loops. It's a difficult
    job to wire up these existing solutions to get something to work while going around
    technical limitations, such as the ones shown in the `libmysqlclient` example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至提供这些功能的现有工具也要求开发者对异步 I/O 模式有深入的了解才能使用事件循环。像 `libmysqlclient` 示例中那样绕过技术限制来让某物工作是一项艰巨的任务。
- en: JavaScript to the rescue
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 前来救援
- en: 'JavaScript was a language created by Brendan Eich in 1995 while working for
    Netscape. It initially only ran in browsers and allowed developers to add interactive
    features to web pages. It is composed of elements that revealed themselves as
    perfect for the event loop:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是由布兰登·艾ich（Brendan Eich）在 1995 年为网景工作时创建的。起初它只在浏览器中运行，并允许开发者在网页中添加交互式功能。它由一些揭示为非常适合事件循环的元素组成：
- en: It has anonymous functions and closures.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有匿名函数和闭包。
- en: It only executes one callback at a time.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它一次只执行一个回调。
- en: I/O is done on DOM via callbacks (for example, `addEventListener`).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 通过回调（例如，`addEventListener`）在 DOM 上进行。
- en: Combining these three fundamental aspects of the language made the event loop
    something natural to anyone used to JavaScript in the browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结合了语言这三个基本方面使得事件循环对于任何习惯了在浏览器中使用 JavaScript 的人来说都是自然而然的事情。
- en: The language's features ended up gearing its developers toward event-driven
    programming.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 语言特性最终使得其开发者倾向于事件驱动编程。
- en: Node.js enters the scene
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 登上舞台
- en: After all these thoughts and questions about I/O and how it should be dealt
    with, Ryan Dahl came up with Node.js in 2009\. It is a JavaScript runtime, based
    on Google's V8 – a JavaScript engine that brings JavaScript to the server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有关于 I/O 以及应该如何处理它的思考和问题之后，瑞恩·达尔（Ryan Dahl）在 2009 年提出了 Node.js。它是一个基于谷歌 V8
    的 JavaScript 运行时 - 一个将 JavaScript 带到服务器的 JavaScript 引擎。
- en: Node.js is asynchronous and single-threaded by design. It has an event loop
    at its core and presents itself as a scalable way to develop backend applications
    that handle thousands of concurrent requests.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 设计上是异步和单线程的。它有一个事件循环作为其核心，并以一种可扩展的方式呈现，用于开发可以处理成千上万个并发请求的后端应用程序。
- en: Event loops provide us with a clean way to deal with concurrency, a topic where
    Node.js contrasts with tools such as PHP or Ruby, which use the thread-per-request
    model. This single-threaded environment grants Node.js users the simplicity of
    not caring about thread-safety problems. It very much succeeds in abstracting
    the event loop and all the issues with synchronous tools from the user, requiring
    little to no knowledge about the event loop itself. Node.js does this by leveraging
    callbacks and, more recently, the use of promises.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环为我们提供了一种干净的方式来处理并发问题，在这方面Node.js与PHP或Ruby等工具不同，后者使用每个请求一个线程的模型。这个单线程环境让Node.js用户可以不必关心线程安全问题。它非常成功地抽象了事件循环以及所有同步工具的问题，用户几乎不需要了解事件循环本身。Node.js通过利用回调和最近承诺（promises）的运用实现了这一点。
- en: Node.js positioned itself as a way to provide a low-level, purely evented, non-blocking
    infrastructure for users to program their applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js将自己定位为为用户提供一个低级别的、纯粹的事件驱动的、非阻塞的基础设施，让他们编程自己的应用程序。
- en: Node.js' rise
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Node.js的崛起
- en: Telling companies and developers that they could leverage their JavaScript knowledge
    to write servers rapidly resulted in a Node.js popularity rise.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉公司和开发者们他们可以利用已有的JavaScript知识迅速地编写服务器，这导致了Node.js的流行度上升。
- en: It didn't take much time for the language to evolve fast since it was released
    and started being used in production by companies of all sizes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它被发布并开始被不同规模的公司在生产环境中使用以来，这种语言很快地发展进化。
- en: Just 2 years after its creation, in 2011, Uber and LinkedIn were already running
    JavaScript on the server. In 2012, Ryan Dahl resigned from the Node.js community's
    day-to-day operations to dedicate himself to research and other projects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在2011年Node.js创建后的仅仅两年，Uber和LinkedIn就已经在服务器上运行JavaScript了。2012年，Ryan Dahl辞去了Node.js社区的日常运营工作，以便致力于研究和其它项目。
- en: 'Estimates say that, in 2017, there were more than 8.8 million instances of
    Node.js running (source: [https://blog.risingstack.com/history-of-node-js/](https://blog.risingstack.com/history-of-node-js/)).
    Today, more than 103 billion packages have been downloaded from **Node Package
    Manager** (**npm**), and there are around 1,467,527 packages published.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 据估计，到2017年，运行Node.js的实例超过880万个（来源：[https://blog.risingstack.com/history-of-node-js/](https://blog.risingstack.com/history-of-node-js/)）。今天，从**Node包管理器**（**npm**）下载的包已经超过1030亿个，发布的包大约有146万7527个。
- en: Node.js is a great platform, there's no questions about that. Pretty much anyone
    who has used it has experienced many of its advantages. Popularity and community
    play a significant role in this. Having a lot of people of very different experience
    levels and backgrounds working with a piece of technology can only push it forward.
    That's what happened – and still happens – with Node.js.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个很好的平台，这一点毫无疑问。基本上任何使用过它的人都会体验到它的许多优点。流行度和社区在其中扮演了重要的角色。有很多不同经验水平和背景的人一起协作开发某项技术，这只能推动它向前发展。这就是Node.js所发生的，并且仍然在发生的事情。
- en: Node.js enabled developers to use JavaScript for lots of varying use cases that
    weren't possible previously. This ranged from robotics, to cryptocurrencies, to
    code bundlers, APIs, and more. It is a stable environment where developers feel
    productive and fast. It will continue its job, supporting companies and businesses
    of different sizes for many years to come.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js让开发者们可以用JavaScript去实现很多之前不可能的用途。这从机器人技术，到加密货币，到代码打包器，API等等都有涉及。它是一个稳定的环境，让开发者们感到高效且速度快。它将继续它的使命，在未来很多年里支持不同规模的公司和企业。
- en: But you've bought this book, so you must believe that Deno has something worth
    exploring, and I can guarantee that it does.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但既然你买了这本书，那说明你相信Deno有一些值得探索的东西，我可以保证它确实如此。
- en: You might be wondering, why bring a new solution to the table when the previous
    one is more than satisfactory? That's what we'll discover next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，既然之前的解决方案已经足够令人满意，为什么还要提出一个新的解决方案呢？我们接下来就会发现答案。
- en: Why Deno?
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么是Deno？
- en: Many things have changed since Node.js was created. More than a decade has passed;
    JavaScript has evolved, as well as the software infrastructure community. Languages
    such as Rust and golang were born and were very important developments in the
    software community. These languages made it much easier to produce native machine
    code while providing a strict and reliable environment for developers to work
    on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Node.js创建以来，许多事情已经改变。十多年过去了，JavaScript也发生了变化，软件基础设施社区也是如此。像Rust和golang这样的语言诞生了，它们在软件社区中是非常重要的发展。这些语言使得生产本地机器代码变得容易，同时为开发者提供一个严格和可靠的环境。
- en: However, this strictness comes at the cost of productivity. Not that developers
    don't feel productive writing those languages, because they do, but you can easily
    argue that productivity is a subject where dynamic languages clearly shine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种严格性是以生产率为代价的。并不是说开发者写这些语言时不觉得生产率低，因为他们确实觉得有生产力，但你可以很容易地争论，生产率是动态语言明显占优势的领域。
- en: The ease and speed of developing dynamic languages makes them a very strong
    contestant when it comes to scripting and prototyping. And when it comes to thinking
    about dynamic languages, JavaScript directly comes to mind.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 动态语言的开发便捷和速度使它们在脚本和原型设计方面成为非常强劲的竞争者。而当考虑到动态语言时，JavaScript立刻浮现在脑海中。
- en: JavaScript is the most used dynamic language and runs in every device with a
    web browser. Due to its heavy usage and giant community, many efforts have been
    put into optimizing it. The creation of organizations such as ECMA International
    has ensured that the language evolves stably and carefully.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是最常用的动态语言，它可以在任何装有网络浏览器的设备上运行。由于它的广泛使用和庞大的社区，人们对它进行了许多优化工作。诸如ECMA
    International等组织的创建确保了该语言稳定而谨慎地发展。
- en: As we saw in the previous section, Node.js played a very successful role in
    bringing JavaScript to the server, opening the door to a huge amount of different
    use cases. It's currently used for many different tasks, including web development
    tooling, creating web servers, and scripting, among many others. At the time of
    its creation, and to enable such use cases, Node.js had to invent concepts for
    JavaScript that didn't exist before. Later, these concepts were discusses by the
    standards' organizations and added to the language differently, making parts of
    Node.js incompatible with its mother language, ECMAScript. A decade has passed,
    and ECMAScript has evolved, as well as the ecosystem around it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节所看到的，Node.js在将JavaScript带到服务器上扮演了非常成功的角色，为大量不同的用例打开了大门。它目前用于许多不同的任务，包括网络开发工具、创建网络服务器和脚本，等等。在其创建之初，为了启用这些用例，Node.js必须为JavaScript发明之前不存在概念。后来，这些概念由标准化组织讨论，并以不同的方式添加到语言中，使得Node.js的部分内容与其母语言ECMAScript不兼容。十年过去了，ECMAScript也发生了变化，围绕它的生态系统也是如此。
- en: '*CommonJS* modules are no longer the standard; JavaScript has ES modules now.
    *TypedArrays* are now a thing, and finally, JavaScript can directly handle binary
    data. Promises and async/await are the go-to way with asynchronous operations.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**CommonJS**模块不再是标准；JavaScript现在有ES模块。**TypedArrays**现在已经存在，最终，JavaScript可以直接处理二进制数据。Promises和async/await是处理异步操作的首选方法。'
- en: These features are available on Node.js, but they must coexist with the non-standard
    features that were created back in 2009 that still need to be maintained. These
    features, and the large number of users that Node.js has, made it difficult and
    slow to evolve the system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在Node.js上是可用的，但它们必须与2009年创建的非标准功能共存，这些功能仍然需要维护。这些功能以及Node.js的大量用户使得系统的发展变得困难且缓慢。
- en: To solve some of these problems, and to keep up with the evolution of the JavaScript
    language, many community projects were created. These projects made it possible
    for us to use the latest features of the language but added things such as a build
    system to many Node.js projects, heavily complicating them. Quoting Dahl, it "*took
    away from the fun of dynamic language scripting*."
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，并跟上JavaScript语言的发展，许多社区项目被创建出来。这些项目使我们能够使用该语言的最新特性，但在许多Node.js项目中加入了诸如构建系统的东西，使得它们变得非常复杂。引用Dahl的话，“*夺走了动态语言脚本的美好*。”
- en: More than 10 years of heavy usage also made it clear that some of the runtime's
    fundamental constructs needed improvement. A lack of a security sandbox was one
    of the major issues. At the time Node.js was created, it was possible for JavaScript
    to access the "outside world" by creating bindings in V8 – the JavaScript engine
    behind it. Even though these bindings enabled I/O features such as reading from
    the filesystem accessing the network, they also broke the purpose of the JavaScript
    sandbox. This decision made it really hard to let the developer control what a
    Node.js script has access to. In its current state, for instance, there's nothing
    preventing a third-party package in a Node.js script to read all the files the
    user has access to, among performing other nefarious actions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 超过 10 年的广泛使用也清楚地表明，运行时的一些基本构建设需要改进。缺乏安全沙箱是主要问题之一。在创建 Node.js 的时候，JavaScript
    可以通过在 V8（它背后的 JavaScript 引擎）中创建绑定来访问“外部世界”。尽管这些绑定使 JavaScript 能够实现诸如从文件系统读取、访问网络等
    I/O 功能，但它们也打破了 JavaScript 沙箱的目的。这个决定使得让开发者控制 Node.js 脚本可以访问的内容变得非常困难。例如，在当前状态下，没有办法阻止
    Node.js 脚本中的第三方包读取用户可以访问的所有文件，以及其他恶意行为。
- en: A decade later, Ryan Dahl and the team behind Deno were missing a fun and productive
    scripting environment that could be used for a wide range of tasks. The team also
    felt like the JavaScript landscape has changed enough that it was worthwhile simplifying,
    and thus they decided to create Deno.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 十年后，Ryan Dahl 和 Deno 背后的团队怀念一个既有趣又高效的脚本环境，可以用于执行各种任务。团队还觉得 JavaScript 景观已经发生了足够大的变化，简化是有价值的，因此他们决定创建
    Deno。
- en: Presenting Deno
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Deno
- en: '"Deno is a simple, modern, and secure runtime for JavaScript and TypeScript
    that uses V8 and is built into Rust." – [https://deno.land/](https://deno.land/)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"Deno 是一个简单、现代且安全的 JavaScript 和 TypeScript 运行时，它使用了 V8 引擎，并内置了 Rust 构建。" –
    [https://deno.land/](https://deno.land/)'
- en: 'Deno''s name was constructed by inverting the syllables of its ancestor''s
    name, no-de, de-no. With a lot of lessons learned from its ancestor, Deno presents
    the following as its main features:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 的名称是通过反转其前身 no-de 的音节而构成的，即 de-no。从它的前身那里学到了很多教训，Deno 提出了以下主要特性：
- en: Secure by default
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下是安全的
- en: First-class TypeScript support
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一等 TypeScript 支持
- en: A single executable file
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一的可执行文件
- en: Provides fundamental tools to write applications
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供编写应用程序的基本工具
- en: Complete and audited standard library
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整且经过审计的标准库
- en: Compatibility with ECMAScript and browser environments
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 ECMAScript 和浏览器环境的兼容性
- en: Deno is secure by default, and it was created like that by design. It ultimately
    leverages the V8 sandbox and provides a strict permission model that enables developers
    to finely control what the code has access to.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Deno 是安全的，并且是按照设计来创建的。它最终利用了 V8 沙箱，并提供了一个严格的权限模型，使开发者能够精确控制代码可以访问的内容。
- en: TypeScript is also first-class supported, meaning developers can choose to use
    TypeScript without any extra configuration. All the Deno APIs are also written
    in TypeScript and thus have correct and precise types and documentation. The same
    is true for the standard library.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 也得到了一等支持，这意味着开发者可以选择不进行任何额外配置就使用 TypeScript。Deno 的所有 API 也都是用 TypeScript
    编写的，因此具有正确和精确的类型和文档。标准库也是如此。
- en: Deno ships a single executable with all the fundamental tools needed to write
    applications; it will always be that way. The team makes an effort to keep the
    executable small (~15 MB) so that we can use it in various situations and environments,
    from simple scripts to full-fledged applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 带有一个单一的可执行文件，其中包含了编写应用程序所需的所有基本工具；它总是这样。团队努力保持可执行文件的小巧（约 15 MB），以便我们可以在各种情况和环境中使用它，从简单的脚本到完整的应用程序。
- en: More than just executing code, the Deno binary provides a complete set of developer
    utilities, namely a linter, a formatter, and a test runner.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是执行代码，Deno 二进制文件提供了一整套开发者工具，具体包括一个代码检查器、一个格式化工具和一个测试运行器。
- en: Golang's carefully polished standard library inspired Deno's standard library.
    It is deliberately bigger and more complete compared to Node.js'. This decision
    was made to address the enormous dependency trees that used to occur in some Node.js
    projects. Deno's core team believes that, by providing a stable and complete standard
    library, it can help address this problem. By removing the need to create third-party
    packages to handle common use cases the platform provides by default, it aims
    to diminish the need to use loads of third-party packages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言精心打磨的标准库激发了Deno标准库的灵感。与Node.js的标准库相比，Deno的标准库故意设计得更大、更完整。这个决定是为了应对一些Node.js项目中曾经出现的庞大的依赖树。Deno的核心团队认为，通过提供一个稳定且完整的标准库，可以帮助解决这个问题。通过移除创建第三方包来处理常见用例的需求，该平台默认提供了这些功能，从而旨在减少使用大量第三方包的必要性。
- en: To keep compatibility with ES6 and browsers, Deno made efforts to mimic browser
    APIs. Things such as performing HTTP requests, dealing with URLs, or encoding
    text, among others, can be done by using the same APIs you'd use in a browser.
    A deliberate effort was made by the Deno team to keep these APIs in sync with
    the browser.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与ES6和浏览器保持兼容，Deno努力模仿浏览器API。执行HTTP请求、处理URL或编码文本等工作，可以通过使用你在浏览器中会使用的相同API来完成。Deno团队故意努力保持这些API与浏览器同步。
- en: Aiming to offer the best of three worlds, Deno provides the prototype-ability
    and developer experience of JavaScript, the type-safety and security offered by
    Typescript, and Rust's performance and simplicity.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 旨在提供三者的最佳特性，Deno提供了JavaScript的原型能力和开发者体验，TypeScript的类型安全和安全性，以及Rust的性能和简洁性。
- en: 'Ideally, as Dahl also mentioned in one of his talks, code would follow the
    following flow in the path from prototype to production: developers can start
    writing JavaScript, migrate to TypeScript, and end up with Rust code.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，正如Dahl在他的一次谈话中提到的，代码应该遵循从原型到生产的以下流程：开发者可以开始写JavaScript，迁移到TypeScript，最终得到Rust代码。
- en: At the time of writing, is it only possible to run JavaScript and TypeScript.
    Rust is only available via a (still unstable) plugin API that might become stable
    in a not-so-distant future.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，只能运行JavaScript和TypeScript。Rust只能通过一个（仍然不稳定的）插件API来使用，这可能在不太遥远的将来可能会变得稳定。
- en: A web browser for command-line scripts
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行脚本的网络浏览器。
- en: As time passed, the Node.js module system evolved into something that is now
    overly complex and painful to maintain. It takes into consideration edge cases
    such as importing folders, searching for dependencies, importing relative files,
    searching for index.js, third-party packages, and reading the `package.json` file,
    among others.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Node.js模块系统演变成现在过于复杂且维护痛苦的东西。它考虑了诸如导入文件夹、搜索依赖项、导入相对文件、搜索index.js、第三方包和读取`package.json`文件等边缘情况。
- en: It also got heavily coupled with **npm**, the **Node Package Manager**, which
    was initially part of Node.js itself but separated in 2014\.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它也与**npm**（**Node包管理器**）紧密耦合，后者最初是Node.js的一部分，但在2014年分离出来。
- en: Having a centralized package manager is not very webby, to use Dahl's words.
    The fact that millions of applications depend on a single registry to survive
    is a liability.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个集中式的包管理器并不非常符合网络化，借用Dahl的话来说。数百万应用程序依赖于一个单一的注册表来生存，这是一个负担。
- en: 'Deno solves this problem by using URLs. It takes an approach that''s very similar
    to a browser, only requiring an absolute URL to a file to execute or import code.
    This absolute URL can be local, remote, or HTTP-based and includes the following
    file extension:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Deno通过使用URL来解决这个问题。它采取了一种与浏览器非常相似的方法，只需要一个到文件的绝对URL就可以执行或导入代码。这个绝对URL可以是本地、远程或基于HTTP的，并包括以下文件扩展名：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code happens to be the same code you would write on a browser
    inside a `<script>` tag if you want to require an ES module.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码碰巧就是你在浏览器中在`<script>`标签内想要引入ES模块时会写的相同代码。
- en: In regard to installation and offline usage, Deno ensures that users don't have
    to worry about that by using a local cache. When the program runs, it installs
    all the required dependencies, removing the need for an installation step. We'll
    dive into this later in more depth later, in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安装和离线使用，Deno通过使用本地缓存确保用户不必为此担心。当程序运行时，它会安装所有必需的依赖项，从而消除了安装步骤。我们稍后会在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)更深入地探讨这一点，*工具链*。
- en: Now that we are comfortable with what Deno is and the problems it solves, we're
    in good shape to go beyond the surface. By knowing what is happening behind the
    scenes, we can get a better comprehension of Deno itself.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Deno是什么以及它解决的问题，我们就可以深入了解。通过了解幕后发生的事情，我们可以更好地理解Deno本身。
- en: In the next section, we'll explore technologies that support Deno and how they
    connect.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨支持Deno的技术以及它们是如何连接的。
- en: Architecture and technologies that support Deno
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持Deno的架构和技术
- en: Architecture-wise, Deno took various topics into consideration such as security.
    Deno put much thought into establishing a clean and performant way of communicating
    with the underlying OS without leaking details to the JavaScript side. To enable
    that, Deno uses message-passing to communicate from inside the V8 to the Deno
    backend. The backend is the component written in Rust that interacts with the
    event loop and thus with the OS.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构上讲，Deno考虑了诸如安全等各种主题，如与底层操作系统通信的干净且高效的通信方式，而不会泄露细节给JavaScript端。为了实现这一点，Deno使用消息传递从V8内部与Deno后端通信。后端是用Rust编写的组件，与事件循环交互，进而与操作系统交互。
- en: 'Deno has been made possible by four pieces of technology:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Deno是由四项技术实现的：
- en: V8
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V8
- en: TypeScript
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript
- en: Tokio (event loop)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tokio (事件循环)
- en: Rust
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust
- en: 'It is the connection of all those four parts that make it possible to provide
    developers with a great experience and development speed while keeping the code
    safe and sandboxed. If you are not familiar with these pieces of technology, I''ll
    leave a short definition:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这四个部分的结合，使得它能够在保证代码安全和沙盒化的同时，为开发者提供出色的体验和开发速度。如果你不熟悉这些技术，我会留下一个简短的定义：
- en: '**V8** is a JavaScript engine developed by Google. It is written in C++ and
    runs across all major operating systems. It is also the engine behind Chrome,
    Node.js, and others.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**V8** 是谷歌开发的JavaScript引擎。它用C++编写，可以在所有主流操作系统上运行。它还是Chrome、Node.js等浏览器的引擎。'
- en: '**TypeScript** is a superset of JavaScript developed by Microsoft that adds
    optional static typing to the language and *transpiles* it to JavaScript.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript** 是微软开发的一种超集JavaScript，它为语言添加了可选的静态类型，并*编译*成JavaScript。'
- en: '**Tokio** is an asynchronous runtime for Rust that provides utilities to write
    network applications of any scale.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tokio** 是为Rust提供编写任何规模网络应用程序的异步运行时。'
- en: '**Rust** is a server-side language designed by Mozilla focused on performance
    and safety.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rust** 是Mozilla设计的专注于性能和安全的服务器端语言。'
- en: Using Rust, a fast-growing language, to write Deno's core made it more approachable
    for developers than Node.js. Node.js' core was written in C++, which is not known
    for being exceptionally easy to deal with. With many pitfalls and with a not-so-good
    developer experience, C++ revealed itself as a small obstacle in the evolution
    of Node.js core.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速发展语言Rust编写Deno的核心，使其比Node.js更受开发者欢迎。Node.js的核心是用C++编写的，这并不以特别容易处理著称。由于许多陷阱和不太好的开发者体验，C++在Node.js核心的发展中显示出是一个小障碍。
- en: '`Deno_core` is shipped as a Rust crate (package). This connection with Rust
    is not a coincidence. Rust provides many features that facilitate this connection
    with JavaScript and adds capabilities to Deno itself. Asynchronous operations
    in Rust typically use Futures that map very well with JavaScript Promises. Rust
    is also an embeddable language, and that provides direct embedding capabilities
    to Deno. This added to Rust being one of the first languages to create a compiler
    for *WebAssembly*, made the Deno team choose it for its core.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deno_core`作为Rust crate（包）分发。Rust与Rust之间的这种联系并非巧合。Rust提供了许多功能，使与JavaScript的连接变得容易，并增加了Deno本身的
    capabilities. Asynchronous operations in Rust typically use Futures that map very
    well with JavaScript Promises. Rust is also an embeddable language, and that provides
    direct embedding capabilities to Deno. This added to Rust being one of the first
    languages to create a compiler for *WebAssembly*, made the Deno team choose it
    for its core.'
- en: Inspiration from POSIX systems
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自POSIX系统的灵感
- en: POSIX systems were of great inspiration to Deno. In one of his talks, Dahl even
    states that Deno handles some of its tasks *"as an operating system"*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX系统对Deno有很大的启发。在他的一次演讲中，Dahl甚至提到Deno处理某些任务*“就像一个操作系统”*。
- en: 'The following table shows some of the standard terms from POSIX/Linux systems
    and how they map to Deno concepts:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的表格显示了来自POSIX/Linux系统的标准术语以及它们如何映射到Deno概念：
- en: '![](img/Table_1.1_B16380.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_1.1_B16380.jpg)'
- en: Some of the concepts from the Linux world might be familiar to you. Let's take,
    for instance, processes. They represent an instance of a running program that
    might execute using one or multiple threads. Deno uses WebWorkers to do the same
    job inside the runtime.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一些来自 Linux 世界的概念你可能很熟悉。比如说进程。它们代表了一个正在运行的程序的实例，该程序可能使用一个或多个线程执行。Deno 使用 WebWorker
    在运行时完成同样的任务。
- en: In the second row, we have syscalls. If you aren't familiar with them, they
    are the way for programs to perform requests to the kernel. In Deno, these requests
    do not go directly to the kernel; instead, they go from the Rust core to the underlying
    operating system, but they work similarly. We'll have the opportunity to see this
    in the upcoming architecture diagram.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们有系统调用。如果你不熟悉它们，它们是程序向内核发出请求的方式。在 Deno 中，这些请求并不直接发送到内核；相反，它们从 Rust 核心发送到底层操作系统，但它们的工作方式相似。我们接下来有机会在即将到来的架构图中看到这一点。
- en: These are just a couple of examples you might recognize if you are familiar
    with Linux/POSIX systems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是如果你熟悉 Linux/POSIX 系统你可能认出的几个例子。
- en: We'll explain and use most of the aforementioned Deno concepts throughout the
    rest of this book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的剩余部分解释和使用上述大部分 Deno 概念。
- en: Architecture
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: Deno's core was initially written in *golang*, but it later changed to Rust.
    This decision was made to get away from *golang* as it is a garbage-collected
    language. Its combination with V8's garbage collector could lead to problems in
    the future.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 的核心最初是用 *golang* 编写的，但后来改用 Rust。这个决定是为了摆脱 *golang*，因为它是一个垃圾收集语言。它与 V8 的垃圾收集器的组合可能会导致未来的问题。
- en: 'To understand how the underlying technologies interact with each other to form
    the Deno core, let''s look at the following architecture diagram for it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解底层技术如何相互作用形成 Deno 核心，让我们看一下以下架构图：
- en: '![Figure 1.3 – Deno architecture'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – Deno 架构'
- en: '](img/Figure_1.3_B16380.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B16380.jpg)'
- en: Figure 1.3 – Deno architecture
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – Deno 架构
- en: Deno uses message passing to communicate with the Rust backend. As a decision
    in regard to privilege isolation, Deno never exposes JavaScript object handles
    to Rust. All communication in and out of V8 uses `Uint8Array` instances.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 使用消息传递与 Rust 后端进行通信。作为一个关于权限隔离的决策，Deno 从不向 Rust 暴露 JavaScript 对象句柄。V8 内部和外部的所有通信都使用
    `Uint8Array` 实例。
- en: For the event loop, Deno uses Tokio, a Rust thread pool. Tokio is responsible
    for handling I/O work and calling back the Rust backend, making it possible to
    handle all operations asynchronously. **Operations** (**ops**) is the name given
    to the messages that are passed back and forth between Rust and the event loop.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事件循环，Deno 使用 Tokio，一个 Rust 线程池。Tokio 负责处理 I/O 工作和回调 Rust 后端，使其能够异步处理所有操作。**操作**（**ops**）是
    Rust 和事件循环之间来回传递的消息的名称。
- en: All the asynchronous messages dispatched from Deno's code into its core (written
    in Rust) return **Promises** back to Deno. To be more precise, asynchronous operations
    in Rust usually return **Futures**, which Deno maps to JavaScript Promises. Whenever
    these **Futures** are resolved, the JavaScript **Promises** are also resolved.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从 Deno 代码发送到其核心（用 Rust 编写）的异步消息都会返回**承诺**给 Deno。更准确地说，Rust 中的异步操作通常返回**未来**，Deno
    将它们映射到 JavaScript 承诺。每当这些**未来**被解决，JavaScript 的**承诺**也同样被解决。
- en: To enable communication from V8 to the Rust backend, Deno uses `rusty_v8`, a
    Rust crate created by the Deno team that provides V8 bindings to Rust.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 V8 能够向 Rust 后端发送消息，Deno 使用 `rusty_v8`，这是由 Deno 团队创建的 Rust 库，它提供了 V8 到 Rust
    的绑定。
- en: Deno also includes the TypeScript compiler right inside V8\. It uses V8 snapshots
    for startup time optimization. Snapshots are used for saving the JavaScript heap
    at a specific execution time and restoring it when needed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 还将在 V8 内部包含 TypeScript 编译器。它使用 V8 快照进行启动时间优化。快照用于在特定的执行时间保存 JavaScript
    堆，并在需要时恢复它。
- en: Since it was first presented, Deno was subject to an iterative, evolutionary
    process. If you are curious about how much it changed, you can look at one of
    the initial roadmap documents written back in 2018 by Ryan Dahl ([https://github.com/ry/deno/blob/a836c493f30323e7b40e988140ed2603f0e3d10f/Roadmap.md](https://github.com/ry/deno/blob/a836c493f30323e7b40e988140ed2603f0e3d10f/Roadmap.md)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它首次提出以来，Deno 一直受到迭代、进化过程的制约。如果你好奇它变化了多少，你可以查看 2018 年由 Ryan Dahl 写的最初路线图文档([https://github.com/ry/deno/blob/a836c493f30323e7b40e988140ed2603f0e3d10f/Roadmap.md](https://github.com/ry/deno/blob/a836c493f30323e7b40e988140ed2603f0e3d10f/Roadmap.md))。
- en: Now, not only do we know what Deno is, but we also know what's happening behind
    the scenes. This knowledge will help us in the future when we're running and debugging
    our applications. The creators of Deno made many technological and architectural
    decisions to bring Deno to the state it is today. These decisions pushed the runtime
    forward and made sure Deno excels in several situations, some of which we'll later
    explore. However, to make it work well for some use cases, some trade-offs had
    to be made. Those trade-offs resulted in the limitations we'll examine next.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅知道Deno是什么，也知道它背后的幕后工作。这些知识将帮助我们在将来运行和调试我们的应用程序。Deno的创造者做出了许多技术和架构决策，将Deno带到今天这个状态。这些决策推动了运行时的进步，并确保Deno在几种情况下都能表现出色，其中一些我们稍后会探讨。然而，为了使其在某些用例中表现良好，必须做出一些权衡。这些权衡导致了我们接下来要探讨的限制。
- en: Grasping Deno's limitations
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握Deno的限制
- en: As with everything, choosing solutions is a matter of dealing with trade-offs.
    The ones that adapt best to the projects and applications we're writing are what
    we end up using. Currently, Deno has some limitations; some of them due to its
    short lifetime, others because of design decisions. As it happens with most solutions,
    Deno is also not a one-size-fits-all tool. In the next few pages, we'll explore
    some of the current limitations of Deno and the motivations behind them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有事情一样，选择解决方案是处理权衡的问题。那些最适合我们正在编写的项目和应用程序的解决方案是我们最终会使用的。目前，Deno有一些限制；有些是由于它短暂的寿命，其他则是因为设计决策。像大多数解决方案一样，Deno也不是一个万能的工具。在接下来的几页中，我们将探讨Deno当前的一些限制以及背后的动机。
- en: Not as stable as Node.js
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不如Node.js稳定
- en: In its current state, Deno can't be compared to Node.js regarding stability
    for obvious reasons. Node.js has more than 10 years of development, while Deno
    is only nearing its second year.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，Deno在稳定性方面无法与Node.js相提并论，这是显而易见的原因。Node.js有超过10年的发展，而Deno只剩下接近两年的寿命。
- en: Even though most of the core features presented in this book are already considered
    stable and correctly versioned, there are still features that are subject to change,
    and live under the unstable flag.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书中介绍的大部分核心功能已经被认为是稳定且版本正确的，但仍然有一些功能可能会发生变化，并且标有不稳定标志。
- en: Node.js's years of experience made sure it is battle-tested and that it works
    in the most diversified environments. That's something we're hopeful Deno will
    get, but time and adoption are essential factors.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js多年的经验确保了它经过了实战考验，并且可以在最多样化的环境中工作。这是我们希望Deno能够获得的，但时间和采用是关键因素。
- en: Better HTTP latency but worse throughput
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的HTTP延迟，但吞吐量更差
- en: Deno keeps performance on track from the beginning. However, as seen on the
    benchmarks page ([https://deno.land/benchmarks](https://deno.land/benchmarks)),
    there are topics where it is still not at Node.js' level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Deno从一开始就保持性能。然而，如基准页面所示（[https://deno.land/benchmarks](https://deno.land/benchmarks)），在某些主题上，它仍然不是Node.js的水平。
- en: Its ancestor leverages the direct bindings with C++ on the HTTP server to amplify
    this performance score. Since Deno resisted to add native HTTP bindings and builds
    on top of native TCP sockets, it still suffers from a performance penalty. This
    decision is something that the team plans to tackle after optimizing TCP socket
    communication.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它的祖先利用了直接与C++绑定在HTTP服务器上，从而提高这个性能分数。由于Deno抵制添加本地的HTTP绑定并在本地的TCP套接字之上构建，它仍然承受着性能上的惩罚。这个决定是团队计划在优化TCP套接字通信之后解决的问题。
- en: The Deno HTTP server handles about 25k requests per second with a max latency
    of 1.3 milliseconds, while Node.js handles 34k requests but has a latency that
    varies between 2 and 300 milliseconds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Deno HTTP服务器每秒处理大约25k个请求，最大延迟为1.3毫秒，而Node.js处理34k个请求，但延迟在2到300毫秒之间变化。
- en: We can't say 25k requests per second is not enough, especially since we're using
    JavaScript. If your app/website needs more than that, probably JavaScript, and
    thus Deno, is not the correct tool for the job.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法说每秒25k请求不够，尤其是当我们使用JavaScript时。如果你的应用/网站需要的请求量超过这个数字，那么JavaScript，以及因此Deno，可能不是这个工作的正确工具。
- en: Compatibility with Node.js
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Node.js的兼容性
- en: Due to many of the changes that have been introduced, Deno doesn't provide compatibility
    with existing JavaScript packages and tooling. A compatibility layer is being
    created on the standard library, but it is still not close to finished.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多已经引入的更改，Deno不提供与现有JavaScript包和工具的兼容性。一个兼容层正在标准库上创建，但它仍然远远没有完成。
- en: As Node.js and Deno are two very similar systems with shared goals, we expect
    the latter to execute more and more Node.js programs out of the box as time goes
    on. However, and even though some Node.js code is currently runnable, that is
    not the case currently.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 和 Deno 是两个非常相似的系统，有着共同的目标，我们预计随着时间的推移，Deno 将能够默认执行越来越多的 Node.js 程序。然而，尽管目前有些
    Node.js 代码是可以运行的，但目前并非如此。
- en: TypeScript compiler speed
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 编译器速度
- en: As we mentioned previously, Deno uses the TypeScript compiler. It reveals itself
    as one of the slowest parts of the runtime, especially compared to the time V8
    takes to interpret JavaScript. Snapshots do help with this, but this is not enough.
    Deno's core team believes that they will have to migrate the TypeScript compiler
    to Rust to fix it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Deno 使用 TypeScript 编译器。它作为运行时最慢的部分表现出来，尤其是与 V8 解释 JavaScript 的时间相比。快照在这方面有所帮助，但这还不够。Deno
    的核心团队认为他们可能需要将 TypeScript 编译器迁移到 Rust 来解决这个问题。
- en: Due to the extensive work required to complete this task, this is probably not
    going to happen anytime soon, even though it's supposed to be one of the things
    that would make its startup time orders of magnitude faster.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完成这项任务需要做大量的工作，这可能不会很快实现，尽管这应该是使其启动时间快得多的事情之一。
- en: Lack of plugins/extensions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏插件/扩展
- en: Even though Deno has a plugin system to support custom operations, it is not
    finished yet and is considered unstable. This means that extending native functionality
    to more than what Deno makes available is virtually impossible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Deno 有一个插件系统来支持自定义操作，但它还没有完成，被认为是不稳定的。这意味着将本地功能扩展到比 Deno 提供的更多是几乎不可能的。
- en: At this point, we should understand Deno's current limitations and why they
    exist. Some of them might be resolved soon, as Deno matures and evolves. Others
    are the result of design decisions or roadmap priorities. Understanding these
    limitations is fundamental when it comes to deciding if you should use Deno in
    a project. In the next section, we will have a look at the use cases we believe
    Deno is the perfect fit for.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该理解 Deno 目前的限制以及这些限制存在的原因。其中一些可能随着 Deno 的成熟和演变而很快得到解决。其他的则是设计决策或路线图优先级的结果。理解这些限制在决定是否在项目中使用
    Deno 时至关重要。在下一节中，我们将看看我们认为 Deno 非常适合的用例。
- en: Exploring use cases
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索用例
- en: As you are probably aware by now, Deno by itself has a lot of use cases in common
    with Node.js. Most of the changes that were made were to ensure the runtime is
    safer and more straightforward, but as it leverages most of the same pieces of
    technology, shares the same engine, and many of the same goals, the use cases
    can't differ by much.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经意识到的，Deno 本身与 Node.js 有许多共同的用例。大多数所做的更改都是为了确保运行时更安全、更简单，但随着它利用了大多数相同的技术，拥有相同的引擎，以及许多相同的目标，用例之间的差异不会太大。
- en: However, and even though the differences are not that big, there may be small
    nuances that will make one a slightly better fit than the other in specific situations.
    In this section, we will explore some use cases for Deno.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管差异并不大，可能存在一些微小的细微差别，这使得在特定情况下其中一个比另一个稍微更适合。在本节中，我们将探讨一些 Deno 的用例。
- en: A flexible scripting language
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活的脚本语言
- en: Scripting is one of those features where interpreted languages always shine.
    JavaScript is perfect when we want to prototype something fast. This can be renaming
    files, migrating data, consuming something from an API, and so on. It just feels
    like the right tool for these use cases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编程是那些解释型语言总是闪耀光芒的功能之一。当我们想要快速原型化某件事时，JavaScript 是完美的。这可以包括重命名文件、迁移数据、从 API
    中消费内容等等。它似乎是这些用例的正确工具。
- en: Deno looked at scripting with much consideration. The runtime itself makes it
    very easy for users to write scripts with it, thus providing many benefits for
    this use case, especially compared to Node.js. These benefits are being able to
    execute code with just a URL, not having to manage dependencies, and the ability
    to create an executable based on Deno.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 对脚本编程给予了深思熟虑。运行时本身让用户用它来写脚本变得非常容易，从而在这方面的使用场景中提供了许多好处，特别是与 Node.js 相比。这些好处包括仅用一个
    URL 就能执行代码，无需管理依赖项，以及基于 Deno 创建可执行文件的能力。
- en: On top of all of this, the fact that you can now import remote code while controlling
    which permissions it uses is a significant step in terms of trust and security.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之上，你现在可以导入远程代码，同时控制它使用的权限，这在信任和安全方面是一个重大的步骤。
- en: Deno's **Read Eval Print Loop** (**REPL**) is a great place to do experimentation
    work. Adding to what we mentioned previously, the small size of the binary and
    the fact it includes all the needed tools is the cherry on top of the cake.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Deno的**读取-评估-打印循环** (**REPL**) 是进行实验工作的好地方。在我们之前提到的基础上，二进制文件的小巧以及它包含所有所需工具的事实是蛋糕上的樱桃。
- en: Safer desktop applications
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更安全的桌面应用程序
- en: Although the plugin system is not stable yet and the packages that allow developers
    to create desktop applications depend heavily on that, it is very promising.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管插件系统还不稳定，允许开发者创建桌面应用程序的包很大程度上依赖于它，但它非常有前景。
- en: During the last few years, we've seen the rise of desktop web applications.
    The rise of the Electron framework ([https://www.electronjs.org/](https://www.electronjs.org/))
    enabled applications such as VS Code or Slack to be created. These are web pages
    running inside a WebView with access to native features that are part of many
    people's daily lives.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，我们见证了桌面网络应用程序的兴起。Electron框架的兴起（[https://www.electronjs.org/](https://www.electronjs.org/)）使可以创建像VS
    Code或Slack这样的应用程序。这些是运行在WebView中的网页，可以访问本地功能，是许多人日常生活的一部分。
- en: However, for users to install these applications, they must trust them blindly.
    Previously, we discussed security and how JavaScript code used to have access
    to all the systems where it ran. Deno is fundamentally different here since, due
    to its sandbox and all its security features, this is much safer, and the potential
    that's unlocked is enormous.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于用户来说安装这些应用程序，他们必须盲目地信任它们。之前，我们讨论了安全性以及JavaScript代码曾经可以访问它运行的所有系统。Deno在这里从根本上不同，因为由于其沙盒和所有的安全特性，这要安全得多，并且解锁的潜力巨大。
- en: We'll be looking at lots of advances in using JavaScript to build desktop applications
    in Deno throughout this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将探讨如何使用JavaScript在Deno中构建桌面应用程序的大量进展。
- en: A quick and complete environment to write tools
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写工具的快速而完整的环境
- en: Deno's features position it as a very complete, simple, and fast environment
    to write tooling in. When we say tooling, this is not only tooling for JavaScript
    or TypeScript projects. As the single binary contains everything needed to develop
    an application, we can use Deno in ecosystems outside of the JavaScript world.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Deno的功能使它成为一个非常完整、简单且快速的编写工具的环境。当我们说工具时，这不仅仅是针对JavaScript或TypeScript项目的工具。由于单一的二进制文件包含了开发应用程序所需的所有内容，我们可以将Deno用于JavaScript世界之外的生态系统。
- en: Its clarity, automatic documentation via TypeScript, ease of running, and the
    popularity of JavaScript make Deno the right cocktail for writing tools such as
    code generators, automation scripts, or any other developer tools.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 它的清晰性、通过TypeScript自动生成文档、易于运行以及JavaScript的普及性，使Deno成为编写工具（如代码生成器、自动化脚本或其他开发工具）的正确组合。
- en: Running on embedded devices
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在嵌入式设备上运行
- en: By using Rust and distributing the core as a Rust crate, Deno automatically
    enables usage in embedded devices, from IoT devices to wearables and ARM devices.
    Again, the fact that it is small and includes all the tools in the binary might
    be a great win.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Rust并将核心作为Rust crate分发，Deno自动启用了在嵌入式设备上的使用，从IoT设备到可穿戴设备和ARM设备。再次，它的小巧以及包含所有工具的二进制文件可能是一个巨大的胜利。
- en: The fact that the crate is made available standalone allows people to embed
    Deno in different places. For instance, when writing a database in Rust and wanting
    to add Map-Reduce logic, we can use JavaScript and Deno to do so.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 箱子可以独立提供的事实允许人们在不同地方嵌入Deno。例如，当用Rust编写数据库并且想要添加Map-Reduce逻辑时，我们可以使用JavaScript和Deno来实现。
- en: Generating browser-compatible code
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成浏览器兼容代码
- en: If you haven't had a look at Deno before, then this probably comes as a surprise.
    Aren't we talking about a server-side runtime? We are. But this same server-side
    runtime has been making efforts to keep the API's browser compatible. It provides
    features in its toolchain that enable code to be written in Deno and executed
    in the browser, as we'll explore in [*Chapter 7*](B16380_07_Final_JM_ePub.xhtml#_idTextAnchor165),
    *HTTPS, Extracting Configuration, and Deno in the Browser.*
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有看过Deno，那么这可能是个惊喜。我们不是在谈论服务器端运行时吗？是的。但这个服务器端运行时一直在努力保持API的浏览器兼容性。它在工具链中提供了特性，使代码可以写在Deno中并在浏览器中执行，这将在[第7章](B16380_07_Final_JM_ePub.xhtml#_idTextAnchor165)
    *HTTPS、提取配置和Deno在浏览器中* 中探索。
- en: All of this is taken care of by the Deno team, which keeps its APIs browser-compatible
    and generates browser code that opens a new set of possibilities yet to be discovered.
    Browser compatibility is something we will use later in this book, in [*Chapter
    7*](B16380_07_Final_JM_ePub.xhtml#_idTextAnchor165), *HTTPS, Extracting Configuration,
    and Deno in the Browser* to build a Deno application by writing a complete application,
    client, and server inside Deno.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的这些工作都由Deno团队负责，他们使自己的API保持与浏览器兼容，并生成可以在浏览器中打开新可能性集的浏览器代码。浏览器兼容性是我们在本书后面将会使用到的内容，在[第7章](B16380_07_Final_JM_ePub.xhtml#_idTextAnchor165)
    *HTTPS、提取配置和Deno在浏览器中* 中，通过编写一个完整的应用程序、客户端和服务器来构建一个Deno应用程序。（注：这里原文中的“in this
    book”翻译为“在本书后面”，以保持上下文的连贯性。）
- en: Full-fledged APIs
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全面的API
- en: Deno, like Node.js,, puts lots of effort into dealing with HTTP servers. With
    a complete standard library providing great primitives for frameworks to write
    on top of, there is no doubt that APIs are among the strongest Deno use cases.
    TypeScript is a great addition here in terms of documentation, code generation,
    and static type checking, helping mature code bases scale.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Deno和Node.js一样，在处理HTTP服务器方面投入了大量精力。拥有一个完整的标准库，为框架提供伟大的基础，毫无疑问，API是Deno最强大的用例之一。TypeScript在文档、代码生成和静态类型检查方面是一个很好的补充，帮助成熟的代码库扩展。
- en: We'll be focusing more on this specific use case throughout the rest of this
    book as we believe it to be one of the most important ones – one where Deno shines.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的剩余部分更多地关注这个具体的用例，因为我相信这是最重要的用例之一——Deno发挥光彩的地方。
- en: These are just a few examples of use cases where we believe Deno is a great
    fit. As with Node.js, we're also aware that there are many new uses to discover.
    We're excited to accompany this adventure and see what it still has to unveil.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们认为Deno非常适合的用例的几个例子。与Node.js一样，我们也知道还有许多新的用途等待发现。我们很高兴能陪伴这个冒险，并看到它还将揭示什么。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we traveled back in time to 2009 to understand the creation
    of Node.js. After that, we realized why and when we should use the event-driven
    approach compared to a threaded model and the advantages it brings. We came to
    understand what evented, asynchronous code is and how JavaScript helped Node.js
    and Deno make the most out of the server's resources.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书这一章中，我们穿越回2009年，以理解Node.js的创建。在那之后，我们意识到与线程模型相比，为什么要使用事件驱动的方法，以及它带来的优势。我们了解到事件驱动、异步代码是什么，以及JavaScript如何帮助Node.js和Deno充分利用服务器的资源。
- en: After that, we fast-forwarded through the Node.js' 10+ year story, its evolution,
    and how its adoption started. We observed how the runtime grew, together with
    its base language, JavaScript, while helping millions of businesses deliver great
    products to its clients.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，我们快速浏览了Node.js的10多年的历史、它的演变以及它的采用开始的情况。我们观察到运行时如何与它的基础语言JavaScript一起增长，同时帮助数百万企业将其伟大的产品带给客户。
- en: Then, we took a modern look at Node.js, with today's eyes. What changed in the
    ecosystem and the language? What are some of the developers' pain points? We dived
    into these pain points and explored why it was difficult and slow to change Node.js
    to solve them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用今天的眼光来看Node.js，生态和语言发生了什么变化？开发者遇到了哪些痛点？我们深入这些痛点，探讨为什么改变Node.js来解决这些问题既困难又缓慢。
- en: As this chapter progressed, Deno's motivations became more and more evident.
    After looking at the past of JavaScript on the server, it made sense for something
    new to appear – something that would solve the pain experienced previously while
    keeping the things developers love.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的进展，Deno的动机变得越来越明显。在查看了JavaScript在服务器端的历史之后，出现一些新东西是合理的——一些可以解决以前经历的痛苦同时保留开发者所喜爱的东西的东西。
- en: Finally, we got to know Deno, which will be our friend for this book. We learned
    its vision, principles, and how it offers to solve certain problems. After having
    a sneak peek at the architecture and the components that made Deno possible, we
    couldn't finish without talking about some of the trade-offs and current limitations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了Deno，它将成为我们这本书的朋友。我们学习了它的愿景、原则以及它如何解决某些问题。在简要介绍了使其成为可能的基础架构和组件之后，我们不禁要谈论一些权衡和当前的限制。
- en: We concluded this chapter by listing use cases where Deno is an excellent fit.
    We will come back to these use cases later in this book, when we start coding.
    From this chapter on, our approach will be more concrete and practical, always
    moving toward code and examples you can run and explore.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过列举Deno适用的一些用例来结束这一章。稍后在本书中，当我们开始编程时，我们会回到这些用例。从这一章开始，我们的方法将更加具体和实用，始终朝着编写可以运行和探索的代码和示例前进。
- en: Now that we understand what Deno is, we have all it takes to start using it.
    In the next chapter, we will set up the respective environment and write a Hello
    World application, among doing many other exciting things.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了Deno是什么，我们就有了开始使用它的所有必要条件。在下一章中，我们将设置相应的环境并编写一个Hello World应用程序，同时做许多其他令人兴奋的事情。
- en: That's how exciting adventures start, right? Let's go!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，激动人心的冒险开始了，对吧？让我们出发吧！
