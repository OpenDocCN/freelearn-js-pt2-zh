- en: Chapter 9. Server-Side JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章．服务器端JavaScript
- en: We have been focusing so far on the versatility of JavaScript as the language
    of the browser. It speaks volumes about the brilliance of the language given that
    JavaScript has gained significant popularity as a language to program scalable
    server systems. In this chapter, we will look at Node.js. Node.js is one of the
    most popular JavaScript frameworks used for server-side programming. Node.js is
    also one of the most watched project on GitHub and has superb community support.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在关注JavaScript作为浏览器语言的多样性。考虑到JavaScript已经作为一种可编程可扩展服务器系统的语言获得了显著的流行，这充分说明了这种语言的辉煌。在本章中，我们将介绍Node.js。Node.js是最受欢迎的JavaScript框架之一，用于服务器端编程。Node.js也是GitHub上最受关注的项目之一，并且拥有非常出色的社区支持。
- en: Node uses V8, the virtual machine that powers Google Chrome, for server-side
    programming. V8 gives a huge performance benefit to Node because it directly compiles
    the JavaScript into native machine code over executing bytecode or using an interpreter
    as a middleware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使用V8，这是为Google Chrome提供动力的虚拟机，来进行服务器端编程。V8给Node.js带来了巨大的性能提升，因为它直接将JavaScript编译成本地机器代码，而不是执行字节码或使用解释器作为中间件。
- en: 'The versatility of V8 and JavaScript is a wonderful combination—the performance,
    reach, and overall popularity of JavaScript made Node an overnight success. In
    this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: V8和JavaScript的多样性是一种美好的组合——性能、覆盖面以及JavaScript的整体流行度使得Node.js一夜之间取得了成功。在本章中，我们将涵盖以下主题：
- en: An asynchronous evented-model in a browser and Node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器和服务器端Node.js中的异步事件模型
- en: Callbacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Timers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: EventEmitters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件发射器
- en: Modules and npm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和npm
- en: An asynchronous evented-model in a browser
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器中的异步事件模型
- en: Before we try to understand Node, let's try to understand JavaScript in a browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试理解Node.js之前，让我们先来理解一下浏览器中的JavaScript。
- en: Node relies on event-driven and asynchronous platforms for server-side JavaScript.
    This is very similar to how browsers handle JavaScript. Both the browser and Node
    are event-driven and non-blocking when they use I/O.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js依赖于事件驱动和异步的平台来进行服务器端JavaScript的编程。这与浏览器处理JavaScript的方式非常相似。当浏览器和Node.js在进行I/O操作时，都是事件驱动和非阻塞的。
- en: 'To dive deeper into the event-driven and asynchronous nature of Node.js, let''s
    first do a comparison of the various kinds of operations and costs associated
    with them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解Node.js的事件驱动和异步特性，让我们首先比较一下各种操作及其相关的成本：
- en: '| L1 cache read | 0.5 nanoseconds |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 从L1缓存读取 | 0.5 纳秒 |'
- en: '| L2 cache read | 7 nanoseconds |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 从L2缓存读取 | 7 纳秒 |'
- en: '| RAM | 100 nanoseconds |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 读取RAM | 100 纳秒 |'
- en: '| Read 4 KB randomly from SSD | 150,000 ns |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 从SSD随机读取4 KB | 150,000 纳秒 |'
- en: '| Read 1 MB sequentially from SSD | 1,000,000 ns |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 从SSD顺序读取1 MB | 1,000,000 纳秒 |'
- en: '| Read 1 MB sequentially from disk | 20,000,000 ns |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 从磁盘顺序读取1 MB | 20,000,000 纳秒 |'
- en: 'These numbers are from [https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)
    and show how costly **Input/Output** (**I/O**) can get. The longest operations
    taken by a computer program are the I/O operations and these operations slow down
    the overall program execution if the program keeps waiting on these I/O operations
    to finish. Let''s see an example of such an operation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字来自[https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)，展示了**输入/输出**（**I/O**）可能有多么昂贵。计算机程序中最耗时的操作就是I/O操作，如果程序一直在等待这些I/O操作完成，这些操作就会降低整个程序的执行效率。让我们来看一个这样的操作示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you call `fileSystemReader.read()`, you are reading a file from the filesystem.
    As we just saw, I/O is the bottleneck here and can take quite a while before the
    read operation is completed. Depending on the kind of hardware, filesystem, OS,
    and so on, this operation will block the overall program execution quite a bit.
    The preceding code does some I/O that will be a blocking operation—the process
    will be blocked till I/O finishes and the data comes back. This is the traditional
    I/O model and most of us are familiar with this. However, this is costly and can
    cause terribly latency. Every process has associated memory and state—both these
    will be blocked till I/O is complete.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`fileSystemReader.read()`时，你正在从文件系统中读取文件。正如我们刚才看到的，I/O是这里的瓶颈，而且可能需要相当长的时间才能完成读取操作。根据硬件、文件系统、操作系统等不同，这个操作会很大程度上阻塞整个程序的执行。前面的代码执行了一些I/O操作，这是一个阻塞操作——进程将会一直阻塞，直到I/O操作完成并返回数据。这是传统的I/O模型，我们大多数人都很熟悉。然而，这种方法代价高昂，可能会导致可怕的延迟。每个进程都关联着内存和状态——在这两个方面，都会一直阻塞，直到I/O操作完成。
- en: If a program blocks I/O, the Node server will refuse new requests. There are
    several ways of solving this problem. The most popular traditional approach is
    to use several threads to process requests—this technique is known as multithreading.
    If are you familiar with languages such as Java, chances are that you have written
    multithreaded code. Several languages support threads in various forms—a thread
    essentially holds its own memory and state. Writing multithreaded applications
    on a large scale is tough. When multiple threads are accessing a common shared
    memory or values, maintaining the correct state across these threads is a very
    difficult task. Threads are also costly when it comes to memory and CPU utilization.
    Threads that are used on synchronized resources may eventually get blocked.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序阻塞了I/O，Node服务器将拒绝新的请求。解决这个问题有几种方法。最传统的流行方法是使用多个线程来处理请求——这种技术被称为多线程。如果你熟悉像Java这样的语言，那么你很可能写过多线程代码。多种语言支持线程的不同形式——线程本质上保持自己的内存和状态。在大规模上编写多线程应用程序是困难的。当多个线程访问公共共享内存或值时，在这些线程之间维护正确的状态是非常困难的工作。线程在内存和CPU利用率方面也是昂贵的。用于同步资源的线程可能会最终被阻塞。
- en: The browser handles this differently. I/O in the browser happens outside the
    main execution thread and an event is emitted when I/O finishes. This event is
    handled by the callback function associated with that event. This type of I/O
    is non-blocking and asynchronous. As I/O is not blocking the main execution thread,
    the browser can continue to process other events as they come without waiting
    on any I/O. This is a powerful idea. Asynchronous I/O allows browsers to respond
    to several events and allows a high level of interactivity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器处理方式不同。浏览器中的I/O发生在主线程之外，当I/O完成时会发出一个事件。这个事件由与该事件关联的回调函数处理。这种I/O是非阻塞和异步的。因为I/O不阻塞主线程，所以浏览器可以继续处理其他事件，而无需等待任何I/O。这是一个强大的想法。异步I/O允许浏览器响应多个事件，并实现高度的交互性。
- en: Node uses a similar idea for asynchronous processing. Node's event loop runs
    as a single thread. This means that the application that you write is essentially
    single-threaded. This does not mean that Node itself is single-threaded. Node
    uses **libuv** and is multithreaded—fortunately, these details are hidden within
    Node and you don't need to know them while developing your application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node为异步处理使用了类似的想法。Node的事件循环作为一个单线程运行。这意味着你编写的应用程序本质上是单线程的。这并不意味着Node本身是单线程的。Node使用了**libuv**并且是多线程的——幸运的是，这些细节被隐藏在Node内部，你在开发应用程序时不需要了解它们。
- en: Every call that involves an I/O call requires you to register a callback. Registering
    a callback is also asynchronous and returns immediately. As soon as an I/O operation
    is completed, its callback is pushed on the event loop. It is executed as soon
    as all the other callbacks that were pushed on the event loop before are executed.
    All operations are essentially thread-safe, primarily because there is no parallel
    execution path in the event loop that will require synchronization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个涉及I/O调用的调用都需要你注册一个回调函数。注册回调函数也是异步的，并且会立即返回。一旦I/O操作完成，其回调函数就会被推送到事件循环中。当所有在其他事件循环中被推送到的事件回调执行完毕后，它才会被执行。所有的操作本质上都是线程安全的，这主要是因为事件循环中没有需要同步的并行执行路径。
- en: Essentially, there is only one thread running your code and there is no parallel
    execution; however, everything else except for your code runs in parallel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，只有一个线程在运行你的代码，并且没有并行执行；然而，除了你的代码之外的所有其他操作都是并行运行的。
- en: Node.js relies on **libev** ([http://software.schmorp.de/pkg/libev.html](http://software.schmorp.de/pkg/libev.html))
    to provide the event loop, which is supplemented by **libeio** ([http://software.schmorp.de/pkg/libeio.html](http://software.schmorp.de/pkg/libeio.html))
    that uses pooled threads to provide asynchronous I/O. To learn even more, take
    a look at the libev documentation at [http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js依赖于**libev**([http://software.schmorp.de/pkg/libev.html](http://software.schmorp.de/pkg/libev.html))来提供事件循环，并通过**libeio**([http://software.schmorp.de/pkg/libeio.html](http://software.schmorp.de/pkg/libeio.html))使用池化线程提供异步I/O。要了解更多，请查看libev文档：[http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod)。
- en: 'Consider the following example of asynchronous code execution in Node.js:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Node.js中异步代码执行的示例：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this program, we read the `response.json` file from the disk. When the disk
    I/O is finished, the callback is executed with parameters containing the argument''s
    error, if any error occurred, and data, which is the file data. What you will
    see in the console is the output of `console.log(''1'')` and `console.log(''2'')`
    one immediately after another:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们从磁盘上读取`response.json`文件。当磁盘I/O完成后，回调函数会以包含任何错误发生的参数和文件数据的参数执行。你将在控制台看到的是`console.log('1')`和`console.log('2')`的输出连续出现：
- en: '![An asynchronous evented-model in a browser](img/00028.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器中的异步事件模型](img/00028.jpeg)'
- en: Node.js does not need any additional server component as it creates its own
    server process. A Node application is essentially a server running on a designated
    port. In Node, the server and application are the same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js不需要任何额外的服务器组件，因为它创建了自己的服务器进程。Node应用程序本质上是在指定端口上运行的服务器。在Node中，服务器和应用程序是相同的。
- en: 'Here is an example of a Node.js server responding with the **Hello Node** string
    when the `http://localhost:3000/` URL is run from a browser:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Node.js服务器示例，当通过浏览器运行`http://localhost:3000/` URL时，会返回**Hello Node**字符串：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we are using an `http` module. If you recall our earlier discussions
    on the JavaScript module, you will realize that this is the CommonJS module implementation.
    Node has several modules compiled into the binary. The core modules are defined
    within Node's source. They can be located in the `lib/` folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个`http`模块。如果你回想我们之前关于JavaScript模块的讨论，你就会意识到这是CommonJS模块的实现。Node将几个模块编译到二进制文件中。核心模块在Node的源代码中定义。它们可以在`lib/`文件夹中找到。
- en: They are loaded first if their identifier is passed to `require()`. For instance,
    `require('http')` will always return the built-in HTTP module, even if there is
    a file by this name.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了它们的标识符给`require()`，它们会首先被加载。例如，`require('http')`总是会返回内置的HTTP模块，即使存在同名的文件也是如此。
- en: 'After loading the module to handle HTTP requests, we create a `server` object
    and use a listener for a `request` event using the `server.on()` function. The
    callback is called whenever there is a request to this server on port `3000`.
    The callback receives `request` and `response` parameters. We are also setting
    the `Content-Type` header and HTTP response code before we send the response back.
    You can copy the preceding code, save it in a plain text file, and name it `app.js`.
    You can run the server from the command line using Node.js as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 加载处理HTTP请求的模块后，我们创建一个`server`对象，并使用`server.on()`函数为`request`事件添加一个监听器。无论何时有请求到达端口`3000`上的此服务器，回调都会被调用。回调接收`request`和`response`参数。我们还在发送响应之前设置`Content-Type`头和HTTP响应代码。你可以复制上面的代码，将其保存为一个纯文本文件，并命名为`app.js`。你可以使用以下命令行节点js运行服务器：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the server is started, you can open the `http://localhost:3000` URL in
    a browser and you will be greeted with unexciting text:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，你可以打开`http://localhost:3000` URL在浏览器中，你会看到令人兴奋的文本：
- en: '![An asynchronous evented-model in a browser](img/00029.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器中的异步事件模型](img/00029.jpeg)'
- en: 'If you want to inspect what''s happening internally, you can issue a `curl`
    command as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查内部正在发生的事情，你可以发出如下`curl`命令：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Curl shows a nice request (`>`) and response (`<`) dialog including the request
    and response headers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Curl显示了一个漂亮的请求（`>`）和响应（`<`）对话，包括请求和响应头。
- en: Callbacks
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: Callbacks in JavaScript usually take some time getting used to. If you are coming
    from some other non-asynchronous programming background, you will need to understand
    carefully how callbacks work; you may feel like you're learning programming for
    the first time. As everything is asynchronous in Node, you will be using callbacks
    for everything without trying to carefully structure them. The most important
    part of the Node.js project is sometimes the code organization and module management.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中的回调通常需要一段时间来适应。如果你来自其他一些非异步编程背景，你需要仔细理解回调是如何工作的；你可能会觉得你正在第一次学习编程。因为Node中一切都是异步的，所以你将不尝试仔细地结构它们而使用回调。Node.js项目最重要的部分有时是代码组织和模块管理。
- en: Callbacks are functions that are executed asynchronously at a later time. Instead
    of the code reading top to bottom procedurally, asynchronous programs may execute
    different functions at different times based on the order and speed that earlier
    functions such as HTTP requests or filesystem reads happen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数是在稍后异步执行的函数。而不是代码从上到下按程序顺序阅读，异步程序可能会根据早期函数（如HTTP请求或文件系统读取）的顺序和速度在不同时间执行不同的函数。
- en: 'Whether a function execution is sequential or asynchronous depends on the context
    in which it is executed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数执行是顺序还是异步取决于它执行的上下文：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run this program using Node, you will see the following output (assuming
    that your file is named `app.js`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Node运行这个程序，你会看到以下输出（假设你的文件名为`app.js`）：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is what we are all used to. This is traditional synchronous code execution
    where each line is executed in a sequence. The code here defines a function and
    then on the next line calls this function, without waiting for anything. This
    is sequential control flow.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都习惯了这种情况。这是传统的同步代码执行，每一行按顺序执行。这里的代码定义了一个函数，然后在下一行调用这个函数，而不等待任何东西。这是顺序控制流。
- en: 'Things will be different if we introduced I/O to this sequence. If we try to
    read something from the file or call a remote endpoint, Node will execute these
    operations in an asynchronous fashion. For the next example, we are going to use
    a Node.js module called `request`. We will use this module to make HTTP calls.
    You can install the module as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个序列中引入I/O，情况将会不同。如果我们试图从文件中读取一些内容或调用远程端点，Node将以异步方式执行这些操作。在下一个例子中，我们将使用一个名为`request`的Node.js模块。我们将使用这个模块来执行HTTP调用。你可以按照以下方式安装这个模块：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will discuss the use of npm later in this chapter. Consider the following
    example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论npm的使用。考虑以下例子：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you execute this code, you will see that the value of the `status` variable
    is still `undefined`. In this example, we are making an HTTP call—this is an I/O
    operation. When we do an I/O operation, the execution becomes asynchronous. In
    the earlier example, we are doing everything within the memory and there was no
    I/O involved, hence, the execution was synchronous. When we run this program,
    all of the functions are immediately defined, but they don't all execute immediately.
    The `request()` function is called and the execution continues to the next line.
    If there is nothing to execute, Node will either wait for I/O to finish or it
    will exit. When the `request()` function finishes its work, it will execute the
    callback function (an anonymous function as the second parameter to the `request()`
    function). The reason that we got `undefined` in the preceding example is that
    nowhere in our code exists the logic that tells the `console.log()` statement
    to wait until the `request()` function has finished fetching the response from
    the HTTP call.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行这段代码时，你会看到`status`变量的值仍然是`undefined`。在这个例子中，我们正在执行一个HTTP调用——这是一个I/O操作。当我们进行I/O操作时，执行变得异步。在之前的例子中，我们在内存中完成所有事情，并且没有涉及I/O，因此，执行是同步的。当我们运行这个程序时，所有函数都被立即定义，但它们并不都立即执行。`request()`函数被调用，执行继续到下一行。如果没有东西要执行，Node将等待I/O完成，或者退出。当`request()`函数完成其工作时，它将执行回调函数（作为`request()`函数第二个参数的匿名函数）。我们在前面例子中得到`undefined`的原因是，在我们的代码中没有任何逻辑告诉`console.log()`语句等待`request()`函数从HTTP调用中获取响应。
- en: 'Callbacks are functions that get executed at some later time. This changes
    things in the way you organize your code. The idea around reorganizing the code
    is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数是在稍后的时间执行的函数。这改变了你组织代码的方式。重新组织代码的想法如下：
- en: Wrapping the asynchronous code in a function
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将异步代码包裹在函数中
- en: Passing a callback function to the wrapper function
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将回调函数传递给包装函数
- en: 'We will organize our previous example with these two ideas in mind. Consider
    this modified example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在考虑这两个想法的基础上组织我们之前的例子。考虑这个修改后的例子：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run this, you will get the following (correct) output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会得到以下（正确）输出：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What we changed was to wrap the asynchronous code in a `getSiteStatus()` function,
    pass a function named `callback()` as a parameter to this function, and execute
    this function on the last line of `getSiteStatus()`. The `showStatusCode()` callback
    function simply wraps around `console.log()` that we called earlier. The difference,
    however, is in the way the asynchronous execution works. The most important idea
    to understand while learning how to program with callbacks is that functions are
    first-class objects that can be stored in variables and passed around with different
    names. Giving simple and descriptive names to your variables is important in making
    your code readable by others. Now that the callback function is called once the
    HTTP call is completed, the value of the `status_code` variable will have a correct
    value. There are genuine circumstances where you want an asynchronous task executed
    only after another asynchronous task is completed. Consider this scenario:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所改变的是将异步代码包裹在`getSiteStatus()`函数中，将一个名为`callback()`的函数作为参数传递给这个函数，在`getSiteStatus()`的最后一行执行这个函数。`showStatusCode()`回调函数仅仅是围绕我们之前调用的`console.log()`。然而，异步执行的工作方式有所不同。在学习如何使用回调编程时，理解函数是一等对象，可以存储在变量中并以不同的名称传递是非常重要的。给你的变量取简单且描述性的名称，这对于让你的代码更容易被他人阅读很重要。现在，一旦HTTP调用完成，回调函数就会被调用，`status_code`变量的值将会有一个正确的值。在某些真实情况下，你可能希望一个异步任务在另一个异步任务完成后执行。考虑这个场景：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we are nesting one asynchronous function in another. This kind
    of nesting can result in code that is difficult to read and manage. This style
    of callback is sometimes known as **callback hell**. To avoid such a scenario,
    if you have code that has to wait for some other asynchronous code to finish,
    then you express that dependency by putting your code in functions that get passed
    around as callbacks. Another important idea is to name your functions instead
    of relying on anonymous functions as callbacks. We can restructure the preceding
    example into a more readable one as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在一个异步函数中嵌套另一个异步函数。这种嵌套可能导致代码难以阅读和管理。这种回调风格有时被称为**回调地狱**。为了避免这种情况，如果你有代码必须等待其他异步代码完成，那么你通过将你的代码放在作为回调传递的函数中来表达这种依赖关系。另一个重要的想法是给你的函数命名，而不是依赖匿名函数作为回调。我们可以将前面的示例重构为更易读的一个，如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This fragment uses two important concepts. First, we are using named functions
    and using them as callbacks. Second, we are not nesting these asynchronous functions.
    If you are accessing closure variables within the inner functions, the preceding
    would be a bit different implementation. In such cases, using inline anonymous
    functions is even more preferable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段使用了两个重要的概念。首先，我们使用了命名函数并将它们作为回调使用。其次，我们并没有嵌套这些异步函数。如果你在内部函数中访问闭包变量，之前的实现会有所不同。在这种情况下，使用内联匿名函数更是可取的。
- en: Callbacks are most frequently used in Node. They are usually preferred to define
    logic for one-off responses. When you need to respond to repeating events, Node
    provides another mechanism for this. Before going further, we need to understand
    the function of timers and events in Node.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回调在Node中最为常用。它们通常用于定义一次性响应的逻辑。当你需要对重复事件做出响应时，Node提供了另一种机制。在进一步讲解之前，我们需要了解Node中的定时器和事件函数。
- en: Timers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器
- en: 'Timers are used to schedule the execution of a particular callback after a
    specific delay. There are two primary methods to set up such delayed execution:
    `setTimeout` and `setInterval`. The `setTimeout()` function is used to schedule
    the execution of a specific callback after a delay, while `setInterval` is used
    to schedule the repeated execution of a callback. The `setTimeout` function is
    useful to perform tasks that need to be scheduled such as housekeeping. Consider
    the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器用于在特定延迟后安排特定回调的执行。设置这种延迟执行有两种主要方法：`setTimeout`和`setInterval`。`setTimeout()`函数用于在延迟后安排特定回调的执行，而`setInterval`用于安排回调的重复执行。`setTimeout`函数适用于需要计划执行的任务，例如家务。考虑以下示例：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, we are using `setTimeout()` to execute a callback (the anonymous function)
    after a delay of 1,000 ms. This is just a one-time schedule for this callback.
    We scheduled the repeated execution of the callback using `setInterval()`. Note
    that we are assigning the value returned by `setInterval()` in a variable `t`—we
    can use this reference in `clearInterval()` to clear this schedule.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`setTimeout()`在1,000毫秒后执行回调（匿名函数）。这只是对这个回调的一次性计划。我们使用`setInterval()`来安排回调的重复执行。注意我们将`setInterval()`返回的值赋给变量`t`——我们可以在`clearInterval()`中使用这个引用来清除这个计划。
- en: EventEmitters
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件发射器
- en: We discussed earlier that callbacks are great for the execution of one-off logic.
    **EventEmitters** are useful in responding to repeating events. EventEmitters
    fire events and include the ability to handle these events when triggered. Several
    important Node APIs are built on EventEmitters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，回调对于执行一次性逻辑非常出色。**EventEmitter**在响应重复事件方面很有用。EventEmitter触发事件，并在事件触发时处理这些事件。一些重要的Node
    API是基于EventEmitter构建的。
- en: Events raised by EventEmitters are handled through listeners. A listener is
    a callback function associated with an event—when the event fires, its associated
    listener is triggered as well. The `event.EventEmitter` is a class that is used
    to provide a consistent interface to emit (trigger) and bind callbacks to events.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由EventEmitter引发的事件通过监听器处理。监听器是与事件关联的回调函数——当事件触发时，其关联的监听器也会被触发。`event.EventEmitter`是一个类，用于提供一致的接口来触发（触发）和绑定回调到事件。
- en: As a common style convention, event names are represented by a camel-cased string;
    however, any valid string can be used as an event name.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个常见的样式约定，事件名用驼峰命名法表示；然而，任何有效的字符串都可以作为事件名。
- en: 'Use `require(''events'')` to access the `EventEmitter` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`require('events')`来访问`EventEmitter`类：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When an EventEmitter instance encounters an error, it emits an `error` event.
    Error events are treated as a special case in Node.js. If you don't handle these,
    the program exits with an exception stack.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当EventEmitter实例遇到错误时，它会触发一个`error`事件。在Node.js中，错误事件被视为一个特殊案例。如果你不处理这些错误，程序将以异常堆栈退出。
- en: All EventEmitters emit the `newListener` event when new listeners are added
    and `removeListener` when a listener is removed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有EventEmitter在添加新监听器时都会触发`newListener`事件，并在移除监听器时触发`removeListener`。
- en: 'To understand the usage of EventEmitters, we will build a simplistic telnet
    server where different clients can log in and enter certain commands. Based on
    these commands, our server will respond accordingly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解EventEmitter的使用方法，我们将构建一个简化的telnet服务器，不同的客户端可以登录并输入某些命令。根据这些命令，我们的服务器将做出相应的响应：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When a client connects, we are emitting a `join` event, and when the client
    disconnects, we are emitting a `quit` event. We have listeners for both these
    events and they log appropriate messages on the server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个客户端连接时，我们触发一个`join`事件，当客户端断开连接时，我们触发一个`quit`事件。我们对这两个事件都有监听器，它们在服务器上记录适当的消息。
- en: 'You start this program and connect to our server using telnet as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你启动这个程序，并通过telnet连接到我们的服务器，如下所示：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the server console, you will see the server logging which client joined
    the server:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器控制台上，你会看到服务器记录哪个客户端加入了服务器：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If any client quits the session, an appropriate message will appear as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何客户端退出会话，会出现一个适当的消息。
- en: Modules
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: When you are writing a lot of code, you soon reach a point where you have to
    start thinking about how you want to organize the code. Node modules are CommonJS
    modules that we discussed earlier when we discussed module patterns. Node modules
    can be published to the **Node Package Manager** (**npm**) repository. The npm
    repository is an online collection of Node modules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写很多代码时，你很快就会达到一个需要开始思考如何组织代码的点。Node模块是我们在讨论模块模式时提到的CommonJS模块。Node模块可以发布到**Node包管理器**（**npm**）仓库。npm仓库是Node模块的在线集合。
- en: Creating modules
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模块
- en: 'Node modules can be either single files or directories containing one or more
    files. It''s usually a good idea to create a separate module directory. The file
    in the module directory that will be evaluated is normally named `index.js`. A
    module directory can look as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Node模块可以是单个文件或包含一个或多个文件的目录。通常创建一个单独的模块目录是个好主意。模块目录中的文件通常命名为`index.js`。模块目录可能如下所示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In your project directory, the `nav` module directory contains the module code.
    Conventionally, your module code needs to reside in the `index.js` file—you can
    change this to another file if you want. Consider this trivial module called `geo.js`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录中，`nav`模块目录包含了模块代码。通常，你的模块代码需要放在`index.js`文件中——如果你想要，你可以将其改放到另一个文件中。考虑这个叫做`geo.js`的简单模块：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You are exporting two functions via `exports`. You can use the module using
    the `require` function. This function takes the name of the module or system path
    to the module''s code. You can use the module that we created as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过`exports`导出了两个函数。你可以使用`require`函数来使用这个模块。这个函数接收模块的名称或者模块代码的系统路径。你可以像下面这样使用我们创建的模块：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we are exporting only two functions to the outside world, everything else
    remains private. If you recollect, we discussed the module pattern in detail—Node
    uses CommonJS modules. There is an alternative syntax to create modules as well.
    You can use `modules.exports` to export your modules. Indeed, `exports` is a helper
    created for `modules.exports`. When you use `exports`, it attaches the exported
    properties of a module to `modules.exports`. However, if `modules.exports` already
    has some properties attached to it, properties attached by `exports` are ignored.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只向外部导出两个函数，所以其他所有内容都保持私有。如果你还记得，我们详细讨论了模块模式——Node使用CommonJS模块。创建模块还有一种替代语法。你可以使用`modules.exports`来导出你的模块。实际上，`exports`是为`modules.exports`创建的一个助手。当你使用`exports`时，它将一个模块导出的属性附加到`modules.exports`上。然而，如果`modules.exports`已经有一些属性附加到它上面，`exports`附加的属性将被忽略。
- en: 'The `geo` module created earlier in this section can be rewritten in order
    to return a single `Geo` constructor function rather than an object containing
    functions. We can rewrite the `geo` module and its usage as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开头创建的`geo`模块可以改写，以返回一个`Geo`构造函数，而不是包含函数的对象。我们可以重写`geo`模块及其使用方式，如下：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Consider a `config.js` module:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`config.js`模块：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want to access `db_config` from outside this module, you can use `require()`
    to include the module and refer the object as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从模块外部访问`db_config`，你可以使用`require()`来包含这个模块，并像下面这样引用这个对象：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are three ways to organize modules:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 组织模块有三种方式：
- en: Using a relative path, for example, `config = require('./lib/config.js')`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相对路径，例如，`config = require('./lib/config.js')`
- en: Using an absolute path, for example, `config = require('/nodeproject/lib/config.js')`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绝对路径，例如，`config = require('/nodeproject/lib/config.js')`
- en: Using a module search, for example, `config = require('config')`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块搜索，例如，`config = require('config')`
- en: The first two are self-explanatory—they allow Node to look for a module in a
    particular location in the filesystem.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个选项是很容易理解的——它们允许Node在文件系统中特定位置查找模块。
- en: When you use the third option, you are asking Node to locate the module using
    the standard look method. To locate the module, Node starts at the current directory
    and appends `./node_modules/` to it. Node then attempts to load the module from
    this location. If the module is not found, then the search starts from the parent
    directory until the root of the filesystem is reached.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用第三种选项时，你是在要求Node使用标准的查找方法来定位模块。为了定位模块，Node从当前目录开始，并附上`./node_modules/`。Node然后尝试从这个位置加载模块。如果找不到模块，那么搜索从父目录开始，直到达到文件系统的根目录。
- en: 'For example, if `require(''config'')` is called in `/projects/node/`, the following
    locations will be searched until a match a found:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`require('config')`在`/projects/node/`中被调用，Node将会搜索以下位置，直到找到匹配项：
- en: '`/projects/node /node_modules/config.js`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/projects/node /node_modules/config.js`'
- en: '`/projects/node_modules/config.js`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/projects/node_modules/config.js`'
- en: '`/node_modules/config.js`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/node_modules/config.js`'
- en: For modules downloaded from npm, using this method is relatively simple. As
    we discussed earlier, you can organize your modules in directories as long as
    you provide a point of entry for Node.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从npm下载的模块，使用这种方法相对简单。正如我们之前讨论的，只要为Node提供一个入口点，你就可以将你的模块组织在目录中。
- en: 'The easiest way to do this is to create the `./node_modules/supermodule/` directory,
    and insert an `index.js` file in this directory. The `index.js` file will be loaded
    by default. Alternatively, you can put a `package.json` file in the `mymodulename`
    folder, specifying the name and main file of the module:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点最简单的方法是创建一个`./node_modules/supermodule/`目录，并在该目录中插入一个`index.js`文件。这个`index.js`文件将会被默认加载。另外，你也可以在`mymodulename`文件夹中放一个`package.json`文件，指明模块的名称和主文件：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You have to understand that Node caches modules as objects. If you have two
    (or more) files requiring a specific module, the first `require` will cache the
    module in memory so that the second `require` will not have to reload the module
    source code. However, the second `require` can alter the module functionality
    if it wishes to. This is commonly called **monkey patching** and is used to modify
    a module behavior without really modifying or versioning the original module.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须明白Node将模块缓存为对象。如果你有两个（或更多）文件需要某个特定模块，第一个`require`将在内存中缓存该模块，这样第二个`require`就无需重新加载模块源代码。然而，第二个`require`可以更改模块的功能，如果它愿意的话。这通常被称为**猴子补丁**，用于修改模块的行为，而不真正修改或版本化原始模块。
- en: npm
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm
- en: The npm is the package manager used by Node to distribute modules. The npm can
    be used to install, update, and manage modules. Package managers are popular in
    other languages such as Python. The npm automatically resolves and updates dependencies
    for a package and hence makes your life easy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: npm是Node用来分发模块的包管理器。npm可以用来安装、更新和管理模块。包管理器在其他语言中也很流行，如Python。npm会自动为包解决和更新依赖，因此使你的生活变得轻松。
- en: Installing packages
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装包
- en: 'There are two ways to install npm packages: locally or globally. If you want
    to use the module''s functionality only for a specific Node project, you can install
    it locally relative to the project, which is default behavior of `npm install`.
    Alternatively, there are several modules that you can use as a command-line tool;
    in this case, you can install them globally:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装npm包有两种方法：本地安装或全局安装。如果你只想为特定的Node项目使用模块的功能，可以在项目相对路径下本地安装，这是`npm install`的默认行为。另外，有许多模块可以用作命令行工具；在这种情况下，你可以全局安装它们：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `install` directive with `npm` will install a particular module—`request`
    in this case. To confirm that `npm install` worked correctly, check to see whether
    a `node_modules` directory exists and verify that it contains a directory for
    the package(s) that you installed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm`的`install`指令将安装一个特定的模块——`request`在这个例子中。为了确认`npm install`是否正确工作，检查是否存在一个`node_modules`目录，并验证它包含你安装的包的目录。
- en: As you start adding modules to your project, it becomes difficult to manage
    the version/dependency of each module. The best way to manage locally installed
    packages is to create a `package.json` file in your project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你向项目中添加模块，管理每个模块的版本/依赖变得困难。管理本地安装包的最佳方式是在你的项目中创建一个`package.json`文件。
- en: 'A `package.json` file can help you in the following ways:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件可以通过以下方式帮助你：'
- en: Defining versions of each module that you want to install. There are times when
    your project depends on a specific version of a module. In this case, your `package.json`
    helps you download and maintain the correct version dependency.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义你想安装的每个模块的版本。有时你的项目依赖于模块的特定版本。在这种情况下，你的`package.json`帮助你下载和维护正确的版本依赖。
- en: Serving as a documentation of all the modules that your project needs.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为项目所需所有模块的文档。
- en: Deploying and packaging your application without worrying about managing dependencies
    every time you deploy the code.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和打包你的应用程序，而不用担心每次部署代码时都要管理依赖。
- en: 'You can create `package.json` by issuing the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令创建`package.json`：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After answering basic questions about your project, a blank `package.json`
    is created with content similar to the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答了关于你的项目的基本问题后，会创建一个空白的`package.json`，其内容与以下类似：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can manually edit this file in a text editor. An important part of this
    file is the `dependencies` tag. To specify the packages that your project depends
    on, you need to list the packages you''d like to use in your `package.json` file.
    There are two types of packages that you can list:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文本编辑器中手动编辑此文件。这个文件的一个重要部分是`dependencies`标签。为了指定你的项目依赖的包，你需要在你的`package.json`文件中列出你想要使用的包。你可以列出两种类型的包：
- en: '`dependencies`: These packages are required by your application in production'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`：这些包是应用程序在生产中所需的'
- en: '`devDependencies`: These packages are needed only for development and testing
    (for example, using the **Jasmine node package**)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies`：这些包仅用于开发和测试（例如，使用**Jasmine node包**）'
- en: 'In the preceding example, you can see the following dependency:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到以下依赖关系：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This means that the project is dependent on the `request` module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着项目依赖于`request`模块。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The version of the module is dependent on the semantic versioning rules—[https://docs.npmjs.com/getting-started/semantic-versioning](https://docs.npmjs.com/getting-started/semantic-versioning).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的版本依赖于语义版本规则——[https://docs.npmjs.com/getting-started/semantic-versioning](https://docs.npmjs.com/getting-started/semantic-versioning)。
- en: Once your `package.json` file is ready, you can simply use the `npm install`
    command to install all the modules for your projects automatically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的 `package.json` 文件准备好了，你只需使用 `npm install` 命令就可以自动为你的项目安装所有模块。
- en: 'There is a cool trick that I love to use. While installing modules from the
    command line, we can add the `--save` flag to add that module''s dependency to
    the `package.json` file automatically:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个我很喜欢的酷炫技巧。在从命令行安装模块时，我们可以添加 `--save` 标志以自动将该模块的依赖项添加到 `package.json` 文件中：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding command, we installed the `async` module with the normal `npm`
    command with a `--save` flag. There is a corresponding entry automatically created
    in `package.json`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用带有 `--save` 标志的正常 `npm` 命令安装了 `async` 模块。在 `package.json` 中自动创建了相应的条目：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: JavaScript performance
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 性能
- en: Like any other language, writing correct JavaScript code at scale is an involved
    task. As the language matures, several of the inherent problems are being taken
    care of. There are several exceptional libraries that aid in writing good quality
    code. For most serious systems, *good code = correct code + high performance code*.
    The demands of new-generation software systems are high on performance. In this
    section, we will discuss a few tools that you can use to analyze your JavaScript
    code and understand its performance metrics.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他语言一样，编写大规模正确的 JavaScript 代码是一项涉及的任务。随着语言的成熟，许多内在问题正在得到解决。有许多优秀的库可以帮助编写高质量的代码。对于大多数严肃的系统来说，*好的代码
    = 正确的代码 + 高性能的代码*。新一代软件系统对性能的要求很高。在本节中，我们将讨论一些你可以使用来分析你的 JavaScript 代码并了解其性能指标的工具。
- en: 'We will discuss the following two ideas in this section:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下两个想法：
- en: 'Profiling: Timing various functions and operations during script-profiling
    helps in identifying areas where you can optimize your code'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剖析：在脚本剖析过程中计时各种函数和操作有助于识别你可以优化代码的区域。
- en: 'Network performance: Examining the loading of network resources such as images,
    stylesheets, and scripts'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络性能：检查网络资源的加载，如图片、样式表和脚本。
- en: JavaScript profiling
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 剖析
- en: JavaScript profiling is critical to understand performance aspects of various
    parts of your code. You can observe timings of the functions and operations to
    understand which operation is taking more time. With this information, you can
    optimize the performance of time-consuming functions and tune the overall performance
    of your code. We will be focusing on the profiling options provided by Chrome's
    Developer Tools. There are comprehensive analysis tools that you can use to understand
    the performance metrics of your code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 剖析对于理解代码各个部分的性能方面至关重要。你可以观察函数和操作的时间来了解哪个操作花费的时间更多。有了这些信息，你可以优化耗时函数的性能并调整代码的整体性能。我们将重点关注
    Chrome 开发者工具提供的剖析选项。还有全面的分析工具，你可以使用它们来了解代码的性能指标。
- en: The CPU profile
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU 剖析
- en: The CPU profile shows the execution time spent by various parts of your code.
    We have to inform DevTools to record the CPU profile data. Let's take the profiler
    for a spin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 剖析显示了你的代码各个部分执行花费的时间。我们必须通知 DevTools 记录 CPU 剖析数据。让我们来试试剖析器。
- en: 'You can enable the CPU profiler in DevTools as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式在 DevTools 中启用 CPU 剖析器：
- en: Open the Chrome DevTools **Profiles** panel.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Chrome DevTools 的**性能**面板。
- en: Verify that **Collect JavaScript CPU Profile** is selected:![The CPU profile](img/00030.jpeg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认**收集 JavaScript CPU 剖析**已选中：![CPU 剖析](img/00030.jpeg)
- en: For this chapter, we will be using Google's own benchmark page, [http://octane-benchmark.googlecode.com/svn/latest/index.html](http://octane-benchmark.googlecode.com/svn/latest/index.html).
    We will use this because it contains sample functions where we can see various
    performance bottlenecks and benchmarks. To start recording the CPU profile, open
    DevTools in Chrome, and in the **Profiles** tab, click on the **Start** button
    or press *Cmd*/*Ctrl* + *E*. Refresh the **V8 Benchmark Suite** page. When the
    page has completed reloading, a score for the benchmark tests is shown. Return
    to the **Profiles** panel and stop the recording by clicking on the **Stop** button
    or pressing *Cmd*/*Ctrl* + *E* again.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为此章节，我们将使用谷歌自己的基准页面，[http://octane-benchmark.googlecode.com/svn/latest/index.html](http://octane-benchmark.googlecode.com/svn/latest/index.html)。我们将使用这个页面，因为它包含示例函数，我们可以看到各种性能瓶颈和基准测试。要开始记录CPU配置文件，请在Chrome中打开开发者工具，在**配置文件**标签中，点击**开始**按钮或按*Cmd*/*Ctrl*
    + *E*。刷新**V8基准套件**页面。当页面完成重新加载后，将显示基准测试的得分。返回**配置文件**面板，通过点击**停止**按钮或再次按*Cmd*/*Ctrl*
    + *E*来停止记录。
- en: 'The recorded CPU profile shows you a detailed view of the functions and the
    execution time taken by them in the bottom-up fashion, as shown in the following
    image:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的CPU配置文件为您提供了函数及其执行时间的详细视图，以下图所示：
- en: '![The CPU profile](img/00031.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![CPU配置文件](img/00031.jpeg)'
- en: The Timeline view
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间线视图
- en: The Chrome DevTools **Timeline** tool is the first place you can start looking
    at the overall performance of your code. It lets you record and analyze all the
    activity in your application as it runs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌开发者工具**时间线**工具是您可以开始查看代码整体性能的第一站。它允许您记录并分析应用程序运行过程中的所有活动。
- en: 'The **Timeline** provides you with a complete overview of where time is spent
    when loading and using your site. A timeline recording includes a record for each
    event that occurred and is displayed in a **waterfall** graph:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间线**为您提供了加载和使用您网站时时间花费的完整概述。时间线记录包括每个发生事件的记录，并以**瀑布**图的形式显示：'
- en: '![The Timeline view](img/00032.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![时间线视图](img/00032.jpeg)'
- en: 'The preceding screen shows you the timeline view when we try to render [https://twitter.com/](https://twitter.com/)
    in the browser. The timeline view gives you an overall view of which operation
    took how much time in execution:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个屏幕展示了我们在浏览器中尝试渲染[https://twitter.com/](https://twitter.com/)时的时间线视图。时间线视图为您提供了执行中各个操作花费了多少时间的总体视图：
- en: '![The Timeline view](img/00033.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![时间线视图](img/00033.jpeg)'
- en: 'In the preceding screenshot, we can see the progressive execution of various
    JavaScript functions, network calls, resource downloads, and other operations
    involved in rendering the Twitter home page. This view gives us a very good idea
    about which operations may be taking longer. Once we identify such operations,
    we can optimize them for performance. The **Memory** view is a great tool to understand
    how the memory is used during the lifetime of your application in the browser.
    The **Memory** view shows you a graph of the memory used by your application over
    time and maintains a counter of the number of documents, DOM nodes, and event
    listeners that are held in the memory. The **Memory** view can help detect memory
    leaks and give you good enough hints to understand what optimizations are required:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图中，我们可以看到各种JavaScript函数、网络调用、资源下载和其他渲染Twitter主页的操作逐步执行。这个视图让我们对哪些操作可能需要更长时间有了很好的了解。一旦我们识别出这样的操作，我们就可以对其进行性能优化。**内存**视图是一个很好的工具，可以帮助您了解在浏览器中您的应用程序生命周期内内存的使用情况。**内存**视图向您展示了您的应用程序随时间使用的内存的图表，并维护了一个计数器，用于统计保存在内存中的文档数量、DOM节点和事件监听器。**内存**视图可以帮助检测内存泄漏，并给出足够好的提示，让您了解需要进行哪些优化：
- en: '![The Timeline view](img/00034.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![时间线视图](img/00034.jpeg)'
- en: JavaScript performance is a fascinating subject and deserves its own dedicated
    text. I would urge you to explore Chrome's DevTools and understand how best to
    use the tools to detect and diagnose performance problems in your code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript性能是一个迷人的主题，完全值得一本专著。我强烈建议您探索Chrome的开发者工具，了解如何最佳地使用这些工具来检测和诊断您代码中的性能问题。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we looked at a different avatar of JavaScript—that of a server-side
    framework in the form of Node.js.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们查看了JavaScript的另一个化身——以Node.js形式的 server-side框架。
- en: Node offers an asynchronous evented-model to program scalable and high-performance
    server applications in JavaScript. We dived deep into some core concepts on Node,
    such as an event loop, callbacks, modules, and timers. Understanding them is critical
    to write good Node code. We also discussed several techniques to structure Node
    code and callbacks in a better way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Node提供了一个异步事件模型，用JavaScript编写可扩展和高性能的服务器应用程序。我们深入探讨了Node的一些核心概念，例如事件循环、回调、模块和定时器。理解它们对于编写好的Node代码至关重要。我们还讨论了几种更好地组织Node代码和回调的技术。
- en: With this, we reach the conclusion of our exploration of a brilliant programming
    language. JavaScript has been instrumental in the evolution of the World Wide
    Web because of its sheer versatility. The language continues to expand its horizons
    and improves with each new iteration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经探索了一种出色的编程语言。JavaScript之所以在万维网的演变中发挥了重要作用，是因为它的多样性。该语言继续扩大其视野，并在每次新迭代中得到改进。
- en: We started our journey with understanding the building blocks of the grammar
    and syntax of the language. We grasped the fundamental ideas of closures and the
    functional behavior of JavaScript. These concepts are so essential that most of
    the JavaScript patterns are based on them. We looked at how we can utilize these
    patterns to write better code with JavaScript. We studied how JavaScript can operate
    on a DOM and how to use jQuery to manipulate the DOM effectively. Finally, we
    looked at the server-side avatar of JavaScript in Node.js.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程始于理解语言的语法和语法的构建块。我们掌握了闭包和JavaScript的功能行为的基本思想。这些概念是如此基本，以至于大多数JavaScript模式都是基于它们的。我们探讨了如何利用这些模式用JavaScript写出更好的代码。我们研究了JavaScript如何操作DOM以及如何有效地使用jQuery操纵DOM。最后，我们查看了JavaScript的服务器端化身Node.js。
- en: This book should have enabled you to think differently when you start programming
    in JavaScript. Not only will you think about common patterns when you code, but
    also appreciate and use newer language features by ES6.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书应该已经让你在开始用JavaScript编程时思维方式有所不同。你不仅会在编码时考虑常见的模式，而且会欣赏并使用ES6带来的新语言特性。
