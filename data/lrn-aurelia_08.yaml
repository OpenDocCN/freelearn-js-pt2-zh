- en: Chapter 8. Internationalization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。国际化
- en: When it comes to internationalization in JavaScript, `i18next` is one of the
    most well-known, widely used libraries. It offers a rich set of features, such
    as pluggable translation loaders, caching, user language detection, and pluralization.
    That's probably why the Aurelia team built the `aurelia-i18n` library on top of
    it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到JavaScript国际化时，`i18next`是最知名、最广泛使用的库之一。它提供了一系列功能，如可插拔的翻译加载器、缓存、用户语言检测和复数形式。也许这就是Aurelia团队在它之上构建`aurelia-i18n`库的原因。
- en: 'The purpose of this chapter is not to explain `i18next` in detail, but more
    to explore the `aurelia-i18n` layer itself. As for the details of `i18next`, the
    official website has extensive documentation, and I strongly suggest you look
    it up if you are not familiar with it: [http://i18next.com/](http://i18next.com/).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的并不是要详细解释`i18next`，而是更多地探索`aurelia-i18n`层本身。至于`i18next`的详细信息，官方网站有广泛的文档，如果你不熟悉它，我强烈建议你查阅：
    [http://i18next.com/](http://i18next.com/)。
- en: Setting things up
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置事情
- en: The `aurelia-i18n` library and the underlying `i18next` library both need to
    be installed and configured before they can be used. Let's see how this goes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-i18n`库和底层`i18next`库在使用之前都需要安装和配置。让我们看看这个过程如何进行。'
- en: Installing the libraries
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装库
- en: 'The first thing to do is to install `aurelia-i18n` and `i18next` by opening
    a console in the project''s directory and running the following command:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要通过在项目目录中打开控制台并运行以下命令来安装`aurelia-i18n`和`i18next`：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `i18next` library uses an abstraction layer to load translation data. In
    `i18next` terminology, this is named a backend. This abstraction layer allows
    for different translation-loading strategies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18next`库使用一个抽象层来加载翻译数据。在`i18next`术语中，这被称为后端。这个抽象层允许不同的翻译加载策略。'
- en: 'The most common way to store and retrieve translation data is in JSON files,
    somewhere among the application''s files. As such, we''ll install the `i18next-xhr-backend`
    implementation, which uses `XMLHttpRequest`s to fetch JSON files containing the
    translations from the server:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和检索翻译数据的最常见方法是在应用程序文件的某个地方使用JSON文件。因此，我们将安装`i18next-xhr-backend`实现，它使用`XMLHttpRequest`从服务器获取包含翻译的JSON文件：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, the bundler needs to know about those new libraries. As such, in
    the `aurelia_project/aurelia.json` file, in the `build` section, under `bundles`,
    let''s add the following entries to the `dependencies` of the bundle named `vendor-bundle.js`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，打包器需要知道这些新库。因此，在`aurelia_project/aurelia.json`文件中，在`build`部分，在`bundles`下的`vendor-bundle.js`的`dependencies`中，让我们添加以下条目：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Configuring the plugin
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置插件
- en: 'We also need to load and configure the plugin in our main `configure` function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的主`configure`函数中加载和配置插件：
- en: '`src/main.js`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we start by importing the `Backend` class from the `i18next-xhr-backend`
    library. Next, we add a call to the `plugin` function to load `aurelia-i18n` and
    configure it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们首先从`i18next-xhr-backend`库中导入`Backend`类。然后，我们调用`plugin`函数来加载`aurelia-i18n`并对其进行配置。
- en: The configuration function receives as a parameter the single instance of `I18N`
    class of `aurelia-i18n`, which acts as a facade, grouping and standardizing the
    API. It starts by telling `i18next` to use the `Backend` class of `i18next-xhr-backend`,
    which will be responsible for fetching the JSON translation files from the server.
    Next, it calls the `I18N` class's `setup` method with a bunch of options. Those
    options will be used to configure the plugin, but will also be used behind the
    scenes to configure `i18next`. This means that any option you would normally pass
    to the `init` method of `i18next`, you can pass to this `setup` method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 配置函数接收`aurelia-i18n`类的单个实例`I18N`，作为外观，分组和标准化API。它首先告诉`i18next`使用`i18next-xhr-backend`的`Backend`类，该类负责从服务器获取JSON翻译文件。然后，它调用`I18N`类的`setup`方法，带有一组选项。这些选项将用于配置插件，但也将用于后台配置`i18next`。这意味着您通常会传递给`i18next`的`init`方法的任何选项，都可以传递给这个`setup`方法。
- en: 'Here are the most important options:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最重要的选项：
- en: '`backend.loadPath`: The path used to load the translation files. The `{{lng}}`
    placeholder will be replaced by the language for which the translations must be
    loaded, and the `{{ns}}` placeholder will be replaced by the namespace for which
    the translations must be loaded.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend.loadPath`：用于加载翻译文件的路径。`{{lng}}`占位符将被替换为必须加载翻译的语言，`{{ns}}`占位符将被替换为必须加载翻译的命名空间。'
- en: '`lng`: The default language.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lng`：默认语言。'
- en: '`fallbackLng`: The language to fall back to in case a given key doesn''t exist
    in the current language.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallbackLng`：如果在当前语言中找不到给定键，则回退到该语言。'
- en: '`debug`: When set to `true`, the logs in the browser console will be more verbose.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`：设置为`true`时，浏览器控制台中的日志将更加详细。'
- en: Creating the translation file
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建翻译文件
- en: 'The `i18next` library allows us to segregate translations with namespaces,
    which are logical groups of translations. Its default namespace is named `translation`.
    If we look at the `backend.loadPath` option, we can easily see where our translation
    files should live:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18next`库允许我们将翻译按命名空间隔离，这些命名空间是逻辑翻译组。其默认命名空间名为`translation`。如果我们看看`backend.loadPath`选项，我们可以很容易地看出我们的翻译文件应该放在哪里：'
- en: '`locales/en/translation.json`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`locales/en/translation.json`'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we simply create a JSON file containing an empty object. We'll add translations
    to it later on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地创建一个包含空对象的JSON文件。我们稍后向其中添加翻译。
- en: Polyfilling the Intl API
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充Intl API
- en: The `aurelia-i18n` plugin uses `i18next` for translations, but relies on the
    native Intl API for some other tasks, such as number and date formatting. However,
    some browsers, mostly mobile ones, don't support this API yet. As such, you may
    need to add a polyfill if you want to support those browsers. [https://github.com/andyearnshaw/Intl.js/](https://github.com/andyearnshaw/Intl.js/)
    is the one recommended in the official documentation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-i18n`插件使用`i18next`进行翻译，但依赖原生Intl API进行一些其他任务，如数字和日期格式化。然而，一些浏览器（主要是移动浏览器）还不支持这个API。因此，如果您想要支持这些浏览器，可能需要添加一个填充物。
    [https://github.com/andyearnshaw/Intl.js/](https://github.com/andyearnshaw/Intl.js/)
    是官方文档中推荐的一个。'
- en: Getting and setting the current locale
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和设置当前区域设置
- en: In addition to various view resources, which we'll see later in this chapter,
    the `aurelia-i18n` exports an `I18N` class, which acts as a facade over various
    APIs such as `i18next` and the native Intl API.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了各种视图资源，我们将在本章后面看到，`aurelia-i18n`还导出一个`I18N`类，它作为各种API（如`i18next`和原生Intl API）的门面。
- en: 'Let''s see how we can use this API to get and set the current locale by creating
    a `locale-picker` custom element, which will allow the user to change the current
    locale:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这个API来获取和设置当前区域设置，通过创建一个`locale-picker`自定义元素，用户可以更改当前区域设置：
- en: '`src/resources/elements/locale-picker.html`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/locale-picker.html`'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this template, we start by adding a `select` element, whose value will be
    bound to the `selectedLocale` property, and which will be disabled when the `isChangingLocale`
    property is `true`. In the `select` element, we render one `option` for each value
    in the `locales` array. The `value` of each `option` is bound to its `locale`
    value, and the text of each option will be the `locale` itself, rendered using
    a string interpolation expression.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，我们首先添加一个`select`元素，其值将绑定到`selectedLocale`属性，当`isChangingLocale`属性为`true`时，该元素将被禁用。在`select`元素中，我们为`locales`数组中的每个值渲染一个`option`。每个`option`的`value`绑定到其`locale`值，每个选项的文本将是本身使用字符串插值表达式渲染的`locale`。
- en: 'Next, we need to add the view-model, which will bridge this template with the
    `I18N` API:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加视图模型，这将使这个模板与`I18N` API相连接：
- en: '`src/resources/elements/locale-picker.js`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/locale-picker.js`'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, this class's constructor starts by receiving the `I18N` instance, then
    uses its `getLocale` method to retrieve the current locale and initialize the
    `selectedLocale` property. This property being `bindable`, the template declaring
    an instance can, however, data-bind to it to override its default value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个类的构造函数从接收`I18N`实例开始，然后使用其`getLocale`方法检索当前区域设置并初始化`selectedLocale`属性。由于这个属性是可绑定的，所以声明实例的模板可以对其默认值进行数据绑定。
- en: Next, the property change handler `selectedLocaleChanged`, which will be called
    by the templating engine when the `selectedLocale` property changes, sets the
    `isChangingLocale` to `true` so the `select` element is disabled, then calls the
    `setLocale` method of `I18N`. This method is asynchronous because it may have
    to load a new translation file from the server, so it returns a `Promise`, which
    we listen for completion to set `isChangingLocale` back to `false`, so the `select`
    element is re-enabled.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，属性更改处理程序`selectedLocaleChanged`将在`selectedLocale`属性发生变化时由模板引擎调用，将`isChangingLocale`设置为`true`，以便禁用`select`元素，然后调用`I18N`的`setLocale`方法。由于它可能需要从服务器加载新的翻译文件，所以这个方法是异步的，返回一个`Promise`，我们监听其完成以将`isChangingLocale`恢复为`false`，以便重新启用`select`元素。
- en: 'Since our locale picker supports English and French by default, we need to
    add another translation file for French, containing an empty object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的本地化选择器默认支持英语和法语，因此我们需要为法语添加另一个翻译文件，其中包含一个空对象：
- en: '`locales/fr/translation.json`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`locales/fr/translation.json`'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now use this custom element in the `app` component:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个自定义元素在`app`组件中：
- en: '`src/app.html`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.html`'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, if you run the application at this point, nothing gets translated
    when you change the current locale; text translations must be added to the templates
    first.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你在这个时候运行应用程序，当你改变当前的本地化设置时，什么也不会被翻译；必须首先向模板中添加文本翻译。
- en: Translating
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译
- en: The `aurelia-i18n` library offers many different ways to translate texts. In
    this section, we will see what our options are.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-i18n`库提供了许多不同的翻译文本的方法。在本节中，我们将了解我们的选择有哪些。'
- en: Using attributes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用属性
- en: The simplest way to translate text in a template is to use the translation attribute,
    named `t`. Let's illustrate this by translating our **Not Found** page.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中翻译文本的最简单方法是使用名为`t`的翻译属性。让我们通过翻译我们的**未找到**页面来说明这一点。
- en: 'We will start by moving the texts to the translation files:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将文本移动到翻译文件开始：
- en: '`locales/en/translation.js`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`locales/en/translation.js`'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`locales/fr/translation.js`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`locales/fr/translation.js`'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, with translations being JSON structures, we can use nested keys
    without any problem.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，由于翻译是JSON结构，我们完全可以没有任何问题地使用嵌套键。
- en: 'To statically display a translated text inside an element, you just need to
    add the `t` attribute to the element and set its value to the path of the translation
    key:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要在元素内静态显示翻译后的文本，你只需要向元素添加`t`属性，并将其值设置为翻译键的路径：
- en: '`src/not-found.html`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/not-found.html`'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upon rendering, the attribute will look the key up in the translation file
    for the current locale and will assign the translated value to the element''s
    text content. After rendering, the DOM will look like this if the current locale
    is English:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染后，属性将在当前本地化的翻译文件中查找键，并将翻译值分配给元素的文本内容。如果当前本地化是英语，渲染后的DOM将看起来像这样：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is also possible to translate the value of an attribute using `t`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`t`来翻译属性的值：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By prefixing the key with the name of an attribute between square brackets,
    the `t` attribute will assign the translated value to this attribute and not to
    the element's text content. Here, the value of the translation key, `contacts.firstName,`
    will be assigned to the `placeholder` attribute of `input`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在方括号内加上属性的名称来前缀键，`t`属性将为这个属性分配翻译值，而不是元素的文本内容。在这里，翻译键`contacts.firstName`的值将被分配给`input`的`placeholder`属性。
- en: 'Additionally, it is possible to translate to multiple targets on a single element,
    by separating the instructions with semicolons:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以在单个元素上翻译多个目标，通过用分号分隔指令来实现：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, the value of the `help` key will be assigned to the `title` attribute,
    and the value of `text` will be assigned to the element's text content. Of course,
    it is also possible to translate multiple attributes using the same technique.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`help`键的值将被分配给`title`属性，`text`的值将被分配给元素的文本内容。当然，使用相同的技术翻译多个属性也是可能的。
- en: Finally, the `t` attribute monitors the current locale. When it changes, the
    output will be automatically updated using the new locale.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`t`属性监控当前的本地化设置。当它改变时，输出会自动使用新的本地化设置进行更新。
- en: Passing parameters
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递参数
- en: Since `i18next` supports passing parameters to a translation, you can bind to
    the `t-params` attribute to pass an object containing parameters for the translation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`i18next`支持向翻译传递参数，你可以将对象绑定到`t-params`属性以传递翻译的参数。
- en: 'Let''s imagine the following translation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下以下的翻译：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Passing the `name` parameter to this translation using attributes would look
    like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性将`name`参数传递给这个翻译看起来像这样：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After rendering, the `p` element would contain the text `Hi Chuck, welcome back!`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染后，`p`元素将包含文本`Hi Chuck, welcome back!`。
- en: Using the value converter
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值转换器
- en: 'An alternative to the `t` attribute is the `t` value converter. It can be used
    in any binding expression, including string interpolations, so in some circumstances
    it can be more convenient than the attribute:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`t`属性的一种替代方案是`t`值转换器。它可以在任何绑定表达式中使用，包括字符串插值，所以在某些情况下它比属性更方便：'
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the `t` value converter will look the `explanation` translation key up
    in the translation file and will output its value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`t`值转换器将在翻译文件中查找`explanation`翻译键并输出其值。
- en: 'Its usage is not limited to string interpolation. It also works in other binding
    expressions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用不仅限于字符串插值。它还适用于其他绑定表达式：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `title` attribute will contain the translation of the `explanation`
    key.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`title`属性将包含`explanation`键的翻译。
- en: Passing parameters
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递参数
- en: The value converter accepts an object containing parameters for the translation
    as its first parameter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器接受一个包含翻译参数的对象作为其第一个参数。
- en: 'Let''s imagine the following translation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设以下的翻译：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using this translation with the value converter would look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个翻译与值转换器的效果是这样的：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After rendering, the `p` element would contain the text `Hi Chuck, welcome back!`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染后，`p`元素将包含文本`Hi Chuck, welcome back!`。
- en: Using the binding behavior
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用绑定行为
- en: The value converter is, however, not useful at all if your application allows
    you to change the language during its life cycle. Because of how value converters
    work, the `t` value converter can't know that it must reevaluate its value, because
    it can't be notified when the current locale changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的应用程序允许你在其生命周期内更改语言，那么值转换器根本就没有用。由于值转换器的工作方式，`t`值转换器不知道它必须重新评估其值，因为它不能在当前区域更改时得到通知。
- en: That's where the `t` binding behavior comes in. The `t` binding behavior simply
    decorates its binding instruction with the `t` value converter when it is applied.
    So, why not simply use the value converter?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`t`绑定行为发挥作用的地方。当应用`t`绑定行为时，它简单地将`t`值转换器装饰在其绑定指示上。那么，为什么不用值转换器呢？
- en: Remember the `signal` binding behavior we saw in [Chapter 3](ch03.html "Chapter 3. Displaying
    Data"), *Displaying Data*? Well, the `setLocale` method of `I18N` actually triggers
    the `aurelia-translation-signal` binding signal, and the `t` binding behavior
    listens for it. When the current locale changes, all active `t` binding behaviors
    force their binding expression to reevaluate, so the underlying value converter
    for each binding expression can be applied using the new locale.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第3章](ch03.html "第3章 显示数据")中看到的`signal`绑定行为吗？*显示数据*？好吧，`I18N`的`setLocale`方法实际上触发了`aurelia-translation-signal`绑定信号，而`t`绑定行为监听它。当当前区域更改时，所有活动的`t`绑定行为强制其绑定表达式重新评估，所以每个绑定表达式的底层值转换器可以使用新的区域。
- en: Passing parameters
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'Any parameter object passed to the binding behavior will be passed to the underlying
    value converter, so the value converter example also works with the binding behavior:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给绑定行为的任何参数对象都将传递给底层的值转换器，所以值转换器示例也适用于绑定行为：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using code
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码
- en: 'Of course, all those various ways to translate a key rely on the same `I18N`
    method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，翻译一个键的所有这些不同方式都依赖于同一个`I18N`方法：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example, given that `i18n` is an instance of `I18N`, translating the same
    `message` key in JS code would look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`i18n`是`I18N`的一个实例，在JS代码中翻译同一个`message`键就像这样：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Choosing one technique over another
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一种技术胜过另一种
- en: We just saw four different ways to do the same thing. It may prove difficult
    at first to decide in what circumstances one technique fits best over the others.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了四种不同的做事方式。一开始可能很难决定在哪种情况下一种技术最适合胜过其他技术。
- en: The `t` attribute is an artefact coming from `i18next`. When used on its own,
    outside of Aurelia, `i18next` uses this attribute to translate texts within a
    DOM tree. The `aurelia-i18n` library probably supports it just so people experienced
    with `i18next` can keep using it like they always did. However, inside an Aurelia
    application, it cannot be used in every scenario; for example, it doesn't work
    well on custom elements, as it overwrites the element's content.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`t`属性是来自`i18next`的一个遗留问题。当独立使用，在Aurelia之外时，`i18next`使用这个属性在DOM树内翻译文本。`aurelia-i18n`库可能支持它，只是为了让有`i18next`经验的人可以像往常一样使用它。然而，在一个Aurelia应用内部，它并不能在每种情况下使用；例如，它在与自定义元素一起使用时表现不佳，因为它会覆盖元素的内容。'
- en: As a rule of thumb, when translating inside a template, I always go with the
    binding behavior technique. Since the `t` attribute and the `t` value converter
    have such important limitations, this technique is the most flexible one, and
    I can be consistent by using the same technique across the whole application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，在模板内翻译时，我总是选择绑定行为技术。由于`t`属性和`t`值转换器有如此重要的限制，这种技术是最灵活的，我可以通过在整个应用程序中使用相同的技术来保持一致性。
- en: If the application has only one language, or if the user cannot change the current
    language once the application is started, then one could use the value converter
    technique. However, I don't see the real benefits. Although its memory footprint
    is probably a little smaller than the binding behavior's, the gain won't be major,
    and if the context changes and the application suddenly needs to support locale
    changes, every single instance of the value converter will have to be replaced
    by the binding behavior, everywhere. As such, using the value converter can be
    a somewhat reckless gamble in most cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序只有一种语言，或者如果用户在应用程序启动后不能更改当前语言，那么可以使用值转换器技术。然而，我看不出真正的益处。尽管它的内存占用可能比绑定行为略小一些，但收益不会很大，而且如果上下文发生变化，应用程序突然需要支持区域设置变化，每个值转换器实例都不得不被绑定行为替换，到处都是。因此，在大多数情况下，使用值转换器可能是一种相当鲁莽的赌博。
- en: Finally, I directly use the API when I need to translate texts in JS code, in
    which case the `I18N` instance can easily be injected in the class needing it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当需要在JS代码中翻译文本时，我会直接使用API，在这种情况下，`I18N`实例可以很容易地被注入到需要它的类中。
- en: Those guidelines apply for translation, but also for the formatting features
    described in the following sections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南适用于翻译，也适用于以下各节中描述的格式化特性。
- en: Formatting numbers
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化数字
- en: As mentioned previously, `aurelia-i18n` also relies on the native Intl API to
    offer number formatting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`aurelia-i18n`也依赖于本地Intl API提供数字格式化功能。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since the library uses the Intl API, I strongly suggest you look it up if you
    are not familiar with it. The Mozilla Developer Network has an extensive documentation
    on the subject: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于库使用了Intl API，如果你不熟悉它，我强烈建议你查阅相关资料。Mozilla开发者网络提供了关于该主题的详尽文档：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
- en: Using the value converter
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值转换器
- en: 'The simplest way to format a number is to use the `nf` value converter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化数字的最简单方法是使用`nf`值转换器：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It simply creates an `Intl.NumberFormat` instance using the current locale and
    calls its `format` method, passing the `1234` value to it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是使用当前区域设置创建一个`Intl.NumberFormat`实例，并调用其`format`方法，将`1234`值传递给它。
- en: 'It can also be passed an `Intl.NumberFormat` instance directly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以直接传递一个`Intl.NumberFormat`实例：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In such a case, the passed `Intl.NumberFormat` instance will be used directly
    to `format` the value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，直接使用传递的`Intl.NumberFormat`实例来`format`值。
- en: 'Finally, it can be passed an options object and, optionally, a locale or an
    array of locales:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它可以传递一个选项对象，可选地传递一个区域设置或区域设置数组：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In such a case, an `Intl.NumberFormat` instance will be created to `format`
    the value using the options and the locale(s). If no locale is passed, the current
    locale will be used.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将创建一个`Intl.NumberFormat`实例，使用选项和区域设置来`format`值。如果没有传递区域设置，将使用当前区域设置。
- en: Using the binding behavior
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用绑定行为
- en: 'The `nf` value converter has the same problem that the `t` value converter
    has: if the current locale changes, it has no way of being notified. As such,
    if the application allows you to change the language during its life cycle, the
    `nf` binding behavior should be used instead:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`nf`值转换器有一个与`t`值转换器相同的问题：如果当前区域设置发生变化，它没有办法得到通知。因此，如果应用程序在其生命周期内允许您更改语言，应使用`nf`绑定行为：'
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It works the exact same way as the `t` binding behavior, listening for the `aurelia-translation-signal`
    binding signal and forcing its binding expression to reevaluate when the signal
    is emitted.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它的运作方式与`t`绑定行为完全相同，监听`aurelia-translation-signal`绑定信号，并在信号发出时强制重新评估其绑定表达式。
- en: It also works the same way by decorating its binding instruction with an `nf`
    value converter behind the scenes, and passing all its parameters back to it,
    so it supports the same parameters as the value converter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它也是通过在幕后用`nf`值转换器装饰其绑定指令，并将所有参数传递给它，因此它支持与值转换器相同的参数。
- en: Using code
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码
- en: 'Behind the scenes, the value converter relies on the `nf` method of `I18N`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，值转换器依赖于`I18N`的`nf`方法：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method simply creates an `Intl.NumberFormat` instance using the provided
    options and locale(s), and returns it. If no locale is passed, the current locale
    is used:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法简单地使用提供的选项和区域设置创建一个`Intl.NumberFormat`实例，并返回它。如果没有传递区域设置，将使用当前区域设置：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we call the `nf` method to create an `Intl.NumberFormat` instance using
    the provided options and the current locale, then we call the resulting `Intl.NumberFormat`
    object's `format` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`nf`方法使用提供的选项和当前区域设置创建一个`Intl.NumberFormat`实例，然后我们调用结果`Intl.NumberFormat`对象的`format`方法。
- en: Formatting dates
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化日期
- en: The Intl API also includes date formatting features. As such, `aurelia-i18n`
    encapsulates those features to make it simpler to work with the current locale.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化的Intl API还包括日期格式化功能。因此，`aurelia-i18n`封装了这些功能，使其更简单地与当前区域设置一起工作。
- en: Using the value converter
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值转换器
- en: 'The `df` value converter works pretty much the same as the `nf` value converter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`df`值转换器的工作方式与`nf`值转换器几乎相同：'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The value on which it applies is expected to be either a `Date` object or a
    `string`, which will be transformed into a `Date` object using the `Date(string)`
    constructor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它应用的值预期要么是一个`Date`对象，要么是一个`string`，该`string`将使用`Date(string)`构造函数转换为`Date`对象。
- en: 'The `df` value converter works just like `nf` behind the scenes, except that
    it works with the `Intl.DateTimeFormat` class. This means that it can accept an
    instance of `Intl.DateTimeFormat` as a parameter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`df`值转换器在幕后的工作方式与`nf`基本相同，不同之处在于它使用`Intl.DateTimeFormat`类。这意味着它可以接受一个`Intl.DateTimeFormat`实例作为参数：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In such a case, the `format` method will be called directly on the provided
    `Intl.DateTimeFormat` instance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`format`方法将直接在提供的`Intl.DateTimeFormat`实例上调用。
- en: 'It can also accept an options object and, optionally, a locale or an array
    of locales:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以接受一个选项对象，以及可选的区域设置或区域设置数组：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In such a case, an `Intl.DateTimeFormat` instance will be created to `format`
    the value using the options and the locale(s). If no locale is passed, the current
    locale will be used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将使用选项和区域设置创建一个`Intl.DateTimeFormat`实例来`format`值。如果没有传递区域设置，将使用当前区域设置。
- en: Using the binding behavior
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用绑定行为
- en: 'The `df` value converter has the same issue as the `t` and the `nf` value converters:
    it cannot know when the current locale changes, so it cannot re-evaluate its output.
    As such, the `df` binding behavior should be used when the locale can be changed
    during the life cycle of the application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`df`值转换器与`t`和`nf`值转换器有同样的问题：它无法知道当前区域设置何时发生变化，因此无法重新评估其输出。因此，当应用程序生命周期中区域设置可以发生变化时，应使用`df`绑定行为：'
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It works the same way as the `t` and the `nf` binding behaviors, it decorates
    its binding expression with the `df` value converter, and forces it to re-evaluate
    its value when the `aurelia-translation-signal` is emitted.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与`t`和`nf`绑定行为相同，它用`df`值转换器装饰其绑定表达式，并在`aurelia-translation-signal`发出时强制它重新评估其值：
- en: Additionally, it passes its parameters to its underlying value converter, so
    it supports the same signatures as the `df` value converter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它将其参数传递给其底层值转换器，因此它支持与`df`值转换器相同的签名。
- en: Using code
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码
- en: 'The value converter relies on the `I18N` class''s `df` method to format dates:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器依赖于`I18N`类的`df`方法来格式化日期：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly to the `nf` method, it simply creates an instance of `Intl.DateTimeFormat,`
    using the provided options and locale(s), and returns it. If no locale is provided,
    the current locale is used:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与`nf`方法类似，它简单地使用提供的选项和区域设置创建一个`Intl.DateTimeFormat`实例，并返回它。如果没有提供区域设置，将使用当前区域设置：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we call the `df` method to create an `Intl.DateTimeFormat` instance using
    the provided options and the current locale, then we call the resulting `Intl.DateTimeFormat`
    object's `format` method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`df`方法使用提供的选项和当前区域设置创建一个`Intl.DateTimeFormat`实例，然后我们调用结果`Intl.DateTimeFormat`对象的`format`方法。
- en: Formatting relative time
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化相对时间
- en: The `aurelia-i18n` library also provides a service to format time relatively
    to the current system time. It allows you to output human-friendly time deltas
    such as `now`, `5 seconds ago`, `2 days ago`, and so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-i18n`库还提供了一个服务，用于将时间相对于当前系统时间格式化。它允许你输出类似于`now`、`5 seconds ago`、`2
    days ago`等人友好的时间差。'
- en: Using the value converter
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值转换器
- en: 'The simplest way to display a human-friendly time delta is to use the `rt`
    value converter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 显示人类友好时间差的最简单方法是使用`rt`值转换器：
- en: '`src/contacts/components/details.html`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/details.html`'
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, the output could be something like `5 days ago`, depending on the value
    of `contact.modifiedAt` and the current system time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，输出可能是类似于`5 days ago`，这取决于`contact.modifiedAt`的值和当前系统时间。
- en: The value on which the converter applies is expected to be either a `Date` object
    or a `string`, which will be transformed into a `Date` object using the `Date(string)`
    constructor.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器应用的值预期要么是一个`Date`对象，要么是一个`string`，它将使用`Date(string)`构造函数转换为`Date`对象。
- en: Periodically refreshing the value
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 周期性地刷新值
- en: 'The previous example has a little problem: the output of `rt` is relative to
    the current time but never gets updated. It will seem kind of strange to the user
    to see `5 seconds ago` displayed forever.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子有一个小问题：`rt`的输出相对于当前时间，但从不更新。如果永远显示`5秒钟前`，用户可能会觉得有些奇怪。
- en: 'Typically, the `rt` value converter will be used with the `signal` binding
    behavior:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`rt`值转换器将与`signal`绑定行为一起使用：
- en: '`src/contacts/components/details.html`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/details.html`'
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Of course, this means that we need to emit the `rt-update` signal somewhere,
    probably from the view-model:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着我们需要在某个地方发出`rt-update`信号，可能是在视图模型中：
- en: '`src/contacts/components/details.js`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/details.js`'
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we start by having a `BindingSignaler` instance injected in the view-model.
    Then, once the contact is loaded, we start emitting an `rt-update` signal every
    second using the `setInterval` function. Each time the signal is emitted, the
    `signal` binding behavior in the view will refresh the binding and reapply the
    `rt` value converter to `contact.modifiedAt`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先在视图模型中注入一个`BindingSignaler`实例。然后，一旦联系人加载完成，我们使用`setInterval`函数每秒发出一个`rt-update`信号。每次发出信号时，视图中的`signal`绑定行为将刷新绑定并重新应用`rt`值转换器到`contact.modifiedAt`。
- en: We also prevent a memory leak by stopping the emission of the signal when the
    component is deactivated using the `clearInterval` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`clearInterval`函数在组件停用时停止信号的发出，从而防止内存泄漏。
- en: 'This code still has a problem: the binding will be refreshed with a delay if
    the current locale changes. This is easy to fix:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仍然有一个问题：如果当前区域更改，绑定将会有延迟地刷新。这个问题很容易解决：
- en: '`src/contacts/components/details.html`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/details.html`'
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We simply need to listen for the `aurelia-translation-signal` in addition to
    the `rt-update` signal. The former signal is emitted by `I18N` every time the
    current locale changes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要监听`aurelia-translation-signal`信号，以及`rt-update`信号。前者是由`I18N`在当前区域每次更改时发出的信号。
- en: Now the displayed time delta for `contact.modifiedAt` will be refreshed every
    second, and will also be updated when the current locale changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`contact.modifiedAt`显示的时间差将每秒刷新，并且在当前区域更改时也会更新。
- en: Using code
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码
- en: 'The value converter relies on a distinct class, named `RelativeTime`, which
    is exported by `aurelia-i18n` and offers the following method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器依赖于一个独特的类，名为`RelativeTime`，该类由`aurelia-i18n`导出，并提供以下方法：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method simply calculates the difference between the provided `time` and
    the current system time, and uses a built-in set of translations to return a human-friendly
    text using the current locale.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法简单地计算提供的`time`和当前系统时间之间的差异，并使用内置的翻译集合，返回当前区域的人友好的文本。
- en: If for some reason you need to transform a date in a human-friendly relative
    time from some JS code, you can easily inject an instance of `RelativeTime` in
    your class and use its `getRelativeTime` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从一些JS代码中转换日期为人友好的相对时间，你可以在你的类中轻松注入`RelativeTime`的一个实例并使用其`getRelativeTime`方法。
- en: Translating our contact management application
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译我们的联系人管理应用程序
- en: At this point, you have all the tools needed to completely internationalize
    our contact management application except for the validation messages and document
    titles, which require integration with `aurelia-validation` and `aurelia-router`
    and are covered in the following sections.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，您已经拥有完全国际化我们的联系人管理应用程序所需的所有工具，除了验证消息和文档标题，它们需要与`aurelia-validation`和`aurelia-router`集成，这部分内容将在接下来的章节中详细介绍。
- en: Showing how to internationalize every template in the application would take
    too long and be pretty tedious, so I'll leave it as an exercise to the reader.
    As usual, this chapter's sample application can be used as a reference.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何国际化应用程序中的每个模板会花费太长时间并且相当繁琐，所以我会留给读者作为一个练习。像往常一样，本章的示例应用程序可以作为参考。
- en: The following section assumes that you have internationalized everything that
    can be in your working copy of the application. If you skip doing this manually,
    I strongly suggest that you get an up-to-date copy of the code from the `chapter-8/samples/app-translated`
    directory in the book's assets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节假设您已经国际化了您工作副本中应用程序中可以国际化的所有内容。如果您跳过手动执行此操作，我强烈建议您从书籍资源中的`chapter-8/samples/app-translated`目录获取最新的代码副本。
- en: Integrating with validation
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与验证集成
- en: If you add internationalization to an application that uses `aurelia-validation`,
    you'll want to translate the error messages. This section explains how to integrate
    both libraries together to achieve that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向使用`aurelia-validation`的应用程序添加国际化，您将希望翻译错误消息。本节解释了如何将这两个库结合起来实现这一点。
- en: Overriding ValidationMessageProvider
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖ValidationMessageProvider
- en: 'The validation library uses a `ValidationMessageProvider` class to retrieve
    error messages. Let''s extend this class and use `I18N` to get messages from a
    translation file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 验证库使用一个`ValidationMessageProvider`类来获取错误消息。让我们扩展这个类，并使用`I18N`从翻译文件中获取消息：
- en: '`src/validation/i18n-validation-message-provider.js`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/i18n-validation-message-provider.js`'
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we start by having a `ValidationParser` instance, which is needed by the
    `ValidationMessageProvider` base class, and an `I18N` instance injected in the
    constructor. We also define as `options` the prefixes to use when building the
    key before performing a translation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个`ValidationParser`实例，这是`ValidationMessageProvider`基类所需的，并在构造函数中注入一个`I18N`实例。我们还定义了`options`，在执行翻译前用于构建键的前缀。
- en: Next, we override the `getMessage` method, in which we build a translation key,
    then ask the `I18N` instance to translate it. Since the `tr` method ultimately
    falls back to returning the key if no translation was found for it, we use the
    translation only if one was found by comparing the result to the key. Otherwise,
    we fall back to using the base implementation of `getMessage`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们覆盖了`getMessage`方法，在其中我们构建了一个翻译键，然后请求`I18N`实例对其进行翻译。由于`tr`方法最终如果没有找到对应的翻译，就会返回键，所以我们只有在找到翻译时才使用翻译，否则我们退回到`getMessage`的基础实现。
- en: When building the translation key, if the key doesn't contain any dot or colon,
    we prefix it with the default prefix of `options`, because we consider that the
    key will be the name of the validation rule, which is the default behavior. However,
    our `getMessage` implementation allows for validation rules to define a custom
    message key, which can be a custom translation path to get the message text from
    another area or namespace in the translation files.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 构建翻译键时，如果键不包含任何点或冒号，我们会在其前面加上`options`的默认前缀，因为我们认为这个键将是验证规则的名称，这是默认行为。然而，我们的`getMessage`实现允许验证规则定义一个自定义消息键，这可以是一个自定义的翻译路径，从翻译文件中的另一个区域或命名空间获取消息文本。
- en: 'The `getDisplayName` method follows a similar process: we prefix the key with
    the default prefix of `options`, translate it, then use the translation, if one
    is found, or fall back to the base implementation if not.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDisplayName`方法遵循一个类似的过程：我们在键前面加上`options`的默认前缀，翻译它，然后使用翻译（如果找到了的话），或者如果没有找到，就退回到基础实现。'
- en: By default, we'll consider that all validation translations will live under
    a common `validation` object, which will contain all error messages under a `messages`
    object, and all property display names in a `properties` object. Those path prefixes
    are the default values stored on the `options` object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们会认为所有的验证翻译都会存放在一个共同的`validation`对象下，该对象将在一个`messages`对象下包含所有错误消息，在`properties`对象下包含所有属性显示名称。这些路径前缀是存储在`options`对象中的默认值。
- en: This `options` object could prove useful if some part of the application needs
    to look its validation keys up in a different part of the translation files; in
    such a case, this area in the application could define its own, customized instance
    of `I18nValidationMessageProvider`, using different `options` values.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`options`对象如果应用程序的某个部分需要在其翻译文件的不同部分查找验证键时可能很有用；在这种情况下，应用程序的这部分可以定义自己的、定制的`I18nValidationMessageProvider`实例，使用不同的`options`值。
- en: 'The next step is to tell the validation system to use this class instead of
    the default `ValidationMessageProvider`. The best place to do this is in the `validation`
    feature''s `configure` function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是告诉验证系统使用这个类而不是默认的`ValidationMessageProvider`。在`validation`特性的`configure`函数中执行这个操作最合适：
- en: '`src/validation/index.js`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/index.js`'
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we simply tell the DI container that an instance of `I18nValidationMessageProvider`
    should be used in place of `ValidationMessageProvider`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需告诉DI容器使用`I18nValidationMessageProvider`实例代替`ValidationMessageProvider`。
- en: Adding the translations
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加翻译
- en: 'Now that the validation system knows where to get the translated error messages
    and property display names, let''s add the proper translations:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在验证系统已经知道去哪里获取翻译后的错误消息和属性显示名称，接下来让我们添加正确的翻译：
- en: '`locales/en/translation.json`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`locales/en/translation.json`'
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The keys under `messages` are the standard rules supported natively by `aurelia-validation`
    at the time of writing, along with the messages for the custom rules we defined
    in our `validation` feature. Those under `properties` are the display names of
    each property used in the application. As for the French translations, you can
    get them from this chapter's sample application.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`messages`下的键是`aurelia-validation`在撰写本文时支持的标准规则，以及我们在`validation`特性中定义的自定义规则的消息。那些在`properties`下的键是应用程序中使用的每个属性的显示名称。至于法语翻译，您可以从本章的示例应用程序中获得。'
- en: At this point, if you run the application, click the **New** button, and, for
    example, put gibberish in the **Birthday** textbox then try to save, you should
    see a translated error message appear. However, if you change the current locale
    using the locale picker at the top right of the viewport, the validation error
    won't be refreshed with the new locale.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，如果您运行应用程序，点击**新建**按钮，例如在**生日**文本框中输入胡言乱语然后尝试保存，您应该会看到一条翻译后的错误消息出现。然而，如果您使用视图区域右上角的地区选择器更改当前语言环境，验证错误将不会随新语言环境刷新。
- en: To achieve this, the `ValidationController` instance needs to be told to revalidate
    when the current locale changes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`ValidationController`实例需要被告知在当前语言环境发生变化时重新验证。
- en: Refreshing validation errors
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新验证错误
- en: In order to refresh the validation errors, the contact creation view-model must
    subscribe to an event named `i18n:locale:changed`, which is published through
    the application's event aggregator by the `I18N` instance when the current locale
    is changed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新验证错误，联系人创建视图模型必须订阅一个名为`i18n:locale:changed`的事件，当当前语言环境发生变化时，通过应用程序的事件聚合器由`I18N`实例发布。
- en: 'The event aggregator, being part of Aurelia''s default configuration, is already
    installed and loaded, so we don''t need to do anything more to use it in our application.
    We can directly update our `creation` view-model:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 事件聚合器是Aurelia默认配置的一部分，已经安装并加载，因此在我们的应用程序中使用它时，我们不需要做任何事情。我们可以直接更新我们的`creation`视图模型：
- en: '`src/contacts/components/creation.js`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/creation.js`'
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we simply subscribe to the proper event and trigger validation when the
    current locale changes. Of course, we also dispose the subscription when the component
    is deactivated, to prevent a memory leak.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需订阅正确的事件，在当前语言环境发生变化时触发验证。当然，当组件被停用时，我们也需要处理订阅，以防止内存泄漏。
- en: If you again try to save a new contact with invalid data, then change the locale
    while validation errors are displayed, you should see the messages be refreshed
    with the new locale on the fly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次尝试保存带有无效数据的新联系人，然后在显示验证错误时更改语言环境，您应该会看到错误消息随着新语言环境实时刷新。
- en: Integrating with the Router
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合路由器
- en: You may have noticed that we have completely overlooked translation of the document
    title, the one displayed in the browser's top bar. Since this title is controlled
    by the `aurelia-router` library, we need to find some way to integrate the routers
    with the `I18N` service.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到我们完全忽略了文档标题的翻译，即在浏览器顶部栏显示的标题。由于这个标题由`aurelia-router`库控制，我们需要找到一种将路由器与`I18N`服务集成的方法。
- en: 'In fact, this is pretty easy to do. The `Router` class offers an integration
    point specifically designed for this kind of scenario:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这样做相当简单。`Router`类提供了一个专门为此类场景设计的集成点：
- en: '`src/main.js`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`'
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we first import the `Router` class from the `aurelia-router` library and
    the `EventAggregator` class from the `aurelia-event-aggregator` library. Next,
    when the `Promise` returned by the `setup` method of `I18N` resolves, we retrieve
    the application's root router instance and we set its `transformTitle` property
    to a function that will take a route's title in and translate it using `tr` method
    of `I18N`. We also retrieve the event aggregator and subscribe to the `i18n:locale:changed`
    event. When this event is published, we call the router's `updateTitle` method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先从`aurelia-router`库导入`Router`类和从`aurelia-event-aggregator`库导入`EventAggregator`类。接下来，当`I18N`的`setup`方法返回的`Promise`解决时，我们检索应用程序的根路由器实例，并将其`transformTitle`属性设置为一个函数，该函数将接收一个路由的标题并使用`I18N`的`tr`方法对其进行翻译。我们还检索事件聚合器并订阅`i18n:locale:changed`事件。当这个事件发布时，我们调用路由器的`updateTitle`方法。
- en: 'Of course, we need to replace all of the titles with translation keys and add
    those to the translation files. I''ll leave this as an exercise for the reader;
    however, here''s a quick list of where those titles must be changed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要将所有标题替换为翻译键，并将这些添加到翻译文件中。我将留这作为读者的练习；不过，这里有一个快速列表，列出了那些标题必须更改的地方：
- en: The application's main title, set in the `app` component's `configureRouter`
    method (in `src/app.js`)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的主标题，在`src/app.js`中的`app`组件的`configureRouter`方法中设置。
- en: The title of the `contacts` feature's main route, added to the router in the
    contact's `configure` function (in `src/contacts/index.js`)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contacts`功能的主路由的标题，在`src/contacts/index.js`中的联系人的`configure`函数中添加到路由器。'
- en: The title of the first two routes defined in the contacts `main` component (in
    `src/contacts/main.js`)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/contacts/main.js`中定义的第一个两个路由的标题。
- en: This chapter's completed sample can be used as a reference.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成的示例可以作为参考。
- en: If you go ahead and test this, the document title should be correctly translated.
    It should also be updated accordingly when changing the current locale.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您继续测试这个，文档标题应该被正确翻译。当更改当前区域设置时，它也应该相应地更新。
- en: Segregating translations by feature
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按功能分割翻译
- en: Since the beginning of the book, one of our goals was to keep the features in
    our application as decoupled as possible. The way we internationalized our application
    in this chapter completely violates that rule.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从书的开头，我们的一个目标就是尽可能保持应用程序中的特性解耦。本章中我们国际化的方式完全违反了这条规则。
- en: There are ways to split the translation files by feature using namespaces, which
    are an `i18next` feature. However, this adds another layer of complexity to our
    application. This should make us reevaluate our architectural choices. Are the
    benefits we get from having decoupled features worth the continuously increasing
    complexity they add? The question is very much worth asking.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法通过使用命名空间来按照功能分割翻译文件，这是`i18next`的一个特性。然而，这为我们的应用程序增加了另一层复杂性。这应该让我们重新评估我们的架构选择。我们从拥有解耦特性的好处是否值得它们不断增加的复杂性？这个问题非常值得提出。
- en: If the answer to that question is still yes, and if you are curious about how
    this can be done, you can take a look at the sample application under `chapter-8/samples/app-translations-by-feature`
    in the book's assets, which implements this segregation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这个问题答案仍然是肯定的，并且您对如何做到这一点感到好奇，您可以查看本书资源中的`chapter-8/samples/app-translations-by-feature`下的示例应用程序，它实现了这种分割。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Internationalization is often overlooked as being a simple topic, but as we
    have seen in this chapter, it has impacts at many levels in an application. It
    can force a team to rethink some architectural decisions if translation is added
    late in a project.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化和被认为是简单话题常常被忽视，但正如本章所看到，在应用程序中它在很多层面都有影响。如果在一个项目后期添加翻译，它可能会迫使一个团队重新思考一些架构决策。
- en: However, a well-designed and powerful internationalization library can greatly
    help with those tasks. Building on a renowned translation library, `i18next,`
    and on a new web standard, the Intl API, `aurelia-i18n`, is such a library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个设计良好且功能强大的国际化库可以极大地帮助这些任务。建立在著名的翻译库`i18next`和新的网络标准Intl API之上，`aurelia-i18n`是这样的一个库。
