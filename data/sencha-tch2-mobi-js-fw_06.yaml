- en: Chapter 6. Getting the Data In
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。获取数据
- en: One of the key aspects of any application is the handling of data—getting data
    into the application, so that you can manipulate and store it, and then get it
    out again for display. We will spend the next two chapters covering data handling
    in Sencha Touch. This first chapter on data will focus on getting data into your
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的关键方面之一是处理数据——将数据输入应用程序，以便您可以操作和存储它，然后再次获取以供显示。我们将用接下来的两章来讨论Sencha Touch中的数据处理。本章将重点介绍如何将数据输入您的应用程序。
- en: We will start with a discussion of the data models that are used to describe
    your data. We will then discuss the readers that gather the data and the stores
    used to hold the data for use in our application. Once we have a grasp on where
    the data goes, we will cover how to use forms to get it there. We will look at
    how to validate your data and provide you with some examples of form submission.
    We will finish up with a look at getting the data back into a form for editing.
    This will serve as our starting point for the next chapter on data, which will
    cover getting data back for display.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论用于描述您数据的模型开始。然后，我们将讨论收集数据的读取器以及用于在应用程序中保存数据的存储。一旦我们了解了数据去了哪里，我们将介绍如何使用表单来获取数据。我们将查看如何验证您的数据，并为您提供一些表单提交示例。最后，我们将介绍如何将数据回填到表单中以进行编辑。这将是下一章关于数据的起点，该章节将涵盖如何获取数据以供显示。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Data models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据模型
- en: Data formats
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据格式
- en: Data stores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储
- en: Using forms and data stores
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单和数据存储
- en: Models
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: The first step in working with data in a Sencha Touch application is to create
    a model of the data. If you are used to database-driven applications, it's helpful
    to think of the model as being a database schema; it's a construct that defines
    the data we are going to store, including the data type, validations, and structure.
    This provides the rest of our application with a common map for understanding
    the data being passed back and forth.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha Touch应用程序中处理数据的第一步是创建数据的模型。如果您习惯于数据库驱动的应用程序，将模型视为数据库架构会有所帮助；这是一个定义我们将要存储的数据的构造，包括数据类型、验证和结构。这为我们的应用程序的其余部分提供了一个共同的映射，用于理解来回传递的数据。
- en: In Sencha Touch 2, the model can also be used to hold the information for a
    single data record. This means that we can create, read, update, and delete the
    single record using functions that are already built in to the Sencha Touch `Ext.data.Model`
    component.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha Touch 2中，模型还可以用于保存单个数据记录的信息。这意味着我们可以使用已经内置到Sencha Touch `Ext.data.Model`组件中的函数来创建、读取、更新和删除单个记录。
- en: The basic model
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本模型
- en: 'At its most basic, the model describes the data fields using `Ext.define()`
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的情况下，模型使用`Ext.define()`描述数据字段，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line declares that we have named our new model `User` and that we
    are extending the default `Ext.data.Model`. We set up the model's configuration
    options inside the `config` section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明我们已经将新模型命名为`User`，并且我们正在扩展默认的`Ext.data.Model`。我们在`config`部分内设置模型的配置选项。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The model setup has changed a bit in Version 2\. We now use `Ext.define` and
    extend instead of creating things through the old Model Manager. We also wrap
    the model's options in a `config` section. Outside the `extend` setting, the rest
    of your model options should be wrapped in this `config` section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本2中，模型设置有所变化。我们现在使用`Ext.define`和扩展，而不是通过旧的模型管理器创建事物。我们还将模型的选项包裹在一个`config`部分内。在`extend`设置外，您的模型选项的其余部分应该用这个`config`部分包裹起来。
- en: 'Inside the `config` section, we describe our data fields as an array of `fields`
    including `name`, `type`, and optional `defaultValue` fields. The `name` field
    is simply how we want to refer to the data in our code. The valid values for `types`
    are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config`部分内，我们将描述我们的数据字段作为一个`fields`数组，包括`name`、`type`和可选的`defaultValue`字段。`name`字段就是我们希望在代码中引用数据的方式。`type`的有效值是：
- en: '`auto`: This is a default value that just accepts the raw data without conversion'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`：这是一个默认值，它接受原始数据而不进行转换'
- en: '`string`: This converts the data into a string'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：这将数据转换为字符串'
- en: '`int`: This converts the data into an integer'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：这将数据转换为整数'
- en: '`float`: This converts the data into a floating point integer'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：这将数据转换为浮点整数'
- en: '`boolean`: This converts the data into a true or false Boolean value'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`：这将数据转换为真或假的布尔值'
- en: '`date`: This converts the data into a JavaScript `Date` object'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：这将数据转换为JavaScript `Date`对象'
- en: 'The `defaultValue` field can be used to set a standard value to be used if
    no data is received for that field. In our example, we set the value of `active`
    to `true`. We can use this when creating a new user instance with `Ext.create()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultValue`字段可以用来设置一个标准值，如果该字段没有收到数据，就可以使用这个值。在我们的例子中，我们将`active`的值设置为`true`。我们可以在使用`Ext.create()`创建新的用户实例时使用这个值：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we did not provide a value for `active` in our new user instance,
    so it just uses our `defaultValue` field from the model definition. This can also
    help when the user forgets to enter a value. We can also double-check the information
    our user enters by using `validations`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在新的用户实例中没有为`active`提供值，所以它只是使用了我们的模型定义中的`defaultValue`字段。这也可以在用户忘记输入值时帮助用户。我们还可以通过使用`validations`来验证用户输入的信息。
- en: Model validations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型验证
- en: Model validations ensure that we are getting the data we think we are getting.
    These validations serve two functions. The first is to provide the guidelines
    for how data is entered. For example, we would typically want a username to consist
    only of letters and numbers; the validation can enforce this constraint and inform
    the user when they use the wrong character.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模型验证确保我们得到我们认为得到的数据。这些验证有两个功能。第一个是提供数据输入的指导方针。例如，我们通常希望用户名只包含字母和数字；验证可以强制这个约束，并在用户使用错误字符时通知用户。
- en: The second is security; malicious users can also use the form field to send
    information that might potentially be harmful to our database. For example, sending
    `DELETE * FROM users;` as your username can cause problems if the database is
    not properly secured. It is always a good idea to validate data, just in case.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是安全性；恶意用户也可以通过表单字段发送可能对我们数据库有害的信息。例如，如果数据库没有得到适当保护，将`DELETE * FROM users;`作为用户名发送可能会造成问题。始终验证数据是个好主意。
- en: 'We can declare `validations` as part of our data model in much the same way
    that we declare our fields. For example, we can add the following code to our
    `User` model:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`validations`作为数据模型的一部分来声明，就像我们声明字段一样。例如，我们可以在我们的`User`模型中添加以下代码：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our example, we have added four validations. The first one tests the presence
    of an `age` value. If there is no value for `age`, we get an error. The second
    validator, `exclusion`, tests for things we don''t want to see as a value for
    this field. In this case, we have a list of two items for the username that we
    don''t want to see: `Admin` and `Root`. The third validator tests to make sure
    that our value for the username is at least three characters long. The final validator
    checks the format of our username using a regular expression.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们增加了四个验证。第一个测试`age`值的存在。如果没有`age`的值，我们会得到一个错误。第二个验证器`exclusion`测试我们不希望在此字段中看到的值。在这个例子中，我们有一个用户名的列表，我们不希望看到的是`Admin`和`Root`。第三个验证器确保我们的用户名至少有三个字符长。最后一个验证器使用正则表达式检查我们的用户名格式。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Regular expressions**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: '**Regular expressions**, also called **regexes** or **regexps**, are an extremely
    powerful tool for matching the structure of a string. You can use RegEx to search
    for particular characters, words, or patterns within a string. A discussion of
    regular expressions would require its own book, but there are a number of good
    resources available online.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**，也称为**正则表达式**或**正则表达式**，是匹配字符串结构的极其强大的工具。您可以使用正则表达式在字符串中搜索特定的字符、单词或模式。正则表达式的讨论需要一本自己的书，但网上有许多好的资源。'
- en: 'Good tutorials are available at:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好的教程可以在以下位置找到：
- en: '[http://www.zytrax.com/tech/web/regex.htm](http://www.zytrax.com/tech/web/regex.htm).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.zytrax.com/tech/web/regex.htm](http://www.zytrax.com/tech/web/regex.htm)。'
- en: 'A searchable database of regular expressions can be found at:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可搜索的正则表达式数据库可以在以下位置找到：
- en: '[http://regexlib.com](http://regexlib.com).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://regexlib.com](http://regexlib.com)。'
- en: 'A wonderful regular expression tester is also available at:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个出色的正则表达式测试器也在此处提供：
- en: '[http://www.rexv.org/](http://www.rexv.org/).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.rexv.org/](http://www.rexv.org/)。'
- en: 'We can test our validations by using the `validate` method on our new `User`
    instance:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用我们新`User`实例的`validate`方法来测试我们的验证：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that we intentionally dropped the `age` field this time, to give us an
    error. If we take a look at our console, we can see the `Ext.data.Errors` object
    that we get back, as shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们故意这次省略了`age`字段，以给我们一个错误。如果我们查看我们的控制台，我们可以看到我们返回的`Ext.data.Errors`对象，如下面的屏幕截图所示：
- en: '![Model validations](img/0748OS_06_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![模型验证](img/0748OS_06_01.jpg)'
- en: 'This is the console output for our `errors` object. The `errors` object includes
    a method called `isValid()`, which will return a `true` or `false` value. We can
    use this method to test for errors and return a message to the user, using something
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们`errors`对象的控制台输出。`errors`对象包括一个名为`isValid()`的方法，它将返回一个`true`或`false`值。我们可以使用这个方法来测试错误并向用户返回消息，例如：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we test `errors` to see if it is valid and if not, display the information
    from the first error. We then use `getField()` and `getMessage()` to display in
    our alert to the user. This detailed error information is included in the `items`
    list of the `errors` object. In practical usage there could be more than one error,
    so we would need to loop through the `items` list to grab all of the errors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们测试`errors`是否有效，如果不有效，则显示第一个错误的信息。然后我们使用`getField()`和`getMessage()`在用户的警报中显示信息。这些详细的错误信息包含在`errors`对象的`items`列表中。在实际使用中可能会有多个错误，因此我们需要遍历`items`列表以获取所有错误。
- en: 'We can also change the default error message by setting additional configuration
    options on the validations for:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在验证上设置额外的配置选项来更改默认错误消息：
- en: '`exclusionMessage`: This is used when we get an excluded value for a field'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exclusionMessage`：当我们在字段中得到一个被排除的值时使用。'
- en: '`formatMessage`: This is used when we get an improperly formatted value for
    a field'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formatMessage`：当我们在字段中得到格式不正确的值时使用。'
- en: '`inclusionMessage`: This is used when we do not get an included value for a
    field'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inclusionMessage`：当我们在字段中没有得到包含的值时使用。'
- en: '`lengthMessage`: This is used when we get a value for a field that does not
    meet our required length'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lengthMessage`：当字段的值不符合我们所需的长度时使用此功能。'
- en: '`presenceMessage`: This is used when we do not reserve a required value for
    a field'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`presenceMessage`：当我们在字段中没有保留所需的值时使用。'
- en: Customizing these errors will help the user understand exactly what went wrong
    and what needs to be done to correct the problem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定制这些错误将帮助用户了解到底出现了什么问题以及需要采取什么措施来解决问题。
- en: Model methods
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型方法
- en: 'Our models can also contain methods that can be called on any instance of our
    model. For example, we can add a method called `deactivate` to our model by adding
    the following to our `User` model after the `fields` list:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型还可以包含可以对模型实例调用的方法。例如，我们可以在`User`模型的`fields`列表之后添加一个名为`deactivate`的方法。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function tests to see if our current value of `active` is `true`. If it
    is, we set it to `false`. Once we create `newUser` as we did previously, we can
    call the function as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数检查我们当前的`active`值是否为`true`。如果是，我们将其设置为`false`。一旦我们像以前那样创建了`newUser`，我们可以像以下方式调用该函数：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These model methods provide a great way to implement common functions in your
    model.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型方法为在模型中实现常见功能提供了很好的方式。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**CRUD**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**CRUD**'
- en: While model methods might look like a good place for adding functions to save
    our model, you really don't need to. These types of functions—`Create`, `Read`,
    `Update`, and `Destroy`—are often referred to by the unattractive acronym **CRUD**,
    and they are handled automatically by Sencha Touch. We will go over these functions
    a bit later in this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模型方法可能看起来是一个添加函数以保存我们模型的不错选择，但实际上你真的不需要这样做。这些类型的函数—`Create`、`Read`、`Update`和`Destroy`—通常被称为不吸引人的缩写**CRUD**，它们由Sencha
    Touch自动处理。我们将在本章后面稍后再讨论这些功能。
- en: Now that we have our model's fields, validations, and functions defined, we
    need a way to pass data to and from the model for the storing and retrieving of
    our users. This is where the proxy and reader come in.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了模型的字段、验证和函数，我们需要一种方法来在模型之间传递数据以存储和检索我们的用户。这时代理和读取器就派上用场了。
- en: Proxies and readers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理和读取器
- en: In the model, the proxy and reader form a partnership to store and retrieve
    data to be used by the model. The proxy tells a model where its data will be stored,
    and the reader tells the model what format is being used to store the data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在该模型中，代理和读取器合作存储和检索模型要使用的数据。代理告诉模型其数据将存储在哪里，读取器告诉模型正在使用哪种格式来存储数据。
- en: 'There are two main types of proxies: local and remote. A local proxy stores
    its data locally on the device with one of the two proxy types:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代理主要有两种类型：本地和远程。本地代理在其设备上以两种代理类型之一存储其数据：
- en: '`LocalStorageProxy`: This saves the data to the local storage via the browser.
    This data is persistent across sessions, unless deleted by the user.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalStorageProxy`：通过浏览器将数据保存到本地存储。除非用户删除，否则这些数据在会话之间是持久的。'
- en: '`MemoryProxy`: This holds the data in the local memory. When the page is refreshed,
    the data is deleted.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MemoryProxy`：本地内存中保存数据。页面刷新时，数据会被删除。'
- en: 'The remote proxy has two basic types:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 远程代理有两个基本类型：
- en: '`AjaxProxy`: This sends requests to a server within the current domain.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AjaxProxy`：将请求发送到当前域内的服务器。'
- en: '`JsonP`: This sends requests to a server on a different domain (this was called
    a `scripttag` proxy in the previous versions).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonP`：这会将请求发送到不同域上的服务器（在先前版本中这被称为`scripttag`代理）。'
- en: 'Additionally, there are a few specialized proxies, which include:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些特殊化的代理，包括：
- en: '`Direct`: This is a proprietary Sencha technology which, like Ajax, allows
    asynchronous communication with a remote server. However, unlike Ajax, `Direct`
    does not need to keep a socket open to the remote server waiting for a response.
    This makes it ideal for any process that may require a long response delay from
    the server. For more information on `Direct`, go to:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Direct`：这是一种专有的Sencha技术，与Ajax一样，允许与远程服务器进行异步通信。然而，与Ajax不同，`Direct`不需要保持一个到远程服务器的套接字打开，等待响应。这使得它非常适合任何可能需要服务器长时间响应延迟的过程。有关`Direct`的更多信息，请访问：'
- en: '[http://docs.sencha.com/touch/2.2.0/#!/api/Ext.direct.Manager](http://docs.sencha.com/touch/2.2.0/#!/api/Ext.direct.Manager).'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Ext.direct.Manager api](http://docs.sencha.com/touch/2.2.0/#!/api/Ext.direct.Manager).'
- en: '`Rest`: The `Rest` proxy takes the basic proxy functions (`Create`, `Read`,
    `Edit`, and `Delete`) and maps these to HTTP request types (`POST`, `GET`, `PUT`,
    and `DELETE`, respectively). This type of communication is very common in commercial
    APIs.For more information on the rest of the proxies, go to:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rest`：`Rest`代理采用基本代理功能（`Create`、`Read`、`Edit`和`Delete`），并将这些映射到HTTP请求类型（分别是`POST`、`GET`、`PUT`和`DELETE`）。这种通信方式在商业API中非常常见。有关其他代理的更多信息，请访问：'
- en: '[http://docs.sencha.com/touch/2.2.0/#!/api/Ext.data.proxy.Rest.](http://docs.sencha.com/touch/2.2.0/#!/api/Ext.data.proxy.Rest)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Ext.data.proxy.Rest api](http://docs.sencha.com/touch/2.2.0/#!/api/Ext.data.proxy.Rest)。'
- en: 'For more information on the REST protocol itself, visit:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关REST协议本身的更多信息，请访问：
- en: '[http://net.tutsplus.com/tutorials/other/a-beginners-introduction-to-http-and-rest/](http://net.tutsplus.com/tutorials/other/a-beginners-introduction-to-http-and-rest/).'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[HTTP和REST的初学者介绍](http://net.tutsplus.com/tutorials/other/a-beginners-introduction-to-http-and-rest/)。'
- en: '`Sql`: This proxy lets you store data in a local SQL database. This should
    not be confused with an actual SQL server. The Sencha Touch SQL proxy outputs
    the model data into an HTML5 local database using WebSQL.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sql`：此代理允许您在本地SQL数据库中存储数据。这不应与实际的SQL服务器混淆。Sencha Touch SQL代理将模型数据输出到HTML5本地数据库中，使用WebSQL。'
- en: For this chapter and the next, we will be dealing mostly with local proxies.
    We will cover remote proxies and synchronizing data in [Chapter 9](ch09.html "Chapter 9. Advanced
    Topics"), *Advanced Topics*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及下一章中，我们将主要处理本地代理。我们将在第9章[高级主题](ch09.html "Chapter 9. Advanced Topics")中覆盖远程代理和数据同步，*高级主题*。
- en: 'The proxy can be declared as part of the model, shown as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代理可以作为模型的一部分声明，如下所示：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All proxies require a type (local storage, session storage, and so on); however,
    some proxies will require additional information such as the unique ID required
    by the `localstorage` proxy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代理都需要一个类型（本地存储、会话存储等）；然而，一些代理将需要附加信息，例如`localstorage`代理所需的唯一ID。
- en: 'We can also add a reader to this proxy configuration. The reader''s job is
    to tell our proxy what format to use for sending and receiving data. The reader
    understands the following formats:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向此代理配置中添加一个读者。读者的任务是告诉我们的代理发送和接收数据时应使用哪种格式。读者理解以下格式：
- en: '`array`: A simple JavaScript array'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`：一个简单的JavaScript数组'
- en: '`xml`: An Extensible Markup Language format'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xml`：可扩展标记语言格式'
- en: '`json`: A JavaScript Object Notation format'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json`：一种JavaScript对象表示法格式'
- en: 'The reader gets declared as part of the proxy:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 读者作为代理的一部分被声明：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Declaring proxies and readers**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明代理和读者**'
- en: The proxies and readers can be declared as part of the data store as well as
    the model. If different proxies are declared for a store and a model, then calling
    `store.sync()` will use the store's proxy, while calling `model.save()` will use
    the model's proxy. Using separate proxies on both models and the store is typically
    only needed in complex situations. It can also be confusing, so it's best to only
    define proxies in the model unless you're sure of what you are doing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代理和读取器也可以作为数据存储和模型的一部分声明。如果为存储和模型声明了不同的代理，那么调用`store.sync()`将使用存储的代理，而调用`model.save()`将使用模型的代理。通常只有在复杂情况下才需要在模型和存储上使用不同的代理。这也可以是令人困惑的，所以最好只在模型中定义代理，除非你确切知道你在做什么。
- en: Introducing data formats
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍数据格式
- en: 'Before we move on to data stores, we need to take a brief look at data formats.
    The three currently supported by Sencha Touch are Array, XML, and JSON. For each
    example, we will take a look at how the data would appear for a simple `contact`
    model with three fields: an ID, a name, and an e-mail ID.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将数据存储前进之前，我们需要简要地查看一下数据格式。Sencha Touch目前支持的三种数据格式是数组、XML和JSON。对于每个示例，我们将查看一个简单的`contact`模型，其中包含三个字段：ID、姓名和电子邮件ID，数据将如何显示。
- en: Arrays
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'An `ArrayStore` data format uses a standard JavaScript array, which would look
    something like this for our `contact` example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayStore`数据格式使用标准的JavaScript数组，对于我们这个`contact`示例，它看起来像这样：'
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'One of the first things we notice about this type of array is that there are
    no field names included as part of a JavaScript array. This means if we want to
    refer to the fields by the name in our template, we have to set up our model to
    understand where these fields should be mapped by using the `mapping` configuration
    option:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数组的一个首要特点是没有字段名包括在JavaScript数组中。这意味着如果我们想通过名称在我们的模板中引用字段，我们必须通过使用`mapping`配置选项来设置我们的模型，使其理解这些字段应该映射到数据数组的哪个位置：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This sets up our `id` field as index `0` of our data, which is the default
    value. We then use the `mapping` configuration to set `name` and `email` as index
    `1` and `2` respectively, of the items in our data array. We can then set the
    template values for the display component using the configuration:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置我们的`id`字段为数据索引`0`，这是默认值。然后我们使用`mapping`配置将`name`和`email`分别设置为数据数组索引`1`和`2`，然后我们可以使用配置设置模板值：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While arrays are typically used for simple data sets, a larger or nested data
    set can become very unwieldy using the simple JavaScript array structure. This
    is where our other formats come in.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组通常用于简单的数据集，但对于更大的或嵌套的数据集，使用简单的JavaScript数组结构可能会变得非常难以管理。这就是我们的其他格式发挥作用的地方。
- en: XML
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML
- en: '**Extensible Markup Language** (**XML**) should be a familiar looking format
    to anyone who has worked with HTML web pages in the past. XML consists of data
    nested within a series of tags that identify the name of each part of the dataset.
    If we put our previous example into an XML format, it would look as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**（**XML**）对于那些过去曾与HTML网页一起工作的人来说，应该是一个熟悉的格式。XML由一系列嵌套在标签中的数据组成，这些标签标识数据集的每个部分的名字。如果我们把之前的例子转换成XML格式，它将如下所示：'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that XML always begins with a version and encoding line. If this line
    is not set, the browser will not interpret the XML correctly and the request will
    fail.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，XML总是以版本和编码行开始。如果没有设置这一行，浏览器将无法正确解释XML，请求将会失败。
- en: 'We also include tags for defining the individual contacts. One advantage of
    this is that we can now nest data, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括用于定义各个联系人的标签。这种格式的一个优点是我们现在可以嵌套数据，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this nested example, we have each individual `contact` tag nested inside
    a `contacts` tag. We also have tags for our `total` and `success` values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个嵌套示例中，我们每个单独的`contact`标签都嵌套在一个`contacts`标签内。我们还为我们的`total`和`success`值设置了标签。
- en: As we have a nested data structure, we will also need to let the reader know
    where to look for the pieces we need.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个嵌套数据结构，我们也需要让读取器知道去哪里寻找我们需要的片段。
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `root` property tells the reader where to start looking for our individual
    contacts. We also set a value outside of our contacts list for `totalProperty`.
    This tells the store that there are a total of 25 contacts, even though the store
    only receives the first three. The `totalProperty` property is used for paging
    through the data (that is, showing three of 25).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`root`属性告诉读取器从哪里开始查找我们的单个联系人。我们在`contacts`列表之外也设置了一个`totalProperty`值。这告诉存储器总共有25个联系人，尽管存储器只接收前三个。`totalProperty`属性用于分页数据（即显示25个中的3个）。'
- en: The other property outside of our `contacts` list is `successProperty`. This
    tells the store where to check whether the request was successful.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`contacts`列表之外的另一个属性是`successProperty`。这告诉存储器在哪里检查请求是否成功。
- en: The only disadvantage of XML is that it's not a native JavaScript format, so
    it adds a little bit of overhead when it's parsed by the system. Typically, this
    is only noticeable in very large or deeply nested arrays, but it can be an issue
    for some applications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: XML的唯一缺点是它不是原生JavaScript格式，因此当系统解析它时会有一些开销。通常，只有在非常庞大或深度嵌套的数组中才会注意到这一点，但对于某些应用程序来说可能是个问题。
- en: Fortunately for us, we can also use JSON.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们也可以使用JSON。
- en: JSON
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: '**JavaScript Object Notation** (**JSON**) has all of the advantages of XML,
    but as a native JavaScript construct, it has less overhead associated with parsing.
    If we look at our data set as JSON, we would see the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）具有XML的所有优点，但由于它是原生JavaScript结构，因此与解析XML相比，它具有更少的开销。如果我们把我们的数据集看作是JSON，我们会看到以下内容：'
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also nest JSON in much the same way we do with XML:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以与处理XML相同的方式嵌套JSON：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The reader would then be set up just as our XML reader, but with the type listed
    as JSON:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，读取器会像我们的XML读取器一样设置，但将类型列为JSON：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As before, we set properties for both `totalProperty` and `successProperty`.
    We also provide the reader with a place to start looking for our `contacts` list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们为`totalProperty`和`successProperty`设置了属性。我们还为读取器提供了一个开始查找我们的`contacts`列表的地方。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It should also be noted that the default values for `totalProperty` and `successProperty`
    are `total` and `success` respectively. If you are using `total` and `success`
    in your JSON return values, you don't really need to set these configuration options
    on `reader`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意的是，`totalProperty`和`successProperty`的默认值分别是`total`和`success`。如果你在自己的JSON返回值中使用了`total`和`success`，你实际上不需要在`reader`上设置这些配置选项。
- en: JSONP
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSONP
- en: JSON also has an alternate format called JSONP, or JSON with padding. This format
    is used when you need to retrieve data from a remote server. We need this option
    because most browsers follow a strict same-origin policy when handling JavaScript
    requests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JSON还有一种替代格式，称为JSONP，即带填充的JSON。这种格式用于你需要从远程服务器获取数据时。我们需要这个选项，因为大多数浏览器在处理JavaScript请求时遵循严格的同源策略。
- en: The same-origin policy means that a web browser will permit JavaScript to run
    as long as the JavaScript is running on the same server as the web page. This
    will prevent a number of potential JavaScript security issues.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略意味着web浏览器只允许JavaScript在与web页面相同的服务器上运行，只要JavaScript在运行。这将防止许多潜在的JavaScript安全问题。
- en: However, there are times when you will have a legitimate reason for making a
    request from a remote server, for example querying an API from a web service such
    as Flickr. Because your app isn't likely to be running on [flickr.com](http://flickr.com),
    you'll need to use JSONP, which simply tells the remote server to encapsulate
    the JSON response in a function call.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你会出于正当理由从远程服务器发起请求，例如查询Flickr web service的API。因为你的应用可能不会在[flickr.com](http://flickr.com)上运行，你需要使用JSONP，它简单地告诉远程服务器将JSON响应封装在一个函数调用中。
- en: Luckily, Sencha Touch handles all of that for us. When you set up your proxy
    and reader, set the proxy type to `jsonp`, and set your reader up like you would
    a regular JSON reader. This tells Sencha Touch to use `Ext.data.proxy.JsonP` to
    do the cross-domain request, and Sencha Touch takes care of the rest.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Sencha Touch为我们处理所有这些事情。当你设置你的代理和读取器时，将代理类型设置为`jsonp`，并像设置常规JSON读取器一样设置你的读取器。这告诉Sencha
    Touch使用`Ext.data.proxy.JsonP`来执行跨域请求，而Sencha Touch处理其余部分。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: If you'd like to see JSONP and `Ext.data.proxy.JsonP` in action, we use both
    to build the **Flickr Finder** application in [Chapter 8](ch08.html "Chapter 8. Creating
    the Flickr Finder Application"), *Creating the Flickr Finder Application*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看看JSONP和`Ext.data.proxy.JsonP`的实际应用，我们在[第8章](ch08.html "第8章. 创建Flickr Finder应用程序")，*创建Flickr
    Finder应用程序*中使用两者来构建**Flickr Finder**应用程序。
- en: While we have a number of formats to choose from, we will be using the JSON
    format for all of our examples moving forward in this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有多种格式可供选择，但本章余下的例子我们将使用JSON格式。
- en: Introducing stores
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍存储
- en: Stores, as the name implies, are used to store data. As we have seen in previous
    chapters, the list components require a store in order to display data, but we
    can also use a store to grab information from forms and hold it for use anywhere
    in our application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，存储用于存储数据。正如我们在前几章所看到的，列表组件需要一个存储来显示数据，但我们也可以使用存储从表单中获取信息并将其保存在我们应用程序的任何地方。
- en: The store, in combination with the model and proxy, works in much the same way
    as a traditional database. The model provides the structure for our data (say
    a schema in a traditional database), and the proxy provides the communication
    layer to get the data in and out of the store. The store itself holds the data
    and provides a powerful component interface for sorting, filtering, saving, and
    editing data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 存储、模型和代理一起工作，与传统数据库非常相似。模型为我们数据提供结构（如传统数据库中的架构），代理提供通信层，以便将数据进出存储。存储本身持有数据，并为排序、筛选、保存和编辑数据提供强大的组件接口。
- en: The store can also be bound to a number of components, such as lists, nested
    lists, select fields, and panels, to provide data for display.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 存储还可以绑定到许多组件，如列表、嵌套列表、选择字段和面板，以提供显示数据。
- en: We will cover display, sorting, and filtering in [Chapter 7](ch07.html "Chapter 7. Getting
    the Data Out"), *Getting the Data Out*, but for now, we are going to look at saving
    and editing data with the store.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](ch07.html "第7章. 获取数据")，*获取数据外*中覆盖显示、排序和筛选内容，但目前，我们将着手查看使用存储来保存和编辑数据。
- en: A simple store
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的存储
- en: 'As this chapter is concerned with getting data into the store, we are going
    to start out with a very simple local store for our example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章关注的是将数据导入存储，我们将从一个非常简单的本地存储示例开始：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example tells the store which model to use, which in turn defines both
    the fields the store knows about and also the proxy the store should use, since
    the store will adopt both the field list and the proxy from its model. We also
    set the store to `autoLoad`, which means that it will load the data as soon as
    the store is created.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例告诉存储使用哪个模型，这反过来定义了存储知道的字段以及存储应该使用的代理，因为存储将采用字段列表和代理从其模型中。我们还设置存储为`autoLoad`，这意味着一旦创建存储，它就会加载数据。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you declare a proxy in the store configuration, that proxy will be used instead
    of the model's proxy. This is useful in some situations where you want to store
    information about the collection of records such as a group of admin users. In
    that case, the model would be used to store the user details, but the store would
    be used to collect several users of a specific type (admin users) together.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在存储配置中声明了一个代理，那么将使用该代理而不是模型的代理。在某些情况下这很有用，例如您想要存储关于记录集合的信息，如一组管理员用户。在这种情况下，模型用于存储用户详细信息，但存储用于收集特定类型（管理员用户）的多个用户。
- en: 'We also need to be sure our model is set up correctly in order to use this
    store. Since we don''t have a proxy listed as part of the store, we need to be
    sure the model has one if we want to save our data:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保我们的模型设置正确，以便使用此存储。由于我们在存储中没有列出代理，我们需要确保模型有一个，如果我们想要保存我们的数据：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is our simple model with three items: an ID, a name, and an e-mail address.
    We would then create a new contact as we did before:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含三个项目的简单模型：一个ID、一个名称和一个电子邮件地址。我们然后像以前一样创建一个新的联系人：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that we don''t set the ID this time. We want the store to set that for
    us (similar to the way autoincrement works in a typical database). We can then
    add this new contact to the store and save it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们没有设置ID。我们希望存储为我们设置ID（这与典型数据库中的自动递增类似）。然后我们可以将这个新联系人添加到存储中并保存它：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first line adds the user to the store and the second line saves the contents
    of the store. By splitting the `add` and `sync` functionalities, you can add multiple
    users to the store and then perform a single save, as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将用户添加到商店，第二行保存商店的内容。通过将 `add` 和 `sync` 功能分开，你可以向商店添加多个用户，然后执行一次保存，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In both the cases, when we add contacts to the store, we set up a return variable
    to grab the return value of the `add` method. This method returns an array of
    contacts that will now have a unique ID as part of each `contact` object. We can
    take a look at these values by adding a couple of console logs after our sync:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，当我们向商店添加联系人时，我们设置一个返回变量来获取 `add` 方法的返回值。这个方法返回一个联系人数组，现在每个 `contact`
    对象都将有一个唯一的 ID。我们可以在我们的同步之后添加几个控制台日志来查看这些值：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will show that two `contact` objects in an array are returned. It also
    shows how to get at the data we need from those objects by using the index number
    of the specific contact in the array. We can then drill down into the data for
    a name and the new ID that was assigned when we synced.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示返回两个 `contact` 对象的数组。它还显示了如何通过使用数组中特定联系人的索引号来获取我们需要的数据。然后我们可以深入到数据中，获取姓名和我们在同步时分配的新
    ID。
- en: '![A simple store](img/0748OS_06_02.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的商店](img/0748OS_06_02.jpg)'
- en: Now that we have a general idea of how to get data into a store, let's take
    a look at how to do it with a form.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经大致了解了如何将数据输入商店的方法，那么让我们来看看如何使用表单来完成它。
- en: Forms and stores
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单和商店
- en: 'For this example, we are going to use the same store and model as our previous
    example, but we will add a list and a form so that we can add new contacts and
    see what we have added. Let''s start with the list:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用与上一个例子相同的商店和模型，但我们将添加一个列表和一个表单，这样我们就可以添加新的联系人并查看我们添加了什么。让我们从列表开始：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will get something similar to what is shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到类似于以下屏幕截图的东西：
- en: '![Forms and stores](img/0748OS_06_03.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![表单和商店](img/0748OS_06_03.jpg)'
- en: Most of the code here is pretty similar to the previous examples. We have a
    single panel with a `list` component. Our list has a template `itemTpl` that uses
    the same field names as our `contact` model and arranges the manner in which they
    will be displayed. We have also added a docked toolbar with our new **Add** button.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大部分代码与之前的例子非常相似。我们有一个带有 `list` 组件的单个子面板。我们的列表有一个使用与我们的 `contact` 模型相同的字段名的模板
    `itemTpl`，它决定了它们将如何显示。我们还添加了一个带有我们新 **添加** 按钮的固定工具栏。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `toolbar` component has also changed from the previous versions of Sencha
    Touch. In Version 2, `toolbar` is part of the `items` list and not a separate
    `dockedItem`, as in the past versions. Additionally, the position of the `toolbar`
    was previously set by the `dock` configuration option. This was changed to `docked`
    in Sencha Touch 2\. It should also be noted that if you try using the older `dockedItem`
    and `dock` configurations, you will not get any errors. You will also not get
    a toolbar. This can lead to a great deal of hair pulling and coarse language.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolbar` 组件也发生了变化，与 Sencha Touch 的以前版本不同。在版本 2 中，`toolbar` 是 `items` 列表的一部分，而不是作为一个单独的
    `dockedItem`。此外，`toolbar` 的位置以前是通过 `dock` 配置选项来设置的。在 Sencha Touch 2 中，这被改为了 `docked`。还应该注意的是，如果你尝试使用旧的
    `dockedItem` 和 `dock` 配置，你不会得到任何错误。你也不会得到工具栏。这可能会导致你扯掉很多头发并说出粗糙的语言。'
- en: 'The button has a very simple function that will add an Ext.Sheet called `addNewContact`
    to our viewport and then show the sheet. Now we need to actually create the sheet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮有一个非常简单的函数，它将一个名为 `addNewContact` 的 Ext.Sheet 添加到我们的视口，然后显示该表单。现在我们需要实际创建这个表单：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This gives us our new sheet that will appear when we click the **Add** button.
    Now, we need to add our form fields to the `items` section of the sheet we just
    created:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个新表单，当我们点击 **添加** 按钮时会出现。现在，我们需要将我们的表单字段添加到我们刚刚创建的表单的 `items` 部分：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We start by creating our `formpanel` component and then adding `textfield` and
    `emailfield` to the `items` list of `formpanel`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `formpanel` 组件，然后将 `textfield` 和 `emailfield` 添加到 `formpanel` 的 `items`
    列表中。
- en: Specialty text fields
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专业文本字段
- en: 'Sencha Touch uses specialty text fields such as `emailfield`, `urlfield`, and
    `numberfield`, to control which keyboard is used by the mobile device, as in the
    following iPhone examples:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch 使用了如 `emailfield`、`urlfield` 和 `numberfield` 等专业文本字段，以控制移动设备使用哪种键盘，如下面的
    iPhone 示例所示：
- en: '![Specialty text fields](img/0748OS_06_04.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![专业文本字段](img/0748OS_06_04.jpg)'
- en: 'The types of keyboards shown in the preceding figure are explained as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前述图表中所示的键盘类型如下解释：
- en: '**The URL Keyboard** replaces the traditional Space bar with keys for dot (**.**),
    slash (**/**), and **.com**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL键盘**用点（`.`）、斜杠（`/**`）和`.com`的键替换了传统的空格键。'
- en: '**The Email Keyboard** shortens the Space bar and makes room for **@** and
    dot (**.**)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子邮件键盘**缩短了空格键，并为`@`和点（`.`）腾出了空间。'
- en: '**The Number Keyboard** initially presents the numeric keyboard instead of
    the standard QWERTY keyboard'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字键盘**最初显示数字键盘，而不是标准的QWERTY键盘。'
- en: These specialty fields do not automatically validate the data the user enters.
    Those kinds of validations are handled through model validations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊字段不会自动验证用户输入的数据。那些验证是通过模型验证处理的。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Specialty keyboards**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊键盘**'
- en: Android and iOS have slightly different special keyboards, so you may find some
    variation between the two. It is usually helpful to run your application through
    both the Android and iOS simulators to ensure that the correct keyboard type is
    being used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓和iOS拥有略微不同的特殊键盘，因此你可能会在这两者之间找到一些变化。通常，运行你的应用程序通过安卓和iOS模拟器，以确保正确使用键盘类型。
- en: Mapping fields to the model
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字段映射到模型
- en: You will also notice that the name of each field in our form matches the name
    used by our `contact` model; this will allow us to easily create our contacts
    and add them to the store. However, before we get there, we need to add two buttons
    (**Save** and **Cancel**) to tell the form what to do.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到我们表单中的每个字段名称与我们`contact`模型的名称相匹配；这将允许我们轻松创建联系信息并将它们添加到商店中。然而，在我们到达那里之前，我们需要添加两个按钮（**保存**和**取消**），以告诉表单要做什么。
- en: 'After the `emailfield` object in our form, we need to add the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们表单中的`emailfield`对象之后，我们需要添加以下内容：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The gives us two buttons at the bottom of our form. Right now, both our **Save**
    and **Cancel** buttons do the same thing: they call a function to hide the sheet
    that holds our form. This is a good starting point, but we need a bit more to
    get our **Save** button to save our data.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们在表单底部两个按钮。现在，我们的**保存**和**取消**按钮做相同的事情：它们调用一个函数来隐藏包含我们表单的弹出窗口。这是一个很好的起点，但我们还需要更多功能来让**保存**按钮保存我们的数据。
- en: '![Mapping fields to the model](img/0748OS_06_05.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![将字段映射到模型](img/0748OS_06_05.jpg)'
- en: 'Since we were good little coders and named our fields to match our model, we
    can just use the following code in our button handler to add our form to our store:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是很棒的程序员，并且给我们的字段命名以匹配我们的模型，我们只需要在我们按钮处理程序中使用以下代码就可以将我们的表单添加到我们的商店中：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line uses the `up` method to grab the form that surrounds the button.
    The second line uses `form.getValues()` and pipes the output directly into a new
    `Contact` model, using the `create()` method from our previous examples. We can
    then add the new contact to the store and sync, as we did before.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用`up`方法获取围绕按钮的表单。第二行使用`form.getValues()`，并将输出直接传递到一个新`Contact`模型中，使用我们之前示例中的`create()`方法。然后我们可以将新联系信息添加到商店并同步，就像我们之前做的那样。
- en: The last bit of cleanup we need to do is to clear all of the form values by
    using `form.reset()` and then hide the sheet, as before. If we don't reset the
    fields, the data would still be there the next time we showed the form.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一点清理工作是通过使用`form.reset()`来清除所有表单值，然后像之前一样隐藏表单。如果我们不清除字段，下次我们显示表单时数据仍然会存在。
- en: The list connected to the store will refresh when we sync the store, and our
    new contact will appear.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们同步商店时，与商店关联的列表将会刷新，我们的新联系信息会出现。
- en: '![Mapping fields to the model](img/0748OS_06_06.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![将字段映射到模型](img/0748OS_06_06.jpg)'
- en: Since this store uses local storage for holding the data, our list will stay
    in place even after we quit the Safari browser. This can be a bit of a pain when
    you are testing an application, so let's take a look at how to clear out the store.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个商店使用本地存储来保存数据，我们的列表在我们退出Safari浏览器后仍然会保持原位。当你测试应用程序时，这可能会让你感到有些烦恼，所以让我们来看看如何清除商店中的数据。
- en: Clearing the store data
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除商店数据
- en: 'Local and session storage saves information on our local machine. As we plan
    on doing lots of testing while coding, it''s a good idea to know how to clear
    out this kind of data without removing other data that you might still need. To
    clear out the data for your local or session store, use the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储和会话存储在我们本地计算机上保存信息。由于我们计划在编码时进行大量测试，知道如何清除这类数据而又不删除可能仍然需要的其他数据是个好主意。要清除您本地或会话存储中的数据，请按照以下步骤操作：
- en: Open up **Web Inspector** from the **Develop** menu and select the **Resources**
    tab.![Clearing the store data](img/0748OS_06_07.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**开发**菜单中打开**网络检查器**，并选择**资源**标签。![清除存储数据](img/0748OS_06_07.jpg)
- en: In the **Local Storage** or **Session Storage** section (depending on the method
    you use), you should see your application's database. Once you select the database,
    you can delete specific records or empty out the database completely. Just select
    the records on the right-hand side of the screen, and click on the **X** at the
    bottom to delete the record.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**本地存储**或**会话存储**部分（取决于您使用的方法），您应该看到您应用程序的数据库。一旦您选择了数据库，您可以删除特定的记录或完全清空数据库。只需在屏幕右侧选择记录，然后点击底部的**X**以删除记录。
- en: You can also reset the value for the counter by double-clicking on it and then
    changing the number. Be careful not to create multiple records with the same number.
    This will cause big problems.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过双击它并更改数字来重置计数器的值。小心不要创建具有相同数字的多个记录。这将造成大问题。
- en: Once you are finished in the **Resources** section, let's move on to editing
    data with our forms.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**资源**部分完成后，让我们继续使用我们的表单编辑数据。
- en: Editing with forms
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表单编辑
- en: Now that we have taken a look at the basics of getting data into a store, let's
    look at how to edit that data, using a few modifications to our current form.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了将数据传入存储的基本知识，让我们来看看如何使用对我们当前表单进行一些修改来编辑这些数据。
- en: 'The first thing we want to add is an `itemsingletap` listener on our list.
    This will let us tap an item in the list and bring up the form with the selected
    entry included in the fields for us to edit. The listener looks like the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加的第一个是一个`itemsingletap`监听器到我们的列表上。这将让我们点击列表中的一个项目并弹出包含所选条目的表单，以便我们进行编辑。监听器如下所示：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our `itemsingletap` listener will automatically get back a copy of the `list`,
    the `index` attributes of the item, the `target` element, and the `record` behind
    the item that got tapped. We can then grab the form inside our sheet and set the
    record on it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`itemsingletap`监听器将自动返回`list`的副本、项目的`index`属性、`target`元素以及被点击项背后的`record`。然后我们可以获取我们表单内的表单并在其中设置记录。
- en: 'It is often useful to chain functions together in this fashion, especially
    if the piece you need has to be used only once. For example, we could have done:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 经常以这种方式链接函数很有用，特别是如果你需要用到的部分只需使用一次。例如，我们可以这样做：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This would also let us use that `form` variable in a number of places within
    the function. Since we only need it to set the record, we can combine both of
    these lines as a single line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这样也可以让我们在函数的许多地方使用那个`form`变量。由于我们只需要用它来设置记录，我们可以将这两行合并为一行：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This loads the data into our form in the following manner:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方式将数据加载到我们的表单中：
- en: '![Editing with forms](img/0748OS_06_08.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![使用表单编辑](img/0748OS_06_08.jpg)'
- en: 'There''s still one more problem to be dealt with: our **Save** button is hardcoded
    to add a new record to the store. If we tap **Save** right now, we will just end
    up with multiple copies of the same contact. We need to make a change to our form
    to let us switch what the **Save** button does, depending on whether we are editing
    or creating a new contact.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题需要解决：我们的**保存**按钮硬编码到向存储中添加新记录。如果我们现在点击**保存**，我们最终会得到同一个联系人的多个副本。我们需要对我们的表单进行更改，以便让我们可以根据我们是在编辑还是创建新联系人来切换**保存**按钮的行为。
- en: Switching handlers
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换处理程序
- en: 'In order to change the handler, the button fires to save our contact; we need
    to separate the bulk of code from the button itself. To begin, locate the handler
    for our **Save** button and copy the current function to your clipboard. Next,
    we want to replace that function with the name of an external function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改处理程序，按钮触发保存我们的联系人；我们需要将代码的主体与按钮本身分开。首先，找到我们的**保存**按钮的处理程序，并将当前函数复制到剪贴板。接下来，我们想要用外部函数的名称替换那个函数：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are also going to add an additional `config` option to our button in the
    following manner:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将以以下方式向我们的按钮添加一个额外的`config`选项：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will make it easier to grab our button with a component query later on.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们稍后用组件查询更容易地获取我们的按钮。
- en: Tip
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `action` config option is a totally arbitrary name. You are not restricted
    to just the options defined by Sencha. You can define any additional options you
    like for the components and reference them in your handlers and controllers just
    like any other config option.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`配置选项是一个完全任意的名称。您不受限于Sencha定义的选项。您可以为组件定义任何其他选项，并在处理程序和控制器中像其他任何配置选项一样引用它们。'
- en: 'Now, we have to create the new `addContact` function for this handler to use.
    In our JavaScript file, right before where we create our `addNewContact` sheet,
    add a new function called `addContact` and paste in the code from our old `handler`
    function. It should look as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为这个处理程序创建一个新的`addContact`函数。在我们创建`addNewContact`表单的JavaScript文件中，在创建`addNewContact`表单之前，添加一个名为`addContact`的新函数，并粘贴我们旧`handler`函数的代码。它应该如下所示：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is the same old form-saving function we used on our button before, and
    it will work just fine for adding new contacts. Now, we need to create a similar
    function to update our contacts when we click on them in the list.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在按钮上使用过的表单保存函数，它添加新联系人正好合适。现在，我们需要创建一个类似的函数，当我们在列表中点击它们时更新我们的联系人。
- en: 'On top of our `addContact` function, add the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`addContact`函数顶部，添加以下代码：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This does almost the same thing as our other function. However, instead of grabbing
    the form fields and creating a new record, we grab the record from the form itself
    using `form.getRecord()`. This record is the one we need to update with our new
    information.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数几乎做了我们另一个函数的所有事情。然而，不同的是，它不是获取表单字段并创建一个新的记录，而是使用`form.getRecord()`从表单本身获取记录。这个记录是我们需要用新信息更新的记录。
- en: We then grab the current values of the form using `form.getValues()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`form.getValues()`获取表单的当前值。
- en: Our `rec` variable is now set to the old record from the data store. We can
    then pass that record to our new data using `rec.set(values)`, which will overwrite
    the old information in the store record with our current form values. The ID will
    stay the same as we do not pass a new value for that.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`rec`变量现在设置为数据存储中的旧记录。然后，我们可以使用`rec.set(values)`将该记录传递给新数据，这将用我们当前表单值覆盖存储记录中的旧信息。由于我们没有传递新值，ID将保持不变。
- en: 'After we update the record, we just perform the following actions we did earlier:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 更新记录后，我们只需执行以下早期所做的操作：
- en: '`sync`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`'
- en: '`reset`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`'
- en: '`hide`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hide`'
- en: Now that the code for our two functions is in place, we need to switch the handler
    for our **Save** button based on whether the user clicked on the **Add** button
    at the top of our list or selected an item in the list.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的两个函数的代码已经就位，我们需要根据用户是否点击了我们列表顶部的**添加**按钮或选择了列表中的项目来切换**保存**按钮的处理程序。
- en: 'Let''s start with the **Add** button. Locate the handler for our **Add** button
    at the top of our `list` object. We need to add some code to this button that
    will change the handler on the **Save** button:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**添加**按钮开始。在`list`对象的顶部找到**添加**按钮的处理程序。我们需要向这个按钮添加一些代码，以更改**保存**按钮的处理程序：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As our `addNewContact` sheet is already defined as a variable elsewhere in the
    code, we can grab `button` using the `down()` method and make a few changes. The
    first is to update the handler to see our new `addContact` function, and the second
    is to change the text of the button to `Create`. We can then add our `addNewContact`
    sheet to the viewport and call `addNewContact.show()`, as before.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`addNewContact`表单已经在代码的其他地方定义为一个变量，我们可以使用`down()`方法获取`button`并做一些更改。首先，更新处理程序以查看我们的新`addContact`函数，第二个更改是将按钮的文本更改为`创建`。然后，我们可以在视口中添加我们的`addNewContact`表单并调用`addNewContact.show()`，就像以前一样。
- en: Our **Add** button is now set to show the form and change the text and handler
    for the button.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**添加**按钮现在设置为显示表单并更改按钮的文本和处理程序。
- en: 'Now, we need to do something similar to the `itemsingletap` hander on our list:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对列表中的`itemsingletap`处理程序做类似的事情：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we still take the record and load it into the form, but we grab `button`
    with the `action` value of `saveContact` and make changes to the handler and text
    as well. The changes point the **Save** button to our `updateContact` function
    and change the text to `Update`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仍然获取记录并将其加载到表单中，但我们要获取`button`带有`action`值为`saveContact`的元素，并更改处理程序和文本。更改将**保存**按钮指向我们的`updateContact`函数，并将文本更改为`更新`。
- en: '![Switching handlers](img/0748OS_06_09.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Switching handlers](img/0748OS_06_09.jpg)'
- en: Deleting from the data store
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据存储中删除
- en: If you remember earlier, when we talked about CRUD functions, you can see that
    we successfully covered `Create`, `Read`, and `Update`. These are all handled
    automatically by the store with very little code required. What about `Delete`?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前我们讨论CRUD功能的时候，你会发现我们已经成功覆盖了`Create`（创建）、`Read`（读取）和`Update`（更新）。这些操作都是由存储自动完成的，几乎不需要编写任何代码。那么`Delete`（删除）呢？
- en: 'As it turns out, `Delete` is just as simple as our other store methods. We
    can use either of the two methods: the first is `remove()`—it takes a record as
    its argument—and the second is `removeAt`, which takes an index to determine the
    record to remove. We could implement either of these as part of our edit form
    by adding a new button at the bottom of the form as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，`Delete`（删除）与其他存储方法一样简单。我们可以使用两个方法中的任意一个：第一个是`remove()`—它需要一个记录作为参数—第二个是`removeAt`，它需要一个索引来确定要删除的记录。我们可以将其中任何一个作为我们编辑表单的一部分，通过在表单底部添加一个新按钮来实现，如下所示：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using `remove` requires the store record, so we grab the record from our form
    panel:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`remove`需要存储记录，因此我们从表单面板中获取记录：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That takes care of all of our basic `Create`, `Read`, `Edit`, and `Delete` functions.
    As long as you remember to set up your model and match your field names, the store
    will handle most of the basics automatically.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了所有基本的`Create`（创建）、`Read`（读取）、`Edit`（编辑）和`Delete`（删除）功能。只要你记得设置你的模型并匹配你的字段名，存储会自动处理大多数基本操作。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Further Information**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**'
- en: Sencha has a number of good tutorials on using forms, models, and stores at
    [http://docs.sencha.com/touch/2.2.1/#!/guide](http://docs.sencha.com/touch/2.2.1/#!/guide).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha提供了许多关于使用表单、模型和存储的优秀教程，请访问[http://docs.sencha.com/touch/2.2.1/#!/guide](http://docs.sencha.com/touch/2.2.1/#!/guide)。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the data model that forms the basic structure for
    all of our data in Sencha Touch. We looked at the proxy and reader that handle
    communications between the data store and our other components. We also discussed
    the data store that holds all of our data in Sencha Touch. Finally, we took a
    look at how you can use forms to get data in and out of the stores as well as
    at how to delete the data when it is no longer needed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第4章，我们介绍了在Sencha Touch中构成所有数据基本结构的数据模型。我们查看了代理和读取器，它们处理数据存储与其他组件之间的通信。我们还讨论了在Sencha
    Touch中持有所有数据的存储。最后，我们查看了如何使用表单将数据进出存储，以及如何在数据不再需要时删除数据。
- en: In the next chapter, we will take a look at all of the other things we can do
    with data once we get it out of the store.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将查看一旦我们把数据从存储中取出后可以做的所有其他事情。
