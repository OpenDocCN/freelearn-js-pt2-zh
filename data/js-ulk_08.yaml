- en: Chapter 7. JavaScript Beyond the Browser
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 JavaScript 浏览器之外
- en: 'Originally, JavaScript was designed as a client-side scripting language, but
    today, it is used literally everywhere: in server scripting, mobile and desktop
    software programming, game development, DB querying, hardware control, and OS
    automation. When you have experience in client-side JavaScript, with a little
    additional knowledge, you can apply your skills in other programming areas as
    well. Here, we will learn how to write a command-line tool, web-server, desktop
    application, and mobile software using JavaScript.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，JavaScript被设计为客户端脚本语言，但今天，它被用在实实在在的每个地方：在服务器脚本、移动和桌面软件编程、游戏开发、数据库查询、硬件控制和操作系统自动化。当你有客户端JavaScript的经验时，加上一些额外的知识，你也可以将你的技能应用到其他编程领域。在这里，我们将学习如何使用JavaScript编写命令行工具、web服务器、桌面应用程序和移动软件。
- en: 'In this chapter, we will be learning about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Leveling up the coding of a command-line program in JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用JavaScript提升命令行程序的编程水平
- en: Building a web-server with JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用JavaScript建立web服务器
- en: Writing a desktop HTML5 application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写桌面HTML5应用程序
- en: Using PhoneGap to make a mobile native app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PhoneGap制作移动原生应用
- en: Levelling up the coding of a command-line program in JavaScript
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用JavaScript提升命令行程序的编程水平
- en: You must have heard about Node.js. This is an open source cross-platform development
    environment that allows the creation of web-servers, networking, and other tools
    using JavaScript. Node.js extends classical JavaScript with a collection of specialized
    modules. These modules handle filesystem I/O, networking, OS-level operations,
    binary data, cryptography functions, data streams, and others ([https://nodejs.org/api/index.html](https://nodejs.org/api/index.html)).
    Node.js uses an event-driven I/O model. Similar to JavaScript, it operates on
    single-thread performing non-blocking calls. So time consuming functions can run
    concurrently by invoking a callback when it completes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定听说过Node.js。这是一个开源的跨平台开发环境，它允许使用JavaScript创建web服务器、网络和其他工具。（https://nodejs.org/api/index.html）。Node.js在经典的JavaScript上增加了一系列专门的模块。这些模块处理文件系统I/O、网络、操作系统级操作、二进制数据、加密功能、数据流等。Node.js使用事件驱动的I/O模型。与JavaScript类似，它在一个单线程上执行非阻塞调用。因此，耗时的函数可以通过在完成时调用回调来并发运行。
- en: 'To get the feel of Node.js, we start with an example that simply prints *Hello
    world*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受Node.js，我们从一个简单地打印*Hello world*的示例开始：
- en: '**hello.js**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**hello.js**'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s open the console (command-line interface: **CMD** in Windows, or
    **Terminal** in Linux and Mac OS), navigate to the example script location, and
    run the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开控制台（命令行界面：Windows中的**CMD**，或Linux和Mac OS中的**Terminal**），导航到示例脚本位置，并运行以下命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we go, we get `Hello world!` in the output.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们在输出中得到了`Hello world!`。
- en: Following screenshot shows the Windows CMD
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了Windows CMD
- en: '![Levelling up the coding of a command-line program in JavaScript](img/00016.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![用JavaScript提升命令行程序的编程水平](img/00016.jpeg)'
- en: 'The Node.js modules follow the CommonJS specification in the same way that
    we examined in [Chapter 2](part0021_split_000.html#K0RQ2-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 2. Modular Programming with JavaScript"), *Modular Programming with JavaScript*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js模块遵循与我们在[第二章](part0021_split_000.html#K0RQ2-f4ff6b81796e4f78aa983a623fb95daf
    "第二章 Modular Programming with JavaScript") *Modular Programming with JavaScript*中考察过的相同的CommonJS规范：
- en: '**foo.js**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we run `main.js`, we are supposed to get the following output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`main.js`时，我们预计会得到以下输出：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Node.js native modules such as `fs` ([https://nodejs.org/api/index.html](https://nodejs.org/api/index.html))
    don''t require downloading. We may just refer to them in `require()`, and at the
    runtime, it will be known where to find them:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js本地模块，如`fs`（[https://nodejs.org/api/index.html](https://nodejs.org/api/index.html)），不需要下载。我们只需在`require()`中引用它们，在运行时，它将知道在哪里找到它们：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we use the filesystem I/O (`fs`) module to read a file. The `__filename`
    property of a module scope contains the absolute path of the executing source
    file. Remember the *Error First Callback* approach that we examined in [Chapter
    5](part0035_split_000.html#11C3M2-f4ff6b81796e4f78aa983a623fb95daf "Chapter 5. Asynchronous
    JavaScript"), *Asynchronous JavaScript* That is the main interface for asynchronous
    functions in Node.js.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用文件系统I/O（`fs`）模块来读取一个文件。模块作用域中的`__filename`属性包含执行源文件的绝对路径。记住我们在[第五章](part0035_split_000.html#11C3M2-f4ff6b81796e4f78aa983a623fb95daf
    "第五章 Asynchronous JavaScript") *Asynchronous JavaScript*中考察过的*错误优先回调*方法。这是Node.js中异步函数的主要接口。
- en: 'Let''s now try something more practical. We''ll write a utility that recursively
    scans all the source files in a given directory to make sure every file has block
    comments with up-to-date copyrights. First of all, we need a module that can test
    whether a supplied block comment text contains the actual copyright line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些更实际的东西。我们将编写一个工具，递归地扫描给定目录中的所有源文件，以确保每个文件都有带有最新版权的块注释。首先，我们需要一个模块，它可以测试提供的块注释文本是否包含实际的版权行：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we have a constructor that creates an object representing `BlockComment`.
    The object has a method (`isValid`) to test its validity. So if we create an instance
    of `BlockComment` with a block comment text, we can validate this against our
    requirements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个构造函数，用于创建代表`BlockComment`的对象。该对象有一个方法（`isValid`），用于测试其有效性。因此，如果我们用块注释文本创建一个`BlockComment`实例，我们可以将其与我们的要求进行验证：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we will write a module capable of testing whether all the copyright lines
    in a given source code has the actual year:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个模块，用于测试给定源代码中所有版权行是否包含实际年份：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example we introduced a `SourceFile` object that has two methods, `parse`
    and `isValid`. The private method, `parse`, extracts all the block comments from
    a given JavaScript source code and returns an array of the `BlockComment` objects.
    The `isValid` method checks whether all the received `BlockComment` objects meet
    our requirements. In these methods, to manipulate arrays, we use `Array.prototype.filter`
    and `Array.prototype.map` that we examined in [Chapter 1](part0014_split_000.html#DB7S2-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 1. Diving into the JavaScript Core"), *Diving into JavaScript Core*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们引入了一个`SourceFile`对象，它有两个方法，`parse`和`isValid`。私有方法`parse`从给定的JavaScript源代码中提取所有块注释，并返回`BlockComment`对象的数组。`isValid`方法检查所有接收的`BlockComment`对象是否符合我们的要求。在这些方法中，为了操作数组，我们使用了我们在[第1章](part0014_split_000.html#DB7S2-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 1. Diving into the JavaScript Core")中介绍的*深入JavaScript核心*的`Array.prototype.filter`和`Array.prototype.map`。
- en: But how can we reliably extract `blockComments` from a JavaScript source? The
    best way is to go with a bulletproof solution called the **esprima** parser ([http://esprima.org/](http://esprima.org/))
    that performs code static analysis and returns a full syntax tree including comments.
    However, esprima is a third-party package that is supposed to be downloaded and
    linked from the application. In general, a package may depend on other packages,
    which also have dependencies. It looks like that bringing the required dependencies
    together may be a hell of a work. Fortunately, Node.js is distributed with the
    NPM package manager. The tool can be used to install and manage in the NPM repository
    ([https://www.npmjs.com/](https://www.npmjs.com/)) third-party modules. NPM doesn't
    just download the requested modules, but also resolves the module dependencies,
    allowing a well-grained structure of reusable components in the scope of a project
    or in the global scope.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何可靠地从JavaScript源代码中提取`blockComments`呢？最好的方法是使用一个叫做**esprima**解析器的解决方案（[http://esprima.org/](http://esprima.org/)），它执行代码静态分析，并返回包括注释在内的完整语法树。然而，esprima是一个第三方包，应该从应用程序中下载并链接。通常，一个包可能依赖于其他包，这些包也有依赖关系。看起来把所需的依赖项集合在一起可能是一项艰巨的工作。幸运的是，Node.js随NPM包管理器一起分发。这个工具可以用来在NPM仓库（[https://www.npmjs.com/](https://www.npmjs.com/)）中安装和管理第三方模块。NPM不仅下载请求的模块，还解析模块依赖项，允许在项目范围或全局范围内有一个细粒度的可重用组件结构。
- en: 'So, to make `esprima` available in our application, we simply request it from
    NPM using this command: `npm install esprima`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了在我们的应用程序中使用`esprima`，我们只需使用这个命令请求它：`npm install esprima`。
- en: 'By running this command in the console, we automatically get a new `node_modules`
    subdirectory with the `esprima` package in it. If the package requires any dependencies,
    they will be fetched and allocated in `node_modules`. As soon as the package is
    installed by NPM, Node.js can find it by its name. For example, `require( "esprima"`
    ). Now when we have the `SourceFile` object, we just need the main script that
    will read the files from a given directory and test them with `SourceFile`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在控制台运行这个命令，我们自动得到一个包含`esprima`包的新`node_modules`子目录。如果该包需要任何依赖项，它们将被获取并在`node_modules`中分配。一旦通过NPM安装了包，Node.js就可以通过名称找到它。例如，`require(
    "esprima"` ）。现在我们有了`SourceFile`对象，我们只需要主脚本，它将读取给定目录中的文件并与`SourceFile`进行测试：
- en: '**copyright-checker.js**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**copyright-checker.js**'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code, we relied on a third-party module, `cli-color`, to colorize the
    command-line output. We used the `fs-walk` module to recursively traverse through
    a directory. And the Node.js native module, path, allows us to resolve the absolute
    path by a given relative directory and filename, and the `fs` built-in module
    is used to read a file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们依赖了一个第三方模块，`cli-color`，来为命令行输出着色。我们使用了`fs-walk`模块递归地遍历目录。而Node.js本地模块，path，允许我们通过给定的相对目录和文件名解析绝对路径，`fs`内置模块用于读取文件。
- en: 'As we intend to run our application from the console, we can use command-line
    options to pass on a directory that we want to test:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算从控制台运行我们的应用程序，我们可以使用命令行选项来传递一个我们想要测试的目录：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can extract script arguments from a built-in process (`process.argv`) object.
    For this command, `process.argv` will contain an array like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从内置进程（`process.argv`）对象中提取脚本参数。对于这个命令，`process.argv`将包含一个数组，像这样：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So in the main script, now we can pass the third element of this array to `walk.files`.
    The function will traverse through the given directory and run the callback for
    every file found. In the callback function, if a filename looks like JavaScript,
    we read the content and test it using the `SourceFile` object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在主脚本中，现在我们可以将这个数组的第三个元素传递给`walk.files`。该函数将遍历给定目录，为找到的每个文件运行回调函数。在回调函数中，如果文件名看起来像JavaScript，我们就读取内容并使用`SourceFile`对象进行测试。
- en: 'Before we can run the main script, we need to ask NPM for third-party packages
    that we are going to use in the script:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够运行主脚本之前，我们需要从NPM那里获取第三方包，这些包将在脚本中使用：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we are good to go. As we run `node copyright-checker.js fixtures`, we get
    a report on the validity of the JavaScript files located in fixtures.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行了。当我们运行`node copyright-checker.js fixtures`时，我们得到了一个有关位于fixtures中的JavaScript文件有效性的报告。
- en: 'Following screenshot shows the Mac OS X terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了Mac OS X终端：
- en: '![Levelling up the coding of a command-line program in JavaScript](img/00017.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![用JavaScript提升命令行程序的编码水平](img/00017.jpeg)'
- en: Building a web server with JavaScript
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript构建网页服务器
- en: We've just learnt how to write command-line scripts with Node.js. However, this
    run-time is mostly known as server-side JavaScript, meaning this is the software
    to run an HTTP-server. Actually, Node.js is especially great for this kind of
    job. If we launch a server application based on Node.js, it runs permanently,
    initialized only once. For instance, we may create a single DB connection object
    and reuse it whenever someone requests the application. Besides, it grants us
    all the flexibility and power of JavaScript including event-driven, non-blocking
    I/O.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何使用Node.js编写命令行脚本。然而，这种运行时通常被称为服务器端JavaScript，意味着这是运行HTTP服务器的软件。实际上，Node.js特别适合这类工作。如果我们基于Node.js启动一个服务器应用程序，它会持续运行，只初始化一次。例如，我们可能创建一个单一的数据库连接对象，并在有人请求应用程序时重复使用它。此外，它还赋予我们所有JavaScript的灵活性和力量，包括事件驱动、非阻塞I/O。
- en: 'So how can we make use of this? Thanks to the HTTP native module of Node.js,
    a simple web-server can be implemented as easy as this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何利用这一点呢？多亏了Node.js的HTTP本地模块，一个简单的网页服务器可以像这样轻易实现：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here we created a server with a dispatcher callback to handle HTTP requests.
    Then, we make the server listen on port 80\. Now run `node simple-server.js` from
    the console, and then hit `http://localhost` in a browser. We will see the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此我们创建了一个带有调度程序回调的服务器来处理HTTP请求。然后，让这个服务器监听80端口。现在从控制台运行`node simple-server.js`，然后在浏览器中访问`http://localhost`。我们会看到如下内容：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So we just need to route incoming requests, read the corresponding HTML files,
    and send them with the response to make a simple static web server. Or we can
    install the existing modules, `connect` and `serve-static`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们只需要路由传入的请求，读取相应的HTML文件，并通过响应将它们发送出去，以创建一个简单的静态网页服务器。或者我们可以安装现有的模块，`connect`和`serve-static`：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And implement the server using this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式实现服务器：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In practice, routing requests can be a challenging task, so we rather go with
    a framework. For example, Express.js ([http://expressjs.com](http://expressjs.com)).
    Then, our routing may look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，路由请求可能是一个具有挑战性的任务，因此我们更倾向于使用一个框架。例如，Express.js ([http://expressjs.com](http://expressjs.com))。然后，我们的路由可能如下所示：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Writing a desktop HTML5 application
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写桌面HTML5应用程序
- en: Have you ever wondered about writing a desktop application with HTML5 and JavaScript?
    Nowadays, we can do this quite easily with NW.js. This project is a cross-platform
    application runtime based on Chromium and Node.js. So, it provides a frameless
    browser where both the DOM API and Node.js API are available. In other words,
    we can run NW.js classical web-applications, access low-level APIs (filesystem,
    network, processes, and so on), and reuse the modules of the NPM repository. Interesting?
    We'll start a tutorial where we will create a simple HTML5 application and run
    it with NW.js. It'll be a roster application with a form to enter names and a
    list of already submitted ones. The names will be stored in localStorage. Let's
    rock it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过用HTML5和JavaScript编写桌面应用程序？现在，我们可以使用NW.js非常容易地做到这一点。这个项目是一个基于Chromium和Node.js的跨平台应用程序运行时。因此，它提供了一个无框架浏览器，其中既可以使用DOM
    API，也可以使用Node.js API。换句话说，我们可以运行NW.js经典网络应用程序，访问低级API（文件系统，网络，进程等），并重用NPM仓库的模块。有趣吗？我们将开始一个教程，我们将创建一个简单的HTML5应用程序并使用NW.js运行它。它将是一个具有输入名字表单和已提交列表的阵容应用程序。名字将存储在localStorage中。让我们摇滚起来。
- en: Setting up the project
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'First of all, we have to download the NW.js run-time relevant to our platform
    (Mac OS X, Windows, or Linux) from [http://nwjs.io](http://nwjs.io). Next to the
    NW.js executable (`nw.exe`, `new.app`, or `nw.` depending on the platform), we
    place the `package,json` file ([https://github.com/nwjs/nw.js/wiki/manifest-format](https://github.com/nwjs/nw.js/wiki/manifest-format))
    where we describe our project:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须从[http://nwjs.io](http://nwjs.io)下载与我们的平台（Mac OS X，Windows或Linux）相关的NW.js运行时。在NW.js可执行文件（`nw.exe`，`new.app`或`nw.`，取决于平台）旁边，我们将`package.json`文件放置在描述我们项目的位置：[https://github.com/nwjs/nw.js/wiki/manifest-format](https://github.com/nwjs/nw.js/wiki/manifest-format)
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our `package.json` file has three main fields. `name` contains a unique name
    associated with the project. Note that this value will be a part of the directory
    path where application data (sessionStorage, localStorage, and so on) is stored.
    `main` accepts a relative path to the main HTML page of the project. Eventually,
    `window` describes the browser window where the HTML will be displayed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`package.json`文件有三个主要字段。`name`包含与项目关联的唯一名称。请注意，此值将是应用程序数据（sessionStorage，localStorage等）存储的目录路径的一部分。`main`接受项目主要HTML页面的相对路径。最后，`window`描述了将显示HTML的浏览器窗口。
- en: Adding the HTML5 application
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加HTML5应用程序
- en: 'According to the `main` field in `package.json`, we will place our `index.html`
    in to the `wwwroot` subdirectory. We can try it with a simple HTML like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`package.json`中的`main`字段，我们将把我们的`index.html`放入`wwwroot`子目录中。我们可以尝试用简单的HTML如下：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'NW.js treats the HTML in the same way as a browser, so if we now launch the
    NW.js executable, we will see `Hello world!`. To give it look and feel we can
    add CSS and JavaScript. So we can write the code for NW.js in the same way as
    we do it for a browser. Here, we have a good opportunity to apply the principles
    that we learned in [Chapter 6](part0042_split_000.html#181NK2-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 6. A Large-Scale JavaScript Application Architecture"), *A Large-Scale
    JavaScript Application Architecture*. In order to make the example concise but
    expressive, we will take the AngularJS approach. First, we create the HTML. The
    markup of the body will be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: NW.js以与浏览器相同的方式处理HTML，因此如果我们现在启动NW.js可执行文件，我们将看到`Hello world!`。为了给它外观和感觉，我们可以添加CSS和JavaScript。因此，我们可以用与浏览器相同的方式编写NW.js的代码。在这里，我们有一个很好的机会来应用我们在[第6章](part0042_split_000.html#181NK2-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 6. A Large-Scale JavaScript Application Architecture")中学习到的原则，*大规模JavaScript应用程序架构*。为了使示例简洁但具有表现力，我们将采用AngularJS方法。首先，我们将创建HTML。主体的标记将如下所示：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We defined a form to submit new names and a table to display the already stored
    names. To make it prettier, we used Bootstrap ([http://getbootstrap.com](http://getbootstrap.com))
    styles. The CSS file can be loaded from a CDN as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个表单来提交新名字和一个表格来显示已经存储的名字。为了使其更漂亮，我们使用了Bootstrap([http://getbootstrap.com](http://getbootstrap.com))样式。CSS文件可以从CDN加载，如下所示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we will bring it to life by adding the AngularJS directives:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过添加AngularJS指令来使其生动起来：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here we declares a `myApp` module scope (`<body ng-app="myApp" >`). Within
    this, we defined a `RosterController` controller. In the boundaries of the controller,
    we bind our input field to the model name (`<input ng-model="name">`) and set
    handlers for the `form submit` and `Empty List` button click events (`<form ng-submit="submit()">`
    and `<button ng-click="empty()">`). Lastly, we make a template bound out of the
    table to the `$scope.persons` collection. So whenever the collection changes,
    the table is updated:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们声明了一个`myApp`模块作用域（`<body ng-app="myApp" >`）。在此范围内，我们定义了一个`RosterController`控制器。在控制器的边界内，我们将输入字段绑定到模型名称（`<input
    ng-model="name">`）并为表单提交和“空列表”按钮点击事件（`<form ng-submit="submit()">`和`<button ng-click="empty()">`）设置处理程序。最后，我们将一个模板从表格中绑定到`$scope.persons`集合。因此，每当集合发生变化时，表格就会更新：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now it is time to add some JavaScript to our HTML:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们向我们的HTML添加一些JavaScript的时候了：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we intend to store the data submitted in the form, we can use localStorage
    that we discussed in [Chapter 4](part0030_split_000.html#SJGS2-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 4. HTML5 APIs"), *HTML5 APIs*. In order to get localStorage in the AngularJS
    way, we used the `ngStorage` module ([https://github.com/gsklee/ngStorage](https://github.com/gsklee/ngStorage)).
    So, we specify the plugin during module initialization, and this makes the plugin
    available in the controller as a parameter (`$localStorage`). In the controller
    body, we have a function `sync` that sets `$scope.persons` with the person array
    from localStorage. We call the `sync` function in the form submit handler (`$scope.submit`)
    and in the **Empty List** button on-click handler (`$scope.empty`). It causes
    the person table to update every time. During the handling of the submit event,
    we append the value of the `$scope.persons` input and save `$scope.persons` in
    localStorage.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算存储表单提交的数据，我们可以使用我们在[第4章](part0030_split_000.html#SJGS2-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 4. HTML5 APIs")中讨论的*HTML5 APIs*中提到的localStorage。为了以AngularJS的方式获取localStorage，我们使用了`ngStorage`模块（[https://github.com/gsklee/ngStorage](https://github.com/gsklee/ngStorage)）。因此，我们在模块初始化时指定插件，这使得插件在控制器中作为一个参数（`$localStorage`）可用。在控制器主体中，我们有一个`sync`函数，它将`$scope.persons`设置为localStorage中的人数组。我们在表单提交处理程序（`$scope.submit`）和“空列表”按钮单击处理程序（`$scope.empty`）中调用`sync`函数。它每次都会更新人员表格。在处理提交事件时，我们将`$scope.persons`的值附加到`$scope.persons`并将其保存到localStorage中。
- en: 'In order to enable this functionality, we have to load the AngularJS and ngStorage
    plugins:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用此功能，我们必须加载AngularJS和ngStorage插件：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we launch the NW.js executable and get the application working. Following
    screenshot shows Roaster example app in NW.js without styles:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们启动NW.js可执行文件并让应用程序运行起来。下面的截图展示了在NW.js中没有样式的Roaster示例应用：
- en: '![Adding the HTML5 application](img/00018.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![添加HTML5应用程序](img/00018.jpeg)'
- en: 'It''s all nice, but as we run NW.js frameless, we have no way to even close
    the application. Besides, we cannot drag the application window within the desktop.
    This is easy to fix. We can add an HTML fragment to the HTML body with two buttons
    to close and minimize the application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但是当我们以无框架方式运行NW.js时，我们甚至没有办法关闭应用程序。此外，我们不能在桌面上拖动应用程序窗口。这个问题很容易解决。我们可以在HTML正文中添加一个HTML片段，带有两个按钮来关闭和最小化应用程序：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we subscribe listeners to these buttons that call the close and minimize
    NW.js Window API ([https://github.com/nwjs/nw.js/wiki/Window](https://github.com/nwjs/nw.js/wiki/Window))
    methods respectively:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为这些按钮订阅监听器，分别调用NW.js窗口API（[https://github.com/nwjs/nw.js/wiki/Window](https://github.com/nwjs/nw.js/wiki/Window)）的关闭和最小化方法：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order to make our window drag-able ([https://github.com/nwjs/nw.js/wiki/Frameless-window](https://github.com/nwjs/nw.js/wiki/Frameless-window)),
    we can use the `-webkit-app-region` CSS pseudo-class. We set this with the drag
    value on the handle container (header) and with the no-drag value on any clickable
    elements within it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的窗口可拖动（[https://github.com/nwjs/nw.js/wiki/Frameless-window](https://github.com/nwjs/nw.js/wiki/Frameless-window)），我们可以使用`-webkit-app-region`CSS伪类。我们将此设置为在处理容器（头部）上具有拖动值，并在其中设置为不可拖动的值：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In addition, we prettify the look and feel of the page. Note that with NW.js,
    we can have a transparent background. So we set the `border-radius` on the `html`
    element and the window gets rounded:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们美化页面的外观和感觉。注意，在NW.js中，我们可以拥有一个透明的背景。因此，我们在`html`元素上设置`border-radius`，使窗口变得圆角：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can launch our NW.js executable again. Roaster example app in NW.js
    with styles is shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次启动我们的NW.js可执行文件。带有样式的Roaster示例应用在NW.js中的截图如下：
- en: '![Adding the HTML5 application](img/00019.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![添加HTML5应用程序](img/00019.jpeg)'
- en: 'Note that on Mac OS X/Linux, we have to launch with special arguments ([https://github.com/nwjs/nw.js/wiki/Transparency](https://github.com/nwjs/nw.js/wiki/Transparency))
    to get the transparency effect. For example, we have to do the following on Mac
    OS X:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Mac OS X/Linux上，我们必须使用特殊参数（[https://github.com/nwjs/nw.js/wiki/Transparency](https://github.com/nwjs/nw.js/wiki/Transparency)）才能获得透明效果。例如，在Mac
    OS X上我们必须这样做：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Debugging
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: 'Still something is missing. If anything goes wrong, how can we debug and trace
    the errors? There are a few options available:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些东西缺失了。如果出了问题，我们如何调试和追踪错误？有以下几个选项可供选择：
- en: Launch the NW.js executable with the `--enable-logging` argument and get the
    logs in `stdout`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--enable-logging`参数启动NW.js可执行文件，并在`stdout`中获取日志。
- en: Launch the NW.js executable with `--remote-debugging-port` and access the DevTools
    application in a remotely running Chrome. For instance, we start up the project
    as `nw --remote-debugging-port=9222` and look for the `http://localhost:9222`
    page in Chrome.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--remote-debugging-port`参数启动NW.js可执行文件，并在远程运行的Chrome中访问DevTools应用程序。例如，我们以`nw
    --remote-debugging-port=9222`的方式启动项目，并在Chrome中寻找`http://localhost:9222`页面。
- en: Enable toolbar and frame for the window in `package.json`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`package.json`中为窗口启用工具栏和框架。
- en: 'The first option isn''t quite handy in debugging. The second provides you with
    a limited version of DevTools, and the last option brings the frame and can make
    the application look terrible. Fortunately, we can call DevTools programmatically
    from the app. So, on the `DEVELOPMENT/TEST` environment, you can add this code
    that shows up DevTools by pressing *Ctrl* + *Shift* + *I*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项在调试时并不太方便。第二个选项为您提供了一个DevTools的简化版，最后一个选项带来了框架，可能会使应用程序看起来很糟糕。幸运的是，我们可以从应用程序中以编程方式调用DevTools。所以在`DEVELOPMENT/TEST`环境中，您可以添加这段按下*Ctrl*
    + *Shift* + *I*即可显示DevTools的代码：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Programmatically called DevTools in NW.JS are shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: NW.JS中以编程方式调用的DevTools在以下屏幕快照中显示：
- en: '![Debugging](img/00020.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![调试](img/00020.jpeg)'
- en: Packaging
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包
- en: 'To have a real desktop application experience, we can bundle the projects assets
    and NW.js files into a single executable. Firstly using ZIP, we compress our project
    directory (`wwwroot`) and the accompanying files (the `node_modules` directory
    and the `NAPI` plugins) into `app.nw`. Then, we combine the archive with the NW.js
    executable. In Windows, this can be done as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有真正的桌面应用程序体验，我们可以将项目的资源和NW.js文件打包成一个可执行文件。首先使用ZIP，我们将项目目录（`wwwroot`）和伴随文件（`node_modules`目录和`NAPI`插件）压缩成`app.nw`。然后，我们将该压缩文件与NW.js可执行文件结合。在Windows上，可以这样操作：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the distribution of NW.js that is targeted for your platform contains any
    components (for example, the Windows distribution includes DLLs), inject them
    into the newly created application executable using Enigma Virtual Box ([http://enigmaprotector.com](http://enigmaprotector.com)).
    Voilà, now we can distribute the project in a single file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果针对您平台的NW.js发行版包含任何组件（例如，Windows发行版包括DLLs），可以使用Enigma虚拟盒（[http://enigmaprotector.com](http://enigmaprotector.com)）将它们注入到新创建的应用程序可执行文件中。完成啦，现在我们可以将项目以单一文件的形式分发。
- en: Using PhoneGap to make a mobile native app
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PhoneGap制作移动原生应用
- en: Well, now we can make desktop applications with JavaScript but what about native
    mobile applications? There are a number of web-based frameworks available for
    mobile development ([https://en.wikipedia.org/wiki/Multiple_phone_web-based_application_framework](https://en.wikipedia.org/wiki/Multiple_phone_web-based_application_framework)).
    One of the most trending solutions is called Adobe PhoneGap, which is built on
    top of the Apache Cordova project. By and large, the PhoneGap application consists
    of a web-stack (HTML5, CSS, and JavaScript). Despite the fact that nowadays, HTML5
    provides access to some of the native features (accelerometer, camera, contacts,
    vibration, GPS, and others), the support across different devices is inconsistent
    and quirky, and performance is relatively poor. So PhoneGap runs HTML5 inside
    a native WebView on a device and provides access to device resources and APIs
    ([https://en.wikipedia.org/wiki/Foreign_function_interface](https://en.wikipedia.org/wiki/Foreign_function_interface)).
    As a result, we can write a mobile application based on HTML5 and build it with
    PhoneGap for the devices and OS that we support (iPhone, Android, Blackberry,
    Windows, Ubuntu, Firefox OS, and others). A good point here is that we can reuse
    the components created for the Web while developing for mobile. In fact, we can
    bundle the Roster application that we made for NW.js as a mobile app. So let's
    do this.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们可以用 JavaScript 制作桌面应用程序，那原生移动应用程序呢？有许多基于 web 的框架可用于移动开发（[https://en.wikipedia.org/wiki/Multiple_phone_web-based_application_framework](https://en.wikipedia.org/wiki/Multiple_phone_web-based_application_framework)）。最流行的解决方案之一称为
    Adobe PhoneGap，它是在 Apache Cordova 项目之上构建的。总的来说，PhoneGap 应用程序由一个 web 堆栈（HTML5、CSS
    和 JavaScript）组成。尽管现在 HTML5 可以访问一些原生功能（加速计、相机、联系人、振动、GPS 等），但不同设备的兼容性不一致且古怪，性能相对较差。所以
    PhoneGap 在设备的本地 WebView 中运行 HTML5，并提供对设备资源和 API 的访问（[https://en.wikipedia.org/wiki/Foreign_function_interface](https://en.wikipedia.org/wiki/Foreign_function_interface)）。结果是，我们可以基于
    HTML5 编写一个移动应用程序，并使用 PhoneGap 为我们支持（iPhone、Android、黑莓、Windows、Ubuntu、Firefox OS
    等）的设备和操作系统构建它。这里的一个好处是，在为移动设备开发时，我们可以重用为 Web 创建的组件。事实上，我们可以将我们为 NW.js 制作的 `roster`
    应用程序作为移动应用程序捆绑。那么让我们这样做。
- en: Setting up the project
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'First of all we need a framework. The easiest way to install it is by using
    the NPM tool:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要一个框架。最简单的方法是使用 NPM 工具进行安装：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `-g` option means that we install this globally on the machine and don't
    need to do it when setting up any new project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 选项意味着我们将在全局安装此软件，在设置任何新项目时无需再次安装。'
- en: 'Now we can create a new project with the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令创建一个新项目：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `roster` subdirectory, the tool creates a `boilerplate` file structure
    for the project named `Roster` that is registered within the `org.tempuri.roster`
    namespace.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `roster` 子目录中，工具为项目创建了一个名为 `Roster` 的项目文件结构，该项目注册在 `org.tempuri.roster` 命名空间中。
- en: 'Now, we need to inform PhoneGap about the platforms that we want to support.
    So, we navigate to the `roster` subdirectory and type the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通知 PhoneGap 我们想要支持哪些平台。所以，我们导航到 `roster` 子目录并输入以下内容：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Building the project
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建项目
- en: 'In the `www` subdirectory, we can find a placeholder HTML5 application. We
    can replace this with the roster application written for NW.js (without an environment-specific
    header container and its listeners code, of course). In order to check whether
    the project was properly initialized, we run the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `www` 子目录中，我们可以找到一个占位符 HTML5 应用程序。我们可以用为 NW.js 编写的 `roster` 应用程序替换它（当然，不包括环境特定的头部容器及其监听器代码）。为了检查项目是否正确初始化，我们运行以下内容：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, we can use this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用这个：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This builds the project and displays it with a platform-specific emulator.
    On a Mac, this is how it looks. Roster example app by PhoneGap is shown in the
    following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这会构建项目并在特定平台的模拟器中显示它。在 Mac 上，它看起来是这样的。PhoneGap 提供的 `roster` 示例应用程序如下屏幕截图所示：
- en: '![Building the project](img/00021.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![构建项目](img/00021.jpeg)'
- en: Adding plugins
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加插件
- en: 'As it was mentioned already, with PhoneGap, we can access native device features
    ([http://phonegap.com/about/feature](http://phonegap.com/about/feature)). Moreover,
    we can also install and use native plugins available in the `Cordova` repository
    ([http://cordova.apache.org/plugins/](http://cordova.apache.org/plugins/)). Let''s
    take one of these—*cordova-plugin-vibration*. We can add it to the project as
    easy as this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用PhoneGap，我们可以访问原生设备功能（[http://phonegap.com/about/feature](http://phonegap.com/about/feature)）。而且，我们还可以安装和使用在`Cordova`仓库中可用的原生插件（[http://cordova.apache.org/plugins/](http://cordova.apache.org/plugins/)）。让我们拿其中一个来说——*cordova-plugin-vibration*。我们可以像这样轻松地将其添加到项目中：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we have the plugin, we can use its API in our JavaScript code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了插件，我们可以在我们的JavaScript代码中使用其API：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Debugging
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: As for debugging a mobile application, there are a number of options ([https://github.com/phonegap/phonegap/wiki/Debugging-in-PhoneGap](https://github.com/phonegap/phonegap/wiki/Debugging-in-PhoneGap)).
    The main idea is to reach the application with a desktop inspector tool. In the
    case of iOS, we go with the Safari WebInspector desktop. Just find the **iPhone
    Simulator** option in the **Develop** menu and press **WebView** corresponding
    to your application HTML. Similarly, we can access Android WebView in Chrome DevTools
    ([https://developer.chrome.com/devtools/docs/remote-debugging#debugging-webviews](https://developer.chrome.com/devtools/docs/remote-debugging#debugging-webviews)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 至于调试移动应用程序，有多种选择（[https://github.com/phonegap/phonegap/wiki/Debugging-in-PhoneGap](https://github.com/phonegap/phonegap/wiki/Debugging-in-PhoneGap)）。主要思想是使用桌面检查工具来达到应用程序。在iOS的情况下，我们选择Safari
    WebInspector桌面。只需在**开发**菜单中找到**iPhone Simulator**选项，并按下与你应用程序HTML相对应的**WebView**。同样，我们可以在Chrome
    DevTools中访问Android WebView([https://developer.chrome.com/devtools/docs/remote-debugging#debugging-webviews](https://developer.chrome.com/devtools/docs/remote-debugging#debugging-webviews))。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The widely spread Node.js run-time extends JavaScript with a low-level API,
    which unlocks for us on the methods of creating command-line tools, web-servers,
    and specialized servers (for example UDP-TCP/WebSocket/SSE servers). To see how
    far we can go beyond the Web, just consider a standalone OS NodeOS built with
    Node.js. With HTML5 and JavaScript we can write a desktop software and easily
    distribute it across different platforms. Similarly, we can compose a mobile application
    out of HTML5/JavaScript and native APIs. Using tools such as PhoneGap, we can
    build the application for diverse mobile platforms.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛使用的Node.js运行时通过低级API扩展JavaScript，这为我们提供了创建命令行工具、网络服务器和专用服务器（例如UDP-TCP/WebSocket/SSE服务器）的方法。只需考虑使用Node.js构建的独立操作系统NodeOS，看看我们可以在Web之外走多远。使用HTML5和JavaScript，我们可以编写桌面软件，并轻松地在不同平台上分发。同样，我们可以使用HTML5/JavaScript和原生API组成移动应用程序。使用诸如PhoneGap之类的工具，我们可以为多种移动平台构建应用程序。
- en: In this chapter, we learned how to access DevTools to debug NW.js and PhoneGap
    applications. In the next chapter, we will talk about how to use DevTools efficiently.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何访问DevTools来调试NW.js和PhoneGap应用程序。在下一章中，我们将讨论如何高效地使用DevTools。
