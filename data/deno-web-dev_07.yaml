- en: '*Chapter 5*: Adding Users and Migrating to Oak'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*5*章：添加用户和迁移到Oak
- en: At this point, we have laid the foundations for a web application with a structure
    that will enable us to add more functionalities as we proceed. As you might have
    guessed by the name of this chapter, we'll start this chapter by adding the middleware
    framework of our choice to the current web application, Oak.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经为Web应用程序奠定了基础，其结构将使我们能够随着进展添加更多功能。正如您可能从本章的名称中猜到的那样，我们将从向当前Web应用程序中添加我们选择的的中间件框架开始本章，这个框架就是Oak。
- en: Together with Oak, and since our application is starting to have more third-party
    dependencies, we'll use what we've learned in previous chapters to create a lock
    file and perform integrity checking when installing dependencies. This way, we
    can guarantee that our applications will run smoothly without dependency problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Oak一起，由于我们的应用程序开始有更多的第三方依赖项，我们将使用前一章节中学到的知识来创建一个锁文件并在安装依赖项时执行完整性检查。这样，我们可以保证我们的应用程序在无依赖问题的情况下顺利运行。
- en: As we get into this chapter, we'll start understanding how to simplify our code
    using Oak's features. We'll make our routing logic more extendable but also more
    scalable. Our first solution was to use `if` statements together with the standard
    library to create a DIY routing solution, which we'll refactor here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的深入，我们将开始了解如何使用Oak的功能简化我们的代码。我们将使我们的路由逻辑更具可扩展性，同时也更具可伸缩性。我们最初的解决方案是使用`if`语句和标准库创建一个DIY路由解决方案，我们将在这里重构它。
- en: Once we've done this, we'll end up with much cleaner code and be able to use
    Oak's features, such as automatic content-type definition, handling unallowed
    methods, and route prefixing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，我们将得到更干净的代码，并能够使用Oak的功能，例如自动内容类型定义、处理不允许的方法和路由前缀。
- en: 'Then, we''ll add a feature that is crucial in pretty much every application:
    users. We''ll create a module alongside museums to handle everything that is user-related.
    In this new module, we''ll develop the business logic to create users, as well
    as the code to create new users in the database, by using common practices such
    as hashes and salts.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个在几乎每个应用程序中都非常重要的功能：用户。我们将创建一个与博物馆并列的模块来处理所有与用户相关的事情。在这个新模块中，我们将开发创建用户的业务逻辑，以及使用散列和盐等常见做法在数据库中创建新用户的代码。
- en: While implementing these features, we will get to know other modules provided
    by Deno, such as the hashing features of the standard library or the crypto APIs
    that are included in the runtime.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这些功能的过程中，我们将了解到Deno提供的其他模块，比如标准库的散列功能或包含在运行时中的加密API。
- en: Adding this new module and having it interact with the rest of the application
    will be a nice way to test the application architecture. By doing this, we'll
    understand how it scales while keeping everything that is related to a context
    in a single place.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 新增这个模块并与应用程序的其他部分进行交互，将是一种很好的测试应用程序架构的方法。通过这样做，我们将了解它是如何保持相关上下文的一切在单一位置的同时进行扩展的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Managing dependencies and lock files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理依赖项和锁文件
- en: Writing a web server with Oak
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Oak编写Web服务器
- en: Adding users to the application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用程序添加用户
- en: Let's get started!
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will build on top of the code we developed in the previous chapter.
    All the codes files for this chapter are available in this book's GitHub repository
    at [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter05/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter05/sections).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将在前一章我们开发的代码基础上进行构建。本章的所有代码文件都可以在这本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter05/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter05/sections)。
- en: Managing dependencies and lock files
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖项和锁文件
- en: In [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056), *The Toolchain*,
    we learned how Deno enables us to do dependency management. In this section, we'll
    use it in a more practical context. We'll start by removing all the scattered
    imports with URLs from our code and move them into a central dependency file.
    After this, we'll create a lock file that makes sure our still young application
    runs smoothly anywhere it is installed. We'll finish by learning how can we install
    the project's dependencies based on a lock file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章《工具链》中，我们学习了Deno如何让我们进行依赖管理。在本节中，我们将使用它在一个更实用的上下文中。我们首先将我们代码中所有分散的带有URL的导入移除，并将它们移到集中式依赖文件中。此后，我们将创建一个锁定文件，以确保我们的尚处于初级阶段的应用程序在任何安装的地方都能顺利运行。最后，我们将学习如何根据锁定文件安装项目的依赖项。
- en: Using a centralized dependency file
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集中式依赖文件
- en: 'In the previous chapter, you probably noticed that we were using direct URLs
    to dependencies directly in our code. Even though this is possible, this was something
    we discouraged a few chapters ago. It worked for us in that first phase, but as
    the application starts growing, we''ll have to manage our dependencies properly.
    We want to avoid struggles with conflicting dependency versions, typos in the
    URLs, and having dependencies scattered across files. To solve this, we must do
    the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你可能注意到了我们直接在代码中使用URL来依赖项。尽管这是可能的，但我们在几章前就 discouraged 过这种做法。在我们第一个阶段，这种方法对我们有效，但随着应用程序开始增长，我们必须适当地管理我们的依赖项。我们希望避免与冲突的依赖版本、URL中的拼写错误以及依赖项分散在各个文件中等问题作斗争。为了解决这个问题，我们必须做以下几步：
- en: Create a `deps.ts` file at the root of the `src` folder.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`目录的根目录创建一个`deps.ts`文件。
- en: This file can have whatever name you prefer. We're currently calling it `deps.ts`
    as it is what is mentioned in Deno's documentation, and it's the naming convention
    many modules use.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个文件可以有任何你喜欢的名字。我们目前称之为`deps.ts`，因为这是Deno文档中提到的，也是许多模块使用的命名约定。
- en: Move all the external dependencies from our code to `deps.ts`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有外部依赖从我们的代码中移动到`deps.ts`。
- en: Currently, the only dependency we have is the HTTP module from the standard
    library, which can be found in the `src/web/index.ts` file.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们唯一拥有的依赖项是标准库中的HTTP模块，可以在`src/web/index.ts`文件中找到。
- en: 'Move the import into the `deps.ts` file and change `import` to `export`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将导入移动到`deps.ts`文件中，并将`import`更改为`export`：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice how the fixed version is on the URL:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意固定版本是如何出现在URL上的：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is how versioning works in Deno, as we learned in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)《工具链》中学到的，这是Deno中版本控制的工作方式。
- en: We now need to change the dependent files so that they import directly from
    the `deps.ts` file instead of being directly imported from the URL.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们需要更改依赖文件，使它们直接从`deps.ts`导入，而不是直接从URL导入。
- en: 'In `src/web/index.ts`, import the `serve` method from `deps.ts`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/web/index.ts`中，从`deps.ts`导入`serve`方法：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By having a centralized dependency file, we also have an easy way to make sure
    we have all our dependencies locally downloaded without having to run any code.
    With this, we now have a single file where we can run the `deno cache` command
    (mentioned in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056), *The
    Toolchain*).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有一个集中式依赖文件，我们也有了确保我们所有依赖项都本地下载的一种简单方式，而无需运行任何代码。有了这个，我们现在有了一个可以运行`deno cache`命令（在第2章《工具链》中提到）的单文件。
- en: Creating a lock file
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建锁定文件
- en: Having centralized our dependencies, we need to guarantee that whoever installs
    the project is getting the same versions of the dependencies we did. This is the
    only way we can guarantee that the code will run in the same way. We'll do this
    by using a lock file. We learned how to do this in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*; here, we'll apply it to our application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在将依赖项集中后，我们需要确保安装项目的人能够获得与我们相同的依赖项版本。这是确保代码以相同方式运行的唯一方式。我们将通过使用锁定文件来实现这一点。我们在第2章《工具链》中学习了如何做到这一点；在这里，我们将将其应用于我们的应用程序。
- en: 'Let''s run the `cache` command with the `lock` and `lock-write` flags, plus
    a path to the lock file and a path to the centralized dependencies file, `deps.ts`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行带有`lock`和`lock-write`标志的`cache`命令，以及锁定文件的路径和集中式依赖文件`deps.ts`的路径：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A `lock.json` file should be generated in the current folder. If you open it,
    it should contain a key-value pair of the URL, as well as the hash that's used
    for performing integrity checks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录下应该会生成一个`lock.json`文件。如果你打开它，它应该包含一个URL的键值对，以及用于执行完整性检查的哈希。
- en: 'This lock file should then be added to version control. Later, if a coworker
    wants to install this same project, they just have to run the same command without
    the `--lock-write` flag:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个锁文件应该然后添加到版本控制中。后来，如果一个同事想要安装这个同样的项目，他们只需要运行同样的命令，但不带`--lock-write`标志：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, the dependencies in `src/deps.ts` (this should be all of them) will
    be installed and have their integrity checked according to the `lock.json` file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，`src/deps.ts`中的所有依赖项（应该是全部依赖项）将被安装，并根据`lock.json`文件检查它们的完整性。
- en: Now, every time we install a new dependency in the project, we must run the
    `deno` `cache` command with the `lock` and `lock-write` flags, to make sure the
    lock file is updated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们在项目中安装一个新的依赖时，我们必须运行带有`lock`和`lock-write`标志的`deno` `cache`命令，以确保锁文件被更新。
- en: That's pretty much it for this section!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节就到这里！
- en: In this section, we learned a simple but very important step in making sure
    an application runs smoothly. This helps us avoid future hairy problems such as
    dependency conflicts and mismatches in behavior across versions. We're also guaranteeing
    resource integrity, something that is even more important in Deno, since its dependencies
    are hosted in a URL instead of a registry.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们学习了一个确保应用程序运行顺畅的简单但非常重要的步骤。这帮助我们避免未来可能出现的诸如依赖冲突和版本间行为不匹配等复杂问题。我们还保证了资源完整性，这对于Deno来说尤为重要，因为它的依赖项是存储在URL中，而不是注册表中。
- en: In the next section, we'll start *refactoring* our application from the standard
    library HTTP server into Oak, which will result in our web code being simplified.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从标准库HTTP服务器开始将我们的应用程序重构为Oak，这将使我们的网络代码得到简化。
- en: Writing a web server with Oak
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Oak编写网络服务器
- en: At the end of the previous chapter, we looked at different web libraries. After
    a brief analysis, we ended up choosing Oak. In this section, we'll rewrite part
    of our web application so that we can use it instead of the HTTP module from the
    standard library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的末尾，我们查看了不同的网络库。经过短暂的分析后，我们最终选择了Oak。在本节中，我们将重写我们网络应用程序的一部分，以便我们可以使用它而不是标准库的HTTP模块。
- en: Let's open `src/web/index.ts` and start tackling it step by step.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`src/web/index.ts`，并一步步开始处理它。
- en: 'Following Oak''s documentation ([https://deno.land/x/oak@v6.3.1](mailto:https://deno.land/x/oak@v6.3.1)),
    the only thing we''ll need to do is instantiate the `Application` object, define
    a middleware, and call the `listen` method. Let''s do it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循Oak的文档([https://deno.land/x/oak@v6.3.1](https://deno.land/x/oak@v6.3.1))，我们唯一需要做的是实例化`Application`对象，定义一个中间件，并调用`listen`方法。让我们来这样做：
- en: 'Add Oak''s import to the `deps.ts` file:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`deps.ts`文件中添加Oak的导入：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you are using VSCode, then you've probably noticed that there is warning
    saying that it couldn't find this version of the dependency locally.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是VSCode，那么你可能会注意到有一个警告，它说在当地找不到这个版本的依赖。
- en: Let's run the commands from the previous section to download it and add it to
    the lock file.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行上一节中的命令来下载它并添加到锁文件中。
- en: 'Do not forget to do this every time we add a dependency so that we have better
    autocompletion and our lock file is always updated:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记每次添加依赖时这样做，这样我们就有更好的自动完成，并且我们的锁文件总是更新的：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With all the necessary dependencies downloaded, let's start using them in our
    code.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有必要的依赖项都下载完成后，让我们开始在代码中使用它们。
- en: Delete all the code from the `createServer` function in `src/web/index.ts`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`src/web/index.ts`中`createServer`函数的所有代码。
- en: 'Inside `src/web/index.ts`, import the `Application` class and instantiate it.
    Create a very simple piece of middleware (as mentioned in the documentation) and
    call the `listen` method:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/web/index.ts`内部，导入`Application`类并实例化它。创建一个非常简单的中间件（如文档中所述）并调用`listen`方法：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Keep in mind that, while removing the old code, we also removed `console.log`
    and thus it will not print anything just yet. Let''s run it and verify that it
    has no problems:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在删除旧代码的同时，我们也删除了`console.log`，所以它现在还不会打印任何内容。让我们运行它并验证它是否有问题：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, if we access `http://localhost:8080`, we'll see the "Hello World!" response
    there.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们访问`http://localhost:8080`，我们将在那里看到“Hello World!”响应。
- en: Now, you might be wondering what the `use` method from Oak's application is.
    Well, we'll be using this method to define middleware. For now, we just want it
    to modify the response and add a message to its body. In the next chapter, we'll
    learn about middleware functions in more depth.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想知道Oak应用程序的`use`方法是什么。嗯，我们将使用这个方法来定义中间件。现在，我们只是想让它修改响应并在其主体中添加一条消息。在下一章，我们将深入学习中间件函数。
- en: Remember when we've removed `console.log` and that we don't get any feedback
    if the application is running? We'll learn how to do this while we learn about
    how to add event listeners to an Oak application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记得当我们移除了`console.log`，并且如果应用程序正在运行，我们就不会得到任何反馈吗？在我们学习如何向Oak应用程序添加事件监听器的同时，我们将学习如何做到这一点。
- en: Adding event listeners to an Oak application
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Oak应用程序中添加事件监听器
- en: So far, we've managed to get the application to run, but at the moment, we don't
    have any message to acknowledge this. We'll use this as an excuse to learn about
    event listeners in Oak.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设法让应用程序运行，但此刻，我们没有任何消息来确认这一点。我们将利用这一点来学习Oak中的事件监听器。
- en: Oak applications dispatch two different types of events. One of them is `listen`,
    while the other is `the listen event` is the one we'll use to log to the console
    when an application is running. The other, `error`, is the one we'll use to log
    to the console when an error occurs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Oak应用程序分发两种不同类型的事件。其中一个是`listen`，而另一个是`the listen event`，我们将用它来在应用程序运行时向控制台记录。另一个是`error`，我们将用它来在发生错误时向控制台记录。
- en: 'First, let''s add the event listener for the `listen` event, before the `app.listen`
    statement:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们调用`app.listen`语句之前，让我们添加一个`listen`事件的监听器：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we're not only printing a message to the console but also printing
    `hostname` from the event and sending it a default value, in case it is undefined.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不仅将消息打印到控制台，还打印出事件中的`hostname`并为其发送默认值，以防它未定义。
- en: 'For safety and to guarantee that we catch any unexpected errors, let''s also
    add an error event listener. This error event will be triggered in case an error
    that hasn''t been handled occurs in our application:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，并确保我们捕获任何意外错误，让我们也添加一个错误事件监听器。如果应用程序中发生了一个未处理的错误，将触发这个错误事件：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These handlers, especially the `error` one, will help us a lot when we're developing
    and want to gather quick feedback about what's happening. Later, when closer to
    the production stage, we'll add proper logging middleware.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些处理程序，特别是`error`处理程序，将在我们开发时帮助我们很多，当我们想要快速了解发生了什么时。后来，当接近生产阶段时，我们将添加适当的中间件日志记录。
- en: 'Now, you might be thinking that we''re still missing the functionality we had
    when we started this chapter, and you''d be right: we''ve removed the endpoint
    that listed all the museums from our application.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能认为我们仍然缺少我们在本章开始时拥有的功能，您是对的：我们从我们的应用程序中移除了列出所有博物馆的端点。
- en: Let's add it again and learn how can we create routes in an Oak application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次添加它，并学习如何在Oak应用程序中创建路由。
- en: Handling routes in an Oak application
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Oak应用程序中处理路由
- en: Oak provides another object, alongside the `Application` class, that allows
    us to define routes – the `Router` class. We'll use this to reimplement the route
    we had before, which listed all the museums in the application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Oak提供了另一个对象，与`Application`类一起使用，允许我们定义路由——`Router`类。我们将使用这个来重新实现我们之前的路由，该路由列出了应用程序中的所有博物馆。
- en: 'Let''s create it by sending the prefix property to the constructor. Doing this
    means that all the routes defined there will be prefixed with that path:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向构造函数发送前缀属性来创建它。这样做意味着那里定义的所有路由都将带有该路径的前缀：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s get back our functionality, which returns the list of museums via
    a `GET` request to `/api/museums`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们恢复我们的功能，通过向`/api/museums`发送一个`GET`请求返回博物馆列表：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A few things are happening here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些事情。
- en: Here, we're defining a route using Oak's router API by sending a URL and a handler
    function. Our handler is then called with a context (`ctx`) object. All of this
    is explained in detail in Oak's documentation ([https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts#Router](mailto:https://doc.deno.land/https/deno.land/x/oak@v6.3.0/mod.ts#Router)),
    but I'll leave you with a short resume.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用Oak的路由API定义路由，通过发送一个URL和一个处理函数。然后，我们的处理程序用一个上下文对象（`ctx`）调用。所有这些都在Oak的文档中详细说明（[https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts#Router](https://doc.deno.land/https/deno.land/x/oak@v6.3.0/mod.ts#Router)），但我留给您一个简短的总结。
- en: In Oak, everything that a handler can do is done through the context object.
    The request that's made is available in the `ctx.request` property, while the
    response for the current request is available in `ctx.response`. Things such as
    headers, cookies, parameters, the body, and so on are available in those objects.
    Some properties, such as `ctx.response.body`, are writable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oak中，所有处理程序能做的事情都是通过上下文对象完成的。发出的请求在`ctx.request`属性中可用，而当前请求的响应在`ctx.response`属性中可用。头信息、cookies、参数、正文等都在这些对象中可用。一些属性，如`ctx.response.body`，是可写的。
- en: Tip
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can get a better overview of Oak''s functionality by looking at Deno''s
    documentation website: [https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts](mailto:https://doc.deno.land/https/deno.land/x/oak@v6.3.0/mod.ts).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看Deno的文档网站更好地了解Oak的功能：[https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts](https://doc.deno.land/https/deno.land/x/oak@v6.3.0/mod.ts)。
- en: In this case, we're using the response body property to set its content. When
    Oak can infer the response's type (which is JSON here), it automatically adds
    the correct `Content-Type` header to the response.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用响应体属性来设置其内容。当Oak能够推断出响应的类型（这里是JSON）时，它会自动在响应中添加正确的`Content-Type`头。
- en: We'll be learning more about Oak and its features throughout this book. The
    next step is to connect our recently created router.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中了解更多关于Oak及其功能的内容。下一步是连接我们最近创建的路由器。
- en: Connecting the router to the application
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将路由器连接到应用程序
- en: Now that our router is defined, we need to register it on the application so
    that it can start handling requests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的路由器已经定义好了，我们需要在应用程序上注册它，这样它就可以开始处理请求了。
- en: To do that, we'll use a method of the application instance we've used previously
    – the `use` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用我们之前使用过的应用程序实例的方法——`use`方法。
- en: 'In Oak, once a `Router` has been defined (and its registered), it provides
    two methods that return middleware functions. These functions can then be used
    to register routes on the application. They are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oak中，一旦定义了一个`Router`（并将其注册），它提供了两个返回中间件函数的方法。这些函数可以用来在应用程序上注册路由。它们如下所示：
- en: '`routes`: Registers the registered route handlers in the application.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`：在应用程序中注册已注册的路由处理程序。'
- en: '`allowedMethods`: Registers automatic handlers for the API calls of methods
    that are not defined in the router, returning a `405 – Not allowed` response.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowedMethods`：为在路由器中未定义的API调用注册自动处理程序，返回`405 – Not allowed`响应。'
- en: 'We''ll use both of them to register our router in the main application, as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用它们来在我们的主应用程序中注册我们的路由器，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And with this, our router registers its handlers in the application, and they
    are ready to start handling requests.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，我们的路由器在应用程序中注册了它的处理程序，它们准备好开始处理请求。
- en: Keep in mind that we have to register these before the Hello World middleware
    we defined earlier. If we don't do this, the Hello World handler will respond
    to all the requests before they reach our router, and thus it will not work.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们必须在之前定义的Hello World中间件之前注册这些。如果我们不这样做，Hello World处理程序会在它们到达我们的路由器之前响应所有请求，因此它将无法工作。
- en: 'Now, we can run our application by running the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行以下命令来运行我们的应用程序：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we can perform a `curl` to the URL:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以对URL执行一个`curl`命令：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, everything is working as expected! We've managed to migrate our
    application to Oak.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，一切都在按预期工作！我们已经成功将我们的应用程序迁移到了Oak。
- en: By doing this, we've vastly improved the readability of our code. We also used
    Oak to handle stuff we didn't wanted to deal with, and we managed to focus on
    our application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，我们大大提高了代码的可读性。我们还使用Oak处理了我们不想处理的事情，并且我们成功地专注于我们的应用程序。
- en: In the next section, we will add the concept of users to the application. More
    routes will be created, as well as a whole new module and some business logic
    to handle users.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向应用程序添加用户概念。将创建更多的路由，以及一个全新的模块和一些处理用户的业务逻辑。
- en: Tip
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The code from this chapter is available, separated by sections, at [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter05/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter05/sections).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter05/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter05/sections)找到，按章节分隔。
- en: Now, let's add some users to the application!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向应用程序中添加一些用户！
- en: Adding users to the application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向应用程序添加用户
- en: We currently have the first endpoint running and listing all the museums in
    the application, but we're still far from meeting the final requirements.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前已经有了一个端点在运行，列出了应用程序中的所有博物馆，但我们离最终要求还远着呢。
- en: We want to add users so that it is possible to register, log in, and interact
    with the application with an identity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望添加用户，以便可以注册、登录并以身份与应用程序交互。
- en: We'll start by creating the object that will define the user, and then proceed
    into the business logic to create and store it. After this, we'll create endpoints
    that will allow us to interact with the application via HTTP, thus allowing users
    to register.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个定义用户的对象，然后进入业务逻辑以创建并存储它。在此之后，我们将创建端点，以便我们能够通过HTTP与应用程序交互，从而允许用户注册。
- en: Creating the user module
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户模块
- en: 'We currently have what we can call a single "module" in the application: the
    `museums` module. Everything that is related to museums is there, from controllers
    to repositories, object definitions, and so on. This module has one single interface,
    which is its `index.ts` file.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们可以称应用程序中有一个单一的“模块”：`museums`模块。从控制器到仓库、对象定义等，与博物馆相关的所有内容都在这里。这个模块有一个单一的接口，即它的`index.ts`文件。
- en: We did this so that we have the freedom of working inside the module while maintaining
    its external API so that it's always stable. This gives us a nice degree of decoupling
    between modules. To make sure that the pieces inside a module are reasonably decoupled,
    we must also inject their dependencies via a constructor, allowing us to easily
    swap pieces and test them in isolation (as you'll see in [*Chapter 8*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178),
    *Testing – Unit and Integration*).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了在模块内部拥有工作的自由，同时保持其外部API的稳定性，以便它总是稳定的。这为我们模块之间提供了很好的解耦。为了确保模块内部的各个部分合理地解耦，我们还必须通过构造函数注入它们的依赖项，这允许我们轻松地交换部分并独立测试它们（如您将在[第8章](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178)中看到的*测试
    - 单元和集成*）。
- en: 'Following those guidelines, we''ll keep using this "modules" system and create
    one for our users by following these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些指南，我们将继续使用这个“模块”系统，并通过以下步骤为我们的用户创建一个模块：
- en: Create a folder named `src/users` and put the `index.ts` file inside it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/users`的文件夹，并将`index.ts`文件放在里面。
- en: 'Create the `src/users/types.ts` file. This is where we''ll define the `User`
    type:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/users/types.ts`的文件。我们将在这里定义`User`类型：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our user object will be very simple: it will have a `username`, a `createdAt`
    date, and then two properties: `hash` and `salt`. We''ll use these to safeguard
    the user''s password when we store it.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的用户对象将非常简单：它将有一个`username`，一个`createdAt`日期，然后是`hash`和`salt`两个属性。我们将使用这些来保护存储时用户密码的安全。
- en: 'Create the user controller in `src/users/controller.ts` with a `register` method.
    It should receive a username and a password, and then create a user in the database:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/controller.ts`中创建一个名为`register`的用户控制器方法。它应该接收一个用户名和一个密码，然后在数据库中创建一个用户：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Define `RegisterPayload` in `src/users/types.ts` and export it in `src/users/index.ts`,
    removing it from `src/users/controller.ts`
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/types.ts`中定义`RegisterPayload`，并在`src/users/index.ts`中导出它，从`src/users/controller.ts`中删除它。
- en: 'Inside `src/users/types.ts`, add the following:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`src/users/types.ts`中添加以下内容：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside `src/users/index.ts`, add the following:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`src/users/index.ts`中添加以下内容：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's stop here for now and think about the register logic.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们现在停下来，思考一下注册逻辑。
- en: To create a user, we must check if that user exists in the database. If they
    don't, we'll create them with the username and password that was entered, and
    then return an object that doesn't contain sensitive data.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建用户，我们必须检查该用户是否存在于数据库中。如果不存在，我们将使用输入的用户名和密码创建他们，然后返回一个不包含敏感数据的对象。
- en: In the previous chapter, we used the repository pattern every time we wanted
    to interact with a data source. The repository kept all the *data accessing* logic
    (`src/museums/repository.ts`).
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一章中，每次我们想要与数据源交互时，我们都使用了仓库模式。仓库保留了所有*数据访问*逻辑（`src/museums/repository.ts`）。
- en: 'Here, we''re going to do the same. We''ve already noticed that our controller
    needs to call two methods in `UserRepository`: one to check if a user exists and
    another to create the user. That''s the interface we''re going to be defining
    next.'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将做同样的操作。我们已经注意到我们的控制器需要调用`UserRepository`中的两个方法：一个是为了检查用户是否存在，另一个是创建用户。这是我们接下来要定义的接口。
- en: 'Go to `src/users/types.ts` and define the interface for `UserRepository`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`src/users/types.ts`并定义`UserRepository`接口：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note how we created a `CreateUser` type that contains all the properties of
    `User` except for `createdAt`, which should be added by the repository.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何创建一个包含`User`对象所有属性（除`createdAt`外）的`CreateUser`类型的。这个`createdAt`应该由仓库添加。
- en: With the `UserRepository` interface defined, we can now move on to our user's
    controller and make sure it receives an instance of the repository in the constructor.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了`UserRepository`接口后，我们就可以继续编写用户控制器，并确保它在构造函数中接收仓库的一个实例。
- en: 'In `src/users/controller.ts`, create a `constructor` that receives the user
    repository as an injected parameter and sets the class property with the same
    name:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/controller.ts`中，创建一个`constructor`，它接收用户仓库作为注入参数，并使用相同名称设置类属性：
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Write the logic for the `register` method, check if the user exists, and create
    them if not:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`register`方法的逻辑，检查用户是否存在，如果不存在则创建他们：
- en: '[PRE22]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a type called `UserDto` in `src/users/types.ts` that defines the format
    of the `User` object without sensitive data:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/types.ts`中创建一个名为`UserDto`的类型，定义了不包含敏感数据的`User`对象的格式：
- en: '[PRE23]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a file called `src/users/adapter.ts` with a function called `userToUserDto`
    inside it that converts a user into a `UserDto`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`src/users/adapter.ts`的文件中创建一个名为`userToUserDto`的函数，该函数将用户转换为`UserDto`：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Use the recently created function in the register method to make sure we''re
    returning a `UserDto`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注册方法中使用最近创建的函数，确保我们返回的是`UserDto`：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, the `register` method is complete!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`register`方法就完成了！
- en: We're currently sending the hash and salt as two plain strings that don't mean
    anything.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前发送的哈希和盐是两个没有任何意义的明文字符串。
- en: You might be wondering why we don't send the password directly. This is because
    we want to make sure we're not storing passwords in plain text in any database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不直接发送密码。这是因为我们想确保我们不会在任何数据库中以明文形式存储密码。
- en: To make sure we're following the best practices, we will use hashing and salting
    to store the users' password in the database. While doing that, we also want to
    learn about a couple more Deno APIs. That's what we'll do in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们遵循最佳实践，我们将使用哈希和加盐的方法将用户的密码存储在数据库中。同时，我们还想学习一些Deno API。我们将在下一节中进行这些操作。
- en: Storing a user in the database
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数据库中存储用户
- en: Even though we're using an in-memory database, we've decided that we won't store
    the passwords in plain text. Instead, we'll use a common method to store passwords
    called hashing and salting. If you are not familiar with it, auth0 has a great
    article on it that I definitely recommend ([https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/](https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们使用的是内存数据库，我们决定不会以明文形式存储密码。相反，我们将使用一种常见的密码存储方法，称为哈希和加盐。如果你不熟悉这个方法，auth0有一篇非常好的文章，我强烈推荐阅读([https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/](https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/)).
- en: The pattern itself is not complicated, and you can learn it just by following
    the code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 模式本身并不复杂，你只需要按照代码来学习它。
- en: So, what we will do is store our password hashed. We won't be storing the exact
    hashed password the user entered, but the password plus a randomly generated string,
    called a salt. This salt will then be stored alongside the password so that it
    can be used later. After this, we will never need to decode the password again.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们所要做的就是以哈希形式存储我们的密码。我们不会存储用户输入的确切哈希密码，而是存储密码加上一个随机生成的字符串，称为盐。然后将这个盐与密码一起存储，以便稍后使用。之后，我们就不需要再次解码密码了。
- en: With the salt, any time we want to check if a password is correct, we just have
    to add the salt to whatever password the user entered, hash it, and verify that
    the output matches what is stored in the database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了盐，每次我们想要检查密码是否正确时，只需将盐添加到用户输入的任何密码中，对其进行哈希，并验证输出是否与数据库中存储的内容匹配。
- en: 'If this still seems strange to you, I can guarantee it becomes much simpler
    when you look at the code. Let''s implement these functions by following these
    steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说仍然很奇怪，我敢保证当你查看代码时它会变得简单得多。让我们按照这些步骤实现这些函数：
- en: 'Create a utils file called `src/users/util.ts` with a `hashWithSalt` function
    inside it that hashes a string with the provided salt:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/util.ts`文件中创建一个名为`hashWithSalt`的函数，该函数使用提供的盐对字符串进行哈希：
- en: '[PRE26]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It should be clear by now that this function will return a string that is the
    `hash` value of the provided string, plus a `salt`.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在应该很清楚，这个函数将返回一个字符串，它是提供字符串的`hash`值加上一个`salt`。
- en: It's also considered a best practice (as mentioned in the article mentioned
    previously) to use different salts for different passwords. By generating a different
    `salt` for each password, we ensure all the passwords are still safe if one password's
    salt is leaked.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如之前文章中提到的，被认为是最佳实践的是为不同的密码使用不同的盐。通过为每个密码生成不同的`salt`，即使一个密码的盐被泄露，我们也能确保所有的密码都是安全的。
- en: Let's proceed by creating a function that will generate a `salt`.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们通过创建一个生成`salt`的函数来继续。
- en: 'Create a `generateSalt` function using the `crypto` API ([https://doc.deno.land/builtin/stable#crypto](https://doc.deno.land/builtin/stable#crypto))
    to get random values and generate a salt string from there:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`crypto` API（[https://doc.deno.land/builtin/stable#crypto](https://doc.deno.land/builtin/stable#crypto)）创建一个`generateSalt`函数，以获取随机值并从那里生成盐字符串：
- en: '[PRE27]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And that's all we need to generate hashed passwords for our application.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是我们为应用程序生成哈希密码所需的一切。
- en: Now, we can start using the utility functions we just created in our controller.
    Let's create a method so that we can hash our password there.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的控制器中开始使用我们刚刚创建的实用函数。让我们创建一个方法，在那里我们可以哈希我们的密码。
- en: 'Create a private method inside `UserController` called `getHashedUser` that
    receives a username and password and returns a user, along with their hash and
    salt:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserController`中创建一个名为`getHashedUser`的私有方法，它接收一个用户名和密码，并返回一个用户，以及他们的哈希值和盐：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use the recently created `getHashedUser` method in the `register` method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`register`方法中使用最近创建的`getHashedUser`方法：
- en: '[PRE29]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And we're done! With that, we've made sure that we aren't storing any plain
    text passwords. In the path, we learned about the `crypto` APIs available in Deno.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大功告成！这样一来，我们确保我们没有存储任何明文密码。在路径中，我们学习了Deno中可用的`crypto` API。
- en: We did all of this implementation while using on the `UserRepository` interface
    that we defined previously. However, currently, we don't have a class that implements
    it, so let's create one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的实现都是在使用我们之前定义的`UserRepository`接口。然而，目前我们还没有一个实现它的类，所以让我们创建一个。
- en: Creating the user repository
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户仓库
- en: 'In the previous section, we created the interface that defined `UserRepository`,
    so next, we''re going to create a class that implements it. Let''s get started:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分，我们创建了定义`UserRepository`的接口，所以接下来，我们要创建一个实现它的类。让我们开始吧：
- en: 'Create a file called `src/users/repository.ts` with an exported `Repository`
    class inside it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/users/repository.ts`的文件，其中有一个导出的`Repository`类：
- en: '[PRE30]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The interface guarantees that these two public methods need to exist.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口保证这两个公共方法必须存在。
- en: Now, we need a way to store the users. For the purpose of this chapter, we'll
    use an in-memory database again, very similar to what we did with our museums.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要一种存储用户的方法。为了本章的目的，我们再次使用内存数据库，这与我们之前的博物馆做法非常相似。
- en: 'Create a property inside the `src/users/repository.ts` class called `storage`.
    It should be a JavaScript Map, and it will work as the users'' database:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/repository.ts`类中创建一个名为`storage`的属性。它应该是一个JavaScript Map，将作为用户数据库使用：
- en: '[PRE31]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the database in place, we can now implement the logic for the two methods.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了数据库，我们现在可以实现这两个方法的逻辑。
- en: 'Get the user from the database in the `exists` method, returning `true` if
    it is there and `false` if not:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`exists`方法中从数据库获取用户，如果存在则返回`true`，否则返回`false`：
- en: '[PRE32]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `Map#get` function returns undefined if it can't get the record, so we're
    converting it into a Boolean to make sure it always returns true or false.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Map#get`函数如果无法获取记录，则返回undefined，所以我们将它转换为Boolean，以确保它总是返回true或false。'
- en: The `exists` method is quite simple; it just needs to check whether the user
    is present in the database and a `boolean` is returned accordingly.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`exists`方法相当简单；它只需要检查用户是否存在于数据库中，相应地返回一个`boolean`。'
- en: To create a user, we need do perform one or two steps more than that. More than
    just creating it, we'll have to ensure it also adds a `createdAt` date to the
    user that's sent by whoever is calling this function.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建用户时，我们需要比那多做一到两个步骤。不仅仅是创建，我们还需要确保调用此函数的人还向用户发送了`createdAt`日期。
- en: 'Now, let''s go back and complete our main task: creating a user in the database.'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的主要任务：在数据库中创建用户。
- en: Open the `src/users/repository.ts` file and implement the `create` method, creating
    a `user` object in the proper format.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/users/repository.ts`文件，实现`create`方法，以正确的格式创建一个`user`对象。
- en: 'Remember to add `createdDate` to the `user` object that was sent to the function:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得向发送给函数的`user`对象中添加`createdDate`：
- en: '[PRE33]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And with that, our repository is complete!
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样一来，我们的仓库就完成了！
- en: It fully implements what we previously defined in the `UserRepository` interface
    and is ready to be used.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它完全实现了我们之前在`UserRepository`接口中定义的内容，并已准备好使用。
- en: The next step is to wire all these pieces together. We've already created the
    `User` controller and the `User` repository, but they're still not being used
    anywhere.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步是把这些碎片串起来。我们已经创建了`User`控制器和`User`仓库，但它们目前还没有在任何地方被使用。
- en: Before we proceed, we need to expose these objects from the user module to the
    outside world. We'll follow the rule we defined previously; that is, the modules
    interface will always be an `index.ts` file at its root.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要将用户模块中的这些对象暴露给外部世界。我们将遵循我们之前定义的规则；也就是说，模块的接口将始终是其根目录下的`index.ts`文件。
- en: 'Open `src/users/index.ts` and export the `Controller`, the `Repository` classes,
    and their respective types from the module:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/users/index.ts`，并从模块中导出`Controller`，`Repository`类及其相应的类型：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can now make sure that every file in the user module is importing types directly
    from this file (`src/users/index.ts`) instead of going directly to other files.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以确保用户模块中的每个文件都是直接从这个文件（`src/users/index.ts`）导入类型，而不是直接导入其他文件。
- en: Now, any module that wants to import stuff from the user module must do so through
    the `index.ts` file. Now, we can start to think about how the user will interact
    with the business logic we just wrote. Since we're building an API, we'll learn
    how to expose it via HTTP in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何想要从用户模块导入内容的模块都必须通过`index.ts`文件进行导入。现在，我们可以开始考虑用户如何与刚刚编写的业务逻辑互动。由于我们正在构建一个API，下一节我们将学习如何通过HTTP暴露它。
- en: Creating the register endpoint
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建注册端点
- en: With the business logic and data accessing logic ready, the only thing missing
    is the endpoint that the user can call to register itself.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑和数据访问逻辑准备就绪，唯一缺少的是用户可以调用以注册自己的端点。
- en: For the register request, we'll implement a `POST /api/users/register` expecting
    a JSON object with a property named `user` containing two properties, `username`
    and `password`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于注册请求，我们将实现一个`POST /api/users/register`接口，预期是一个包含名为`user`的属性，该属性包含`username`和`password`两个属性的JSON对象。
- en: 'The first thing we''ll have to do is declare that our `createServer` function
    in `src/web/index.ts` will depend on the `UserController` interface to be injected.
    Let''s get started:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先必须做的是声明`src/web/index.ts`中的`createServer`函数将依赖于`UserController`接口被注入。让我们开始吧：
- en: 'In `src/users/types.ts`, create the `UserController` interface. Make sure it
    is also exported in `src/users/index.ts`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/users/types.ts`中创建`UserController`接口。确保它也导出在`src/users/index.ts`中：
- en: '[PRE35]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, just to keep things tidy, go to `src/users/controller.ts` and make sure
    that the class implements `UserController`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了保持整洁，前往`src/users/controller.ts`，确保类实现了`UserController`：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Back inside `src/web/index.ts`, add `UserController` to the `createServer`
    dependencies:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/web/index.ts`，将`UserController`添加到`createServer`依赖项中：
- en: '[PRE37]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We're now ready to create our register handler.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在准备好创建我们的注册处理器。
- en: 'Create a handler that responds to a `POST` request in `/api/users/register`
    and creates a user using the injected controller''s `register` method:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个处理器，响应`/api/users/register`的`POST`请求，并使用注入的控制器的`register`方法创建用户：
- en: '[PRE38]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This should be enough for the web layer to be able to answer our request perfectly.
    Now, we just need to connect everything together.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以使Web层能够完美地回答我们的请求。现在，我们只需要连接所有东西在一起。
- en: Wiring the user controller with the web layer
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将用户控制器与Web层连接
- en: We have created the fundamental pieces of the application. There's the business
    logic, there's the data accessing logic, and there's the web server to handle
    the request. The only thing that is missing is something that connects them. In
    this section, we'll instantiate the actual implementations of the interfaces we've
    defined and inject them into the content that's expecting them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了应用程序的基本部分。有业务逻辑，有数据访问逻辑，有Web服务器来处理请求。唯一缺少的是将它们连接在一起的东西。在本节中，我们将实例化我们定义的接口的实际实现，并将它们注入到期望它们的内容中。
- en: Go back into `src/index.ts`. Let's do something similar to what we did with
    the `museums` module. Here, we'll import the user repository and controller, instantiate
    them, and send the controller to the `createServer` function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`src/index.ts`。让我们做与`museums`模块类似的事情。在这里，我们将导入用户仓库和控制器，实例化它们，并将控制器发送到`createServer`函数。
- en: 'Follow the steps to do so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作：
- en: 'In `src/index.ts`, import the user `Controller` and `Repository` from the user
    module and instantiate them, sending the necessary dependencies while doing so:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/index.ts`中，从用户模块导入`Controller`和`Repository`，并在实例化它们时发送必要的依赖项：
- en: '[PRE39]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Send the user controller to the `createServer` function:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户控制器发送到`createServer`函数中：
- en: '[PRE40]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And with that, we''re done! To finish this, let''s run our application by running
    the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，到这里我们就算是完成了！为了结束这一节，让我们通过运行以下命令来运行我们的应用程序：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s test the registered endpoint by making a request to `/api/users/register`
    with `curl`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用`curl`向`/api/users/register`发送请求来测试注册端点：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As we can see, it''s working and returning the contents of `UserDto`. Our main
    objective for this chapter has been achieved: we''ve created the user module and
    added an endpoint to register a user!'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它正在运行并返回`UserDto`的内容。我们这一章的主要目标已经实现：我们创建了用户模块并在其中添加了一个注册用户的端点！
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our application went through a big change in this chapter!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们的应用程序经历了巨大的变化！
- en: We started by migrating our application from the standard library HTTP module
    to Oak. Not only did we migrate the logic to serve the app, but we also started
    to define some routes using Oak's router. We noticed that the application logic
    started to become simpler as Oak encapsulated part of the job that was done manually
    previously. We managed to migrate all the HTTP code from the standard library
    without having to change the business logic, which is a very good sign that we're
    doing well in terms of application architecture.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将我们的应用程序从标准库HTTP模块迁移到Oak。我们不仅迁移了服务应用程序的逻辑，而且还开始使用Oak的路由器定义一些路线。我们注意到，随着Oak封装了以前需要手动完成的任务，应用程序逻辑开始变得简单。我们成功地将标准库中的所有HTTP代码迁移过来，而没有改变业务逻辑，这是一个非常好的迹象，表明我们在应用程序架构方面做得很好。
- en: We kept moving and learned how to listen and handle events in an Oak application.
    As we started writing more code, we also became more familiar with Oak, understanding
    its functionalities, exploring its documentation, and experimenting with it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续前进，并学会了如何在Oak应用程序中监听和处理事件。随着我们开始编写更多的代码，我们也对Oak变得更加熟悉，理解其功能，探索其文档，并对其进行实验。
- en: Users are an important part of any application and with that in mind, we also
    spent a big part of this chapter focusing on them. We not only added users to
    our application but added it as a separate, self-contained module, alongside museums.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是任何应用程序的重要组成部分，带着这样的想法，我们把这一章的大部分时间都花在了他们身上。我们不仅在应用程序中添加了用户，还把它作为一个独立的、自包含的模块添加了进来，与博物馆并列。
- en: Once we'd developed the business logic for registering a user in the application,
    the need for a persistency layer for it was imminent. This meant we had to develop
    a user repository, which is responsible for creating users in the database. Here,
    we dived a little deeper and implemented a hash and salt mechanism to store the
    user's password on the database securely, while learning about a few Deno APIs
    in the process.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在应用程序中开发了注册用户的业务逻辑，为它添加一个持久层就变得迫切了。这意味着我们必须开发一个用户存储库，负责在数据库中创建用户。在这里，我们深入实现了一个散列和盐机制，以在数据库上安全地存储用户的密码，并在过程中学习了一些Deno
    API。
- en: 'With the user business logic complete, we moved on to the part that was missing:
    the HTTP endpoint. We added the register route to our HTTP router and got everything
    set up with the help of Oak.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用户业务逻辑完成后，我们转向了缺失的部分：HTTP端点。我们在HTTP路由器中添加了注册路线，并在Oak的帮助下完成了所有设置。
- en: To wrap things up, we wired everything up again using dependency injection.
    Since all our modules' dependencies were based on interfaces, we easily injected
    the needed dependencies and got our code to work.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用依赖注入再次连接了所有内容。由于我们所有模块的依赖都是基于接口的，我们很容易注入所需的依赖并使我们的代码工作。
- en: This chapter was a journey toward making our application more scalable and readable.
    We started by removing our DIY router code and moving it into Oak, and ended by
    us adding one big and important *business* entity – users. The latter also worked
    as a test for our architecture and to demonstrate how it can scale with different
    business domains.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是我们使应用程序更具可扩展性和可读性的旅程。我们首先移除了我们的DIY路由器代码并将其移动到Oak，并以添加一个重要的大*业务*实体——用户结束。后者也作为我们架构的测试，并展示了它如何随着不同的业务领域而扩展。
- en: In the next chapter, we'll keep iterating on the application by adding some
    interesting features. By doing this, we will complete the functionality we created
    here, such as user login, authorization, and persistence in a real database. Otherthings
    we'll tackle will include common API practices, such as basic logging and error
    handling.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加一些有趣的功能来不断迭代应用程序。这样做，我们将完成在这里创建的功能，例如用户登录、授权以及在真实数据库中的持久化。我们还将处理包括基本日志记录和错误处理在内的常见API实践。
- en: Excited? So are we – let's go!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 兴奋吗？我们也是——开始吧！
