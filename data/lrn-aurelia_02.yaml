- en: Chapter 2. Layout, Menu, and Getting Familiar
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 布局、菜单和熟悉
- en: At this point, you should have a good understanding of how to create an Aurelia
    application. The big picture is probably still vague, but details will keep emerging
    as we go through this chapter. We will first see how dependency injection and
    Aurelia's plugin system work, then we will see how to use, configure, and customize
    the Aurelia logger so we can trace and monitor what's going on in our code. Lastly,
    we will explore the Aurelia router and navigation model. Incidentally, we will
    keep scratching at templating, while we start building a real-life application
    by creating a global layout template and its navigation menu.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，你应该已经对如何创建Aurelia应用程序有了很好的了解。大局可能仍然模糊，但随着我们贯穿本章，细节将不断出现。我们首先将了解依赖注入和Aurelia的插件系统是如何工作的，然后我们将了解如何使用、配置和自定义Aurelia日志记录器，以便我们可以追踪和监控我们代码中的情况。最后，我们将探讨Aurelia路由器和导航模型。顺便说一下，在我们开始构建真实应用程序时，我们将继续研究模板，通过创建全局布局模板及其导航菜单来构建真实应用程序。
- en: Throughout this book, we will build, step by step, an application. In each chapter,
    we will add both functional and technical features. It starts in this chapter.
    So before getting technical, let me first describe what our application will do.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将逐步构建一个应用程序。在每一章中，我们将添加功能性和技术性特征。它从这一章开始。所以在深入技术之前，请允许我首先描述我们的应用程序将做什么。
- en: We will be building a contact management application. This application will
    allow users to browse through contacts, perform searches, create, and edit entries.
    Of course, it will rely on an HTTP API to manage the data. This backend is available
    [https://github.com/PacktPublishing/Learning-Aurelia](https://github.com/PacktPublishing/Learning-Aurelia);
    it is a simple Node.js-based service. Just download it, unzip it in a directory,
    fire a console into that directory and run `npm install` to restore the required
    packages and then `npm start` to launch the web server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建一个联系人管理应用程序。这个应用程序将允许用户浏览联系人、执行搜索、创建和编辑条目。当然，它将依赖于一个HTTP API来管理数据。这个后端可以在
    [https://github.com/PacktPublishing/Learning-Aurelia](https://github.com/PacktPublishing/Learning-Aurelia)找到；这是一个简单的基于Node.js的服务。只需下载它，在一个目录中解压，在该目录中打开控制台并运行
    `npm install` 以恢复所需包，然后运行 `npm start` 来启动网络服务器。
- en: Next, you should go and create an empty project with the Aurelia CLI, preferably
    using the default options. All the examples and code samples in this book having
    been built with the default CLI setup in mind; some code snippets won't work if
    you customize the project creation or use a skeleton instead. So in order to keep
    the learning process as smooth as possible, I strongly suggest you start with
    the default setup.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你应该去使用Aurelia CLI创建一个空项目，最好使用默认选项。本书中的所有示例和代码样本都是使用默认CLI设置构建的；如果你定制项目创建或使用骨架，一些代码片段可能无法工作。因此，为了使学习过程尽可能顺利，我强烈建议你从默认设置开始。
- en: Dependency injection
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'The **SOLID** principles were first introduced by Robert C. Martin, a.k.a.
    Uncle Bob, in the early 2000s. The mnemonic acronym, later coined by Michael Feathers,
    contributed to the principles'' popularity. They describe five concerns at the
    core of good object-oriented design. Although the SOLID principles themselves
    are outside the scope of this book, we will dwell on one of them: dependency inversion.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLID** 原则最早是由罗伯特·C·马丁（Robert C. Martin）在2000年代初提出的，他也被大家亲切地称为“Uncle Bob”。这个记忆助手的缩写后来由迈克尔·费瑟斯（Michael
    Feathers）提出，为这些原则的普及做出了贡献。它们描述了良好面向对象设计的核心五个关注点。尽管**SOLID**原则本身超出了本书的范围，但我们将详细讨论其中一个原则：依赖倒置。'
- en: The dependency inversion principle states that classes and modules should depend
    on abstractions. When a class depends on abstractions, it cannot be responsible
    for creating those dependencies, and they must be injected in the object. That's
    what we refer to as **dependency injection** (**DI**). It greatly increases decoupling
    and composability, and enforces a style of coding where graphs of objects are
    composed at the top of the hierarchy, at or near the application's entry point.
    The application's behavior can then be changed without modifying lots of code,
    just by changing how objects are composed at the application root.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则表明类和模块应该依赖于抽象。当一个类依赖于抽象时，它无法负责创建这些依赖，它们必须被注入到对象中。这就是我们所说的**依赖注入**（**DI**）。它极大地增加了解耦和组合性，并强制执行一种在应用程序顶层或接近应用程序入口点组合对象图的编码风格。这样，应用程序的行为可以通过改变根部对象组合的方式而无需修改大量代码来改变。
- en: However, manual creation of the whole object graph, or Poor Man's DI as Mark
    Seemann calls it, can quickly get tedious. This is where dependency injection
    containers come into play. A DI container, using both conventions and configuration,
    is able to understand how to create graphs of objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动创建整个对象图，或者像Mark Seemann所说的“穷人版DI”，很快就会变得单调。这就是依赖注入容器发挥作用的地方。一个DI容器，利用约定和配置，能够理解如何创建对象图。
- en: 'In Aurelia, almost all objects are provided by a DI container. This container
    has two responsibilities: creating and assembling objects and, afterwards, managing
    their lifetime. One way it can do this is by using metadata attached to the class
    it has to instantiate.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Aurelia中，几乎所有的对象都是由一个DI容器提供的。这个容器有两个责任：创建和组装对象，之后管理它们的生存周期。它可以通过使用附加到它必须实例化的类的元数据来做到这一点。
- en: The inject decorator
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`inject`装饰器'
- en: 'Let''s imagine a `PersonListView` component displaying a list of people. The
    view-model requires a `PersonService` instance, used to retrieve a list of `Person`
    objects:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个显示人员列表的`PersonListView`组件。视图模型需要一个`PersonService`实例，用于检索一个`Person`对象列表：
- en: '`src/person-list-view.js`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/person-list-view.js`'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have a simple view-model, whose constructor expects a `personService`
    parameter. This parameter is then stored on an instance variable, so it can be
    used later. The view-model also has a `getPeople` method, which calls the `getAll`
    method on the `personService` to retrieve the list of people. If you're a familiar
    with object-oriented design and dependency inversion, there's nothing new here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的视图模型，其构造函数期望一个`personService`参数。这个参数然后存储在一个实例变量中，以便稍后使用。视图模型还有一个`getPeople`方法，该方法调用`personService`的`getAll`方法来检索人员列表。如果你熟悉面向对象设计和依赖倒置，这里没有什么新东西。
- en: 'What''s interesting in this code snippet is the `inject` decorator on the `PersonListView`
    class. This decorator is imported from Aurelia and instructs the DI container
    to resolve an instance of `PersonService` and inject it as the constructor''s
    first parameter when creating a new instance of `PersonListView`. The important
    thing here is that the list of dependencies passed to the `inject` decorator matches
    the list of parameters expected by the constructor. If the class has multiple
    dependencies, you must pass them all to `inject` in the proper order:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段中有趣的是`PersonListView`类上的`inject`装饰器。这个装饰器是从Aurelia导入的，指示DI容器在创建`PersonListView`的新实例时，解析一个`PersonService`实例，并将其作为构造函数的第一个参数注入。这里重要的是，传递给`inject`装饰器的依赖项列表与构造函数期望的参数列表一致。如果类有多个依赖项，你必须将它们全部按正确顺序传递给`inject`：
- en: '`src/person-list-view.js`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/person-list-view.js`'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Decorators are an ESNext feature; they are not currently supported by any browser.
    Additionally, Babel does not support them by default, so you need to add the `babel-plugin-transform-decorators-legacy`
    plugin if you want to use them in your code. A project created using the CLI comes
    with this setting already enabled.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是ESNext的一个特性；目前没有任何浏览器支持它们。此外，Babel默认也不支持它们，所以如果你想在你的代码中使用它们，你需要添加`babel-plugin-transform-decorators-legacy`插件。使用CLI创建的项目已经包含了这个设置。
- en: TypeScript and autoinject
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript和autoinject
- en: If you use TypeScript, using the `inject` decorator is pretty redundant when
    you specify the type of every dependency in the constructor declaration. To make
    things easier, Aurelia provides an `autoinject` decorator, which leverages type
    metadata added by the TypeScript transpiler to the transpiled JS classes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用TypeScript，在构造函数声明中指定了每个依赖项的类型时，使用`inject`装饰器是相当冗余的。为了简化事情，Aurelia提供了一个`autoinject`装饰器，它利用了TypeScript转译器添加到转译后的JS类中的类型元数据。
- en: In order to use `autoinject`, you will first need to enable decorators and the
    metadata emission in TypeScript by setting `experimentalDecorators` to `true`
    in your `tsconfig.json` file, and then setting `emitDecoratorMetadata` to `true`
    in the `compilerOptions` section of the same file. A TypeScript project created
    by the CLI comes with these settings already enabled.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`autoinject`，你首先需要在你的`tsconfig.json`文件中将`experimentalDecorators`设置为`true`以启用装饰器和元数据发射，然后在同一文件的`compilerOptions`部分将`emitDecoratorMetadata`设置为`true`。由CLI创建的TypeScript项目已经包含了这些设置。
- en: 'Here''s an example of the same `PersonListView` using TypeScript:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用TypeScript的相同`PersonListView`的示例：
- en: '`src/person-list-view.js`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/person-list-view.js`'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the DI container will know that, in order to create an instance of `PersonListView`,
    it first needs to resolve an instance of `PersonService` and inject it in the
    constructor of `PersonListView`, thanks to the `autoinject` decorator.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，DI容器知道，为了创建一个`PersonListView`实例，它首先需要解析一个`PersonService`实例并在`PersonListView`的构造函数中注入它，这要归功于`autoinject`装饰器。
- en: The static inject method or property
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态inject方法或属性
- en: 'If you aren''t using ESNext decorators nor TypeScript, or don''t want to have
    a dependency on Aurelia inside a given class, you can declare the dependencies
    of a class using a static `inject` method returning those dependencies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用ESNext装饰器也不是TypeScript，或者不想在给定类内部有Aurelia的依赖，你可以使用返回这些依赖的静态`inject`方法声明类的依赖：
- en: '`src/person-list-view.js`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/person-list-view.js`'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The static `inject` method should return an array containing the class' dependencies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`inject`方法应该返回包含类依赖的数组。
- en: Alternatively, a static `inject` property containing the dependency array is
    also supported. This is actually what happens behind the scene when you use the
    `inject` or `autoinject` decorators, they just assign the dependencies to a static
    `inject` property on the class. They are simply syntactic sugar.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以支持包含依赖项数组的静态`inject`属性。实际上，当你使用`inject`或`autoinject`装饰器时，背后发生的就是这件事，它们只是将依赖项分配给类的静态`inject`属性。它们只是语法糖。
- en: Root and child containers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根容器和子容器
- en: In Aurelia, a container can create child containers, which can themselves create
    their own children, forming a tree of containers starting from the application's
    root container. Each child container inherits the services of their parent, but
    can register their own to override their parent's.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Aurelia中，一个容器可以创建子容器，这些子容器又可以创建自己的子容器，从而形成从应用程序的根容器开始的容器树。每个子容器继承其父容器的服务，但可以注册自己的服务以覆盖父容器的服务。
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*,
    an application starts with a root component. It also starts with a root container.
    When evaluating a view, the templating engine will create a child container each
    time it encounters a child component inside the view, may it be a custom element,
    an element with a custom attribute or a view-model created through routing or
    composition. The child component's view-model class will be registered as a singleton
    in the child container, which will then be used to resolve a child component instance.
    As this component's view is loaded and analyzed by the templating engine, the
    process goes on recursively. As the components are composed into a tree, so are
    the containers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](ch01.html "第1章：入门")中看到的，*入门 *，一个应用程序从根组件开始。它也从根容器开始。当评估一个视图时，模板引擎会在每次遇到视图内的子组件时创建一个子容器，无论是自定义元素、具有自定义属性的元素还是通过路由或组合创建的视图模型。子组件的视图模型类将在子容器中注册为单例，然后用于解析子组件实例。随着这个组件的视图被加载和分析，这个过程会递归进行。随着组件被组合成树状结构，容器也是如此。
- en: 'Since child containers are created by the templating engine most of the time,
    it is likely that you will never have to manually create a child container. However,
    here''s an example of how it is done:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子容器通常是由模板引擎创建的，所以你很可能永远不需要手动创建一个子容器。不过，这里有一个例子展示了它是如何完成的：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Resolving an instance
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析实例
- en: Resolution of an instance involves resolvers. We'll come back to those a little
    later to explain in more details how they work and how they are used, but in the
    meantime, think of them as strategies responsible for resolving a class instance
    requested by a DI container.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实例的解析涉及到解析器。我们稍后会回到这部分，详细解释它们是如何工作的以及如何使用，但与此同时，可以先将它们视为负责解析DI容器请求的类实例的策略。
- en: When resolving an instance, the root container first checks if it already has
    a `Resolver` for the class. If it does, this `Resolver` is used to acquire an
    instance. If no `Resolver` is found, the root container will automatically register
    a singleton `Resolver` for the class and use it to acquire an instance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解析实例时，根容器首先检查它是否已经有了一个针对该类的`Resolver`。如果有，这个`Resolver`就被用来获取一个实例。如果没有找到`Resolver`，根容器将自动注册一个单例`Resolver`对该类进行实例获取。
- en: When resolving an instance using a child container, things are a little different.
    The child container still checks if it has a `Resolver` for the class and still
    uses it to acquire an instance if it does. However, if no `Resolver` is found,
    the child container will delegate resolution to its parent container. The parent
    will repeat this process until the instance is resolved or the resolution request
    goes up to the root container. When it does, the root container resolves the instance
    as described previously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子容器解析实例时，情况有点不同。子容器仍然检查它是否有该类的`Resolver`，如果有，则使用它来获取实例。然而，如果没有找到`Resolver`，子容器将委托其父容器进行解析。父容器会重复这个过程，直到实例被解析或解析请求上升到根容器。当它这样做时，根容器按照前述方式解析实例。
- en: That means that instances of classes that are registered on the fly when first
    resolved are application singletons, because they are registered at the root container,
    so every child container will end up resolving to this single instance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当首次解析时动态注册的类的实例是应用单例，因为它们是在根容器中注册的，所以每个子容器最终都会解析为这个单一实例。
- en: 'View-models are resolved by the templating engine using a container, so you''ll
    mostly never have to manually resolve an instance. However, there are scenarios
    where you''ll want to inject a container in an object and manually resolve services.
    Here''s how to do it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型由模板引擎使用容器解析，所以你大多数时候永远不需要手动解析一个实例。然而，有一些场景你可能希望在一个对象中注入一个容器并手动解析服务。以下是这样做的方法：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here the `get` method is called with the `PersonService` class and returns an
    instance of this class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`get` 方法是用 `PersonService` 类调用，并返回这个类的实例。
- en: Lifetime
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'Any object created by a container has a lifetime. There are three typical lifetimes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由容器创建的任何对象都有生命周期。有三种典型的生命周期：
- en: '**Container Singleton**: The container instantiates the class when it is first
    requested and then keeps a reference to that instance. Every other time an instance
    of the class is requested from the container, this same instance is returned.
    This means the instance''s life is tied to the container''s. It won''t be garbage
    collected until the container is discarded and no other object holds a reference
    to the instance.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器单例**：当容器首次请求类时实例化该类，然后保留对该实例的引用。每当从容器中请求该类的实例时，这个相同的实例会被返回。这意味着实例的生命周期与容器的生命周期绑定。它不会被垃圾回收，直到容器被丢弃，且没有其他对象持有对实例的引用。'
- en: '**Application Singleton**: A class registered as an application singleton is
    simply a container singleton registered in the application''s root container,
    so the same instance is reused throughout the whole application.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用单例**：作为应用单例注册的类，其实质是在应用的根容器中注册的一个容器单例，因此整个应用中都会重用同一个实例。'
- en: '**Transient**: When a class is registered as transient, the container will
    create a new instance each time an instance is requested. It will keep no reference
    to any of those instances. The container simply acts as a factory.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态**：当一个类被注册为瞬态时，容器每次请求实例时都会创建一个新的实例。它不会保留对任何这些实例的引用。容器仅仅作为一个工厂。'
- en: Registration
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册
- en: In order to resolve an instance of a class, a container must first learn about
    it. This learning process is called registration. Most of the time, it is performed
    automatically and on the fly by the container when it receives a resolution request.
    It can also be performed manually, using the container's registration API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析一个类的实例，容器首先必须了解它。这个学习过程被称为注册。大多数时候，它是由容器在接收到解析请求时自动且即时执行的。它也可以通过使用容器的注册
    API 手动执行。
- en: The container registration API
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器注册 API
- en: The `Container` class offers multiple methods to manually register a class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Container` 类提供了多种方法用于手动注册一个类。'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method registers a class as a container singleton. The `key` will be used
    for lookup and the `fn` is expected to be the class that will be instantiated.
    If only the `key` is provided, it is expected to be a class because it will be
    used for both lookup and instantiation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将类注册为容器单例。`key` 将在查找时使用，`fn` 预期是要实例化的类。如果只提供 `key`，则预期它是一个类，因为它将用于查找和实例化。
- en: For example, `container.registerSingleton(HttpClient)` registers the `HttpClient`
    class as a singleton. When resolving `HttpClient` for the first time, an instance
    will be created and returned. For each subsequent resolution request for `HttpClient`,
    this single instance will be returned.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`container.registerSingleton(HttpClient)` 将 `HttpClient` 类注册为单例。第一次解析 `HttpClient`
    时，将创建一个实例并返回。对于后续每次解析 `HttpClient` 的请求，都将返回这个单一实例。
- en: Alternatively, `container.registerSingleton(PersonService, CachingPersonService)`
    registers the `CachingPersonService` class using `PersonService` as the key. This
    means that when resolving the `PersonService` class, the single instance of `CachingPersonService`
    will be returned. This mapping is crucial when dealing with abstractions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`container.registerSingleton(PersonService, CachingPersonService)` 使用 `PersonService`
    作为键来注册 `CachingPersonService` 类。这意味着当解析 `PersonService` 类时，将返回 `CachingPersonService`
    的单一实例。这种映射在处理抽象时非常重要。
- en: Of course, the fact that the class is a container singleton or an application
    singleton simply depends on whether the container upon which it is called is the
    application's root container or not.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，类是容器单例还是应用单例，仅仅取决于调用它的容器是否是应用的根容器。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method registers a class as transient, meaning that every time the `key`
    is requested, a new instance of `fn` is created. Just like with `registerSingleton`,
    `fn` can be omitted, in which case the `key` will be used both for lookup and
    instance creation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将类注册为瞬态，意味着每次请求`key`时，都会创建`fn`的新实例。与`registerSingleton`类似，`fn`可以省略，在这种情况下，`key`将用于查找和实例创建。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method registers an existing instance as a singleton. This is useful if
    you already have an instance and want to register it in the container. The only
    difference with `registerSingleton` is that instead of passing the class, you
    pass the actual single instance to use. If only the `key` is provided, it will
    be used both for look up and as the instance, but I can't really see scenarios
    where this would be useful, as you need to already have the value in order to
    look it up.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将现有实例注册为单例。如果你已经有一个实例并希望将其注册到容器中，这很有用。与`registerSingleton`的区别在于，传递的是实际的单例实例，而不是类。如果只提供`key`，它将用于查找和作为实例，但我真的看不到这种情况会有什么用，因为你需要已经拥有值才能查找它。
- en: 'For example, `container.registerInstance(HttpClient, myClient)` registers the
    `myClient` instance for the `HttpClient` class. Each time an `HttpClient` instance
    is requested from the container, the `myClient` instance will be returned:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`container.registerInstance(HttpClient, myClient)` 为 `HttpClient` 类注册 `myClient`
    实例。每次从容器中请求 `HttpClient` 实例时，将返回 `myClient` 实例：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method registers a custom handler, which is a function that will be called
    every time the container is requested for the `key`. This handler function will
    be passed the container, the `key` and the internal `Resolver` storing the handler.
    This allows support for multiple scenarios outside of the standard singleton and
    transient lifetimes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法注册一个自定义处理程序，这是一个每次容器根据`key`请求时将被调用的函数。这个处理函数将传递容器、`key` 和内部存储处理器的 `Resolver`。这支持了超出标准单例和瞬态生命周期的多种场景。
- en: 'For example, `container.registerHandler(PersonService, () => new PersonService(myConfig))`
    registers a factory function. Each time a `PersonService` instance is requested
    from the container, the handler function will be called and will create a new
    instance of `PersonService` using the captured value of `myConfig`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`container.registerHandler(PersonService, () => new PersonService(myConfig))`
    注册了一个工厂函数。每次从容器中请求一个`PersonService`实例时，该处理函数将被调用，并使用捕获的`myConfig`值创建一个新的`PersonService`实例：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method registers a custom `Resolver` instance. Behind the scene, all container
    methods we saw previously use this method with built-in resolvers. It is, however,
    possible to create our own `Resolver` implementation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法注册一个自定义 `Resolver` 实例。在幕后，我们之前看到的所有容器方法都使用这个方法带有内置解析器。然而，创建我们自己的 `Resolver`
    实现也是可能的。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although keys are, most of the time, classes, they can be anything, including
    strings, numbers, symbols, or objects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数时候键是类，但它们可以是任何东西，包括字符串、数字、符号或对象。
- en: Automatic registration
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动注册
- en: 'Automatic registration of a class is handled by the following class method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类的自动注册由以下类方法处理：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method can be called with either a single parameter, being the class to
    register, or with two parameters, the first being the key under which the class
    must be registered and the second being the class to register. When only one parameter
    is passed, the class itself is used as the key.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以带有单一参数，即要注册的类，或者带有两个参数，第一个参数是要注册的类的键，第二个参数是要注册的类。当只有一个参数传递时，类本身被用作键。
- en: The container automatically calls `autoRegister` when it tries resolve an instance
    of a class for which it can't find any resolver. It is rarely used directly by
    the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在尝试解析一个找不到任何解析器的类的实例时，会自动调用`autoRegister`。它很少被应用程序直接使用。
- en: Registration strategies
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册策略
- en: 'The automatic registration process for a given class can be customized by attaching
    a `Registration` strategy to the class'' metadata. This can be done using one
    of the registration decorators:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 给定类的自动注册过程可以通过将`Registration`策略附加到类的元数据来定制。这可以通过使用注册装饰器之一来完成：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the `transient` decorator will tell the `autoRegister` method
    that the `MyModel` class must be registered as transient, so every time a container
    must resolve a `MyModel` instance, it will create a new instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`transient`装饰器将告诉`autoRegister`方法，`MyModel`类必须作为暂态注册，所以每次容器必须解析`MyModel`实例时，它将创建一个新的实例。
- en: 'Alternatively, you can use the `singleton(registerInChild: boolean = false)`
    decorator. When the `registerInChild` argument is `false`, which it is by default,
    this decorator tells the `autoRegister` method that the class should be registered
    as a singleton on the root container. This makes the class an application singleton,
    which is the container''s default behavior anyway, so using `singleton` with `registerInChild`
    set to `false` or left to its default value is kind of useless.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '另外，你可以使用`singleton(registerInChild: boolean = false)`装饰器。当`registerInChild`参数为`false`时，默认就是这样，这个装饰器告诉`autoRegister`方法，这个类应该在根容器上注册为单例。这使得这个类成为应用程序的单例，而这本来就是容器的默认行为，所以将`singleton`与`registerInChild`设置为`false`或让其保持默认值是有点没用的。'
- en: 'However, `singleton` with `registerInChild` set to `true` indicates that the
    class should be registered as singleton, not on the root container, but on the
    actual container on which the `autoRegister` method was called. This allows us
    to decorate a class so that each container has its own instance:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`singleton`中`registerInChild`设置为`true`表示，该类应该作为单例注册，不是在根容器上，而是在实际调用`autoRegister`方法的容器上。这允许我们装饰一个类，使得每个容器都有自己的实例：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, `MyModel` will be registered as a container singleton. Each
    container will have its own instance of it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`MyModel`将被注册为容器单例。每个容器都将有自己的实例。
- en: 'Those two decorators rely behind the scene on `registration(registration: Registration)`.
    This third decorator is used to associate a `Registration` strategy to a class.
    It can be used if you create your own custom `Registration` strategy. It is used
    behind the scene by `transient` and `singleton` to attach one of the built-in
    `Registration` strategies to the class they decorate.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '这两个装饰器背后依赖于`registration(registration: Registration)`。这个第三个装饰器用于将一个`Registration`策略与一个类关联。如果你创建了自己的自定义`Registration`策略，可以使用它。它被`transient`和`singleton`背后使用，将内置的`Registration`策略之一附加到它们装饰的类上。'
- en: Creating a custom registration strategy
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义注册策略
- en: 'A registration strategy must implement the following method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注册策略必须实现以下方法：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, the `autoRegister` method registers the class passed to it as an
    application singleton. However, when called for, a class having a `Registration`
    strategy attached to its metadata, `autoRegister` will delegate the class' registration
    to the `Registration`'s `registerResolver` method, which is expected to create
    a `Resolver` for the class, to register it in the container, and to return it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`autoRegister`方法将传递给它的类注册为应用程序单例。然而，当被调用时，拥有附加到其元数据的`Registration`策略的类，`autoRegister`将委托该类的注册到`Registration`的`registerResolver`方法，该方法预期为该类创建一个`Resolver`，将其注册到容器中，并返回它。
- en: 'Typically, a `registerResolver` method implementation will use the registration
    API of the `Container` instance passed as parameter to register the class. For
    example, the `registerResolver` method of the built-in `TransientRegistration`
    class, which is used behind the scene by the `transient` decorator, looks like
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`registerResolver`方法实现将使用作为参数传递的`Container`实例的注册API来注册类。例如，内置的`TransientRegistration`类`registerResolver`方法，它被`transient`装饰器在幕后使用，看起来像这样：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the method calls the container's `registerTransient` method, which creates
    a transient `Resolver`, and returns it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，该方法调用容器的`registerTransient`方法，该方法创建一个瞬态`Resolver`，并返回它。
- en: Resolvers
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析器
- en: We previously defined `Resolver` as strategies responsible for resolving instances.
    A container, when stripped to the bare minimum, simply manages a `Map` correlating
    `key` with their respective `Resolver`, which are created either by `Registration`
    strategies or by container registration methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义了`Resolver`作为负责解析实例的策略。当容器简化为最基本的形式时，它仅仅管理一个将`key`与相应的`Resolver`相关联的`Map`，这些`Resolver`是通过`Registration`策略或容器注册方法创建的。
- en: 'Additionally to being used when registering a service, resolvers can also be
    used when declaring a dependency: the `inject` decorator, so incidentally the
    `inject` static method or property, can be passed as `Resolver` instead of `key`.
    Like we saw earlier, during resolution of a `key` dependency, the container or
    one of its ancestors will find the `Resolver` for the key, or the root container
    will auto-register a singleton `Resolver`, and this `Resolver` will be used to
    resolve an instance. But when resolving a `Resolver` dependency, the container
    will directly use this `Resolver` to resolve an instance. This allows us to override
    a given class'' registered resolution strategy in the context of a specific injection.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在注册服务时使用解析器之外，解析器还可以在声明依赖时使用：`inject`装饰器，因此顺便说一下，`inject`静态方法或属性，可以作为`Resolver`而不是`key`传递。正如我们之前所见，在解析`key`依赖时，容器或其一个祖先将找到该`key`的`Resolver`，或者根容器将自动注册一个单例`Resolver`，这个`Resolver`将用于解析一个实例。但是，当解析一个`Resolver`依赖时，容器将直接使用这个`Resolver`来解析一个实例。这允许我们在特定注入的上下文中覆盖给定类注册的解析策略。
- en: There are typically six resolvers that are useful during injection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在注入时有用的大约有六个解析器。
- en: Lazy
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒惰
- en: 'The `Lazy` resolver injects a function that, when evaluated, lazily resolves
    the dependency:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lazy`解析器注入一个函数，当评估时，延迟解析依赖项：'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means that resolution of `PersonService` is not performed during the creation
    of the instance, but rather when the `personServiceAccessor` function is called.
    This can be useful if the resolution needs to be delegated to a later time rather
    than when creating the object, or when the resolution must be re-evaluated multiple
    time during the object's lifetime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在实例创建时不会解析`PersonService`，而是在调用`personServiceAccessor`函数时解析。如果解析需要在创建对象之后而不是创建对象时进行委托，或者在对象生命周期内必须重新评估多次解析，这可能很有用。
- en: All
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全部
- en: 'By default, the `Container` resolves to the first instance matching the requested
    key. The `All` resolver allows us to inject an array containing all the services
    registered for a given key:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Container`解析为与请求键匹配的第一个实例。`All`解析器允许我们注入一个包含给定键注册的所有服务的数组：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we can imagine that multiple objects or classes have been registered using
    the `PersonValidator` key, and they are all injected as an array in the `PersonForm`
    view-model.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以想象多个对象或类已经使用`PersonValidator`键进行了注册，并且它们都被作为数组注入到`PersonForm`视图模型中。
- en: Optional
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选
- en: The `Optional` resolver injects an instance only if a given key is already registered.
    If not, instead of auto-registering it, it will inject `null`. The second parameter,
    when omitted or set to `true`, makes the lookup for a resolver go up the container
    hierarchy. If set to `false`, only the current container will be checked.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`解析器只有在给定键已经注册时才注入实例。如果没有，它不会自动注册，而是注入`null`。第二个参数省略或设置为`true`时，使查找解析器上升到容器层次结构。如果设置为`false`，则只检查当前容器。'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, an instance of `PersonService` is injected in the `PersonListView` constructor
    only if it was already registered in the current container. If not, `null` is
    injected instead.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有在当前容器中已经注册了`PersonService`实例时，才在`PersonListView`构造函数中注入`PersonService`的一个实例。如果没有，则注入`null`。
- en: Parent
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父级
- en: 'The `Parent` resolver skips the current container and starts the resolution
    at the parent container. If the current container is the root container, `null`
    is injected instead:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parent`解析器跳过当前容器，从父容器开始解析。如果当前容器是根容器，则注入`null`：'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Factory
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂
- en: 'The `Factory` resolver injects a factory function. Each time the factory function
    is executed, it will request a new instance from the container. Additionally,
    any parameters passed to this factory function will be passed to the class constructor
    by the container. If the class has dependencies, declared using any `inject` strategy,
    the additional parameters will be appended to the resolved dependencies when passed
    to the constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Factory`解析器注入一个工厂函数。每次执行工厂函数时，它将请求容器中的新实例。此外，传递给这个工厂函数的任何参数都将由容器传递给类构造函数。如果类有依赖项，使用任何`inject`策略声明，额外的参数将在解析的依赖项传递到构造函数时附加：'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we first see a `Person` class decorated with `inject`, which
    suggests to the container that its constructor needs an `AddressService` instance
    as its first parameter. We can also see that the constructor actually expects
    a second parameter called `address`, which the container knows nothing about.
    Next, we have a `PersonListView` class, decorated in such a way that a `Person`
    factory gets injected in its constructor. Its `createPerson` method, which is
    passed an `address`, calls the `Person` factory function with this address.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先看到一个`Person`类被`inject`装饰器修饰，这暗示容器其构造函数需要一个`AddressService`实例作为第一个参数。我们也可以看到，构造函数实际上期望一个名为`address`的第二个参数，容器对此一无所知。接下来，我们有一个`PersonListView`类，以一种`Person`工厂在其构造函数中被注入的方式被装饰。其`createPerson`方法，传入一个`address`，用这个地址调用`Person`工厂函数。
- en: When called, in order to create an instance of `Person`, the container will
    first resolve an instance of `AddressService` to fulfill the `Person` dependencies,
    and will then call the `Person` constructor with the resolved `AddressService`
    instance and the `address` passed to the factory function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，为了创建一个`Person`实例，容器将首先解析一个`AddressService`实例来满足`Person`的依赖关系，然后用解析的`AddressService`实例和传递给工厂函数的`address`调用`Person`构造函数。
- en: NewInstance
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新实例
- en: The `NewInstance` resolver makes the container inject a new instance of the
    class each time, completely ignoring any existing registration for the class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewInstance`解析器让容器在每次注入时创建类的全新实例，完全忽略类任何现有的注册。'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The plugin system
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件系统
- en: Now that we have a good understanding of how dependency injection works in Aurelia,
    we can start using it. Apart from being used for components creation and composition
    using `inject` and `Resolver`s, dependency injection is also central to Aurelia's
    plugin system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对Aurelia中依赖注入的工作原理有了很好的理解，我们就可以开始使用它了。除了用于使用`inject`和`Resolver`创建和组合组件外，依赖注入还是Aurelia插件系统的核心。
- en: Plugins
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件
- en: Almost every part of Aurelia comes as a plugin. In fact, the `aurelia-framework`
    library is just a plugin system and configuration mechanism, and every other Aurelia
    core library comes and plugs in this mechanism.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎Aurelia的每一个部分都是以插件的形式出现的。事实上，`aurelia-framework`库只是一个插件系统和配置机制，Aurelia的其他核心库都是以这种方式plugged
    into this mechanism。
- en: An Aurelia plugin starts with an `index.js` file, which must export a `configure`
    function. This function will be called by Aurelia upon start up and will receive
    an Aurelia configuration object as its first parameter and an optional configuration
    callback function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Aurelia插件从`index.js`文件开始，这个文件必须导出一个`configure`函数。这个函数将在Aurelia启动时被调用，并接收一个Aurelia配置对象作为其第一个参数和一个可选的配置回调函数。
- en: An example
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个示例
- en: 'Let''s imagine a plugin named `our-plugin`. This plugin would first need to
    be enabled in the `configure` function of our `main.js` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个名为`our-plugin`的插件。这个插件首先需要在我们的`main.js`文件中的`configure`函数中启用：
- en: '**src/main.js**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**src/main.js**'
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, additionally to the standard application configuration, we tell Aurelia
    to load `our-plugin`. We also tell Aurelia to configure `our-plugin` using the
    callback provided as the second parameter of the `plugin` function. This callback
    receives a configuration object defined by `our-plugin` and we set its `debug`
    property to `true`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，除了标准的应用程序配置外，我们还告诉Aurelia加载`our-plugin`。我们还告诉Aurelia使用作为`plugin`函数第二个参数提供的回调来配置`our-plugin`。这个回调接收到由`our-plugin`定义的配置对象，我们将其`debug`属性设置为`true`。
- en: 'Let''s now imagine our plugin''s `index.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下我们插件的`index.js`文件：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we could first create a default configuration object for our plugin and,
    if a configuration callback was provided, we would call it with our configuration,
    giving the user of our plugin the opportunity to change it. Then we could register
    our configuration object as the single instance of the `OurPluginConfig` class.
    We can then imagine that services exposed by `our-plugin` would have a dependency
    on this `OurPluginConfig`, so when they are instantiated by the container, they
    would have injected the configuration object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先可以为我们的插件创建一个默认配置对象，如果提供了配置回调，我们将用我们的配置调用它，给插件的使用者机会更改它。然后我们可以将我们的配置对象注册为`OurPluginConfig`类的唯一实例。然后我们可以想象，由`our-plugin`暴露的服务会有这个`OurPluginConfig`的依赖，所以当它们由容器实例化时，它们会注入配置对象。
- en: Registering global resources
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册全局资源
- en: 'Using this `configure` function, any plugin can register its own services,
    or even alter or override services declared by other plugins. It can also register
    resources for the templating engine:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`configure`函数，任何插件都可以注册自己的服务，甚至更改或覆盖其他插件声明的服务。它还可以为模板引擎注册资源：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, a plugin registers a resource named `my-component`. This resource may
    be different things; we will cover templating resources in the next chapters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个插件注册了一个名为`my-component`的资源。这个资源可能有很多不同的事物；我们将在下一章节中覆盖模板资源。
- en: Features
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性
- en: Plugins are a great way to structure and decouple code. But plugins sit as project
    dependencies, with external libraries. For example, when using the CLI, plugins
    sit in the `node_modules` directory. In a typical project, the code sitting there
    is not version controlled. This code must not be modified as part of the project.
    It doesn't actually belong with the project; it is managed by someone else or,
    at least, in a distinct project workflow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是组织和解除代码耦合的好方法。但是插件作为项目依赖存在于外部库中。例如，在使用CLI时，插件位于`node_modules`目录中。在典型项目中，那里的代码不受版本控制。这部分代码不应作为项目的一部分进行修改。实际上它不属于项目；它由其他人管理，或者至少在一个不同的项目工作流中。
- en: But what if we would like to structure our own application like this? Using
    the plugin mechanism makes this pretty complicated, because we need to consider
    our different plugins as separate projects, and package them individually, then
    install them on our application. Each time a change is required in one of the
    plugins, it needs to be changed individually, then released and its dependency
    updated in the application. Although it's sometimes useful to share common components
    or behaviors used in multiple projects, this workflow is more complicated and
    adds a burden on the development process when not necessary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要像这样结构自己的应用程序怎么办呢？使用插件机制会使这变得相当复杂，因为我们需要将不同的插件视为不同的项目，并单独打包它们，然后在应用程序中安装它们。每次需要更改插件中的任何一个时，都需要单独进行更改，然后发布并更新应用程序中的依赖关系。尽管有时共享在多个项目中使用的通用组件或行为很有用，但这种工作流程在非必要时增加了开发过程的复杂性。
- en: 'Fortunately, Aurelia has a solution for this, features. A feature works exactly
    like a plugin, but it is located inside the application. Let''s see an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Aurelia有一个解决方案，即特性。特性与插件完全一样工作，但它位于应用程序内部。让我们看一个例子：
- en: '`src/my-feature/index.js`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/my-feature/index.js`'
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**src/main.js**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**src/main.js**'
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Features work the exact same way plugins do, except that we use the `feature`
    method instead of the `plugin` method to load them and that they sit inside the
    `src` directory. Like a plugin, a feature is expected to have an `index.js` file
    at its root, which should export a `configure` function. Like a plugin, it can
    be passed a configuration callback as the second parameter of the `feature` method,
    and this callback will be passed to the `configure` function of `feature`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 特性工作方式和插件完全一样，不同之处在于我们使用`feature`方法而不是`plugin`方法来加载它们，并且它们位于`src`目录内。像插件一样，特性预期在其根目录下有一个`index.js`文件，该文件应导出一个`configure`函数。像插件一样，它可以传递一个配置回调作为`feature`方法的第二个参数，这个回调将传递给特性的`configure`函数。
- en: The `feature` method expects the relative path to the directory containing the
    feature's `index.js` file. For example, if my feature sits at `src/some/path/index.js`,
    the call to load it would be `feature('some/path')`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`feature`方法期望相对路径到包含`index.js`文件的目录。例如，如果我的特性位于`src/some/path/index.js`，加载它的调用将是`feature(''some/path'')`。'
- en: Features are a great way to organize your code. They make it easier to break
    down what could be a huge, monolithic application into a well-designed set of
    modules. Of course, it all depends on the design skills of the development team.
    In [Chapter 6](ch06.html "Chapter 6. Design Concerns - Organizing and Decoupling"),
    *Design Concerns - Organizing and Decoupling*, we will go over some patterns,
    strategies and ways to organize code to build better Aurelia applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 特性是组织代码的好方法。它们使你更容易将可能是一个巨大、单块的应用程序分解成一系列设计良好的模块。当然，这都取决于开发团队的设计技能。在[第6章](ch06.html
    "第6章。设计关注 - 组织和解耦")，*设计关注 - 组织和解耦*，我们将介绍一些模式、策略和组织代码的方法，以构建更好的Aurelia应用程序。
- en: Logging
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Aurelia comes with a simple yet powerful logging system. It supports log levels
    and pluggable appenders.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia带有一个简单而强大的日志系统。它支持日志级别和可插拔的附加器。
- en: Configuration
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'To configure logging, at least one log appender must be added:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置日志，至少必须添加一个日志附加器：
- en: '**src/main.js**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`**src/main.js**`'
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, an instance of the `ConsoleAppender`, imported from the `aurelia-logging-console`
    library, is first added to the logging module. This appender simply outputs the
    logs to the browser's console.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先向日志模块添加了`ConsoleAppender`实例，该实例从`aurelia-logging-console`库导入。这个附加器简单地将日志输出到浏览器的控制台。
- en: At least one appender must be added for logging to work. If no appender is added,
    the logs will simply be discarded.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使日志工作，至少必须添加一个附加器。如果没有添加附加器，日志将被简单丢弃。
- en: 'Next, the log level is set to `info`. This means that all logs with a lower
    level won''t be dispatched to the appenders. Aurelia supports four log levels,
    from lowest to highest: `debug`, `info`, `warn`, and `error`. For example, setting
    the minimal log level to `warn` means that `debug` and `info` logs will be ignored.
    Additionally, a `none` log level is available. When set, it simply performs no
    filtering at all and dispatches all logs to the appenders.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，日志级别被设置为`info`。这意味着所有较低级别的日志不会被分发到附加器。Aurelia支持四个日志级别，从最低到最高：`debug`、`info`、`warn`和`error`。例如，将最小日志级别设置为`warn`意味着`debug`和`info`日志将被忽略。此外，还有一个`none`日志级别可用。当设置时，它简单地执行没有任何过滤，并将所有日志分发到附加器。
- en: Default configuration
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认配置
- en: 'The previous example was intended to show a fully customized setup. Instead,
    you can use the `developmentLogging` method when configuring your application:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例旨在展示一个完全自定义的设置。相反，你可以在配置应用程序时使用`developmentLogging`方法：
- en: '`**src/main.js**`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`**src/main.js**`'
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This default configuration installs the `ConsoleAppender` and sets the log level
    to `none`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个默认配置安装了`ConsoleAppender`，并将日志级别设置为`none`。
- en: An appender
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加器
- en: 'Appenders must implement a simple interface, with one method for each log level.
    For example, here is Aurelia''s `ConsoleAppender` implementation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 附加器必须实现一个简单的接口，每个日志级别有一个方法。例如，以下是Aurelia的`ConsoleAppender`实现：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, each method receives first the logger that initiated the log,
    followed by the arguments passed to the logger's logging method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个方法首先接收初始化日志的日志器，然后是传递给日志器的日志方法的参数。
- en: Writing logs
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写日志
- en: 'To write logs, you first need to acquire a logger:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写日志，你首先需要获取一个日志器：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `getLogger` method expects the name of the logger, and returns the logger
    instance. If no logger exists for the provided name, a new one is created. Loggers
    are singletons, so the same instance is always returned for a given name.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLogger`方法期望日志器的名称，并返回日志器实例。如果为提供的名称不存在日志器，则会创建一个新的。日志器是单例，所以对于给定的名称始终返回相同的实例。'
- en: 'Once you have a logger instance, you can call one of its four logging methods:
    `debug()`, `info()`, `warn()`, or `error()`. Each of these methods will dispatch
    a call to the corresponding level method on all appenders, assuming the method''s
    log level is equal or greater than the configured minimum log level. Otherwise,
    the appenders are not called and the log is discarded.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个日志器实例，你可以调用它的四个日志方法之一：`debug()`、`info()`、`warn()`或`error()`。每个这些方法都将调用所有附加器的相应级别方法，假设方法日志级别等于或高于配置的最小日志级别。否则，附加器不会被调用，日志将被丢弃。
- en: The logger methods can be passed any number of arguments, and these arguments
    will be dispatched to the appenders. For example, when calling `error('A message',
    12)` on the logger, the call will be delegated to the appenders' as `appender.error`(`logger,
    'A message', 12)`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 日志器方法可以传递任意数量的参数，这些参数将被分发到附加器。例如，当在日志器上调用`error('A message', 12)`时，调用将被委派给附加器的`appender.error`(`logger,
    'A message', 12)`。
- en: 'By default, all loggers are configured with the global log level. However,
    loggers also have a `setLevel` method, which allows to set a different log level
    for a single logger:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有日志记录器都使用全局日志级别进行配置。然而，日志记录器还具有一个`setLevel`方法，允许为单个日志记录器设置不同的日志级别：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Routing
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Except for really simple cases, a typical single-page application is made of
    multiple views. Most of the time, such an application has some fixed, global layout
    comprising a variable area that displays the current view and a menu that allows
    the user to navigate from one view to another. In Aurelia, those features are
    supported by the router plugin.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非常简单的情况外，一个典型的单页应用程序通常由多个视图组成。大多数时候，这样的应用程序有一个固定的全局布局，包括一个显示当前视图的可变区域和一个允许用户从一个视图导航到另一个视图的菜单。在Aurelia中，这些功能由路由器插件支持。
- en: Configuring the router
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置路由器
- en: To enable routing, make sure your application depends on the `aurelia-router`
    and the `aurelia-templating-router` libraries as CLI-based projects do by default.
    Then load the router plugin in the `configure` function of your `main.js` file,
    by either loading the whole `standardConfiguration()`, which includes the router,
    or by loading the `router()`individually. See [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*, for more information about how to load plugins in
    the application `configure` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用路由，请确保您的应用程序依赖于`aurelia-router`和`aurelia-templating-router`库，就像基于CLI的项目那样默认依赖。然后在你`main.js`文件的`configure`函数中加载路由插件，
    either by loading the whole `standardConfiguration()`, which includes the router,
    or by loading the `router()`individually. 有关如何在应用程序`configure`函数中加载插件的更多信息，请参阅[第1章](ch01.html
    "Chapter 1. Getting Started")，*入门*。
- en: Declaring routes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明路由
- en: 'We will start by adding a `configureRouter` method to our root component. When
    Aurelia detects this callback method on a component, it calls it as part of the
    component initialization cycle. This method receives two parameters: a router
    configuration object and the router itself:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向我们的根组件添加一个`configureRouter`方法开始。当Aurelia检测到组件上的这个回调方法时，它会在组件初始化周期中调用它。这个方法接收两个参数：一个路由配置对象和路由本身：
- en: '`src/app.js`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `configureRouter` method, we start by assigning the router to an instance
    variable. This is important, because our root component's view will need to access
    the router to render the menu and the active route component.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`configureRouter`方法中，我们首先将路由器分配给一个实例变量。这很重要，因为我们的根组件的视图需要访问路由器以渲染菜单和活动路由组件。
- en: Once this is done, we set the global title. This value will be displayed in
    the browser's title bar.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们设置全局标题。这个值将显示在浏览器标题栏中。
- en: 'Next, we configure two routes using the `map` method. A route configuration
    is basically a mapping between a URL path pattern which, when matched, causes
    the route to be activated, and a component, which is displayed when the route
    is activated. It also contains other properties. Let''s decompose a route configuration:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`map`方法配置两个路由。路由配置基本上是将一个URL路径模式与一个组件的映射，当路径匹配时激活路由，并在路由激活时显示组件。它还包含其他属性。让我们分解一个路由配置：
- en: 'The `route` property is the URL path pattern. It is important to notice that
    the patterns omit the path''s leading slash. There are three types of patterns:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`属性是URL路径模式。重要的是要注意，这些模式省略了路径的前斜杠。有三种类型的模式：'
- en: '**Static routes**: The pattern matches the path exactly. The first pattern
    of our first route is an example of this: it matches the root path (`/`) which,
    since the leading slash is omitted, matches an empty string. This makes it the
    default route.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态路由**：该模式完全匹配路径。我们第一个路由的第一个模式是这种模式的例子：它匹配根路径（`/`），由于省略了前斜杠，它匹配空字符串。这使得它成为默认路由。'
- en: '**Parameterized routes**: The pattern matches the path exactly, and the parts
    of the path matching the placeholders, prefixed by a colon (`:`), are parsed as
    route parameters. The value of those parameters are made available to the route
    component as part of the screen activation life cycle. The pattern of our second
    route is an example of this: it matches paths starting with `/contacts/`, followed
    by a second part interpreted as the contact''s `id`.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数化路由**：该模式完全匹配路径，并且与占位符匹配的路径部分（前缀为冒号`:`）被解析为路由参数。这些参数的值在屏幕激活生命周期中作为路由组件的一部分提供。我们第二个路由的模式是这种模式的例子：它匹配以`/contacts/`开头的路径，后跟第二个部分，被解释为联系人的`id`。'
- en: Note
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Additionally, a route parameter can be made optional by adding a trailing question
    mark to it. For example, the `contacts/:id?/details` pattern would be matched
    by both `/contacts/12/details` and `/contacts/details`. When the parameter is
    omitted in the path, the corresponding parameter passed to the route component
    will be `undefined`.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，可以通过在参数后添加一个问号使其成为可选参数。 例如，`contacts/:id?/details` 模式将匹配 `/contacts/12/details`
    和 `/contacts/details` 两者。 当在路径中省略参数时，传递给路由组件的相应参数将是 `undefined`。
- en: '**Wildcard routes**: The pattern matches the beginning of the path, and the
    rest of the path is considered a single parameter, whose value is made available
    to the route component as part of the screen activation life cycle. For example,
    the `my-route*param` pattern will match any path starting with `/my-route` and
    `param` will be a parameter whose value is the rest of the matched path.'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通配符路由**：该模式匹配路径的开始部分，路径的其余部分被视为一个单一参数，其值在屏幕激活生命周期中作为路由组件的一部分提供。 例如，`my-route*param`
    模式将匹配任何以 `/my-route` 开头的路径，`param` 将是 一个参数，其值是匹配到的路径的其余部分。'
- en: The `name` property uniquely identifies the route. We will see later how to
    use it to generate the URL of the route.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 属性唯一标识路由。 我们稍后可以看到如何使用它来生成路由的 URL。'
- en: The `moduleId` property is the path of the route component.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleId` 属性是路由组件的路径。'
- en: The `nav` property, when set to a `true` value, tells the router to include
    this route in its navigation model, which is used to automatically build the application's
    navigation menu. Additionally, if `nav` is a number, the router will use it to
    sort the items in the navigation menu.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nav` 属性，当设置为 `true` 值时，告诉路由器将此路由包含在其导航模型中，该模型用于自动构建应用程序的导航菜单。另外，如果 `nav` 是一个数字，则路由器将使用它来对导航菜单中的项目进行排序。'
- en: The `title` property will be displayed in the browser's title bar when this
    route is active, unless the component overrides it. It is also used as the text
    of the menu item for the route if `nav` is `true`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title` 属性在路由活动时将显示在浏览器标题栏中，除非组件覆盖它。 如果 `nav` 是 `true`，它也用作路由的菜单项文本。'
- en: The `settings` property is optional, and can contain arbitrary data that can
    be used by activated components or pipeline steps, which we'll see later in this
    chapter.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settings` 属性是可选的，可以包含激活组件或管道步骤可以使用任意数据，我们将在本章后面看到。'
- en: Redirection route
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重定向路由
- en: 'Instead of a `moduleId`, a route can declare a `redirect` property. When such
    a route is activated, the router will perform an internal redirection to the path
    represented by the value of this property. This allows an alternative to the multiple
    patterns technique to declare a default route, as illustrated by our first route.
    Instead, we could declare the following routes:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 代替 `moduleId`，路由可以声明一个 `redirect` 属性。 当这样的路由被激活时，路由器将执行内部重定向到代表该属性值的路径。 这允许用多个模式技术声明默认路由的替代方法，正如我们第一个路由所展示的那样。
    相反，我们可以声明以下路由：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The main difference with this configuration is that, when accessing `/`, the
    URL in the browser address bar will change to `/contacts`, because the router
    will perform a redirection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个配置的主要区别是，当访问 `/` 时，浏览器地址栏中的 URL 将更改为 `/contacts`，因为路由器将执行重定向。
- en: When using this pattern, the `nav` property should be made `true` only on the
    target route. If it is set on the redirection route and not the target route,
    the router won't be able to highlight the corresponding menu item because the
    route is technically activated for just a brief moment before the target route
    is in turn activated. Finally, making it `true` on both the redirection route
    and its target route would cause both to be rendered in the menu, which is kind
    of pointless, because they both lead to the same place.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式时，`nav` 属性应该只在目标路由上设置为 `true`。 如果它在重定向路由上设置而不是目标路由，那么路由器将无法突出显示相应的菜单项，因为该路由在目标路由激活之前仅短暂激活片刻。
    最后，在重定向路由及其目标路由上都设置为 `true` 会导致两者都在菜单中渲染，这是没有意义的，因为它们都通向同一个地方。
- en: If the `nav` property is `false`, then setting the `title` is also pointless,
    since the route never stays activated long enough for the title to be visible.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `nav` 属性是 `false`，那么设置 `title` 也是没有意义的，因为该路由从未激活足够长的时间以至于标题可见。
- en: However, setting a `name` on a redirection route may be useful. When a redirection
    is expected to change in the future, links can be generated using the redirection
    route's `name` instead of the target route's. This way, the route's `redirect`
    property is the only thing that needs to change and every link that depends on
    this route will follow.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为重定向路由设置`name`可能是有用的。当重定向预期在未来会改变时，可以使用重定向路由的`name`来生成链接，而不是目标路由的。这样，路由的`redirect`属性是唯一需要改变的东西，依赖于这个路由的每一个链接都会随之改变。
- en: Navigation strategies
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航策略
- en: 'Alternatively to the `moduleId` and `redirect` properties, a route can have
    a `navigationStrategy` property. Its value must be a function that will be called
    by the router and passed a `NavigationInstruction` instance. This object can then
    be configured dynamically. For example, our last route could be configured like
    this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`moduleId`和`redirect`属性之外，路由还可以有一个`navigationStrategy`属性。其值必须是一个函数，该函数将由路由器调用，并传递一个`NavigationInstruction`实例。然后可以动态地配置这个对象。例如，我们的最后一个路由可以配置成这样：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the end, this route does the same thing as it did before. But for scenarios
    requiring more flexibility than `moduleId` and `redirect` can offer, this alternative
    can become handy, as a `NavigationInstruction` instance contains the following
    properties:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个路由做的和之前一样。但对于需要比`moduleId`和`redirect`更灵活的场景，这个替代方案可以变得很有用，因为`NavigationInstruction`实例包含以下属性：
- en: '`config`: The configuration object of the route being navigated to'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：正在导航到的路由的配置对象'
- en: '`fragment`: The URL path that triggered the navigation'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fragment`：触发导航的URL路径'
- en: '`params`: An object containing a property for each parameter extracted from
    the route pattern'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：包含从路由模式中提取的每个参数的对象'
- en: '`parentInstruction`: The instruction of the parent router, if this router is
    a child router'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parentInstruction`：如果这个路由是一个子路由，则是指令父路由的指令'
- en: '`plan`: The navigation plan, built and used internally by the router to perform
    navigation'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plan`：由路由器内部构建并使用以执行导航的导航计划'
- en: '`previousInstruction`: The navigation instruction which the current instruction
    will replace in the router'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previousInstruction`：当前指令将在路由器中替换的导航指令'
- en: '`queryParams`: An object containing the values parsed from the query string'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryParams`：包含从查询字符串解析出的值的对象'
- en: '`queryString`: The raw query string'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryString`：原始查询字符串'
- en: '`viewPortInstructions`: The viewport instructions, built and used internally
    by the router to perform navigation'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewPortInstructions`：视口指令，由路由器内部构建并使用以执行导航'
- en: Laying out our application
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局我们的应用程序
- en: Based on its routes configuration, the router generates a navigation model that
    can be used to automatically generate a navigation menu. Thanks to this, when
    adding new routes, we don't have to change both the route's configuration and
    the menu view.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 基于其路由配置，路由器生成一个导航模型，可以用来自动生成导航菜单。因此，当添加新路由时，我们不需要改变路由的配置和菜单视图。
- en: 'Since our root component''s view-model is the one responsible for declaring
    the routes, it just makes sense for its view to be the global layout and render
    the navigation menu. Let''s use this navigation model and create our root component''s
    view:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们根组件的视图模型负责声明路由，它的视图应该是全局布局并渲染导航菜单。让我们使用这个导航模型来创建根组件的视图：
- en: '`src/app.html`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.html`'
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The interesting parts in this template are highlighted. Let's go over them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板中突出显示的部分是最有趣的部分。让我们来看一下。
- en: The first thing to notice is that we require a file named `app.css`, which we
    will write in a moment. This file will style our app component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们需要一个名为`app.css`的文件，我们将在一会儿写它。这个文件将样式化我们的应用程序组件。
- en: Next, the view uses the `router` property, defined in the `configureRouter`
    method of our root component's view-model. We first see it inside the `a` tag
    with the `nav-brand` class, where a string interpolation instruction renders the
    document title.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，视图使用了`router`属性，该属性定义在我们根组件的视图模型的`configureRouter`方法中。我们首先在带有`nav-brand`类的`a`标签中看到它，其中字符串插值指令渲染文档标题。
- en: Then, we find a `repeat.for="row of router.navigation"` attribute on a `li`
    tag. This binding instruction repeats the `li` tag for each item in the `router.navigation`
    array. This `navigation` property contains the router's navigation model, built
    using the route's truthy `nav` property. When rendering each `li` tag, a `row`
    variable containing the current navigation model item is available in the template
    engine's binding context.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`li`标签上发现了一个`repeat.for="row of router.navigation"`属性。这个绑定指令为`router.navigation`数组中的每个项目重复`li`标签。这个`navigation`属性包含了路由器的导航模型，该模型是用路由的truthy
    `nav`属性构建的。在渲染每个`li`标签时，模板引擎的绑定上下文中都有一个包含当前导航模型项的`row`变量。
- en: 'The `li` tag additionally has a `class="${row.isActive ? ''active'' : ''''}"`
    attribute. This string interpolation instruction uses the current navigation model
    item''s `isActive` property. It assigns an `active` CSS class to the `li` tag
    if `isActive` evaluates to a `true` value. This property is managed by the router
    and is `true` only if the navigation model item belongs to the active route. In
    this template, it is used to highlight the active menu item.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`li`标签还有一个`class="${row.isActive ? ''active'' : ''''}"`属性。这个字符串插值指令使用当前导航模型项的`isActive`属性。如果`isActive`评估为`true`值，它就会给`li`标签分配一个`active`
    CSS类。这个属性由路由器管理，仅当导航模型项属于活动路由时才是`true`。在这个模板中，它用来突出显示活动菜单项。'
- en: The anchor inside the `li` tag has a `href.bind="row.href"` attribute. This
    instruction binds the tag's `href` attribute to the `href` property of the current
    navigation model item. This `href` property is built by the router using the route's
    path pattern. Additionally, inside the anchor, the route's `title` is rendered.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`li`标签内的锚点有一个`href.bind="row.href"`属性。这个指令将标签的`href`属性绑定到当前导航模型项的`href`属性。这个`href`属性是由路由器使用路由的路径模式构建的。此外，在锚点内部，还渲染了路由的`title`。'
- en: Towards the end of the menu, we can see a `li` tag with a `loader` CSS class.
    This element contains a spinner icon. It has an `if.bind="router.isNavigating"`
    attribute, which binds the presence of this element in the DOM with the value
    of the router's `isNavigating` property. This means that when the router is performing
    a navigation, a spinner icon will be visible in the top right corner of the application.
    When no navigation is occurring, the icon is not only invisible, it is actually
    not even present in the DOM, thanks to the `if` attribute.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜单的末尾，我们可以看到一个带有`loader` CSS类的`li`标签。这个元素包含一个旋转图标。它有一个`if.bind="router.isNavigating"`属性，它将这个元素在DOM中的存在与路由器的`isNavigating`属性的值绑定在一起。这意味着当路由器执行导航时，顶部的右角将显示一个旋转图标。当没有导航发生时，这个图标不仅不可见，实际上甚至根本不在DOM中，感谢`if`属性。
- en: Lastly, the `router-view` element acts as the router viewport and displays the
    active route component. This is the only required part in this whole template.
    When a component configures a router, its view must contain a `router-view` element,
    otherwise an error will be thrown. Exploiting the navigation model is optional,
    a menu can be static, or built by any other means you can imagine. Displaying
    the title is also optional. Leveraging the `isNavigating` indicator is absolutely
    not mandatory. However having a component configure a router is completely pointless
    if its view cannot display the active route component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`router-view`元素作为路由视图port，显示活动路由组件。这是整个模板中唯一必需的部分。当一个组件配置路由器时，其视图必须包含一个`router-view`元素，否则将抛出错误。利用导航模型是可选的，菜单可以是静态的，或者通过任何你能想象到的其他方式构建。显示标题也是可选的。利用`isNavigating`指示器绝对是完全不必要的。然而，如果一个组件配置了路由器，而它的视图却不能显示活动路由组件，那么这个组件配置路由器就是毫无意义的。
- en: 'This view uses a structure that you may be familiar with if you''ve ever worked
    with Bootstrap. Bootstrap is a CSS framework developed by Twitter, and we will
    use it in our application. Let''s install it:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图使用了一种结构，如果你曾经使用过Bootstrap，你可能就会熟悉。Bootstrap是由Twitter开发的CSS框架，我们将在我们的应用程序中使用它。让我们来安装它：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also need to load it in our application:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的应用程序中加载它：
- en: '`index.html`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our `app` component is still missing one last piece before it can work, the
    `app.css` file. Here it is:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`app`组件在能正常工作之前还缺最后一块拼图，那就是`app.css`文件。文件内容如下：
- en: '`src/app.css`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.css`'
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Trying it out
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试一下
- en: At this point, if you run our application, you should see a router error in
    your browser console. That's because the default route tries to load the `contact-list`
    component, which doesn't exist yet.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，如果你运行我们的应用程序，你应在浏览器的控制台看到一个路由错误。那是因为默认路由试图加载`contact-list`组件，而这个组件还不存在。
- en: 'Let''s just create it and leave it empty:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个空的文件：
- en: '`src/contact-list.html`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.html`'
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`src/contact-list.js`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.js`'
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now if you try and run the application again, you should see the application
    load correctly, display the top menu and the empty `contact-list` component.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你再次尝试运行应用程序，你应该看到应用程序正确加载，显示顶部菜单和空的 `contact-list` 组件。
- en: The screen activation life cycle
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕激活生命周期
- en: 'When the router detects a URL path change, it goes through the following life
    cycle:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器检测到 URL 路径发生变化时，它会经历以下生命周期：
- en: The target route is identified. If no route matches the new path, an error is
    thrown and the process stops here.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定目标路由。如果没有任何路由与新路径匹配，将抛出一个错误，并且在这里停止处理过程。
- en: A chance is given to the active route component to refuse deactivation, in which
    case the router restores the previous URL and stops the process here.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给活动路由组件一个拒绝停用的机会，在这种情况下，路由器恢复之前的 URL 并在这里停止处理过程。
- en: A chance is given to the target route component to refuse activation, in which
    case the router restores the previous URL and stops the process here.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给目标路由组件一个拒绝激活的机会，在这种情况下，路由器恢复之前的 URL 并在这里停止处理过程。
- en: The active route component is deactivated.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停用活动路由组件。
- en: The target route component is activated.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活目标路由组件。
- en: The views are swapped.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图被交换。
- en: 'Components, in order to opt in this life cycle, can implement any of the following
    callback methods:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加入这个生命周期，组件可以实现以下任意一个回调方法：
- en: '`canActivate(params, routeConfig, navigationInstruction)`: Called at step #2
    to know if the component can be activated. Can return a `boolean` value, a `Promise`
    of a `boolean` value, a navigation command, or a `Promise` of a navigation command.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canActivate(params, routeConfig, navigationInstruction)`：在步骤 #2 时调用，以知道组件是否可以被激活。可以返回一个
    `boolean` 值、一个 `Promise` 类型的 `boolean` 值、一个导航命令，或者一个 `Promise` 类型的导航命令。'
- en: '`activate(params, routeConfig, navigationInstruction)`: Called at step #5,
    when the component gets activated. Can optionally return a `Promise`.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate(params, routeConfig, navigationInstruction)`：在步骤 #5 时调用，当组件被激活时。可以返回一个可选的
    `Promise`。'
- en: '`canDeactivate()`: Called at step #3 to know if the component can be deactivated.
    Can return a `boolean` value, a `Promise` of a `boolean` value, a navigation command,
    or a `Promise` of a navigation command.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canDeactivate()`：在步骤 #3 时调用，以知道组件是否可以被停用。可以返回一个 `boolean` 值、一个 `Promise` 类型的
    `boolean` 值、一个导航命令，或者一个 `Promise` 类型的导航命令。'
- en: '`deactivate()`: Called at step #4, when the component gets deactivated. Can
    optionally return a `Promise`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deactivate()`：在步骤 #4 时调用，当组件被停用时。可以返回一个可选的 `Promise`。'
- en: '`Promise`s are supported through the whole life cycle. This means that when
    any of the callback methods returns a `Promise`, the router will wait for its
    resolution before continuing the process.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 在整个生命周期中都是被支持的。这意味着当回调方法中的任何一个返回一个 `Promise` 时，路由器会在继续处理之前等待其解决。'
- en: 'Additionally, `canActivate` and `activate` both receive arguments related to
    the navigation context:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`canActivate` 和 `activate` 都接收与导航上下文相关的参数：
- en: The `params` object will have a property for each parsed parameter in the route
    pattern, as well as a property for each query string value. For example, our `contact-details`
    component will receive a `params` object with an `id` property. Optional parameters
    that have no value in the matched path will be `undefined`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params` 对象将有一个属性，用于每个解析的路由模式中的参数，以及每个查询字符串值的属性。例如，我们的 `contact-details` 组件将接收一个具有
    `id` 属性的 `params` 对象。在匹配路径中没有值的可选参数将被设置为 `undefined`。'
- en: 'The `routeConfig` will be the original route configuration object, with an
    additional `navModel` property. This `navModel` object has a `setTitle(title:
    string)` method, which can be used by the component to change the document title
    to a dynamic value, such as data loaded during activation. We will see more of
    this when we start building our data display components in [Chapter 3](ch03.html
    "Chapter 3. Displaying Data"), *Displaying Data*.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routeConfig` 将是原始的路由配置对象，具有一个额外的 `navModel` 属性。这个 `navModel` 对象有一个 `setTitle(title:
    string)` 方法，该方法可以被组件用来将文档标题更改为动态值，如激活期间加载的数据。我们将在第 [3](ch03.html "第 3 章：显示数据")
    章中看到更多内容，*显示数据*。'
- en: The `navigationInstruction` is the `NavigationInstruction` instance used by
    the router to perform the navigation.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navigationInstruction` 是路由器用来执行导航的 `NavigationInstruction` 实例。'
- en: Finally, `canDeactivate` and `canActivate` can both cancel the navigation if
    they return `false`, a `Promise` resolving to `false`, a navigation command or
    a `Promise` resolving to a navigation command.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`canDeactivate`和`canActivate`都可以如果它们返回`false`、一个解析为`false`的`Promise`、一个导航命令或一个解析为导航命令的`Promise`来取消导航。
- en: Navigation commands
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航命令
- en: 'A navigation command is an object with a `navigate(router: Router)` method.
    When a navigation command is returned from `canDeactivate` or `canActivate`, the
    router cancels the current navigation and delegates control to the command. Aurelia
    ships with a single navigation command out of the box: `Redirect`. Here''s an
    example of how to use it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '导航命令是一个具有`navigate(router: Router)`方法的对象。当从`canDeactivate`或`canActivate`返回导航命令时，路由器取消当前导航并将控制权委托给命令。Aurelia自带一个导航命令：`Redirect`。这是一个使用它的示例：'
- en: '`src/contact-details.js`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-details.js`'
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, in the `canActivate` callback method, the `ContactDetails` view-model
    tries to load a contact by its `id`. If the `Promise` returned by `getById` is
    rejected, the user is redirected to an `error` route.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`canActivate`回调方法中，`ContactDetails`视图模型尝试通过其`id`加载联系人。如果由`getById`返回的`Promise`被拒绝，用户将被重定向到`error`路由。
- en: Handling unknown routes
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理未知路由
- en: 'When the router cannot match the URL path to any route, it throws an error.
    But before raising this error, it first delegates the navigation instruction to
    an unknown route handler, if any. This handler can be configured using the `mapUnknownRoutes`
    method, which can take one of the following values as a parameter:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器无法将URL路径与任何路由匹配时，它会抛出一个错误。但在提出这个错误之前，它首先将导航指令委托给一个未知的路由处理程序，如果有的话。此处理程序可以通过使用`mapUnknownRoutes`方法进行配置，该方法可以接受以下值之一作为参数：
- en: The path of the component to display instead of throwing an error.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件显示的路径，而不是抛出错误。
- en: A route configuration object, containing either a `moduleId`, a `redirect`,
    or a `navigationStrategy` property. The router will delegate navigation to this
    route instead of throwing an error.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由配置对象，包含`moduleId`、`redirect`或`navigationStrategy`属性之一。路由器将委托导航到此路由，而不是抛出错误。
- en: A function receiving the `NavigationInstruction` instance and returning the
    path of the component to display instead of throwing an error.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接收`NavigationInstruction`实例并返回要显示的组件路径而不是抛出错误的函数。
- en: 'Let''s implement a `not-found` component that our application will display
    when a link is broken:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个`not-found`组件，当链接断裂时，我们的应用程序将显示它：
- en: '`src/not-found.html`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/not-found.html`'
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`src/not-found.js`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/not-found.js`'
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In our root component, we simply need to add the highlighted line:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的根组件中，我们只需要添加突出显示的行：
- en: '`src/app.js`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Any time the router is unable to match the URL path to an existing route, our
    `not-found` component will be displayed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候路由器无法将URL路径与现有路由匹配，我们的`not-found`组件都将显示。
- en: Conventional routing
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 约定路由
- en: 'Another option offered by `mapUnknownRoutes` is to use conventions for routing
    instead of a set of statically defined routes. If all of your routes follow the
    same naming pattern between the path and the `moduleId`, we could imagine having
    something like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapUnknownRoutes`提供的另一个选项是使用路由约定而不是一组静态定义的路由。如果你的所有路由都遵循路径和`moduleId`之间的相同命名模式，我们可以想象这样的事情：'
- en: '`src/app.js`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE45]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, the routing is relying on a convention that is to be implemented by the
    `getComponentForRoute` function, which receives the URL path that triggered navigation
    and returns the path of the component that must be displayed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，路由依赖于一个由`getComponentForRoute`函数实现的约定，该函数接收触发导航的URL路径，并返回必须显示的组件路径。
- en: Activation strategies
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活策略
- en: 'When multiple static routes lead to the same component and a navigation between
    two of those routes occur, the router just keeps the same component instance.
    Because of this, the activation life cycle is not executed. This behavior is determined
    by the activation strategy. The `activationStrategy` enumeration has two values:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个静态路由导致相同的组件，并在这些路由之间发生导航时，路由器只是保持相同的组件实例。由于这个原因，激活生命周期不会执行。这种行为由激活策略决定。`activationStrategy`枚举有两个值：
- en: '`replace`: Replace the current route with the new one, keeping the same component
    instance, without going through the activation life cycle. This is the default
    behavior.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`：用新路由替换当前路由，保持相同的组件实例，不经过激活生命周期。这是默认行为。'
- en: '`invokeLifecycle`: Go through the activation life cycle even though the active
    component does not change.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeLifecycle`：即使活动组件没有变化，也要经历激活生命周期。'
- en: 'There are two ways to change this behavior:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 改变这种行为有两种方法：
- en: In the configuration object of a route, you can add an `activationStrategy`
    property specifying which strategy should be used when activating this route.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由的配置对象中，你可以添加一个`activationStrategy`属性，指定激活此路由时应使用哪种策略。
- en: In the route component's view-model, you can add a `determineActivationStrategy`
    method, which must return the strategy to be used for all routes displaying this
    component.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由组件的视图模型中，你可以添加一个`determineActivationStrategy`方法，该方法必须返回所有显示此组件的路由所使用的策略。
- en: Child routers
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子路由 (Child routers)
- en: Just like DI, containers can have children and form a container tree; just like
    components can include child components and form a component tree, routers can
    also have children. This means that a route component's view-model can have its
    own `configureRouter` method, and its view a `router-view` element. When such
    a component is encountered, the router will create a child router for this sub-component.
    The route patterns of this child router will be relative to the parent route's
    pattern.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 就像DI一样，容器可以有子容器，形成一个容器树；就像组件可以包含子组件，形成一个组件树，路由器也可以有子路由器。这意味着一个路由组件的视图模型可以有自己的`configureRouter`方法，其视图有一个`router-view`元素。当遇到这样的组件时，路由器将为这个子组件创建一个子路由器。这个子路由器的路由模式相对于父路由的模式是相对的。
- en: This allows for an application to have a navigation tree, with multiple levels.
    We will see how to leverage this feature when we discuss how to organize a large
    application in [Chapter 6](ch06.html "Chapter 6. Design Concerns - Organizing
    and Decoupling"), *Design Concerns - Organizing and Decoupling*
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得应用程序可以有一个具有多级层次的导航树。在讨论如何组织大型应用程序时，我们将会看到如何利用这一特性，请参阅[第6章](ch06.html "Chapter 6. 设计关注点
    - 组织和解耦")，*设计关注点 - 组织和解耦*。
- en: Pipelines
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道 (Pipelines)
- en: It may be useful to connect the router with some logic that gets invoked each
    time a navigation request is issued. For example, an application with an authentication
    mechanism may need to restrict some routes to authenticated users only. The Aurelia
    router's pipelines were conceived exactly for such scenarios.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可能很有必要将路由器与一些在每次发出导航请求时都会被调用的逻辑连接起来。例如，具有认证机制的应用程序可能需要将某些路由限制为仅限认证用户。Aurelia路由器的管道正是为这类场景而设计的。
- en: 'The router supports four pipelines: `authorize`, `preActivate`, `preRender`,
    and `postRender`. Those pipelines are called at different stages during the navigation
    process. Let''s see where each of them occurs:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器支持四个管道：`authorize`、`preActivate`、`preRender`和`postRender`。这些管道在导航过程中的不同阶段被调用。让我们看看它们各自发生在哪里：
- en: The current route component's `canDeactivate` method is called, if present.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在的话，当前路由组件的`canDeactivate`方法会被调用。
- en: The `authorize` pipeline is executed.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`authorize`管道。
- en: The target route component's `canActivate` method is called, if present.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在的话，目标路由组件的`canActivate`方法会被调用。
- en: The `preActivate` pipeline is executed.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`preActivate`管道。
- en: The current route component's `deactivate` method is called, if present.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在的话，当前路由组件的`deactivate`方法会被调用。
- en: The target route component's `activate` method is called, if present.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在的话，目标路由组件的`activate`方法会被调用。
- en: The `preRender` pipeline is executed.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`preRender`管道。
- en: The views are swapped in the router viewport.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由视口中交换视图。
- en: The `postRender` pipeline is executed.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`postRender`管道。
- en: A pipeline is composed of steps, which are called in sequence. A pipeline step
    is a class with a `run(instruction, next)` method, where `instruction` is a `NavigationInstruction`
    instance and `next` a `Next` object.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 管道由步骤组成，这些步骤按顺序调用。管道步骤是一个具有`run(instruction, next)`方法类的实例，其中`instruction`是一个`NavigationInstruction`实例，`next`是一个`Next`对象。
- en: A `Next` object is a function with methods.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Next`对象是一个具有方法的对象。'
- en: When `next()` is invoked, it tells the router pipeline to keep going with the
    next step. The `next.cancel()` method cancels the navigation process and expects
    either a navigation command or an `Error` object to be passed as a parameter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`next()`时，它告诉路由器管道继续执行下一个步骤。`next.cancel()`方法取消了导航过程，并期望传递一个导航命令或`Error`对象作为参数。
- en: Both return `Promise`s.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都返回`Promise`。
- en: 'Let''s see an example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '`src/app.js`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The important thing to notice here is that the `AuthenticatedStep` class is
    added to the `authorize` pipeline. Pipeline steps are added as classes, not as
    instances. That's because the router uses its DI container to resolve instances
    of the steps. This allows steps to have dependencies, which are resolved and injected
    just before being executed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，`AuthenticatedStep`类被添加到了`authorize`管道中。管道步骤作为类添加，而不是实例。这是因为路由使用其DI容器来解析步骤的实例。这允许步骤有依赖关系，这些依赖关系在执行前被解析和注入。
- en: The second thing to notice is that the `management` route has a `settings` object
    with a `secured` property, set to `true`. It will be used by the pipeline step
    depicted in the following snippet to identify routes that need to be restricted
    to authenticated users.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要注意的是，`management`路由有一个`settings`对象，其`secured`属性被设置为`true`。它将由以下片段中的管道步骤使用，以识别需要对已认证用户限制的路由。
- en: '`src/authenticated-step.js`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/authenticated-step.js`'
- en: '[PRE47]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the actual pipeline step. In this example, we can imagine that our application
    contains a `User` class, which exposes the current user's information. Our pipeline
    relies on an instance of this class to know if the current user is authenticated
    or not.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际的管道步骤。在这个例子中，我们可以想象我们的应用程序包含一个`User`类，它暴露了当前用户的信息。我们的管道依赖于这个类的实例，以知道当前用户是否已认证。
- en: The `run` method first checks if any of the routes in the instruction are configured
    as secured. This is achieved by inspecting all the navigation instructions, including
    instructions for potential parent routers, and checking their configuration's
    `settings` for a truthy `secured` property.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`方法首先检查指令中的任何路由是否被配置为安全。这是通过检查所有导航指令，包括潜在父路由的指令，并检查其配置的`settings`中的真值`secured`属性来实现的。'
- en: For example, when navigating to the `management` route defined in the previous
    code snippet, the value assigned to `isRouteSecured` would be `true`. That would
    also be the case if the `management` component declared child routes and the navigation
    occurred for one of those. In such a scenario, even if the child route was not
    configured as `secured`, `isRouteSecured` would still be `true` because one of
    the parent routes would be `secured`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当导航到前一个代码片段中定义的`management`路由时，`isRouteSecured`的值将被设置为`true`。如果`management`组件声明了子路由，并且导航是对其中之一进行的，那么情况也会如此。在这种情况下，即使子路由没有被配置为`secured`，`isRouteSecured`仍将是`true`，因为其中一个父路由将是`secured`。
- en: When the target route or one of its parents is secured, if the user is not authenticated,
    navigation is canceled and the user is redirected to the `login` route. Otherwise,
    `next` is invoked, letting the router know it can keep going with the navigation
    process.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标路由或其之一被设置为安全时，如果用户未认证，导航将被取消，用户将被重定向到`login`路由。否则，调用`next`，让路由器知道它可以继续导航过程。
- en: Events
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: The Aurelia router offers yet another extension point. Additionally to the screen
    activation life cycle and to pipelines, the router publishes events through the
    event aggregator, which is another of Aurelia's core libraries.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia路由还提供了另一个扩展点。除了屏幕激活生命周期和管道之外，路由还通过事件聚合器发布事件，这是Aurelia的核心库之一。
- en: 'A demo of the router events can be found in `samples/chapter-2/router-events`.
    Let''s see those events:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`samples/chapter-2/router-events`中找到路由事件的演示。让我们看看这些事件：
- en: '`router:navigation:processing`: This event is fired every time the router starts
    processing a navigation instruction.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router:navigation:processing`：每次路由开始处理导航指令时，都会触发此事件。'
- en: '`router:navigation:error`: This event is fired when a navigation instruction
    triggers an error.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router:navigation:error`：当导航指令触发错误时，会触发此事件。'
- en: '`router:navigation:canceled`: This event is fired when a navigation instruction
    is canceled, either by one of the screen activation life cycle callback methods
    of either the current or target route component, or by a pipeline step.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router:navigation:canceled`：当导航指令被取消时，会触发此事件，取消可以是当前或目标路由组件的屏幕激活生命周期回调方法之一，或者是管道步骤。'
- en: '`router:navigation:success`: This event is fired when a navigation instruction
    is successful.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router:navigation:success`：当导航指令成功时，会触发此事件。'
- en: '`router:navigation:complete`: This event is fired once a navigation instruction''s
    processing is completed, no matter if it failed, was canceled, or was successful.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router:navigation:complete`：一旦导航指令的处理完成，无论它失败、被取消还是成功，都会触发此事件。'
- en: The payload of all of these events contains the `NavigationInstruction` instance,
    stored as an `instruction` property. Also, except for `router:navigation:processing`,
    all other events' payload has the `PipelineResult` as a `result` property. For
    example, when handling the `error` event, the `Error` object that was thrown can
    be accessed using the `output` property of `result`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些事件的负载都包含一个`NavigationInstruction`实例，作为`instruction`属性存储。此外，除了`router:navigation:processing`之外，其他事件的所有负载都有一个`PipelineResult`作为`result`属性。例如，在处理`error`事件时，可以使用`result`属性的`output`属性来访问被抛出的`Error`对象。
- en: We will see how the event aggregator works in [Chapter 6](ch06.html "Chapter 6. Design
    Concerns - Organizing and Decoupling"), *Design Concerns - Organizing and Decoupling*
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](ch06.html "第6章 设计关注 - 组织和解耦")中看到事件聚合器是如何工作的，*设计关注 - 组织和解耦*。
- en: Multiple viewports
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个视口
- en: In all previous examples, the `router-view` element never has any attribute.
    It can actually have a `name` attribute. When this attribute is omitted, the viewport
    declared on the router by the element is named `default`. Can you see the implication
    here?
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的示例中，`router-view`元素从未有过任何属性。它实际上可以有一个`name`属性。当省略这个属性时，由元素声明在路由器上的视口被称为`default`。您看到这里的含义了吗？
- en: 'If your answer is that the router supports multiple viewports, you guessed
    right. Of course, it also means that each route must be configured for every viewport
    declared in the view. Let''s see how this works:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回答路由支持多个视口，那你猜对了。当然，这也意味着每个声明在视图中的视口都必须为每个视口配置路由。让我们看看这是如何工作的：
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following code snippets are excerpts of `samples/chapter-2/router-multiple-viewports`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段摘自`samples/chapter-2/router-multiple-viewports`。
- en: '`src/app.html`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.html`'
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, the interesting thing to notice in the component''s view is that there
    are two `router-view` elements, with different `name` attributes. This component''s
    router will end up with two viewports: one named `header` and another named `content`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的视图中，有趣的是注意到有两个`router-view`元素，有不同的`name`属性。这个组件的路由最终会有两个视口：一个名为`header`，另一个名为`content`：
- en: '`src/app.js`'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the view-model's `configureRouter` callback method, both routes are configured
    with a specific `moduleId` for both the `header` and the `content``viewPorts`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图模型的`configureRouter`回调方法中，两个路由都使用特定的`moduleId`进行了配置，既适用于`header`，也适用于`content`和`viewPorts`。
- en: 'If not every router''s viewports are accounted for by the route configuration
    when activated, the router will throw an error. It doesn''t matter if the route
    was configured statically with a `viewPorts` property defining a `moduleId` for
    every viewport, or if the `viewPorts` property was dynamically configured by a
    `navigationStrategy`. In the previous example, the `page-2` route could be replaced
    by:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在路由激活时没有为每个路由的视口配置路由，则路由器将抛出错误。无论是否静态地使用`viewPorts`属性为每个视口定义了`moduleId`，还是`viewPorts`属性通过`navigationStrategy`动态配置，都不重要。在前一个示例中，`page-2`路由可以被替换为：
- en: '[PRE50]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This route would have the same effect as in the previous example. The only difference
    here is that the viewports are configured dynamically each time the route is activated.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由与前一个示例中的效果相同。这里唯一的区别是，每次路由激活时都会动态地配置视口。
- en: Of course, redirection routes are not affected by viewports, since they don't
    render anything.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，重定向路线不会受到视口的影响，因为它们不会渲染任何内容。
- en: Push state versus hash change
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态推送与哈希变化
- en: The router works by reacting to URL changes. In older browsers, only the part
    of the URL after the hash sign (#), called the hash, can change without triggering
    a page reload. So routers running on those browsers can only change the hash part,
    and listen for changes in the hash part.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器通过响应URL的变化来工作。在旧浏览器中，只有URL中的#符号后面的部分，即哈希部分，可以改变而不触发页面重载。因此，在这些浏览器上运行的路由器只能更改哈希部分，并监听哈希部分的更改。
- en: With HTML5, a new History API has been introduced to enable manipulation of
    the browser history. This allows a JavaScript router running on a modern browser
    to directly manipulate its current URL and its browsing history, and to monitor
    changes to its current URL. This API enables the router to use the full URL, and
    allows things such as isomorphic applications, with server rendering and progressive
    enhancement. Those techniques can make an application's content accessible to
    a wider range of clients, and will also increase the application's SEO, as Google
    deprecated hash-based applications with AJAX content loading (see [https://googlewebmastercentral.blogspot.com/2015/10/deprecating-our-ajax-crawling-scheme.html](https://googlewebmastercentral.blogspot.com/2015/10/deprecating-our-ajax-crawling-scheme.html)).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 随着HTML5的推出，一个新的历史API被引入，以实现对浏览器历史的操作。这使得运行在现代浏览器上的JavaScript路由器可以直接操作其当前URL和浏览历史，并监控当前URL的变化。这个API使得路由器能够使用完整的URL，并允许诸如同构应用之类的技术，具有服务器渲染和渐进增强。这些技术可以使应用程序的内容能够被更广泛的客户端访问，同时也将提高应用程序的SEO，因为谷歌已经弃用了基于哈希的带有AJAX内容加载的应用（参见[https://googlewebmastercentral.blogspot.com/2015/10/deprecating-our-ajax-crawling-scheme.html](https://googlewebmastercentral.blogspot.com/2015/10/deprecating-our-ajax-crawling-scheme.html)）。
- en: Note
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An application is isomorphic when it can be executed on both the client and
    the server. Typically, an isomorphic application is executed server-side to render
    a text-based HTML representation that can then be returned to a client; a search
    engine crawler, for example. When executed client-side, it is normally enhanced
    with runtime event handlers, data bindings, and actual behavior so users can interact
    with the application.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序可以在客户端和服务器上执行时，它被称为同构应用程序。通常，同构应用程序在服务器端执行，以渲染基于文本的HTML表示，然后可以返回给客户端；例如，搜索引擎爬虫。当在客户端执行时，它通常通过运行时事件处理程序、数据绑定和实际行为进行增强，以便用户可以与应用程序互动。
- en: Aurelia's router plugin can work with either of those two strategies. By default,
    it is configured to use the hash-based strategy, because push-state requires the
    server to be configured accordingly. Also, the hash-based strategy supports older
    browsers not fully compatible with HTML5.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 奥雷利亚（Aurelia）的路由插件可以与这两种策略中的任何一种工作。默认情况下，它被配置为使用基于哈希的策略，因为状态推送需要服务器相应地配置。此外，基于哈希的策略支持不完全兼容HTML5的旧浏览器。
- en: However, if support of older browsers is not needed, or server-side rendering
    is required and the application will likely evolve toward isomorphism, the router
    can be configured to use the History API.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果不需要支持旧浏览器，或者需要服务器端渲染，并且应用程序可能会向同构方向发展，路由器可以配置为使用历史API。
- en: Note
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following code snippets are excerpts of `samples/chapter-2/router-push-state`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段是`samples/chapter-2/router-push-state`的摘录。
- en: First, in the `index.html` file, in the head section, a `<base href="/">` tag
    must be added. This element instructs the browser that `/` is the base for all
    relative URLs in the page.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`index.html`文件中，在头部部分，必须添加一个`<base href="/">`标签。这个元素指示浏览器`/`是页面中所有相对URL的基础。
- en: 'Next, in the root component''s view-model, the router must be configured differently:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在根组件的视图模型中，路由必须配置不同：
- en: '`src/app.js`'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE51]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Additionally, for the right route to be displayed when a user accesses the application
    using a URL other than the root URL, the server needs to output the `index.html`
    page instead of a 404 response to requests for unknown paths. This way, when a
    user accesses an application route, the server will respond with the index page,
    then the application will boot and the router will handle the route and display
    the right view. Implicitly, this means that there must be no naming conflicts
    between the routes in your application and server-side resources, such as CSS,
    images, fonts, JS, HTML, or whatever files that must be loaded by the index page
    or the application from the server.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了在用户使用除根URL以外的URL访问应用程序时显示正确的路由，服务器需要输出`index.html`页面，而不是对未知路径的404响应。这样，当用户访问应用程序的路由时，服务器将响应index页面，然后应用程序启动，路由器将处理路由并显示正确的视图。这意味着应用程序中的路由和服务器端资源（如CSS、图片、字体、JS、HTML或必须由index页面或应用程序从服务器加载的任何文件）之间必须没有命名冲突。
- en: Generating URLs
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成URL
- en: The router being able to react to URL changes and update its viewport accordingly
    is one thing. But what about links allowing it to navigate? If we hardcode URLs,
    any change in a route's path pattern would require not just changing the route
    configuration, but also to go over every place this URL is used for navigation,
    may it be in JS code or in views, and change it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器能够对URL的变化做出反应，并相应地更新其视口，这是一件事。但是关于允许它导航的链接呢？如果我们硬编码URL，任何路由路径模式的更改都需要更改路由配置，还要检查用于导航的每个地方，无论是JS代码还是视图，并修改它。
- en: 'Thankfully, the router is also able to generate URLs. There are two requirements
    to generate a route path:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，路由器也能够在生成URL。要生成一个路由路径，有两个要求：
- en: The route configuration must have a unique `name` property
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由配置必须有一个唯一的`name`属性
- en: If the route has a parameterized or a wildcard pattern, a parameter object containing
    a value for each parameter must be provided when generating the URL.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由具有参数化或通配符模式，生成URL时必须提供包含每个参数值的参数对象。
- en: In code
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在代码中
- en: 'To generate a URL path in JS code, you must first have an instance of the router,
    generally by injecting it in the class where you need it. Then, you can call the
    following method:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JS代码中生成URL路径，你首先必须有一个路由器的实例，通常是通过在需要它的类中注入它来获得的。然后，你可以调用以下方法：
- en: '[PRE52]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This method must be called with the name of the route, the parameters object
    if the route has any, and an optional options object, and will return the resulting
    URL. The only supported option at the moment is `absolute` which, when set to
    `true`, forces the router to return an absolute URL instead of a relative one.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用路由名称、路由有时的参数对象以及可选的选项对象调用此方法，并将返回生成的URL。目前唯一支持的选择是`absolute`，当设置为`true`时，强制路由器返回绝对URL而不是相对URL。
- en: 'For example, for our route named `contact-details` with the path pattern `contacts/:id`,
    the call to generate the URL for a contact whose `id` is 12 would be:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于路径模式为`contacts/:id`的名为`contact-details`的路由，为id为12的联系人生成URL的调用将是：
- en: '[PRE53]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And for an absolute URL:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于绝对URL：
- en: '[PRE54]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In views
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在视图中
- en: What if we need to render a link to one of our routes inside a view? I guess
    you can see how you could inject the router inside a view-model, call the `generate`
    method, and data-bind an anchor's `href` attribute to the result. That would quickly
    get tedious at best.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在视图中渲染一个指向我们路由的链接怎么办？我猜你可以看到如何将路由器注入视图模型中，调用`generate`方法，并将锚点的`href`属性与结果数据绑定。在最坏的情况下，这会很快变得繁琐。
- en: 'The `aurelia-templating-router` library ships with a `route-href` attribute,
    which makes this much easier. For example, the template snippet to render a link
    to the contact with the `id 12` for our route named `contact-details` would be:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-templating-router`库带有一个`route-href`属性，这使得这变得容易得多。例如，要为名为`contact-details`的路由渲染一个到id为12的联系人链接的模板片段将是：'
- en: '[PRE55]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Chances are the ID won''t be hardcoded but will be stored in an object:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 机会很大，ID不会被硬编码，而是存储在一个对象中：
- en: '[PRE56]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'By default, the `route-href` attribute will assign the resulting URL to the
    `href` attribute of the element it is on, but it supports an `attribute` property,
    which can be used to specify the name of the attribute on which the URL must be
    set:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`route-href`属性会将生成的URL分配给它所在元素的`href`属性，但它支持一个`attribute`属性，可以用来指定必须设置URL的属性名称：
- en: '[PRE57]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, the URL for the `quote` route will be assigned to the `cite` attribute
    of the `q` element.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`quote`路由的URL将被分配给`q`元素的`cite`属性。
- en: Navigating
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航
- en: 'The router offers convenient methods to perform navigation from JS code:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器提供了方便的方法，可以从JS代码执行导航：
- en: '`navigate(fragment: string, options?: any): boolean`: Navigates to a new location,
    whose path is `fragment`. Returns `true` if the navigation succeeded, `false`
    otherwise. There are two supported `options`:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navigate(fragment: string, options?: any): boolean`：导航到新的位置，其路径为`fragment`。如果导航成功，则返回`true`，否则返回`false`。目前支持两个`options`：'
- en: '`replace: boolean`: If set to `true`, the new URL will replace the current
    location in history, instead of being appended to history.'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace: boolean`：如果设置为`true`，新URL将替换历史记录中的当前位置，而不是添加到历史记录中。'
- en: '`trigger: boolean`: If set to `false`, Aurelia''s router will not be triggered.
    This means that if the URL is relative, it will change in the browser''s address
    bar but no actual navigation will occur.'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trigger: boolean`：如果设置为`false`，Aurelia的路由器将不会被触发。这意味着如果URL是相对的，它会在浏览器的地址栏中更改，但实际上不会发生导航。'
- en: '`navigateToRoute(name: string, params?: any, options?: any): boolean`: Conveniently
    wraps a call to `generate` and then to `navigate`.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navigateToRoute(name: string, params?: any, options?: any): boolean`：方便地包装了对`generate`的调用，然后是`navigate`。'
- en: '`navigateBack(): void`: Navigates back to the previous location in history.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navigateBack(): void`：返回历史记录中的上一个位置。'
- en: Summary
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Dependency injection, being at the core of Aurelia, it is important to understand
    how it works. If you were not familiar with the concept before this chapter, it
    may be a lot to process at once; but rest assured, as we will keep using those
    features a lot in the remainder of the book, it will help you get more familiar
    with it.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是Aurelia的核心，因此理解其工作方式很重要。如果你在本章之前对这个概念不熟悉，一下子可能接受不了这么多；但请放心，由于我们将在书的剩余部分大量使用这些功能，这将帮助你更加熟悉它。
- en: The same thing goes with plugins, features, and routing. We will keep digging
    those subjects later in the book, particularly in [Chapter 6](ch06.html "Chapter 6. Design
    Concerns - Organizing and Decoupling"), *Design Concerns - Organizing and Decoupling*,
    when we will discuss various ways to structure an application.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 插件、功能和路由也是如此。我们将在书的后面继续深入研究这些主题，特别是在[第6章](ch06.html "第6章. 设计关注 - 组织和解耦")，*设计关注
    - 组织和解耦*，当我们讨论各种应用程序结构的实现方式时。
- en: Before getting there, we still have a lot of ground to cover. In the next chapter,
    we will discuss data binding and the basics of templating, and we will add components
    to fetch and display data in our contact management application.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达那里之前，我们还有很多内容需要学习。在下一章，我们将讨论数据绑定和模板的基础知识，并将组件添加到我们的联系人管理应用程序中以获取和显示数据。
