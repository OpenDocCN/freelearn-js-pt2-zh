- en: '*Chapter 4*: Building a Web Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：构建Web应用程序'
- en: 'Here we are! We have traveled down a long road to get here. This is where all
    the fun starts. We''ve been through three phases: getting to know what Deno is,
    exploring the toolchain provided by it, and understanding the details and functionality
    available via its runtime.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里我们来了！我们走过了漫长的一段路才到达这里。这里才是所有乐趣的开始。我们已经经历了三个阶段：了解Deno是什么，探索它提供的工具链，以及通过其运行时了解其细节和功能。
- en: Pretty much all the content from the previous chapters will prove to be useful
    in this one. Hopefully, the introductory chapters made you feel confident enough
    to start applying what we have learned together. We'll use those chapters, together
    with your existing TypeScript and JavaScript knowledge, to build a complete web
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章的大部分内容将在这一章中证明是有用的。希望，入门章节让您有信心开始应用我们一起学到的内容。我们将使用这些章节以及您现有的TypeScript和JavaScript知识，来构建一个完整的Web应用程序。
- en: We'll be writing an API that contains business logic, handles authentication,
    authorization, and logging, and much more. We will cover enough of the fundamental
    pieces for you to, at the end, feel comfortable choosing Deno to build your next
    great app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个包含业务逻辑、处理身份验证、授权和日志记录等内容的API。我们将涵盖足够的基础知识，以便您最终可以自信地选择Deno来构建您下一个伟大的应用程序。
- en: In this chapter, instead of talking just about Deno, we will also go over some
    thoughts regarding the fundamentals of software engineering and application architecture.
    We believe it is crucial to keep some things in mind when it comes to building
    an application from scratch. We will look at of the fundamentals, which will be
    proven useful and help us structure our code, enabling it to evolve in the future
    by making it easy to change.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅要谈论Deno，还要回顾一些关于软件工程和应用程序架构的基本思想。我们认为，在从头开始构建应用程序时，牢记一些事情至关重要。我们将查看一些基本原理，这些原理将被证明是有用的，并帮助我们构建代码，使其易于在未来变化中进化。
- en: Later, we will start to reference some third-party modules, look at their approaches,
    and decide on what we'll use from here on to help us deal with routing and HTTP
    related challenges. We'll also make sure that we structure our application in
    a way that the third-party code is isolated and works as an enabler for the functionalities
    we want to build, more than the functionalities themselves.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将开始引用一些第三方模块，查看它们的方法，并决定从这里开始我们将使用什么来帮助我们处理路由和与HTTP相关的挑战。我们还将确保我们以一种使第三方代码隔离并作为我们想要构建的功能的使能者而不是功能本身来工作的方式来构建我们的应用程序。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Structuring a web application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Web应用程序的结构
- en: Exploring Deno HTTP frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Deno HTTP框架
- en: Let's get started!
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files used in this chapter are available at the following link: [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码文件可在以下链接找到：[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api)。
- en: Structuring a web application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Web应用程序的结构
- en: 'When starting an application, it''s important that we spend some time thinking
    about its structure and architecture. That''s where there this section will start:
    by looking at the backbone of application architecture. We''ll have a look at
    what advantages it brings and align ourselves with a set of principles that will
    help us scale it as the application grows.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个应用程序时，花时间思考其结构和架构是很重要的。这一节将从这个角度开始：通过查看应用程序架构的骨架。我们将看看它带来了什么优势，并使自己与一套原则保持一致，这些原则将帮助我们在应用程序增长时扩展它。
- en: Then, we'll develop what will become the application's first endpoint. However,
    first, we'll start with the business logic. The persistency layer will follow,
    and we'll finish by looking at an HTTP endpoint that will act as the application's
    entry point.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开发出将成为应用程序第一个端点的部分。然而，首先，我们将从业务逻辑开始。持久层将紧随其后，最后我们将查看一个HTTP端点，它将作为应用程序的入口点。
- en: Deno as an unopinionated tool
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Deno作为一个无偏见的工具
- en: When we're using tools that are low level and delegate many decisions to developers,
    such as Node.js and Deno, structuring an application is one of the big challenges
    that arises.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用低级别的工具，并将许多决策权委托给开发者时，如Node.js和Deno，构建应用程序是随之而来的一个重大挑战。
- en: This is very different compared to an opinionated web framework, such as PHP
    Symfony, Java SpringBoot, or Ruby on Rails, where many of these decisions are
    made for us.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这与具有明确观点的Web框架，如PHP Symfony、Java SpringBoot或Ruby on Rails，有很大的不同，在这些框架中，许多这些决策已经为我们做出。
- en: Most of these decisions have something to do with structure; that is, code and
    folder structure. Those frameworks normally provide us with ways to deal with
    dependencies, imports, and even provide some guidance regarding different application
    layers. Since we're using the *raw* language with a few packages, we will take
    care of structure by ourselves in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决策大多数与结构有关；也就是说，代码和文件夹结构。这些框架通常为我们提供处理依赖项、导入的方法，甚至在不同的应用程序层次结构上提供一些指导。由于我们使用的是*原始*语言和几个包，因此在这本书中我们将自己负责这些结构。
- en: The aforementioned frameworks can't be directly compared with Deno since they
    are frameworks built on top of languages, such as PHP, Java, and Ruby. But when
    we look at the JS world, namely at Node.js we can observe that the most popular
    tools used to create HTTP servers are Express.js and Kao. These tend to be much
    lighter than the aforementioned frameworks, and even though there are also some
    solid complete alternatives such as Nest.js or hapi.js, the Node.js community
    tends to prefer a *library* approach more than a *framework* one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前述框架不能直接与Deno相比较，因为它们是构建在诸如PHP、Java和Ruby等语言之上的框架。但是当我们查看JS世界，尤其是Node.js时，我们可以观察到最常用来创建HTTP服务器的最受欢迎工具是Express.js和Kao.js。这些通常比前述框架轻量级得多，尽管还有一些坚固完整的替代方案，如Nest.js或hapi.js，但Node.js社区更倾向于采用*库*方法，而不是*框架*方法。
- en: Even though these very popular libraries provide a good amount of functionality,
    many decisions are still delegated to developers. This isn't the libraries' fault,
    but more a community preference.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些非常流行的库提供了大量功能，但许多决策仍然委托给开发者。这不是库的错，更多的是一个社区偏好。
- en: On one hand, having direct access to these primitives lets us build applications
    that are very well-suited to our use cases. On the other hand, flexibility is
    a trade-off. Having a lot of flexibility comes the responsibility of making an
    innumerous number of decisions. And when it comes to making many decisions there
    are many opportunities to make bad decisions. The hard part is that these are
    normally decisions that drastically influence the way a code base scales, and
    that's what gives them such importance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，直接访问这些原语让我们能够构建非常适合我们用例的应用程序。另一方面，灵活性是一个权衡。拥有大量的灵活性随之而来的是做出无数决策的责任。而当需要做出许多决策时，就有很多机会做出糟糕的决策。难点在于，这些通常是对代码库扩展方式产生巨大影响的决策，这也是它们如此重要的原因。
- en: In its current state, Deno and its community are following an approach that's
    very similar to Node.js on this framework-versus-library subject. The community
    is mostly betting on light and small pieces of software that are created by developers
    to fit their specific needs. We'll evaluate some of these later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，Deno及其社区在框架与库这一问题上遵循与Node.js非常相似的方法。社区主要押注于由开发者创建的轻量级且小巧的软件，以适应他们的特定需求。我们将在本章后面评估其中的一些。
- en: Starting here, and throughout this book, we'll use an application structure
    that we believe offers great benefits for the use case at hand. However, don't
    expect that structure and architecture to be a silver bullet, as we are pretty
    sure such things do not exist in the software world; every architecture will have
    to keep evolving as it grows.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在这本书的其余部分，我们将使用一种我们相信对当前用例有很大好处的应用程序结构。然而，不要期望这种结构和架构是灵丹妙药，因为我们深信软件世界中不存在这样的东西；每种架构都将随着成长而不断进化。
- en: 'Instead of just throwing in a recipe and following it, we want to become familiar
    with a way of thinking – a rationale. This should enable us to make correct decisions
    further down the road with one objective in mind: *writing code that is easy to
    change*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的不仅仅是扔进一个食谱并遵循它，而是要熟悉一种思维方式——一种推理。这应该能让我们在将来做出正确的决策，目标只有一个：*编写易于更改的代码*。
- en: By writing code that is easy to change, we're always ready to change our application
    for the better without much effort.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写易于更改的代码，我们总是准备好在不需要太多努力的情况下改进我们的应用程序。
- en: The most important part of an application
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序最重要的部分
- en: Applications are created to fit a purpose. It doesn't matter if that purpose
    is to support a business or a simple pet project. At the end of the day, we want
    it to do something. That *something* is what makes the application useful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是为了适应一个目的而被创建的。无论这个目的是支持一个企业还是一个简单的宠物项目都不重要。归根结底，我们希望它能做些什么。那*些什么*就是使应用程序变得有用的原因。
- en: This might seem obvious, but it is sometimes very easy for us, as developers,
    to get so enthusiastic about a technology that we forget that it is just a means
    to an end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很显然，但有时对于我们这些开发者来说，我们很容易因为对一种技术的热情而忘记，它只是达到目的的一种手段。
- en: As Uncle Bob says in his *Architecture – the lost years* talk ([https://www.youtube.com/watch?v=hALFGQNeEnU](https://www.youtube.com/watch?v=hALFGQNeEnU)),
    it is very common for people to forget the application's purpose and focus more
    on the technology itself. It is very important that we remember this in all the
    phases of application development, but it is even more critical when we're setting
    up its initial structure. Next, we'll discover the requirements for the application
    we'll be building throughout the remainder of this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Uncle Bob 在他的*Architecture – the lost years*演讲中所说([https://www.youtube.com/watch?v=hALFGQNeEnU](https://www.youtube.com/watch?v=hALFGQNeEnU)),人们很容易忘记应用程序的目的，而更多地关注技术本身。在我们开发应用程序的所有阶段，记住这一点非常重要，尤其是在建立其初始结构时更是如此。接下来，我们将探讨本书剩余部分我们将要构建的应用程序的需求。
- en: What is our application about?
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的应用程序是关于什么的？
- en: 'Even though we truly believe that business logic is the most important thing
    in any application, in this book, the case is a little different. We''ll be creating
    an example application, but it will just be a means to reach the main goal: learning
    Deno. However, as we want the process to be as real as possible, we want to have
    a clear objective in mind.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们确实相信在任何应用程序中业务逻辑是最重要的事情，但在这本书中，情况有点不同。我们将创建一个示例应用程序，但它只是一个达到主要目标：学习 Deno
    的手段。然而，为了使过程尽可能真实，我们希望在心中有一个清晰的目标。
- en: 'We will build an application that will let people create and interact with
    a list of museums. We can make this clearer by listing its features as user stories,
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个允许人们创建和与博物馆列表互动的应用程序。我们可以通过将其功能作为用户故事列出使其更清晰，如下所示：
- en: The user is able to register and log in.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能够注册和登录。
- en: The user is able to create a museum with a title, description, and location.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能够创建一个带有标题、描述和位置的博物馆。
- en: The user can view a list of museums.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以查看博物馆列表。
- en: Throughout this journey, we'll develop APIs and the logic to support those features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个旅程中，我们将开发 API 和支持这些功能的逻辑。
- en: Now that we're familiar with the end goals, we can start thinking about how
    to structure the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了最终目标，我们可以开始思考如何组织应用程序。
- en: Understanding folder structure and application architecture
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解文件结构和应用程序架构
- en: The first thing we need to be aware of regarding the folder structure, especially
    when we're starting a project from scratch without a framework, is that it will
    keep evolving with the project. A folder structure that is good for a project
    with a couple of endpoints will not be as good for a project with hundreds of
    them. This depends on many things, from team size, to the standards defined, and
    ultimately to preferences.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文件结构，我们首先需要意识到的一点，特别是当我们从零开始一个没有框架的项目时，它将随着项目的发展而不断演变。对于只有几个端点的项目来说好的文件结构，对于有数百个端点的项目来说可能不那么好。这取决于许多事情，从团队规模，到定义的标准，最终到偏好。
- en: When defining the folder structure, it is important that we get to a place where
    we can facilitate future decisions about where to locate a piece of code. The
    folder structure should provide clear hints on how to make good architectural
    decisions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义文件结构时，重要的是我们要达到一个地步，使我们能够促进关于代码放置位置的未来决策。文件结构应该为如何做出良好的架构决策提供清晰的提示。
- en: At the same time, we certainly don't want to create an overengineered application.
    We'll create enough abstractions so that modules are very contained and do not
    have knowledge outside their domain, but not more than that. Keeping this in mind
    also forces us to build flexible code and clear interfaces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们当然不希望创建一个过度工程化的应用程序。我们将创建足够的抽象，使模块非常独立，并且没有超出它们领域的知识，但不会超过这个程度。牢记这一点也迫使我们构建灵活的代码和清晰的接口。
- en: 'Ultimately, what''s most important is that the architecture enables the code
    base to be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，最重要的是架构能够使代码库具备以下特点：
- en: Testable
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试。
- en: Easy to extend
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展。
- en: Decoupled from a specific technology or library
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与特定技术或库解耦。
- en: Easy to navigate and reason about
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于导航和理解。
- en: We'll have to keep in mind that, while creating folders, files, and modules,
    we don't want any of the previously listed topics to be compromised.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建文件夹、文件和模块时，我们必须要记住，绝不能有任何妥协前面提到的话题。
- en: These principles are very much in line with the SOLID principles of software
    design, made famous by Uncle Bob, Robert C. Martin ([https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID))
    in another talk worth watching ([https://youtu.be/zHiWqnTWsn4](https://youtu.be/zHiWqnTWsn4)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则与软件设计中的 SOLID 原则非常一致，由“Uncle Bob”Robert C. Martin 在一次演讲中提出（[https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)），该演讲值得一看（[https://youtu.be/zHiWqnTWsn4](https://youtu.be/zHiWqnTWsn4)）。
- en: The folder structure we are going to use in this book might sound familiar to
    you if you come from a Node.js background.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书我们将要使用的文件夹结构，如果你有 Node.js 背景，可能会觉得熟悉。
- en: As it also happens with Node.js there's nothing preventing us from creating
    a full API in a single file. However, we will not do this as we believe that some
    initial separation of concerns will vastly improve our flexibility later, without
    sacrificing the developer's productivity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如发生在 Node.js 一样，我们完全可以在一个文件中创建一个完整的 API。然而，我们不会这样做，因为我们认为在初始阶段对关注点进行一些分离将大大提高我们的灵活性，而不会牺牲开发者的生产力。
- en: In the following section, we'll look at the responsibilities of the different
    layers and how they fit together while developing a feature for our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨不同层次的责任以及它们在我们开发应用程序功能时的相互配合。
- en: By following this line of thought, we strive to guarantee a degree of decoupling
    between modules. For instance, we want to ensure that making a change in the web
    framework doesn't means we have to touch business logic objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这种思路，我们努力确保模块之间的解耦程度。例如，我们希望通过确保在 web 框架中的更改不会影响到业务逻辑对象。
- en: All these recommendations, as well as the ones we will be making throughout
    this book, will help ensure that the central part of our application is our business
    logic, with everything else being just plugins. A JSON API is just a way of sending
    our data to our users, while a database is just a way to persist data; neither
    of these should be central parts of the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些建议，以及我们在这本书中将会提出的建议，将有助于确保我们应用程序的核心部分是业务逻辑，其他所有内容只是插件。JSON API 只是一种将我们的数据发送给用户的方式，而数据库只是一种持久化数据的方式；这些都不应该是应用程序的核心部分。
- en: 'One way to make sure we''re doing this is to do the following mental exercise
    when we are writing the code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们这样做的一种方法是在编写代码时进行以下心理练习：
- en: '*"When you''re writing business logic, imagine that these objects will be used
    in a different context. Take, for instance, using the business logic with a different
    delivery mechanism (a CLI, for instance) or a different persistence engine (an
    in-memory database instead of a NOSQL database)."*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编写业务逻辑时，想象这些对象将在不同的上下文中使用。例如，使用不同的交付机制（例如 CLI）或不同的持久化引擎（内存数据库而非 NoSQL 数据库）。
- en: In the next few pages, we'll walk you through how to create different layers,
    and we'll also explain all the design decisions and what they enable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将引导您如何创建不同的层次，并解释所有设计决策以及它们所启用的功能。
- en: Let's get practical and start creating our project's backbone.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实际操作，开始构建我们项目的基础框架。
- en: Defining the folder structure
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义文件夹结构。
- en: The first thing we'll do in our project's folder is create an `src` folder.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目的文件夹中，我们首先要创建一个 `src` 文件夹。
- en: This is, predictably, where our code will live. We don't want any code to be
    at the root level of the project because configuration files, READMEs, documentation
    folders, and so on might be added there. This would make it hard to distinguish
    the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里， predictably，是我们的代码将要存放的地方。我们不希望项目的根目录有任何代码，因为可能会在这里添加配置文件、READMEs、文档文件夹等。这会使代码难以区分。
- en: We'll be spending most of our time inside the `src` folder in the following
    chapters. Since our application is about museums, we'll create a folder inside
    the `src` folder named `museums`. This is where most of the logic that will be
    written in this chapter will live. Later, we'll create files for types, controllers,
    and repositories. Then, we'll create the `src/web` folder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将在`src`文件夹内度过大部分时间。由于我们的应用程序是关于博物馆的，我们将在`src`文件夹内创建一个名为`museums`的文件夹。这个文件夹将存放本章将编写的
    most of the logic。稍后，我们将创建类型、控制器和方法文件。然后，我们将创建`src/web`文件夹。
- en: The controller's file is where our business logic will live. The repository
    will take care of the logic related to data access, while the web layer will handle
    everything that is *web-related*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的文件是我们的业务逻辑将存放的地方。仓库将处理与数据访问相关的逻辑，而网络层将处理所有与*网络相关*的事情。
- en: 'You can see what the final structure will look like by taking a look at the
    GitHub repository of this book: [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看本书的GitHub仓库来查看最终结构：[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api)。
- en: The initial requirement for this chapter is that there is a route where we can
    perform a GET request and receive a list of museums in JSON format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的初始要求是有一个路由，我们可以在此路由上执行GET请求，并接收以JSON格式表示的博物馆列表。
- en: We will start in the controller's file (`src/museums/controller.ts`) and write
    the required business logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在控制器文件（`src/museums/controller.ts`）中开始编写所需的业务逻辑。
- en: 'This is how the folder''s structure should look like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构应该如下所示：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is our starting point. Everything that is related to museums will be located
    inside the `museums` folder, and we'll call it a module. The `controller` file
    will host the business logic, the `repository` file will host data fetching capabilities,
    and the `types` file will be where our types will be located.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始的地方。与博物馆有关的所有内容都将在`museums`文件夹内，我们将称之为一个模块。`controller`文件将托管业务逻辑，`repository`文件将托管数据获取功能，而`types`文件将位于我们的类型。
- en: Now, let's start coding!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写代码！
- en: Developing the business logic
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写业务逻辑
- en: We previously stated that our business logic is the most important part of our
    application. Even though ours will be super simple for now, that's what we'll
    develop first.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，我们的业务逻辑是应用程序最重要的部分。尽管我们的业务逻辑现在非常简单，但这是我们首先开发的。
- en: 'Since we''ll be using TypeScript for our application, let''s create the interface
    that will define our `Museum` object. Follow these steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用TypeScript来编写我们的应用程序，让我们创建一个定义`Museum`对象的接口。按照以下步骤操作：
- en: 'Go into `src/museums/types.ts` and create a type that defines a `Museum`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`src/museums/types.ts`，并创建一个定义`Museum`的类型：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure it is exported as we'll be using this across other files.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保它被导出，因为我们将跨其他文件使用此文件。
- en: Now that we know the type, we must create some business logic to get a list
    of museums.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经知道了类型，我们必须创建一些业务逻辑来获取博物馆列表。
- en: 'Inside `src/museums/types.ts`, create an interface that will define `MuseumController`.
    It should contain a method that lists all the museums:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums/types.ts`中，创建一个接口，定义`MuseumController`。它应该包含一个列出所有博物馆的方法：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside `src/museums/controller.ts`, create a class that will act as the controller.
    It should contain a function named `getAll`. In the future, this is where the
    business logic will live, but for now, we can just return an empty array:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums/controller.ts`中，创建一个类，作为控制器。它应该包含一个名为`getAll`的函数。将来，这里将存放业务逻辑，但现在，我们只需返回一个空数组：
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We could use this to directly access the database and get certain records. However,
    since we want to be able to have our business logic isolated and not coupled with
    other parts of the application, we won't do this.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以用这个直接访问数据库并获取某些记录。然而，由于我们希望能够使我们的业务逻辑孤立，并且不与应用程序的其他部分耦合，所以我们不会这样做。
- en: On top of that, we also want our business logic to be testable in isolation,
    without depending on a connection to a database or a server. To achieve this,
    we can't access our data source directly from our controller. Later, we will create
    an abstraction that will be responsible for getting those records from the database.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还希望我们的业务逻辑能够在没有数据库或服务器连接的情况下独立测试。为了实现这一点，我们不能直接从我们的控制器访问数据源。稍后，我们将创建一个抽象，它将负责从数据库获取这些记录。
- en: For now, we know that we will need to call an external module that will get
    all the museums for us it give them to our controller – it doesn't matter from
    where.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们知道我们需要调用一个外部模块，它将为我们获取所有的博物馆，并将它们交给我们的控制器——它来自哪里无关。
- en: 'Keep in mind the following software design best practice: *"Code to an interface,
    not an implementation."*'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住以下软件设计最佳实践：*"面向接口编程，而不是面向实现。"*
- en: Simply put, this quote means that we should define the module's signature and
    only then start thinking about its implementation. This vastly helps when it comes
    to designing clear interfaces.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单地说，这句话的意思是我们应该定义模块的签名，然后才开始考虑它的实现。这大大有助于设计清晰的接口。
- en: Going back to our controller, we know that the controller's `getAll` method
    will, at some point, have to call a module to get the data from a data source.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回到我们的控制器，我们知道控制器的`getAll`方法最终必须调用一个模块来从数据源获取数据。
- en: 'Inside `src/museums/types.ts`, define `MuseumRepository`, the module that will
    be responsible for getting the museums from a data source:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums/types.ts`中，定义`MuseumRepository`，这个模块将负责从数据源获取博物馆：
- en: '[PRE4]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside `src/museums/controller.ts`, add an injected class called `museumRepository`
    to the constructor:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums/controller.ts`中，向构造函数中添加一个注入的类`museumRepository`：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a file called `src/index.ts`, import the `MuseumController`, instantiate
    it, and call the `getAll` method, logging its output. For now, you can inject
    a dummy repository that just returns an empty array:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/index.ts`的文件，导入`MuseumController`，实例化它，并调用`getAll`方法，记录其输出。现在，你可以注入一个伪仓库，它只是返回一个空数组：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run it to check whether it''s working:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它以检查它是否正常工作：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's it! We just received the empty array that's coming from the dummy repository
    function!
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！我们刚刚从伪仓库函数接收到了一个空数组！
- en: With the abstraction we have created, our controller is now decoupled from the
    data source. Its dependencies are injected via a constructor, allowing us to change
    repositories without changing the controller later.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们创建的这种抽象，我们的控制器现在与数据源解耦。其依赖关系通过构造函数注入，允许我们稍后不更改控制器而更改仓库。
- en: What we just did is called **dependency inversion** – the **D** in the SOLID
    principles – and it consists of lifting up part of the dependencies to the function
    caller. This makes it very easy to test the inside functions independently, as
    we will see in [*Chapter 8*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178),
    *Testing – Unit and Integration*, where we'll cover testing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才所做的称为**依赖倒置**——SOLID原则中的**D**——它包括将部分依赖性提升到函数调用者。这使得独立测试内部函数变得非常容易，正如我们将在[*第8章*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178)*测试——单元和集成*中看到的，我们将涵盖测试。
- en: To transform what we just wrote into a fully functioning app, we need to have
    a database or something that looks like one. We need something that can store
    and retrieve a list of museums. Let's create that now.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们刚刚编写的代码转换为完全功能的应用程序，我们需要有一个数据库或类似的东西。我们需要能够存储和检索博物馆列表的东西。我们现在来创建这个东西。
- en: Developing the data accessing logic
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发数据访问逻辑
- en: While developing the controller, we noticed that we needed something that would
    be able to get the data; that is, the repository. This is the module that will
    abstract all the calls to a data source, and in this case, the data source that
    stores the museums. It will have a very well-defined set of methods, and whoever
    wants to access the data should do so through this module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发控制器的过程中，我们注意到我们需要能够获取数据；也就是说，仓库。这个模块将抽象所有对数据源的调用，在这个案例中，数据源存储博物馆。它将有一套非常明确的方法，任何想要访问数据的人都应该通过这个模块来访问。
- en: We already have part of its interface defined inside `src/museums/types.ts`,
    so let's write a class that implements it. For now, we will not connect it to
    a real database. We will use an ES6 Map as an in-memory database instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`src/museums/types.ts`中定义了其部分接口，所以让我们写一个实现它的类。现在，我们不会将它连接到真实数据库。我们将其作为内存数据库使用ES6
    Map。
- en: 'Let''s get into our repository file and start writing our data accessing logic
    by following these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入我们的仓库文件，并按照以下步骤开始编写我们的数据访问逻辑：
- en: Open the `src/museums/repository.ts` file and create a `Repository` class.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/museums/repository.ts` 文件并创建一个 `Repository` 类。
- en: 'It should have a property named `storage` that will be a JavaScript `Map`.
    The `Map` keys should be strings and the values should be objects of the `Museum`
    type:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该有一个名为 `storage` 的属性，这将是一个 JavaScript `Map`。`Map` 的键应该是字符串，值应该是 `Museum` 类型的对象：
- en: '[PRE8]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are using TypeScript generics to set the types of our `Map`. Note that we've
    imported the `Museum` interface from the museum controller, as well as `MuseumRepository`,
    which is implemented by our class.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在使用 TypeScript 泛型来设置我们的 `Map` 类型。请注意，我们引入了来自博物馆控制器 的 `Museum` 接口，以及由我们的类实现的
    `MuseumRepository`。
- en: Now that the *database* is "ready", we have to expose certain methods so that
    people can interact with it. The requirement from the previous section is that
    we can get all the records from the database. Let's implement that next.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在“数据库”已经“就绪”，我们必须暴露某些方法，这样人们就可以与它交互。上一节的要求是我们可以从数据库中获取所有记录。让我们接下来实现它。
- en: 'Inside the repository class, create a method named `getAll`. It should be responsible
    for returning all the records in our `storage` `Map`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仓库类内部，创建一个名为 `getAll` 的方法。它应该负责返回我们 `storage` `Map` 中的所有记录：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `src/museums/index.ts` file that exports the museum''s controller
    and repository:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `src/museums/index.ts` 的文件，该文件导出博物馆的控制器 和仓库：
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To remain consistent, we'll need go to all the previous imports that were importing
    from a file that isn't `src/museums/index.ts` and change them so that they're
    only importing things from this file.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了保持一致性，我们需要去所有之前从不是 `src/museums/index.ts` 的文件导入的导入，并更改它们，使它们只从这个文件导入东西。
- en: 'Update the `controller.ts` and `repository.ts` imports to import from the `index`
    file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `controller.ts` 和 `repository.ts` 的导入更新为从 `index` 文件导入：
- en: '[PRE11]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You've probably guessed what we must do next… Do you remember the end of the
    previous section, where we injected a dummy function into the museum's controller,
    which was returning an empty array? Let's go back to this and use the logic we
    just wrote.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经猜到我们接下来必须做什么了…… 你还记得上一节的末尾，我们在博物馆控制器中注入了一个返回空数组的伪函数吗？让我们回到这里并使用我们刚刚编写的逻辑。
- en: 'Go back to `src/index.ts`, import the `Repository` class we''ve just developed
    and inject it into the `MuseumController` constructor:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `src/index.ts`，导入我们刚刚创建的 `Repository` 类，并将其注入到 `MuseumController` 构造函数中：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's add a fixture to our "database" so that we can check it if it's actually
    printing something.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们向我们的“数据库”添加一个 fixture，这样我们就可以检查它是否实际上正在打印一些内容。
- en: Access the storage property in `museumRepository` and add a fixture to it.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `museumRepository` 中的存储属性并为其添加一个 fixture。
- en: 'This is currently an anti-pattern as we''re directly accessing the module''s
    database, but we''ll create a method so that we can add fixtures properly later:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这目前是一个反模式，因为我们直接访问模块的数据库，但我们将创建一个方法，以便我们以后可以正确添加 fixtures：
- en: '[PRE13]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s run our code again:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行我们的代码：
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With that, the connection to our database is working, as we can see by the printed
    fixture.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这个，我们的数据库连接就可以工作了，正如我们通过打印的 fixture 所看到的那样。
- en: The abstractions we created in the previous section enabled us to change the
    data source without changing the controller. This is one of the advantages of
    the architecture we are using.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中创建的抽象使我们能够在不更改控制器的情况下更改数据源。这是我们正在使用的架构的一个优点。
- en: Now, if we recall our initial requirement, we can confirm that we are halfway
    there. Our business logic to satisfy the use case has been created – we're just
    missing the HTTP part.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们回顾一下我们的初始需求，我们可以确认我们已经完成了一半。我们已经创建了满足用例的业务逻辑——我们只是缺少 HTTP 部分。
- en: Creating the web server
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建网络服务器
- en: 'Now that we have our functionality in place, we need to expose it via a web
    server. Let''s use what we''ve learned from the standard library to create it
    by following these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的功能，我们需要通过一个网络服务器来暴露它。让我们使用我们从标准库中学到的知识来创建它，并按照以下步骤进行：
- en: 'Create a file named `index.ts` inside the `src/web` folder and add the logic
    there to create a server. We can copy and paste it from the previous chapter''s
    exercise:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/web` 文件夹中创建一个名为 `index.ts` 的文件，并在那里添加创建服务器的逻辑。我们可以从上一章的练习中复制和粘贴它：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since we want our application to be easily configurable, we don't want `port`
    to be hardcoded here but to be configurable from the outside. We need to export
    this server creation logic as a function.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们希望应用程序易于配置，我们不希望`port`在这里是硬编码的，而是可以从外部配置的。我们需要将这个服务器创建逻辑作为一个函数导出。
- en: 'Wrap the server logic creation inside a function that receives the configuration
    and `port` as an argument:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务器逻辑创建包裹在一个函数中，该函数接收配置和`port`作为参数：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make this function''s parameters an `interface`. This will help us in terms
    of documentation and will also add type safety and static checks:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个函数的参数改为`interface`。这将有助于我们的文档，同时也会增加类型安全和静态检查：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have configured the web server, we can think of using it for our
    use case.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Web服务器，我们可以考虑将其用于我们的用例。
- en: 'Go back to `src/index.ts`, import `createServer`, and use it to create a server
    running on port `8080`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/index.ts`，导入`createServer`，并使用它创建一个在端口`8080`上运行的服务器：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run it and see if it works:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它，看看它是否正常工作：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we can see that we have a log stating that the server is running and a
    log of the result from the previous section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到有一个日志记录服务器正在运行，以及来自上一节的日志结果。
- en: 'Now, we can test the web server with `curl` to guarantee it is working:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用`curl`测试Web服务器，以确保它正在工作：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, it works – we have some pretty basic logic that still doesn't
    satisfy our requirements but that spins up a web server. What we'll do next is
    connect this web server with the logic we wrote previously.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它起作用了——我们有一些相当基础的逻辑，但这仍然不能满足我们的要求，却能启动一个Web服务器。我们接下来要做的就是将这个Web服务器与之前编写的逻辑连接起来。
- en: Wiring the web server to the business logic
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Web服务器与业务逻辑连接
- en: We're pretty close to finishing what we planned to do at the beginning of this
    chapter. We currently have a web server and some business logic; it is the connection
    that is missing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经非常接近完成本章开始时计划要做的内容。我们目前有一个Web服务器和一些业务逻辑；缺少的是它们之间的连接。
- en: One quick way to connect both things would be to import the controller directly
    on `src/web/index.ts` and use it there. Here, the application would have the desired
    behavior and currently, that doesn't bring any problems.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将两件事连接起来的一个快速方法就是在`src/web/index.ts`上直接导入控制器并在此处使用它。在这里，应用程序将具有期望的行为，目前这样做没有任何问题。
- en: However, since we are thinking of an app architecture that can grow without
    many issues, we won't do this. This is because it would make it very hard to test
    our web logic in isolation, thus compromising one of our principles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们考虑的是一个可以无需太多问题就能扩展的应用程序架构，所以我们不会这样做。这是因为这将使我们的Web逻辑在隔离测试中变得非常难以实现，从而违背了我们的一条原则。
- en: If we import the controller directly from the web server, every time we call
    the `createServer` function in a testing environment, it will automatically import
    and call the methods from the `MuseumController` and that's not what we want.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接从Web服务器中导入控制器，每次在测试环境中调用`createServer`函数时，它将自动导入并调用`MuseumController`中的方法，这不是我们想要的结果。
- en: We will use dependency inversion once more to send the controller's methods
    to the web server. If this still seems too abstract, don't worry – we'll get to
    the code in a minute.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用依赖倒置将控制器的函数发送到Web服务器。如果这仍然看起来过于抽象，不用担心——我们马上就会看到代码。
- en: To make sure we aren't forgetting our initial goal, what we want is for, when
    a user does a `GET` request to `/api/museums`, our web server to return a list
    of museums.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们没有忘记我们的初始目标，我们想要的是，当用户对`/api/museums`执行`GET`请求时，我们的Web服务器能够返回一个博物馆列表。
- en: Since we're doing this as an exercise, we will not use a routing library just
    yet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行这项练习，所以我们暂时不会使用路由库。
- en: We just want to add a basic check to ensure that the URL and method of the request
    are the ones we want to answer to. If they are, we want to return the list of
    museums.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是想添加一个基本检查，以确保请求的URL和方法是我们想要回答的。如果是，我们想返回博物馆的列表。
- en: 'Let''s go back to the `createServer` function and add our route handler:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`createServer`函数并添加我们的路由处理程序：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ve added a basic check for the request URL and method and a different response
    when they match the initial requirement. Let''s run the code to see how it behaves:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为请求URL和方法添加了一个基本检查，并在它们符合初始要求时返回不同的响应。运行代码看看它的行为如何：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, test it with `curl`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，用`curl`测试它：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It works – cool!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它起作用了——太棒了！
- en: Now comes the part where we define what we need in order to satisfy this request
    as an interface.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个接口，以满足这个请求所需的内容。
- en: 'We ultimately require a function that returns a list of museums to be injected
    into our server. Let''s add that inside the `CreateServerDependencies` interface
    by following these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终需要一个函数，它返回一个博物馆列表，然后将其注入到我们的服务器中。让我们按照以下步骤在`CreateServerDependencies`接口中添加该功能：
- en: 'Back inside `src/web/index.ts`, add `MuseumController` as a dependency to the
    `createServer` function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/web/index.ts`中，将`MuseumController`作为`createServer`函数的一个依赖项：
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the `getAll` function from the museum''s controller to get a list of all
    the museums and respond to the request:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从博物馆控制器中调用`getAll`函数以获取所有博物馆的列表并响应请求：
- en: '[PRE25]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Go back to `src/index.ts`, which is where we are calling the `createServer`
    function, and send the `getAll` function from `MuseumController`. You can also
    remove the code that directly calls the controller method from the previous section
    as it is of no use at the moment:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/index.ts`，这是我们调用`createServer`函数的地方，并向`MuseumController`发送`getAll`函数。你也可以删除上一节直接调用控制器方法的代码，因为现在它没有任何用处：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the application again:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用程序：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Send a request to http://localhost:8080/api/museums; you will get a list of
    museums:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向http://localhost:8080/api/museums发送请求；你会得到一个博物馆列表：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And there it is – we're getting the list of museums!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们得到了博物馆列表！
- en: We've just accomplished the goal of this section; that is, to connect our business
    logic to the web server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了本节的任务，那就是将我们的业务逻辑连接到web服务器。
- en: Note how we've enabled the controller methods to be injected instead of the
    web server being the one that directly imports it. This was made possible because
    we used dependency inversion. This is something we'll keep doing throughout this
    book, whenever we want to decouple and increase the testability of modules and
    functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使控制器方法可以被注入，而不是web服务器直接导入它。这之所以可能，是因为我们使用了依赖倒置。这是我们在这本书中会不断做的事情，无论何时我们想要解耦模块和函数，并提高它们的测试性。
- en: While doing our mental exercise to test the coupling of our code, when we wanted
    to use the current business logic with a different delivery mechanism, such as
    a CLI, nothing impeded us. We could still reuse the same controllers and repositories.
    This means that we're doing a nice job of using abstractions to decouple our business
    logic from the application logic.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行代码耦合的思维锻炼时，当我们想要使用不同的交付机制（如CLI）来使用当前的业务逻辑时，没有任何阻碍。我们仍然可以重用相同的控制器和存储库。这意味着我们很好地使用了抽象来将业务逻辑与应用程序逻辑解耦。
- en: Now that we have the baseline of our application architecture and folder structure,
    and we also understand the *whys* behind it, we can start looking at the utilities
    that might help us build it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了应用程序架构和文件结构的基础，并且也理解了背后的原因，我们可以开始查看可能帮助我们构建它的工具。
- en: In the next section, we will have a look at the current HTTP frameworks that
    exist in the Deno community. We won't spend much time doing this, but we want
    to understand the pros and cons of each one and ultimately choose one to help
    us with the rest of our journey.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看Deno社区中现有的HTTP框架。我们不会花太多时间在这方面，但我们希望了解每个框架的优缺点，并最终选择一个来帮助我们完成剩余的旅程。
- en: Exploring Deno HTTP frameworks
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Deno HTTP框架
- en: When you're building an application that's more complex than a simple tutorial,
    and if you don't want to take a purist approach, you are most likely going to
    use third-party software.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个比简单教程更复杂的应用程序时，如果你不想采取纯粹的方法，你很可能会使用第三方软件。
- en: Obviously, this is not something particular to Deno. Even though there are communities
    that are keener on using third-party modules than others, all the communities
    use third-party software.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不仅仅是Deno特有的。尽管有些社区比其他社区更愿意使用第三方模块，但所有社区都在使用第三方软件。
- en: We could go over the reasons why people do or don't do this, but the more popular
    reasons are always to do with reliability and time management. This might be because
    you want to use software that is battle tested instead of building it yourself.
    Sometimes, it is a mere time management question of not wanting to rewrite something
    that has already been created.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以讨论人们为什么这样做或不做，但更常见的原因总是与可靠性和时间管理有关。这可能是因为你想使用经过实战测试的软件，而不是自己构建它。有时，这只是一个时间管理问题，即不想重新编写已经创建的东西。
- en: One important thing we have to say is that we must be extremely cautious in
    terms of how many of the applications we're building are coupled with third-party
    software. We don't mean that you should try to reach for the utopia of having
    everything completely decoupled, especially because that introduces other problems
    and lots of indirection. What we're saying is that we should be very aware of
    the cost of bringing a dependency into our code and the trade-offs it introduces.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须说的一件重要事情是我们必须在对构建的应用程序进行耦合第三方软件时非常谨慎。我们并不是说你应该试图达到完全解耦的乌托邦，尤其是因为这会引入其他问题和很多间接性。我们要说的是，我们应该非常清楚将依赖项引入我们代码中的成本以及它引入的权衡。
- en: In the first section of this chapter, we built the foundations for a web application
    that we'll be adding features to throughout the rest of this book. In its current
    state, it is still very small, so it doesn't have any dependencies other than
    the standard library.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们构建了一个web应用的基础，我们将在本书的其余部分向其添加功能。在其当前状态下，它仍然非常小，所以它除了标准库之外没有任何依赖。
- en: In that application, we did a couple of things that we don't believe will scale
    well, such as defining routes by matching URLs and HTTP methods using plain `if`
    statements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在该应用中，我们做了一些我们相信不太容易扩展的事情，比如通过使用普通的`if`语句来匹配URL和HTTP方法来定义路由。
- en: As the application grows, it is likely that we will have more advanced needs.
    These needs can go from dealing with an HTTP request body in different formats
    to having more complex routing systems, handling headers and cookies, or connecting
    to a database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，我们很可能会需要更高级的功能。这些需求可能从以不同格式处理HTTP请求体，到拥有更复杂的路由系统，处理头部和cookies，或者连接到数据库。
- en: Because we don't believe in reinventing the wheel when it comes to developing
    applications, we will analyze a few libraries and frameworks that currently exist
    in the Deno community and are focused on creating web applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不相信在开发应用程序时重新发明轮子，所以我们将分析几个目前存在于Deno社区中，并专注于创建web应用程序的库和框架。
- en: We will take a general look at the existing solutions and explore their features
    and approaches.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对现有的解决方案进行一般性了解，并探索它们的功能和方法。
- en: In the end, we'll choose the one we believe offers the best trade-off for our
    use case.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将选择我们认为在我们用例中提供最佳权衡的那个。
- en: What alternatives exist?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有哪些替代方案？
- en: At the time of writing, there are a few third-party packages that offer a great
    amount of functionality to create web applications and APIs. Some of them are
    heavily inspired by very popular Node.js packages, such as Express.JS, Koa, or
    hapi.js, while others are inspired by other frameworks outside of JavaScript,
    such as Laravel, Flask, and so on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，有一些第三方包提供了大量功能来创建web应用程序和API。其中一些深受非常流行的Node.js包（如Express.JS、Koa或hapi.js）的启发，而其他则受到JavaScript之外的其他框架（如Laravel、Flask等）的启发。
- en: We'll be exploring four of them that are quite popular and well-maintained at
    the time of writing. Keep in mind since as Deno and the mentioned packages are
    evolving quickly, this might change over time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索其中的四个，它们在写作时非常流行且维护良好。请注意，由于Deno和提到的包正在快速发展，这可能会随时间而变化。
- en: Important note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There is a great article by Craig Morten that does a very thorough analysis
    and exploration of the available libraries. I heavily recommend this article if
    you want to find out more ([https://dev.to/craigmorten/what-is-the-best-deno-web-framework-2k69](https://dev.to/craigmorten/what-is-the-best-deno-web-framework-2k69)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Craig Morten写了一篇非常好的文章，对可用的库进行了非常彻底的分析和解构。如果你想了解更多，我强烈推荐这篇文章（[https://dev.to/craigmorten/what-is-the-best-deno-web-framework-2k69](https://dev.to/craigmorten/what-is-the-best-deno-web-framework-2k69)）。
- en: We will try to be diverse when it comes to the packages we're going to explore.
    There are some that provide more abstractions and structure than others, and some
    that provide not much more than mere utility functions and composable functionality.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试在要探索的包方面保持多样性。有一些提供了比其他更抽象和结构化的内容，而有一些提供的不仅仅是简单的实用函数和可组合功能。
- en: 'The packages we''ll explore are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的包如下：
- en: Drash
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drash
- en: Servest
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servest
- en: Oak
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oak
- en: Alosaur
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alosaur
- en: Let's look at each one separately.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看它们。
- en: Drash
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Drash
- en: Drash ([https://github.com/drashland/deno-drash](https://github.com/drashland/deno-drash))
    aims to be different from the existing Deno and Node.js frameworks. This motivation
    is explicitly mentioned by its maintainer, Edward Bebbington, on a blog post where
    he compares Drash to other alternatives and explains the motivations behind its
    creation ([https://dev.to/drash_land/what-makes-drash-different-idd](https://dev.to/drash_land/what-makes-drash-different-idd)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Drash ([https://github.com/drashland/deno-drash](https://github.com/drashland/deno-drash))
    旨在与现有的Deno和Node.js框架不同。这一动机在其维护者Edward Bebbington的一篇博客文章中明确提到，他比较了Drash与其他替代方案，并解释了其创建的动机
    ([https://dev.to/drash_land/what-makes-drash-different-idd](https://dev.to/drash_land/what-makes-drash-different-idd)).
- en: These motivations are great, and the inspiration of very popular software tools
    such as Laravel, Flask, and Tonic justifies most of these decisions. Some of the
    similarities are also noticeable the moment you look at Drash's code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动机很好，灵感来自于非常流行的软件工具如Laravel、Flask和Tonic，这些决策大部分得到了证实。你一查看Drash的代码，就能发现一些相似之处。
- en: 'It really offers a different approach compared to libraries such as Express.js
    or Koa, as the documentation states:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与Express.js或Koa等库相比，它确实提供了一种不同的方法，正如文档所述：
- en: '"Where Deno is different than Node.js, Drash aims to be different than Express
    or Koa, utilizing resources and a full class-based system."'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “Deno与Node.js的不同之处在于，Drash旨在与Express或Koa不同，利用资源并采用完整的类式系统。”
- en: 'The main differences are that Drash doesn''t want to provide an application
    object where developers can then register their endpoints, like some popular Node.js
    frameworks do. It sees endpoints as resources that are defined within a class,
    similar to the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于，Drash不想提供应用程序对象，让开发者可以注册他们的端点，像一些流行的Node.js框架那样。它将端点视为在类中定义的资源，与以下内容相似：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These resources are then plugged into Drash''s application later:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源随后被插到Drash的应用程序中：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we can directly state it is, in fact, different from the other frameworks
    we've mentioned. These differences are deliberate and plan to please developers
    that are fans of this approach and the problems it solves for other frameworks.
    Those use cases are very well-explained in Drash's documentation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以直接声明它实际上与我们在上面提到的其他框架不同。这些差异是有意的，旨在取悦喜欢这种方法并解决其他框架问题的开发者。这些用例在Drash的文档中解释得非常清楚。
- en: Drash's resource-based approach is definitely something to keep an eye on. Its
    inspiration from very mature pieces of software such as Flask and Tonic definitely
    brings something to the table and proposes a solution that helps solve some of
    the common problems unopinionated tools have. The documentation is complete and
    easy to understand, which makes it a great asset to have when it comes to choosing
    a tool for building your application with.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Drash基于资源的方法绝对值得关注。它从非常成熟的软件如Flask和Tonic得到的灵感确实为桌面带来了东西，并提出了一种解决方案，有助于解决无观点工具的常见问题。文档完整且易于理解，这使得在选择构建应用程序的工具时，它成为了一个很好的资产。
- en: Servest
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Servest
- en: Servest ([https://servestjs.org/](https://servestjs.org/)) calls itself a *"progressive
    HTTP server for Deno."*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Servest ([https://servestjs.org/](https://servestjs.org/)) 自称为适用于Deno的*“渐进式HTTP服务器”*。
- en: One of the reasons it was created was because its author wanted to make some
    APIs from the standard library's HTTP module easier to use and experiment with
    new features. The latter is something that is really hard to do on a standard
    library that needs stability.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它被创建的一个原因是因为其作者希望让标准库的HTTP模块中的一些API更容易使用，并实验新特性。后者是在需要稳定性的标准库中真正难以实现的事情。
- en: Servest directly focuses on this comparison with the standard library's HTTP
    module. One of its main objectives, which is directly stated on the project's
    home page, is making it easy to migrate from the standard library's HTTP module
    to Servest. This summarizes Servest's vision well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Servest直接关注与标准库的HTTP模块的比较。其项目主页上直接声明的一个主要目标，就是使其容易从标准库的HTTP模块迁移到Servest。这很好地总结了Servest的愿景。
- en: 'API-wise, Servest is very similar to what we''re used to from Express.js and
    Koa. It provides an application object where routes can be registered. You can
    also recognize obvious influences from what is provided by the standard library
    module, as we can see in the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从API角度来看，Servest与我们从Express.js和Koa熟悉的东西非常相似。它提供了一个应用程序对象，可以在其中注册路由。你也可以看到明显受到了标准库模块所提供内容的启发，正如我们在以下代码片段中所见：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can recognize the application object from well-known Node.js libraries and
    the request object from the standard library, among other things.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别出知名Node.js库中的应用对象和标准库中的请求对象，以及其他内容。
- en: On top of this functionality, Servest also provides common features, such as
    support for directly rendering JSX pages, serving static files, and authentication.
    The documentation is also clear and full of examples.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，Servest还提供了诸如直接渲染JSX页面、服务静态文件和认证等常见功能，文档也非常清晰，充满了示例。
- en: Servest tries to leverage knowledge and familiarity from Node.js users while
    using the benefits provided by Deno in a promising mix. Its progressive nature
    brings very nice features to the table, with the promise to make developers more
    productive than when they're using the standard library HTTP package.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Servest试图利用Node.js用户的知识和熟悉度，同时利用Deno提供的好处，这是一个有希望的混合。其渐进性质为桌面带来了非常漂亮的功能，承诺会让开发者的生产力比使用标准库HTTP包时更高。
- en: Oak
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oak
- en: Oak ([https://oakserver.github.io/oak/](https://oakserver.github.io/oak/)) is
    currently the most popular Deno library when it comes to creating web applications.
    Its name derives from a play on words of Koa, a very popular Node.js middleware
    framework and Oak's main inspiration.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Oak ([https://oakserver.github.io/oak/](https://oakserver.github.io/oak/)) 目前是创建web应用程序的最受欢迎的Deno库。它的名字来源于Koa的词语游戏，Koa是一个非常流行的Node.js中间件框架和Oak的主要灵感来源。
- en: Due to its heavy inspirations, it is of no surprise that its APIs resemble Koa
    by using asynchronous functions and a context object. Oak also includes a router,
    also inspired by `@koa/router`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其深受启发，其API使用异步函数和上下文对象与Koa相似并不令人意外。Oak还包括一个路由器，也是受`@koa/router`启发的。
- en: 'If you know Koa, the following code might look very familiar to you:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Koa，下面的代码可能看起来会很熟悉：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For those of you who are not familiar with Koa, we'll explain it in brief, since
    understanding it will help you understand Oak.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉Koa的人来说，我们会简要地解释一下，因为理解它将帮助你理解Oak。
- en: Koa provides a minimal and unopinionated approach by using modern JavaScript
    features. One of the initial reasons Koa was created (by the same team who created
    Express.js) was that its creator wanted to create a framework that would leverage
    modern JavaScript features, as opposed to Express, which was created at the beginning
    of Node.js' lifetime.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Koa通过使用现代JavaScript特性提供了一个最小化和无观点的方法。Koa最初被创建（由创建Express.js的同一团队）的原因之一是，其创作者想要创建一个利用现代JavaScript特性的框架，而不是像Express那样，Express是在Node.js的早期创建的。
- en: The team wanted to use new features such as promises and async/await, and then
    solve challenges that developers faced with Express.JS. Most of these challenges
    were related to error handling, dealing with callbacks, and the lack of clarity
    of some APIs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 团队想要使用诸如promises和async/await等新特性，然后解决开发者在使用Express.JS时面临的挑战。其中大多数挑战与错误处理、处理回调和某些API的不清晰有关。
- en: Oak's popularity doesn't come out of nowhere, and its current distance from
    the alternatives in terms of GitHub stars reflects that. By themselves, GitHub
    stars don't mean much, but together with opened and closed issues, the number
    of releases, and so on, we can see why people are trusting it. Of course, this
    familiarity plays a big role in terms of this package's popularity.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Oak的流行并非空穴来风，它在GitHub上的星级与其他选项的距离反映了这一点。单凭GitHub的星级并不能说明什么，但结合打开和关闭的问题、发布的版本等，我们可以看出人们为什么信任它。当然，这种熟悉度在的这个包的流行中起了很大的作用。
- en: In its current state, Oak is a solid (in terms of Deno's community standards)
    way to build web applications as it provides a very clear and direct set of features.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在其当前状态下，Oak是一个构建web应用程序的固体（就Deno的社区标准而言），因为它提供了一组非常清晰和直接的功能。
- en: Alosaur
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Alosaur
- en: Alosaur ([https://github.com/alosaur/alosaur](https://github.com/alosaur/alosaur))
    is a Deno web application framework based on decorators and classes. It is similar
    to Drash in a way, even though the final approaches are quite different.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Alosaur ([https://github.com/alosaur/alosaur](https://github.com/alosaur/alosaur))
    是一个基于装饰器和类的Deno web应用程序框架。它在某种程度上与Drash相似，尽管最后的实现方式有所不同。
- en: Among its main features, Alosaur provides things such as template rendering,
    dependency injection, and OpenAPI support. These features have been added on top
    of what is a standard for all the alternatives we presented here, such as middleware
    support and routing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在其主要功能中，Alosaur提供了诸如模板渲染、依赖注入和OpenAPI支持等功能。这些功能是在所有我们在这里介绍的替代方案的标准之上添加的，如中间件支持和路由。
- en: 'This framework''s approach is to define controllers by using classes and define
    their behavior using decorators, as shown in the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架的方法是使用类定义控制器，并使用装饰器定义其行为，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we can see that the application's instantiation has similarities with
    Drash. It also uses TypeScript decorators to declare a framework's behavior.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到应用程序的实例化与Drash有相似之处。它还使用TypeScript装饰器来声明框架的行为。
- en: Alosaur takes a different approach compared to most of the aforementioned libraries,
    mainly because it doesn't try to be minimal. Instead, it provides a set of features
    that prove to be useful when it comes to building certain types of applications.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Alosaur与前面提到的大多数库采取了不同的方法，主要原因在于它并不试图简约。相反，它提供了一组在构建某些类型的应用程序时证明有用的特性。
- en: We decided to have a look at it not only because it does what it is supposed
    to do, but also because it has some features that are not so common in the Node.js
    and Deno world. This includes things such as dependency injection and OpenAPI
    support, which are not offered by any other of the presented solutions. At the
    same time, it keeps features such as template rendering, which is something that
    might be familiar to you from Express.JS but not so familiar in more modern frameworks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定对其进行研究，不仅因为它能完成预期的工作，还因为它在Node.js和Deno领域拥有的一些不常见的特性。这包括诸如依赖注入和OpenAPI支持等功能，这是其他展示的解决方案所没有的。同时，它保留了诸如模板渲染等特性，这可能你们从Express.JS中熟悉，但在更现代的框架中就不那么熟悉了。
- en: The final solution is very promising and complete in the sense of the functionalities
    it provides. It is definitely something to keep an eye on so that you can see
    how it evolves.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最终解决方案在提供的功能方面非常有前途且完整。这绝对是值得关注的东西，这样你就可以看到它是如何发展的。
- en: The verdict
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: After looking at all the presented solutions and recognizing that all of them
    have their merits, we've decided to go with Oak for the rest of this book.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视了所有展示的解决方案并认识到它们都有优点之后，我们决定在本书的剩余部分使用Oak。
- en: This doesn't mean that this book will focus on Oak. It will not, as it will
    only handle HTTP and routing. Oak's minimal approach will fit very nicely with
    what we will be doing next, helping us to incrementally create features without
    it getting in the way. The fact that it is also one of the most stable, maintained,
    and popular options in the Deno community has an obvious influence on our decision.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着本书将重点介绍Oak。不会的，因为它只会处理HTTP和路由。Oak的简约方法将与我们接下来要做的非常吻合，帮助我们逐步创建功能，而不会让它成为障碍。它还是Deno社区中最稳定、维护良好和最受欢迎的选项之一，这对我们的决定有明显的影响。
- en: Be aware that this decision doesn't mean that what we will learn in the next
    few chapters can't be done in any of the alternatives. In fact, because of the
    way we will organize our code and architecture, we believe that it would be easy
    to keep up with most of the things we are going to do using a different framework.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个决定并不意味着我们将在接下来的几章中学到的内容不能在任何替代方案中完成。事实上，由于我们将如何组织和架构我们的代码，我们相信很容易就能跟上使用不同框架我们要做的绝大多数事情。
- en: Throughout the rest of this book, we will use other third-party modules that
    can help us build the functionalities we've proposed. The reason we've decided
    to have a deeper look at the libraries that deal with HTTP is because this is
    the fundamental delivery mechanism for the application we'll be developing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将使用其他第三方模块来帮助我们构建我们提出的功能。我们决定深入研究处理HTTP的库，原因是这是我们即将开发的应用程序的基本交付机制。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we finally started building an application that leverages our
    knowledge of Deno. We started by considering the main goals we will have when
    we build an application and define its architecture. These goals will set the
    tone for most of our conversations regarding architecture and structure throughout
    this book as we'll keep going back to them, ensuring that we're in line with them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于开始构建一个利用我们对Deno知识的应用程序。我们首先考虑了构建应用程序时我们将拥有的主要目标及其架构。这些目标将为我们本书中关于架构和结构的多数对话定下基调，因为我们将会不断回顾它们，确保我们与它们保持一致。
- en: 'We started by creating our folder structure and trying to achieve our very
    first application goal: have an HTTP endpoint that lists museums. We did this
    by building the simple business logic first and progressed while needs such as
    separation of concerns and isolation and responsibilities arose. These needs derived
    our architecture, proving why the layers and abstractions we created are useful
    and demonstrating what they add.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了我们的文件结构，并试图实现我们第一个应用程序目标：拥有一个列出博物馆的HTTP端点。我们先构建了简单的业务逻辑，并在需要关注分离和职责隔离等需求时逐步推进。这些需求定义了我们的架构，证明了我们所创建的层和抽象的好处，并展示了它们所提供的价值。
- en: 'By having the responsibilities and the module''s interfaces well-defined, we
    understood that we could temporarily build our application by using an in-memory
    database, which we did. It was possible to build the application to fit this chapter''s
    requirement with that, and layer separation allows us to come back later and change
    it to a proper persistency layer without any issues. After defining the business
    and data accessing logic, we created a web server with the standard library that
    worked as a delivery mechanism. After creating a very rudimentary routing system,
    we plugged in the business logic we built previously and satisfied the main requirement
    for this chapter: having an application that returns a list of museums.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明确责任和模块接口，我们理解到我们可以暂时使用内存数据库来构建我们的应用程序，这就是我们所做的。借助这种方法，我们能够构建出符合本章要求的应用程序，并且层次分离允许我们稍后回来，无需任何问题地将它更改为一个适当的持久层。在定义了业务和数据访问逻辑之后，我们使用标准库创建了一个Web服务器作为交付机制。在创建了一个非常简单的路由系统之后，我们插入了之前构建的业务逻辑，满足了本章的主要要求：拥有一个返回博物馆列表的应用程序。
- en: We did all of this without creating a direct coupling between the business logic,
    the data fetching, and the delivery layers. This is something we believe will
    be very useful as we start adding complexity, extending our application, and adding
    tests to it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在不创建业务逻辑、数据获取和交付层之间直接耦合的情况下做到了这一切。这是我们认为当我们开始添加复杂性、扩展我们的应用程序并向其添加测试时将非常有用的东西。
- en: This chapter wraps up by having a look at the HTTP frameworks and libraries
    that currently exist in the Deno community and understanding their differences
    and approaches. Some of them use approaches that are familiar to Node.js users,
    while others deeply use TypeScript and its features to create a more structured
    web application. By looking at the four currently available solutions, we learned
    what is being developed in the community and the directions they might go in.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过查看Deno社区目前存在的HTTP框架和库，并理解它们之间的差异和方法来结束。其中一些使用对Node.js用户熟悉的方法，而其他则深入使用TypeScript及其特性来创建更具结构的Web应用程序。通过查看四个目前可用的解决方案，我们了解到了社区正在开发的内容以及他们可能采取的方向。
- en: We ended up choosing Oak, a very minimal and reasonably mature solution, to
    help us solve the routing and HTTP challenges we'll come across in the rest of
    this book.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终选择了Oak，这是一个非常最小化和相对成熟解决方案，以帮助我们解决在本书剩余部分遇到的路由和HTTP挑战。
- en: In the next chapter, we'll start adding Oak to our code base, together with
    useful features such as authentication and authorization, using concepts such
    as middleware, and growing our application so that it achieves the goals we set
    ourselves up to complete.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始将Oak添加到我们的代码库中，并添加一些有用特性，如认证和授权，使用中间件等概念，并使我们的应用程序达到我们设定的目标。
- en: Let's go!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
