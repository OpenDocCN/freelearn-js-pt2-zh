- en: Chapter 5. Data, Meteor Style!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。数据，Meteor风格！
- en: We've nearly completed the Lending Library application, without having to worry
    much about how our data is being stored. Meteor's data caching and synching methodology
    is intentionally built to make that part of building the application as simple
    as possible, so that instead of spending a lot of time messing around with database
    connections, queries, and caching, you can concentrate on writing a great program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近完成借阅图书馆应用程序的开发，而无需过多担心我们的数据是如何被存储的。Meteor的数据缓存和同步方法故意构建，以使应用程序这部分尽可能简单，这样你就可以集中精力编写伟大的程序，而不是花很多时间处理数据库连接、查询和缓存。
- en: We do want to go over the methodology, however, and make sure we have a solid
    understanding of how Meteor handles data, so we can perform some common optimizations,
    and build our applications even more quickly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实想回顾一下方法，并确保我们有一个坚实的基础，了解Meteor如何处理数据，这样我们就可以进行一些常见的优化，并且更快地构建我们的应用程序。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: MongoDB and document-oriented storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB和文档导向存储
- en: Broadcasting changes – how Meteor makes your web application reactive
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播变化——Meteor如何使你的网络应用具有反应性
- en: Configuring publishers – how to streamline and protect your data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置发布者——如何优化和保护你的数据
- en: Document-oriented storage
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档导向存储
- en: Meteor uses a version of MongoDB (minimongo), to store all of the data from
    your models. It's capable of using any other NoSQL/document-oriented database,
    but MongoDB comes by default with the Meteor installation. This feature makes
    your programs much simpler and easier to write, and works really well for quick,
    lightweight data storage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor使用MongoDB的一个版本（minimongo）来存储来自你模型的所有数据。它能够使用任何其他NoSQL/文档导向数据库，但MongoDB随Meteor安装包默认提供。这个特点使得你的程序更简单、更容易编写，并且非常适合快速、轻量级的数据存储。
- en: But why not use a relational database
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，为什么不使用关系型数据库呢？
- en: Traditionally, data is stored using a relational model. The relational model,
    with all of its associated rules, relations, logic, and syntax is an integral
    and invaluable part of modern computing. The rigid structure of a relational database,
    with exact requirements for each record, relation, and association, provides us
    with quick searches, scalability, and the possibility for deep analytics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，数据是使用关系模型进行存储的。关系模型，以及它所有的相关规则、关系、逻辑和语法，是现代计算的一个不可或缺且极其有价值的部分。关系型数据库那种严格结构，对每个记录、关系和关联的精确要求，为我们提供了快速搜索、可扩展性以及深入分析的可能性。
- en: That type of exactness, however, isn't always necessary. In the case of our
    Lending Library, for example, a full-fledged relational database would be overkill.
    In fact, in some cases, it's more effective to have a flexible data storage system,
    one that you can extend quickly and without significant recoding.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，那种精确性并不总是必要的。例如，在我们的借阅图书馆的情况下，一个完整的关系型数据库可能是杀鸡用牛刀。实际上，在某些情况下，拥有一个灵活的数据存储系统更为有效，这个系统你可以快速扩展，而不需要大量的重编码。
- en: For example, if you wanted to add a new property to your `list` object, it would
    be much simpler to just add the new property and let the database worry about
    it, rather than having to refactor your database code, add a new column, update
    all of your SQL statements and triggers, and make sure that all previous records
    have the new property.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要向你的`list`对象添加一个新属性，只是简单地添加新属性，让数据库去操心，而不是必须重构你的数据库代码、添加新列、更新你所有的SQL语句和触发器，并确保所有之前的记录都有这个新属性，要简单得多。
- en: That's where document-oriented storage comes into play. In a document-oriented
    storage system, your data store is made up of a bunch of key-value paired documents.
    What's the structure of that document? The data store doesn't really care. It
    could contain pretty much anything as long as each record has a unique key so
    that it can be retrieved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 文档导向存储就此发挥作用。在文档导向存储系统中，你的数据存储由一系列键值对文档组成。那个文档的结构是怎样的？数据存储其实并不关心。它可能包含几乎任何东西，只要每个记录有一个唯一的键，以便它可以被检索到。
- en: So in one document entry, you could have a very simple document. Maybe a key-value
    pair.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在一个文档条目中，你可能会有一个非常简单的文档。也许是一个键值对。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And then in another document entry (in the same data store) you could have a
    complex object, with nested arrays, nested objects, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在另一个文档条目（在同一个数据存储中），你可能会有一个复杂的对象，有嵌套数组、嵌套对象等等。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Heck, it could be the unabridged works of William Shakespeare. It doesn't really
    matter. As long as the data store can take that document and assign a unique key
    to it, it can be stored.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，它可能是威廉·莎士比亚的全集。真的不重要。只要数据存储能够为那个文档分配一个唯一的键，它就可以被存储。
- en: As you may have guessed, the lack of structure *can* make querying, sorting,
    and manipulating those documents less efficient. But that's okay, because our
    primary concern is with ease of coding and development speed, not efficiency.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，缺乏结构*可以*使查询、排序和操作那些文档的效率降低。但没关系，因为我们的主要关注点是编码的便利性和开发速度，而不是效率。
- en: In addition, because our application only has a few core functions, we can quickly
    identify what queries we'll be using most often, and optimize our document schema
    around that. This makes a document-oriented database actually perform *better*
    in some cases than a traditional relational database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们的应用程序只有几个核心功能，我们可以快速确定我们将最经常使用的查询，并将文档架构围绕那个进行优化。这使得在某些情况下，面向文档的数据库实际上比传统的关系数据库表现得*更好*。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are some pretty sophisticated document-oriented storage solutions out
    there that some would argue are as efficient or even more so than a standard relational
    database, but that discussion is beyond the scope of this book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有一些相当复杂的面向文档的存储解决方案，有些人认为它们与标准的关系数据库一样有效，甚至更有效，但这个讨论超出了本书的范围。
- en: Given the flexible nature of a document-oriented storage system, it is perfect
    for making quick changes, and the foundation libraries Meteor provides make it
    so that we don't have to worry about the connection or the structure. All we have
    to do is have a high-level understanding of how to retrieve, add, and modify those
    documents, and we can leave the rest to Meteor.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于面向文档的存储系统的灵活性，它非常适合快速更改，Meteor提供的基础库使我们不必担心连接或结构。我们只需要对如何检索、添加和修改这些文档有高层次的理解，其余的都可以留给Meteor。
- en: MongoDB
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB
- en: MongoDB—a play on the word "humongous"—is an open source NoSQL (not only SQL)
    database. It provides sophisticated features such as indexing, linking, and atomic
    operations, but at its heart it is a document-oriented storage solution.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB——这个词是对“humongous”（巨大）的玩弄——是一个开源的NoSQL（不仅仅是SQL）数据库。它提供了如索引、链接和原子操作等复杂功能，但它的核心仍然是一个面向文档的存储解决方案。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To learn more about MongoDB, visit the official site [http://www.mongodb.org](http://www.mongodb.org).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于MongoDB的信息，请访问官方网站 [http://www.mongodb.org](http://www.mongodb.org)。
- en: 'Using simple commands, we can see what records (what documents) are available,
    convert those records into JavaScript objects, and then save those changed objects.
    Think of MongoDB records as you would think about an actual text document:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单命令，我们可以查看哪些记录（哪些文档）可用，将那些记录转换成JavaScript对象，然后保存那些更改后的对象。把MongoDB记录想象成实际文本文档：
- en: 'Locate the document, and open it for editing (Meteor equivalent: `lists.find
    (...)`).'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并打开文档进行编辑（Meteor等效：`lists.find (...)`）。
- en: 'Make changes to the document (Meteor equivalent: `lists.update({...})`).'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文档（Meteor等效：`lists.update({...})`）。
- en: Save the document (automatically done with the `.update()` function).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档（自动通过`.update()`函数完成）。
- en: 'It''s not as simple as that, and there''s a lot of syntax you''ll need to learn
    if you want to consider yourself an expert in MongoDB, but you can clearly see
    the simple, clean document-oriented approach: Find/create a record, make changes,
    and save/update the record to the data store.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 没那么简单，如果你想要成为MongoDB领域的专家，还有很多语法你需要学习，但你可以清晰地看到这种简单、干净的面向文档的方法：查找/创建一个记录，进行更改，并将记录保存/更新到数据存储中。
- en: We need to discuss one final concept to help you better understand how MongoDB
    works. It is called a database, but it's easier to conceptualize as a collection
    of documents. The collection is indexed and quickly accessible, but it's still
    a collection, rather than a group of relational tables/entities. Just like you'd
    think about a folder on your hard drive, where you keep all of your text documents,
    think about MongoDB as a collection of documents, all of which are accessible
    and able to be "opened", changed, and saved.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论一个最后一个概念，以帮助您更好地理解MongoDB是如何工作的。它被称为数据库，但把它想象成文档的集合更容易。集合是索引化的，可以快速访问，但它仍然是一个集合，而不是关系表/实体的组。就像你会在硬盘上想象一个文件夹，你把所有的文本文档都放在里面，把MongoDB想象成一个文档的集合，所有这些文档都可以访问并且可以“打开”，更改和保存。
- en: Using direct commands
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用直接命令
- en: To gain a better understanding of how MongoDB works, let's have some fun in
    the command line.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解MongoDB如何工作，让我们在命令行中玩得开心一些。
- en: First, make sure that your application is up and running (open a terminal window,
    `cd` to the `~/Documents/Meteor/LendLib` directory, and execute the `meteor` command).
    Next, open a browser to `http://localhost:3000`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保您的应用程序正在运行（打开一个终端窗口，`cd`到`~/Documents/Meteor/LendLib`目录，并执行`meteor`命令）。接下来，打开浏览器访问`http://localhost:3000`。
- en: 'Now, you will want to open an *additional* terminal window, `cd` to the `~/Documents/Meteor/LendLib`
    directory, and run the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可能想打开一个*额外的*终端窗口，`cd`到`~/Documents/Meteor/LendLib`目录，并运行以下命令：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see a message similar to the following screenshot:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到以下类似屏幕截图的消息：
- en: '![Using direct commands](img/0823OS_05_12.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用直接命令](img/0823OS_05_12.jpg)'
- en: You have now connected to the running MongoDB database for your Lending Library
    application. Let's poke around with a couple of commands.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已连接到您借阅图书馆应用程序的运行MongoDB数据库。让我们用几个命令四处看看。
- en: 'First, let''s bring up the help screen. Enter the following command and hit
    *Enter*:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们打开帮助屏幕。输入以下命令并按*Enter*：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You''ll get a list of commands, and a brief explanation of what each one does.
    One in particular will show us even *more* commands we can use: `db.help()`. This
    will give us a list of database-related commands. Type the following into your
    terminal window, and press *Enter*:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将获得一个命令列表，以及每个命令的简要说明。其中一个特别能让我们看到*更多*命令：`db.help()`。这将为我们提供数据库相关命令的列表。在您的终端窗口中输入以下内容，然后按*Enter*：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't get overwhelmed by the number of possible commands. You don't need to
    know all of these, unless you'd like to become an expert on MongoDB. You only
    need to know a few, but having a look around never hurt anybody, so let's proceed.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要被可能的命令数量吓到。除非您想成为MongoDB专家，否则您不需要了解所有这些。您只需要知道几个，但四处看看永远不会伤害任何人，所以让我们继续。
- en: 'As mentioned previously, documents are stored in MongoDB in a logical grouping
    called a collection. We can see this firsthand, and take a look at our lists collection
    directly in the terminal window. To see a list of all available collections, enter
    the following:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，文档存储在MongoDB中的一个逻辑分组中，称为集合。我们可以亲眼看到这一点，并直接在终端窗口中查看我们的lists集合。要查看所有可用集合的列表，请输入以下内容：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the response you will find the name of your Lending Library collection:
    `lists`. Let''s go ahead and take a look at the `lists` collection. Enter the
    following:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的响应中，您将找到您借阅图书馆集合的名称：`lists`。让我们继续查看`lists`集合。输入以下内容：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Well, that wasn't very exciting. All we got back was `meteor.lists`. We want
    to be able to perform some queries on that collection. So this time, lets assign
    the collection to a variable.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嗯，这并不是很有趣。我们得到的只是`meteor.lists`。我们希望能够对该集合执行一些查询。所以这次，让我们将集合分配给一个变量。
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It appears that we have the same result as last time, but we have a lot more
    than that. We've now assigned the `lists` collection to the variable `myLists`.
    Therefore, we can run commands in the terminal window just like we would inside
    our Meteor code.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看来我们得到了与上次相同的结果，但我们得到的远不止这些。现在，我们将`lists`集合分配给变量`myLists`。因此，我们可以在终端窗口中运行与我们在Meteor代码中相同的命令。
- en: 'Let''s get the `Clothes` list, which currently doesn''t have any items in it,
    but still exists. Enter the following command:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取`Clothes`列表，该列表目前没有任何项目，但仍然存在。输入以下命令：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will return some very basic JSON. If you look closely, you''ll be able
    to see the empty items array, represented as `"items" : [ ]`. You''ll also notice
    an `_id` key-value, with a long number next to it, similar to the following:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这将返回一些非常基本的JSON。如果您仔细看，将能够看到空的项目数组，表示为`"items" : [ ]`。您还会注意到一个`_id`键值，旁边有一个长数字，类似于以下内容：'
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We didn't add that `_id`. MongoDB created it for us. It's a unique key, so that
    if we know it, we can make changes to that document without disturbing any of
    the other documents. We actually use this inside our Lending Library application,
    in multiple locations.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们没有添加那个`_id`。MongoDB为我们创建了它。这是一个唯一键，因此如果我们知道它，我们就可以更改该文档，而不会干扰其他文档。我们实际上在我们借阅图书馆应用程序的多个位置使用这个。
- en: 'If you look inside `~/Documents/Meteor/LendLib/LendLib.js`, you''ll see the
    following function for adding an item to a list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`~/Documents/Meteor/LendLib/LendLib.js`中查看，您将看到以下用于向列表添加项目的函数：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that when we call the `lists.update()` function, we identify which document
    we're going to update by the `_id`. This ensures that we're not updating multiple
    documents accidentally. If, for example, you were to give two lists the same category
    name (for example, `"DVDs"`), and used the category as the selector `({Category:"DVDs"}`),
    you would be taking action on both category lists. If, instead, you use the `_id`,
    it will only update the unique document with that matching `_id`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们调用`lists.update()`函数时，我们通过`_id`来识别我们要更新的文档。这确保了我们不会意外地更新多个文档。例如，如果你给两个列表赋予相同的类别名称（例如，"DVDs"），并使用类别作为选择器`({Category:"DVDs"}`），你将对这两个类别列表采取行动。如果你
    instead使用`_id`，它将只更新具有匹配`_id`的唯一文档。
- en: Getting back to the terminal, we now have the variable `myLists` assigned to
    our `lists` collection, and we've assigned the `Clothes` variable to the document
    in our `lists` collection that represents the `Clothes` list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回到终端，现在我们的`lists`集合有了变量`myLists`，我们将`Clothes`变量赋予了代表"Clothes"列表的`lists`集合中的文档。
- en: Take note of what the `Clothes` list currently looks like in our browser.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一下目前`Clothes`列表在浏览器中的样子。
- en: '![Using direct commands](img/0823OS_05_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用直接命令](img/0823OS_05_01.jpg)'
- en: 'Let''s go ahead and add our favorite shirt to the `Clothes` list. We''ll do
    this directly, in the terminal window. Enter the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将我们最喜欢的衬衫添加到`Clothes`列表中。我们将在终端窗口直接执行此操作。输入以下命令：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command updates `myLists`, using `Clothes._id` as the selector, and calls
    `$addToSet`, adding an item with the `Name:"Favorite Shirt"`. It will take a few
    seconds for Meteor to update, but you will soon see your favorite shirt now added
    to the list.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令使用`Clothes._id`作为选择器更新`myLists`，并调用`$addToSet`，添加一个名为`Name:"Favorite Shirt"`的项目。Meteor更新需要几秒钟，但很快您就会看到您最喜欢的衬衫已添加到列表中。
- en: '![Using direct commands](img/0823OS_05_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用直接命令](img/0823OS_05_02.jpg)'
- en: If you re-run the `Clothes` assignment command `Clothes = myLists.findOne({Category:"Clothes"})`
    you will now see that the `items` array has an entry for your favorite shirt.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新运行`Clothes`赋值命令`Clothes = myLists.findOne({Category:"Clothes"})`，您现在会看到`items`数组有一个您最喜欢的衬衫的条目。
- en: We can just as easily update or remove an item, using the `.update()` function
    with different arguments (`$pull` for removing, `$set` for updating).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同样轻松地更新或删除一个项目，使用不同的参数调用`.update()`函数（`$pull`用于删除，`$set`用于更新）。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For code examples, review the `removeItem()` and `updateLendee()` functions
    in `LendLib.js`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码示例，请参阅`LendLib.js`中的`removeItem()`和`updateLendee()`函数。
- en: For a more in-depth tutorial on MongoDB commands, visit [http://mongodb.org](http://mongodb.org)
    and click on **TRY IT OUT**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解MongoDB命令，请访问[http://mongodb.org](http://mongodb.org)并点击**TRY IT OUT**。
- en: Now that we've gone through some of the commands we can implement directly,
    let's revisit some of our `LendLib.js` code, and discuss the reactive code that
    tracks changes to our collection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经浏览了一些可以直接实施的命令，让我们重新审视一下我们的`LendLib.js`代码，讨论一下追踪我们集合变化的响应式代码。
- en: Broadcasting changes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播变化
- en: Using a publish/subscribe model, Meteor is constantly looking for changes to
    collections and to `Session` variables. When changes are made, a change event
    is broadcast (or published). Callback functions are listening (or subscribed)
    to the events being broadcast, and the code in a function is activated when the
    specific event it's subscribed to is published. Alternatively, the data model
    can be directly bound to portions of the HTML/Handlebars templates, so that when
    a change occurs, the HTML is re-rendered.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用发布/订阅模型，Meteor不断寻找集合和`Session`变量的变化。发生变化时，会触发一个变化事件（或发布）。回调函数监听（或订阅）正在广播的事件，当它订阅的特定事件发布时，函数中的代码将被激活。或者，数据模型可以与HTML/Handlebars模板的某些部分直接绑定，这样当发生变化时，HTML将被重新渲染。
- en: Published events
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布的事件
- en: So, when is an event published? As mentioned previously, events are broadcast
    when there's a change in the model. In other words, when a collection or a variable
    is modified, Meteor publishes the appropriate change event. If a document is added
    to a collection, an event is triggered. If a document already in a collection
    is modified and then saved back into the collection, an event is triggered. Finally,
    if a `Session` variable is changed, an event is triggered. Functions and templates
    are listening (subscribed) to the specific events, and will process the change
    in the data appropriately.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时发布事件呢？如前所述，当模型发生更改时会广播事件。换句话说，当集合或变量被修改时，Meteor发布适当的变化事件。如果将文档添加到集合中，将触发一个事件。如果已存在于集合中的文档被修改并保存回集合中，将触发一个事件。最后，如果`Session`变量被更改，将触发一个事件。函数和模板正在监听（订阅）特定事件，并将适当地处理数据的更改。
- en: 'If you recall from [Chapter 3](ch03.html "Chapter 3. Why Meteor Rocks!"), *Why
    Meteor Rocks!*, this is the Model View View-Model pattern at work. In a reactive
    context, functions and templates react to changes in the model. In turn, actions
    from the view will create changes to the model, through the View-Model logic:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回想起来自[第3章](ch03.html "第3章：为什么Meteor如此棒！")，*为什么Meteor如此棒！*，这是模型-视图-视图模型模式在起作用。在一个反应式上下文中，函数和模板会响应模型的更改。反过来，视图中的动作将通过视图模型逻辑创建对模型的更改：
- en: '![Published events](img/0823OS_05_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![已发布的事件](img/0823OS_05_03.jpg)'
- en: 'Meteor''s MVVM is a clean, concise development pattern:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor的MVVM是一种干净、简洁的开发模式：
- en: Set up subscribers to model changes (model = collections, documents, and `Session`
    variables).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置订阅以监控模型更改（模型=集合、文档和`Session`变量）。
- en: Create logic to handle view events (view events = button click, text input,
    and so on).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建逻辑来处理视图事件（视图事件=按钮点击、文本输入等）。
- en: Change the model, when the logic calls for it (changes = published events).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改模型，当逻辑需要时（更改=已发布的事件）。
- en: Around and around it goes, with a click on a button causing a model change,
    which then triggers an event, listened to by a template. This updates the view
    based on the model change. Lather, rinse, repeat.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一圈又一圈地转，按钮点击导致模型更改，然后触发一个事件，模板监听这个事件。根据模型更改更新视图。洗发水，冲洗。重复。
- en: Configuring publishers
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置发布者
- en: Up to this point, we have been using `autopublish`. Meaning, we haven't had
    to code specific publish events for any events or collections. This is great for
    testing, but we want to have a bit more control over what events and documents
    get published, so we can improve both performance and security.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`autopublish`。这意味着，我们没有为任何事件或集合编写特定的发布事件。这对于测试来说很好，但我们希望对发布的事件和文档有更多的控制，以便我们可以提高性能和安全性。
- en: If we have a large dataset, we may not want to return the entire collection
    every time. If `autopublish` is being used, the entire collection will return,
    and that can slow things down, or it can expose data we don't want to have exposed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个大数据集，我们可能不希望每次都返回整个集合。如果使用`autopublish`，将返回整个集合，这可能会减慢速度，或者可能会暴露我们不想暴露的数据。
- en: Turning off autopublish
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭autopublish
- en: 'The time has come to turn off `autopublish`. Temporarily stop your Meteor application
    (if it''s still running) by opening the terminal window you ran the `meteor` command
    from. You can stop it by pressing *Ctrl* + *C*. Once it''s stopped, enter the
    following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候关闭`autopublish`了。如果您正在运行Meteor应用程序，请通过打开您运行`meteor`命令的终端窗口来暂时停止它。您可以按*Ctrl*
    + *C*键停止它。一旦它停止，请输入以下命令：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This removes the `autopublish` library, which is responsible for the automatic
    publishing of all events inside of Meteor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这移除了`autopublish`库，这个库负责Meteor内部所有事件的自动发布。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's considered a best practice to remove `autopublish` from your project. `autopublish`
    is for developing and debugging, and should be turned off when you're ready to
    start using your application in earnest.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议从您的项目中移除`autopublish`。`autopublish`用于开发和调试，当您准备认真使用应用程序时应关闭。
- en: 'By turning this off, you''ve effectively made your application do nothing!
    Congratulations! You can see your amazing progress by starting up your Meteor
    service again (enter the `meteor` command and press *Enter*), and opening/navigating
    to `http://localhost:3000`. You will see the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关闭此功能，您实际上使您的应用程序什么也不做！恭喜您！您可以通过重新启动Meteor服务（输入`meteor`命令并按*Enter*键），然后打开/导航到`http://localhost:3000`来查看您的惊人进步。您将看到以下屏幕截图：
- en: '![Turning off autopublish](img/0823OS_05_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![关闭autopublish](img/0823OS_05_04.jpg)'
- en: 'The categories/lists are gone! You can even check in the console if you''d
    like. Enter the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 分类/列表消失了！你甚至可以在控制台进行检查。输入以下命令：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see a count of `6`, but you will instead see a count of `0`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个`6`的计数，但你会发现计数是`0`：
- en: '![Turning off autopublish](img/0823OS_05_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![关闭autopublish](img/0823OS_05_05.jpg)'
- en: What gives? Well, it's pretty simple, actually. Because we removed the `autopublish`
    library, the server is no longer broadcasting any changes to our model.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事呢？实际上，原因很简单。因为移除了`autopublish`库，服务器不再广播我们模型的任何更改。
- en: Why again did we do this? What's the purpose of breaking our application? Ah!
    Because we want to make our application more efficient. Instead of getting every
    record automatically, we're going to instead just get the records we need, and
    the minimum set of data fields from those records.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这么做呢？破坏我们应用的目的是什么？啊！因为我们想要让我们的应用更高效。我们不是自动获取每个记录，而是只获取我们需要的记录，以及这些记录的最小数据字段集。
- en: Listing categories
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出分类
- en: 'In `LendLib.js`, inside the `if(Meteor.isServer)` block, create the following
    `Meteor.publish` function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LendLib.js`中，在`if(Meteor.isServer)`块内，创建以下`Meteor.publish`函数：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This tells the server to publish a `"Categories"` event. It will publish this
    whenever a change is made to the variables found inside the function. In this
    case, it's `lists.find()`. Whenever a change is made that would affect the results
    of `lists.find()`, Meteor will trigger/publish an event.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉服务器发布一个`"Categories"`事件。每当函数内部变量发生变化时，它都会发布这个事件。在这个例子中，是`lists.find()`。每当对`lists.find()`的结果产生影响的变化发生时，Meteor将触发/发布一个事件。
- en: 'If you noticed, the `lists.find()` call isn''t empty. There''s a selector:
    `{fields:{Category:1}}`. This selector is telling the `lists.find()` call to only
    return the `fields:` specified. And only one field is specified –`{Category:1}`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，`lists.find()`调用并不是空的。有一个选择器：`{fields:{Category:1}}`。这个选择器告诉`lists.find()`调用只返回`fields:`指定的内容。并且只指定了一个字段——`{Category:1}`。
- en: This snippet of JSON is telling the selector that we want to get the `Category`
    field (`1` = true, `0` = false). Because that is the only field mentioned, and
    it's set to `1` (true), Meteor assumes that you want to *exclude* all other properties.
    If you had any fields set to `0` (false), Meteor would assume that you want to
    *include* all the other fields you didn't mention.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段JSON代码告诉选择器我们想要获取`Category`字段（`1`=真，`0`=假）。因为提到的唯一字段是`1`（真），Meteor假定你希望排除所有其他属性。如果你有任何字段设置为`0`（假），Meteor会假定你希望包括所有你没有提到的其他字段。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information on the `find()` function, consult the MongoDB documentation
    at [http://www.mongodb.org/display/DOCS/Advanced+Queries](http:// http://www.mongodb.org/display/DOCS/Advanced+Queries).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`find()`函数的更多信息，请查阅MongoDB文档：[http://www.mongodb.org/display/DOCS/Advanced+Queries](http://http://www.mongodb.org/display/DOCS/Advanced+Queries)。
- en: So, if you save this change, your browser will refresh and... nothing happens
    to the display!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你保存这个更改，你的浏览器会刷新，然后...显示没有任何变化！
- en: Why? As you may have guessed, removing the `autopublish` library did more than
    get rid of the `publish` events. It also got rid of the listeners/subscribers.
    We don't have any subscriber set up to listen on the `Categories` event channel.
    So we need to add a subscriber event that is tuned in to the `Categories` channel.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这么做呢？正如你可能会猜到的，移除`autopublish`库不仅仅是去除了`publish`事件。它还去除了监听器/订阅者。我们没有为`Categories`事件通道设置任何订阅者。因此我们需要添加一个订阅者事件，以便能够接收到`Categories`通道的信息。
- en: 'Inside the `if (Meteor.isClient)` function, at the very top, just inside the
    opening bracket, enter the following line of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if (Meteor.isClient)`函数的最顶部，在开括号内输入以下代码行：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save this change, and you will now see your `Categories` back where they belong.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个更改，你现在将看到`Categories`回到了它们应该在的位置。
- en: '![Listing categories](img/0823OS_05_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![列出分类](img/0823OS_05_06.jpg)'
- en: Before we celebrate, go ahead and click on the **Clothes** category.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们庆祝之前，先点击**服装**分类。
- en: '![Listing categories](img/0823OS_05_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![列出分类](img/0823OS_05_07.jpg)'
- en: Our favorite shirt is missing! As you probably figured out by now, this is because
    the publish event we set up was very specific. The only field in the `Categories`
    channel being published is the `Category` field. All the other fields, including
    our `items` (and therefore our favorite shirt) are not being broadcast.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最喜欢的衬衫不见了！正如你现在可能已经猜到的，这是因为我们设置的发布事件非常具体。在`Categories`通道中发布的唯一字段是`Category`字段。包括我们的`items`（以及因此我们的最喜欢的衬衫）在内的所有其他字段都没有被广播。
- en: Let's double-check this. Click on the **+** button inside of the **Clothes**
    category in your browser, type in `Red Hooded Sweatshirt`, and press *Enter*.
    The new entry will appear for a split second, and then it will disappear. This
    is because of local caching and server sync.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再检查一下。在浏览器中点击**+**按钮，在**Clothes**类别中输入`Red Hooded Sweatshirt`，然后按*Enter*。新条目会出现一瞬间，然后就会消失。这是因为本地缓存和服务器同步。
- en: When you enter the new `item`, the local cache contains a copy. That `item`
    is temporarily visible to your client. However, when the sync with the server
    occurs, the server update only publishes the `Category` field, so when the server
    model updates the local model, the `item` is no longer included.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入一个新的`item`时，本地缓存包含一个副本。那个`item`暂时对您的客户端可见。然而，当与服务器同步时，服务器更新只发布`Category`字段，所以当服务器模型更新本地模型时，`item`就不再包括在内。
- en: One more test, just for funzies. In your terminal window, stop the Meteor service
    (*Ctrl* + *C*). Now, in your browser, enter another `item` in the **Clothes**
    category (we'll use `Pumped Up Kicks`). Because the service is stopped, no sync
    happens with the server, so you're using your local cache, and there is your `item`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次，只是为了好玩。在你的终端窗口中，停止Meteor服务(*Ctrl* + *C*)。现在，在浏览器中，在**Clothes**类别中输入另一个`item`（我们用`Pumped
    Up Kicks`）。因为服务已经停止，所以没有与服务器的同步，所以您使用本地缓存，您的`item`就在那里。
- en: '![Listing categories](img/0823OS_05_08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![列出类别](img/0823OS_05_08.jpg)'
- en: Now start your server back up. Your client will sync with the server, and poof!
    your `item` is gone again.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新启动你的服务器。您的客户端将与服务器同步，然后你的`item`又消失了。
- en: '![Listing categories](img/0823OS_05_13.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![列出类别](img/0823OS_05_13.jpg)'
- en: Listing items
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出项目
- en: 'This is no good, because we want to see our `items`. So, let''s add `items`
    back in, and grab the appropriate list of `items` whenever a `Category` is selected.
    In `LenLib.cs`, just below our first `Meteor.publish()` function inside the `if(Meteor.isServer)`
    block, add the following function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这不行，因为我们想要看到我们的`items`。所以，让我们把`items`加回来，并在选择一个`Category`时获取适当的`items`列表。在`LenLib.cs`中，在我们第一个`Meteor.publish()`函数下面的`if(Meteor.isServer)`块中，添加以下函数：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This `publish` function will publish on the `"listdetails"` channel. Any listener/subscriber
    will provide the variable `category_id`, so that our `find()` function returns
    a leaner recordset.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`publish`函数将在`"listdetails"`通道上发布。任何监听器/订阅者都将提供变量`category_id`，以便我们的`find()`函数返回一个更轻的记录集。
- en: Notice that nothing has changed in our client yet (your `items` still aren't
    visible). That's because we need to create the `subscribe` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，到目前为止，我们的客户端还没有发生变化（您的`items`仍然不可见）。那是因为我们需要创建一个`subscribe`函数。
- en: 'Just below our first `Meteor.subscribe()` function, add the following function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个`Meteor.subscribe()`函数下面，添加以下函数：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save your changes, and check out your swag **Clothes** collection!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的更改，然后查看您的**Clothes**收藏！
- en: '![Listing items](img/0823OS_05_09.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![列出项目](img/0823OS_05_09.jpg)'
- en: Let's look under the hood here for a minute, and figure out what just happened.
    Notice that the subscription uses `Session.get('current_list')`. That is the variable
    that gets passed into the publish function. In other words, the value inside of
    the `Session` variable `current_list` will be used as `category_id` in the `find()`
    function's selector.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟揭开这里面的奥秘，弄清楚刚才发生了什么。请注意，订阅使用了`Session.get('current_list')`。这个变量是在发布函数中传递的。换句话说，`Session`变量`current_list`中的值将作为`find()`函数选择器中的`category_id`使用。
- en: If you remember from [Chapter 4](ch04.html "Chapter 4. Templates"), *Templates*,
    we have a click event handler set up to listen for `Category` changes. When you
    click on **Clothes**, for example, an event fires, and the `selectCategory()`
    function inside `LendLib.js` handles the event, and changes our `Session` variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得[第4章](ch04.html "第4章 模板 Templates")，*模板*，我们已经设置了一个点击事件处理程序，用来监听`Category`的变化。例如，当你点击**Clothes**时，一个事件会被触发，`LendLib.js`中的`selectCategory()`函数处理该事件，并改变我们的`Session`变量。
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That `Session.set()` triggers a publish event. We wrapped the `Meteor.subscribe()`
    function for the `"listdetails"` channel inside of a `Meteor.autosubscribe()`
    function. We did this because the `Session.set()` event will trigger `Meteor.autosubscribe()`,
    and we have a `Meteor.subscribe()` function in there, specifically for the `"listdetails"`
    channel.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `Session.set()` 触发了一个发布事件。我们将 `Meteor.subscribe()` 函数包裹在 `Meteor.autosubscribe()`
    函数中，以便为 `"listdetails"` 通道提供 `Meteor.subscribe()` 函数。我们这样做是因为 `Session.set()`
    事件将触发 `Meteor.autosubscribe()`，而那里正好有一个 `Meteor.subscribe()` 函数，专门为 `"listdetails"`
    通道服务。
- en: 'In other words:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：
- en: '`Session.set()` triggers an event.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Session.set()` 触发一个事件。'
- en: '`Meteor.subscribe()` listens to that event because it uses the `Session` variable.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Meteor.subscribe()` 监听这个事件，因为它使用了 `Session` 变量。'
- en: Meteor resets the subscription listener on the `"listdetails"` channel (because
    it's wrapped inside `Meteor.autosubscribe()`).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流星在 `"listdetails"` 通道上重置了订阅监听器（因为它被包裹在 `Meteor.autosubscribe()` 中）。
- en: Meteor sees that new subscription listener and fires an initial event.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流星看到新的订阅监听器并触发了一个初始事件。
- en: '`Meteor.subscribe()` function picks up that event, passes in the `category_id`
    variable, and the UI refreshes because of the model change.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Meteor.subscribe()` 函数接收到这个事件，传入 `category_id` 变量，由于模型变化，UI 进行了刷新。'
- en: Checking your streamlined data
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查你的简化数据
- en: 'The display is now no different than when we started this chapter. But underneath
    the display, the model is much leaner. With the **Clothes** category selected,
    run the following command in the browser console:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显示与我们开始本章时没有区别。但在显示之下，模型要精简得多。选择 **服装** 类别，在浏览器控制台中运行以下命令：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Expand the object, and you'll see that there are no items listed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 展开对象，你会看到没有列出任何项目。
- en: '![Checking your streamlined data](img/0823OS_05_10.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![检查你的简化数据](img/0823OS_05_10.jpg)'
- en: The reason there are no items is because our `Session` variable `current_list`
    is set to `Clothes`, not `DVDs`. The `find()` function only gets the full record
    for the `current_list`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以没有项目，是因为我们的 `Session` 变量 `current_list` 被设置为 `Clothes`，而不是 `DVDs`。`find()`
    函数只获取 `current_list` 的完整记录。
- en: 'Now enter the following command in the browser console and press *Enter*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器控制台中输入以下命令并按 *Enter*：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Expand the object, and you'll see your three items in an array.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 展开对象，你会看到你的三个项目在一个数组中。
- en: '![Checking your streamlined data](img/0823OS_05_11.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![检查你的简化数据](img/0823OS_05_11.jpg)'
- en: Click around, add items to categories, add new categories, and check the underlying
    data model that's visible on the client. You'll see that your lists are now much
    less visible, and therefore more secure and discreet. This probably won't be a
    problem for your own personal Lending Library application, but as we expand this
    out in the next chapter, so that multiple people can use it, streamlined and discreet
    data will really improve performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 点击各个地方，为类别添加项目，添加新类别，并检查客户端可见的底层数据模型。你会发现你的列表现在明显可见性降低，因此更加安全和私密。这可能对你个人的借贷图书馆应用来说不会有问题，但随着我们在下一章中扩展这个应用，让多个人可以使用，简化和私密的数据将真正提高性能。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've learned what MongoDB is, how a document-oriented database
    works, and you've performed direct queries in the command line, becoming familiar
    with Meteor's default data repository system. You've also streamlined your application
    by removing `autopublish`, and have gained a firm understanding of the publish/subscribe
    design pattern built in to Meteor.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了 MongoDB 是什么，面向文档的数据库是如何工作的，以及在命令行中进行了直接查询，熟悉了 Meteor 的默认数据存储系统。你还通过移除
    `autopublish` 简化了你的应用，并且对内置于 Meteor 中的发布/订阅设计模式有了扎实的理解。
- en: In the next chapter, you'll really tighten up security on your app, allowing
    multiple users to keep track of and control their own lists of items, and you'll
    see how to further streamline your client and server code through the use of folders.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将真正加强应用的安全性，允许多用户跟踪和控制他们自己的项目列表，并且你将了解如何通过使用文件夹进一步简化客户端和服务器代码。
