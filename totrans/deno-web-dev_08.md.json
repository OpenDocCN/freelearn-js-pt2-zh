["```js\n    FROM hayd/alpine-deno:1.7.5\n    ```", "```js\n    WORKDIR /app\n    ```", "```js\n    COPY command from Docker allows us to specify a file to copy from the local filesystem (the first parameter) into the container image (the last parameter), which is currently the app folder. By dividing our workflows and copying only the files we need, we allow Docker to cache and rerun part of the steps only when the involved files changed. \n    ```", "```js\n    deno-mongo) and also using the lock file, we have to pass additional flags. Docker's `RUN` command enables us to run this specific command inside the container.\n    ```", "```js\n    workdir (/app folder) inside the container.\n    ```", "```js\n    CMD [\"deno\", \"run\", \"--allow-net\", \"--unstable\", \"--allow-env\", \"--allow-read\", \"--allow-write\", \"--allow-plugin\", \"src/index.ts\" ]\n    ```", "```js\n    museums-api in this example) and choose whichever version you want (0.0.1 in the example).This should produce the following output:\n\n    ```", "```js\n\n    ```", "```js\n    0.0.1 of the museums-api image, binding the 8080 container port to the 8080 host port. We can now go to http://localhost:8080 and see that the application is running.\n    ```", "```js\n$ docker run -p 8080:8080 -it  museums-api:0.0.1 sh\n```", "```js\n$ docker run -p 8080:8080 -it  museums-api:0.0.1 sh        \n/app # ls\nDockerfile           certificate.pem      config.staging.yaml  index.html           lock.json\nREADME.md            config.dev.yaml      heroku.yml        key.pem              src\n```", "```js\n/app # deno --version\ndeno 1.7.2 (release, x86_64-unknown-linux-gnu)\nv8 8.9.255.3\ntypescript 4.1.3 \n/app #\n```", "```js\n    $ heroku login\n    heroku: Press any key to open up the browser to login or q to exit:\n    Opening browser to https://cli-auth.heroku.com/auth/cli/...\n    Logging in... done\n    Logged in as your-login-email@gmail.com\n    ```", "```js\n    $ git init\n    Initialized empty Git repository in /Users/alexandre/dev/ museums-api/.git/\n    ```", "```js\n    heroku, which is where we have to push our code to trigger the deployment process.\n    ```", "```js\n    build:\n      docker:\n        web: Dockerfile\n    ```", "```js\n    build:\n      docker:\n        web: Dockerfile\n    Dockerfile, and that's true. Normally, Heroku would run the command from the `Dockerfile` to execute the image, and it would work. It happens that Heroku doesn't run these commands as root, as a security best practice. Deno, at its current stage, needs root privileges whenever you want to use plugins (an unstable feature). As our application is using a plugin to connect with MongoDB, we need this command to be explicitly defined on `heroku.yml` so that it is run with root privileges and works when Deno is starting up the application.  \n    ```", "```js\n    heroku.yml file included) to version control and push it to Heroku so that it starts the build.\n    ```", "```js\n    $ git add .\n    ```", "```js\n    -m flag that we've used is a command that allows us to create a commit with a message with a short syntax.\n    ```", "```js\n    Dockerfile, following all the steps specified there, as happened when we built the image locally, as illustrated in the following code snippet: \n\n    ```", "```js\n\n    And it should be working, right? Well…, not really. We still have a couple of things that we need to configure, but we're almost there.\n    ```", "```js\nexport async function load(\n  env = \"dev\",\n): Promise<Configuration> {\n```", "```js\n    const config = await\n      loadConfiguration(DENO_ENV is not defined, and allow us to load a different configuration file in production.\n    ```", "```js\n    web:\n      port: 9001\n    ```", "```js\n    DENO_ENV). We mentioned how you can do this in *Chapter 7**, HTTPS, Extracting Configuration, and Deno in the Browser*, in the *Accessing secret values* section.And after running it we can confirm it's loading the correct file, because the application port is now `9001`.\n    ```", "```js\n    DENO_ENV variable so that our application knows that, when running in Heroku, it is the production environment.If you are not using your own MongoDB cluster and you have questions about its credentials, you can go back to [*Chapter 6*](B16380_06_Final_JM_ePub.xhtml#_idTextAnchor141), *Adding Authentication and Connecting to the Database*, where we created a MongoDB cluster in MongoDB Atlas.If you're using a different cluster, remember that it is defined in the configuration file in `config.production.yml` and not in the environment, and thus you need to add your cluster URL and database in the configuration file as follows:\n\n    ```", "```js\n\n    ```", "```js\n    $ git commit -am \"Configure environment variables and DENO_ENV\"\n    ```", "```js\n    $ git push heroku master\n    …\n    remote: Verifying deploy... done.\n    To https://git.heroku.com/boiling-dusk-18477.git\n       9340446..36a061e  master -> master\n    ```", "```js\ntype Configuration = {\n  web: {\n    port: number;\n  };\n  cors: { \n…\nexport async function load(\n  env = \"dev\",\n): Promise<Configuration> {\n  const configuration = parse(\n    await Deno.readTextFile(`./config.${env}.yaml`),\n  ) as Configuration;\n  return {\n    ...configuration,\n    web: {\n      ...configuration.web,\n      port: Number(Deno.env.get(\"PORT\")) ||\n        configuration.web.port,\n    },\n…\n```", "```js\n$ curl -X POST -d '{\"username\": \"test-username-001\", \"password\": \"testpw1\" }' -H 'Content-Type: application/json' https://boiling-dusk-18477.herokuapp.com/api/users/register\n{\"user\":{\"username\":\"test-username-001\",\"createdAt\":\"2020-12-19T16:49:51.809Z\"}}%\n```", "```js\n    app.use((ctx) => {\n      ctx.response.body = \"Hello Deno World!\";\n    });\n    ```", "```js\n    $ git commit -am \"Change Hello World message\"\n    [master 35f7db7] Change Hello World message\n     1 file changed, 1 insertion(+), 1 deletion(-)\n    ```", "```js\n    $ git push heroku master\n    Enumerating objects: 9, done.\n    Counting objects: 100% (9/9), done.\n    Delta compression using up to 8 threads\n    Compressing objects: 100% (5/5), done.\n    Writing objects: 100% (5/5), 807 bytes | 807.00 KiB/s, done.\n    Total 5 (delta 4), reused 0 (delta 0)\n    remote: Compressing source files… Done\n    …\n    remote: Verifying deploy... done.\n    To https://git.heroku.com/boiling-dusk-18477.git\n    ```", "```js\n2020-12-19T17:04:23.639359+00:00 app[web.1]: GET http://boiling-dusk-18477.herokuapp.com/ - 1ms\n```"]