- en: Chapter 2. Advanced JavaScript Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 高级JavaScript概念
- en: JavaScript, when initially designed, was not expected to become the core programming
    language for Web development. It was normally used to perform some basic client-side
    operations that require some manipulation of the **Document Object Model** (**DOM**)
    elements. Later on, with the recent pace in Web development, things have pretty
    much changed. Now, many applications are purely using JavaScript and HTML to handle
    complex situations. From time to time, with different versions, different features
    were added and, as per the specification of ECMAScript 6, you can now have classes,
    you can do inheritance as you do with any other programming language, such as
    C# or Java. Closures, prototype functions, property descriptors, and many more
    that we will discuss in this chapter make it more powerful and robust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在最初设计时，并没有预料到会成为Web开发的核心编程语言。它通常被用来执行一些基本的客户端操作，这些操作需要对**文档对象模型**（**DOM**）元素进行一些操作。后来，随着Web开发的最近步伐，事情已经发生了很大的变化。现在，许多应用程序纯粹使用JavaScript和HTML来处理复杂的情况。有时，随着不同版本的出现，增加了不同的特性，根据ECMAScript
    6的规范，你现在可以有类，可以进行继承，就像你用C#或Java任何其他编程语言一样。闭包、原型函数、属性描述符等等，我们将在本章讨论的内容，使它更加强大和健壮。
- en: In the previous chapter, we learned the core concepts and some basic fundamentals
    of writing programs in JavaScript and what features as a language it provides.
    In this chapter, we will be focusing more on the advanced topics, which help us
    to use these concepts in large and complex applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了JavaScript编程的核心概念和一些基本的基本原理，以及它作为一门语言提供的特性。在本章中，我们将重点关注更高级的主题，这些主题有助于我们在大型和复杂的应用程序中使用这些概念。
- en: We will also focus on scoping and hoisting variables, object-oriented programming,
    prototype functions, property descriptors, closures, exception handling, and so
    on. Some topics, such as promises, asynchronous patterns and **Asynchronous JavaScript
    and XML** (**Ajax**) techniques, are broader topics and are covered in other chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将重点关注作用域和提升变量、面向对象编程、原型函数、属性描述符、闭包、异常处理等。一些主题，如承诺、异步模式和**异步JavaScript和XML**（**Ajax**）技术，是更广泛的主题，在其他章节中进行覆盖。
- en: Variables – scope and hoisting
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量 - 作用域和提升
- en: We already know how variables are declared in JavaScript using the `var` keyword.
    Any variable that is declared using the `var` keyword is termed a hoisted variable,
    and the term *hoisting* is the JavaScript default behavior of moving declarations
    to the top. When JavaScript is compiled by the JavaScript engine, all the variables
    that are declared using the `var` keyword are placed at the top within its scope.
    This means that if the variable is declared within a function block, it will be
    placed at the top of the function; otherwise, if it's declared outside any function
    and at the root of the script, it will become globally available. Let's have a
    look at this example to clarify our understanding.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何在JavaScript中使用`var`关键字声明变量。任何使用`var`关键字声明的变量都被称为提升变量，*提升*是JavaScript的默认行为，将声明移动到顶部。当JavaScript通过JavaScript引擎编译时，所有使用`var`关键字声明的变量都放在其作用域的顶部。这意味着如果变量在函数块内声明，它将被放在函数顶部；否则，如果它声明在任何函数之外并在脚本的根部，它将变得全局可用。让我们看看这个例子来澄清我们的理解。
- en: 'Let''s suppose the following code is the simple program that returns the GMT
    of the country name passed in the function''s parameter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下代码是一个简单的程序，它返回传递给函数参数的国家名称的GMT：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the JavaScript engine compiles the script, the `var gmt` variable will
    be placed at the top:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript引擎编译脚本时，`var gmt`变量将被放在顶部：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is called hoisting, where the `var` variables are placed at the top within
    its scope. Moreover, if you try to access the variable value in the last `else`
    condition, it will give an undefined value and could be accessible in every condition
    block.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为提升，其中`var`变量被放在其作用域的顶部。此外，如果您尝试在最后一个`else`条件中访问变量值，它将给出一个未定义的值，并且在每个条件块中都可能可用。
- en: 'This code shows another example of declaring the `gmt` variable globally and
    declaring it in the bottom of the code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示了另一个声明`gmt`变量全局和在代码底部声明的例子：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the script compiles, it will put the declaration of `gmt` at the top of
    the code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本编译时，它将在代码顶部放置`gmt`的声明：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To overcome this behavior in ECMAScript 6, there is a new `let` keyword introduced
    to declare variables and the scope remains where it is defined. These variables
    are inaccessible outside its scope.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服 ECMAScript 6 中的这种行为，引入了一个新的 `let` 关键字来声明变量，其作用域保留在定义的位置。这些变量在其作用域外不可访问。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that ECMAScript 6 is not supported by older browser versions but Microsoft
    Edge, Google Chrome 11, and Mozilla Firefox support it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ECMAScript 6 不被老旧的浏览器版本支持，但 Microsoft Edge、Google Chrome 11 和 Mozilla Firefox
    支持它。
- en: Declaring let
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明 `let` 变量
- en: As with `var`, you can use `let` to declare variables in the same way. You can
    use this keyword in your programs but it will be accessible within the scope where
    it is defined. So, for example, if some variable is defined within the condition
    block, it will not be accessible outside its scope.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `var` 一样，你可以用 `let` 以相同的方式声明变量。你可以在你的程序中使用这个关键字，但它将仅在其定义的作用域内可访问。所以，例如，如果某个变量在条件块内定义，它将无法在其作用域之外访问。
- en: 'Let''s have a look at the following example, where a variable is declared inside
    a condition block and the final output after compilations remains as it is. This
    is beneficial in conditions where you want to declare variables within a scope
    for a particular logic or scenario. In the `else` condition, `gmt` will not be
    accessible, as it is defined within the `if` condition:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看以下示例，其中在条件块内部声明了一个变量，在编译后的最终输出保持不变。这在您想在一个特定逻辑或场景内声明变量的条件下非常有用。在 `else`
    条件中，`gmt` 将不可访问，因为它是在 `if` 条件内定义的：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the `let` variable is declared within the scope of the function or script,
    it cannot be redeclared. Also, if the variables are declared using the `var` keyword,
    they cannot be redeclared using `let`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在函数或脚本的作用域内声明了 `let` 变量，它就不能被重新声明。另外，如果使用 `var` 关键字声明变量，则不能使用 `let` 重新声明。
- en: 'This code will not throw an exception as the scope is different. However, within
    the same block, it cannot be redeclared:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不会抛出异常，因为作用域不同。然而，在同一块中，它不能被重新声明：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Conditions where let is efficient to use
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在使用 `let` 关键字时效率较高的条件
- en: Here are the conditions where `let` is used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 `let` 的条件。
- en: Functions in loops
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环中的函数
- en: 'If we use the `var` variables in functions inside loop, these variables generate
    issues. Consider the following example, where there is an array of values and,
    through looping, we are inserting a function at each index of any array. This
    will make an error and pass the `i` variable as a reference. So, if you traverse
    each index and call function, the same value, that is, `10`, will be printed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在循环中的函数内部使用 `var` 变量，这些变量会产生问题。考虑以下示例，其中有一个值数组，并通过循环在每个数组的索引处插入一个函数。这将导致错误并将
    `i` 变量作为引用传递。所以，如果你遍历每个索引并调用函数，将会打印出相同的值，即 `10`：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Events in JavaScript
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 中的事件
- en: Events play an important role in any business application where you want to
    save a record on a button-click event, or show some message, or change some element's
    background color. Any of these events can be defined from the control level itself
    or register directly through the script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在任何一个商业应用程序中扮演着重要的角色，你希望在按钮点击事件上保存记录，或者显示一些消息，或者改变某个元素的背景颜色。这些事件可以从控件级别本身定义，或者通过脚本直接注册。
- en: 'Let''s have a look at this example, which changes the inner `html` code of
    the `div` control when the mouse is entered:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，当鼠标进入时，这个例子会改变 `div` 控件内部的 `html` 代码：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding example registered two events on the script side for an HTML
    `div` control. It changes text, if the mouse has entered the function or has left
    the boundary of `div`. Alternatively, we can also register events on the control
    itself, and this example shows the way you can display a message on a button-click
    event. If you have noticed the scripting block is defined after the `div` pane,
    the reason is that when the page loads, it will try to execute the script and
    throw an error because the `contentPane` element was not created at that time:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例在 HTML `div` 控件的脚本侧注册了两个事件。如果鼠标进入了函数或离开了 `div` 的边界，它会改变文本。另外，我们也可以在控件本身上注册事件，这个示例展示了如何在按钮点击事件上显示一条消息。如果你注意到脚本块是在
    `div` 面板之后定义的，原因是当页面加载时，它会尝试执行脚本并抛出一个错误，因为当时 `contentPane` 元素尚未创建：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the scripting block is defined at the top of the page. In this
    scenario, it can be defined anywhere in the page because it will only be executed
    when the user clicks on a button.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，脚本块定义在页面的顶部。在这种情况下，它可以定义在页面的任何位置，因为它只有在用户点击按钮时才会执行。
- en: Function arguments
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'We already know that the JavaScript functions can have parameters. However,
    the type of the parameters cannot be specified when creating a function. JavaScript
    neither performs any type checking on the parameter values passed nor validates
    the number of parameters when the function is called. So, for example, if a JavaScript
    function is taking two parameters, as shown in this code, we can even call it
    without passing any parameter value or by passing any type of the values or more
    values than the expected number of the parameters defined:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 JavaScript 函数可以有参数。然而，在创建函数时无法指定参数的类型。JavaScript 在调用函数时既不会对参数值进行类型检查，也不会验证传递的参数数量。所以，例如，如果一个
    JavaScript 函数接受两个参数，像这段代码所示，我们甚至可以不传递任何参数值，或者传递任何类型的值，或者传递比定义的预期参数数量更多的值：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The missing parameters are set as undefined, whereas if more parameters are
    passed, these parameters can be accessed through the arguments object. The arguments
    object is a built-in object in JavaScript that contains an array of the arguments
    used when the function is invoked. We can use it as shown in this code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的参数被设置为未定义，而如果传递了更多参数，这些参数可以通过 arguments 对象访问。arguments 对象是 JavaScript 中的一个内置对象，它包含了一个数组，该数组是在调用函数时使用的参数。我们可以像这段代码中这样使用它：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Arguments are passed by value; this means if the values are changed inside the
    function, it will not change the parameter's original value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 参数按值传递；这意味着如果在函数内部改变了参数的值，它将不会改变原始参数的值。
- en: Object-oriented programming in JavaScript
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JavaScript 中的面向对象编程
- en: All the objects in JavaScript are inherited from an object. JavaScript provides
    different patterns to adhere to the **object-oriented programming** (**OOP**)
    principles when building applications. There are different patterns, such as constructor
    patterns, prototype patterns, and object literal representation, and, with ECMAScript
    6, a completely new way of representing objects through classes and inheriting
    a base class using the `extends` keyword.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 JavaScript 对象都是从某个对象继承来的。JavaScript 提供了不同的模式，以便在构建应用程序时遵循**面向对象编程**（**OOP**）原则。这些模式包括构造器模式、原型模式和对象字面量表示法，以及
    ECMAScript 6 中通过类和使用 `extends` 关键字继承基类来表示对象的一种完全新的方式。
- en: In this section, we will see how we can implement the OOP principles with different
    methodologies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用不同的方法实现 OOP 原则。
- en: Creating objects
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: A class represents the structure of an object and every class has certain methods
    and properties used by the object, whereas an object is an instance of a class
    and is known as a class instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类表示对象的结构，每个类都有某些由对象使用的方法和属性，而对象是类的实例，被称为类实例。
- en: JavaScript is a prototype-based language and based on objects. In a class-based
    language such as C# and Java, we have to first define the class that contains
    some methods and properties and then use its constructor to create objects. In
    JavaScript, any object can be used as a template to create new objects and use
    the properties or methods defined within it. New objects can also define their
    own properties or methods and can be associated as a prototype for another object.
    ECMAScript 6, however, introduces classes in JavaScript, which is syntactical
    sugar over existing paradigms and makes it easy for developers to write simpler
    and cleaner code to create objects. In the next section, we will see different
    ways of creating objects in JavaScript.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种基于原型的语言，并且基于对象。在像 C# 和 Java 这样的类式语言中，我们必须首先定义一个包含一些方法和属性的类，然后使用其构造函数来创建对象。在
    JavaScript 中，任何对象都可以作为模板来创建新对象，并使用其中定义的属性或方法。新对象也可以定义自己的属性或方法，并可以作为另一个对象的原型。然而，ECMAScript
    6 在 JavaScript 中引入了类，这是对现有范式的语法糖，使开发者能够更容易地编写更简单、更干净的代码来创建对象。在下一节中，我们将看到在 JavaScript
    中创建对象的不同方法。
- en: Defining objects using object literal notation
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象字面量表示法定义对象
- en: Object literals are comma-separated lists of name value pairs wrapped in curly
    braces.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量是使用花括号括起来的由逗号分隔的名称值对列表。
- en: 'Object literals are defined using the following syntax rules:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量使用以下语法规则定义：
- en: A colon separates a property name from a value
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒号将属性名与值分隔开来：
- en: A value can be any data type, including array literals, functions, and nested
    object literals
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值可以是任何数据类型，包括数组字面量、函数和嵌套对象字面量：
- en: Each name value pair is separated by a comma from the next name value pair defined
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个名称值对之间用逗号与下一个名称值对分隔：
- en: The last name value pair should not contain any comma after it
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓氏值对之后不应该包含任何逗号
- en: 'Here is the basic representation of a `person` object in object literal notation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在对象字面量表示法中一个`person`对象的基本表示：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is another representation of a `personModel` object with a `savePerson()`
    method in object literal notation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用对象字面量表示法展示的`personModel`对象的另一种表示，其中包含`savePerson()`方法：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Defining objects using a constructor pattern
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用构造模式定义对象
- en: 'Classes can be defined using functions in JavaScript. This code shows the simple
    way of defining a customer class in JavaScript:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，可以使用函数来定义类。这段代码展示了用JavaScript定义客户类的一种简单方式：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code just defined an empty class with a default constructor and
    no properties and methods. Objects can be initialized using a new keyword, as
    shown in this code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只是定义了一个空的类，有一个默认构造函数，没有属性和方法。可以使用new关键字来初始化对象，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same function can be defined in a regular function declaration style:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个函数可以用常规函数声明风格定义：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the regular function declaration, the JavaScript engine knows to fetch
    the function when it is needed. For example, if you call it before the function
    declaration in your script, it will call this function, whereas the variable defining
    approach needs the variable to be declared first before calling it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规函数声明，JavaScript引擎知道在需要时获取函数。例如，如果您在脚本中在函数声明之前调用它，它会调用这个函数，而变量定义方法需要在调用它之前先声明变量。
- en: Using the class keyword
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用类关键字
- en: 'ECMAScript 6 provides a new way of defining classes and introduced a class
    keyword, which can be used just like in other programming languages. This code
    is the representation of defining a customer object. The default constructor is
    `constructor()` that takes no parameters and can be overridden with more parameters,
    depending on the requirements. Each class allows you to define only one constructor,
    and if the constructor is overridden, the default constructor will not be used
    to instantiate objects:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6提供了一种新的定义类的方法，并引入了一个类关键字，可以像在其他编程语言中一样使用。这段代码是定义一个客户对象的表示。默认构造函数是`constructor()`，不带任何参数，可以根据需求用更多参数覆盖。每个类允许您定义只有一个构造函数，如果覆盖了构造函数，默认构造函数将不会用来实例化对象：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Properties
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: Properties are used to store and return values. We can define properties when
    initializing functions and these properties will be available each time the object
    is created.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 属性用于存储和返回值。我们可以在初始化函数时定义属性，每次创建对象时这些属性都将可用。
- en: Defining properties using object literal notation
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用对象字面量表示法定义属性
- en: 'Properties can be defined in objects as literal strings. For example, in this
    code, there is the customer object containing two properties and a method. The
    drawback with this approach is that there is no constructor and we cannot restrict
    users to supply property values when initializing an object. Either it can be
    set as hardcoded, as shown here, or after initializing an object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以在对象中定义为字面量字符串。例如，在这段代码中，有一个包含两个属性和一个方法的客户对象。这种方法的缺点是没有构造函数，我们无法限制用户在初始化对象时提供属性值。它可以设置为硬编码，如所示，或者在初始化对象后：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Defining properties using a constructor pattern
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用构造模式定义属性
- en: 'A constructor function pattern allows you to define parameters that restrict
    users to pass property values when instantiating objects. Consider this example;
    it contains a customer object with two properties, namely `id` and `name`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数模式允许您定义参数，限制用户在实例化对象时传递属性值。考虑这个例子，它包含一个具有`id`和`name`两个属性的客户对象：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `this` keyword refers to the current object and properties can be accessed
    using `this` when calling inside the class, or through the instance variable,
    as shown in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字指的是当前对象，在类内部调用时可以使用`this`来访问属性，或者通过实例变量，如下面的代码所示：'
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Property values can also be set after initializing an object, as shown in the
    following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值也可以在初始化对象后设置，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This snippet also represents the same approach of defining a person object
    that takes two parameters. We will see the limitations of using this approach
    in the next section when dealing with prototypes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也代表了定义一个接受两个参数的人对象的相同方法。在下一节中，当我们处理原型时，我们将看到这种方法的局限性：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Defining properties using setters/getters in ECMAScript 6
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用setter/getter在 ECMAScript 6 中定义属性
- en: 'In ECMAScript 6, there is a new way of defining properties and it follows the
    standard way like other programming languages:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 6 中，有一种新的定义属性的方法，它遵循其他编程语言的标准方式：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unlike this approach, we can also define setters and getters using the `set`
    and `get` keywords. Constructors are optional in JavaScript when defining classes;
    if no constructor is defined, the default constructor, `constructor()`, will be
    invoked on object initialization. Let''s have a look at this example containing
    a `personName` property for both setter and getter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与这种方法不同，我们也可以使用`set`和`get`关键字定义setter和getter。在JavaScript中定义类时，构造函数是可选的；如果没有定义构造函数，对象初始化时会调用默认构造函数`constructor()`。让我们看一个包含`personName`属性的例子，该属性用于setter和getter：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: JavaScript property descriptors
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JavaScript 属性描述符
- en: 'Every property has the property descriptor, which is used to configure, and
    has the following meaning:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都有属性描述符，用于配置，其含义如下：
- en: '**Writable**: This attribute is used to make the code read-only or writable.
    The `false` keyword makes it read-only and the value cannot be modified.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Writable**：这个特性用于设置代码为只读或可写。`false`关键字使其只读，值不能被修改。'
- en: '**Enumerable**: This attribute is used to hide/unhide the property to be accessible
    or serializable. Setting this attribute to `false` will not show up the property
    when you iterate through an object''s members and also could not be serialized
    when using `JSON.stringify`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Enumerable**：这个特性用于隐藏/显示属性，使其可访问或可序列化。将此属性设置为`false`，在遍历对象成员时不会显示属性，并且在使用`JSON.stringify`时也不会被序列化。'
- en: '**Configurable**: This attribute is used for the `on` and `off` configuration
    changes. For example, setting this attribute to `false` will prevent a property
    to be modified or deleted.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Configurable**：这个特性用于`on`和`off`的配置更改。例如，将此属性设置为`false`将防止属性被修改或删除。'
- en: 'All these attributes are `true` by default but can be overridden, as shown
    in the following example. This example has a `car` object containing two properties,
    namely `name` and `color`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性默认都是`true`，但可以被覆盖，如下例所示。这个例子有一个`car`对象，包含两个属性，分别是`name`和`color`：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Display property descriptors
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示属性描述符
- en: 'You can display the existing properties using the following statement:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语句显示现有属性：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Managing property descriptors
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 管理属性描述符
- en: 'The property descriptors of any object''s property can be managed as shown
    in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象的属性都可以像以下代码那样进行管理：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using getters and setters
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用getter和setter
- en: 'Through `Object.defineProperty`, we can also add setters and getters for properties.
    This example adds the full name of the car by concatenating `make` and `name`,
    and then splitting `name` to get the model and name through two different properties:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Object.defineProperty`，我们还可以为属性添加setter和getter。这个例子通过连接`make`和`name`并分割`name`来添加汽车的完整名称，然后通过两个不同的属性获取模型和名称：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Methods
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: Methods are the actions that can be performed on objects. In JavaScript, it
    can be represented as a property containing a function definition. Let's have
    a look at a different approach to defining the methods of the JavaScript objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是可以在对象上执行的动作。在JavaScript中，它可以表示为一个包含函数定义的属性。让我们看看定义JavaScript对象方法的不同方法。
- en: Defining methods through object literal notation approach
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过对象字面量表示法定义方法
- en: 'An example showing the `logToConsole()` method defined in the object literal
    notation approach is shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了对象字面量表示法中定义的`logToConsole()`方法：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Defining objects using the constructor function approach
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用构造函数函数定义对象
- en: 'The `constructor` function approach to defining methods is shown in the following
    code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`constructor`函数定义方法的代码如下：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another way is to declare the `constructor` function approach is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是声明`constructor`函数，如下所示：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In ECMAScript 6, there is a better syntax for defining methods. The code snippet
    with the same example is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 6 中，定义方法的语法更为优雅。以下是一个示例代码片段：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The method return type is not needed when defining a method and it is realized
    based on the method body.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义方法时不需要指定方法返回类型，它基于方法体实现。
- en: Extending properties and methods
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展属性和方法
- en: Every JavaScript object has an object known as a prototype. A prototype is a
    pointer to another object. This prototype can be used to extend the object properties
    and methods. For example, if you are trying to access some property of an object
    that is not defined, it will look into the prototype object and proceed through
    the prototype chain until it is found or returns undefined. Therefore, whether
    an object is created using a literal syntax approach or a constructor function
    approach, it inherits all the methods and properties from a prototype known as
    `Object.prototype`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个JavaScript对象都有一个称为原型的对象。原型是指向另一个对象的指针。这个原型可以用来扩展对象属性和方法。例如，如果你尝试访问一个对象的某个未定义属性，它会查看原型对象并通过原型链继续查找，直到找到或者返回undefined。因此，无论使用字面量语法方法还是构造函数方法创建对象，它都会从称为`Object.prototype`的原型继承所有方法和属性。
- en: For example, an object created using `new Date()` inherits from `Date.prototype`,
    and so on. However, the base object itself does not have any prototype.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`new Date()`创建的对象从`Date.prototype`继承，依此类推。然而，基本对象本身没有原型。
- en: 'We can easily add properties and functions to objects, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地向对象添加属性和函数，如下所示：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Extending existing functions without initializing an object is done using a
    prototype object. Let''s have a look at this example, where we add one method,
    `logToConsole()`, and a `phoneNo` property on a `Person` function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不初始化对象而扩展现有函数是通过原型对象完成的。让我们来看这个例子，我们在`Person`函数上添加了一个方法`logToConsole()`和一个`phoneNo`属性：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Private and public members
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有和公共成员
- en: In JavaScript, there are no access modifiers like we have in C#. All the members
    that are defined as `this` or with prototypes are accessible from the instance,
    whereas other members, which are defined in some other way, are non-accessible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，没有像我们在C#中那样的访问修饰符。所有定义为`this`或具有原型的一切成员都可以从实例中访问，而其他以某种其他方式定义的成员是不可访问的。
- en: 'Let''s have a look at this example, which enables only the `y` and `y1()` methods
    to be accessible outside the function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看这个例子，它只允许`y`和`y1()`方法在函数外部被访问：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inheritance
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is a core principle of OOP. In JavaScript, if you are working with
    an older version that does not comply with the ES6 standard, it is done using
    prototype-based programming.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的核心原则。在JavaScript中，如果你使用的是不遵守ES6标准的旧版本，它是通过基于原型的编程来实现的。
- en: Prototype-based programming is an OOP model that does not use classes but extends
    objects or inheritance using the prototype chain. This means that every object
    has an internal `prototype` property, which points to a particular object or null
    if not used. This property is not accessible through the program and is `private`
    to the JavaScript engine. So, for example, if you are calling some property, such
    as `customer.getName`, it will first check the `getName` property locally on the
    object itself, otherwise go through the chaining process and try to find it by
    linking objects through the prototype property until it is found. If no property
    is defined, it will return undefined.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于原型的编程是一种不使用类，而是通过原型链来扩展对象或继承的面向对象编程模型。这意味着每个对象都有一个内部的`prototype`属性，它指向一个特定的对象，如果没有使用则为null。这个属性不能通过程序访问，并且对JavaScript引擎来说是`private`的。所以，例如，如果你调用某个属性，比如`customer.getName`，它会首先在对象本身上查找`getName`属性，否则通过原型属性链接对象来查找。如果没有定义属性，它会返回undefined。
- en: 'Consider the following **entity–relationship model** (**ERD**) that has a base
    person object with some generic properties and two child objects, namely **Vendor**
    and **Employee**, with specific properties:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下**实体-关系模型**（**ERD**），它有一个具有某些通用属性的基本person对象和两个子对象，分别是**Vendor**和**Employee**，具有特定的属性：
- en: '![Inheritance](img/00010.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/00010.jpeg)'
- en: 'In order to articulate the same inheritance using the JavaScript constructor
    function approach, we can use the `prototype` property of both `Vendor` and `Employee`
    to the person object, as shown in this code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用JavaScript构造函数方法表达相同的继承，我们可以像这段代码一样，将`Vendor`和`Employee`的`prototype`属性添加到person对象上：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, `vendorObj` is an object that was created from the
    `Vendor` constructor function. The `Vendor` constructor is both an object and
    a function because functions are objects in JavaScript, and the `vendorObj` object
    can have its own properties and methods. It can also inherit methods and properties
    from the `Vendor` object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，`vendorObj`是从`Vendor`构造函数创建的对象。`Vendor`构造函数既是对象又是函数，因为函数在JavaScript中是对象，而`vendorObj`对象可以有自己的属性和方法。它还可以从`Vendor`对象继承方法和属性。
- en: By setting the `prototype` property of the `Vendor` and `Employee` objects to
    the `Person` instance through the constructor function, it inherits all the properties
    and methods of the `Person` object and becomes accessible by the `Vendor` and
    `Employee` objects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造函数将`Vendor`和`Employee`对象的`prototype`属性设置为`Person`实例，它继承了`Person`对象的属性和方法，并成为`Vendor`和`Employee`对象可访问的。
- en: Object's properties and methods defined using the `prototype` object are inherited
    by all the instances that referenced it. So, in our example, we extended the `Vendor`
    and `Employee` objects through the `prototype` property and assigned them to the
    `Person` instance. This way, whenever any instance of the `Vendor` or `Employee`
    object is created, it can access all the properties or methods of an object of
    `Person`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`prototype`对象定义的对象属性和方法被所有引用它的实例所继承。因此，在我们的例子中，我们通过`prototype`属性扩展了`Vendor`和`Employee`对象并将它们分配给`Person`实例。这样，无论何时创建`Vendor`或`Employee`对象的任何实例，它都可以访问`Person`对象的属性和方法。
- en: 'Properties and methods can also be added through the object; for example, we
    can add a property to the `Vendor` object, as shown in the following code, but
    this will become the static property and not accessible by the `Vendor` instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过对象添加属性和方法；例如，我们可以向`Vendor`对象添加一个属性，如下面的代码所示，但这将变成静态属性，`Vendor`实例无法访问：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On the other hand, we can also add properties and methods to the `Vendor` instance
    as well but this will be accessible by that particular instance only:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们也可以向`Vendor`实例添加属性和方法，但这将仅对该特定实例可用：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Another technique of achieving inheritance is by assigning the parent''s prototype
    to the child''s prototype object, as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承的另一种技术是通过将父对象的`prototype`分配给子对象的`prototype`对象，如下所示：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With this technique, any methods or properties added in the `Person` prototype
    will be accessible by the `Vendor` object:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，在`Person`原型中添加的任何方法或属性都将可通过`Vendor`对象访问：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After running this script, it will show `true` in an alert message. This is
    because the `Vendor` object becomes an instance of the `Person` object and any
    method or property added in any of the objects will be accessible by both.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后，它将在警告消息中显示`true`。这是因为`Vendor`对象成为`Person`对象的实例，并且在任何对象中添加的任何方法或属性都可以被两个对象访问。
- en: If we modify the preceding example and add another method through a `Vendor`
    prototype property after the assignment of the `Person` prototype to the `Vendor`
    prototype, it will be accessible by the `Person` object. This is because, in JavaScript,
    when the child's object prototype is set to the parent's object prototype, any
    methods or properties added in either object after the assignment will be accessible
    by both.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改前面的示例，在将`Person`原型分配给`Vendor`原型之后，通过`Vendor`原型属性添加另一个方法，它将可通过`Person`对象访问。这是因为，在JavaScript中，当子对象的原型被设置为父对象的原型时，在分配后添加到任一对象中的任何方法或属性都将可通过两个对象访问。
- en: 'Let''s add a `showConsoleMessage()` method in the `Vendor` object through a
    `prototype` property and access it through the `Person` instance, as shown in
    this code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Vendor`对象中通过`prototype`属性添加一个`showConsoleMessage()`方法，并通过`Person`实例访问它，如这段代码所示：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Chaining constructors in JavaScript
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JavaScript中的构造函数链
- en: 'In the example in the previous section, we have seen how to inherit objects.
    However, if some base object has some overloaded constructor, accepting properties
    will require some extra effort. Every function in JavaScript has a `call` method,
    which is used to chain constructors for an object. We can use the `call` method
    to chain constructors and call base constructors. As the `Person` object takes
    two parameters, we will modify the `Vendor` function and two properties, `id`
    and `number`, which can be passed while creating a `Vendor` object. So, whenever
    the `Vendor` object is created, the `Person` object will be created and the values
    will be populated:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何继承对象。然而，如果某个基对象有一些重载构造函数，接受属性将需要一些额外的努力。JavaScript中的每个函数都有一个`call`方法，用于将构造函数链接到对象。我们可以使用`call`方法来链接构造函数并调用基构造函数。因为`Person`对象接受两个参数，我们将修改`Vendor`函数和两个属性`id`和`number`，在创建`Vendor`对象时可以传递这些属性。所以，无论何时创建`Vendor`对象，都会创建`Person`对象并填充值：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Inheritance using Object.create()
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`Object.create()`继承
- en: 'With ECMAScript 5, you can easily inherit your base object through the `Object.create()`
    method. This method takes two parameters, the object to use as a prototype and
    an object containing properties and methods for the new object to create. The
    `Object.create()` method improves constructor-based inheritance. It''s a good
    choice for creating an object without going through its constructor. Let''s see
    the example of `Vendor` and `Employee` inheriting the `Person` object using the
    `Object.create()` approach:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ECMAScript 5，你可以通过`Object.create()`方法轻松地继承你的基对象。这个方法接受两个参数，一个作为原型的对象和一个包含新对象应具有的属性和方法的对象。`Object.create()`方法改进了基于构造函数的继承。它是一个创建对象而不必通过其构造函数的好方法。让我们看看使用`Object.create()`方法的`Vendor`和`Employee`继承`Person`对象的示例：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, we used `Object.create()` to inherit the `Person`
    object to the `Vendor` and `Employee` objects. Whenever the `Vendor` or `Employee`
    instances are created, they can access the properties of the `Person` object.
    The `Object.create()` method automatically instantiates an instance of an object
    defined as the parameter in its `call` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`Object.create()`来继承`Person`对象到`Vendor`和`Employee`对象。无论何时创建`Vendor`或`Employee`实例，它们都可以访问`Person`对象的属性。`Object.create()`方法自动实例化其在`call`方法中定义的参数的对象实例。
- en: Predefined properties of Object.create()
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Object.create()`的预定义属性'
- en: 'An `Object.create()` method does not execute the `Person` function; instead,
    it will just set the `Person` function as a prototype of the customer function.
    Another representation of the customer object, containing property as `CustomerCode`,
    is shown in the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create()`方法不会执行`Person`函数；相反，它只是将`Person`函数设置为客户函数的原型。下面代码中展示了客户对象的另一种表示形式，包含一个名为`CustomerCode`的属性：'
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, value is the actual value representing the customer code, whereas `enumerable`,
    `writable`, and `configurable` are predefined attributes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，value代表实际的用户代码值，而`enumerable`、`writable`和`configurable`是预定义的属性。
- en: Defining inheritance using class
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用类定义继承
- en: In the example in the previous section, we have already seen how to define classes
    using ECMAScript 6\. Just like Java, we can inherit a parent class using the `extends`
    keyword.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节示例中，我们已经看到了如何使用ECMAScript 6定义类。就像Java一样，我们可以使用`extends`关键字来继承一个父类。
- en: 'An example of using `extends` is shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`extends`的一个示例在这里展示：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With ECMAScript 6, you can get the true essence of declaring static variables
    and methods in the class. Let''s have a look at the following example, which contains
    one static method, `logToConsole()`, and calls it from the customer class without
    initializing its object after inheriting it from the `Person` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有了ECMAScript 6，你可以真正领略到在类中声明静态变量和方法的精髓。让我们看看下面的例子，其中包含一个静态方法`logToConsole()`，并且从继承`Person`类的客户类中调用它，而无需在继承后初始化其对象：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Encapsulation
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装
- en: In the example in the previous section, the `Vendor` object doesn't need to
    know the implementation of the `logToConsole()` method in the `Person` class and
    can use that method. The `Vendor` class doesn't need to define this method unless
    overriding for a specific reason. This is called encapsulation, in which the `Vendor`
    object doesn't need to know the actual implementation of the `logToConsole()`
    method and each `Vendor` object can use this method to log to console. This is
    how the encapsulation is done, through which every class is encapsulated into
    a single unit.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`Vendor`对象不需要知道`Person`类中`logToConsole()`方法的实现，并可以使用该方法。除非有特定的原因需要覆盖，否则`Vendor`类不需要定义这个方法。这称为封装，其中`Vendor`对象不需要知道`logToConsole()`方法的实际实现，每个`Vendor`对象都可以使用这个方法来记录到控制台。就是这样通过封装来完成的，每个类都被封装成一个单一的单元。
- en: Abstraction
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象
- en: Abstraction is used to hide all the information except the data, which is relevant
    about an object, to reduce complexity and increase efficiency. This is one of
    the core principles of OOP.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象用于隐藏与对象相关的所有信息，除了数据，以减少复杂性并提高效率。这是面向对象编程的核心原则之一。
- en: In JavaScript, there is no built-in support for abstraction and it does not
    provide any type such as an interface or abstract to create interfaces or abstract
    classes to achieve abstraction. However, there are certain patterns through which
    you can implement abstraction but still it does not restrict and ensures that
    all the abstract methods are completely implemented by the concrete class or function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，没有内置的对抽象的支持，并且它不提供如接口或抽象类之类的类型来创建接口或抽象类以实现抽象。然而，通过某些模式，你可以实现抽象，但这种模式仍然不限制并确保所有抽象方法都被具体类或函数完全实现。
- en: 'Let''s have a look at the following example, where we have a `person` controller
    that takes a concrete object as a parameter, and then calls its specific implementation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下下面的例子，其中我们有一个`person`控制器，它接受一个具体对象作为参数，然后调用其具体的实现：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, with ECMAScript 6, we can implement the same scenario, as shown
    in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，借助ECMAScript 6，我们可以实现同样的场景，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: new.target
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: new.target
- en: 'The `new.target` property is used to detect whether the function or a class
    is called using the `new` keyword. It returns a reference to the function or a
    class if it is called, otherwise `null`. Considering the example in the previous
    section, we can restrict creating the `call` objects of `person` by using `new.target`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`new.target`属性用于检测函数或类是否使用`new`关键字调用。如果调用，它将返回对函数或类的引用，否则为`null`。考虑上面例子中的例子，我们可以通过使用`new.target`来限制创建`person`的`call`对象：'
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Namespace
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: ECMAScript 6 introduced modules through which you can define namespaces and
    use the `export` and `import` keywords but they are still in draft and no implementations
    are present so far.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6通过模块引入了命名空间，并使用`export`和`import`关键字，但它们仍然处于草案阶段，到目前为止没有实现。
- en: 'However, with earlier versions, namespaces can be simulated using local objects.
    For example, here is the syntax to define a local object represented as a namespace
    and we can add functions and objects inside it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在早期版本中，可以通过局部对象来模拟命名空间。例如，下面是定义一个表示命名空间的局部对象的语法，我们可以在其中添加函数和对象：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can then add functions, as shown in this code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在上面显示的代码中添加函数：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Moreover, more nested namespace hierarchy can also be defined, as shown in
    the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以定义更多嵌套的命名空间层次，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Exception handling
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: JavaScript is becoming a powerful platform for developing large applications,
    and exception handling plays an important role in handling exceptions in programs
    and propagate them where needed. Just like C# or any other programming language,
    JavaScript provides the `try`, `catch`, and `finally` keywords to annotate code
    for handling errors. JavaScript provides the same way of using the nested `try
    catch` statements and conditions for handling different conditions in the `catch`
    block.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript正在成为开发大型应用程序的强大平台，异常处理在处理程序中的异常和按需传播它们方面发挥着重要作用。就像C#或其他任何编程语言一样，JavaScript提供了`try`、`catch`和`finally`关键字来注解用于错误处理的代码。JavaScript提供了使用嵌套的`try
    catch`语句和条件在`catch`块中处理不同条件的相同方式。
- en: 'When an exception occurs, an object is created that represents the error thrown.
    Just like C#, we have different types of exception, such as `InvalidOperationException`,
    `ArgumentException`, `NullException`, and `Exception`. JavaScript provides six
    error types, which are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个异常发生时，会创建一个代表所抛出错误的对象。就像C#一样，我们有不同类型的异常，如`InvalidOperationException`、`ArgumentException`、`NullException`和`Exception`。JavaScript提供六种错误类型，如下所示：
- en: '`Error`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Error`'
- en: '`RangeError`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeError`'
- en: '`ReferenceError`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceError`'
- en: '`SyntaxError`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyntaxError`'
- en: '`TypeError`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeError`'
- en: '`URIError`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URIError`'
- en: Error
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Error`'
- en: 'The `Error` object represents generic exceptions and is mostly used in returning
    user-defined exceptions. An `Error` object contains two properties, namely name
    and message. Name returns the type of error and message returns the actual error
    message. We can throw error exceptions, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error`对象代表通用异常，主要用于返回用户定义的异常。一个`Error`对象包含两个属性，分别是name和message。Name返回错误类型，message返回实际错误信息。我们可以抛出错误异常，如下所示：'
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: RangeError
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`RangeError`'
- en: 'The `RangeError` exception is thrown if the range of any number is exceeded.
    For example, creating an array with a negative length will throw `RangeError`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何数字的范围被超出，将抛出`RangeError`异常。例如，创建一个负长度的数组将抛出`RangeError`：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ReferenceError
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ReferenceError`'
- en: 'The `ReferenceError` exception occurs when accessing an object or variable
    that does not exist; for example, the following code will throw a `ReferenceError`
    exception:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReferenceError`异常发生在访问一个不存在的对象或变量时；例如，以下代码将抛出一个`ReferenceError`异常：'
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: SyntaxError
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SyntaxError`'
- en: As the name states, `SyntaxError` is thrown if there is any syntax problem in
    the JavaScript code. So, if some closing bracket is missing, loops are not structured
    properly, and so on, this will come under the `SyntaxError` category.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，如果JavaScript代码中存在任何语法问题，就会抛出`SyntaxError`。所以，如果有些闭合括号缺失，循环结构不正确，等等，这都将归类为`SyntaxError`。
- en: TypeError
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型错误
- en: 'The `TypeError` exception occurs when a value is not of the excepted type.
    The following code throws a `TypeError` exception as the object is trying to call
    a method that does not exist:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值不是期望的类型时，会发生`TypeError`异常。以下代码抛出一个`TypeError`异常，因为对象试图调用一个不存在的函数：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: URIError
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URIError
- en: 'The `URIError` exception occurs with `encodeURI()` and `decodeURI()` when an
    invalid URI is specified. The following code throws this error:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当`encodeURI()`和`decodeURI()`中指定了一个无效的URI时，会发生`URIError`异常。以下代码抛出此错误：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Closures
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: Closures are one of the most powerful features of JavaScript. Closures provide
    a way to expose inner functions that are inside the body of other functions. A
    function can be termed a closure when one of the inner functions is made accessible
    outside the function in which it was contained and can be executed after the outer
    function is executed and use the same local variables, parameters, and function
    declarations when the outer function was called.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是JavaScript最强大的特性之一。闭包提供了一种暴露位于其他函数体内内部函数的方式。当一个内部函数被暴露在包含它的函数外部，并且在外部函数执行后可以执行，并且可以使用外部函数调用时的相同局部变量、参数和函数声明时，一个函数可以被称为闭包。
- en: 'Let''s have a look at the following example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下示例：
- en: '[PRE59]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is a simple closure example, in which `inc()` becomes the closure that
    references the inner function, which increments the `x` variable defined in the
    outer function. The `x` variable will be incremented on each call and the value
    will become `3` on the last call.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的闭包示例，其中`inc()`成为引用内部函数的闭包，该内部函数增加外层函数中定义的`x`变量。`x`变量将在每次调用时增加，最后调用的值为`3`。
- en: A closure is a special kind of object that combines the function and the environment
    in which that function was created. So, calling it multiple times will use the
    same environment and the values being updated in the previous call.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是一种特殊类型的对象，它将函数和函数创建的环境结合起来。所以，多次调用它将使用相同的环境，以及在之前调用中更新的值。
- en: 'Let''s have a look at another example, where we have a table generator function
    that takes a table number and returns the function, which can be used to get the
    result of any number multiplication with the table number supplied on the first
    call:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个示例，其中有一个表格生成函数，它接受一个表格号并返回一个函数，该函数可用于获取任何数字与提供的表格号相乘的结果：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The resultant values after calling the `twotable()` and `threetable()` methods
    will be `10` and `18`. This is because the `twoTable()` function object was initialized
    by passing `2` as the parameter to the `tableGen()` function. This `tableGen()`
    function then stores the value passed as a parameter in the `x` variable and multiplies
    it with the variable passed in the second call when it is executed through the
    `twoTable()` and `threeTable()` method calls.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`twotable()`和`threetable()`方法后的结果值将是`10`和`18`。这是因为`twoTable()`函数对象是通过将`2`作为参数传递给`tableGen()`函数进行初始化的。当通过`twoTable()`和`threetable()`方法调用执行时，这个`tableGen()`函数将传递的参数值存储在`x`变量中，并将其与第二次调用传递的变量相乘。
- en: 'Hence, the output of the `twoTable(5)` function call will be `10`, as shown
    in the following screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`twoTable(5)`函数调用的输出将是`10`，如下所示：
- en: '![Closures](img/00011.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![闭包](img/00011.jpeg)'
- en: 'The output of the second statement, `threeTable(6)`, will be `18`, as shown
    in the following screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条语句`threeTable(6)`的输出将是`18`，如下所示：
- en: '![Closures](img/00012.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![闭包](img/00012.jpeg)'
- en: Practical use
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际使用
- en: We have seen what closures are and how we can implement them. However, let's
    consider their practical implications. Closures let you associate some environment
    with a function that operates within that environment or data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了闭包是什么以及我们如何实现它们。然而，让我们考虑它们的实际影响。闭包让你可以将某些环境与在那种环境或数据中操作的函数相关联。
- en: 'In JavaScript, functions mostly execute on any event or trigger on any action
    taken by the user. Let''s have a look at the following example of the practical
    use of closures to log messages on a `console` and `dialog` window:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数大多在发生任何事件或用户执行任何操作时执行。让我们看看以下闭包在`console`和`dialog`窗口上实际使用示例，以记录消息：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the preceding example, we have two logger closures: one that logs to the
    console and the other one to a pop-up dialog window. We can initialize these closures
    and use them throughout our program to log messages.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有两个日志闭包：一个记录到控制台，另一个记录到弹出对话窗口。我们可以初始化这些闭包，并在程序中使用它们来记录消息。
- en: JavaScript typed arrays
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript类型数组
- en: Client-side development in JavaScript has become a powerful platform and there
    are certain APIs and libraries available that allow you to work with media files,
    Web sockets, and so on, and handle data in binary. When working with binary data,
    it is required to save it in its own specific format. Here comes the role of typed
    arrays, which allow developers to manipulate data in a raw binary format.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端开发在JavaScript已经成为一个强大的平台，并且有一些API和库可供使用，允许你与媒体文件、Web套接字等进行交互，并在二进制中处理数据。当处理二进制数据时，需要将其保存在其特定的格式中。这时就轮到类型数组发挥作用了，它允许开发者在原始二进制格式中操纵数据。
- en: Typed array architecture
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型数组架构
- en: Typed arrays keep the data in two portions, namely buffer and view. Buffer contains
    the actual data in binary but it cannot be accessible without view. View tells
    the actual metadata information and context about the buffer, such as data type,
    starting offset, and number of elements.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 类型数组将数据分为两部分，即缓冲区和视图。缓冲区包含二进制中的实际数据，但没有视图无法访问。视图提供了有关缓冲区的实际元数据信息和上下文，例如数据类型、起始偏移量和元素数量。
- en: The array buffer
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组缓冲区
- en: The array buffer is a data type that is used to represent binary data. Its content
    cannot be manipulated until it is assigned to a view, which represents the buffer
    in a specific format and performs manipulation on the data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 数组缓冲区是一种用于表示二进制数据的数据类型。在它被分配给一个视图之前，其内容无法被操纵。视图以特定格式表示缓冲区，并对数据执行操作。
- en: 'There are different types of type array views, which are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的类型数组视图，如下所示：
- en: '| Type | Size in bytes | Description |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 字节大小 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Int8Array` | 1 | This array is 8-bit signed integer. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `Int8Array` | 1 | 这是一个8位有符号整数数组。|'
- en: '| `UInt8Array` | 1 | This array is 8-bit unsigned integer. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `UInt8Array` | 1 | 这是一个8位无符号整数数组。|'
- en: '| `Int16Array` | 2 | This array is 16-bit signed integer. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `Int16Array` | 2 | 这是一个16位有符号整数数组。|'
- en: '| `UInt16Array` | 2 | This array is 16-bit unsigned integer. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `UInt16Array` | 2 | 这是一个16位无符号整数数组。|'
- en: '| `Int32Array` | 4 | This array is 32-bit signed integer. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `Int32Array` | 4 | 这是一个32位有符号整数数组。|'
- en: '| `UInt32Array` | 4 | This array is 32-bit unsigned integer. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `UInt32Array` | 4 | 这是一个32位无符号整数数组。|'
- en: '| `Float32Array` | 4 | This array is 32-bit IEEE floating point number. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `Float32Array` | 4 | 这是一个32位IEEE浮点数数组。|'
- en: '| `Float64Array` | 8 | This array is 64-bit IEEE floating point number. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `Float64Array` | 8 | 此数组是64位的IEEE浮点数。|'
- en: '| `UInt8ClampedArray` | 1 | This array is 8-bit unsigned integer (clamped).
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `UInt8ClampedArray` | 1 | 此数组是8位无符号整数（夹紧）。|'
- en: Now, let's go through an example to see how we can store data in a buffer and
    manipulate it through a view.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过一个示例来看看我们如何通过视图在缓冲区中存储数据并操作它。
- en: Creating a buffer
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建缓冲区
- en: 'First of all, we need to create a buffer, as shown in this code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个缓冲区，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding statement allocates the memory for 32 bytes. Now we can use any
    of the type array views to manipulate it:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声明分配了32字节的内存。现在我们可以使用任意一种类型数组视图来操作它：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And finally, we can access the fields, as shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以像这样访问字段：
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This code will make eight entries into the view, from `0` to `7`. The output
    will look as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在视图中进行八个条目的操作，从`0`到`7`。输出将如下所示：
- en: '[PRE65]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The same buffer can also be manipulated with the other view types. For example,
    if we wanted to read the populated buffer with a 16-bit array view, the result
    will be like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个缓冲区也可以使用其他视图类型进行操作。例如，如果我们想要用一个16位数组视图读取已填充的缓冲区，结果将像这样：
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will look as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE67]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is how easily we can manipulate single buffer data with multiple views
    of different types and interact with the data objects containing multiple data
    types.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何可以轻松地使用多种不同类型的视图来操作单个缓冲区数据，并与包含多种数据类型的数据对象交互。
- en: Maps, sets, weak maps, and weak sets
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射、集合、弱映射和弱集合
- en: Maps, weak maps, sets, and weak sets are objects that represent collections.
    Maps are keyed collections that hold values in name value pairs, whereas sets
    store unique values of any type. We will discuss each of them in the next sections.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 映射（Maps）、弱映射（weak maps）、集合（sets）和弱集合（weak sets）都是代表集合的对象。映射是键值对的键ed集合，而集合存储任何类型的唯一值。我们将在接下来的章节中讨论它们每一个。
- en: Maps and weak maps
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射和弱映射
- en: 'A `Map` object provides a simple key/value map and iterates it based on the
    insertion. The first inserted value will be retrieved first. Weak maps are non-enumerable
    and hold object types only. No primitive types are allowed in weak maps and each
    key represents an object. Let''s have a look at the following example of using
    a map for currencies:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`对象提供了一个简单的键/值映射，并且根据插入的顺序进行迭代。首先插入的值将被首先检索。弱映射是不可枚举的，仅保存对象类型。在弱映射中不允许有原始类型，每个键代表一个对象。让我们看看以下使用映射作为货币的示例：'
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Some other properties and methods available on the `Map` object are shown in
    the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`对象上可用的其他属性和方法如下所示：'
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Instead of simple primitive values, weak maps hold objects and their keys are
    represented as weak keys. This is because if there is no reference to the object
    stored in a weak map value and got collected in garbage, the key will become weak.
    It is normally used to store private data for an object or to hide implementation
    details.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 弱映射（weak maps）中保存的是对象，其键被表示为弱键（weak keys）。这是因为如果一个弱映射值中存储的对象没有被引用，并且在垃圾回收（garbage
    collection）时被回收，那么这个键就会变成弱键。它通常被用来存储对象的私有数据或者隐藏实现细节。
- en: 'We learned in the previous section that everything that is exposed on the instance
    level and prototype level is public. The practical example containing a function
    to authenticate a user from a Twitter account is shown in the following code.
    For **open authentication** (**OAuth**), Twitter needs two keys: the consumer
    API key and a secret key. We don''t wanted to expose and let the user to change
    this information. Therefore, we have kept this information using weak maps, and
    then retrieved it in the `prototype` function to authenticate the user:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到实例级别和原型级别上暴露的都是公共的（public）。下面是一个实际例子，包含了一个用于验证来自Twitter账户用户的函数：对于**开放认证**（**OAuth**），Twitter需要两个密钥：消费者API密钥和一个密钥秘密。我们不想暴露这些信息并让用户更改。因此，我们使用弱映射来保存这些信息，然后在`prototype`函数中检索它来验证用户：
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Sets and weak sets
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合和弱集合
- en: Sets are the collections of values where each value should be unique. So, for
    example, if at any index you have a value, `1`, already defined, you cannot insert
    it into the same set instance.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是值的集合，每个值应该是唯一的。所以，例如，如果你在任何索引上已经有了一个值`1`，已经定义，你不能将它插入到同一个集合实例中。
- en: 'Sets are not typed and you can put any data, irrespective of any data type:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是无类型的，你可以放入任何数据，不考虑任何数据类型：
- en: '[PRE71]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'On the other hand, weak sets are collections of unique objects and not the
    arbitrary values of any type. Just like weak maps, if there is no other reference
    to the object stored, it will be disposed and garbage collected. Similar to weak
    maps, they are not enumerable:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，弱集合是独特对象的集合，而不是任意类型的任意值。就像弱映射一样，如果没有其他对存储的对象的引用，它将被处置并回收。与弱映射类似，它们是不可枚举的：
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The strict mode
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格模式
- en: The `strict` mode is a literal expression introduced in ECMAScript 5\. It is
    used to write a secure JavaScript and throws errors if there are any minor errors
    on your script and doesn't overlook them. Secondly, it runs faster than the normal
    JavaScript code because it sometimes fixes mistakes, which helps JavaScript engines
    to perform optimizations and make your code run faster.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`strict`模式是ECMAScript 5中引入的字面表达式。它用于编写安全的JavaScript，并在脚本中出现任何小错误时抛出错误，而不会忽视它们。其次，它的运行速度比普通JavaScript代码快，因为它有时会修复错误，这有助于JavaScript引擎进行优化，使您的代码运行得更快。'
- en: 'We can invoke the `strict` mode on a global script level or a function level:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在全局脚本级别或函数级别调用`strict`模式：
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'For example, in the following code, it will throw an error as the `x` variable
    is not defined:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码中，它会抛出错误，因为`x`变量未定义：
- en: '[PRE74]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For larger applications, it''s a better choice to use the `strict` mode, which
    will throw an error if something is missing or not defined. The list of scenarios
    where using the `strict` mode will result in an error is shown in the following
    table:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的应用程序，使用`strict`模式是一个更好的选择，如果缺少或不定义某些内容，它会抛出错误。以下表格显示了使用`strict`模式会导致错误的一些场景：
- en: '| Code | Reason for error |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| Code | Error原因 |'
- en: '| --- | --- |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `x=100;` | In this code, variable is not declared. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `x=100;` | 这段代码中变量未声明。|'
- en: '| `x= {id:1, name:''ABC''};` | In this code, object variable is not declared.
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `x= {id:1, name:''ABC''};` | 这段代码中对象变量未声明。|'
- en: '| `function(x,x){}` | Duplicating the parameter name caused the error in this
    code. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `function(x,x){}` | 在此代码中参数名称重复导致了错误。|'
- en: '| `var x = 0001` | In this code, octal numeric literals are used. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `var x = 0001` | 这段代码中使用了八进制数字字面量。|'
- en: '| `var x=\0001` | Escape is not allowed, so the error occurred. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `var x=\0001` | 转义是不允许的，因此发生了错误。|'
- en: '| `var x = {get val() {return ''A''}};``x.val = ''B''` | Writing to a `get`
    value caused the error in this code. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `var x = {get val() {return ''A''}};` `x.val = ''B''` | 在此代码中，向`get`值写入导致了错误。|'
- en: '| `delete obj.prototype;` | Deleting object prototype is not allowed, so the
    error occurred. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `delete obj.prototype;` | 删除对象原型是不允许的，因此发生了错误。|'
- en: '| `var x= 2;``delete x;` | Deleting a variable is not allowed, so the error
    occurred. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `var x= 2;` `delete x;` | 删除变量是不允许的，因此发生了错误。|'
- en: Moreover, there are certain reserved keywords, such as `arguments`, `eval`,
    `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`,
    `static`, and `yield`, which are not allowed as well.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些保留关键字，如`arguments`、`eval`、`implements`、`interface`、`let`、`package`、`private`、`protected`、`public`、`static`和`yield`，也是不允许的。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learnt about some advanced concepts of JavaScript, such
    as hoisted variables and their scope, property descriptors, OOP, closures, typed
    arrays to store types of data, and exception handling. In the next chapter, we
    will learn about the most extensively used library, jQuery, to perform DOM traversal
    and manipulation, event handling, and more in a very simple and easy way.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了JavaScript的一些高级概念，如提升的变量及其作用域、属性描述符、面向对象编程、闭包、类型数组以存储数据类型，以及异常处理。在下一章中，我们将学习最广泛使用的库jQuery，以非常简单和容易的方式进行DOM遍历和操作、事件处理等。
