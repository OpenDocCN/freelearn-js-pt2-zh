- en: Chapter 7. Getting the Data Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。获取数据
- en: In the previous chapter, we looked at how you can get data into a Sencha Touch
    data store. Once we have the data, the next step is figuring out how to get it
    out of the store and use it in our application. Fortunately for us, Sencha Touch
    has a number of built-in ways to help us accomplish this task. Here we will explore
    how to use individual data records as well as the complete contents of the data
    store to display information in our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了如何将数据导入Sencha Touch数据存储。一旦我们有了数据，下一步就是弄清楚如何从存储中获取数据并在我们的应用程序中使用它。幸运的是，Sencha
    Touch有几种内置方法可以帮助我们完成这项任务。在这里，我们将探讨如何使用单个数据记录以及数据存储的完整内容来在我们的应用程序中显示信息。
- en: 'In this chapter, we will look at:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨：
- en: Using data stores for display
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据存储进行显示
- en: Binding, sorting, filtering, paging, and loading data stores
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定、排序、过滤、分页和加载数据存储
- en: Working with XTemplates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XTemplates
- en: Looping through data in an XTemplate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XTemplate中遍历数据
- en: Conditional display and inline functions in XTemplates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XTemplates中的条件显示和内联函数
- en: Inline JavaScript and member functions in XTemplates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XTemplates中的内联JavaScript和成员函数
- en: Using Sencha Touch Charts to display store data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sencha Touch图表显示存储数据
- en: Using data stores for display
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据存储进行显示
- en: 'Being able to store data in your application is only half the battle. You need
    to be able to easily get the data back out and present it in a meaningful way
    to the user. Lists, panels and other data-capable components in Sencha Touch offer
    three configuration options to help you accomplish this task: `store`, `data`,
    and `tpl`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在应用程序中存储数据只是战斗的一半。您需要能够轻松地将数据重新取出并以有意义的方式呈现给用户。Sencha Touch中的列表、面板和其他具有数据功能的组件提供三种配置选项来帮助您完成这项任务：`store`、`data`和`tpl`。
- en: Directly binding a store
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接绑定存储
- en: 'Data views, lists, nested lists, form select fields, and index bars are all
    designed to display multiple data records. Each of these components can be configured
    with a data store from where to pull these records. We introduced this practice
    earlier in the book:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据视图、列表、嵌套列表、表单选择字段和索引栏都旨在显示多个数据记录。这些组件中的每一个都可以配置一个数据存储，从中提取这些记录。我们在书中的早些时候介绍了这种做法：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The store configuration takes the `model` and `autoLoad` properties as part
    of its setup. This will grab all of the store's data (using the proxy on the `model`
    parameter) and pull it into the list for display. We are pretty familiar with
    this now, but what if we only want some of the data, or if we need the data in
    a specific order?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 存储配置在设置时包括`model`和`autoLoad`属性。这将获取存储的所有数据（使用`model`参数中的代理）并将其拉入列表以供显示。我们现在对此很熟悉，但如果我们只想获取一些数据，或者需要以特定顺序获取数据呢？
- en: As it turns out, Sencha Touch stores can be sorted and filtered both when they
    are first created and later if we need to change the filtering or sorting in response
    to the user.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，Sencha Touch存储可以在首次创建时以及我们需要根据用户更改过滤或排序时进行排序和过滤。
- en: Sorters and filters
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序器和过滤器
- en: Sorters and filters can be used in a number of ways. The first way is to set
    up a default configuration on the store as part of its creation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 排序器和过滤器可以用多种方式使用。第一种方式是在创建存储时设置默认配置。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `sorters` component is set as an array of property and direction values.
    These are executed in order, so our example sorts first by `lastLogin` (most recent
    first). Within `lastLogin`, we sort by name (alphabetically ascending).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sorters`组件被设置为一个属性值和方向值的数组。这些按顺序执行，因此我们的示例首先按`lastLogin`（最新）排序。在`lastLogin`内，我们按名称（按字母顺序递增）排序。
- en: Our filters are listed as `property` and `value` pairs. In our example, we want
    the store to show us only `admin`. The store might actually contain non-admins
    as well, but here we are requesting that those be filtered out initially.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤器列为`property`和`value`对。在示例中，我们希望商店只显示`admin`给我们。商店实际上可能包含非管理员，但在这里我们要求首先过滤掉那些人。
- en: 'Sorters and filters can also be modified after the initial load-in by using
    one of the following methods:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 排序器和过滤器可以通过使用以下方法之一在初始加载后进行修改：
- en: '`clearFilter`: This method clears all filters on the store, giving you the
    full content of the store.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearFilter`：此方法清除存储上的所有过滤器，给您商店的完整内容。'
- en: '`filter`: This method takes a filter object, just like the one in our earlier
    configuration example, and uses it to limit the data as requested.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`：此方法接受一个过滤器对象，与我们在早期配置示例中的对象类似，并使用它来限制所需的数据。'
- en: '`filterBy`: This method allows you to declare a function that is run on each
    item in the store. If your function returns `true`, the item is included. If it
    returns `false`, then the item is filtered out.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterBy`：这个方法允许你声明一个在每个存储项上运行的函数。如果你的函数返回`true`，该项目将被包含在内。如果它返回`false`，那么该项目将被过滤掉。'
- en: '`sort`: This method takes a `sort` object just like the ones in our configuration
    example and uses it to sort the data as requested.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`：这个方法接收一个`sort`对象，就像我们配置示例中的那些，并使用它来按请求的顺序排序数据。'
- en: 'If we use our earlier store example, changing the `sort` order would look like
    this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用先前的存储示例，改变`sort`顺序将如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Filtering has to take into account any previous filters on the store. In our
    current store example, we are set to filter out anyone without an `admin` value
    of `true`. If we try the following code, we will not get back anything in the
    list because we have effectively told the store to filter by both the new (`admin`
    = `false`) and previous (`admin` = `true`) filters:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选必须考虑存储上任何先前的筛选。在我们的当前存储示例中，我们设置为筛选出`admin`值为`false`的人。如果我们尝试以下代码，我们将列表中什么也得不到，因为我们实际上告诉存储同时根据新（`admin`
    = `false`）和先前（`admin` = `true`）的筛选进行筛选：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As `admin` is a Boolean value, we get back nothing. We have to clear out the
    old filter first:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`admin`是一个布尔值，所以我们什么也得不到。我们首先必须清除旧的筛选器：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example will clear the old `'admin'` filter from the store and return a
    list of everyone who is not an admin.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将清除存储中的旧`'admin'`筛选器，并返回一个不是管理员的每个人的列表。
- en: Sorting and filtering provides a powerful tool for manipulating data inside
    the data store. However, there are a few other situations we should also take
    a look at. What do you do when you have too much data, and what do you do when
    you need to reload the data store?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和筛选为在数据存储中操作数据提供了强大的工具。然而，还有其他几种情况我们也应该考虑。当你有太多数据时你应该做什么，当你需要重新加载数据存储时你应该做什么？
- en: Paging a data store
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面数据存储
- en: In some cases, you will end up with more data than your application can comfortably
    manage in a single bite. For example, if you have an application with 300 contacts,
    the initial load-in time might be more than you really want. One way to handle
    this is by paging the data store. Paging allows us to grab the data in chunks
    and send the next or previous chunk of data as the user needs it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能会得到比你的应用程序一次能舒适处理更多的数据。例如，如果你有一个带有300个联系人的应用程序，初始加载时间可能会比你真正想要的要长。处理这种情况的一种方法是分页数据存储。分页允许我们按块获取数据，并在用户需要时发送下一个或前一个数据块。
- en: 'We can set up paging using the `pageSize` configuration:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pageSize`配置来设置分页：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can then move through the data using the paging functions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用分页功能遍历数据：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code moves forward one page, moves back one page, and then jumps to page
    five.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码先前进一页，再后退一页，然后跳转到第五页。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should be noted that page indexes are 1 based (that is, numbered 1, 2, 3,
    and so on) rather than 0 based (that is, numbered 0, 1, 2, 3, and so on, like
    arrays).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，页面索引是基于1的（也就是说，编号为1、2、3等），而不是基于0的（也就是说，编号为0、1、2、3等，就像数组一样）。
- en: If we jump to page five and it doesn't exist, things will probably go poorly
    for our application (that is, it will go kaboom!), which means that we need a
    good way to figure out how many pages we actually have. For this we need to know
    the total number of records in our data store.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跳转到第五页并且它不存在，我们的应用程序可能会出现问题（也就是说，它会爆炸！），这意味着我们需要一种好的方法来确定我们实际上有多少页。为此，我们需要知道数据存储中的记录总数。
- en: We could try using the `getCount()` method for the data store, but this only
    returns the number of currently cached records in the store. Since we are paging
    through the data, it means that we are not loading everything available. If we
    have a maximum page count of 40, but there are 60 records in our database, the
    `getCount()` method will return `40` for the first page and `20` when we load
    the second page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用数据存储的`getCount()`方法，但这个方法返回的只是存储中当前缓存的记录数。由于我们在分页数据，这意味着我们并没有加载所有可用的数据。如果我们最大页面数为40，但我们的数据库中有60条记录，那么`getCount()`方法在第一页将返回40，在加载第二页时将返回20。
- en: Also, if you filter your store's data, the number returned by `getCount()` will
    be the number of records that matched the filter, not the total number of records
    in the store. We need to set up our store's reader to get an actual total back
    from our system. We also need to tell the store where these records will be when
    the data comes back to it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您过滤商店的数据，`getCount()`返回的数字将是匹配过滤器的记录数，而不是商店中记录的总数。我们需要设置商店的读取器以从我们的系统中获取实际的总数。我们还需要告诉商店当数据返回时这些记录将在哪里。
- en: 'We can set a configuration on the `reader` for `totalProperty` and `rootProperty`,
    such as the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`reader`上为`totalProperty`和`rootProperty`设置一个配置，例如以下内容：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This tells our reader to look for two extra properties, called `totalContacts`
    and `rootProperty`, in the data that it collects. The data that we pull into the
    store will also have to be set up to include this new property as part of the
    data string. How this is done will be determined largely by how your data is created
    and stored, but in a JSON data array, the format will look something like the
    following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的读者在收集的数据中寻找两个额外的属性，分别叫做`totalContacts`和`rootProperty`。我们从商店拉入的数据也必须设置为在数据字符串中包括这个新属性。如何实现这一点在很大程度上取决于您的数据是如何创建和存储的，但在JSON数据数组中，格式将类似于以下内容：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `totalContacts` property tells us how many contacts we have, and the `rootProperty`
    tells the reader where to start looking for those contacts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalContacts`属性告诉我们有多少联系人，`rootProperty`告诉读者从哪里开始寻找这些联系人。'
- en: 'Once our data is set up in this fashion, we can grab the total contacts, as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的数据以这种方式设置好，我们可以如下获取总联系人：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then divide by `myStore.getPageSize()`, to determine the total number
    of pages in our data. We can also grab the current page with `myStore.currentPage`.
    These two pieces of information will allow us to display the user''s current location
    in the pages (for instance, **Page: 5 of 8**). Now, we need to account for what
    happens when the data behind our store changes.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以除以`myStore.getPageSize()`，以确定我们数据中的总页数。我们还可以通过`myStore.currentPage`获取当前页。这两条信息将允许我们显示用户在页面中的当前位置（例如，**第5页/共8页**）。现在，我们需要考虑当商店背后的数据发生变化时会发生什么。
- en: Loading changes in a store
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在商店中加载更改
- en: When we use a data store to pull information from an external source, such as
    a file, a website, or a database, there is always the chance that the data will
    change at the external source. This will leave us with stale data in the store.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用数据存储从外部源（如文件、网站或数据库）拉取信息时，数据总是有可能在外部源处发生变化。这将导致我们在商店中留下陈旧的数据。
- en: 'Fortunately there is an easy way to deal with this using the `load()` function
    on the store. The `load()` function works as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单的方法可以处理这个问题，即使用商店上的`load()`函数。`load()`函数的工作方式如下：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `scope` and `callback` functions are both optional. However, `callback`
    offers us an opportunity to do a number of interesting things, such as compare
    our old and new records or alert the user visually once the new records are loaded.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`scope`和`callback`函数都是可选的。然而，`callback`为我们提供了做一些有趣事情的机会，比如比较我们的旧记录和新记录，或者在新技术记录加载后通过视觉方式向用户发出警报。'
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can also set up a listener on the store for the `load` event. This will
    make the store use this callback at any point in time when the basic `store.load()`
    function is called. Additionally, there is an event called `beforeLoad` that,
    as the name implies, fires off each time before the store is loaded. If the `beforeLoad`
    event returns `false`, the `load` event is not fired.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在商店中为`load`事件设置监听器。这将使得商店在任何时候调用基本`store.load()`函数时都使用这个回调。另外，还有一个名为`beforeLoad`的事件，顾名思义，在商店加载之前每次都会触发。如果`beforeLoad`事件返回`false`，则不会触发`load`事件。
- en: Another consideration while loading data stores is whether to automatically
    load (`autoLoad`) the store as part of its creation or load it later. A good rule
    of thumb is to only autoload the data stores that you know will be displayed initially.
    Any subsequent stores can be set to load when the component that they are bound
    to is shown.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载数据存储时，还需要考虑是否要自动加载（`autoLoad`）商店作为其创建的一部分，或者稍后加载。一个好的经验法则是只自动加载您知道最初将显示的数据存储。任何后续的数据存储都可以设置在它们所绑定的组件显示时加载。
- en: 'For example, let''s say we have a list of system users that will only be accessed
    occasionally within the program. We can add a listener to the component list itself
    in the following manner:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个系统用户列表，在程序中只偶尔访问。我们可以以如下方式向组件列表本身添加一个监听器：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will load the store only if the `list` component is actually shown.
    Loading stores in this fashion saves us time while launching our application,
    and also saves memory. However, it should be noted that the code will also load
    the store every time this component is shown. This is desirable if you expect
    the data behind the store to be updated frequently; otherwise, it is better to
    load the store manually.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只有在`list`组件实际显示时才会加载存储。这种加载存储的方式可以在启动我们的应用程序时节省时间，同时也可以节省内存。然而，需要注意的是，代码也会在组件显示时每次加载存储。如果你预计存储背后的数据会频繁更新，这是可取的；否则，最好手动加载存储。
- en: We can also save time and memory by using the store to feed multiple components,
    such as a list of data and a details panel. As with the preceding example, there
    are some caveats to this tactic. If a filter, sort, or data load is applied to
    the store by one component, it will also affect any of the other components that
    this store is bound to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用存储来为多个组件提供数据，例如数据列表和详细面板，从而节省时间和内存。与前面的示例一样，这种策略也有一些注意事项。如果一个组件对存储应用了过滤器、排序或数据加载，它也会影响与此存储绑定的任何其他组件。
- en: Data stores and panels
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据存储和面板
- en: Unlike lists, where a number of records can be displayed, a panel typically
    displays a single record. However, we can still grab this information from our
    data store in the same way that we do for a list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，面板通常显示单个记录，但是我们可以以与列表相同的方式从我们的数据存储中获取这些信息。
- en: Let's start with a variation of our contacts example from the beginning of the
    chapter; we will build a list of names using `first` and `last`, and then add
    a details panel that shows the full name, e-mail address, and phone number for
    the selected name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个章节的开始部分的联系人示例开始；我们将使用`first`和`last`构建一个名字列表，然后添加一个详细面板，显示所选名字的全名、电子邮件地址和电话号码。
- en: 'We start with our model and store first:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从我们的模型和存储开始：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This gives us our `first` and `last` values, which we will use for our initial
    list, and the `email`, `birthday`, and `address` information, which we will use
    for the details.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们`first`和`last`的值，我们将用于初始列表，以及`email`、`birthday`和`address`的信息，我们将用于详细信息。
- en: 'Sharp-eyed readers will also notice that we have changed our model to use Ajax
    as the proxy for an `api/contacts.json` URL (remember, our store will automatically
    use this proxy as well). This means that when the store loads, it will look for
    a local file in the `api` folder called `contacts.json`. This file is available
    as part of the downloadable code files for this book, and it contains some test
    data that we have thrown together. If you want to create your own file instead
    of downloading it, the format of the file looks like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者可能已经注意到，我们将模型更改为使用Ajax作为`api/contacts.json` URL的代理（记住，我们的存储将自动使用这个代理）。这意味着当存储加载时，它将在`api`文件夹中寻找一个名为`contacts.json`的本地文件。这个文件作为本书可下载代码文件的一部分提供，其中包含我们整理的一些测试数据。如果你不想下载它，而是想创建自己的文件，该文件的格式如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By setting this store to look at a local text file, we can add data quickly
    for testing by adding new `children` to the text file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此存储设置为查看本地文本文件，我们可以通过向文本文件添加新的`children`来快速添加测试数据。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Test data is your friend**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试数据是你朋友**'
- en: Whenever you put together an application and test it, you will probably need
    some data in order to make sure things are working correctly. It's often very
    tedious to enter this information into a text file manually or to enter it in
    data forms over and over again. Fortunately, [http://www.generatedata.com/](http://www.generatedata.com/)
    is a website that generates random data in a number of formats. Just provide the
    field names and types, and then tell the website how many records you need. Click
    on the button, and you get back random data, ready for testing. Best of all, it's
    free!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你组装一个应用程序并测试它，你可能需要一些数据以确保事情正常运行。通常，手动将此信息输入文本文件或一遍又一遍地输入数据表单是非常繁琐的。幸运的是，[http://www.generatedata.com/](http://www.generatedata.com/)
    是一个网站，可以以多种格式生成随机数据。只需提供字段名称和类型，然后告诉网站你需要多少条记录。点击按钮，你就可以得到准备测试的随机数据。最重要的是，它是免费的！
- en: '![Data stores and panels](img/0748OS_07_01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![数据存储和面板](img/0748OS_07_01.jpg)'
- en: 'Our `list` component basically stays the same as before. As `list` uses the
    template `itemTpl: ''{last}, {first}''` for each item in the list, it simply ignores
    the values for `address`, `city`, `state`, `zip`, `email`, and `birthday`. However,
    as these values are still part of the overall data record, we can still grab them
    and use them in our panel to display details.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的`list`组件基本上与之前保持不变。由于`list`使用模板`itemTpl: ''{last}, {first}''`对列表中的每个项目进行格式化，它简单地忽略了`address`、`city`、`state`、`zip`、`email`和`birthday`的值。然而，由于这些值仍然是数据记录的一部分，我们仍然可以获取它们并在我们的面板上使用它们来显示详情。'
- en: 'Before we can add our details panel, we need to create our `main` panel and
    set it to use a `card` layout. This will let us switch between the list and the
    details with a single tap:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够添加详情面板之前，我们需要创建一个`main`面板并将其设置为使用`card`布局。这将让我们通过一次轻触就能在列表和详情之间切换：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have set the `main` panel to use a `card` layout, with the `activeItem` component
    as `0`. In this case, item `0` is our `list`, which is built into the `main` panel.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`main`面板设置为使用`card`布局，`activeItem`组件为`0`。在这种情况下，项目`0`是我们的`list`，它被内置到`main`面板中。
- en: 'Make sure that all the components are wrapped inside an application launch
    function like our examples from the previous chapters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有组件都包裹在一个应用程序启动函数内，就像我们前几章的例子一样：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At the bottom, within the `launch` function, we add the `main` panel to the
    `Viewport`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，在`launch`函数内，我们向`Viewport`添加了`main`面板。
- en: Once you have your data and the `main` panel set up, load the page to make sure
    that things are working correctly with what we have so far.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了数据和`main`面板，加载页面以确保到目前为止我们所做的一切都是正确的。
- en: '![Data stores and panels](img/0748OS_07_02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![数据存储和面板](img/0748OS_07_02.jpg)'
- en: 'Now, we need to add in our `detailsPanel` component. We will start simple with
    this first part and add a new `panel` item after our list:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加我们的`detailsPanel`组件。我们首先在这个第一部分保持简单，并在我们的列表后添加一个新的`panel`项：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first thing we add is a simple template. We include some HTML line breaks
    to lay out the data in a better way. We also split the template into multiple
    lines for readability and used the `+` operator to concatenate the strings together.
    Then we add a `Back` button that will bring us back to our main list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个简单的模板。我们包含一些HTML换行符，以更好地布局数据。我们还把模板分成多行以提高可读性，并使用`+`运算符将字符串连接在一起。然后我们添加一个`返回`按钮，它将带我们回到主列表。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Since we already defined `main` as a variable in our code, we can use it inside
    our `handler` function. Since the `main` panel is also the first panel inside
    our viewport, we can grab it like this: `console.log(this.up(''viewport'').down(''panel''));`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在代码中将`main`定义为一个变量，我们可以在`handler`函数内使用它。由于`main`面板也是我们视口中的第一个面板，我们可以这样获取它：`console.log(this.up('viewport').down('panel'));`
- en: 'Once our `detailsPanel` is defined, we need to add a `listeners` section to
    our list to load the data into the panel:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`detailsPanel`被定义，我们需要在我们的列表中添加一个`listeners`部分，以将数据加载到面板中：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The good thing about this is that we don''t really need to load anything new.
    The list already has access to all of the extra data that is present in the data
    store. We also receive the record as part of the `itemTap` event. We can take
    this record and set it on the panel using the `setRecord()` function. Finally,
    we set the active item to our `detailsPanel` component. When we tap on an item
    in the list, the result looks as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好处是我们实际上并不需要加载任何新东西。列表已经可以访问数据存储中存在的所有额外数据。我们还在`itemTap`事件中接收记录作为一部分。我们可以获取这个记录，并使用`setRecord()`函数将其设置在面板上。最后，我们将活动项目设置为我们的`detailsPanel`组件。当我们轻触列表中的一个项目时，结果如下所示：
- en: '![Data stores and panels](img/0748OS_07_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![数据存储和面板](img/0748OS_07_03.jpg)'
- en: The `detailsPanel` component includes not only the first and last name from
    our list, but the address, e-mail, and birthday data as well. All of this data
    comes from the same data store; we simply use the templates to choose which data
    to display.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`detailsPanel`组件不仅包括我们从列表中的第一个和最后一个名字，还包括地址、电子邮件和出生日期数据。所有这些数据都来自同一个数据存储；我们只是使用模板来选择显示哪些数据。'
- en: Speaking of templates, ours looks a little dull, and the `birthday` value is
    a bit more specific than we really need. There must be something we can do to
    dress this up a bit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 说到模板，我们的看起来有点单调，而且`birthday`值比我们真正需要的要具体得多。我们必须想办法让这看起来更好一点。
- en: XTemplates
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XTemplates
- en: As we have seen from a number of previous examples, **XTemplate** is a structure
    that contains HTML layout information and placeholders for our data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从之前的许多例子中看到的那样，**XTemplate**是一个包含HTML布局信息和用于我们数据的占位符的结构。
- en: 'So far we have only created very basic templates for our list and panel using
    the data values and a bit of HTML. In our first example, we learned how to use
    the `+` operator to allow us to take a very long string and break it up into smaller
    strings for readability. Another way to do this is to set these templates up as
    separate components:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了用于我们的列表和面板的非常基本的模板，这些模板使用了数据值和一些HTML。在我们的第一个例子中，我们学会了如何使用`+`运算符，使我们能够将一个非常长的字符串拆分成更小的字符串，以提高可读性。另一种这样做的方法是将这些模板设置为独立的组件：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will create a template that looks exactly like what we had before. This
    is the way most examples on the Sencha Touch website are written, so it is good
    to be aware of both methods.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个与之前完全相同的模板。这是Sencha Touch网站上大多数示例的编写方式，所以知道这两种方法都是好的。
- en: 'Once we have our component template, we can then add it to our panel along
    with `tpl: myTemplate`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦我们有了组件模板，我们就可以将其添加到我们的面板中，并与`tpl: myTemplate`一起使用。'
- en: 'The following two methods provide better readability for your code while working
    with complex templates:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个方法在处理复杂模板时为您提供更好的可读性：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'or:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both methods provide the same result.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法提供相同的结果。
- en: '![XTemplates](img/0748OS_07_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![XTemplates](img/0748OS_07_04.jpg)'
- en: 'We can also use the same types of XTemplates with our main list to give it
    a bit more style. For example, adding the following code as the `itemTpl` component
    for our list will place an adorable kitten picture next to each name in the list:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用相同类型的XTemplates给我们的主列表添加一些样式。例如，将以下代码作为我们列表的`itemTpl`组件将会在列表中的每个名字旁边放置一个可爱的猫图片：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For this example, we just added an HTML component to lay out each line of data
    and then used a random image-generation service (in this case, [placekitten.com](http://placekitten.com))
    to place any 36x36 kitten picture, which will line up next to our names on the
    left (you can also use this to display the contact's picture).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是添加了一个HTML组件来布局每行数据，然后使用一个随机图像生成服务（在这个例子中，[placekitten.com](http://placekitten.com)）放置任何36x36的猫图片，它将位于左侧我们的名字旁边（你也可以用它来显示联系人的照片）。
- en: '![XTemplates](img/0748OS_07_05.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![XTemplates](img/0748OS_07_05.jpg)'
- en: At this point, we are still playing with basic HTML; however, XTemplates are
    much more powerful than that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仍然只是在使用基本的HTML；然而，XTemplates的功能要比这强大得多。
- en: Manipulating data
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作数据
- en: XTemplates also allow us to directly manipulate the data within the template
    in a number of ways. The first thing we can do is clean up that ugly birthday
    value!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: XTemplates还允许我们在模板中以多种方式直接操作数据。我们首先可以做的事情就是清理那个丑陋的生日值！
- en: 'Since the `birthday` value is listed in our model as being a `date` object,
    we can treat it like one in the template. We can replace the current birthday
    line of our template with the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的模型中`birthday`值被列为一个`date`对象，因此我们可以在模板中将其当作一个对象来处理。我们可以用以下内容替换我们模板中的当前生日行：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will use our value of `birthday`, and the format function `date`. `date`
    uses the string `"n/j/Y"` to convert `birthday` into a more readable format. These
    format strings can be found on the date page of the Sencha Touch API.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用我们的`birthday`值，以及格式化函数`date`。`date`函数使用字符串`"n/j/Y"`将`birthday`转换为更易读的格式。这些格式化字符串可以在Sencha
    Touch API的日期页面上找到。
- en: '![Manipulating data](img/0748OS_07_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/0748OS_07_06.jpg)'
- en: 'Sencha Touch includes a number of formatting functions that can be used in
    this fashion. Some of the functions include:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch包括许多可以以这种方式使用的格式化函数。这些函数包括：
- en: '`date`: This function formats a `date` object using the specified formatting
    string (the format strings can be found on the date page of the Sencha Touch API).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：这个函数使用指定的格式化字符串对`date`对象进行格式化（格式化字符串可以在Sencha Touch API的日期页面上找到）。'
- en: '`ellipsis`: This function truncates the string to a specified length and adds
    `…` to the end (note that `…` is considered to be part of the total length).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ellipsis`：这个函数将字符串截断到指定长度，并在末尾添加`…`（注意`…`被认为是总长度的部分）。'
- en: '`htmlEncode` and `htmlDecode`: These functions convert HTML characters (`&`,
    `<`, `>`, and `''`) to and from HTML.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`htmlEncode`和`htmlDecode`：这两个函数将HTML字符（`&`、`<`、`>`和`''`）转换为HTML或从HTML转换回来。'
- en: '`leftPad`: This function pads the left side of the string with a specified
    character (good for padding numbers with leading zeros).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`leftPad`：这个函数用指定的字符填充字符串的左侧（适用于用前导零填充数字）。'
- en: '`toggle`: This utility function switches between two alternating values.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toggle`：这个实用函数会在两个交替的值之间切换。'
- en: '`trim`: This function removes any white space from the beginning and end of
    the string. It leaves spaces with the string intact.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim`：这个函数会删除字符串开头和结尾的空格。它会保留字符串中的空格。'
- en: The basic functions can be used inside the HTML of our XTemplate to format our
    data. However, XTemplate has a few additional tricks up its sleeve.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的函数可以被用在我们的 XTemplate 的 HTML 内部来格式化我们的数据。然而，XTemplate 还有一些额外的小技巧。
- en: Looping through data
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环数据
- en: 'In a list view, the XTemplate for the `itemTpl` component is automatically
    applied to each item in the list. However, you can also loop through your data
    manually using the following syntax:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表视图中，`itemTpl` 组件的 XTemplate 会自动应用到列表中的每个项目上。然而，你也可以使用下面的语法手动地循环你的数据：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When you use the `<tpl>` tag, it tells XTemplate that we are exiting the realm
    of HTML and making some decisions within the template. In this case, `<tpl for=".">`
    tells the code to start a loop and use the root node of our data. The closing
    `</tpl>` tag tells the loop to stop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `<tpl>` 标签时，它告诉 XTemplate 我们正在退出 HTML 的领域，在模板内部做一些决策。在这个例子中，`<tpl for=".">`
    告诉代码开始一个循环，并使用我们数据的根节点。闭合的 `</tpl>` 标签告诉循环停止。
- en: 'Since we can have complex nested data with both XML and JSON, it can also be
    helpful to loop the data in other places besides the root node. For example, let''s
    say we have an array of states and each state contains an array of cities. We
    can loop through this data as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以拥有既包含 XML 又包含 JSON 的复杂嵌套数据，因此除了根节点之外，在其他的地点循环数据也会很有帮助。比如说，假设我们有一个包含州的数据数组，而每个州又包含一个城市数据数组。我们可以像下面这样循环这个数据：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our first `<tpl>` tag begins looping through our states, printing the name.
    After the name is printed, it looks for a child array within the individual state
    called `cities`. This time, when we use the variable `{name}`, it's inside our
    child loop so it prints the name of each city in the state before moving onto
    the next state in the loop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个 `<tpl>` 标签开始循环我们的州数据，打印出名称。在打印出名称之后，它会寻找个体州内部的名为 `cities` 的子数组。这次，当我们使用变量
    `{name}` 时，它处于我们的子循环中，所以它会打印出州内的每个城市的名称，然后继续循环到下一个循环中的下一个州。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Notice that when we use a field name inside our `<tpl>` tags, we do not use
    the curly braces like this: `{cities}`. Since we are outside the HTML section
    of our template, Sencha Touch assumes `"cities"` is a variable.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们在 `<tpl>` 标签内部使用字段名称时，我们不会像这样使用花括号：`{cities}`。由于我们处于模板的 HTML 部分之外，Sencha
    Touch 假定 `"cities"` 是一个变量。
- en: 'We can even access an array nested in each city, for example, `postal codes`,
    by adding another loop:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过添加另一个循环来访问每个城市中嵌套的数组，例如 `postal codes`：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, we have used `<tpl for="cities.postal">` to indicate that we will
    loop through the `postal codes` data array within the `cities` data array. Our
    other array loops execute as before.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `<tpl for="cities.postal">` 来表示我们将会在 `cities` 数据数组内部的 `postal codes`
    数据数组中循环。我们的其他数组循环像以前一样执行。
- en: Numbering within the loop
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环内的编号
- en: 'When you are working inside a loop, it''s often helpful to be able to count
    the cycles in the loop. You can do this by using `{#}` in your XTemplate:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在循环内部工作时，能够计算循环的次数通常很有帮助。你可以通过在你的 XTemplate 中使用 `{#}` 来做到这一点：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will print the current loop number next to each name in the loop. This
    will work in a similar fashion for nested data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在循环中的每个名字旁边打印当前的循环次数。这对于嵌套数据也会以类似的方式工作：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first `{#}` will display where we are in the main loop, and the second `{#}`
    will display where we are in the `cities` loop.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `{#}` 会在主循环中显示我们的位置，第二个 `{#}` 会在 `cities` 循环中显示我们的位置。
- en: Parent data in the loop
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环中的父数据
- en: 'In cases where we have nested data, it can also be helpful to be able to get
    to the parent properties from within the child loop. You can do this by using
    the `parent` object. Using our nested example with states, cities, and countries,
    this would look as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在嵌套数据的情况下，能够从子循环内部访问父级属性也会很有帮助。你可以通过使用 `parent` 对象来实现这一点。在我们的包含州、城市和国家的嵌套示例中，这看起来像这样：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When inside our `cities` loop, `{parent.name}` would display the state name
    for that city. When we are inside our `cities.postal` loop, `{parent.name}` would
    display the city name associated with that postal code. Using this `{parent.fieldname}`
    syntax, we can access any of the parent's values from within the current child
    item.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`cities`循环中时，`{parent.name}`将显示该城市的州名。当我们我们在`cities.postal`循环中时，`{parent.name}`将显示与那个邮政编码相关联的城市名称。使用这种`{parent.fieldname}`语法，我们可以从当前子项中访问父项的任何值。
- en: Conditional display
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件显示
- en: 'In addition to looping, XTemplates offer some limited conditional logic for
    use in your template. With the 2.x Version of Sencha Touch, we now have access
    to the full `if...then...else...` functionality. For example, we can use the `if`
    statement in our states and cities to only display cities with a population above
    2,000:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了循环，XTemplates还为您模板中提供了一些有限的条件逻辑。在Sencha Touch的2.x版本中，我们现在可以访问完整的`if...then...else...`功能。例如，我们可以在我们的州和城市中使用`if`语句，只显示人口超过2,000的城市：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we want to color code our cities based on more than one population target,
    then we can use `if...then...else` like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要根据多个人口目标对城市进行颜色编码，那么我们可以像这样使用`if...then...else`：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Conditional display](img/0748OS_07_07.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![条件显示](img/0748OS_07_07.jpg)'
- en: 'Now, you probably are already asking yourself why we are using `&gt;` and `&lt;`
    instead of `>` and `<`. The reason is that anything in our conditional statement
    needs to be HTML encoded for XTemplate to parse it correctly. This can be a bit
    confusing at first, but the key things to remember are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能已经自己在问自己为什么我们使用`&gt;`和`&lt;`而不是`>`和`<`。原因是我们的条件语句中的任何东西都需要进行HTML编码，以便XTemplate正确解析它。这可能一开始有点令人困惑，但需要记住的关键事情如下：
- en: Use `&gt;` instead of `>`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`&gt;`而不是`>`。
- en: Use `&lt;` instead of `<`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`&lt;`而不是`<`。
- en: 'Use equals as normal `==`. However, if you are comparing a string value, you
    have to escape the single quotes such as this: `''<tpl if="state == \''PA\''">''`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`==`作为等于符号。然而，如果你要比较一个字符串值，你必须转义单引号，例如这样：`'<tpl if="state == 'PA'">'`。
- en: You will need to encode `"` if it is part of your conditional statement. So
    if you are searching for the word `"spam"` including the quotes, you would have
    to encode it as `&quot;spam&quot;`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想将`"`编码为条件语句的一部分，那么您需要将其编码为`&quot;spam&quot;`。
- en: Arithmetic functionality
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术功能
- en: 'In addition to conditional logic, XTemplates also support basic math functionality
    for the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了条件逻辑，XTemplates还支持以下基本算术功能：
- en: Addition (`+`)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法（`+`）
- en: Subtraction (`-`)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法（`-`）
- en: Multiplication (`*`)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法（`*`）
- en: Division (`/`)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法（`/`）
- en: Modulus—the remainder of one number divided by another (`%`)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模数——一个数除以另一个数的余数（`%`）
- en: 'For example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This gives us our initial population value followed by a projected population
    of 1.15 times the current population. The math functions are included within the
    curly braces around our variable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们初始的人口值，接着是当前人口的1.15倍的预测人口。数学函数包含在我们变量的花括号中。
- en: Inline JavaScript
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联JavaScript
- en: 'We can also execute arbitrary inline code as part of our XTemplate by placing
    the code within a combination of brackets and curly braces: `{[…]}`. There are
    also a few special attributes we can access within this code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将代码放在括号和花括号组合中来执行任意的内联代码作为XTemplate的一部分：`{[…]}`。在此代码中还可以访问一些特殊属性：
- en: '`values`: This attribute holds the values in the current scope'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：此属性保留当前作用域中的值'
- en: '`parent`: This attribute holds the values of the current parent object'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：此属性保留当前父对象的价值'
- en: '`xindex`: This attribute holds the current index of the loop you are on'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xindex`：此属性保留您当前所在的循环索引'
- en: '`xcount`: This attribute holds the total number of items in the current loop'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xcount`：此属性保留当前循环中的项目总数'
- en: 'Let''s take an example to elaborate on these attributes. We can make sure that
    our state and city names are in uppercase and the colors alternate on our list
    of cities by using the following XTemplate:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来阐述这些属性。我们可以确保我们的州和城市名称是大写的，并且列表中城市的颜色交替，通过使用以下的XTemplate：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, we use `{[values.name.toUpperCase()]}` to force the name of the
    state and the city to be in uppercase. We also use `{[xindex % 2 === 0 ? "even"
    : "odd"]}` to alternate our row colors based on the remainder of the current count
    divided by `2` (the modulus operator).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，我们使用`{[values.name.toUpperCase()]}`将州和城市的名称强制为大写。我们还使用`{[xindex % 2
    === 0 ? "even" : "odd"]}`根据当前计数除以2的余数（取模运算符）交替行颜色。'
- en: Even with the ability to write inline JavaScript, there are a number of cases
    where you might require something a bit more robust. This is where the XTemplate
    member functions come into play.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了编写内联JavaScript的能力，有许多情况下你可能需要更加健壮的东西。这就是XTemplate成员函数发挥作用的地方。
- en: XTemplate member functions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XTemplate成员函数
- en: An XTemplate member function allows you to attach a JavaScript function to your
    XTemplate and then execute it inside the template by calling `this.function_name`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个XTemplate成员函数允许你将一个JavaScript函数附加到你的XTemplate上，然后通过调用`this.function_name`在模板内部执行它。
- en: 'The functions are added to the end of the template, and a template can include
    multiple member functions. These member functions are wrapped in a set of curly
    braces in a fashion similar to that for listeners:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数添加到模板的末尾，一个模板可以包含多个成员函数。这些成员函数被一对花括号括起来，这与监听器的风格类似：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can use these member functions to return additional data to our template.
    Let's use our earlier states and cities example, and see how we can place a special
    icon next to larger cities based on multiple amounts of our data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些成员函数向我们的模板返回附加数据。让我们使用我们之前的州和城市示例，看看我们如何根据我们数据的多个量在较大的城市旁边放置一个特殊图标。
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For this example, we have created a member function called `isLargeCity`, within
    which we pass our data. Since our function can execute any JavaScript we desire,
    we can use the result to control the template. We can then call the function inside
    our template with `{[this.isLargeCity(values)]}` that will print our `bigCity.png`
    image based on the values in the data record.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`isLargeCity`的成员函数，在其中传递我们的数据。由于我们的函数可以执行任何我们想要的JavaScript，我们可以使用结果来控制模板。然后我们可以在模板中调用函数`{[this.isLargeCity(values)]}`，根据数据记录中的值打印我们的`bigCity.png`图片。
- en: '![XTemplate member functions](img/0748OS_07_08.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![XTemplate成员函数](img/0748OS_07_08.jpg)'
- en: 'We can also use our member functions to help us test for the presence or absence
    of data. This comes in very handy for controlling our template. For example, let''s
    start with a contacts template that contains a name, address, and e-mail, similar
    to the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用成员函数来帮助我们检查数据是否存在或不存在。这在控制我们的模板时非常有用。例如，让我们从一个包含姓名、地址和电子邮件的联系人模板开始，类似于以下内容：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we have no data for `address`, `city`, and `state`, we will end up with some
    empty lines and a stray comma. Since our `zip` variable is an `integer` according
    to our model, it will show up as **0** if we don't have a value stored for it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有`address`、`city`和`state`的数据，我们最终会有一些空行和一个多余的逗号。由于根据我们的模型，`zip`变量是一个`integer`，如果我们没有为它存储值，它将显示为**0**。
- en: '![XTemplate member functions](img/0748OS_07_09.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![XTemplate成员函数](img/0748OS_07_09.jpg)'
- en: We need a way to check and see if we have data for these items before we print
    them onto the screen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来检查在将这些项目打印到屏幕之前我们是否有这些项目的数据。
- en: The isEmpty function
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空函数
- en: 'As it turns out, native JavaScript is very problematic when it comes to detecting
    an empty value. Depending on the function, JavaScript might return the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，原生JavaScript在检测空值方面非常有问题。根据函数的不同，JavaScript可能会返回以下内容：
- en: 'Null'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: Undefined
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: An empty array
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空数组
- en: An empty string
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串
- en: For most of us, these are pretty much the same thing; we didn't get back anything.
    However, to JavaScript, these return values are very different. If we try to test
    for data with `if(myVar == '')` and we get back `null`, `undefined`, or an empty
    array, JavaScript will return `false`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们大多数人来说，这些都是差不多一样的东西；我们没有得到任何东西。然而，对于JavaScript来说，这些返回值是非常不同的。如果我们尝试用`if(myVar
    == '')`来测试数据，并且我们得到`null`、`undefined`或空数组，JavaScript将返回`false`。
- en: Fortunately, Sencha Touch has a handy little function called `isEmpty()`. This
    function will test for null, undefined, empty arrays, and empty strings, all in
    one function. However, Sencha Touch does not have an opposite function for `has
    data`, which is what we really want to test for. Thanks to template member functions,
    we can write our own.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Sencha Touch有一个方便的小函数叫做`isEmpty()`。这个函数将测试null、undefined、空数组和空字符串，所有这些都在一个函数中。然而，Sencha
    Touch没有一个相反的函数来测试`有数据`，这是我们真正想要测试的。多亏了模板成员函数，我们可以编写自己的函数。
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We don't even need a member function for this data check. We can add `<tpl if="!Ext.isEmpty(address)">`
    to our template and check for the address in line with our template. The `Ext.isEmpty`
    function class takes the address data and determines whether it is empty or contains
    data, returning `true` or `false` respectively. If `address` is not empty, we
    print the address and if it is empty, we do nothing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至不需要为这个数据检查编写成员函数。我们可以在我们的模板中添加`<tpl if="!Ext.isEmpty(address)">`，并与我们的模板并列检查地址。`Ext.isEmpty`函数类获取地址数据，确定它是空的还是包含数据，分别返回`true`或`false`。如果`address`不为空，我们打印出地址，如果为空，我们什么都不做。
- en: Changing a panel's content with XTemplate.overwrite
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XTemplate.overwrite更改面板内容
- en: In our previous examples, we have declared XTemplate as part of our panel or
    list, using `tpl` or `itemtpl`. However, it can also be helpful to overwrite a
    template programmatically after the list or panel is displayed. You can do this
    by declaring a new template and then using the panel's or list's `overwrite` command
    to combine the template and data, and overwrite the content area of your panel
    or list.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们已经将XTemplate作为我们面板或列表的一部分声明，使用`tpl`或`itemtpl`。然而，在列表或面板显示之后，编程地覆盖一个模板也可能很有帮助。您可以通过声明一个新的模板，然后使用面板或列表的`overwrite`命令将模板和数据结合，覆盖面板或列表的内容区域来实现。
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our `overwrite` function takes an element (`Ext` or `HTML`) as the first argument.
    So instead of just using panel, we need to use the body element of the panel as
    `panel.body`. We can then supply a record from a data store or an array of values
    as our second argument for the new template to use.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`overwrite`函数将一个元素（`Ext`或`HTML`）作为第一个参数。所以，我们不仅需要使用面板，还需要使用面板的`body`元素作为`panel.body`。然后，我们可以为新的模板提供来自数据存储的一个记录或一个值数组作为第二个参数。
- en: While XTemplates are extremely powerful for displaying our data, they are still
    very text heavy. What if we want to display data in a more colorful way? Let's
    take a look at Sencha Touch Charts to learn how we can do this.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然XTemplates对于显示我们的数据非常强大，但它们仍然非常文本化。如果我们想以更有色彩的方式显示数据会怎样？让我们来看看Sencha Touch
    Charts，了解我们如何做到这一点。
- en: Sencha Touch Charts
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sencha Touch Charts
- en: So far, we have only looked at data stores and records as a way to display text
    data, but with the release of Sencha Touch Charts, we are now able to display
    complex graphical data as part of our applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是查看了数据存储和记录作为显示文本数据的方式，但随着Sencha Touch Charts的发布，我们现在能够以图形数据的形式在我们的应用程序中显示复杂的数据。
- en: '![Sencha Touch Charts](img/0748OS_07_10.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Sencha Touch Charts](img/0748OS_07_10.jpg)'
- en: 'These new components use data stores to display a wide range of chart and graph
    types, including the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新组件使用数据存储来显示各种图表和图类型，包括以下类型：
- en: Pie Chart
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图
- en: Bar
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柱状图
- en: Line
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折线图
- en: Scatter
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图
- en: Candlestick
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜡烛图
- en: OHLC (Open High Low Close)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OHLC（开盘价、最高价、最低价、收盘价）
- en: Bubble
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气泡图
- en: While a full exploration of the chart components would be worthy of a book by
    itself, we will provide an overview of how these components interact with the
    data store and, hopefully, boost your curiosity.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对图表组件的全面探索值得一本单独的书，但我们将提供一个这些组件如何与数据存储交互的概述，并希望激发你的好奇心。
- en: Installing Sencha Touch Charts
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Sencha Touch Charts
- en: As of Version 2.1, Sencha Touch Charts are built in to Sencha Touch and no longer
    require a separate download. At the time of writing, the Charts package license
    was available as part of the open source GPLv3 license or as a part of Sencha
    Complete or Sencha Touch Bundle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 截至版本2.1，Sencha Touch Charts已集成到Sencha Touch中，不再需要单独下载。在撰写本文时，图表包许可作为开源GPLv3许可的一部分提供，或作为Sencha
    Complete或Sencha Touch Bundle的一部分提供。
- en: A simple pie chart
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的饼图
- en: 'Let''s start with a simple JavaScript file for our charts example, beginning
    with a data store:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的JavaScript文件开始，用于我们的图表示例，从数据存储开始：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our store declares two field types, `month` and `sales`, and our data array
    holds five sets of `month` and `sales` values. This will feed into a polar chart,
    in this case, a pie chart. After the store definition, we add the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的存储声明了两个字段类型，`month`和`sales`，我们的数据数组持有五组`month`和`sales`值。这将输入到极坐标图中，在本例中，是一个饼图。在存储定义之后，我们添加如下内容：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Much like our other panel components, an `Ext.chart.PolarChart` class takes
    standard configurations such as `height`, `width`, and `fullscreen`. It also has
    a few special configurations, such as `innerPadding`, which is the padding between
    the axis and the series, and `background`, which is the background color behind
    the chart. The `chart` component also takes a `store` configuration option that
    we will set to our previously created `mystore` component.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的其他面板组件一样，`Ext.chart.PolarChart`类需要一些标准的配置，如`height`、`width`和`fullscreen`。它还有一些特殊的配置，如`innerPadding`，这是坐标轴和系列之间的填充，以及`background`，这是图表背后的背景颜色。`chart`组件还需要一个`store`配置选项，我们将将其设置为我们之前创建的`mystore`组件。
- en: 'The `interactions` section allows us to specify some visual tools that allow
    theuser to interact with the chart. Each type of chart has its own set of interactions.
    The current interactions include:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`interactions`部分允许我们指定一些视觉工具，使用户能够与图表互动。每种图表都有它自己的一组交互。当前的交互包括：'
- en: '`panzoom`: This interaction allows us to pan and zoom across the axes'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panzoom`：此交互允许我们在坐标轴之间平移和缩放'
- en: '`itemhighlight`: This interaction allows us to highlight series data points'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemhighlight`：此交互允许我们突出显示系列数据点'
- en: '`iteminfo`: This interaction allows us to display the details of a data point
    in a pop-up panel'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iteminfo`：此交互允许我们在弹出面板中显示数据点的详细信息'
- en: '`rotate`: This interaction allows the rotation of the pie chart and radar series'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate`：此交互允许旋转饼图和雷达系列'
- en: Next we have a configuration for our chart's `legend`. This provides a color-coded
    reference for all our chart values. We can use a position configuration to designate
    how the legend should appear in portrait and landscape modes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们图表的`legend`配置。这为我们的所有图表值提供了颜色编码的参考。我们可以使用一个位置配置来指定图例在纵向和横向模式下应如何显示。
- en: 'The final piece is our `series` configuration. In our example, we have set:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是我们的`series`配置。在我们的示例中，我们设置了：
- en: The **type** of chart we will see
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看到的**类型**的图表
- en: Which **xfield** the chart will use to determine the size of the pie slices
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表将使用哪个**xfield**来确定饼图扇区的大小
- en: The value of **labelField** to use for the slices
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要用于饼图扇区的**labelField**的值
- en: The **size** of the donut hole at the center of our pie chart
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图中心孔洞的**大小**
- en: The overall **style** of the chart
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表的**整体风格**
- en: 'When we load it all up, our chart looks as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载所有内容时，我们的图表如下所示：
- en: '![A simple pie chart](img/0748OS_07_11.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的饼图](img/0748OS_07_11.jpg)'
- en: If you click on any of the months on the legend, you can turn them on or off
    in the chart. This functionality happens automatically without any additional
    code. Our interaction setting also lets us click-and-drag to rotate the chart.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击图例上的任何月份，您可以将其在图表中打开或关闭。这个功能无需任何额外代码即可自动发生。我们的交互设置还允许我们点击并拖动以旋转图表。
- en: This kind of pie chart works well for very simple single-series data, but what
    happens if we have data for several years? Let's see how a bar chart might work
    to display this kind of data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种饼图非常适合非常简单的单系列数据，但如果我们有几年的数据呢？让我们看看柱状图可能如何显示这种数据。
- en: A bar chart
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柱状图
- en: 'For our bar chart, let''s replace our chart data store with the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的柱状图，让我们用以下内容替换我们的图表数据存储：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This data set has multiple series of data that we need to display (five months,
    with three years for each month). An effective bar chart will need to display
    a row for each month and separate bars within the month for each of the years.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集有我们需要显示的多系列数据（五个月，每个月有三年的数据）。一个有效的柱状图需要为每个月显示一行，并在同一个月内为每个年份显示不同的柱状图。
- en: 'Next, we need to change our `PolarChart` to `CartesianChart` like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的`PolarChart`更改为`CartesianChart`，如下所示：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Like our pie chart, the bar chart component takes configuration options for
    `background`, `fullscreen`, a data `store`, and the `panzoom` interaction. This
    option us allows to pan and zoom across our axes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的饼图一样，柱状图组件也需要`background`、`fullscreen`、数据`store`以及`panzoom`交互的配置选项。这个选项使我们能够在坐标轴之间进行平移和缩放。
- en: We then have our legend as before, followed by a new configuration option called
    `axes`. Since a bar chart operates along the x and y axes, we need to specify
    what type of data is being fed into each axis (in this case, the `bottom` and
    `left` axes).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是我们之前的图例，后面跟着一个新配置选项叫做`axes`。由于柱状图沿着x轴和y轴进行操作，我们需要指定每个轴输入的是什么类型的数据（在这个例子中，是`bottom`和`left`轴）。
- en: First up is our sales data for each year. The data is numeric, positioned at
    the bottom and given the title of `sales`. We also specify what our minimum value
    should be (this is the number that will appear on the far-left corner of our bar
    chart and will usually be `0`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是我们每年的销售数据。这些数据是数值型的，位于底部，并命名为`sales`。我们还指定了我们的最小值应该是多少（这个数字将出现在柱状图的最左端，通常会是`0`）。
- en: The next axis is our category data (which will also be used for our legend).
    In this case, our `position` is `left`, and our `title` is `Month of the Year`.
    With this we complete our `axes` configuration.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个轴是我们的分类数据（也将用于我们的图例）。在这个例子中，我们的`position`是`left`，我们的`title`是`一年的月份`。有了这个，我们就完成了`axes`配置。
- en: Finally, we have our `series` configuration, which sets this up as a bar graph.
    Unlike our previous pie chart example, which only tracked sales data for a single
    point, the bar chart tracks sales data for two separate points (`month` and `year`),
    so we need to assign our `xField` and `yField` variables and declare an axis location.
    This location should match the axis where you are displaying numerical data (in
    our case, the data is on the y axis, which is at the bottom). We close out by
    using `showInLegend` to display our legend.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是我们的`series`配置，将其设置为柱状图。与我们之前的饼图示例不同，后者只跟踪单个点的销售数据，而柱状图跟踪两个不同点的销售数据（`month`和`year`），因此我们需要分配我们的`xField`和`yField`变量，并声明一个轴位置。这个位置应该与您显示数值数据所在的轴匹配（在我们的案例中，数据在y轴上，位于底部）。我们最后使用`showInLegend`来显示我们的图例。
- en: 'The final chart should look as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图表应该如下所示：
- en: '![A bar chart](img/0748OS_07_12.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![柱状图](img/0748OS_07_12.jpg)'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Charts are an incredibly robust way to use stores to display data. We don't
    really have time to go through them all here, but you can explore all of the capabilities
    of Sencha Touch Charts at [http://docs.sencha.com/touch/2.2.0/#!/guide/drawing_and_charting](http://docs.sencha.com/touch/2.2.0/#!/guide/drawing_and_charting).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图表是使用存储显示数据的一种非常灵活的方式。我们在这里实在没有时间一一讲解，但你可以通过[http://docs.sencha.com/touch/2.2.0/#!/guide/drawing_and_charting](http://docs.sencha.com/touch/2.2.0/#!/guide/drawing_and_charting)探索Sencha
    Touch Charts的所有功能。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored the way data stores can be used to display
    both simple and complex data. We talked about binding, sorting, paging, and loading
    data stores. We then walked through using data stores with both lists and panels.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了数据存储可以用来显示简单和复杂数据的方式。我们谈论了绑定、排序、分页和加载数据存储。然后我们通过使用数据存储与列表和面板结合的方式进行讲解。
- en: We also covered how to lay out your application by using XTemplates to control
    how the data from stores and records will appear. We explored how to manipulate
    and loop through our data inside an XTemplate, as well as how to use conditional
    logic, arithmetic, and inline JavaScript. We finished up our conversation on XTemplates
    by discussing member functions and some of their uses. We concluded our chapter
    with a look at using the Sencha Touch Charts package to display our store data
    graphically.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讲解了如何使用XTemplates来控制存储和记录中的数据布局。我们探讨了如何在XTemplate中操作和遍历我们的数据，以及如何使用条件逻辑、算术和内联JavaScript。我们在讨论XTemplates时，通过讨论成员函数及其用途来结束。我们通过查看如何使用Sencha
    Touch Charts包以图形化的方式显示我们的存储数据来结束本章。
- en: In our next chapter, we will explore how to put all of the information from
    our previous chapters together into a full-scale application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将我们前几章的所有信息整合到一个完整的应用程序中。
