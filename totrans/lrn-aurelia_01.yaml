- en: Chapter 1. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章 入门
- en: Developer experience is a key strength of Aurelia. Its authors paid careful
    attention to every aspect of the development process, so using the framework is
    seamless and fluid, and so the learning curve is as smooth as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia 开发者体验是其关键优势。该框架的作者对开发过程中的每一个环节都给予了深思熟虑的关注，因此使用该框架的过程无缝而流畅，从而使得学习曲线尽可能平滑。
- en: This book humbly attempts to follow the same philosophy. It will teach you how
    you can use Aurelia to build real-world applications from A to Z. In fact, while
    reading the book and following the code samples, that's exactly what you will
    do. You will start by setting up your development environment and creating the
    project, then I will walk you through concepts such as routing, templating, data
    binding, automated testing, internationalization, and bundling. We will discuss
    application design, communication between components, and integration of third
    parties. We will cover every topic most modern, real-world single-page applications
    require.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书谦虚地遵循了同样的哲学。它将教你如何从 A 到 Z 使用 Aurelia 构建真实世界的应用程序。实际上，在阅读本书并跟随代码示例时，你确实会做这件事。你将从设置你的开发环境和创建项目开始，然后我会引导你了解诸如路由、模板、数据绑定、自动化测试、国际化以及打包等概念。我们将讨论应用程序设计、组件之间的通信以及第三方集成。我们将涵盖所有现代、真实世界的单页应用程序所需的主题。
- en: In this first chapter, we will start by defining some terms that will be used
    throughout the book. We will quickly cover some core Aurelia concepts. Then we
    will take a look at the core Aurelia libraries and see how they interact with
    each other to form a complete, full-featured framework. We will see also what
    tools are needed to develop an Aurelia application and how to install them. Finally,
    we will start creating our application and explore its global structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们将首先定义一些将在整本书中使用的术语。我们将快速介绍 Aurelia 的核心概念。然后，我们将查看核心 Aurelia 库，并了解它们如何相互交互以形成一个完整、功能丰富的框架。我们还将了解开发
    Aurelia 应用程序所需的工具以及如何安装它们。最后，我们将开始创建我们的应用程序并探索其全局结构。
- en: Terminology
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: As this book is about a JavaScript framework, JavaScript plays a central role
    in it. If you are not completely up-to-date with the terminology, which has changed
    a lot in the last few years, let me clear a few things up.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书是关于一个 JavaScript 框架的，因此 JavaScript 在其中扮演着中心角色。如果你对最近几年变化很大的术语不是完全了解，让我来澄清一些事情。
- en: JavaScript (or JS) is a dialect, or implementation, of the **ECMAScript** (**ES**)
    standard. It is not the only implementation, but it is definitely the most popular.
    In this book, I will use the JS acronym to talk about actual JavaScript code or
    code files and the ES acronym when talking about an actual version of the ECMAScript
    standard.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript（或 JS）是 **ECMAScript**（**ES**）标准的方言或实现。它不是唯一的实现，但绝对是其中最受欢迎的。在这本书中，我将使用
    JS 缩写来讨论实际的 JavaScript 代码或代码文件，而在谈论实际的 ECMAScript 标准版本时，我将使用 ES 缩写。
- en: Like everything in computer programing, the ECMAScript standard evolves over
    time. At the time of writing, the latest version is **ES2016** and was published
    in June 2016\. It was originally called **ES7,** but **TC39**, the committee drafting
    the specification, decided to change their approval and naming model, hence the
    new name.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就像计算机编程中的所有事物一样，ECMAScript 标准随时间不断发展。在撰写本书时，最新版本是 **ES2016**，于 2016 年 6 月发布。它最初被称为
    **ES7，**但制定规范的 **TC39** 委员会决定改变他们的批准和命名模型，因此有了新名字。
- en: The previous version, named **ES2015** (**ES6**) before the naming model changed,
    was published in June 2015 and was a big step forward as compared to the version
    before it. This older version, named **ES5**, was published in 2009 and was the
    most recent version for six years, so it is now widely supported by all modern
    browsers. If you have been writing JavaScript in the last five years, you should
    be familiar with ES5.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的版本，在命名模型改变之前称为 **ES2015**（**ES6**）的版本，于 2015 年 6 月发布，与之前的版本相比是一个很大的进步。这个较早的版本，称为
    **ES5**，于 2009 年发布，是六年来最新的版本，因此现在所有现代浏览器都广泛支持。如果你在过去五年中一直在编写 JavaScript，你应该熟悉
    ES5。
- en: When they decided to change the ES naming model, the TC39 committee also chose
    to change the specification's approval model. This decision was made in an effort
    to publish new versions of the language at a quicker pace. As such, new features
    are being drafted and discussed by the community, and must pass through an approval
    process. Each year, a new version of the specification will be released, comprising
    the features that were approved during the year.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们决定改变ES命名模型时，TC39委员会还选择改变规格的批准模型。这个决定是为了更快地发布语言的新版本。因此，新的特性正在社区中起草和讨论，必须通过一个批准过程。每年，将发布一个新的规格版本，包括当年批准的特性和概念。
- en: Those upcoming features are often referred as **ESNext**. This term encompasses
    language features that are approved or at least pretty close to approval but not
    yet published. It can be reasonable to expect that most or at least some of those
    features will be published in the next language version.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些即将推出的功能通常被称为**ESNext**。这个术语包括已经批准或至少相当接近批准但尚未发布的语言特性。可以合理地期待其中大多数或至少一些特性将在下一个语言版本中发布。
- en: As ES2015 and ES2016 are still recent versions, they are not fully supported
    by most browsers. Moreover, ESNext features have typically no browser support
    at all.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ES2015和ES2016仍然是较新的版本，它们并没有得到大多数浏览器的完全支持。此外，ESNext特性通常根本没有浏览器支持。
- en: Those multiple names can be pretty confusing. To make things simpler, I will
    stick with the official names ES5 for the previous version, ES2016 for the current
    version and ESNext for the next version. But that's only my preference; in the
    following chapters, we may encounter some tools or libraries still using the original
    nomenclature.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多个名称可能会让人感到相当困惑。为了简化事情，我将坚持使用官方名称ES5代表之前版本，ES2016代表当前版本，ESNext代表下一个版本。但这只是我的偏好；在接下来的章节中，我们可能会遇到一些仍然使用原始命名法的工具或库。
- en: Before going any further, you should make yourself familiar with the features
    introduced by ES2016 and with ESNext decorators, if you are not already. We will
    use these features throughout the book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，你应该熟悉ES2016引入的功能以及ESNext装饰器（如果你还不熟悉的话）。我们将在整本书中使用这些功能。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you don''t know where to start with ES2015 and ES2016, you can find a great
    overview of the new features on Babel''s website:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道从ES2015和ES2016开始，你可以在Babel网站上找到新特性的概述：
- en: '[https://babeljs.io/docs/learn-es2015/](https://babeljs.io/docs/learn-es2015/)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://babeljs.io/docs/learn-es2015/](https://babeljs.io/docs/learn-es2015/)'
- en: 'As for ESNext decorators, Addy Osmani, a Google engineer, explained them pretty
    well:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 至于ESNext装饰器，谷歌工程师Addy Osmani解释得相当好：
- en: '[https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841](https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841](https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841)'
- en: 'For further reading, you can take a look at the feature proposals (decorators,
    class property declarations, async functions, and so on) for future ES versions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为进一步阅读，你可以查看未来ES版本的特性提案（如装饰器、类属性声明、异步函数等）：
- en: '[https://github.com/tc39/proposals](https://github.com/tc39/proposals)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/tc39/proposals](https://github.com/tc39/proposals)'
- en: Core concepts
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心概念
- en: Before we start getting our hands dirty, there are a couple of core concepts
    that need to be explained.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实践之前，有几个核心概念需要解释。
- en: Conventions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约定
- en: First, Aurelia relies a lot on conventions. Most of those conventions are configurable,
    and can be changed if they don't suit your needs. Each time we'll encounter a
    convention throughout the book, we will see how to change it whenever possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Aurelia非常依赖约定。其中大多数约定是可配置的，如果它们不符合你的需求，可以进行更改。每当我们在书中遇到一个约定时，我们都会看看是否有可能改变它。
- en: Components
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: Components are a first class citizen of Aurelia. What is an Aurelia component?
    It is a pair made of an HTML template, called the **view**, and a JavaScript class,
    called the **view-model**. The view is responsible for displaying the component,
    while the view-model controls its data and behavior. Typically, the view sits
    in an `.html` file and the view-model in a `.js` file. By convention, those two
    files are bound through a naming rule, they must be in the same directory and
    have the same name (except for their extension, of course).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Aurelia的一等公民。Aurelia组件是什么？它由一个HTML模板组成，称为**视图**，和一个JavaScript类组成，称为**视图模型**。视图负责显示组件，而视图模型控制其数据和行为。通常，视图位于一个`.html`文件中，视图模型在`.js`文件中。按照约定，这两个文件通过命名规则绑定，它们必须位于同一目录中，并且具有相同的名称（当然，除了它们的扩展名）。
- en: 'Here''s an example of an empty component with no data, no behavior, and a static
    template:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个没有数据、没有行为和静态模板的空组件的示例：
- en: '`component.js`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`component.js`'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`component.html`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`component.html`'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A component must comply with two constraints, a view's root HTML element must
    be the `template` element, and the view-model class must be exported from the
    `.js` file. As a rule of thumb, the only function that should be exported by a
    component's JS file should be the view-model class. If multiple classes or functions
    are exported, Aurelia will iterate on the file's exported functions and classes
    and will use the first it finds as the view-model. However, since the enumeration
    order of an object's keys is not deterministic as per the ES specification, nothing
    guarantees that the exports will be iterated in the same order they were declared,
    so Aurelia may pick the wrong class as the component's view-model.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 组件必须遵守两个约束，视图的根HTML元素必须是`template`元素，视图模型类必须从`.js`文件中导出。作为一个经验法则，组件的JS文件应该只导出一个视图模型类。如果导出了多个类或函数，Aurelia将在文件的导出函数和类上迭代，并使用找到的第一个作为视图模型。然而，由于ES规范中对象的键的枚举顺序不是确定的，没有任何保证导出会按照它们声明的顺序进行迭代，所以Aurelia可能会将错误的类作为组件的视图模型。
- en: The only exception to that rule is some view resources which we'll see in [Chapter
    3](ch03.html "Chapter 3. Displaying Data"), *Displaying Data*, and [Chapter 5](ch05.html
    "Chapter 5. Making Reusable Components"), *Making Reusable Components*. In addition
    to its view-model class, a component's JS file can export things like value converters,
    binding behaviors, and custom attributes basically any view resource that can't
    have a view, which excludes custom elements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那个规则的唯一例外是一些视图资源，我们将在[第3章](ch03.html "第3章 显示数据")，*显示数据*，和[第5章](ch05.html "第5章 创建可复用的组件")，*创建可复用的组件*中看到它们。除了它的视图模型类，一个组件的JS文件可以导出像值转换器、绑定行为和自定义属性等东西，基本上任何不能有视图的视图资源，这排除了自定义元素。
- en: Components are the main building blocks of an Aurelia application. Components
    can use other components; they can be composed to form bigger or more complex
    components. Thanks to the slot mechanism, you can design a component's template
    so parts of it can be replaced or customized. We will see all of this in the next
    chapters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Aurelia应用的主要构建块。组件可以使用其他组件；它们可以组合成更大的或更复杂的组件。得益于插槽机制，你可以设计一个组件的模板，使其部分可以被替换或自定义。我们将在接下来的章节中看到所有这些。
- en: Architecture
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: Aurelia is not your average monolithic framework. It is a set of loosely coupled
    libraries with well-defined abstractions. Each of its core libraries solves a
    specific and well-defined problem common to single-page applications. Aurelia
    leverages dependency injection and a plugin architecture so you can discard parts
    of the framework and replace them with third-party or even your own implementations.
    Or you can just throw away features you don't need so your application is lighter
    and faster to load. We will look deeper into this plugin mechanism in [Chapter
    2](ch02.html "Chapter 2. Layout, Menu, and Getting Familiar"), *Layout, Menu,
    and Getting Familiar*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia不是您通常意义上的单页应用的单体框架。它是一组松散耦合的库，具有明确定义的抽象。它的每个核心库都解决了一个特定且明确定义的问题，这是单页应用中常见的。Aurelia利用依赖注入和插件架构，因此您可以丢弃框架的部分内容，用第三方甚至您自己的实现来替换它们。或者，您也可以丢弃不需要的功能，使您的应用程序更轻便，加载速度更快。我们将在[第2章](ch02.html
    "第2章 布局、菜单和熟悉")，*布局、菜单和熟悉*中更深入地了解这个插件机制。
- en: The core Aurelia libraries can be divided into multiple categories. Let's have
    a quick glance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 核心Aurelia库可以分为多个类别。让我们快速浏览一下。
- en: Core features
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心功能
- en: 'The following libraries are mostly independent and can be used by themselves
    if needed. They each provide a focused set of features and are at the core of
    Aurelia:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库大多相互独立，如果需要，可以单独使用。它们各自提供一组专注的功能，是Aurelia的核心：
- en: '`aurelia-dependency-injection`: A lightweight yet powerful dependency injection
    container. It supports multiple lifetime management strategies and child containers.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-dependency-injection`：一个轻量级但强大的依赖注入容器。它支持多种生命周期管理策略和子容器。'
- en: '`aurelia-logging`: A simple logger, supporting log levels and pluggable consumers.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-logging`：一个简单的日志记录器，支持日志级别和可插拔的消费者。'
- en: '`aurelia-event-aggregator`: A lightweight message bus, used for decoupled communication.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-event-aggregator`：一个轻量级的消息总线，用于解耦通信。'
- en: '`aurelia-router`: A client-side router, supporting static, parameterized or
    wildcard routes, and child routers.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-router`：一个客户端路由器，支持静态、参数化或通配符路由，以及子路由。'
- en: '`aurelia-binding`: An adaptive and pluggable data-binding library.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-binding`：一个适应性强且可插拔的数据绑定库。'
- en: '`aurelia-templating`: An extensible HTML templating engine.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-templating`：一个可扩展的HTML模板引擎。'
- en: Abstraction layers
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象层
- en: 'The following libraries mostly define interfaces and abstractions in order
    to decouple concerns and enable extensibility and pluggable behaviors. This does
    not mean that some of the libraries in the previous section do not expose their
    own abstractions besides their features. Some of them do. But the libraries described
    in the current section have almost no other purpose than defining abstractions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库主要定义接口和抽象，以解耦关注点并启用可扩展性和可插拔行为。这并不意味着上一节中的某些库没有除了它们的功能之外的自己的抽象。其中一些确实有。但当前节中描述的库几乎除了定义抽象之外没有其他目的：
- en: '`aurelia-loader`: An abstraction defining an interface for loading JS modules,
    views, and other resources.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-loader`：一个定义了加载JS模块、视图和其他资源的接口的抽象。'
- en: '`aurelia-history`: An abstraction defining an interface for history management
    used by routing.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-history`：一个定义了历史管理接口的抽象，被路由使用。'
- en: '`aurelia-pal`: An abstraction for platform-specific capabilities. It is used
    to abstract away the platform on which the code is running, such as a browser
    or Node.js. Indeed, this means that some Aurelia libraries can be used on the
    server side.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-pal`：一个用于平台特定能力的抽象。它用于抽象代码运行的平台，如浏览器或Node.js。实际上，这意味着一些Aurelia库可以在服务器端使用。'
- en: Default implementations
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认实现
- en: 'The following libraries are the default implementations of abstractions exposed
    by libraries from the two previous sections:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库是前两节库暴露的抽象的默认实现：
- en: '`aurelia-loader-default`: An implementation of the `aurelia-loader` abstraction
    for SystemJS and `require`-based loaders.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-loader-default`：`aurelia-loader`抽象的SystemJS和`require`基础加载器的实现。'
- en: '`aurelia-history-browser`: An implementation of the `aurelia-history` abstraction
    based on standard browser hash change and push state mechanisms.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-history-browser`：基于标准浏览器哈希变化和推态机制的`aurelia-history`抽象的实现。'
- en: '`aurelia-pal-browser`: An implementation of the `aurelia-pal` abstraction for
    the browser.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-pal-browser`：`aurelia-pal`抽象的浏览器实现。'
- en: '`aurelia-logging-console`: An implementation of the `aurelia-logging` abstraction
    for the browser console.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-logging-console`：`aurelia-logging`抽象的浏览器控制台实现。'
- en: Integration layers
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成层
- en: 'The following libraries'' purpose is to integrate some of the core libraries
    together. They provide interface implementations and adapters, along with default
    configuration or behaviors:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库的目的是将一些核心库集成在一起。它们提供接口实现和适配器，以及默认配置或行为：
- en: '`aurelia-templating-router`: An integration layer between the `aurelia-router`
    and the `aurelia-templating` libraries.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-templating-router`：`aurelia-router`和`aurelia-templating`库之间的集成层。'
- en: '`aurelia-templating-binding`: An integration layer between the `aurelia-templating`
    and the `aurelia-binding` libraries.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-templating-binding`：`aurelia-templating`和`aurelia-binding`库之间的集成层。'
- en: '`aurelia-framework`: An integration layer that brings together all of the core
    Aurelia libraries into a full-featured framework.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-framework`：一个将所有核心Aurelia库集成到一个功能齐全的框架的集成层。'
- en: '`aurelia-bootstrapper`: An integration layer that brings default configuration
    for `aurelia-framework` and handles application starting.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aurelia-bootstrapper`：一个将`aurelia-framework`的默认配置带入并处理应用程序启动的集成层。'
- en: Additional tools and plugins
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加工具和插件
- en: If you take a look at Aurelia's organization page on GitHub at [https://github.com/aurelia](https://github.com/aurelia),
    you will see many more repositories. The libraries listed in the previous sections
    are just the core of Aurelia - the tip of the iceberg, if I may. Many other libraries
    exposing additional features or integrating third-party libraries are available
    on GitHub, some of them developed and maintained by the Aurelia team, many others
    by the community. We'll cover some of those additional libraries in further chapters,
    but I strongly suggest that you explore the Aurelia ecosystem by yourself after
    reading this book, as it is rapidly growing, and the Aurelia community is doing
    some very exciting things.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Aurelia在GitHub上的组织页面[https://github.com/aurelia](https://github.com/aurelia)，你会看到更多仓库。前面部分列出的库只是Aurelia的核心——如果我可以这么说的话，这只是冰山一角。在GitHub上还有许多其他库，它们提供了额外的功能或集成了第三方库，其中一些是由Aurelia团队开发和维护的，许多其他是由社区开发的。我们将在后续章节中介绍一些这些额外的库，但我强烈建议你在阅读完这本书后自己探索Aurelia生态系统，因为它是快速发展的，Aurelia社区正在做一些非常令人兴奋的事情。
- en: Tooling
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: In the following section, we will go over the tools needed to develop our Aurelia
    application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将介绍开发Aurelia应用程序所需的工具。
- en: Node.js and NPM
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js和NPM
- en: Aurelia being a JavaScript framework, it just makes sense that its development
    tools are also in JavaScript. This means that the first thing you need to do when
    getting started with Aurelia is to install Node.js and NPM on your development
    environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Aurelia是一个JavaScript框架，因此其开发工具自然也是用JavaScript编写的。这意味着当你开始学习Aurelia时，你需要做的第一件事就是在你的开发环境中安装Node.js和NPM。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Node.js is a server-side runtime environment based on Google's V8 JavaScript
    engine. It can be used to build complete websites or web APIs, but it is also
    used by a lot of front-end projects for  development and to build tasks, such
    as transpiling, linting, and minimizing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是基于Google的V8 JavaScript引擎的服务器端运行环境。它可以用来构建完整的网站或网络API，但它也被许多前端项目用于开发和构建任务，如转换、校验和压缩。
- en: NPM is the de facto package manager for Node.js. It uses [http://www.npmjs.com](http://www.npmjs.com) 
    as its main repository, where all available packages are stored. It is bundled
    with Node.js, so if you install Node.js on your computer, NPM will also be installed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: NPM是Node.js的默认包管理器。它使用[http://www.npmjs.com](http://www.npmjs.com)作为其主要仓库，所有可用的包都存储在这里。它与Node.js捆绑在一起，因此如果你在电脑上安装了Node.js，NPM也会被安装。
- en: To install Node.js and NPM on your development environment, you simply need
    to go to  [https://nodejs.org/](https://nodejs.org/) and download the proper installer
    for your environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的开发环境中安装Node.js和NPM，你只需要访问[https://nodejs.org/](https://nodejs.org/)并下载适合你环境的正确安装程序。
- en: 'If Node.js and NPM are already installed, I strongly recommend that you make
    sure to use at least version 3 of NPM, as older versions may have issues collaborating
    with some of the other tools we''ll use. If you are not sure which version you
    have, you can check it by running the following command in a console:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Node.js和NPM已经安装，我强烈建议你确保使用至少版本3的NPM，因为旧版本可能与我们将要使用的其他一些工具存在兼容性问题。如果你不确定你有哪些版本，你可以在控制台中运行以下命令来检查：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If Node.js and NPM are already installed but you need to upgrade NPM, you can
    do so by running the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Node.js和NPM已经安装但你需要升级NPM，你可以通过运行以下命令来实现：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Aurelia CLI
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aurelia命令行界面（CLI）
- en: Even though an Aurelia application can be built using any package manager, build
    system, or bundler you want, the preferred tool to manage an Aurelia project is
    the command line interface, a.k.a. the CLI.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用任何包管理器、构建系统或打包器来构建Aurelia应用程序，但管理Aurelia项目的最佳工具是命令行界面，也称为CLI。
- en: At the time of writing, the CLI only supports NPM as its package manager and
    `requirejs` as its module loader and bundler, probably because they are both the
    most mature and stable. It also uses Gulp 4 behind the scenes as its build system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本文时，CLI只支持NPM作为其包管理器以及`requirejs`作为其模块加载器和打包器，这可能是因为它们都是最成熟和最稳定的。它还在幕后使用Gulp
    4作为其构建系统。
- en: CLI-based applications are always bundled when running, even in development
    environments. This means that the performance of an application during development
    will be very close to what it should be like in production. This also means that
    bundling is a recurring concern, as new external libraries must be added to some
    bundles in order to be available at runtime. We'll see this in detail in [Chapter
    10](ch10.html "Chapter 10. Bundling for Production"), *Bundling for Production*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 CLI 的应用在运行时总是会被打包，即使在开发环境中也是这样。这意味着在开发过程中应用的性能将与生产环境中的性能非常接近。这也意味着打包是一个持续关注的问题，因为新的外部库必须添加到某些打包中，以便在运行时可以使用。我们将在第
    10 章详细看到这一点，*生产环境下的打包*。
- en: In this book, we'll stick with the preferred solution and use the CLI. There
    are, however, two appendices at the end of the book covering alternatives, a first
    for Webpack, and a second for SystemJS with JSPM.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将坚持使用首选方案并使用 CLI。然而，书末有两个附录介绍了替代方案，第一个是针对 Webpack 的，第二个是针对 SystemJS 和
    JSPM 的。
- en: Installing the CLI
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 CLI
- en: 'The CLI being a command line tool, it should be installed globally, by opening
    a console and executing the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 是一个命令行工具，应该通过打开控制台并执行以下命令来全局安装：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may have to run this command with administrator privileges, depending on
    your environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的环境，你可能需要以管理员权限运行这个命令。
- en: 'If you already have it installed, make sure you have the latest version, by
    running the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了它，请确保你有最新版本，通过运行以下命令：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can then compare the version this command outputs with the latest version
    number tagged on GitHub, at [https://github.com/aurelia/cli/releases/latest](https://github.com/aurelia/cli/releases/latest).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以将这个命令输出的版本与 GitHub 上标记的最新版本号进行比较，地址是：[https://github.com/aurelia/cli/releases/latest](https://github.com/aurelia/cli/releases/latest)。
- en: 'If you don''t have the latest version, you can simply update it by running
    the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有最新版本，你可以通过运行以下命令简单地更新它：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If for some reason the command to update the CLI fails, simply uninstall then
    reinstall it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因更新 CLI 的命令失败了，只需卸载然后重新安装即可：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This should reinstall the latest version.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会重新安装最新版本。
- en: The project skeletons
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目骨架
- en: As an alternative to the CLI, project skeletons are available at [https://github.com/aurelia/skeleton-navigation](https://github.com/aurelia/skeleton-navigation).
    This repository contains multiple sample projects, sitting on different technologies
    such as SystemJS with JSPM, Webpack, ASP .Net Core, or TypeScript.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 CLI 的替代方案，项目骨架可在 [https://github.com/aurelia/skeleton-navigation](https://github.com/aurelia/skeleton-navigation)
    找到。这个仓库包含多个样本项目，基于不同的技术，如 SystemJS 和 JSPM、Webpack、ASP .Net Core 或 TypeScript。
- en: Prepping up a skeleton is easy. You simply need to download and unzip the archive
    from GitHub or clone the repository locally. Each directory contains a distinct
    skeleton. Depending on which one you chose, you'll need to install different tools
    and run setup commands. Generally, the instructions in the skeleton's `README.md`
    file are pretty clear.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 准备骨架非常简单。你只需要从 GitHub 下载并解压存档，或者在本地克隆仓库。每个目录都包含一个不同的骨架。根据你的选择，你可能需要安装不同的工具并运行设置命令。通常，骨架中的
    `README.md` 文件中的说明是非常清晰的。
- en: Those skeletons are other good starting points to begin a new application using
    different technologies. The two appendices at the end of this book show how to
    use some of them to build an application using either SystemJS with JSPM or Webpack.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些骨架是使用不同技术开始新应用的其他良好起点。本书的最后两章附录展示了如何使用其中一些骨架，使用 SystemJS 和 JSPM 或 Webpack
    构建应用程序。
- en: Apart from those appendices, the rest of the book will keep using the CLI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了附录，本书其余部分将继续使用 CLI。
- en: Our application
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的应用
- en: 'Creating an Aurelia application using the CLI is extremely simple. You just
    need to open a console in the directory where you want to create your project
    and run the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CLI 创建 Aurelia 应用非常简单。你只需要在你想创建项目的目录中打开一个控制台，并运行以下命令：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The CLI''s project creation process will start, and you should see something
    like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 的项目创建过程将开始，你应该看到类似这样的内容：
- en: '![Our application](img/image_01_001.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用](img/image_01_001.jpg)'
- en: 'The first thing the CLI will ask for is the name you want to give to your project.
    This name will be used both to create the directory in which the project will
    live and to set some values, such as the `name` property in the `package.json`
    file it will create. Let''s name our application `learning-aurelia`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）首先会询问您想要为您项目命名什么。这个名称将用于创建项目所在的目录以及设置一些值，例如它将创建的`package.json`文件中的`name`属性。让我们给我们的应用命名为`learning-aurelia`：
- en: '![Our application](img/image_01_002.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用](img/image_01_002.jpg)'
- en: Next, the CLI asks what technologies we want to use to develop our application.
    Here, you can select a custom transpiler such as TypeScript and a CSS preprocessor
    such as LESS or SASS.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，CLI会询问我们想要使用哪些技术来开发应用。在这里，您可以选择一个自定义转换器，如TypeScript，以及一个CSS预处理器，如LESS或SASS。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The transpiler, little cousin of the compiler, translates one programming language
    into another. In our case, it will be used to transform ESNext code, which may
    not be supported by all browsers, into ES5, which is understood by all modern
    browsers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器，编译器的小表亲，将一种编程语言翻译成另一种。在我们的案例中，它将用于将ESNext代码转换为ES5，后者被所有现代浏览器理解。
- en: 'The default choice is to use ESNext and plain CSS, and this is what we will
    choose:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认选择是使用ESNext和普通CSS，这是我们将会选择的：
- en: '![Our application](img/image_01_003.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用](img/image_01_003.jpg)'
- en: 'The following steps simply recap the choices we made and ask for confirmation
    to create the project, then ask if we want to install our project''s dependencies
    which it does by default. At this point, the CLI will create the project and run
    an `npm install` behind the scene. Once it completes, our application is ready
    to roll:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤简单回顾了我们所做的选择，并请求确认创建项目，然后询问我们是否想要安装项目的依赖，默认情况下它会这样做。在此阶段，命令行界面将创建项目并在幕后运行`npm
    install`。一旦完成，我们的应用就准备好了：
- en: '![Our application](img/image_01_004.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用](img/image_01_004.jpg)'
- en: At this point, the directory you ran `au new` in will contain a new directory
    named `learning-aurelia`. This sub-directory will contain the Aurelia project.
    We'll explore it a bit in the following section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，您运行`au new`的目录将包含一个名为`learning-aurelia`的新目录。这个子目录将包含Aurelia项目。我们将在下一节中稍作探讨。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The CLI is likely to change and offer more options in the future, as there are
    plans to support additional tools and technologies. Don't be surprised if you
    see different or new options when you run it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）可能会发生变化，在将来提供更多选项，因为计划支持更多工具和技术。如果您运行它，不要惊讶看到不同或新的选项。
- en: 'The path we followed to create our project uses Visual Studio Code as the default
    code editor. If you want to use another editor such as **Atom**, **Sublime**,
    or **WebStorm**, which are the other supported options at the time of writing,
    you simply need to select option #3 custom transpilers, CSS pre-processors and
    more at the beginning of the creation process, then select the default answer
    for each question until asked to select your default code editor. The rest of
    the creation process should stay pretty much the same. Note that if you select
    a different code editor, your own experience may differ from the examples and
    screenshots you''ll find in this book, as Visual Studio Code is the editor that
    was used during writing.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建项目的路径使用了Visual Studio Code作为默认代码编辑器。如果你想使用其他编辑器，比如**Atom**、**Sublime**或**WebStorm**，这些是在撰写本文时支持的其他选项，你只需要在创建过程开始时选择选项#3自定义转换器、CSS预处理器等，然后为每个问题选择默认答案，直到被要求选择您的默认代码编辑器。创建过程的其余部分应该基本保持不变。请注意，如果您选择不同的代码编辑器，您的体验可能与本书中找到的示例和屏幕截图不同，因为撰写本书时使用的是Visual
    Studio Code。
- en: If you are a TypeScript developer, you may want to create a TypeScript project.
    I however recommend that you stick with plain ESNext, as every example and code
    sample in this book has been written in JS. Trying to follow with TypeScript may
    prove cumbersome, although you can try if you like the challenge.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是TypeScript开发者，您可能想创建一个TypeScript项目。然而，我建议您坚持使用简单的ESNext，因为本书中的每个示例和代码示例都是用JS编写的。尝试跟随TypeScript可能会证明很繁琐，尽管如果您喜欢挑战，可以尝试。
- en: The structure of a CLI-based project
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于CLI的项目的结构
- en: 'If you open the newly created project in a code editor, you should see the
    following file structure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在代码编辑器中打开新创建的项目，您应该看到以下文件结构：
- en: '`node_modules`: The standard NPM directory containing the project''s dependencies'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules`：包含项目依赖的标准NPM目录'
- en: '`src`: The directory containing the application''s source code'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：包含应用源代码的目录'
- en: '`test`: The directory containing the application''s automated test suites,
    which we will explore in [Chapter 7](ch07.html "Chapter 7. Test All the Things"),
    *Test all the Things*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：包含应用自动化测试套件的目录，我们将在[第7章](ch07.html "Chapter 7. Test All the Things"
    "测试所有事物")中探索，*测试所有事物*'
- en: '`.babelrc`: The configuration file for Babel, which is used by the CLI to transpile
    our application''s ESNext code into ES5 so most browsers can run it'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.babelrc`：Babel的配置文件，CLI使用它将我们的应用的ESNext代码转换成ES5，这样大多数浏览器都可以运行它。'
- en: '`index.html`: The HTML page that loads and launches the application'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`：加载并启动应用的HTML页面'
- en: '`karma.conf.js`: The configuration file for **Karma**, which is used by the
    CLI to run unit tests;'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`karma.conf.js`：**Karma**的配置文件，CLI使用它来运行单元测试；'
- en: '`package.json`: The standard Node.js project file'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`：标准的Node.js项目文件'
- en: The directory contains other files such as `.editorconfig`, `.eslintrc.json`,
    and `.gitignore` that are of little interest for learning Aurelia, so we won't
    cover them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录还包括其他文件，如`.editorconfig`、`.eslintrc.json`和`.gitignore`，它们对学习Aurelia来说兴趣不大，所以我们不覆盖它们。
- en: In addition to all of this, you should see a directory named `aurelia_project`.
    This directory contains things related to the building and bundling of the application
    using the CLI. Let's see what it's made of.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些，你应该看到一个名为`aurelia_project`的目录。这个目录包含与使用CLI构建和打包应用相关的事物。让我们看看它由什么组成。
- en: The aurelia.json file
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`aurelia.json`文件'
- en: The first thing of importance in this directory is a file named `aurelia.json`.
    This file contains the configuration used by the CLI to test, build, and bundle
    the application. This file can change drastically depending on the choices you
    make during the project creation process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录中最重要的文件是一个名为`aurelia.json`的文件。这个文件包含了CLI用于测试、构建和打包应用的配置。这个文件根据你在项目创建过程中的选择可能会有很大的变化。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are very few scenarios where this file needs to be modified by hand. Adding
    an external library to the application is such a scenario, which we will face
    multiple times in next chapters. Apart from this, this file should mostly never
    be updated manually.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况非常少见，需要手动修改这个文件。向应用中添加一个外部库就是这种情况，我们在接下来的章节中会面临多次。除了这种情况，这个文件基本上不应该手动更新。
- en: 'The first interesting section in this file is the `platform`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中第一个有趣的部分是`platform`：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This section tells the CLI that the output directory where the bundles are written
    is named `scripts`. It also tells that the HTML index page, which will load and
    launch the application, is the `index.html` file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分告诉CLI，输出目录的名称是`scripts`，它还告诉CLI，将加载并启动应用的HTML主页是`index.html`文件。
- en: 'The next interesting part is the `transpiler` section:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有趣的部分是`transpiler`部分：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This section tells the CLI to transpile the application's source code using
    Babel. It also defines additional plugins as some are already configured in `.babelrc`
    to be used when transpiling the source code. In this case, it adds a plugin that
    will output transpiled files as AMD-compliant modules, for `requirejs` compatibility.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分告诉CLI使用Babel转换应用的源代码。它还定义了额外的插件，因为有些插件已经在`.babelrc`中配置好，在转换源代码时使用。在这种情况下，它添加了一个插件，将以AMD兼容模块的形式输出转换后的文件，以兼容`requirejs`。
- en: There are many other sections in this file, some of which we will cover in further
    chapters, some others I've left for you to explore on your own.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中有许多其他部分，其中一些我们将在后续章节中覆盖，还有一些我留给你们自己探索。
- en: Tasks
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务
- en: The `aurelia_project` directory contains a subdirectory named `tasks`. This
    subdirectory contains various Gulp tasks to build, run, and test the application.
    These tasks can be executed using the CLI.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project`目录包含一个名为`tasks`的子目录。这个子目录包含各种Gulp任务，用于构建、运行和测试应用。这些任务可以使用CLI执行。'
- en: 'The first thing you can try is to run `au` without any argument:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以首先尝试不带任何参数运行`au`：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will list all available commands, along with their available arguments.
    This list includes built-in commands such as `new`, which we've used already,
    or `generate`, which we'll see in the next section along with the Gulp tasks declared
    in the `tasks` directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有可用的命令以及它们的可用参数。这个列表包括内置命令，比如我们已经在用的`new`，或者在下一节中会看到的`generate`，还有在`tasks`目录中声明的Gulp任务。
- en: 'To run one of those tasks, simply execute `au` with the name of the task as
    its first argument:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些任务中的一个，只需执行`au`，后面跟上任务的名称作为它的第一个参数：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command will run the `build` task which is defined in `aurelia_project/tasks/build.js`.
    This task transpiles the application code using Babel, executes the CSS and markup
    preprocessors if any, and bundles the code in the `scripts` directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将运行定义在`aurelia_project/tasks/build.js`中的`build`任务。这个任务使用Babel转换应用程序代码，如果有的话，执行CSS和标记预处理器，并在`scripts`目录中打包代码。
- en: 'After running it, you should see two new files in `scripts`: `app-bundle.js`
    and `vendor-bundle.js`. Those are the actual files that will be loaded by `index.html`
    when the application is launched. The former contains all application code, and 
    both JS files and templates, while the later contains all external libraries used
    by the application including Aurelia libraries. We''ll learn how to customize
    bundling in [Chapter 10](ch10.html "Chapter 10. Bundling for Production"), *Bundling
    for Production*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，你应在`scripts`目录下看到两个新文件：`app-bundle.js`和`vendor-bundle.js`。这两个文件是在应用程序启动时由`index.html`加载的实际文件。前者包含所有应用程序代码，包括JS文件和模板，而后者包含应用程序使用的所有外部库，包括Aurelia库。我们将在[第10章](ch10.html
    "第10章：生产环境下的打包")中学习如何自定义打包——*生产环境下的打包*。
- en: 'You may have noticed a command named `run` in the list of available commands.
    This task is defined in `aurelia_project/tasks/run.js`, and executes the `build`
    task internally before spawning a local HTTP server to serve the application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到列表中有一个名为`run`的命令。这个任务定义在`aurelia_project/tasks/run.js`中，在启动本地HTTP服务器以提供应用程序之前内部执行`build`任务：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By default, the HTTP server will listen for requests on port 9000, so you can
    open your favorite browser and go to http://localhost:9000/ to see the default
    demo application in action.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HTTP服务器将在端口9000上监听请求，因此你可以打开你喜欢的浏览器，访问http://localhost:9000/ 来查看默认的演示应用程序。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you ever need to change the port number on which the development HTTP server
    runs, you just need to open `aurelia_project/tasks/run.js`, and locate the call
    to the `browserSync` function. The object passed to this function contains a property
    named `port`. You can change its value accordingly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更改开发HTTP服务器运行的端口号，你只需要打开`aurelia_project/tasks/run.js`，找到对`browserSync`函数的调用。传递给这个函数的对象包含一个名为`port`的属性。你可以相应地更改它的值。
- en: 'The `run` task can accept a `--watch` switch:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`任务可以接受一个`--watch`开关：'
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If this switch is present, the task will keep monitoring the source code and,
    when any code file changes, will rebuild the application and automatically refresh
    the browser. This can be pretty useful during development.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在此开关，任务将继续监控源代码，并在任何代码文件更改时重新构建应用程序并自动刷新浏览器。这在开发过程中非常有用。
- en: Generators
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器
- en: The CLI also offers a way to generate code, using classes defined in the `aurelia_project/generators`
    directory. At the of writing, there are generators to create custom attributes,
    custom elements, binding behaviors, value converters, and even tasks and generators,
    yes, there is a generator to generate generators.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）还提供了一种生成代码的方法，使用位于`aurelia_project/generators`目录中的类。在撰写本文时，有创建自定义属性、自定义元素、绑定行为、值转换器和甚至任务和生成器的生成器。是的，有一个生成器用于生成生成器。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not familiar with Aurelia at all, most of those concepts, value converters,
    binding behaviors, and custom attributes and elements probably mean nothing to
    you. Don't worry, we will cover these topics in the next chapters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Aurelia一无所知，那些概念（值转换器、绑定行为以及自定义属性和元素）可能对你来说毫无意义。不用担心，我们将在接下来的章节中介绍这些主题。
- en: 'A generator can be executed using the built-in `generate` command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用内置的`generate`命令执行生成器：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command will run the custom attribute generator. It will ask for the name
    of the attribute to generate then create it in the `src/resources/attributes`
    directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将运行自定义属性生成器。它会询问要生成的属性的名称，然后在其`src/resources/attributes`目录中创建它。
- en: If you take a look at this generator which is found in `aurelia_project/generators/attribute.js`,
    you'll see that the file exports a single class named `AttributeGenerator`. This
    class uses the `@inject` decorator (which we'll see in more detail in [Chapter
    2](ch02.html "Chapter 2. Layout, Menu, and Getting Familiar"), *Layout, Menu,
    and Getting Familiar)* to declare various classes from the `aurelia-cli` library
    as dependencies and have instances of them injected in its constructor. It also
    defines an `execute` method, which is called by the CLI when running the generator.
    This method leverages the services provided by `aurelia-cli` to interact with
    the user and generate code files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下这个生成器，它可以在`aurelia_project/generators/attribute.js`中找到，你会发现文件导出一个名为`AttributeGenerator`的单一类。这个类使用`@inject`装饰器（我们将在[第2章](ch02.html
    "Chapter 2. Layout, Menu, and Getting Familiar")中更详细地看到，*布局、菜单和熟悉*)来声明`aurelia-cli`库中的各种类作为依赖项，并在其构造函数中注入它们的实例。它还定义了一个`execute`方法，当生成器运行时由CLI调用。这个方法利用`aurelia-cli`提供的服务与用户交互并生成代码文件。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The exact generator names available by default are `attribute`, `element`, `binding-behavior`,
    `value-converter`, `task`, and `generator`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认可用的生成器名称有`attribute`、`element`、`binding-behavior`、`value-converter`、`task`和`generator`。
- en: Environments
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境
- en: CLI-based applications support environment-specific configuration values. By
    default, the CLI supports three environments-development, staging, and production.
    The configuration object for each of these environments can be found in the different
    files `dev.js`, `stage.js`, and `prod.js` located in the `aurelia_project/environments`
    directory.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 基于CLI的应用程序支持环境特定的配置值。默认情况下，CLI支持三个环境-开发、暂存和生产。这些环境的每个配置对象都可以在`aurelia_project/environments`目录中的不同文件`dev.js`、`stage.js`和`prod.js`中找到。
- en: 'A typical environment file looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的环境文件看起来像这样：
- en: '`aurelia_project/environments/dev.js`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/environments/dev.js`'
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By default, the environment files are used to enable debugging logging and test-only
    templating features in the Aurelia framework depending on the environment. We'll
    see this in a next section. The environment objects can, however, be enhanced
    with whatever properties you may need. Typically, it could be used to configure
    different URLs for a backend, depending on the environment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，环境文件用于根据环境启用Aurelia框架的调试日志和仅限测试的模板功能。我们将在下一节看到这一点。然而，环境对象可以增强任何所需的属性。通常，它可用于根据环境配置后端的不同URL。
- en: Adding a new environment is simply a matter of adding a file for it in the `aurelia_project/environments`
    directory. For example, you can add a `local` environment by creating a `local.js`
    file in the directory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新环境仅仅是 在`aurelia_project/environments`目录中为其添加一个文件的问题。例如，您可以通过在目录中创建一个`local.js`文件来添加一个`local`环境。
- en: 'Many tasks, basically `build` and all other tasks using it, such as `run` and
    `test` expect an environment to be specified using the `env` argument:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 许多任务，基本上是`build`和所有使用它的任务，如`run`和`test`，都期望使用`env`参数指定环境：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the application will be built using the `prod.js` environment file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应用程序将使用`prod.js`环境文件进行构建。
- en: If no `env` argument is provided, `dev` will be used by default.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`env`参数，默认使用`dev`。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When executed, the `build` task just copies the proper environment file to `src/environment.js`
    before running the transpiler and bundling the output. This means that `src/environment.js`
    should never be modified by hand, as it will be automatically overwritten by the
    `build` task.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`build`任务时，它只是在运行转译器和打包输出之前将适当的环境文件复制到`src/environment.js`。这意味着`src/environment.js`绝不应该手动修改，因为它将被`build`任务自动覆盖。
- en: The structure of an Aurelia application
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aurelia应用程序的结构
- en: The previous section described the files and folders that are specific to a
    CLI-based project. However, some parts of the project are pretty much the same
    whatever the build system and package manager are. These are the more global topics
    we will see in this section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节描述了特定于基于CLI的项目的一些文件和文件夹。然而，项目中的某些部分无论构建系统和包管理器如何都是相同的。这些是在本节中将要看到的更全局的主题。
- en: The hosting page
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 托管页面
- en: The first entry point of an Aurelia application is the HTML page-loading and
    hosting it. By default, this page is named `index.html` and is located at the
    root of the project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia应用程序的第一个入口点是HTML页面的加载和托管。默认情况下，这个页面名为`index.html`，位于项目的根目录中。
- en: 'The default hosting page looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的托管页面看起来像这样：
- en: '`index.html`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When this page loads, the `script` element inside the `body` element loads the
    `scripts/vendor-bundle.js` file, which contains `requirejs` itself along with
    definitions for all external libraries and references to `app-bundle.js`. When
    loading, `requirejs` checks the `data-main` attribute and uses its value as the
    entry point module. Here, `aurelia-bootstrapper` kicks in.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，`body`元素内的`script`元素加载了`scripts/vendor-bundle.js`文件，该文件包含了`requirejs`本身以及所有外部库的定义和对`app-bundle.js`的引用。加载时，`requirejs`检查`data-main`属性并将其值作为入口点模块使用。在这里，`aurelia-bootstrapper`开始工作。
- en: The bootstrapper first looks in the DOM for elements with the `aurelia-app`
    attribute. We can find such an attribute on the `body` element in the default
    `index.html` file. This attribute identifies elements acting as application viewports.
    The bootstrapper uses the attribute's value as the name of the application's main
    module and locates the module, loads it, and renders the resulting DOM inside
    the element, overwriting any previous content. The application is now running.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 启动器首先在DOM中查找具有`aurelia-app`属性的元素。我们可以在默认的`index.html`文件中的`body`元素中找到这样的属性。这个属性识别作为应用程序视图口的元素。启动器使用属性的值作为应用程序的主模块名称，定位模块，加载它，并在元素内渲染结果DOM，覆盖任何先前的内容。应用程序现在正在运行。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though the default application doesn't illustrate this scenario, it is
    possible for an HTML file to host multiple Aurelia applications. It just needs
    to contain multiple elements with an `aurelia-app` attribute, each element referring
    to its own main module.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认的应用程序没有说明这种情况，但一个HTML文件托管多个Aurelia应用程序是可能的。它只需要包含多个带有`aurelia-app`属性的元素，每个元素都引用自己的主模块。
- en: The main module
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主模块
- en: By convention, the main module referred to by the `aurelia-app` attribute is
    named `main`, and as such is located under `src/main.js`. This file is expected
    to export a `configure` function, which will be called by the Aurelia bootstrapping
    process and will be passed a configuration object used to configure and boot the
    framework.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，由`aurelia-app`属性引用的主模块命名为`main`，因此位于`src/main.js`中。此文件预计将导出一个`configure`函数，该函数将由Aurelia启动过程调用，并将传递一个用于配置和启动框架的配置对象。
- en: 'By default, the main `configure` function looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，主要的`configure`函数看起来像这样：
- en: '`src/main.js`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`'
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `configure` function starts by telling Aurelia to use its defaults configuration,
    and to load the `resources` feature, we'll see how features work in [Chapter 2](ch02.html
    "Chapter 2. Layout, Menu, and Getting Familiar"), *Layout, Menu, and Getting Familiar*. It
    also conditionally loads the development logging plugin based on the environment's
    `debug` property, and the testing plugin based on the environment's `testing`
    property. This means that, by default, both plugins will be loaded in development,
    while none will be loaded in production.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`函数首先告诉Aurelia使用其默认配置，并加载`resources`特性，我们将在[第2章](ch02.html "第2章：布局、菜单和熟悉")，*布局、菜单和熟悉*中看到特性是如何工作的。它还根据环境的`debug`属性有条件地加载开发日志插件，并根据环境的`testing`属性有条件地加载测试插件。这意味着，默认情况下，两个插件将在开发中加载，而在生产中不会加载任何一个。'
- en: Lastly, the function starts the framework then attaches the root component to
    the DOM.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该函数启动了框架，然后将根组件附加到DOM。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `start` method returns a `Promise`, whose resolution triggers the call to
    `setRoot`. If you are not familiar with `Promise`s in JavaScript, I strongly suggest
    that you look it up before going any further, as they are a core concept in Aurelia.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`方法返回一个`Promise`，其解析触发了对`setRoot`的调用。如果你不熟悉JavaScript中的`Promise`，我强烈建议你在继续之前查阅相关资料，因为它们是Aurelia中的核心概念。'
- en: The root component
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根组件
- en: At the root of any Aurelia application is a single component, which contains
    everything within the application. By convention, this root component is named
    `app`. It is composed of two files `app.html`, which contains the template to
    render the component, and `app.js`, which contains its view-model class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Aurelia应用程序的根部都有一个单一的组件，包含应用程序内的所有内容。按惯例，这个根组件名为`app`。它由两个文件组成：`app.html`，其中包含渲染组件的模板，以及`app.js`，其中包含其视图模型类。
- en: 'In the default application, the template is extremely simple:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的应用程序中，模板非常简单：
- en: '`src/app.html`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.html`'
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This template is made of a single `h1` element, which will contain the value
    of the view-model's `message` property as text, thanks to string interpolation
    which we will explore more in details in [Chapter 3](ch03.html "Chapter 3. Displaying
    Data"), *Displaying Data*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板由一个单一的 `h1` 元素组成，它将包含视图模型的 `message` 属性的值作为文本，感谢字符串插值，我们将在 [第 3 章](ch03.html
    "第 3 章：显示数据")，*显示数据* 中更详细地探讨。
- en: 'The `app` view-model looks like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`app` 视图模型看起来像这样：'
- en: '`src/app.js`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This file simply exports a class having a `message` property containing the
    string `Hello World!`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件简单地导出一个类，该类有一个 `message` 属性，包含字符串 `Hello World!`。
- en: This component will be rendered when the application starts. If you run the
    application and navigate to the application in your favorite browser, you'll see
    a `h1` element containing `Hello World!`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动时，此组件将被渲染。如果你运行应用程序并使用你最喜欢的浏览器导航到应用程序，你会看到一个包含 `Hello World!` 的 `h1` 元素。
- en: You may notice that there is no reference to Aurelia in this component's code.
    In fact, the view-model is just plain ESNext and it can be used by Aurelia as
    is. Of course, we're going to leverage many Aurelia features in many of our view-models
    later on, so most of our view-models will in fact have dependencies on Aurelia
    libraries, but the key point here is that you don't have to use any Aurelia library
    in your view-models if you don't want to, because Aurelia is designed to be as
    unobtrusive as possible.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，这个组件的代码中没有提到 Aurelia。实际上，视图模型只是普通的 ESNext，Aurelia 可以原样使用它。当然，我们稍后会在很多视图模型中利用许多
    Aurelia 特性，所以大多数视图模型实际上将依赖于 Aurelia 库，但这里的重点是，如果你不想在视图模型中使用任何 Aurelia 库，你就不必使用，因为
    Aurelia 设计得尽可能不具侵入性。
- en: Conventional bootstrapping
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统引导方式
- en: 'It is possible to leave the `aurelia-app` attribute empty in the hosting page:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在宿主页面中将 `aurelia-app` 属性留空：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In such a case, the bootstrapping process is much simpler. Instead of loading
    a main module containing a `configure` function, the bootstrapper will simply
    use the framework's default configuration and load the `app` component as the
    application root.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，引导过程要简单得多。而不是加载一个包含 `configure` 函数的主模块，引导器将简单地使用框架的默认配置并作为应用程序根加载 `app`
    组件。
- en: This can be a simpler way to get started for a very simple application; as it
    negates the need for the `src/main.js` file you can simply delete it. However,
    it means that you are stuck with the default framework configuration. You cannot
    load features or plugins. For most real-life applications, you'll need to keep
    the main module, which means specifying it as the `aurelia-app` attribute's value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个非常简单的应用程序来说，这可能是一个更简单的开始方式；因为它消除了 `src/main.js` 文件的必要性，你可以直接删除它。然而，这意味着你被默认框架配置所束缚。你不能加载功能或插件。对于大多数实际应用，你需要保留主模块，这意味着指定为
    `aurelia-app` 属性值的 `aurelia-app`。
- en: Customizing Aurelia configuration
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 Aurelia 配置
- en: 'The `configure` function of the main module receives a configuration object,
    which is used to configure the framework:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 主模块的 `configure` 函数接收一个配置对象，用于配置框架：
- en: '`src/main.js`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`'
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the `standardConfiguration()` method is a simple helper that encapsulates
    the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`standardConfiguration()` 方法是一个简单的助手，它封装了以下内容：
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the default Aurelia configuration. It loads the default binding language,
    the default templating resources, the browser history plugin, the router plugin,
    and the event aggregator. This is the default set of features that a typical Aurelia
    application uses. All those plugins will be covered at one point or another throughout
    this book. All those plugins are optional except the binding language, which is
    needed by the templating engine. If you don't need one, just don't load it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Aurelia 的默认配置。它加载了默认的绑定语言、默认的模板资源、浏览器历史插件、路由插件和事件聚合器。这是典型 Aurelia 应用程序使用的默认一组功能。本书的各个章节都会涉及到这些插件。除了绑定语言之外的所有这些插件都是可选的，绑定语言是模板引擎所必需的。如果你不需要其中一个，那就不要加载它。
- en: In addition to the standard configuration, some plugins are loaded depending
    on the environment's settings. When the environment's `debug` property is `true`,
    Aurelia's console logger is loaded using the `developmentLogging()` method, so
    traces and errors can be seen in the browser console. When the environment's `testing`
    property is `true`, the `aurelia-testing` plugin is loaded using the `plugin`
    method. This plugin registers some resources that are useful when debugging components.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准配置之外，根据环境设置还会加载一些插件。当环境的`debug`属性为`true`时，会使用`developmentLogging()`方法加载Aurelia的控制台日志记录器，因此可以在浏览器控制台中看到跟踪和错误信息。当环境的`testing`属性为`true`时，会使用`plugin`方法加载`aurelia-testing`插件。这个插件注册了一些在调试组件时非常有用的资源。
- en: 'The last line in the `configure` function starts the application and displays
    its root component, which is named `app` by convention. You may, however, bypass
    the convention and pass the name of your root component as the first argument
    to `setRoot`, if you named it otherwise:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`函数中的最后一行启动了应用程序并显示其根组件，根据约定，这个组件的名称是`app`。然而，如果你违反了约定并为根组件指定了其他名称，你可以通过将根组件的名称作为`setRoot`函数的第一个参数来绕过这个约定：'
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the root component is expected to sit in the `src/root.html` and `src/root.js`
    files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，预期根组件位于`src/root.html`和`src/root.js`文件中。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Getting started with Aurelia is very easy, thanks to the CLI. Installing the
    tooling and creating an empty project is simply a matter of running a couple of
    commands, and it takes typically more time waiting for the initial NPM install
    to complete than doing the actual setup.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于Aurelia的命令行界面（CLI），入门非常简单。安装工具并创建一个空项目仅仅是运行几个命令的问题，通常等待初始NPM安装完成的时间比实际设置的时间还要长。
- en: In the next chapter, we'll go over dependency injection and logging, and we'll
    start building our application by adding components and configuring routes to
    navigate between them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍依赖注入和日志记录，并开始通过向应用程序中添加组件和配置路由来导航它们来构建我们的应用程序。
