["```js\nDeno.test(\"my first test\", () => {})\n```", "```js\nDeno.test({\n  name: \"my-second-test\",\n  fn: () => {},\n  only: false,\n  sanitizeOps: true,\n  sanitizeResources: true,\n});\n```", "```js\n    Deno.test(\"it lists all the museums\", async () => {});\n    ```", "```js\n    export * as t from\n      \"https://deno.land/std@0.83.0/testing/asserts.ts\";\n    ```", "```js\n    import { t } from \"../deps.ts\";\n    import { Controller } from \"./controller.ts\";\n    Deno.test(\"it lists all the museums\", async () => {\n      const controller = new Controller({\n    MuseumController and sending in a mocked version of museumRepository, which returns a static array. This is how we're sure we're testing only the logic inside MuseumController, and nothing more. Closer to the end of the snippet, we're making sure the getAll method's result is returning the museum being returned by the mocked repository. We are doing this by using the assertion methods we exported from the dependencies file.\n    ```", "```js\n    $ deno test --unstable --allow-plugin --allow-env --allow-read –-allow-write --allow-net src/museums\n    running 1 tests\n    test it lists all the museums ... ok (1ms)\n    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (1ms)\n    ```", "```js\n    Deno.test(\"it is able to get all the museums from\n      storage\", async () => {});\n    ```", "```js\n    import { t } from \"../deps.ts\";\n    import { Controller, Repository } from \"./index.ts\";\n    Deno.test(\"it is able to get all the museums from\n      storage\", async () => {\n      const repository = new Repository();\n      repository.storage.set(\"0\", {\n        description: \"museum with id 0\",\n        name: \"my-museum\",\n        id: \"0\",\n        location: { lat: \"123\", lng: \"321\" },\n      });\n      repository.storage.set(\"1\", {\n        description: \"museum with id 1\",\n        name: \"my-museum\",\n        id: \"1\",\n        location: { lat: \"123\", lng: \"321\" },\n      });\n    …\n    ```", "```js\n    const controller = new Controller({ museumRepository:\n      repository });\n    ```", "```js\n    const allMuseums = await controller.getAll();\n    t.assertEquals(allMuseums.length, 2);\n    t.assertEquals(allMuseums[0].name, \"my-museum\", \"has\n      name\");\n    t.assertEquals(\n      allMuseums[0].description,\n      \"museum with id 0\",\n      \"has description\",\n    );\n    t.assertEquals(allMuseums[0].id, \"0\", \"has id\");\n    t.assertEquals(allMuseums[0].location.lat, \"123\", \"has\n      latitude\");\n    t.assertEquals(allMuseums[0].location.lng, \"321\", assertEquals, allowing us to get a proper message when this assertion fails. This is something that all assertion methods support.\n    ```", "```js\n    $ deno test --unstable --allow-plugin --allow-env --allow-read –-allow-write --allow-net src/museums\n    running 2 tests\n    test it lists all the museums ... ok (1ms)\n    test it is able to get all the museums from storage ... ok (1ms)\n    test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (2ms)\n    ```", "```js\n    const app = new Application();\n    …\n    return { app };\n    ```", "```js\n    const app = new Application();\n    …\n    const controller = new AbortController();\n    const { signal } = controller;\n    …\n    return { app, controller };\n    ```", "```js\n    Deno.test(\"it responds to hello world\", async () => {})\n    ```", "```js\n    import { Controller as UserController } from\n      \"../users/index.ts\";\n    import { Controller as MuseumController } from\n      \"../museums/index.ts\";\n    import { createServer } from \"./index.ts\";\n    …\n    const server = await createServer({\n      configuration: {\n        allowedOrigins: [],\n        authorization: {\n          algorithm: \"HS256\",\n          key: \"abcd\",\n        },\n        certFile: \"\",\n        keyFile: \"\",\n        port: 9001,\n        secure: false,\n      },\n    9001 and with HTTPS disabled, along with some random algorithm and key.Note how we're using TypeScript's `as` keyword to pass mocked types into the `createServer` function without TypeScript warning us about the type.\n    ```", "```js\n    import { t } from \"../deps.ts\";\n    …\n    const response = await fetch(\n      \"http://localhost:9001/\",\n      {\n        method: \"GET\",\n      },\n    ).then((r) => r.text());\n    t.assertEquals(\n      response,\n      \"Hello World!\",\n      \"responds with hello world\",\n    );\n    ```", "```js\n      server.controller.abort();\n    ```", "```js\n    Deno.test(\"it returns user and token when user logs\n      in\", async () => {})\n    ```", "```js\n    import { CreateServerDependencies } from\n      \"./web/index.ts\";\n    …\n    function createTestServer(options?: CreateServerDependencies) {\n      const museumRepository = new MuseumRepository();\n      const museumController = new MuseumController({\n        museumRepository });\n      const authConfiguration = {\n        algorithm: \"HS256\" as Algorithm,\n        key: \"abcd\",\n        tokenExpirationInSeconds: 120,\n      };\n      const userRepository = new UserRepository();\n      const userController = new UserController(\n        {\n          userRepository,\n          authRepository: new AuthRepository({\n            configuration: authConfiguration,\n          }),\n        },\n      );\n      return createServer({\n        configuration: {\n          allowedOrigins: [],\n          authorization: {\n            algorithm: \"HS256\",\n            key: \"abcd\",\n          },\n          certFile: \"abcd\",\n          keyFile: \"abcd\",\n          port: 9001,\n          secure: false,\n        },\n        museum: museumController,\n        user: userController,\n        ...options,\n      });\n    }\n    ```", "```js\n    import {\n      Controller as MuseumController,\n      InMemoryRepository as MuseumRepository,\n    } from \"./museums/index.ts\";\n    import {\n      Controller as UserController,\n      InMemoryRepository as UserRepository,\n    } from \"./users/index.ts\";\n    ```", "```js\n    export { Repository } from \"./repository/mongoDb.ts\";\n    Repository but also exporting InMemoryRepository at the same time.Now that we have a way to create a test server instance, we can go back to writing our tests.\n    ```", "```js\n    Deno.test(\"it returns user and token when user logs\n      in\", async () => {\n      const jsonHeaders = new Headers();\n      jsonHeaders.set(\"content-type\", \"application/json\");\n      const server = await createTestServer();\n      // Registering a user\n      const { user: registeredUser } = await fetch(\n        \"http://localhost:9001/api/users/register\",\n        {\n          method: \"POST\",\n          headers: jsonHeaders,\n          body: JSON.stringify({\n            username: \"asantos00\",\n            password: \"abcd\",\n          }),\n        },\n      ).then((r) => r.json())\n    …\n    ```", "```js\n      // Login in with the createdUser\n      const response = await\n        fetch(\"http://localhost:9001/api/login\", {\n          method: \"POST\",\n          headers: jsonHeaders,\n          body: JSON.stringify({\n          username: registeredUser.username,\n          password: \"abcd\",\n        }),\n      }).then((r) => r.json())\n    ```", "```js\n      t.assertEquals(response.user.username, \"asantos00\",\n        \"returns username\");\n      t.assert(!!response.user.createdAt, \"has createdAt\n        date\");\n      t.assert(!!response.token, \"has token\");\n    ```", "```js\n    server.controller.abort();\n    ```", "```js\n    Deno.test(\"it should let users with a valid token\n      access the museums list\", async () => {})\n    ```", "```js\n    function register(username: string, password: string) {\n      const jsonHeaders = new Headers();\n      jsonHeaders.set(\"content-type\", \"application/json\");\n      return\n       fetch(\"http://localhost:9001/api/users/register\", {\n         method: \"POST\",\n         headers: jsonHeaders,\n         body: JSON.stringify({\n          username,\n          password,\n        }),\n      }).then((r) => r.json());\n    }\n    function login(username: string, password: string) {\n      const jsonHeaders = new Headers();\n      jsonHeaders.set(\"content-type\", \"application/json\");\n      return fetch(\"http://localhost:9001/api/login\", {\n        method: \"POST\",\n        headers: jsonHeaders,\n        body: JSON.stringify({\n          username,\n          password,\n        }),\n      }).then((r) => r.json());\n    }\n    ```", "```js\n    Deno.test(\"it returns user and token when user logs\n      in\", async () => {\n      const jsonHeaders = new Headers();\n      jsonHeaders.set(\"content-type\", \"application/json\");\n      const server = await createTestServer();\n      // Registering a user\n      await register(\"test-user\", \"test-password\");\n      const response = await login(\"test-user\", \"test-\n      password\");\n      // Login with the created user\n      t.assertEquals(response.user.username, \"test-user\",\n        \"returns username\");\n      t.assert(!!response.user.createdAt, \"has createdAt\n        date\");\n      t.assert(!!response.token, \"has token\");\n      server.controller.abort();\n    });\n    ```", "```js\n    Deno.test(\"it should let users with a valid token\n      access the museums list\", async () => {\n      const jsonHeaders = new Headers();\n      jsonHeaders.set(\"content-type\", \"application/json\");\n      const server = await createTestServer();\n      // Registering a user\n      await register(\"test-user\", \"test-password\");\n      const { token } = await login(\"test-user\", \"test-\n        password\");\n    ```", "```js\n      const authenticatedHeaders = new Headers();\n      authenticatedHeaders.set(\"content-type\",\n        \"application/json\");\n      login function and sending it with the Authorization header in the request to the museums route. Then, we're checking if the API responds correctly to the request with the 200 OK status code. In this case, since our application doesn't have any museums, it is returning an empty array, which we're also asserting.Since we're testing this authorization feature, we can also test that a user with no token or an invalid token can't access this same route. Let's do it.\n    ```", "```js\n    Deno.test(\"it should respond with a 401 to a user with\n      an invalid token\", async () => {\n      const server = await createTestServer();\n      const authenticatedHeaders = new Headers();\n      authenticatedHeaders.set(\"content-type\",\n        \"application/json\");\n    authenticatedHeaders.set(\"authorization\", \n       `Bearer invalid-token`);\n      const response = await\n        fetch(\"http://localhost:9001/api/museums\", {\n          headers: authenticatedHeaders,\n          body: JSON.stringify({\n          username: \"test-user\",\n          password: \"test-password\",\n        }),\n      });\n      t.assertEquals(response.status, 401);\n      t.assertEquals(await response.text(),\n       \"Authentication failed\");\n      server.controller.abort();\n    });\n    ```", "```js\n    $ deno test --unstable --allow-plugin --allow-env --allow-read –-allow-write --allow-net src/index.test.ts      \n    running 3 tests\n    test it returns user and token when user logs in ... Application running at http://localhost:9001\n    POST http://localhost:9001/api/users/register - 3ms\n    POST http://localhost:9001/api/login - 3ms\n    ok (24ms)\n    test it should let users with a valid token access the museums list ... Application running at http://localhost:9001\n    POST http://localhost:9001/api/users/register - 0ms\n    POST http://localhost:9001/api/login - 1ms\n    GET http://localhost:9001/api/museums - 8ms\n    ok (15ms)\n    test it should respond with a 400 to a user with an invalid token ... Application running at http://localhost:9001\n    An error occurred Authentication failed\n    ok (5ms)\n    test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (45ms)\n    ```", "```js\n    Deno.test(\"it returns user and token when user logs in\n      with the client\", async () => {})\n    ```", "```js\n    import { getClient } from \"./client/index.ts\"\n    ```", "```js\n    Deno.test(\"it returns user and token when user logs in\n      with the client\", async () => {\n      const server = await createTestServer();\n      const client = getClient({\n    createTestServer function and this test, but for simplicity, we won't do this here.\n    ```", "```js\n    Deno.test(\"it returns user and token when user logs in\n      with the client\", async () => {\n    …\n      // Register a user\n      await client.register(\n        { username: \"test-user\", password: \"test-password\"\n           },\n      );\n      // Login with the createdUser\n      const response = await client.login({\n        username: \"test-user\",\n        password: \"test-password\",\n      });\n      t.assertEquals(response.user.username, \"test-user\",\n        \"returns username\");\n      t.assert(!!response.user.createdAt, \"has createdAt\n        date\");\n      t.assert(!!response.token, \"has token\");\n    …\n    });\n    ```", "```js\n    import { generateSalt, hashWithSalt } from \"./util.ts\"\n    ```", "```js\n    export * as benchmark from\n      \"https://deno.land/std@0.83.0/testing/bench.ts\";\n    ```", "```js\n    import { benchmarks } from \"../deps.ts\";\n    benchmarks.bench({\n      name: \"runsSaltFunction1000Times\",\n      runs: 1000,\n      func: (b) => {\n        bench function (as stated in the documentation). Inside this object, we're defining the number of runs, the name of the benchmark, and the test function. That function is what will run every time, since an argument is an object of the BenchmarkTimer type with two methods; that is, start and stop. These methods are used to start and stop the timings of the benchmarks, respectively.\n    ```", "```js\n    benchmarks.bench({\n      name: \"runsSaltFunction1000Times\",\n      …\n    });\n    benchmarks.runBenchmarks();\n    ```", "```js\n    $ deno run --unstable --allow-plugin --allow-env --allow-read --allow-write --allow-hrtime src/users/utilBenchmarks.ts\n    running 1 benchmarks ...\n    benchmark runsSaltFunction1000Times ...\n        1000 runs avg: 0.036691561000000206ms\n    benchmark result: DONE. 1 measured; 0 filtered\n    ```", "```js\n    benchmarks.bench({\n      name: \"runsHashFunction1000Times\",\n      runs: 1000,\n      func: (b) => {\n        b.start();\n        hashWithSalt(\"password\", \"salt\");\n        b.stop();\n      },\n    });\n    benchmarks.runBenchmarks();\n    ```", "```js\n    $ deno run --allow-hrtime --unstable --allow-plugin --allow-env –-allow-write --allow-read src/users/utilBenchmarks.ts     \n    running 2 benchmarks ...\n    benchmark runsSaltFunction100Times ...\n        1000 runs avg: 0.036691561000000206ms\n    benchmark runsHashFunction100Times ...\n        1000 runs avg: 0.02896806399999923ms\n    benchmark result: DONE. 2 measured; 0 filtered\n    ```"]