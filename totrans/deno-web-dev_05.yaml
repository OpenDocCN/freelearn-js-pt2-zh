- en: '*Chapter 7*: HTTPS, Extracting Configuration, and Deno in the Browser'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：HTTPS，提取配置和Deno在浏览器中'
- en: 'In the previous chapter, we pretty much wrapped up our application''s features.
    We added authorization and persistence, ending up with an application connected
    to a MongoDB instance. In this chapter, we''ll focus on some known best practices
    that are standard in production applications: basic security practices and dealing
    with configuration.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们基本上完成了应用程序的功能。我们添加了授权和持久性，最终得到了一个连接到MongoDB实例的应用程序。在本章中，我们将关注一些在生产应用程序中常见的最佳实践：基本的安全实践和处理配置。
- en: First, we'll add a couple of basic security features to our **application programming
    interface** (**API**), starting with **Cross-Origin Resource Sharing** (**CORS**)
    protection, to enable the filtering of requests based on their origin. Then, we'll
    learn how to enable **HyperText Transfer Protocol Secure** (**HTTPS**) in our
    application so that it supports encrypted connections. This will allow users to
    perform requests to the API using a secure connection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为我们的**应用程序编程接口**（**API**）添加一些基本的安全特性，从**跨源资源共享**（**CORS**）保护开始，以使基于它们的来源对请求进行过滤。然后，我们将学习如何在我们的应用程序中启用**安全超文本传输协议**（**HTTPS**），以便它支持加密连接。这将允许用户使用安全的连接对API进行请求。
- en: Until now, we've used a few secret values, but we weren't concerned about having
    them in the code. In this chapter, we'll extract the configuration and secrets
    so that they don't have to live in the code base. We'll then learn how we can
    have them safely stored and injected in the application. This way, we can be sure
    that those values are kept a secret and are not present in the code. By doing
    this, we'll also enable different deployments with different configurations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们使用了一些密钥值，但我们没有关注它们在代码中的存在。在本章中，我们将提取配置和密钥，使它们不必存在于代码库中。然后，我们将学习如何安全地存储和注入它们。这样，我们可以确保这些值保持秘密，并且不出现在代码中。通过这样做，我们还将使不同的部署具有不同的配置成为可能。
- en: 'Moving forward, we''ll explore the capabilities enabled by one specific Deno
    feature: the ability to compile and run code in the browser. By using Deno''s
    compatibility with ECMAScript 6 (supported by modern browsers), we''ll share code
    between the API and the frontend, enabling a whole new world of possibilities.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们将探索由一个特定的Deno功能启用的能力：在浏览器中编译和运行代码的能力。通过使用Deno对ECMAScript 6的兼容性（受现代浏览器支持），我们将在API和前端之间共享代码，启用一个全新的可能性世界。
- en: 'Leveraging this specific feature, we''ll explore one specific scenario: building
    a JavaScript client for the API. This client will be built using the same types
    and parts of code that also run on the server, and we''ll explore the benefits
    provided by that.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个特定的功能，我们将探索一个特定的场景：为API构建一个JavaScript客户端。这个客户端将使用在服务器上运行的相同类型和代码部分构建，并探索由此带来的好处。
- en: This chapter wraps up the *Building an application* section of this book, whereby
    we built an application step by step, adding some common application features
    with an incremental approach. While learning, we also made sure this application
    was as close to real as possible for an introductory book. This enabled us to
    learn about Deno, many of its APIs, and some community packages while we created
    a functional application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书的*构建应用程序*部分，我们一步一步地构建了一个应用程序，并用逐步增加的方法添加了一些常见应用程序特性。在学习过程中，我们还确保这个应用程序尽可能接近现实，这是一本介绍性书籍。这使我们能够在创建功能应用程序的同时学习Deno，它的许多API以及一些社区包。
- en: 'By the end of this chapter, you''ll be familiar with the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将熟悉以下主题：
- en: Enabling CORS and HTTPS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用CORS和HTTPS
- en: Extracting configuration and secrets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取配置和密钥
- en: Running Deno code in the browser
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中运行Deno代码
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code files needed for this chapter can be found at the following GitHub
    link:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的所有代码文件都可以在以下GitHub链接中找到：
- en: '[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter07/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter07/sections)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter07/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter07/sections)'
- en: Enabling CORS and HTTPS
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用CORS和HTTPS
- en: CORS protection and HTTPS support are two things considered critical in any
    running production application. This section will explain how can we add them
    to the application that we're building.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 跨源资源共享（CORS）和 HTTPS 支持是任何运行中的生产应用程序考虑的两个关键因素。本节将解释我们如何将它们添加到我们正在构建的应用程序中。
- en: There are many other security practices that can be added to any API. As those
    aren't Deno specifics and deserve a book by themselves, we decided to focus on
    these two elements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他安全实践可以添加到任何 API 中。由于这些不是 Deno 特定内容，并且值得单独一本书，我们决定专注于这两个要素。
- en: We'll begin by learning about CORS and how can we leverage `oak` and the middleware
    function feature we know in order to do it. Then, we'll learn how can we also
    use a self-signed certificate and make our API handle secure HTTP connections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习关于 CORS 的知识以及我们如何利用我们所知道的 `oak` 和中间件函数特性来实现它。然后，我们将学习如何使用自签名证书，并使我们的
    API 处理安全的 HTTP 连接。
- en: Let's go, starting with CORS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，从 CORS 开始。
- en: Enabling CORS
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 CORS
- en: If you are not familiar with CORS, it is a mechanism that enables a server to
    indicate to browsers which origins they should allow resource loading from. When
    the application is running on the same domain as the API, CORS is not even necessary,
    as the name directly makes explicit.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉 CORS，它是一种机制，使服务器能够指示浏览器允许从哪些来源加载资源。当应用程序在与 API 相同的域上运行时，CORS 甚至是不必要的，因为名称直接使其显而易见。
- en: 'I''ll provide you with the following quote from **Mozilla Developer Network**
    (**MDN**), explaining CORS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从**Mozilla Developer Network**（**MDN**）提供以下引用，解释 CORS：
- en: '"Cross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that
    allows a server to indicate any other origins (domain, protocol, or port) than
    its own from which a browser should permit loading of resources. CORS also relies
    on a mechanism by which browsers make a "preflight" request to the server hosting
    the cross-origin resource, in order to check that the server will permit the actual
    request. In that preflight, the browser sends headers that indicate the HTTP method
    and headers that will be used in the actual request."'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '"跨源资源共享（CORS）是一个基于 HTTP 头的机制，允许服务器指示浏览器应该允许从哪些其他来源（域、协议或端口）加载资源。CORS 还依赖于一种机制，浏览器向托管跨源资源的服务器发送“预检”请求，以检查服务器将允许实际请求。在预检中，浏览器发送头指示将使用实际请求中的
    HTTP 方法和头。"'
- en: To give you a more concrete example, imagine you have an API running at `the-best-deno-api.com`
    and you want to handle requests made from `the-best-deno-client.com`. Here, you'll
    want your server to have CORS enabled for the `the-best-deno-client.com` domain.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个更具体的例子，想象你有一个运行在 `the-best-deno-api.com` 的 API 并且你想处理来自 `the-best-deno-client.com`
    的请求。在这里，你希望你的服务器为 `the-best-deno-client.com` 域启用 CORS。
- en: 'If you don''t have it enabled, the browser will make a preflight request to
    your API (using the `OPTIONS` method), and the response to this request will not
    have an `Access-Control-Allow-Origin: the-best-deno-client.com` header, causing
    the request to fail and the browser to prevent further requests.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你没有启用它，浏览器将向你的 API 发送一个预检请求（使用 `OPTIONS` 方法），对这个请求的响应将不会有 `Access-Control-Allow-Origin:
    the-best-deno-client.com` 头，导致请求失败并阻止浏览器进一步请求。'
- en: We'll learn how we can enable this mechanism in our application, allowing requests
    to be made from `http://localhost:3000` in the example that follows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在我们的应用程序中启用此机制，允许在以下示例中从 `http://localhost:3000` 发起请求。
- en: As our application is using the `oak` framework, we'll learn how to do it with
    this framework. However, this is very similar to any other HTTP framework. We
    basically want to add a middleware function that handles requests and verifies
    their origins against a list of allowed domains.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序正在使用 `oak` 框架，我们将学习如何使用这个框架来实现。然而，这与其他任何 HTTP 框架非常相似。我们基本上想要添加一个处理请求并将其来源与允许的域列表进行比较的中间件函数。
- en: We'll use a community package called `cors` ([https://deno.land/x/cors@v1.2.1](mailto:https://deno.land/x/cors@v1.2.1)),
    but the implementation is quite simple. If you're curious about what it does,
    take a look at [https://deno.land/x/cors@v1.2.1/oakCors.ts](mailto:https://deno.land/x/cors@v1.2.1/oakCors.ts),
    as the code is quite straightforward.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 `cors` 的社区包（[https://deno.land/x/cors@v1.2.1](https://deno.land/x/cors@v1.2.1)），但实现非常简单。如果你好奇它做什么，可以查看
    [https://deno.land/x/cors@v1.2.1/oakCors.ts](https://deno.land/x/cors@v1.2.1/oakCors.ts)，因为代码非常直接。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'We''ll use the code we created in the previous chapter to start this implementation.
    This is available at [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/sections/4-connecting-to-mongodb/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/sections/4-connecting-to-mongodb/museums-api).
    You can also have a look at the finished code for this section here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前一章中创建的代码来启动这个实现。这可以在[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/sections/4-connecting-to-mongodb/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter06/sections/4-connecting-to-mongodb/museums-api)找到。您还可以查看本节完成后的代码：
- en: '[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter07/sections/3-deno-on-the-browser/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter07/sections/3-deno-on-the-browser/museums-api)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter07/sections/3-deno-on-the-browser/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter07/sections/3-deno-on-the-browser/museums-api)'
- en: Here, we'll add the `cors` package to our application, together with our own
    list of allowed domains. The end goal is that we can perform requests from a trusted
    website to this API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`cors`包添加到我们的应用程序中，同时加上我们自己的允许域名列表。最终目标是使我们能够从可信网站对这项API执行请求。
- en: 'Let''s do it. Proceed as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做。按照以下步骤进行：
- en: 'Install the `cors` module by updating the `deps` file (check [*Chapter 3*](B16380_03_Final_JM_ePub.xhtml#_idTextAnchor089),
    *The Runtime and Standard Library,* for reference on how to do this). The code
    can be seen in the following snippet:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更新`deps`文件安装`cors`模块（参考[第3章](B16380_03_Final_JM_ePub.xhtml#_idTextAnchor089)，《运行时和标准库》，了解如何进行此操作）。代码如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, run the `cache` command to update the `lock` file, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行`cache`命令以更新`lock`文件，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Import `oakCors` on `src/web/index.ts` and register it on the application,
    before the router is registered, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/web/index.ts`中导入`oakCors`，并在注册路由之前在应用程序中注册它，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Change the `createServer` function parameters to receive an array of `string`
    named `allowedOrigins` inside `configuration` and later send it to the `oakCors`
    middleware creator function. The code for this is shown here:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`createServer`函数参数更改为接收名为`allowedOrigins`的数组`string` inside `configuration`，稍后将其传递给`oakCors`中间件创建函数。这段代码如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There''s one thing missing, though—we need to send this array of `allowedOrigins`
    from `src/index.ts`. Let''s do this, as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不过还有一件事缺失——我们需要从`src/index.ts`发送这个`allowedOrigins`数组。让我们这样做，如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s test this, starting by running the API, as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来测试一下，首先运行API，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To test it, create an HTML file named `index.html` in the root folder (`museums-api`),
    with a script that performs a `POST` request to `http://localhost:8080/api/users/register`.
    The code for this is shown here:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试它，请在根目录（`museums-api`）中创建一个名为`index.html`的HTML文件，其中包含执行`POST`请求到`http://localhost:8080/api/users/register`的脚本。这段代码如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the same folder we created the `index.html` file, let''s run Deno''s standard
    library web server, using the `-p` flag to set the port to `3000` and `--host`
    to set the host to `localhost`. The code for this is shown here:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建了`index.html`文件的同一目录中，让我们运行Deno的标准库Web服务器，使用`-p`标志将端口设置为`3000`和`--host`将主机设置为`localhost`。这段代码如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Access `http://localhost:3000` with your browser and you should see a **WORKING**
    message, as illustrated in the following screenshot:![Figure 7.1 – Testing that
    the CORS API is working
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器访问`http://localhost:3000`，您应该看到一个**WORKING**消息，如下图所示：![图7.1 – 测试CORS API是否正常工作
- en: '](img/Figure_7.1_B16380.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B16380.jpg)'
- en: Figure 7.1 – Testing that the CORS API is working
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.1 – 测试CORS API是否正常工作
- en: 'If you want to test what happens when the origin is not in the `allowedOrigins`
    list, you can run the same command but with a different port (or host) and check
    the behavior. The code for this is shown here:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想测试当源不在`allowedOrigins`列表中时会发生什么，您可以运行相同的命令，但端口（或主机）不同，并检查行为。这段代码如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can now navigate to that new **Uniform Resource Locator** (**URL**) on the
    browser, and you should see a **NOT WORKING** message. If you look at the browser's
    console, you can also confirm that the browser is warning you that the CORS preflight
    request failed. That's the desired behavior.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您可以在浏览器中导航到这个新的**统一资源定位符**（**URL**），并且您应该看到一个**NOT WORKING**消息。如果您查看浏览器的控制台，还可以确认浏览器正在警告您CORS预检请求失败。这是期望的行为。
- en: And that's all we need to enable CORS on the API!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们启用API上的CORS所需的一切！
- en: The third-party module we used has a few more options you can explore—things
    such as filtering for specific HTTP methods or answering the preflight request
    with a different status code. At the moment, the default options are working for
    us. We'll now proceed and see how we can enable users to connect to the application
    via HTTPS, adding an extra layer of security and encryption.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的第三方模块还有一些其他选项供您探索——例如过滤特定的HTTP方法或用不同的状态码回答预检请求。目前，默认选项对我们来说正在工作。现在，我们将看看如何启用用户通过HTTPS连接到应用程序，添加一个额外的安全层和加密层。
- en: Enabling HTTPS
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用HTTPS
- en: 'Any user-facing application nowadays should not only be allowing but also forcing
    its users to connect over HTTPS. This is a layer of security added on top of HTTP,
    making sure all connections are encrypted via a trusted certificate. Once again,
    we''ll not try to come up with a definition, instead using the following one from
    MDN ([https://developer.mozilla.org/en-US/docs/Glossary/https](https://developer.mozilla.org/en-US/docs/Glossary/https)):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的任何面向用户的应用程序不仅应该允许，还应该强制其用户通过HTTPS连接。这是在HTTP之上添加的一层安全防护，确保所有连接都通过可信证书进行加密。再次强调，我们不会尝试给出定义，而是使用以下来自MDN的定义（[https://developer.mozilla.org/en-US/docs/Glossary/https](https://developer.mozilla.org/en-US/docs/Glossary/https)）：
- en: '"HTTPS (HyperText Transfer Protocol Secure) is an encrypted version of the
    HTTP protocol. It uses SSL or TLS to encrypt all communication between a client
    and a server. This secure connection allows clients to safely exchange sensitive
    data with a server, such as when performing banking activities or online shopping."'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '"HTTPS（安全超文本传输协议）是HTTP协议的加密版本。它使用SSL或TLS来加密客户端和服务器之间的所有通信。这种安全连接允许客户端安全地与服务器交换敏感数据，例如执行银行活动或在线购物时。"'
- en: By enabling HTTPS connections in our application, we're making sure that it's
    way harder to intercept and interpret requests. Without this a malicious user
    can, for instance, intercept a login request and have access to the user's password-and-username
    combination. We're protecting the user's sensitive data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的应用程序中启用HTTPS连接，我们可以确保拦截和解释请求变得更加困难。如果没有这个，恶意用户可以拦截登录请求并访问用户的密码-用户名组合。我们在保护用户的敏感数据。
- en: 'As we''re using `oak` in our application, we''ll look for a solution on how
    to support HTTPS connections in its documentation. By looking at [https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts](mailto:https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts),
    we can see that the `Application.listen` method receives a `configuration` object,
    the same one we previously used to send the `port` variable. There are other options,
    though, as we can see here: [https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts#Application](mailto:https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts#Application).
    That''s what we''ll use to enable HTTPS.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在应用程序中使用`oak`，我们将查看其文档以寻找支持HTTPS连接的解决方案。通过查看[https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts](https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts)，我们可以看到`Application.listen`方法接收一个`configuration`对象，这是我们之前用来发送`port`变量的同一个对象。然而，还有其他选项，正如我们在这里看到的：[https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts#Application](https://doc.deno.land/https/deno.land/x/oak@v6.3.1/mod.ts#Application)。这就是我们将用来启用HTTPS的东西。
- en: 'Let''s see how we can change `oak`''s configuration so that it supports secure
    connections, by following these steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过以下步骤更改`oak`的配置，使其支持安全连接：
- en: 'Go to `src/web/index.ts` and add the `secure`, `keyFile`, and `certFile` options
    to the `listen` method call, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/web/index.ts`文件，并向`listen`方法调用中添加`secure`、`keyFile`和`certFile`选项，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To keep our code tidy and more configurable, let''s extract these options and
    send them as parameters to the `createServer` function, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持我们的代码整洁且更易于配置，让我们提取这些选项并将它们作为参数发送到`createServer`函数，如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is what the `CreateServerDependencies` parameter type should look like:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是`CreateServerDependencies`参数类型应该的样子：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And this is what the `createServer` function looks like afterward, with the
    destructured parameters:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是之后具有解构参数的`createServer`函数的样子：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To wrap up, we will now send the paths to the certificate and key files from
    the `src/index.ts` file, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结一下，现在我们将从`src/index.ts`文件中发送证书和密钥文件的路径，如下所示：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, to keep the logs accurate, we need to fix the event listener we previously
    created, which logs that the application is running. This handler should now take
    into consideration that the application might run over HTTP or HTTPS, and log
    according to that.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，为了保持日志的准确性，我们需要修复我们之前创建的日志事件监听器，该监听器记录应用程序正在运行。此处理程序应考虑应用程序可能通过 HTTP 或 HTTPS
    运行，并相应地记录。
- en: 'Go back to `src/web/index.ts` and fix the event listener that is listening
    for the `listen` event so that it checks whether the connection is secure or not.
    The code for this is shown here:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `src/web/index.ts` 文件，修复监听 `listen` 事件的日志监听器，使其检查连接是否安全。这段代码如下所示：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s run the application and see if it works, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用程序，看看它是否可以正常工作，如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should now be able to access that URL and connect to the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够访问该 URL 并连接到应用程序。
- en: 'You might still be seeing security warnings, but no worries. You can click
    **Advanced** and **Proceed to localhost (unsafe)**, as illustrated in the following
    screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会继续看到安全警告，但不用担心。你可以点击**高级**和**继续访问 localhost（不安全）**，如图所示：
- en: '![Figure 7.2 – Chrome security warning screen'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – Chrome 安全警告屏幕'
- en: '](img/Figure_7.2_B16380.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B16380.jpg)'
- en: Figure 7.2 – Chrome security warning screen
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – Chrome 安全警告屏幕
- en: This is due to the certificate being self-signed and not signed by a trusted
    certificate authority. However, it shouldn't matter much, as the process is the
    exact same as if it were a production certificate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为证书是自签名的，并没有由受信任的证书机构签名。然而，这并不会有很大影响，因为过程与生产证书完全相同。
- en: If you're still having problems, you might need to access the API URL directly
    before opening this page (`https://localhost:8080/`). From there, you can just
    follow the procedure on the following link (https://jasonmurray.org/posts/2021/thisisunsafe/)
    to enable communication with an API that isn't using a trusted certificate. After
    that, accessing `https://localhost:8080` will work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然遇到问题，你可能需要直接访问 API URL 然后再打开这个页面（`https://localhost:8080/`）。从那里，你可以按照以下链接（https://jasonmurray.org/posts/2021/thisisunsafe/）上的程序启用与使用不受信任证书的
    API 的通信。之后，访问 `https://localhost:8080` 将正常工作。
- en: The moment you have a proper certificate, signed by a trusted certificate authority,
    you can use it the same way we're using this one and everything will keep working
    just fine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个由受信任的证书机构签名的正确证书，你可以像我们使用这个一样使用它，一切都会继续正常工作。
- en: And that wraps it up for this section! We've added CORS and HTTPS support to
    our existing application, improving its security.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，本节就结束了！我们向现有应用程序添加了 CORS 和 HTTPS 支持，提高了其安全性。
- en: In the next section, we'll see how we can extract the configuration and secrets
    from our code, enabling it to be a little more flexible and configurable from
    the outside.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何从我们的代码中提取配置和机密，使其对外部更加灵活和可配置。
- en: Let's go!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧！
- en: Extracting configuration and secrets
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取配置和机密
- en: Any application, independent of its dimension, will have configuration parameters.
    By looking at the application we've been building in the previous chapters, even
    if we look at the simplest version of them all—the *Hello World* web server—we'll
    find configuration values, such as the `port` value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序，无论其规模如何，都将有配置参数。通过查看我们在前一章节中构建的应用程序，即使我们查看最简单的版本——*Hello World* Web 服务器，我们也会发现配置值，例如
    `port` 值。
- en: It's also not a coincidence that we're sending a full object called `configuration`
    inside the `createServer` function, the function that starts up the web server.
    At the same time, we also have a couple of values that we know should be secret
    in the application. They're currently living in the code base, as it's been working
    for our purpose (which is learning), but we want to change it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们发送一个名为 `configuration` 的完整对象到 `createServer` 函数中，该函数用于启动 Web 服务器。在这个过程中，我们还知道有一些值应该是应用程序中的机密。目前，这些值存在于代码库中，因为这对于我们的目的（学习）来说是可行的，但我们希望进行更改。
- en: We're thinking of things such as the **JSON Web Token** (**JWT**) encryption
    keys, or the MongoDB credentials. Those are definitely not things you want to
    check out into your version control system. This is what this section is about.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑像 **JSON Web Token**（**JWT**）加密密钥或 MongoDB 凭据这样的东西。这些绝对不是你想放入版本控制系统的东西。这就是本节要讨论的内容。
- en: We'll be looking at the configuration values and the secrets currently living
    in the code base. We will extract them so that they can be kept a secret and only
    passed to the application when it runs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看当前存在于代码库中的配置值和机密。我们将提取它们，以便它们可以保持秘密，并且只在应用程序运行时传递给应用程序。
- en: Doing this process can be a tough job when you have an application in which
    the configuration values are scattered across multiple modules and files. However,
    as we're following some architecture best practices and thinking about keeping
    the code decoupled and configurable, we made our life a little easier.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个过程可能当你有一个应用程序时是一个艰难的工作，在这个应用程序中，配置值散布在多个模块和文件中。然而，由于我们正在遵循一些架构最佳实践，并考虑到保持代码解耦和可配置，我们使我们的生活变得稍微容易了一些。
- en: By having a look at `src/index.ts`, you can confirm that all the configuration
    values and secrets we're using are living there. This means that all the other
    modules are not aware of the configuration, and that's how it should be.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`src/index.ts`，你可以确认我们正在使用的所有配置值和机密都保存在那里。这意味着所有其他模块都不知道配置，这才是正确的。
- en: We'll be doing this "migration" in two phases. First, we'll extract all the
    configuration values into a `configuration` module, and then we'll extract the
    secrets.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两个阶段进行这个“迁移”。首先，我们将所有配置值提取到一个名为`configuration`的模块中，然后我们将提取机密。
- en: Creating a configuration file
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建配置文件
- en: 'To start, let''s find out what hardcoded values we have in the code that should
    be living in a configuration file. The following snippet highlights the values
    we don''t want to have living in the code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找出代码中应该保存在配置文件中的硬编码值。以下代码片段突出了我们不想在代码中存在的值：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By looking at this snippet from our application code, we can already identify
    a few things, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们应用程序代码中的这段片段，我们可以已经识别出一些东西，如下所示：
- en: The cluster URL and database name (the username and password are secrets)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群URL和数据库名称（用户名和密码是秘密）
- en: JWT algorithm, and expiration time (the key is a secret)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT算法和过期时间（密钥是一个秘密）
- en: The web server port
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站服务器端口
- en: CORS allowed origins
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CORS允许的源
- en: The HTTPS certificate and key file paths
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS证书和密钥文件路径
- en: These are the elements we're going to extract here. We'll start by creating
    what would be our configuration file with all these values.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将要提取的内容。我们将从创建包含所有这些值的我们的配置文件开始。
- en: We'll use **YAML Ain't Markup Language** (**YAML**), since this is a commonly
    used file type for configuration. If you're not familiar with it, no worries—it's
    quite simple to grasp. You can get an overview of how it works on the official
    website, [https://yaml.org/](https://yaml.org/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**YAML Ain't Markup Language**（**YAML**），因为这是一种常用于配置的文件类型。如果你不熟悉它，不用担心——它是相当简单的。你可以在官方网站上了解它的工作原理，[https://yaml.org/](https://yaml.org/)。
- en: We'll also make sure that we have different configuration files for different
    environments, thus creating a file that has the environment in its name.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将确保为不同环境有不同的配置文件，从而创建一个在其名称中包含环境的文件。
- en: 'Next, we''ll implement a feature that will allow us to store our configurations
    in a file, starting by creating the file itself, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个功能，这将允许我们将配置保存在一个文件中，首先是从创建该文件本身开始，如下所示：
- en: 'Create a `config.dev.yaml` file at the root of the project and add all the
    configurations there, like this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个名为`config.dev.yaml`的文件，并在其中添加所有这些配置，像这样：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now need a way of loading this file into our application. We'll be creating
    a module named `config` inside the `src` folder for that.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们需要一种方法将此文件加载到我们的应用程序中。为此，我们将在`src`文件夹中创建一个名为`config`的模块。
- en: To read the configuration file, we'll use the filesystem functions we learned
    in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056), *The Toolchain*,
    together with the `encoding` package from Deno's standard library.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了读取配置文件，我们将使用我们在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)《工具链》中学到的文件系统功能，以及Deno标准库中的`encoding`包。
- en: Create a `src/config` folder with a file named `index.ts` inside.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/config`的文件夹，里面有一个名为`index.ts`的文件。
- en: 'Here, we''ll define and export a function named `load`. This function will
    be responsible for loading the configuration file. The code for this is shown
    here:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将定义并导出一个名为`load`的函数。这个函数将负责加载配置文件。这段代码如下所示：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since we''re using TypeScript, we''ll define the type of what will be our configuration
    file, adding that as a return type for the `load` function. This should match
    the structure of the configuration file we previously created. The code for this
    is shown here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在使用 TypeScript，我们将定义将成为我们的配置文件的类型的配置文件，将此作为 `load` 函数的返回类型。这应该与先前创建的配置文件的结构相匹配。这段代码的显示如下：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the `load` function, we should now try to load the configuration file
    we previously created, by using Deno filesystem APIs. As there can be multiple
    files depending on the environment, we''ll also add `env` as a parameter to the
    `load` function, with the default value of `dev`, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `load` 函数内部，我们现在应该尝试使用 Deno 文件系统 API 加载我们之前创建的配置文件。由于根据环境可能会有多个文件，我们还将 `env`
    作为 `load` 函数的参数，默认值为 `dev`，如下所示：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Install the YAML encoder module from the Deno standard library, using `deno
    cache` to make sure we update the `lock` file (refer to [*Chapter* *3*](B16380_03_Final_JM_ePub.xhtml#_idTextAnchor089),
    *The Runtime and Standard Library*), and export it on `src/deps.ts`, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Deno 标准库中的 YAML 编码器模块，使用 `deno cache` 确保我们更新 `lock` 文件（参考 [第*3*章](B16380_03_Final_JM_ePub.xhtml#_idTextAnchor089)，*运行时和标准库*)，并在
    `src/deps.ts` 上导出它，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Import it on `src/config/index.ts` and use it to parse the contents of the
    read file, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/config/index.ts` 上导入它，并使用它解析读取文件的正文，如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Import the `config` module, call its `load` function, and use the configuration
    values, which previously were hardcoded values.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `config` 模块，调用其 `load` 函数，并使用先前硬编码的配置值。
- en: 'This is what the `src/index.ts` file should look like afterward:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是 `src/index.ts` 文件之后的样子：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We should now be able to run our application as we did previously, with the
    difference that all our configuration is now living in a separate file.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们应该能够像以前一样运行我们的应用程序，区别在于我们的所有配置现在都保存在一个单独的文件中。
- en: And that's it regarding configuration! We've extracted the configurations from
    the code into a `config` file, making them easier to read and maintain. We've
    also created a module that abstracts all the configuration-file reading and parsing,
    making sure the rest of the application isn't concerned about that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置就是这样！我们将配置从代码中提取到一个 `config` 文件中，使它们更容易阅读和维护。我们还创建了一个模块，它抽象了所有配置文件的读取和解析，确保应用程序的其余部分不关心这一点。
- en: Next, we'll learn how we can extend this `config` module so that it also incorporates
    secret values read from the environment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何扩展这个 `config` 模块，使其还包括从环境中读取的机密值。
- en: Accessing secret values
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问机密值
- en: As I previously mentioned, we've used a couple of values that should be secret,
    but we initially kept them on the code. Those are values that might change from
    environment to environment, and configuration we want to keep as a secret for
    security reasons. This requirement makes it impossible to have them checked out
    into version control, and thus they have to live somewhere else.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们使用了几个应该被视为机密的值，但我们最初将它们保留在代码中。这些值可能会根据环境而变化，我们想要将其作为机密出于安全原因。这个要求使得它们无法检出到版本控制中，因此它们必须存在于别处。
- en: One common practice to do this is to get these values from the environment,
    using environment variables. Deno provides an API that we'll use to read from
    environment variables. We'll be extending the `config` module so that it also
    includes secret values on its exported object of type `Configuration`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的一个常见做法是从环境中获取这些值，使用环境变量。Deno 提供了一个 API，我们将使用它来读取环境变量。我们将扩展 `config` 模块，使其还包括类型
    `Configuration` 的导出对象中的机密值。
- en: 'Here are the values that are supposed to be secrets and that are still living
    in the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是仍留在代码中的应被视为机密的值：
- en: MongoDB username
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 用户名
- en: MongoDB password
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 密码
- en: JWT encryption key
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT 加密密钥
- en: 'Let''s get them out of the code, and add them to the `configuration` object
    by following these steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它们从代码中提取出来，并通过以下步骤将它们添加到 `configuration` 对象中：
- en: 'In `src/config/index.ts`, add the MongoDB username and password to the configuration
    and the key to JWT in the configuration type, as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/config/index.ts` 中，将 MongoDB 用户名和密码以及 JWT 密钥添加到配置和配置类型中，如下所示：
- en: '[PRE24]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Extend the `configuration` object to include the `username` and `password`
    missing properties on `mongoDb` and `key` on `jwt`, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `configuration` 对象扩展到包括 `mongoDb` 中的 `username` 和 `password` 缺失属性以及 `jwt`
    中的 `key`，如下所示：
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only thing still to do is to get these values from the environment instead
    of having them hardcoded here. We'll use Deno's API for that, in order to access
    the environment (https://doc.deno.land/builtin/stable#Deno.env).
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在唯一剩下要做的就是从环境变量中获取这些值，而不是在这里硬编码它们。我们将使用Deno的API来实现这一点，以便访问环境（[https://doc.deno.land/builtin/stable#Deno.env](https://doc.deno.land/builtin/stable#Deno.env)）。
- en: 'Use `Deno.env.get` to get the variables from the environment. We should also
    set a default value in case the `env` variable is not present. The code is shown
    in the following snippet:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Deno.env.get`从环境变量中获取变量。如果`env`变量不存在，我们还应该设置一个默认值。以下代码片段展示了这一点：
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s get back to `src/index.ts` and use the secret values that we just added
    to the `configuration` object, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`src/index.ts`，并使用我们刚刚添加到`configuration`对象中的密钥值，如下所示：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, if we try to register and log in, we'll verify that everything is working.
    The application is connected to MongoDB and is retrieving the JWT token properly—the
    secrets are working!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试注册并登录，我们将验证一切是否正常工作。应用程序连接到了MongoDB，并且正确地检索到了JWT令牌——秘密正在起作用！
- en: Note for Windows users
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户的注意
- en: In Windows systems, you can use the `set` command ([https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/set_1](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/set_1))
    to set environment variable. Windows doesn't support setting environment variables
    inline, and thus, you have to run these commands prior to running the API. Throughout
    the book, we'll use the *nix syntax, but you'll have to use the `set` command
    if you're using Windows, as the following code demonstrates.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows系统中，您可以使用`set`命令（[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/set_1](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/set_1)）来设置环境变量。Windows不支持内联设置环境变量，因此，您必须在运行API之前运行这些命令。在整个书籍中，我们将使用*nix语法，但如果您使用Windows，您必须使用`set`命令，如下面的代码所示。
- en: 'Following are the `set` commands for Windows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是针对Windows的`set`命令：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We just managed to have all the configurations and secrets extracted from the
    code! This step made the configurations easier to read and maintain by writing
    them to a file, and made the secrets more secure by sending them via the environment
    to the application, instead of having them on the code base.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚成功将所有的配置和密钥从代码中提取出来！这一步使得通过写入文件来配置更加容易阅读和维护，通过将密钥通过环境发送到应用程序，而不是将它们放在代码库中，从而使密钥更加安全。
- en: We're getting closer to an application that can easily be deployed and configured
    in different environments, something we'll do in [*Chapter 9*](B16380_09_Final_JM_ePub.xhtml#_idTextAnchor190),
    *Deploying a Deno Application*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近一个可以在不同环境中轻松部署和配置的应用程序，我们将在[第9章](B16380_09_Final_JM_ePub.xhtml#_idTextAnchor190)中介绍如何部署Deno应用程序。
- en: In the next section, we'll leverage Deno's capabilities to bundle code for the
    browser, creating a very simple JavaScript client that connects to the API. That
    client can then be used by frontend clients so that the HTTP connection is abstracted;
    it will also share code and types with the API code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将利用Deno的能力为浏览器打包代码，创建一个非常简单的JavaScript客户端，该客户端连接到API。然后，前端客户端可以使用该客户端，使HTTP连接抽象化；它还将与API代码共享代码和类型。
- en: Get on board!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们吧！
- en: Running Deno code in the browser
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中运行Deno代码
- en: One of the things we mentioned in the previous chapters and one that we've considered
    as one of Deno's selling points is its full compatibility with ECMAScript6\. This
    makes it possible for Deno code to be compiled and run on the browser. This compilation
    is something made by Deno itself, and the bundler is included in the toolchain.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中提到的一些事情，也是我们将Deno作为卖点之一的是它对ECMAScript6的完全兼容性。这使得Deno代码可以被编译并在浏览器中运行。这个编译是由Deno本身完成的，并且打包器包含在工具链中。
- en: This feature enables a whole load of possibilities. A lot of them are due to
    the capacity for sharing code between the API and the client, and that's what
    we'll explore in this section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能启用了一系列的可能性。其中许多是由于API和客户端之间共享代码的能力，这是我们将在本节中探讨的。
- en: We'll build a very simple JavaScript client to interact with the Museums API
    we just built. This client can then be used by any browser application that wants
    to connect to the API. We'll write that client in Deno and bundle it so that it
    can be used by a client, or even served by the application itself.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个非常简单的JavaScript客户端来与刚刚构建的博物馆API交互。这个客户端随后可以被任何想要连接到API的浏览器应用程序使用。我们将在Deno中编写那个客户端并将其捆绑，以便它可以被客户端使用，甚至可以被应用程序本身提供服务。
- en: The client we'll write will be a very rudimentary HTTP client, thus we'll not
    focus much on the code. We're doing this to demonstrate how can we reuse code
    and types from Deno to generate code that runs on the browser. At the same time,
    we'll also explain some advantages of keeping a client and its API together.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的客户端是一个非常基础的HTTP客户端，因此我们不会过多关注代码。我们这样做是为了展示如何复用Deno中的代码和类型来生成在浏览器上运行的代码。同时，我们还将解释将客户端及其API放在一起的一些优点。
- en: 'Let''s start by creating a new module in the application, which we''ll call
    `client`, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在应用程序中创建一个新的模块，我们称之为`client`，如下所示：
- en: Create a folder inside `src` named `client`, with a file named `index.ts` inside
    it.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`中创建一个名为`client`的文件夹，并在其中创建一个名为`index.ts`的文件。
- en: 'Let''s create an exported method, `getClient`, which should return an instance
    of our API client with three functions: `login`, `register`, and `getMuseums`.
    The code for this is shown in the following snippet:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个导出的方法，`getClient`，它应该返回一个带有三个函数的API客户端实例：`login`、`register`和`getMuseums`。这段代码显示在下面的片段中：
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note how we're getting a `config` object that hosts `baseURL`.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何获取一个包含`baseURL`的`config`对象的。
- en: Now, it's just a matter of implementing the HTTP logic to make requests to the
    API. We'll not do a step-by-step guide to implementing this as it is quite straightforward,
    but you can access the full client on the book files ([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter07/sections/3-deno-on-the-browser/museums-api/src/client/index.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter07/sections/3-deno-on-the-browser/museums-api/src/client/index.ts)).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只是实现HTTP逻辑以向API发送请求的问题。我们不会逐步指导这个实现，因为它相当直接，但你可以访问书中的完整客户端文件([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter07/sections/3-deno-on-the-browser/museums-api/src/client/index.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter07/sections/3-deno-on-the-browser/museums-api/src/client/index.ts)).
- en: 'This is what the `register` method will look like:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是`register`方法的样子：
- en: '[PRE31]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note how we're importing types from the `users` module, adding them to our application.
    This will make our functions much more readable, and it will later allow us to
    have type-checking and completion when writing tests using the TypeScript client.
    We're also creating an object with `content-type` headers that will be used in
    all the requests.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何从`users`模块导入类型，并将它们添加到我们的应用程序中的。这会使我们的函数更加可读，并允许我们在使用TypeScript客户端编写测试时进行类型检查和补全。我们还创建了一个带有`content-type`头部的对象，它将在所有的请求中使用。
- en: By creating an HTTP client, we handle things such as authentication automatically.
    In this specific case, our client can automatically save the token and send it
    in future requests after the user logs in.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过创建一个HTTP客户端，我们可以自动处理诸如认证之类的事情。在这个特定案例中，我们的客户端可以在用户登录后自动保存令牌并在未来的请求中发送它。
- en: 'This is what the `login` method would look like:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是`login`方法的样子：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It''s currently setting the `token` variable that lives on the client instance.
    That token is later added to authenticated requests such as the `getMuseums` function,
    as demonstrated in the following snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 目前它正在设置存储在客户端实例上的`token`变量。那个令牌后来会被添加到诸如`getMuseums`函数之类的认证请求中，如下面的片段所示：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After creating the client, we want to distribute it. We can use the Deno bundle
    command to do it, as we learned in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)*,
    The Toolchain*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建客户端后，我们希望能够分发它。我们可以使用我们在学习[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)*，工具链*中学到的Deno打包命令来做到这一点。
- en: 'If we want to have it served by our web server, we can also do this by adding
    a handler that serves the bundled content of our client file. It would look something
    like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望由我们的网络服务器来提供这个服务，我们也可以通过添加一个处理器来服务客户端文件的捆绑内容。它看起来像这样：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You might need to go back to your `.vscode/settings.json` file and enable the
    `unstable` property so that it recognizes we''re using unstable APIs. This is
    demonstrated in the following snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要回到你的`./vscode/settings.json`文件，并启用`unstable`属性，以便它认识到我们正在使用不稳定的API。这如下面的代码段所示：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note how we're using the unstable `Deno.emit` API and setting the `content-type`
    as `application/javascript`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用不稳定的`Deno.emit` API并设置`content-type`为`application/javascript`的。
- en: We're then sending the file emitted by Deno (`deno:///bundle.js`) as the request
    body.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将由Deno发出的文件（`deno:///bundle.js`）作为请求体发送。
- en: This way, if a client performs a `GET` request to `/api/client.js`, it will
    bundle and serve the content of the client we just wrote. The end result will
    be a bundled, browser- compatible JavaScript file that can then be used by an
    application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果一个客户端对`/api/client.js`执行`GET`请求，它将会打包并服务我们刚刚编写的客户端内容。最终结果将是一个打包的、浏览器兼容的JavaScript文件，然后可以被应用程序使用。
- en: 'To finish, we''ll use this client in an HTML file that will authenticate and
    get the museums from the API. Proceed as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在HTML文件中使用这个客户端，该文件将进行认证并从API获取博物馆信息。按照以下步骤操作：
- en: 'Create an HTML file in the root of the project, named `index-with-client.html`,
    as illustrated in the following code snippet:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中创建一个名为`index-with-client.html`的HTML文件，如下面的代码段所示：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a `script` tag and import the script directly from the API URL, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`script`标签，并直接从API URL导入脚本，如下所示：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, it''s just a matter of using the client we built. We''ll use it to log
    in (with a user you previously created) and get a list of museums. The code is
    illustrated in the following snippet:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只是使用我们构建的客户端的问题。我们将使用它登录（使用你之前创建的用户）并获取博物馆列表。代码如下所示：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We'll use `window.prompt` to get the username and password when the user accesses
    the page, and then we'll log in with that data and use it to get museums. After
    this, we'll just add that to the **Document Object Model** (**DOM**), creating
    a list of museums.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`window.prompt`在用户访问页面时获取用户名和密码，然后用这些数据登录并获取博物馆信息。之后，我们只需将其添加到**文档对象模型**（**DOM**）中，创建一个博物馆列表。
- en: 'Let''s spin up the application again, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次启动应用程序，如下所示：
- en: '[PRE39]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And then, serving the frontend application, this time adding the `–cert` and
    `--key` flags with paths to the respective files, to run the file server with
    HTTPS, as illustrated in the following snippet:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，这次在前端应用程序中添加`–cert`和`--key`标志，以及各自文件的路径，以使用HTTPS运行文件服务器，如下面的代码段所示：
- en: '[PRE40]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now access the web page at https://localhost:3000/index-with-client.html,
    fill in the username and password, and get a list of museums on the screen, as
    illustrated in the following screenshot:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以访问https://localhost:3000/index-with-client.html这个网页，输入用户名和密码，然后在屏幕上获取博物馆列表，如下面的屏幕截图所示：
- en: '![Figure 7.3 – Web page with a JavaScript client getting data from the API'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3 – Web page with a JavaScript client getting data from the API](img/Figure_7.3_B16380.jpg)'
- en: '](img/Figure_7.3_B16380.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16380.jpg)'
- en: Figure 7.3 – Web page with a JavaScript client getting data from the API
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.3 – Web page with a JavaScript client getting data from the API
- en: 'To log in in the previous step, you need to use a user you previously registered
    on the application. If you don''t have one, you can create it using the following
    command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步登录时，你需要使用之前在应用程序上注册的用户。如果没有，你可以使用以下命令创建：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Make sure to replace `your-username` with the desired username, and `your-password`
    with the desired password.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 确保用你想要的用户名替换`your-username`，用你想要密码替换`your-password`。
- en: And with that, we've finished our section about using Deno on the browser!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们就完成了关于在浏览器上使用Deno的部分！
- en: What we just did can be further explored, unlocking great amounts of potential;
    this is just a quick example that applies to our use case. This practice makes
    it easier for any browser application to integrate with the application we just
    wrote. Instead of having to deal with HTTP logic, clients would just have to call
    methods and receive their responses. As we saw, this client can also handle topics
    such as authentication and cookies automatically.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚所做的可以进一步探索，解锁大量的潜力；这只是适用于我们用例的快速示例。这种实践使得任何浏览器应用程序更容易与我们现在编写的应用程序集成。客户无需处理HTTP逻辑，只需调用方法并接收其响应即可。正如我们所看到的，这个客户端也可以自动处理认证和cookie等主题。
- en: 'This section explored one feature that Deno enables: compiling code for the
    browser.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了Deno启用的一项功能：为浏览器编译代码。
- en: We've applied it in the context of our application by creating an HTTP client
    that abstracts the user from the API. This feature can be used to do lots of things
    and is currently being used in writing frontend JavaScript code inside Deno.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序的上下文中应用了这个功能，通过创建一个抽象用户与API之间的HTTP客户端。这个功能可以用来做很多事情，目前正被用于在Deno内部编写前端JavaScript代码。
- en: As we explained in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*, the only thing we have to take into consideration when writing
    code for the browser is not using functions from the `Deno` namespace. By following
    these restrictions, we can very easily write code in Deno using all its advantages
    and compile it to JavaScript for distribution.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)中解释的，*工具链*，当我们为浏览器编写代码时，需要考虑的唯一事情就是不要使用`Deno`命名空间中的函数。遵循这些限制，我们可以非常容易地在Deno中编写代码，利用其所有优势，并将其编译为JavaScript以供分发。
- en: This was just an introduction to a very promising feature. This feature, as
    with Deno, is still in its initial stages, and many great uses for it will be
    discovered by the community. Now that you're also aware of it, I'm sure you'll
    also come up with great ideas.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对一个非常有望的功能的介绍。这个功能，就像Deno一样，仍处于初期阶段，社区将会发现它的许多伟大用途。既然你现在也知道了它，我相信你也会想出很多好主意。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was a chapter in which we focused a lot on practices that bring our application
    closer to a state that we can deploy into production. We started by exploring
    basic security practices, adding the CORS mechanism and HTTPS to the API. These
    two features, which are pretty much standard in any application, are a big security
    improvement on what we already had.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们重点关注将应用程序带入可部署状态的实践章节。我们首先探索了基本的安全实践，为API添加了CORS机制和HTTPS。这两个功能几乎是任何应用程序的标准，它们比我们已有的功能有了很大的安全提升。
- en: Also, thinking about deploying the application, we also abstracted the configuration
    and secrets from the code base. We started by creating an abstraction that would
    deal with it so that the configuration is not scattered, and modules just receive
    their configuration values without any awareness of how they're loaded. Then,
    we proceeded to using those values in our current code base, something that revealed
    itself to be quite easy. This step removed any configuration values from the code
    and moved them to a configuration file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑到应用程序的部署，我们还从代码库中抽象出了配置和秘密。我们首先创建了一个处理它的抽象，这样配置就不会分散，模块只需接收它们的配置值，而无需了解它们是如何加载的。然后，我们继续在我们的当前代码库中使用这些值，这揭示了自己实际上相当容易。这一步骤将任何配置值从代码中移除，并将它们移动到配置文件中。
- en: Once done with configuration, we used the same abstraction created to deal with
    secrets in an application. We implemented a feature that loads values from environment
    variables and adds them to the application configuration. Then, we used those
    secret values where they were needed, with things such as the MongoDB credentials,
    and token-signing keys.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了配置，我们就使用了同样的抽象来处理应用程序中的秘密。我们实现了一个功能，它从环境变量中加载值并将它们添加到应用程序配置中。然后，我们在需要的地方使用这些秘密值，比如MongoDB凭据和令牌签名密钥。
- en: 'We finished the chapter by exploring a possibility offered by Deno since its
    first days: bundling code for the browser. Applying this feature to our application
    context, we decided on writing a JavaScript HTTP client to connect to the API.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以探索Deno自第一天起就提供的可能性结束了这个章节：为浏览器捆绑代码。将这个功能应用到我们的应用程序上下文中，我们决定编写一个JavaScript
    HTTP客户端来连接到API。
- en: 'This step explored part of the potential of sharing code between the API and
    client, unlocking a world of possibilities. With this, we explored how we can
    use this bundling feature of Deno to compile a file at runtime and serve it to
    the user. Part of this feature''s advantages will also be explored in the next
    chapter, where we''ll write unit and integration tests for our application. Part
    of those tests will use the HTTP client created here, leveraging one big advantage
    of this practice: having the client and server in the same code base.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步骤探讨了API和客户端之间共享代码的潜力，解锁了一个充满可能性的世界。通过这个步骤，我们探讨了如何使用Deno的捆绑功能在运行时编译一个文件并将其提供给用户。这个功能的优点也将在下一章中探讨，我们将为我们的应用程序编写单元和集成测试。其中一些测试将使用在这里创建的HTTP客户端，利用这种实践的一个巨大优势：客户端和服务器在同一个代码库中。
- en: In the next chapter, we'll focus deeply on testing. We'll write tests for the
    logic we wrote in the rest of the book, starting with the business logic. We'll
    learn how we can improve the reliability of a code base by adding tests, and how
    the layers and architecture we created are crucial when it comes to writing them.
    The tests we'll write will go from unit to integration tests, and we'll explore
    the use cases where they apply. We'll see the value added by tests when it comes
    to writing new features and maintaining old ones. Along the way, we'll learn about
    some new Deno APIs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将深入探讨测试。我们将为书中剩余部分编写的逻辑编写测试，从业务逻辑开始。我们将学习如何通过添加测试来提高代码库的可靠性，以及我们创建的层次结构和架构在编写它们时的关键性。我们将编写的测试从单元测试到集成测试，并探索它们适用的用例。我们将看到测试在编写新功能和维护旧功能时所增加的价值。在这个过程中，我们将了解一些新的Deno
    API。
- en: The code isn't done until the tests are written, and thus we'll write them to
    conclude our API.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代码没有编写测试就不算完成，因此我们将编写测试来结束我们的API。
- en: Let's go!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
