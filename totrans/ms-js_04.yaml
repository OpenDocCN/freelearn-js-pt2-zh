- en: Chapter 4. Object-Oriented JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript''s most fundamental data type is the Object data type. JavaScript
    objects can be seen as mutable key-value-based collections. In JavaScript, arrays,
    functions, and RegExp are objects while numbers, strings, and Booleans are object-like
    constructs that are immutable but have methods. In this chapter, you will learn
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance properties versus prototype properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start looking at how JavaScript treats objects, we should spend some
    time on an object-oriented paradigm. Like most programming paradigms, **object-oriented
    programming** (**OOP**) also emerged from the need to manage complexity. The main
    idea is to divide the entire system into smaller pieces that are isolated from
    each other. If these small pieces can hide as many implementation details as possible,
    they become easy to use. A classic car analogy will help you understand this very
    important point about OOP.
  prefs: []
  type: TYPE_NORMAL
- en: When you drive a car, you operate on the interface—the steering, clutch, brake,
    and accelerator. Your view of using the car is limited by this interface, which
    makes it possible for us to drive the car. This interface is essentially hiding
    all the complex systems that really drive the car, such as the internal functioning
    of its engine, its electronic system, and so on. As a driver, you don't bother
    about these complexities. A similar idea is the primary driver of OOP. An object
    hides the complexities of how to implement a particular functionality and exposes
    a limited interface to the outside world. All other systems can use this interface
    without really bothering about the internal complexity that is hidden from view.
    Additionally, an object usually hides its internal state from other objects and
    prevents its direct modification. This is an important aspect of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: In a large system where a lot of objects call other objects' interfaces, things
    can go really bad if you allow them to modify the internal state of such objects.
    OOP operates on the idea that the state of an object is inherently hidden from
    the outside world and it can be changed only via controlled interface operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'OOP was an important idea and a definite step forward from the traditional
    structured programming. However, many feel that OOP is overdone. Most OOP systems
    define complex and unnecessary class and type hierarchies. Another big drawback
    was that in the pursuit of hiding the state, OOP considered the object state almost
    immaterial. Though hugely popular, OOP was clearly flawed in many areas. Still,
    OOP did have some very good ideas, especially hiding the complexity and exposing
    only the interface to the outside world. JavaScript picked up a few good ideas
    and built its object model around them. Luckily, this makes JavaScript objects
    very versatile. In their seminal work, *Design Patterns: Elements of Reusable
    Object-Oriented Software*, the *Gang of Four* gave two fundamental principles
    of a better object-oriented design:'
  prefs: []
  type: TYPE_NORMAL
- en: Program to an interface and not to an implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object composition over class inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two ideas are really against how classical OOP operates. The classical
    style of inheritance operates on inheritance that exposes parent classes to all
    child classes. Classical inheritance tightly couples children to its parents.
    There are mechanisms in classical inheritance to solve this problem to a certain
    extent. If you are using classical inheritance in a language such as Java, it
    is generally advisable to *program to an interface, not an implementation*. In
    Java, you can write a decoupled code using interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of programming to an implementation, you can perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'How does programming to an interface help? When you program to the `List` interface,
    you can call methods only available to the `List` interface and nothing specific
    to `ArrayList` can be called. Programming to an interface gives you the liberty
    to change your code and use any other specific child of the `List` interface.
    For example, I can change my implementation and use `LinkedList` instead of `ArrayList`.
    You can change your variable to use `LinkedList` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of this approach is that if you are using the `List` at 100 places
    in your program, you don't have to worry about changing the implementation at
    all these places. As you were programming to the interface and not to the implementation,
    you were able to write a loosely coupled code. This is an important principle
    when you are using classical inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classical inheritance also has a limitation where you can only enhance the
    child class within the limit of the parent classes. You can''t fundamentally differ
    from what you have got from the ancestors. This inhibits reuse. Classical inheritance
    has several other problems as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance introduces tight coupling. Child classes have knowledge about their
    ancestors. This tightly couples a child class with its parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you subclass from a parent, you don''t have a choice to select what you
    want to inherit and what you don''t. *Joe Armstrong* (the inventor of **Erlang**)
    explains this situation very well—his now famous quote:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"The problem with object-oriented languages is they''ve got all this implicit
    environment that they carry around with them. You wanted a banana but what you
    got was a gorilla holding the banana and the entire jungle."*'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Behavior of JavaScript objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this background, let''s explore how JavaScript objects behave. In broad
    terms, an object contains properties, defined as a key-value pair. A property
    key (name) can be a string and the value can be any valid JavaScript value. You
    can create objects using object literals. The following snippet shows you how
    object literals are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A property''s name can be any string or an empty string. You can omit quotes
    around the property name if the name is a legal JavaScript name. So quotes are
    required around `first-name` but are optional around `firstname`. Commas are used
    to separate the pairs. You can nest objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Properties of an object can be accessed by using two notations: the array-like
    notation and dot notation. According to the array-like notation, you can retrieve
    the value from an object by wrapping a string expression in `[]`. If the expression
    is a valid JavaScript name, you can use the dot notation using `.` instead. Using
    `.` is a preferred method of retrieving values from an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an `undefined` error if you attempt to retrieve a non-existent
    value. The following would return `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A useful trick is to use the `||` operator to fill in default values in this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can update values of an object by assigning a new value to the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you observe closely, you will realize that the object literal syntax that
    you see is very similar to the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods are properties of an object that can hold function values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the properties that we add to an object, there is one default property
    for almost all objects, called a **prototype**. When an object does not have a
    requested property, JavaScript goes to its prototype to look for it. The `Object.getPrototypeOf()`
    function returns the prototype of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Many programmers consider prototypes closely related to objects' inheritance—they
    are indeed a way of defining object types—but fundamentally, they are closely
    associated with functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypes are used as a way to define properties and functions that will be
    applied to instances of objects. The prototype''s properties eventually become
    properties of the instantiated objects. Prototypes can be seen as blueprints for
    object creation. They can be seen as analogous to classes in object-oriented languages.
    Prototypes in JavaScript are used to write a classical style object-oriented code
    and mimic classical inheritance. Let''s revisit our earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a `player()` function that does nothing. We
    invoke it in two different ways. The first call of the function is as a normal
    function and second call is as a constructor—note the use of the `new()` operator
    in this call. Once the function is defined, we add a `usesBat()` method to it.
    When this function is called as a normal function, the object is not instantiated
    and we see `undefined` assigned to `crazyBob`. However, when we call this function
    with the `new` operator, we get a fully instantiated object, `swingJay`.
  prefs: []
  type: TYPE_NORMAL
- en: Instance properties versus prototype properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instance properties are the properties that are part of the object instance
    itself, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this example, you will see that **Instance method says - he is
    hired** is printed. The `isAvailable()` function defined in the `Player()` function
    is called an instance of `Player`. This means that apart from attaching properties
    via the prototype, you can use the this keyword to initialize properties in a
    constructor. When we have the same functions defined as an instance property and
    also as a prototype, the instance property takes precedence. The rules governing
    the precedence of the initialization are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Properties are tied to the object instance from the prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties are tied to the object instance in the constructor function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This example brings us to the use of the `this` keyword. It is easy to get
    confused by the `this` keyword because it behaves differently in JavaScript. In
    other OO languages such as Java, the `this` keyword refers to the current instance
    of the class. In JavaScript, the value of `this` is determined by the invocation
    context of a function and where it is called. Let''s see how this behavior needs
    to be carefully understood:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When `this` is used in a global context: When `this` is called in a global
    context, it is bound to the global context. For example, in the case of a browser,
    the global context is usually `window`. This is true for functions also. If you
    use `this` in a function that is defined in the global context, it is still bound
    to the global context because the function is part of the global context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When `this` is used in an object method: In this case, `this` is assigned or
    bound to the enclosing object. Note that the enclosing object is the immediate
    parent if you are nesting the objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When there is no context: A function, when invoked without any object, does
    not get any context. By default, it is bound to the global context. When you use
    `this` in such a function, it is also bound to the global context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `this` is used in a constructor function: As we saw earlier, when a function
    is called with a `new` keyword, it acts as a constructor. In the case of a constructor,
    `this` points to the object being constructed. In the following example, `f()`
    is used as a constructor (because it''s invoked with a `new` keyword) and hence,
    `this` is pointing to the new object being created. So when we say `this.member
    = "f"`, the new member is added to the object being created, in this case, that
    object happens to be `o`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We saw that instance properties take precedence when the same property is defined
    both as an instance property and prototype property. It is easy to visualize that
    when a new object is created, the properties of the constructor''s prototype are
    copied over. However, this is not a correct assumption. What actually happens
    is that the prototype is attached to the object and referred when any property
    of this object is referred. Essentially, when a property is referenced on an object,
    either of the following occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The object is checked for the existence of the property. If it's found, the
    property is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The associated prototype is checked. If the property is found, it is returned;
    otherwise, an `undefined` error is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an important understanding because, in JavaScript, the following code
    actually works perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code is a slight variation of the earlier example. We are creating the
    object first and then attaching the function to its prototype. When you eventually
    call the `isAvailable()` method on the object, JavaScript goes to its prototype
    to search for it if it's not found in the particular object (`crazyBob`, in this
    case). Think of this as *hot code loading*—when used properly, this ability can
    give you incredible power to extend the basic object framework even after the
    object is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with OOP already, you must be wondering whether we can
    control the visibility and access of the members of an object. As we discussed
    earlier, JavaScript does not have classes. In programming languages such as Java,
    you have access modifiers such as `private` and `public` that let you control
    the visibility of the class members. In JavaScript, we can achieve something similar
    using the function scope as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can declare private variables using the `var` keyword in a function. They
    can be accessed by private functions or privileged methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private functions may be declared in an object's constructor and can be called
    by privileged methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privileged methods can be declared with `this.method=function() {}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public methods are declared with `Class.prototype.method=function(){}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public properties can be declared with `this.property` and accessed from outside
    the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows several ways of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand a few important concepts from this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The `retirementAge` variable is a private variable that has no privileged method
    to get or set its value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `country` variable is a private variable created as a constructor argument.
    Constructor arguments are available as private variables to the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we called `cricketer.switchHands()`, it was only applied to the `cricketer`
    and not to both the players, although it's a prototype function of the `Player`
    itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private functions and privileged methods are instantiated with each new object
    created. In our example, new copies of `isAvailable()` and `book()` would be created
    for each new player instance that we create. On the other hand, only one copy
    of public methods is created and shared between all instances. This can mean a
    bit of performance gain. If you don't *really* need to make something private,
    think about keeping it public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance is an important concept of OOP. It is common to have a bunch of
    objects implementing the same methods. It is also common to have an almost similar
    object definition with differences in a few methods. Inheritance is very useful
    in promoting code reuse. We can look at the following classic example of inheritance
    relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that from the generic **Animal** class, we derive more specific
    classes such as **Mammal** and **Bird** based on specific characteristics. Both
    the Mammal and Bird classes do have the same template of an Animal; however, they
    also define behaviors and attributes specific to them. Eventually, we derive a
    very specific mammal, **Dog**. A Dog has common attributes and behaviors from
    an Animal class and Mammal class, while it adds specific attributes and behaviors
    of a Dog. This can go on to add complex inheritance relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, inheritance is used to establish or describe an **IS-A** relationship.
    For example, a dog IS-A mammal. This is what we know as **classical inheritance**.
    You would have seen such relationships in object-oriented languages such as C++
    and Java. JavaScript has a completely different mechanism to handle inheritance.
    JavaScript is classless language and uses prototypes for inheritance. Prototypal
    inheritance is very different in nature and needs thorough understanding. Classical
    and prototypal inheritance are very different in nature and need careful study.
  prefs: []
  type: TYPE_NORMAL
- en: In classical inheritance, instances inherit from a class blueprint and create
    subclass relationships. You can't invoke instance methods on a class definition
    itself. You need to create an instance and then invoke methods on this instance.
    In prototypal inheritance, on the other hand, instances inherit from other instances.
  prefs: []
  type: TYPE_NORMAL
- en: As far as inheritance is concerned, JavaScript uses only objects. As we discussed
    earlier, each object has a link to another object called its prototype. This prototype
    object, in turn, has a prototype of its own, and so on until an object is reached
    with `null` as its prototype; `null`, by definition, has no prototype, and acts
    as the final link in this prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand prototype chains better, let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a `Person` and then `Child`—a child IS-A person. We also copy
    the `cry` property of a `Person` to the `cry` property of `Child`. When we try
    to see this relationship using `instanceof`, we soon realize that just by copying
    a behavior, we could not really make `Child` an instance of `Person`; `aChild
    instanceof Person` fails. This is just copying or masquerading, not inheritance.
    Even if we copy all the properties of `Person` to `Child`, we won''t be inheriting
    from `Person`. This is usually a bad idea and is shown here only for illustrative
    purposes. We want to derive a prototype chain—an IS-A relationship, a real inheritance
    where we can say that child IS-A person. We want to create a chain: a child IS-A
    person IS-A mammal IS-A animal IS-A object. In JavaScript, this is done using
    an instance of an object as a prototype as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify the earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The changed line uses an instance of `Person` as the prototype of `Child`. This
    is an important distinction from the earlier method. Here we are declaring that
    child IS-A person.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed about how JavaScript looks for a property up the prototype chain
    till it reaches `Object.prototype`. Let''s discuss the concept of prototype chains
    in detail and try to design the following employee hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is a typical pattern of inheritance. A manager IS-A(n) employee. **Manager**
    has common properties inherited from an **Employee**. It can have an array of
    reportees. An **Individual Contributor** is also based on an employee but he does
    not have any reportees. A **Team Lead** is derived from a Manager with a few functions
    that are different from a Manager. What we are doing essentially is that each
    child is deriving properties from its parent (Manager being the parent and Team
    Lead being the child).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can create this hierarchy in JavaScript. Let''s define our
    `Employee` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special about these definitions. The `Employee` object contains
    three properties—name, salary, and department. Next, we define `Manager`. This
    definition shows you how to specify the next object in the inheritance chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In JavaScript, you can add a prototypical instance as the value of the prototype
    property of the constructor function. You can do so at any time after you define
    the constructor. In this example, there are two ideas that we have not explored
    earlier. First, we are calling `Employee.call(this)`. If you come from a Java
    background, this is analogous to the `super()` method call in the constructor.
    The `call()` method calls a function with a specific object as its context (in
    this case, it is the given the `this` value), in other words, call allows to specify
    which object will be referenced by the `this` keyword when the function will be
    executed. Like `super()` in Java, calling `parentObject.call(this)` is necessary
    to correctly initialize the object being created.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing we see is `Object.create()` instead of calling `new`. `Object.create()`
    creates an object with a specified prototype. When we do `new Parent()`, the constructor
    logic of the parent is called. In most cases, what we want is for `Child.prototype`
    to be an object that is linked via its prototype to `Parent.prototype`. If the
    parent constructor contains additional logic specific to the parent, we don't
    want to run this while creating the child object. This can cause very difficult-to-find
    bugs. `Object.create()` creates the same prototypal link between the child and
    parent as the `new` operator without calling the parent constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a side effect-free and accurate inheritance mechanism, we have to make
    sure that we perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the prototype to an instance of the parent initializes the prototype
    chain (inheritance); this is done only once (as the prototype object is shared)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the parent's constructor initializes the object itself; this is done
    with every instantiation (you can pass different parameters each time you construct
    it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this understanding in place, let''s define the rest of the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this hierarchy, we can instantiate these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the following output for the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A generic `Employee` has a department assigned to `None` (as specified in the
    default value) and the rest of the properties are also assigned as the default
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we instantiate a manager; we can provide specific values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For `TeamLead`, the `reports` property is derived from the base class (Manager
    in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When JavaScript processes the new operator, it creates a new object and passes
    this object as the value of `this` to the parent—the `TeamLead` constructor. The
    constructor function sets the value of the `projects` property and implicitly
    sets the value of the internal `__proto__` property to the value of `TeamLead.prototype`.
    The `__proto__` property determines the prototype chain used to return property
    values. This process does not set values for properties inherited from the prototype
    chain in the `jason` object. When the value of a property is read, JavaScript
    first checks to see whether the value exists in that object. If the value does
    exist, this value is returned. If the value is not there, JavaScript checks the
    prototype chain using the `__proto__` property. Having said this, what happens
    when you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It does not propagate to all the instances of `Employee`. This is because when
    you create an instance of the `Employee` object, this instance gets a local value
    for the name. When you set the `TeamLead` prototype by creating a new `Employee`
    object, `TeamLead.prototype` has a local value for the `name` property. Therefore,
    when JavaScript looks up the `name` property of the `jason` object, which is an
    instance of `TeamLead`), it finds the local value for this property in `TeamLead.prototype`.
    It does not try to do further lookups up the chain to `Employee.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the value of a property changed at runtime and have the new value
    be inherited by all the descendants of the object, you cannot define the property
    in the object''s constructor function. To achieve this, you need to add it to
    the constructor''s prototype. For example, let''s revisit the earlier example
    but with a slight change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Though this is a very powerful technique, care should be taken not to overuse
    it. Refer to [http://perfectionkills.com/extending-native-builtins/](http://perfectionkills.com/extending-native-builtins/)
    to understand the pitfalls of extending native built-ins and what care should
    be taken if you intend to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Getters** are convenient methods to get the value of specific properties;
    as the name suggests, **setters** are methods that set the value of a property.
    Often, you may want to derive a value based on some other values. Traditionally,
    getters and setters used to be functions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `setLastName()`, `setFirstName()`, and `getFullName()` are functions
    used to do *get* and *set* of properties. `Fullname` is a derived property by
    concatenating the `firstname` and `lastname` properties. This is a very common
    use case and ECMAScript 5 now provides you with a default syntax for getters and
    setters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how getters and setters are created using the
    object literal syntax in ECMAScript 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of declaring getters and setters is using the `Object.defineProperty()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this method, you can call `Object.defineProperty()` even after the object
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have tasted the object-oriented flavor of JavaScript, we will
    go through a bunch of very useful utility methods provided by **Underscore.js**.
    We discussed the installation and basic usage of Underscore.js in the previous
    chapter. These methods will make common operations on objects very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keys()`: This method retrieves the names of an object''s own enumerable properties.
    Note that this function does not traverse up the prototype chain:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`allKeys()`: This method retrieves the names of an object''s own and inherited
    properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`values()`: This method retrieves the values of an object''s own properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`mapObject()`: This method transforms the value of each property in the object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`functions()`: This returns a sorted list of the names of every method in an
    object—the name of every function property of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pick()`: This function returns a copy of the object, filtered to just the
    values of the keys provided:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`omit()`: This function is an invert of `pick()`—it returns a copy of the object,
    filtered to omit the values for the specified keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript applications can improve in clarity and quality by allowing for the
    greater degree of control and structure that object-orientation can bring to the
    code. JavaScript object-orientation is based on the function prototypes and prototypal
    inheritance. These two ideas can provide an incredible amount of wealth to developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw basic object creation and manipulation. We looked at
    how constructor functions are used to create objects. We dived into prototype
    chains and how inheritance operates on the idea of prototype chains. These foundations
    will be used to build your knowledge of JavaScript patterns that we will explore
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
