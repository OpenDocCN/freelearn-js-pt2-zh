- en: Chapter 3. Data Structures and Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章．数据结构与操作
- en: 'Most of the time that you spend in programming, you do something to manipulate
    data. You process properties of data, derive conclusions based on the data, and
    change the nature of the data. In this chapter, we will take an exhaustive look
    at various data structures and data manipulation techniques in JavaScript. With
    the correct usage of these expressive constructs, your programs will be correct,
    concise, easy to read, and most probably faster. This will be explained with the
    help of the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中你花费大部分时间做的事情是操作数据。你处理数据的属性，根据数据得出结论，改变数据的本性。在本章中，我们将详细介绍JavaScript中的各种数据结构和数据操作技术。正确使用这些表达式结构，你的程序将会是正确的、简洁的、易于阅读的，并且很有可能是更快的。这将在以下主题帮助下解释：
- en: Regular expressions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Exact match
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确匹配
- en: Match from a class of characters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符类中匹配
- en: Repeated occurrences
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复出现
- en: Beginning and end
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和结束
- en: Backreferences
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向引用
- en: Greedy and lazy quantifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪婪与懒惰量词
- en: Arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Maps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Sets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: A matter of style
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风格问题
- en: Regular expressions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: If you are not familiar with regular expressions, I request you to spend time
    learning them. Learning and using regular expressions effectively is one of the
    most rewarding skills that you will gain. During most of the code review sessions,
    the first thing that I comment on is how a piece of code can be converted to a
    single line of **regular expression** (or **RegEx**). If you study popular JavaScript
    libraries, you will be surprised to see how ubiquitous RegEx are. Most seasoned
    engineers rely on RegEx primarily because once you know how to use them, they
    are concise and easy to test. However, learning RegEx will take a significant
    amount of effort and time. A regular expression is a way to express a pattern
    to match strings of text. The expression itself consists of terms and operators
    that allow us to define these patterns. We'll see what these terms and operators
    consist of shortly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉正则表达式，我建议你花时间去学习它们。有效地学习和使用正则表达式是你会获得的最有价值的技能之一。在大多数代码审查会议中，我首先评论的是如何将一段代码转换成单个正则表达式（或RegEx）的行。如果你研究流行的JavaScript库，你会惊讶地看到正则表达式的普遍性。大多数经验丰富的工程师主要依赖正则表达式，因为一旦你知道如何使用它们，它们就是简洁且易于测试的。然而，学习正则表达式将需要大量的精力和时间。正则表达式是表达匹配文本字符串的模式的方法。表达式本身由术语和操作符组成，使我们能够定义这些模式。我们很快就会看到这些术语和操作符由什么组成。
- en: 'In JavaScript, there are two ways to create a regular expression: via a regular
    expression literal and constructing an instance of a `RegExp` object.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，创建正则表达式有两种方法：通过正则表达式字面量和使用`RegExp`对象实例化。
- en: 'For example, if we wanted to create a RegEx that matches the string test exactly,
    we could use the following RegEx literal:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要创建一个正好匹配字符串test的正则表达式，我们可以使用以下正则表达式字面量：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'RegEx literals are delimited using forward slashes. Alternatively, we could
    construct a `RegExp` instance, passing the RegEx as a string:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式字面量使用斜杠分隔。或者，我们可以构造一个`RegExp`实例，将正则表达式作为字符串传递：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both of these formats result in the same RegEx being created in the variable
    pattern. In addition to the expression itself, there are three flags that can
    be associated with a RegEx:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种格式都会在变量pattern中创建相同的正则表达式。除了表达式本身，还有三个标志可以与正则表达式关联：
- en: '`i`: This makes the RegEx case-insensitive, so `/test/i` matches not only `test`,
    but also `Test`, `TEST`, `tEsT`, and so on.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：这使正则表达式不区分大小写，所以`/test/i`不仅匹配`test`，还匹配`Test`、`TEST`、`tEsT`等。'
- en: '`g`: This matches all the instances of the pattern as opposed to the default
    of local, which matches the first occurrence only. More on this later.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：这与默认的局部匹配相反，后者只匹配第一个出现。稍后会有更多介绍。'
- en: '`m`: This allows matches across multiple lines that might be obtained from
    the value of a `textarea` element.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：这允许跨多行匹配，这可能来自`textarea`元素的值。'
- en: These flags are appended to the end of the literal (for example, `/test/ig`)
    or passed in a string as the second parameter to the `RegExp` constructor (`new
    RegExp("test", "ig")`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志在字面量末尾附加（例如，`/test/ig`）或作为字符串传递给`RegExp`构造器的第二个参数（`new RegExp("test", "ig")`）。
- en: 'The following example illustrates the various flags and how they affect the
    pattern match:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了各种标志以及它们如何影响模式匹配：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It isn't very exciting if we can just test whether the pattern matches a string.
    Let's see how we can express more complex patterns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只能测试模式是否与一个字符串匹配，那就没什么意思了。让我们看看如何表达更复杂的模式。
- en: Exact match
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精确匹配
- en: 'Any sequence of characters that''s not a special RegEx character or operator
    represents a character literal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不是特殊正则字符或运算符的连续字符都代表一个字符字面量：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We mean `o` followed by `r` followed by `a` followed by `n` followed by …—you
    get the point. We rarely use exact match when using RegEx because that is the
    same as comparing two strings. Exact match patterns are sometimes called simple
    patterns.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意思是`o`后面跟着`r`，后面跟着`a`，后面跟着`n`，后面跟着……—你应该明白了。当我们使用正则表达式时，我们很少使用精确匹配，因为那就像是比较两个字符串。精确匹配模式有时被称为简单模式。
- en: Match from a class of characters
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一类字符中匹配
- en: 'If you want to match against a set of characters, you can place the set inside
    `[]`. For example, `[abc]` would mean any character `a`, `b`, or `c`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想匹配一组字符，你可以在`[]`里放置这一组字符。例如，`[abc]`就意味着任何字符`a`、`b`或`c`：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can specify that you want to match anything but the pattern by adding a
    `^` (caret sign) at the beginning of the pattern:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定想匹配除模式以外的任何内容，通过在模式的开头添加一个`^`（感叹号）来实现：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One critical variation of this pattern is a range of values. If we want to
    match against a sequential range of characters or numbers, we can use the following
    pattern:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的一个关键变体是值的范围。如果我们想匹配一系列连续的字符或数字，我们可以使用以下的模式：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Special characters such as `$` and period (`.`) characters either represent
    matches to something other than themselves or operators that qualify the preceding
    term. In fact, we've already seen how `[`, `]`, `-`, and `^` characters are used
    to represent something other than their literal values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符，比如`$`和`.`，要么代表与自身以外的匹配，要么是修饰前面项的运算符。实际上，我们已经看到了`[`, `]`, `-`, 和`^`字符如何用来表示它们字面值以外的含义。
- en: How do we specify that we want to match a literal `[` or `$` or `^` or some
    other special character? Within a RegEx, the backslash character escapes whatever
    character follows it, making it a literal match term. So `\[` specifies a literal
    match to the `[` character rather than the opening of a character class expression.
    A double backslash (`\\`) matches a single backslash.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何指定想匹配一个字面`[`或`$`或`^`或其他特殊字符呢？在正则表达式中，反斜杠字符转义它后面的任何字符，使其成为一个字面匹配项。所以`\[`指定了一个对`[`字符的精确匹配，而不是字符类表达式的开始。双反斜杠（`\\`）匹配一个单反斜杠。
- en: In the preceding examples, we saw the `test()` method that returns **true**
    or **false** based on the pattern matched. There are times when you want to access
    occurrences of a particular pattern. The `exec()` method comes in handy in such
    situations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了`test()`方法，它基于匹配到的模式返回`true`或`false`。有时你想访问特定模式的各个出现。在这种情况下，`exec()`方法就派上用场了。
- en: 'The `exec()` method takes a string as an argument and returns an array containing
    all matches. Consider the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec()`方法接收一个字符串作为参数，返回一个包含所有匹配项的数组。考虑以下例子：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will return all the occurrences of the word `oyo` from the original text.
    The String object contains the `match()` method that has similar functionality
    of the `exec()` method. The `match()` method is called on a String object and
    the RegEx is passed to it as a parameter. Consider the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回原文中所有单词`oyo`的出现。String对象包含`match()`方法，其功能与`exec()`方法类似。在String对象上调用`match()`方法，把正则表达式作为参数传给它。考虑以下例子：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we are calling the `match()` method on the String object. We
    pass the RegEx as a parameter to the `match()` method. The results are the same
    in both these cases.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在String对象上调用`match()`方法。我们把正则表达式作为参数传给`match()`方法。这两种情况的结果是一样的。
- en: 'The other String object method is `replace()`. It replaces all the occurrences
    of a substring with a different string:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个String对象的方法是`replace()`。它用一个不同的字符串替换所有子字符串的出现：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is possible to pass a function as a second parameter of the `replace()`
    method. The `replace()` function takes the matching text as a parameter and returns
    the text that is used as a replacement:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把一个函数作为`replace()`方法的第二个参数。`replace()`函数把匹配到的文本作为参数，并返回用作替换的文本：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The String object''s `split()` method also takes a RegEx parameter and returns
    an array containing all the substrings generated after splitting the original
    string:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象的`split()`方法也接受一个正则表达式参数，并返回一个包含在原字符串分割后生成的所有子字符串的数组：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We need to add a backslash before the comma because a comma is treated specially
    in RegEx and we need to escape it if we want to use it literally.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在逗号之前加上反斜杠，因为正则表达式中逗号有特殊含义，如果我们想直接使用它，就需要转义它。
- en: 'Using simple character classes, you can match multiple patterns. For example,
    if you want to match `cat`, `bat`, and `fat`, the following snippet shows you
    how to use simple character classes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的字符类，你可以匹配多个模式。例如，如果你想匹配`cat`、`bat`和`fat`，以下片段展示了如何使用简单的字符类：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, this variation opens up possibilities to write concise RegEx
    patterns. Take the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这种变化打开了编写简洁正则表达式模式的可能性。看下面的例子：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, we are matching the numeric part of the matching string with
    a range `[0-5]`, hence we get a match from `i0` to `i5`. You can also use the
    negation class `^` to filter the rest of the matches:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们匹配匹配字符的数字部分，范围为`[0-5]`，因此我们从`i0`得到匹配到`i5`。您还可以使用否定类`^`过滤其余的匹配：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Observe how we are negating only the range clause and not the entire expression.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何只否定范围子句而不是整个表达式的。
- en: 'Several character groups have shortcut notations. For example, the shortcut
    `\d` means the same thing as `[0-9]`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 几个字符组有快捷方式。例如，快捷方式`\d`与`[0-9]`相同：
- en: '| Notation | Meaning |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 表示法 | 意义 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\d` | Any digit character |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 任何数字字符 |'
- en: '| `\w` | An alphanumeric character (word character) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 字母数字字符（单词字符） |'
- en: '| `\s` | Any whitespace character (space, tab, newline, and similar) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 任何空白字符（空格、制表符、换行符等） |'
- en: '| `\D` | A character that is not a digit |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 非数字字符 |'
- en: '| `\W` | A non-alphanumeric character |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 非字母数字字符 |'
- en: '| `\S` | A non-whitespace character |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 非空白字符 |'
- en: '| `.` | Any character except for newline |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 除换行符外的任何字符 |'
- en: 'These shortcuts are valuable in writing concise RegEx. Consider this example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些快捷方式在编写简洁的正则表达式中很有价值。考虑这个例子：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This expression definitely looks a bit strange. We can replace `[0-9]` with
    `\d` and make this a bit more readable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式看起来确实有点奇怪。我们可以用`\d`替换`[0-9]`，使这变得更易读：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, you will soon see that there are even better ways to do something like
    this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你很快就会看到还有更好的方法来这样做。
- en: Repeated occurrences
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复出现
- en: So far, we saw how we can match fixed characters or numeric patterns. Most often,
    you want to handle certain repetitive natures of patterns also. For example, if
    I want to match 4 `a`s, I can write `/aaaa/`, but what if I want to specify a
    pattern that can match any number of `a`s?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了如何匹配固定字符或数字模式。大多数时候，你希望处理模式的某些重复特性。例如，如果我想要匹配 4 个`a`，我可以写`/aaaa/`，但如果我想指定一个可以匹配任意数量`a`的模式呢？
- en: 'Regular expressions provide you with a wide variety of repetition quantifiers.
    Repetition quantifiers let us specify how many times a particular pattern can
    occur. We can specify fixed values (characters should appear *n* times) and variable
    values (characters can appear at least *n* times till they appear *m* times).
    The following table lists the various repetition quantifiers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式为您提供了各种重复量词。重复量词让我们指定特定模式可以出现的次数。我们可以指定固定值（字符应出现 *n* 次）和变量值（字符可以出现至少 *n*
    次，直到它们出现 *m* 次）。以下表格列出了各种重复量词：
- en: '`?`: Either 0 or 1 occurrence (marks the occurrence as optional)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`: 要么出现 0 次要么出现 1 次（将出现标记为可选）'
- en: '`*`: 0 or more occurrences'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`: 0 或多个出现'
- en: '`+`: 1 or more occurrences'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`: 1 或多个出现'
- en: '`{n}`: Exactly `n` occurrences'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n}`: 正好 `n` 次出现'
- en: '`{n,m}`: Occurrences between `n` and `m`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n,m}`: 在 `n` 和 `m` 之间的出现'
- en: '`{n,}`: At least an `n` occurrence'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n,}`: 至少出现 `n` 次'
- en: '`{,n}`: 0 to `n` occurrences'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{,n}`: 0 到 `n` 次出现'
- en: 'In the following example, we create a pattern where the character `u` is optional
    (has 0 or 1 occurrence):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们创建一个字符`u`可选（出现 0 或 1 次）的模式：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It helps to read the `/behaviou?r/` expression as 0 or 1 occurrences of character
    `u`. The repetition quantifier succeeds the character that we want to repeat.
    Let''s try out some more examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 把`/behaviou?r/`表达式看作是 0 或 1 次字符`u`的出现有助于阅读。重复量词 succeeds 了我们想要重复的字符。让我们尝试一些更多例子：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You should read and interpret the `\d+` expression as `'` is a literal character
    match, `\d` matches characters `[0-9]`, the `+` quantifier will allow one or more
    occurrences, and `'` is a literal character match.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该读取并解释`\d+`表达式，就像`'`是字面字符匹配，`\d`匹配字符`[0-9]`，`+`量词将允许一个或多个出现，而`'`是字面字符匹配。
- en: 'You can also group character expressions using `()`. Observe the following
    example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`()`对字符表达式进行分组。观察以下示例：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s break the preceding expression into smaller chunks to understand what
    is going on in here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把前面的表达式分解成更小的块，以了解这里发生了什么：
- en: '`H`: literal character match'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`：字面字符匹配'
- en: '`a+`: 1 or more occurrences of character `a`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`：字符`a`的一个或多个出现'
- en: '`(`: start of the expression group'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(`：表达式组的开始'
- en: '`H`: literal character match'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`：字面字符匹配'
- en: '`a+`: 1 or more occurrences of character `a`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`：字符`a`的一个或多个出现'
- en: '`)`: end of expression group'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`)`：表达式组的结束'
- en: '`+`: 1 or more occurrences of expression group (`Ha+`)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：表达式组（`Ha+`）的一个或多个出现'
- en: Now it is easier to see how the grouping is done. If we have to interpret the
    expression, it is sometimes helpful to read out the expression, as shown in the
    preceding example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更容易看出分组是如何进行的。如果我们必须解释表达式，有时读出表达式是有帮助的，如前例所示。
- en: Often, you want to match a sequence of letters or numbers on their own and not
    just as a substring. This is a fairly common use case when you are matching words
    that are not just part of any other words. We can specify the word boundaries
    by using the `\b` pattern. The word boundary with `\b` matches the position where
    one side is a word character (letter, digit, or underscore) and the other side
    is not. Consider the following examples.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你想匹配一组字母或数字本身，而不仅仅是作为子字符串。当你匹配的词不是其他任何词的一部分时，这是一个相当常见的用例。我们可以通过使用`\b`模式来指定单词边界。`\b`的单词边界匹配一侧是单词字符（字母、数字或下划线）而另一侧不是的位置。考虑以下示例。
- en: 'The following is a simple literal match. This match will also be successful
    if `cat` is part of a substring:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的字面匹配。如果`cat`是子字符串的一部分，这个匹配也会成功：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, in the following example, we define a word boundary by indicating
    `\b` before the word `cat`—this means that we want to match only if `cat` is a
    word and not a substring. The boundary is established before `cat`, and hence
    a match is found on the text, `a black cat`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下面的示例中，我们通过在单词`cat`前标示`\b`来定义一个单词边界——这意味着我们只想匹配`cat`作为一个单词而不是一个子字符串。边界是在`cat`之前建立的，因此在文本`a
    black cat`中找到了匹配项：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we use the same boundary with the word `tomcat`, we get a failed match
    because there is no word boundary before `cat` in the word `tomcat`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对单词`tomcat`使用相同的边界时，我们得到一个失败的匹配，因为在单词`tomcat`中`cat`之前没有单词边界：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is a word boundary after the string `cat` in the word `tomcat`, hence
    the following is a successful match:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在单词`tomcat`中，`cat`之后有一个单词边界，因此以下是一个成功的匹配：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the following example, we define the word boundary before and after the
    word `cat` to indicate that we want `cat` to be a standalone word with boundaries
    before and after:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在单词`cat`的前后都定义了单词边界，以表示我们想要`cat`作为一个有前后边界的独立单词：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Based on the same logic, the following match fails because there are no boundaries
    before and after `cat` in the word `concatenate`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于相同逻辑，以下匹配失败，因为在单词`concatenate`中`cat`前后的边界不存在：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `exec()` method is useful in getting information about the match found
    because it returns an object with information about the match. The object returned
    from `exec()` has an `index` property that tells us where the successful match
    begins in the string. This is useful in many ways:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec()`方法在获取关于找到匹配的信息方面很有用，因为它返回一个包含关于匹配的信息的对象。`exec()`返回的对象有一个`index`属性，告诉我们成功匹配在字符串中的开始位置。这在许多方面都是有用的：'
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Alternatives – OR
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代方案——或
- en: Alternatives can be expressed using the `|` (pipe) character. For example, `/a|b/`
    matches either the `a` or `b` character, and `/(ab)+|(cd)+/` matches one or more
    occurrences of either `ab` or `cd`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`|`（管道）字符可以表示替代方案。例如，`/a|b/`匹配`a`或`b`字符，而`/(ab)+|(cd)+/`匹配`ab`或`cd`的一个或多个出现。
- en: Beginning and end
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和结束
- en: 'Frequently, we may wish to ensure that a pattern matches at the beginning of
    a string or perhaps at the end of a string. The caret character, when used as
    the first character of the RegEx, anchors the match at the beginning of the string
    such that `/^test/` matches only if the test substring appears at the beginning
    of the string being matched. Similarly, the dollar sign (`$`) signifies that the
    pattern must appear at the end of the string: `/test$/`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，我们可能希望确保模式在字符串的开始处或 perhaps 在字符串的结束处匹配。当正则表达式的第一个字符是井号时（`^`），它将匹配固定在字符串的开始处，例如`/^test/`仅当`test`子字符串出现在要匹配的字符串的开头时才匹配。同样，美元符号（`$`）表示模式必须出现在字符串的末尾：`/test$/`。
- en: 'Using both `^` and `$` indicates that the specified pattern must encompass
    the entire candidate string: `/^test$/`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`^`和`$`指示指定的模式必须包含整个候选字符串：`/^test$/`。
- en: Backreferences
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向引用
- en: After an expression is evaluated, each group is stored for later use. These
    values are known as backreferences. Backreferences are created and numbered by
    the order in which opening parenthesis characters are encountered going from left
    to right. You can think of backreferences as the portions of a string that are
    successfully matched against terms in the regular expression.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式计算之后，每个组都存储起来以供以后使用。这些值称为反向引用。反向引用通过从左到右遇到左括号字符的顺序创建并编号。你可以将反向引用视为与正则表达式中的项成功匹配的字符串的部分。
- en: The notation for a backreference is a backslash followed by the number of the
    capture to be referenced, beginning with 1, such as `\1`, `\2`, and so on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 引用后缀的表示方法是一个反斜杠，后面跟着要引用的捕获组的编号，从1开始，例如`\1`、`\2`等等。
- en: 'An example could be `/^([XYZ])a\1/`, which matches a string that starts with
    any of the `X`, `Y`, or `Z` characters followed by an `a` and followed by whatever
    character matched the first capture. This is very different from `/[XYZ] a[XYZ]/`.
    The character following `a` can''t be any of `X`, or `Y`, or `Z`, but must be
    whichever one of those that triggered the match for the first character. Backreferences
    are used with String''s `replace()` method using the special character sequences,
    `$1`, `$2`, and so on. Suppose that you want to change the `1234 5678` string
    to `5678 1234`. The following code accomplishes this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是`/^([XYZ])a\1/`，它匹配一个以`X`、`Y`或`Z`中的任何一个字符开头，后面跟着一个`a`，再后面跟着与第一个捕获组匹配的任何字符的字符串。这与`/[XYZ]
    a[XYZ]/`非常不同。`a`后面的字符不能是`X`、`Y`或`Z`中的任何一个，而必须是触发第一个字符匹配的那个。反向引用用于字符串的`replace()`方法，使用特殊字符序列`$1`、`$2`等等。假设你想把`1234
    5678`字符串改为`5678 1234`。以下代码实现此功能：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, the regular expression has two groups each with four digits.
    In the second argument of the `replace()` method, `$2` is equal to `5678` and
    `$1` is equal to `1234`, corresponding to the order in which they appear in the
    expression.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，正则表达式有两个组，每个组都有四个数字。在`replace()`方法的第二个参数中，`$2`等于`5678`，`$1`等于`1234`，对应于它们在表达式中出现的顺序。
- en: Greedy and lazy quantifiers
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪婪与懒惰量词
- en: All the quantifiers that we discussed so far are greedy. A greedy quantifier
    starts looking at the entire string for a match. If there are no matches, it removes
    the last character in the string and reattempts the match. If a match is not found
    again, the last character is again removed and the process is repeated until a
    match is found or the string is left with no characters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止讨论的所有量词都是贪婪的。一个贪婪的量词从整个字符串开始寻找匹配。如果没有找到匹配，它会删除字符串中的最后一个字符并重新尝试匹配。如果没有再次找到匹配，它将再次删除最后一个字符，并重复这个过程，直到找到匹配或者字符串剩下没有字符。
- en: The `\d+` pattern, for example, will match one or more digits. For example,
    if your string is `123`, a greedy match would match `1`, `12`, and `123`. Greedy
    pattern `h`.`+l` would match `hell` in a string `hello`—which is the longest possible
    string match. As `\d+` is greedy, it will match as many digits as possible and
    hence the match would be `123`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`\d+`模式将匹配一个或多个数字。例如，如果你的字符串是`123`，贪婪匹配将匹配`1`、`12`和`123`。贪婪模式`h`.`+l`将在字符串`hello`中匹配`hell`—这是可能的最长字符串匹配。由于`\d+`是贪婪的，它会尽可能多地匹配数字，因此匹配将是`123`。
- en: In contrast to greedy quantifiers, a lazy quantifier matches as few of the quantified
    tokens as possible. You can add a question mark (`?`) to the regular expression
    to make it lazy. A lazy pattern `h.?l` would match `hel` in the string `hello`—which
    is the shortest possible string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与贪婪量词相比，懒惰量词尽可能少地匹配量词化的令牌。你可以在正则表达式中添加一个问号（`?`）使其变得懒惰。一个懒惰的模式`h.?l`将在字符串`hello`中匹配`hel`—这是可能的最短字符串。
- en: The `\w*?X` pattern will match zero or more words and then match an `X`. However,
    a question mark after `*` indicates that as few characters as possible should
    be matched. For an `abcXXX` string, the match can be `abcX`, `abcXX`, or `abcXXX`.
    Which one should be matched? As `*?` is lazy, as few characters as possible are
    matched and hence the match is `abcX`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`\w*?X`模式将匹配零个或多个单词，然后匹配一个`X`。然而，在`*`后面的问号表示应该尽可能少地匹配字符。对于字符串`abcXXX`，匹配可以是`abcX`、`abcXX`或`abcXXX`。哪一个应该被匹配？由于`*?`是懒惰的，尽可能少地匹配字符，因此匹配是`abcX`。'
- en: With this necessary information, let's try to solve some common problems using
    regular expressions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些必要的信息，让我们尝试使用正则表达式解决一些常见问题。
- en: 'Removing extra white space from the beginning and end of a string is a very
    common use case. As a String object did not have the `trim()` method until recently,
    several JavaScript libraries provide and use an implementation of string trimming
    for older browsers that don''t have the `String.trim()` method. The most commonly
    used approach looks something like the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串的开始和结束去除多余的空格是一个非常常见的用例。由于字符串对象直到最近才有一个`trim()`方法，因此一些JavaScript库为没有`String.trim()`方法的旧浏览器提供并使用了字符串截取的实现。最常用的方法看起来像下面的代码：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What if we want to replace repeated whitespaces with a single whitespace?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用一个空格替换重复的空格怎么办？
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Arrays
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is an ordered set of values. You can refer to the array elements with
    a name and index. These are the three ways to create arrays in JavaScript:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个有序的值集合。你可以用一个名字和索引来引用数组元素。以下是JavaScript中创建数组的三个方法：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When these values are specified, the array is initialized with them as the array's
    elements. An array's `length` property is equal to the number of arguments. The
    bracket syntax is called an array literal. It's a shorter and preferred way to
    initialize arrays.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些值被指定时，数组初始化为这些值作为数组的元素。数组的`length`属性等于参数的数量。方括号语法称为数组字面量。这是一种更简短且更推荐的方式来初始化数组。
- en: 'You have to use the array literal syntax if you want to initialize an array
    with a single element and the element happens to be a number. If you pass a single
    number value to the `Array()` constructor or function, JavaScript considers this
    parameter as the length of the array, not as a single element:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想初始化一个只有一个元素且该元素碰巧是数字的数组，你必须使用数组字面量语法。如果你将一个单一的数字值传递给`Array()`构造函数或函数，JavaScript将这个参数视为数组的长度，而不是单个元素：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: JavaScript does not have an explicit array data type. However, you can use the
    predefined `Array` object and its methods to work with arrays in your applications.
    The `Array` object has methods to manipulate arrays in various ways, such as joining,
    reversing, and sorting them. It has a property to determine the array length and
    other properties for use with regular expressions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有显式的数组数据类型。然而，你可以使用预定义的`Array`对象及其方法来处理应用程序中的数组。`Array`对象有各种方式操作数组的方法，如连接、反转和排序它们。它有一个属性来确定数组长度和其他用于正则表达式的属性。
- en: 'You can populate an array by assigning values to its elements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过给它的元素赋值来填充一个数组：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also populate an array when you create it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在创建数组时填充它：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In most languages, the elements of an array are all required to be of the same
    type. JavaScript allows an array to contain any type of values:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数语言中，数组的元素都必须是同一类型。JavaScript允许数组包含任何类型的值：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can refer to elements of an `Array` using the element''s index number.
    For example, suppose you define the following array:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用元素的索引号码来引用`Array`的一个元素。例如，假设你定义了以下数组：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You then refer to the first element of the array as `colors[0]` and the second
    element of the array as `colors[1]`. The index of the elements starts with `0`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将数组的第一个元素称为`colors[0]`，第二个元素称为`colors[1]`。元素的索引从`0`开始。
- en: 'JavaScript internally stores array elements as standard object properties,
    using the array index as the property name. The `length` property is different.
    The `length` property always returns the index of the last element plus one. As
    we discussed, JavaScript array indexes are 0-based: they start at `0`, not `1`.
    This means that the `length` property will be one more than the highest index
    stored in the array:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript内部将数组元素作为标准对象属性存储，使用数组索引作为属性名。`length`属性是不同的。`length`属性总是返回最后一个元素索引加一。正如我们讨论的，JavaScript数组索引是基于0的：它们从`0`开始，而不是`1`。这意味着`length`属性将是数组中存储的最高索引加一：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also assign to the `length` property. Writing a value that is shorter
    than the number of stored items truncates the array; writing `0` empties it entirely:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以赋值给`length`属性。如果写入的值比存储的项目数少，数组就会被截断；写入`0`则会清空它：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you query a non-existent array index, you get `undefined`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查询一个不存在的数组索引，你会得到`undefined`。
- en: 'A common operation is to iterate over the values of an array, processing each
    one in some way. The simplest way to do this is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的操作是遍历数组的值，以某种方式处理每一个值。这样做最简单的方式如下：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `forEach()` method provides another way of iterating over an array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()` 方法提供了另一种遍历数组的方式：'
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function passed to `forEach()` is executed once for every item in the array,
    with the array item passed as the argument to the function. Unassigned values
    are not iterated in a `forEach()` loop.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `forEach()` 的函数对数组中的每个项目执行一次，将数组项目作为函数的参数传递。在 `forEach()` 循环中不会遍历未赋值的值。
- en: The `Array` object has a bunch of useful methods. These methods allow the manipulation
    of the data stored in the array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 对象有一组实用的方法。这些方法允许操作数组中存储的数据。'
- en: 'The `concat()` method joins two arrays and returns a new array:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()` 方法将两个数组合并成一个新数组：'
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `join()` method joins all the elements of an array into a string. This
    can be useful while processing a list. The default delimiter is a comma (`,`):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 方法将数组的所有元素合并成一个字符串。这在处理列表时可能很有用。默认的分隔符是逗号 (`,`)：'
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `pop()` method removes the last element from an array and returns that
    element. This is analogous to the `pop()` method of a stack:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()` 方法从数组中移除最后一个元素，并返回该元素。这与栈的 `pop()` 方法类似：'
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `push()` method adds one or more elements to the end of an array and returns
    the resulting length of the array:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()` 方法向数组的末尾添加一个或多个元素，并返回数组的结果长度：'
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `shift()` method removes the first element from an array and returns that
    element:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`shift()` 方法从数组中移除第一个元素，并返回该元素：'
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `unshift()` method adds one or more elements to the front of an array and
    returns the new length of the array:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`unshift()` 方法向数组的开头添加一个或多个元素，并返回数组的新长度：'
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `reverse()` method reverses or transposes the elements of an array—the
    first array element becomes the last and the last becomes the first:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()` 方法反转或转置数组的元素——第一个数组元素变为最后一个，最后一个变为第一个：'
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `sort()` method sorts the elements of an array:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 方法对数组的元素进行排序：'
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `sort()` method can optionally take a callback function to define how the
    elements are compared. The function compares two values and returns one of three
    values. Let us study the following functions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 方法可以接受一个回调函数作为可选参数，以定义元素如何进行比较。该函数比较两个值并返回三个值之一。让我们研究以下函数：'
- en: '`indexOf(searchElement[, fromIndex])`: This searches the array for `searchElement`
    and returns the index of the first match:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(searchElement[, fromIndex])`：此方法在数组中搜索 `searchElement` 并返回第一个匹配项的索引：'
- en: '[PRE51]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`lastIndexOf(searchElement[, fromIndex])`: This works like `indexOf()`, but
    only searches backwards:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOf(searchElement[, fromIndex])`：此方法类似于 `indexOf()`，但只从后向前搜索：'
- en: '[PRE52]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we have covered JavaScript arrays in depth, let me introduce you to
    a fantastic library called **Underscore.js** ([http://underscorejs.org/](http://underscorejs.org/)).
    Underscore.js provides a bunch of exceptionally useful functional programming
    helpers to make your code even more clear and functional.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经深入讲解了 JavaScript 数组，那么让我向您介绍一个名为 **Underscore.js** 的绝佳库（[http://underscorejs.org/](http://underscorejs.org/)）。Underscore.js
    提供了一系列极其有用的函数编程助手，使您的代码更加清晰和功能化。
- en: 'We will assume that you are familiar with **Node.js**; in this case, install
    Underscore.js via npm:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您熟悉**Node.js**；在这种情况下，通过 npm 安装 Underscore.js：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we are installing Underscore as a Node module, we will test all the examples
    by typing them in a `.js` file and running the file on Node.js. You can install
    Underscore using **Bower** also.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将 Underscore 作为 Node 模块进行安装，因此我们将通过在 Node.js 上运行 `.js` 文件来输入所有示例。您也可以使用
    **Bower** 安装 Underscore。
- en: Like jQuery's `$` module, Underscore comes with a `_` module defined. You will
    call all functions using this module reference.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 jQuery 的 `$` 模块，Underscore 带有一个 `_` 模块的定义。您将使用这个模块引用调用所有函数。
- en: 'Type the following code in a text file and name it `test_.js`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入文本文件并命名为 `test_.js`：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This can be written as follows, without using `each()` function from underscore
    library:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不使用 underscore 库中的 `each()` 函数的写法：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: What you see here is a powerful functional construct that makes the code much
    more elegant and concise. You can clearly see that the traditional approach is
    verbose. Many languages such as Java suffer from this verbosity. They are slowly
    embracing functional paradigms. As JavaScript programmers, it is important for
    us to incorporate these ideas into our code as much as possible.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所展示的是一个强大的功能性结构，使代码更加优雅和简洁。你可以明显看出传统方法是冗长的。像 Java 这样的许多语言都受到这种冗长的影响。它们正在逐渐接受函数式编程范式。作为
    JavaScript 程序员，我们尽可能地将这些思想融入到我们的代码中是非常重要的。
- en: The `each()` function we saw in the preceding example iterates over a list of
    elements, yielding each to an iteratee function in turn. Each invocation of iteratee
    is called with three arguments (element, index, and list). In the preceding example,
    the `each()` function iterates over the array `[1,2,3]`, and for each element
    in the array, the `print` function is called with the array element as the parameter.
    This is a convenient alternative to the traditional looping mechanism to access
    all the elements in an array.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子中看到的`each()`函数遍历元素列表，依次将每个元素传递给迭代函数。每次迭代函数调用时，都会传入三个参数（元素、索引和列表）。在前面的例子中，`each()`函数遍历数组`[1,2,3]`，对于数组中的每个元素，`print`函数都会被调用，并传入数组元素作为参数。这是访问数组中所有元素的方便方法，代替传统的循环机制。
- en: 'The `range()` function creates lists of integers. The start value, if omitted,
    defaults to `0` and step defaults to `1`. If you''d like a negative range, use
    a negative step:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`函数创建整数列表。如果省略起始值，默认为`0`，步长默认为`1`。如果你想要一个负范围，使用负步长：'
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'By default, `range()` populates the array with integers, but with a little
    trick, you can populate other data types also:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`range()`用整数填充数组，但用一点小技巧，你也可以用其他数据类型填充：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is a fast and convenient way to create and initialize an array with values.
    We frequently do this by traditional loops.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种快速方便的方法来创建和初始化一个带有值的数组。我们经常通过传统循环来做这件事。
- en: 'The `map()` function produces a new array of values by mapping each value in
    the list through a transformation function. Consider the following example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数通过映射每个列表中的值到一个转换函数，生成一个新的值数组。考虑以下示例：'
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `reduce()` function reduces a list of values to a single value. The initial
    state is passed by the iteratee function and each successive step is returned
    by the iteratee. The following example shows the usage:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`函数将一个值列表减少到一个单一的值。初始状态由迭代函数传递，每个连续步骤由迭代函数返回。以下示例展示了使用方法：'
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this example, the line, `console.log(memo,num);`, is just to make the idea
    clear. The output will be as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`console.log(memo,num);`这行代码只是为了更清楚地说明想法。输出结果如下：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The final output is a sum of *1+2+3=6*. As you can see, two values are passed
    to the iteratee function. On the first iteration, we call the iteratee function
    with two values `(0,1)`—the value of the `memo` is defaulted in the call to the
    `reduce()` function and `1` is the first element of the list. In the function,
    we sum `memo` and `num` and return the intermediate `sum`, which will be used
    by the `iterate()` function as a `memo` parameter—eventually, the `memo` will
    have the accumulated `sum`. This concept is important to understand how the intermediate
    states are used to calculate eventual results.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出是`*1+2+3=6*`的和。正如你所见，两个值被传递到迭代函数中。在第一次迭代中，我们调用迭代函数并传入两个值`(0,1)`——`memo`在调用`reduce()`函数时的默认值是`0`，`1`是列表的第一个元素。在函数中，我们计算`memo`和`num`的和并返回中间的`sum`，这个`sum`将被`iterate()`函数作为`memo`参数使用——最终，`memo`将累积`sum`。理解这个概念对于了解如何使用中间状态来计算最终结果很重要。
- en: 'The `filter()` function iterates through the entire list and returns an array
    of all the elements that pass the condition. Take a look at the following example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数遍历整个列表，返回满足条件的所有元素的数组。看看下面的例子：'
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `filter()` function's iteratee function should return a truth value. The
    resulting `evens` array contains all the elements that satisfy the truth test.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数的迭代函数应该返回一个真值。结果的`evens`数组包含所有满足真值测试的元素。'
- en: 'The opposite of the `filter()` function is `reject()`. As the name suggests,
    it iterates through the list and ignores elements that satisfy the truth test:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数的反义词是`reject()`。正如名字 suggest，它遍历列表并忽略满足真值测试的元素：'
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are using the same code as the previous example but using the `reject()`
    method instead of `filter()`—the result is exactly the opposite.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了与上一个例子相同的代码，但这次用`reject()`方法而不是`filter()`——结果正好相反。
- en: 'The `contains()` function is a useful little function that returns `true` if
    the value is present in the list; otherwise, returns `false`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains()`函数是一个有用的小函数，如果值在列表中，就返回`true`；否则，返回`false`：'
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'One very useful function that I have grown fond of is `invoke()`. It calls
    a specific function on each element in the list. I can''t tell you how many times
    I have used it since I stumbled upon it. Let us study the following example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常实用的函数，我已经喜欢上了，就是 `invoke()`。它在列表中的每个元素上调用一个特定的函数。我无法告诉你自从偶然发现它以来我使用了多少次。让我们研究以下示例：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In this example, the `sort()` method of the `Array` object is called for each
    element in the array. Note that this would fail:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Array` 对象的 `sort()` 方法被应用于数组中的每个元素。注意这将失败：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is because the `sort` method is not part of the String object. This, however,
    would work perfectly:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `sort` 方法不是字符串对象的一部分。然而，这完全有效：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is because `toUpperCase()` is a String object method and all elements of
    the list are of the String type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `toUpperCase()` 是字符串对象的方法，列表中的所有元素都是字符串类型。
- en: 'The `uniq()` function returns the array after removing all duplicates from
    the original one:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq()` 函数返回去除原始数组所有重复项后的数组：'
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `partition()` function splits the array into two; one whose elements satisfy
    the predicate and the other whose elements don''t satisfy the predicate:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition()` 函数将数组分成两部分；一部分是满足谓词的元素，另一部分是不满足谓词的元素：'
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `without()` function returns a copy of the array with all instances of
    the specific values removed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`without()` 函数返回一个删除特定值所有实例的数组副本：'
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Maps
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射（Maps）
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Sets
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: ECMAScript 6 introduces sets. Sets are collections of values and can be iterated
    in the order of the insertion of their elements. An important characteristic about
    sets is that a value can occur only once in a set.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6 引入了集合。集合是值的集合，并且可以按照它们的元素插入顺序进行迭代。关于集合的一个重要特征是，集合中的值只能出现一次。
- en: 'The following snippet shows some basic operations on sets:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了集合的一些基本操作：
- en: '[PRE73]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We discussed briefly that JavaScript arrays are not really arrays in a traditional
    sense. In JavaScript, arrays are objects that have the following characteristics:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论过，JavaScript 数组并不是真正意义上的数组。在 JavaScript 中，数组是具有以下特征的对象：
- en: The `length` property
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length` 属性'
- en: The functions that inherit from `Array.prototype` (we will discuss this in the
    next chapter)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承自 `Array.prototype` 的函数（我们将在下一章讨论这个）
- en: Special handling for keys that are numeric keys
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数字键的特殊处理
- en: 'When we write an array index as numbers, they get converted to strings—`arr[0]`
    internally becomes `arr["0"]`. Due to this, there are a few things that we need
    to be aware of when we use JavaScript arrays:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写数组索引作为数字时，它们会被转换为字符串——`arr[0]` 内部变成了 `arr["0"]`。由于这一点，当我们使用 JavaScript 数组时，我们需要注意一些事情：
- en: Accessing array elements by an index is not a constant time operation as it
    is in, say, C. As arrays are actually key-value maps, the access will depend on
    the layout of the map and other factors (collisions and others).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引访问数组元素并不是一个常数时间操作，比如在 C 语言中。因为数组实际上是键值映射，访问将取决于映射的布局和其他因素（冲突等）。
- en: 'JavaScript arrays are sparse (most of the elements have the default value),
    which means that the array can have gaps in it. To understand this, look at the
    following snippet:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 数组是稀疏的（大多数元素都有默认值），这意味着数组中可能会有间隙。为了理解这一点，看看以下代码片段：
- en: '[PRE74]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You will see the output as `[undefined, undefined, undefined]`—`undefined` is
    the default value stored on the array element.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到输出是 `[undefined, undefined, undefined]`——`undefined` 是数组元素存储的默认值。
- en: 'Consider the following example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE75]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can see that there are gaps in this array. Only two elements have elements
    and the rest are gaps with the default value. Knowing this helps you in a couple
    of things. Using the `for...in` loop to iterate an array can result in unexpected
    results. Consider the following example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个数组中有间隙。只有两个元素有值，其余的都是使用默认值填充的间隙。了解这一点可以帮助你避免一些问题。使用 `for...in` 循环迭代数组可能会导致意外的结果。考虑以下示例：
- en: '[PRE76]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A matter of style
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风格问题
- en: Like the previous chapters, we will spend some time discussing the style considerations
    while creating arrays.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 和前面章节一样，我们将花些时间讨论创建数组时的风格考虑。
- en: 'Use the literal syntax for array creation:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字面量语法创建数组：
- en: '[PRE77]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use `Array#push` instead of a direct assignment to add items to an array:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Array#push` 而不是直接赋值来向数组中添加项目：
- en: '[PRE78]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As JavaScript matures as a language, its tool chain also becomes more robust
    and effective. It is rare to see seasoned programmers staying away from libraries
    such as Underscore.js. As we see more advanced topics, we will continue to explore
    more such versatile libraries that can make your code compact, more readable,
    and performant. We looked at regular expressions—they are first-class objects
    in JavaScript. Once you start understanding `RegExp`, you will soon find yourself
    using more of them to make your code concise. In the next chapter, we will look
    at JavaScript Object notation and how JavaScript prototypal inheritance is a new
    way of looking at object-oriented programming.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript作为一种语言的成熟，其工具链也变得更加健壮和有效。经验丰富的程序员很少会避开像Underscore.js这样的库。随着我们看到更多高级主题，我们将继续探索更多这样的多功能库，这些库可以使你的代码更加紧凑、易读且性能更优。我们研究了正则表达式——它们在JavaScript中是第一类对象。一旦你开始理解`RegExp`，你很快就会发现自己更多地使用它们来使你的代码更加简洁。在下一章，我们将探讨JavaScript对象表示法以及JavaScript原型继承是如何为面向对象编程提供一种新的视角。
