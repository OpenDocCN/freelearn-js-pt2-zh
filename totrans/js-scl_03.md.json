["```js\n// main.js\n// Imports a log() function from the util.js model.\nimport log from 'util.js';\nlog('Initializing...');\n\n// util.js\n// Exports a basic console.log() wrapper function.\n'use strict';\n\nexport default function log(message) {\n    if (console) {\n        console.log(message);\n    }\n}\n```", "```js\n// router.js\n\nimport Events from 'events.js'\n\n// A router is a type of event broker, it\n// can trigger routes, and listen to route\n// changes.\nexport default class Router extends Events {\n\n    // If a route configuration object is passed,\n    // then we iterate over it, calling listen()\n    // on each route name. This is translating from\n    // route specs to event listeners.\n    constructor(routes) {\n        super();\n\n        if (routes != null) {\n            for (let key of Object.keys(routes)) {\n                this.listen(key, routes[key]);\n            }\n        }\n    }\n\n    // This is called when the caller is ready to start\n    // responding to route events. We listen to the\n    // \"onhashchange\" window event. We manually call\n    // our handler here to process the current route.\n    start() {\n        window.addEventListener('hashchange',\n            this.onHashChange.bind(this));\n\n        this.onHashChange();\n    }\n\n    // When there's a route change, we translate this into\n    // a triggered event. Remember, this router is also an\n    // event broker. The event name is the current URI.\n    onHashChange() {\n        this.trigger(location.hash, location.hash);\n    }\n\n};\n\n// Creates a router instance, and uses two different\n// approaches to listening to routes.\n//\n// The first is by passing configuration to the Router.\n// The key is the actual route, and the value is the\n// callback function.\n//\n// The second uses the listen() method of the router,\n// where the event name is the actual route, and the\n// callback function is called when the route is activated.\n//\n// Nothing is triggered until the start() method is called,\n// which gives us an opportunity to set everything up. For\n// example, the callback functions that respond to routes\n// might require something to be configured before they can\n// run.\n\nimport Router from 'router.js'\n\nfunction logRoute(route) {\n    console.log('${route} activated');\n}\n\nvar router = new Router({\n    '#route1': logRoute\n});\n\nrouter.listen('#route2', logRoute);\n\nrouter.start();\n```", "```js\n// A super simple model class.\nclass Model {\n    constructor(first, last, age) {\n        this.first = first;\n        this.last = last;\n        this.age = age;\n    }\n}\n\n// The base view, with a name method that\n// generates some output.\nclass BaseView {\n    name() {\n        return '${this.model.first} ${this.model.last}';\n    }\n}\n\n// Extends BaseView with a constructor that accepts\n// a model and stores a reference to it.\nclass GenericModelView extends BaseView {\n    constructor(model) {\n        super();\n        this.model = model;\n    }\n}\n\n// Extends GenericModelView with specific constructor\n// arguments.\nclass SpecificModelView extends BaseView {\n    constructor(first, last, age) {\n        super();\n        this.model = new Model(...arguments);\n    }\n}\n\nvar properties = [ 'Terri', 'Hodges', 41 ];\n\n// Make sure the data is the same in both views.\n// The name() method should return the same result...\nconsole.log('generic view',\n    new GenericModelView(new Model(...properties)).name());\nconsole.log('specific view',\n    new SpecificModelView(...properties).name());\n```", "```js\nimport Events from 'events.js';\n\n// A basic model. It extending \"Events\" so it\n// can listen to events triggered by other components.\nclass Model extends Events {\n    constructor(enabled) {\n        super();\n        this.enabled = !!enabled;\n    }\n\n    // Setters and getters for the \"enabled\" property.\n    // Setting it also triggers an event. So other components\n    // can listen to the \"enabled\" event.\n    set enabled(enabled) {\n        this._enabled = enabled;\n        this.trigger('enabled', enabled);\n    }\n\n    get enabled() {\n        return this._enabled;\n    }\n}\n\n// A view component that takes a model and a DOM element\n// as arguments.\nclass View {\n    constructor(element, model) {\n\n        // When the model triggers the \"enabled\" event,\n        // we adjust the DOM.\n        model.listen('enabled', (enabled) => {\n            element.setAttribute('disabled', !enabled);\n        });\n\n        // Set the state of the model when the element is\n        // clicked. This will trigger the listener above.\n        element.addEventListener('click', () => {\n            model.enabled = false;\n        });\n    }\n}\n\nnew View(document.getElementById('set'), new Model());\n```", "```js\n// The base fetch() implementation of a model, sets\n// some property values, and resolves the promise.\nclass BaseModel {\n    fetch() {\n        return new Promise((resolve, reject) => {\n            this.id = 1;\n            this.name = 'foo';\n            resolve(this);\n        });\n    }\n}\n\n// Extends BaseModel with a specific implementation\n// of fetch().\nclass SpecificModel extends BaseModel {\n\n    // Overrides the base fetch() method. Returns\n    // a promise with combines the original\n    // implementation and result of calling fetchSettings().\n    fetch() {\n        return Promise.all([\n            super.fetch(),\n            this.fetchSettings()\n        ]);\n    }\n\n    // Returns a new Promise instance. Also sets a new\n    // model property.\n    fetchSettings() {\n        return new Promise((resolve, reject) => {\n            this.enabled = true;\n            resolve(this);\n        });\n    }\n}\n\n// Make sure the properties are all in place, as expected,\n// after the fetch() call completes.\nnew SpecificModel().fetch().then((result) => {\n    var [ model ] = result;\n    console.assert(model.id === 1, 'id');\n    console.assert(model.name === 'foo');\n    console.assert(model.enabled, 'enabled');\n    console.log('fetched');\n});\n```", "```js\n// A Renderer instance takes a renderer function\n// as an argument. The render() method returns the\n// result of calling the function.\nclass Renderer {\n    constructor(renderer) {\n        this.renderer = renderer;\n    }\n\n    render() {\n        return this.renderer ? this.renderer(this) : '';\n    }\n}\n\n// A feature defines an output pattern. It accepts\n// header, content, and footer arguments. These are\n// Renderer instances.\nclass Feature {\n    constructor(header, content, footer) {\n        this.header = header;\n        this.content = content;\n        this.footer = footer;\n    }\n\n    // Renders the sections of the view. Each section\n    // either has a renderer, or it doesn't. Either way,\n    // content is returned.\n    render() {\n        var header = this.header ?\n                '${this.header.render()}\\n' : '',\n            content = this.content ?\n                '${this.content.render()}\\n' : '',\n            footer = this.footer ?\n                this.footer.render() : '';\n\n        return '${header}${content}${footer}';\n    }\n}\n\n// Constructs a new feature with renderers for three sections.\nvar feature = new Feature(\n    new Renderer(() => { return 'Header'; }),\n    new Renderer(() => { return 'Content'; }),\n    new Renderer(() => { return 'Footer'; })\n);\n\nconsole.log(feature.render());\n\n// Remove the header section completely, replace the footer\n// section with a new renderer, and check the result.\ndelete feature.header;\nfeature.footer = new Renderer(() => { return 'Test Footer'; });\n\nconsole.log(feature.render());\n```"]