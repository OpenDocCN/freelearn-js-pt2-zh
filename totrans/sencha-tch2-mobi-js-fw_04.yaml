- en: Chapter 4. Components and Configurations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。组件和配置
- en: In this chapter, we are going to take a deeper look at the individual components
    available in Sencha Touch. We will examine the layout configuration options and
    how they affect each of the components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地查看Sencha Touch中可用的各个组件。我们将检查布局配置选项以及它们如何影响每个组件。
- en: Throughout the chapter, we will use the simple base components as a starting
    point for learning about the more complex components. We'll also talk a bit about
    how to access our components after they have been created.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用简单的基组件作为学习更复杂组件的起点。我们还会稍微谈谈如何在组件创建后访问它们。
- en: Finally, we will wrap up with a look at how to use the Sencha Touch API documentation
    to find detailed information on configurations, properties, methods, and events
    for each component.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将总结如何使用Sencha Touch API文档来查找每个组件的详细配置、属性、方法和事件信息。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The base component class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基组件类
- en: Layouts revisited
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局重新审视
- en: The TabPanel and Carousel components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签面板和轮播组件
- en: The FormPanel components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单面板组件
- en: MessageBox and Sheet
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息框和弹幕
- en: The Map component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图组件
- en: The List and NestedList components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和嵌套列表组件
- en: Where to find more information on components
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪里查找有关组件的更多信息
- en: The base component class
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基组件类
- en: When we talk about components in Sencha Touch, we are generally talking about
    buttons, panels, sliders, toolbars, form fields, and other tangible items that
    we can see on the screen. However, all of these components inherit their configuration
    options, methods, properties, and events from a single base component with the
    startlingly original name of `component`. This can obviously lead to a bit of
    confusion, so we will refer to this as `Ext.Component` for the rest of this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Sencha Touch中的组件时，我们通常是指按钮、面板、滑块、工具栏、表单字段和其他我们可以在屏幕上看到的实际项目。然而，所有这些组件都继承自一个具有惊人原创名称的单一基础组件`component`。这显然可能会导致一些混淆，所以我们将把这个称为`Ext.Component`。
- en: 'One of the most important things to understand is that you don''t always use
    `Ext.Component` directly. It is more often used as a building block for all of
    the other components in Sencha Touch. However, it is important to be familiar
    with the base component class, because anything that it can do, all the other
    components can do. Learning this one class can give you a huge head start on everything
    else. Some of the most useful configuration options of `Ext.Component` are as
    follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 理解最重要的一点是，你并不总是直接使用`Ext.Component`。它更常作为Sencha Touch中所有其他组件的构建块。然而，熟悉基组件类是很重要的，因为只要它能做，所有其他组件都能做。学习这个类可以让你在所有其他事情上有一个巨大的优势。`Ext.Component`一些最有用的配置选项如下：
- en: '`border`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`border`'
- en: '`cls`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cls`'
- en: '`disabled`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disabled`'
- en: '`height`/`width`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`/`width`'
- en: '`hidden`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hidden`'
- en: '`html`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html`'
- en: '`margin`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin`'
- en: '`padding`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding`'
- en: '`scroll`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scroll`'
- en: '`style`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style`'
- en: '`ui`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ui`'
- en: As the other components, which we will cover later in this chapter, inherit
    from the base component class, they will all have these same configuration options.
    One of the most critical of these configurations is `layout`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们将在本章后面覆盖的其他组件一样，继承自基组件类，它们都会有这些相同的配置选项。这些配置中最关键的是`layout`。
- en: Taking another look at layouts
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次审视布局
- en: When you start creating your own applications, you will need a firm understanding
    of how the different layouts affect what you see on the screen. To this end, we
    are going to start out with a demonstration application that shows how the different
    layouts work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始创建自己的应用程序时，你需要充分理解不同的布局如何影响你在屏幕上看到的内容。为此，我们将从演示应用程序开始，展示不同的布局是如何工作的。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the purposes of this demo application, we will create the different components,
    one at a time, as individual variables. This is done for the sake of readability
    and should not be considered the best programming style. Remember that any items
    created in the following way will take up memory, even if the user never views
    the component:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个演示应用程序的目的，我们将一次创建不同的组件，作为单独的变量。这样做是为了可读性，不应被视为最佳编程风格。记住，以这种方式创建的任何项目都会占用内存，即使用户从未查看组件：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is always a much better practice to create your components, using the `xtype`
    attributes, within your main container, as shown in the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 始终创建你的组件，使用`xtype`属性，在你的主容器内，如下面的代码片段所示，是一个更好的做法：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This allows Sencha Touch to render the components as they are needed, instead
    of rendering them all at once when the page loads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许Sencha Touch在需要时渲染组件，而不是在页面加载时一次性渲染所有组件。
- en: Creating a card layout
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个卡片布局
- en: 'To begin with, we will create a simple app with a container that is configured
    to use the `card` layout:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的应用程序，其包含一个配置为使用`card`布局的容器：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sets up a single container called `mainPanel` with a `card` layout. This
    `mainPanel` container is where we will be adding the rest of our layout example
    containers in this section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了一个名为`mainPanel`的单一容器，具有`card`布局。这个`mainPanel`容器是我们将在本节中添加我们布局示例容器的剩余部分的地方。
- en: The `card` layout arranges its items so that it looks similar to a stack of
    cards. Only one of these cards is active and displayed at a time. The `card` layout
    keeps any additional cards in the background and only creates them when the panel
    receives the `setActiveItem()` command.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`card`布局将其项目安排得类似于卡片堆叠。这些卡片中只有一张是激活的并一次显示。`card`布局将任何额外的卡片保留在后台，并在面板接收到`setActiveItem()`命令时仅创建它们。'
- en: 'Each item in the list can be activated by using `setActiveItem(n)`, where *n*
    is the item number. This can be a bit confusing, as the numbering of the items
    is zero-based, meaning that you start counting at 0 and not 1\. For example, if
    you want to activate the fourth item in the list, you would use:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个项目可以通过使用`setActiveItem(n)`激活，其中*n*是项目编号。这可能会有些令人困惑，因为项目的编号是基于零的，这意味着你从0开始计数，而不是从1开始。例如，如果你想要激活列表中的第四个项目，你会使用：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, we are starting out with only a single card/item called `hboxTest`.
    We need to add this container to make our program run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此案例中，我们起初只有一个名为`hboxTest`的单一卡片/项目。我们需要添加这个容器以使我们的程序运行。
- en: Creating an hbox layout
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个hbox布局
- en: 'In the code in the preceding section, on top of the `var mainPanel =` `Ext.create(''Ext.Container'',
    {` line, add the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分的代码中，在`var mainPanel = Ext.create('Ext.Container', {`行上方，添加以下代码：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This gives us a container with an `hbox` layout and three child items.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个具有`hbox`布局和三个子项目的容器。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Child and parent**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**子项与父项**'
- en: In Sencha Touch, we often find ourselves dealing with very large arrays of items,
    nested in containers that are in turn nested in other containers. It is often
    helpful to refer to a container as a parent to any items it contains. These items
    are then referred to as the children of the container.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha Touch中，我们经常发现自己处理非常大量的项目，这些项目被嵌套在容器中，而这些容器又被嵌套在其他容器中。通常，将容器称为其包含的任何项目的父容器是有帮助的。这些项目被称为容器的子项目。
- en: 'The `hbox` layout stacks its items horizontally and uses the `width` and `flex`
    values to determine how much horizontal space each of its child items will take
    up. The `align: ''stretch''` configuration causes the items to stretch in order
    to fill all of the available vertical space.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`hbox`布局将其项目横向堆叠，并使用`width`和`flex`值来确定其每个子项目将占据多少横向空间。`align: ''stretch''`配置导致项目拉伸以填充所有可用的垂直空间。'
- en: '![Creating an hbox layout](img/0748OS_04_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个hbox布局](img/0748OS_04_01.jpg)'
- en: You should try adjusting the `flex` and `width` values to see how they affect
    the size of the child containers. You can also change the available configuration
    options for `align` (`center`, `end`, `start`, and `stretch`), to see the different
    options available. Once you are finished, let's move on and add some more items
    to our card layout.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尝试调整`flex`和`width`值，看看它们如何影响子容器的尺寸。你还可以更改`align`（`center`、`end`、`start`和`stretch`）的可选配置选项，以查看可用的不同选项。完成之后，让我们继续向我们的卡片布局添加更多项目。
- en: Creating a vbox layout
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个vbox布局
- en: 'On top of our `var hboxTest = Ext.create`(''`Ext.Container`''`,{` line, add
    the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`var hboxTest = Ext.create('Ext.Container',{`行上方，添加以下代码：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code is virtually identical to our previous `hbox` code, a container with
    three child containers. However, this parent container uses `layout: vbox`, and
    the third child container in the `items` list uses `height` instead of `width`.
    This is because the `vbox` layout stacks its items vertically and uses the values
    for `height` and `flex` to determine how much space the child items will take
    up. In this layout, the `align: ''stretch''` configuration causes the items to
    stretch to fill the horizontal space.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '这代码与我们的之前的`hbox`代码几乎一模一样，一个具有三个子容器的容器。然而，这个父容器使用`layout: vbox`，`items`列表中的第三个子容器使用`height`而不是`width`。这是因为`vbox`布局是垂直堆叠其项目，并使用`height`和`flex`的值来确定子项目将占据多少空间。在这个布局中，`align:
    ''stretch''`配置导致项目伸展以填满水平空间。'
- en: 'Now that we have our `vbox` container, we need to add it to the items in our
    main `layoutContainer`. Change the `items` list in `layoutContainer` to say the
    following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的`vbox`容器，我们需要将其添加到我们主`layoutContainer`中的项目。将`layoutContainer`中的`items`列表更改为以下内容：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run the code now, it''s going to look exactly the same as before. This
    is because our card layout on `layoutContainer` can only have one active item.
    You can set `layoutContainer` to show our new `vbox` by adding the following configuration
    to our `layoutContainer`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行代码，它看起来会和之前一模一样。这是因为我们的卡片布局`layoutContainer`中只能有一个活动项目。您可以通过向我们的`layoutContainer`添加以下配置来设置`layoutContainer`显示我们的新`vbox`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember that our items are numbered starting with zero, so item `1` is the
    second item in our list: `items: [hboxTest, vboxTest]`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '记住我们的项目是从零开始编号的，所以项目`1`是我们列表中的第二个项目：`items: [hboxTest, vboxTest]`。'
- en: 'You should now be able to see the `vbox` layout for our application:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够看到我们应用程序的`vbox`布局：
- en: '![Creating a vbox layout](img/0748OS_04_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个vbox布局](img/0748OS_04_02.jpg)'
- en: As with `hbox`, you should take a moment to adjust the `flex` and `width` values
    and see how they affect the size of the containers. You can also change the available
    configuration options for `align` (`center`, `end`, `start`, and `stretch`) in
    order to see the different options available. Once you are finished, let's move
    on and add some more items to our `card` layout.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与`hbox`一样，您应该花点时间调整`flex`和`width`值，看看它们如何影响容器的大小。您还可以更改`align`（`center`、`end`、`start`和`stretch`）的可选配置选项，以查看不同的选项。完成后，让我们继续向我们的`card`布局添加更多项目。
- en: Creating a fit layout
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建合适的布局
- en: The `fit` layout is the most basic layout, and it simply makes any child items
    fill up the parent container. While this seems pretty basic, it can also have
    some unintended consequences, as we will see in our example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`fit`布局是最基本的布局，它只是使任何子项目填满父容器。虽然这看起来相当基础，但它也可能有一些 unintended consequences，正如我们在例子中所见。'
- en: 'On top of our preceding `var vboxTest = Ext.create(`''`Ext.Container'', {`
    line, add the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的`var vboxTest = Ext.create(`'`Ext.Container', {`行上，添加以下代码：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a single container with a `fit` layout and a button. Now, all we need
    to do is set the `activeItem` configuration on our main `layoutContainer` component
    by changing `activeItem: 1` to `activeItem: 2`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个具有`fit`布局的单容器和按钮。现在，我们只需要在我们的主`layoutContainer`组件上设置`activeItem`配置，将`activeItem:
    1`更改为`activeItem: 2`。'
- en: 'If you reload the page now, you will see what we mean by unintended consequences:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在重新加载页面，您将看到我们所说的unintended consequences：
- en: '![Creating a fit layout](img/0748OS_04_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个适合布局](img/0748OS_04_03.jpg)'
- en: As you can see, our button has expanded to fill the entire screen. We can change
    this by declaring a specific height and width for the button (and any other items
    we place in this container). However, fit layouts tend to work best for a single
    item that is intended to take up the entire container. This makes them a pretty
    good layout for child containers, where the parent container controls the overall
    size and position.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的按钮已经扩展到填满整个屏幕。我们可以通过为按钮（以及我们放置在这个容器中的任何其他项目）声明一个特定的高度和宽度来更改此情况。然而，适合布局通常最适合单个项目，该项目旨在占据整个容器。这使得它们成为子容器的一个很好的布局，在这种情况下，父容器控制整体大小和位置。
- en: Let's see how this might work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这可能如何工作。
- en: Adding complexity
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加复杂度
- en: For this example, we are going to create a nested container and add it to our
    card stack. We will also add some buttons to make switching the card stack easier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个嵌套容器并添加到我们的卡片堆叠中。我们还将添加一些按钮，以便更容易切换卡片堆叠。
- en: 'Our two new containers are variations on what we already have in our current
    application. The first is a copy of our `hbox` layout with a few minor changes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们两个新容器是我们当前应用程序中已经拥有的变体。第一个是我们`hbox`布局的副本，有几个小的变化：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can copy and paste our old `vboxTest` code and change the first line to
    say `complexTest` instead of `vboxTest`. You will also need to remove the second
    container in our `items` list (parentheses and all) and replace it with `hboxTest2`.
    This is where we will nest another container with its own layout.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以复制并粘贴我们旧的`vboxTest`代码，并将第一行更改为说`complexTest`而不是`vboxTest`。你还需要删除我们`items`列表中的第二个容器（包括所有括号）并用`hboxTest2`替换它。这是我们将在其中嵌套具有自己布局的另一个容器的位置。
- en: 'Now, we need to define `hboxTest2` by copying our previous `hboxTest` code,
    and make a few minor changes. You will need to paste this new code up on top of
    where you placed the `complexTest` code; otherwise, you will get errors when we
    try to use `hboxTest2` before we actually define it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过复制我们之前的`hboxTest`代码来定义`hboxTest2`，并进行一些小的修改。你需要将这段新代码粘贴到你放置`complexTest`代码的地方；否则，在我们实际定义它之前尝试使用`hboxTest2`时，你会得到错误：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After you paste in the code, you will need to change the variable name to `hboxTest2`,
    and we will need to add a `flex` configuration to the main parent container. As
    this container is nested within our `vbox` container, the `flex` configuration
    is needed to define how much space `hboxTest2` will occupy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 粘贴代码后，你需要将变量名更改为`hboxTest2`，并且我们需要为主父容器添加一个`flex`配置。由于这个容器嵌套在我们的`vbox`容器中，`flex`配置需要定义`hboxTest2`将占据多少空间。
- en: Before we take a look at this new complex layout, let's make our lives a bit
    easier by adding some buttons to switch between our various layout cards.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这个新的复杂布局之前，让我们通过添加一些按钮来简化我们的工作，以便在各种布局卡之间切换。
- en: 'Locate `mainPanel`, and underneath it, where we define the list of `items`,
    add the following code at the top of the list of `items`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 定位`mainPanel`，在它下面，定义`items`列表的地方，在`items`列表的最上面添加以下代码：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code adds a toolbar to the top of our `mainPanel`, with a button for each
    of our layout cards.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在`mainPanel`的顶部添加了一个工具栏，每个布局卡片都有一个按钮。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In previous versions of Sencha Touch, the `toolbar` item was defined separately
    from the rest of the items and used a configuration called `dock` to control its
    position. In current versions, the `toolbar` component is defined inline with
    other items, and the placement of the toolbar is controlled by the `docked` configuration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha Touch的早期版本中，`toolbar`项是独立于其他项定义的，并使用一个名为`dock`的配置来控制其位置。在当前版本中，`toolbar`组件与其他项一起内联定义，而工具栏的位置则由`docked`配置控制。
- en: 'Each button has a text configuration, which serves as the button''s title,
    and a `handler` configuration. The `handler` configuration defines what happens
    when the button is tapped. For each of our buttons, we use the `mainPanel` variable
    we set earlier in the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都有一个文本配置，作为按钮的标题，还有一个`handler`配置。`handler`配置定义了按钮被点击时会发生什么。对于我们每个按钮，我们在代码中使用之前设置的`mainPanel`变量：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This lets us use any of the methods available to the container and its `card`
    layout. In the code for each button, we set the active item (which tab is visible)
    by using the following line of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以使用容器及其`card`布局可用的任何方法。在每按钮的代码中，我们通过使用以下代码行来设置活动项（哪个标签页是可见的）：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `x` value, in this case, would be replaced by the index of the item we want
    to activate (remember that these go in order, starting with 0 and not 1).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，`x`值将被替换为我们想要激活的项的索引（记住这些是按顺序排列的，从0开始，而不是1）。
- en: Notice that we also leave the initial configuration option for `activeItem`
    in our `mainPanel` component. This will control which item is displayed when our
    application starts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们还在`mainPanel`组件的`activeItem`初始配置选项中留下了空位。这将控制我们的应用程序启动时显示哪个项。
- en: If you refresh the page, you should be able to click on the buttons and see
    each of our layouts, including the new complex layout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新页面，你应该能够点击按钮并看到我们的各种布局，包括新的复杂布局。
- en: '![Adding complexity](img/0748OS_04_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![增加复杂性](img/0748OS_04_04.jpg)'
- en: As you can see from this example, our `vbox` layout splits the window into three
    rows. The `hbox` layout, in the second row, splits it into three columns. Using
    these types of nested layouts makes it pretty easy to create traditional layouts,
    such as those used in e-mails or social networking applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，您可以看到我们的`vbox`布局将窗口分为三行。第二行的`hbox`布局将其分为三列。使用这些嵌套布局类型可以非常容易地创建传统布局，例如电子邮件或社交网络应用程序中使用的布局。
- en: '![Adding complexity](img/0748OS_04_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![增加复杂性](img/0748OS_04_05.jpg)'
- en: 'In this example, we have a typical layout for an e-mail application. This layout
    can be conceptually broken down into the following pieces:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个典型电子邮件应用程序的布局。这个布局可以从概念上分解为以下几个部分：
- en: An application container with a **Toolbar** menu and a single container called
    **Main** with a fit layout.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有**工具栏**菜单的应用程序容器和一个称为**主**的单个容器，具有适合布局。
- en: The **Main** container will have an `hbox` layout and two child containers called
    **Left** and **Right**.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主**容器将有一个`hbox`布局和两个子容器，分别称为**左侧**和**右侧**。'
- en: The **Left** container will have a `flex` value of `1` and a `vbox` layout.
    It will have two child containers called **Mailboxes** (with a `flex` of `3`)
    and **Activity** (with a `flex` of `1`).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左侧**容器将有一个`flex`值为`1`和一个`vbox`布局。它将有两个子容器，分别称为**邮箱**（具有`flex`为`3`）和**活动**（具有`flex`为`1`）。'
- en: The **Right** container will have a `flex` of `3` and a `vbox` layout. It will
    also have two child containers called **Messages** (with a `flex` of `1`) and
    **Message** (with a `flex` of `2`).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右侧**容器将有一个`flex`值为`3`和一个`vbox`布局。它还将有两个子容器，分别称为**消息**（具有`flex`为`1`）和**消息**（具有`flex`为`2`）。'
- en: Building container layouts such as these is a good practice. To see the example
    code for this container layout, take a look at the `TouchStart2b.js` file in the
    code bundle. It's also a good idea to create some base layouts such as these to
    use as templates for getting a jumpstart on building your future applications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此类容器布局是一种良好的实践。要查看此容器布局的示例代码，请查看代码包中的`TouchStart2b.js`文件。创建这些基本布局作为模板以快速启动构建您未来的应用程序也是一个好主意。
- en: Now that we have a better understanding of layouts, let's take a look at some
    of the components we can use inside the layouts.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更好地了解了布局，让我们来看看我们可以在布局中使用的某些组件。
- en: The TabPanel and Carousel components
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签面板和轮播组件
- en: In our last application, we used buttons and a `card` layout to create an application
    that switched between different child items. While it is often desirable for your
    application to do this programmatically (with your own buttons and code), you
    can also choose to have Sencha Touch set this up automatically, using a `TabPanel`
    or `Carousel`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后一个应用程序中，我们使用按钮和`card`布局创建了一个可以在不同的子项之间切换的应用程序。虽然应用程序经常需要以这种方式（使用您自己的按钮和代码）进行编程，但您也可以选择让Sencha
    Touch自动设置此操作，使用`TabPanel`或`Carousel`。
- en: Creating a TabPanel component
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建标签面板组件
- en: A `TabPanel` component is useful when you have a number of views the user needs
    to switch between, such as contacts, tasks, and settings. The `TabPanel` component
    auto-generates the navigation for the layout, which makes it very useful as the
    main container for an application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要让用户在多个视图之间切换时，`TabPanel`组件非常有用，例如联系人、任务和设置。`TabPanel`组件自动生成布局的导航，这使其成为应用程序主要容器的非常有用功能。
- en: 'One of our early example applications in [Chapter 2](ch02.html "Chapter 2. Creating
    a Simple Application"), *Creating a Simple Application*, used a simple `TabPanel`
    to form the basis of our application. The following is a similar code example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们[第2章](ch02.html "第2章. 创建一个简单应用程序")的早期示例应用程序中，*创建一个简单应用程序*，使用了一个简单的`TabPanel`来形成我们应用程序的基础。以下是一个类似的代码示例：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, `Ext.tab.Panel` automatically generates a card layout; you don't
    have to declare a layout. You will probably want to declare a `tabBarPosition`
    value for the component. This is where your tabs will automatically appear; the
    default is the top of the screen.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`Ext.tab.Panel`会自动生成一个卡片布局；您不需要声明一个布局。您可能希望为组件声明一个`tabBarPosition`值。这是您的标签将自动出现的地方；默认情况下在屏幕的顶部。
- en: This will generate a large square button for each child item in the `items`
    list. The button will also use the `iconCls` value to assign an icon to the button.
    The `title` configuration is used to name the button.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`items`列表中的每个子项生成一个大的正方形按钮。按钮还将使用`iconCls`值分配一个图标给按钮。`title`配置用于给按钮命名。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: See the previous chapter for more information of the available icons and styling
    for the tab panel. It should also be noted that these icons are only used when
    the `tabBarPosition` value is set to `bottom`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用的图标和样式信息，请参阅上一章关于`tab panel`的更多信息。还应注意的是，这些图标只在`tabBarPosition`值设置为`bottom`时使用。
- en: If you set the `tabBarPosition` value to the top (or leave it blank), it makes
    the buttons small and round. It also eliminates the icons, even if you declare
    a value for `iconCls`, in your child items.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`tabBarPosition`值设置为顶部（或者留空），它会使按钮变小且变圆。它还会消除图标，即使你在子项目中声明了`iconCls`值。
- en: '![Creating a TabPanel component](img/0748OS_04_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个TabPanel组件](img/0748OS_04_06.jpg)'
- en: Creating a Carousel component
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Carousel组件
- en: The `Carousel` component is similar to `tabpanel`, but the navigation it generates
    is more appropriate for things such as slide shows. It probably would not work
    as well as a main interface for your application, but it does work well as a way
    to display multiple items in a single swipeable container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Carousel`组件与`tabpanel`类似，但它生成的导航更适合于幻灯片展示等事物。它可能不会像应用程序的主界面那样出色，但它确实作为在一个可滑动的容器中显示多个项目的方式表现良好。'
- en: 'Similar to `tabpanel`, `Carousel` gathers its child items and automatically
    arranges them in a `card` layout. In fact, we can actually make just some simple
    modifications to our previous code to make it into a `Carousel` component:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与`tabpanel`类似，`Carousel`收集其子项目，并自动将它们安排在一个`card`布局中。实际上，我们实际上可以对我们之前的代码进行一些简单的修改，使其成为一个`Carousel`组件：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing we did was use `Ext.create` to make a new `Ext.carousel.Carousel`
    class instead of a new `Ext.tab.Panel` class. We also added a configuration for
    `direction`, which can be either `horizontal` (scrolling from left to right) or
    `vertical` (scrolling up or down).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`Ext.create`创建了一个新的`Ext.carousel.Carousel`类，而不是一个新的`Ext.tab.Panel`类。我们还添加了一个`direction`配置，可以是`horizontal`（从左到右滚动）或`vertical`（向上或向下滚动）。
- en: We removed the docked toolbar, because, as we will see, `Carousel` doesn't use
    one. We also removed the icon's class and the title from each of our child items
    for the same reason. Finally, we removed the `xtype` configuration, as the `Carousel`
    component automatically creates an `Ext.Container` class for each of its items.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了停靠工具栏，因为正如我们将看到的，`Carousel`不需要它。我们还将每个子项目的图标类和标题移除，原因相同。最后，我们移除了`xtype`配置，因为`Carousel`组件会为每个子项目自动创建一个`Ext.Container`类。
- en: '![Creating a Carousel component](img/0748OS_04_07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个Carousel组件](img/0748OS_04_07.jpg)'
- en: 'Unlike `tabpanel`, `carousel` has no buttons, only a series of dots at the
    bottom, with one dot for each child item. While it is possible to navigate using
    the dots, the `carousel` component automatically sets itself up to respond to
    a swipe on a touch screen. You can duplicate this gesture in the browser by clicking
    and holding the pointer with the mouse, while moving it horizontally. If you declare
    a `direction: vertical` configuration in your `carousel`, you can swipe vertically
    to move between the child items.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '与`tabpanel`不同，`carousel`没有按钮，只在底部有一系列圆点，每个子项目都有一个圆点。虽然使用圆点进行导航是可能的，但`carousel`组件会自动设置以响应触摸屏上的滑动。你可以在浏览器中通过点击并按住鼠标指针，同时水平移动它来复制这个手势。如果你在`carousel`中声明了一个`direction:
    vertical`配置，你还可以垂直滑动以在子项目之间移动。'
- en: Similar to the card layout in our example at the beginning of the chapter, both
    the `tabpanel` and `carousel` components understand the `activeItem` configuration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与章节开头我们的示例中的卡片布局类似，`tabpanel`和`carousel`组件都理解`activeItem`配置。
- en: This lets you set which item appears when the application first loads. Additionally,
    they all understand the `setActiveItem()` method that allows you to change the
    selected child item after the application loads.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你可以设置应用程序首次加载时显示哪个项目。此外，它们都理解`setActiveItem()`方法，该方法允许你在应用程序加载后更改选中的子项目。
- en: The `Carousel` component also has methods for `next()` and `previous()`, which
    allow you to step through the items in order.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Carousel`组件还有`next()`和`previous()`方法，允许你按顺序遍历项目。'
- en: It should also be noted that as `tabpanel` and `carousel` both inherit from
    `Ext.Container`, they also understand any methods and configurations that containers
    understand.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，由于`tabpanel`和`carousel`都继承自`Ext.Container`，它们也理解容器理解的所有方法和配置。
- en: 'Along with containers, `tabpanel` and `carousel` will serve as the main starting
    point for most of your applications. However, there is another type of container
    you will likely want to use at some point: the `FormPanel` component.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器一样，`tabpanel`和`carousel`将是大多数应用程序的主要起点。然而，在某个时候，你可能还想使用另一种容器：`FormPanel`组件。
- en: Creating a FormPanel component
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建FormPanel组件
- en: The `FormPanel` component is a very specialized version of the `Ext.Container`
    component, and as the name implies, it is designed to handle form elements. Unlike
    panels and containers, you don't need to specify the layout for `formpanel`. It
    automatically uses its own special form layout.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormPanel`组件是`Ext.Container`组件的一个非常特殊的版本，正如名称暗示的那样，它被设计用来处理表单元素。与面板和容器不同，您不需要为`formpanel`指定布局。它自动使用自己的特殊表单布局。'
- en: 'A basic example of creating a `formpanel` component is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`formpanel`组件的基本示例如下：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For this example, we just create the panel and add items for each field in
    the form. Our `xtype` tells the form what type of field to create. We can add
    this to our `carousel` and replace our first container, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是创建了一个面板，并为表单中的每个字段添加了项目。我们的`xtype`告诉表单要创建什么类型的字段。我们可以将此添加到我们的`carousel`中，替换我们的第一个容器，如下所示：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Creating a FormPanel component](img/0748OS_04_08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![创建FormPanel组件](img/0748OS_04_08.jpg)'
- en: 'Anyone who has worked with forms in HTML should be familiar with all of the
    standard field types, so the following `xtype` attribute names will make sense
    to anyone who is used to standard HTML forms:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾经在HTML中处理表单的人都应该熟悉所有标准的字段类型，因此熟悉标准HTML表单的人都会理解以下的`xtype`属性名称：
- en: '`checkboxfield`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkboxfield`'
- en: '`fieldset`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fieldset`'
- en: '`hiddenfield`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiddenfield`'
- en: '`passwordfield`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`passwordfield`'
- en: '`radiofield`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radiofield`'
- en: '`selectfield`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectfield`'
- en: '`textfield`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textfield`'
- en: '`textareafield`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textareafield`'
- en: 'These field types all match their HTML cousins for the most part. Sencha Touch
    also offers a few specialized text fields that can assist with validating the
    user''s input:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段类型在很大程度上与它们的HTML同类相匹配。Sencha Touch还提供了一些特殊的文本字段，可以帮助验证用户输入：
- en: '`emailfield`: This accepts only a valid e-mail address, and on iOS devices,
    it will pull up an alternate e-mail address and URL-friendly keyboard'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emailfield`：此字段只接受有效的电子邮件地址，在iOS设备上，它会弹出另一个电子邮件地址和URL友好型键盘'
- en: '`numberfield`: This accepts only numbers'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numberfield`：此字段只接受数字'
- en: '`urlfield`: This accepts only a valid web URL, and also brings up the special
    keyboard'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urlfield`：此字段只接受有效的网络URL，并且还会弹出特殊键盘'
- en: These special fields will only allow the submit operation if the input is valid.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊字段只有在输入有效时才会允许提交操作。
- en: All of these basic form fields inherit properties from the main container class,
    so they have all of the standard `height`, `width`, `cls`, `style`, and other
    container configuration options.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些基本表单字段都继承自主容器类，因此它们具有所有标准的`height`、`width`、`cls`、`style`和其他容器配置选项。
- en: 'They also have a few field-specific options:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还有一些字段特定的选项：
- en: '`label`: This is a text label to use with the field'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这是与字段一起使用的文本标签'
- en: '`labelAlign`: This is where the label appears; this can be top or left, and
    defaults to left'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labelAlign`：这是标签出现的位置；可以是顶部或左侧，默认为左侧'
- en: '`labelWidth`: This tells us how wide the label should be'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labelWidth`：这告诉我们标签应该有多宽'
- en: '`name`: This corresponds to the HTML name attribute, which is how the value
    of the field will be submitted'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这对应于HTML的name属性，这是字段值提交的方式'
- en: '`maxLength`: This tells us how many characters can be used in the field'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxLength`：这告诉我们字段中可以使用多少个字符'
- en: '`required`: This tells us if the field is required in order for the form to
    be submitted'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`：这告诉我们字段是否为必须的，以便表单能够提交'
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Form field placement**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**表单字段位置**'
- en: While `FormPanel` is typically the container you will use while displaying form
    elements, it has the advantage of understanding the `submit()` method that will
    post the form values via an AJAX request or `POST`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`FormPanel`通常是在显示表单元素时使用的容器，但它理解`submit()`方法，该方法将通过AJAX请求或`POST`提交表单值。
- en: If you include a form field in something that is not a `FormPanel` component,
    you will need to get and set the values for the field using your own custom JavaScript
    method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在不是`FormPanel`组件的东西中包含一个表单字段，您将需要使用您自己的自定义JavaScript方法来获取和设置字段的值。
- en: In addition to the standard HTML fields, there are a few specialty fields available
    in Sencha Touch. These include the `DatePicker`, `slider`, `spinner`, and `toggle`
    fields.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的HTML字段外，Sencha Touch中还提供了一些特殊字段，包括`DatePicker`、`slider`、`spinner`和`toggle`字段。
- en: Adding a DatePicker component
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加日期选择器组件
- en: The `datepickerfield` component (is this correct?) places a clickable field
    in the form with a small triangle on the far-right side.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`datepickerfield`组件（这个名称正确吗？）在表单中放置一个可点击的字段，字段右侧有一个小三角形。'
- en: 'You can add a date picker to our form by adding the following code after the
    `emailfield` item:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`emailfield`项之后添加以下代码来向我们的表单中添加一个日期选择器：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the user clicks on the field, a `DatePicker` component will appear, allowing
    the user to select a date by rotating the month, day, and year wheels, or by swiping
    up or down.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击字段时，将出现一个`DatePicker`组件，用户可以通过旋转月份、日期和年份轮盘，或通过向上或向下滑动来选择日期。
- en: '![Adding a DatePicker component](img/0748OS_04_09.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![添加日期选择器组件](img/0748OS_04_09.jpg)'
- en: 'The `datepickerfield` also has the option `configs` for the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`datepickerfield`还具有`configs`选项，如下所示：'
- en: '`yearFrom`: The start year for the date picker.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yearFrom`：日期选择器的开始年份。'
- en: '`yearTo`: The end year for the date picker.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yearTo`：日期选择器的结束年份。'
- en: '`slotOrder`: This uses an array of strings to set the slot order. It defaults
    to `[''month'', ''day'', ''year'']`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slotOrder`：使用字符串数组来设置插槽顺序。默认值为`[''month'', ''day'', ''year'']`。'
- en: Adding sliders, spinners, and toggles
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加滑块、微调器和切换按钮
- en: Sliders allow for the selection of a single value from a specified numerical
    range. The `sliderfield` value displays a bar with an indicator that can be slid
    horizontally to select a value. This can be useful for setting volume, color values,
    and other ranged options.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块允许从指定的数值范围内选择一个值。`sliderfield`值显示一个带有指示器的条，可以通过水平滑动来选择值。这可以用于设置音量、颜色值和其他范围选项。
- en: Like the slider, a spinner allows for the selection of a single value from a
    specified numerical range. The `spinnerfield` value displays a form field with
    a numerical value with **+** and **-** buttons on either side of the field.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与滑块类似，微调器允许从指定的数值范围内选择一个值。`spinnerfield`值显示一个带有数字值和**+**和**-**按钮的表单字段。
- en: A toggle allows for a simple selection between one and zero (on and off) and
    displays a toggle-style button on the form.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 切换按钮允许在1和0之间进行简单选择（开和关），并在表单上显示一个切换风格的按钮。
- en: 'Add the following new components to the end of our list of items:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下组件列表的末尾添加以下新组件：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Adding sliders, spinners, and toggles](img/0748OS_04_10.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![添加滑块、微调器和切换按钮](img/0748OS_04_10.jpg)'
- en: Our `sliderfield` and `spinnerfield` have configuration options for `minValue`
    and `maxValue`. We also added an `incrementValue` attribute to `spinnerfield`
    that will cause it to move in increments of `2` whenever the **+** or **-** button
    is clicked.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sliderfield`和`spinnerfield`具有`minValue`和`maxValue`配置选项。我们还向`spinnerfield`添加了一个`incrementValue`属性，当点击**+**或**-**按钮时，它将按`2`的增量移动。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will cover sending and receiving data with forms later in [Chapter 6](ch06.html
    "Chapter 6. Getting the Data In"), Getting the Data In.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](ch06.html "第6章：获取数据")中介绍表单的发送和接收数据，获取数据。
- en: The MessageBox and Sheet components
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息框和表单组件
- en: At some point, your application will probably need to give feedback to the user,
    ask the user a question, or alert the user to an event. This is where the `MessageBox`
    and `Sheet` components come into play.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，您的应用程序可能需要向用户反馈、询问用户问题或提醒用户事件。这就是`MessageBox`和`Sheet`组件发挥作用的地方。
- en: Creating a MessageBox component
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建消息框组件
- en: 'The `MessageBox` component creates a window on the page, and can be used to
    display alerts, gather information, or present options to the user. `MessageBox`
    can be called in three different ways:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBox`组件在页面上创建一个窗口，可用于显示警告、收集信息或向用户展示选项。`MessageBox`可以通过三种不同的方式调用：'
- en: '`Ext.Msg.alert` takes a title, some message text, and an optional callback
    function to call when the **OK** button on the alert is clicked.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext.Msg.alert`接受一个标题、一些消息文本，以及一个可选的回调函数，当点击警告框的**确定**按钮时调用。'
- en: '`Ext.Msg.prompt` takes a title, some message text, and a callback function
    to call when the **OK** button is pressed. The `prompt` command creates a text
    field and adds it to the window automatically. The function, in this case, is
    passed the text of the field for processing.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext.Msg.prompt`带有标题、一些消息文本和一个当按下**OK**按钮时调用的回调函数。该`prompt`命令创建一个文本字段并自动添加到窗口中。在此例中，函数接收字段的文本进行处理。'
- en: '`Ext.Msg.confirm` takes a title, some message text, and a callback function
    to call when either one of the buttons is pressed.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext.Msg.confirm`带有标题、一些消息文本和一个当任一按钮被按下时调用的回调函数。'
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The callback function**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调函数**'
- en: A callback function is a function that gets called automatically in response
    to a particular action taken by the user or the code. This is basically the code's
    way of saying "When you are finished with this, call me back and tell me what
    you did". This callback allows the programmer to make additional decisions based
    on what happened in the function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数是一个在用户或代码采取特定行动时自动调用的函数。这是程序员让代码说“当你完成这个，回调我并告诉我你做了什么”的基本方式。这个回调允许程序员根据函数中发生的事情做出额外的决定。
- en: 'Let''s try a few examples, starting with a simple message box:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些例子，从一个简单的消息框开始：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code sets up a simple panel with a toolbar and a single button. The button
    has a handler that uses `Ext.Msg.alert()` to show our message box.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了一个带有工具栏和单个按钮的简单面板。按钮有一个处理程序，使用`Ext.Msg.alert()`来显示我们的消息框。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Escaping quotes**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**转义引号**'
- en: In our previous example, we use the string `Don\'t Panic` as the title for our
    message box. The `\` tells JavaScript that our second single quote is part of
    the string and not the end of the string. You can see in the example that the
    `\` disappears in our message box.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的上一个示例中，我们使用字符串`Don\'t Panic`作为消息框的标题。`\`告诉JavaScript我们的第二个单引号是字符串的一部分，而不是字符串的结束。正如在示例中看到的那样，`\`在我们的消息框中消失了。
- en: '![Creating a MessageBox component](img/0748OS_04_11.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个MessageBox组件](img/0748OS_04_11.jpg)'
- en: 'Now, let''s add a second button to our items in our `toolbar` component for
    a `Ext.Msg.prompt` style message box:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`toolbar`组件中的`items`中添加一个第二个按钮，以`Ext.Msg.prompt`样式的消息框：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This message box is a bit more complex. We create our `Ext.Msg.prompt` class
    with a title, a message, and a function. The prompt will create our text field
    automatically, but we need to use the function to determine what to do with the
    text that the user types in the field.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息框有点更复杂。我们创建了一个带有标题、信息和函数的`Ext.Msg.prompt`类。提示将自动创建我们的文本字段，但我们需要使用函数来确定用户在字段中输入的文本要做什么。
- en: The function is passed a value for the button and a value for the text. Our
    function grabs the text and creates a new alert to respond, along with the name
    the user typed into the field.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接收按钮的值和文本的值。我们的函数抓取文本并创建一个新的警告框来响应，还包括用户在字段中输入的名称。
- en: '![Creating a MessageBox component](img/0748OS_04_12.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个MessageBox组件](img/0748OS_04_12.jpg)'
- en: The `Ext.Msg.confirm` class of `MessageBox` is used for decisions the user needs
    to make, or confirmation of a particular action the system is going to take.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBox`的`Ext.Msg.confirm`类用于用户需要做出决定，或确认系统将要采取的特定行动。'
- en: 'Let''s add the following component to our list of `items` in the `toolbar`
    component:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们下面的组件添加到`toolbar`组件的`items`列表中：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similar to the prompt function of the `Ext.Msg` component, the confirm version
    takes a title, a message, and a callback function. The callback function is passed
    the button that the user pressed (as the value `btn`), which can then be used
    to determine what steps the system should take next.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Ext.Msg`组件的提示函数类似，确认版本也带有标题、信息和回调函数。回调函数接收用户按下的按钮（作为值`btn`），然后可以用来确定系统接下来应该采取哪些步骤。
- en: In this case, we just pop up an alert to display the choice the user has made.
    You can also use an `if...then` statement to take different actions depending
    on which button is clicked.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是弹出一个警告框来显示用户所做的选择。你也可以使用`if...then`语句来根据点击哪个按钮采取不同的行动。
- en: '![Creating a MessageBox component](img/0748OS_04_13.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个MessageBox组件](img/0748OS_04_13.jpg)'
- en: Creating a Sheet component
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Sheet组件
- en: The `Sheet` component is similar to the `Ext.Msg` component, in that it is typically
    used to pop up new information or options on the screen. It also presents this
    new information by appearing over the top of the existing screen. As with `MessageBox`,
    no further actions can be taken until `Sheet` is closed or responded to in some
    fashion.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sheet`组件与`Ext.Msg`组件类似，通常用于在屏幕上弹出新的信息或选项。它也通过出现在现有屏幕之上来展示这些新信息。与`MessageBox`一样，在`Sheet`关闭或以某种方式响应之前，无法进行进一步的操作。'
- en: 'Let''s add another button to our list of items in the `items` section of our
    `toolbar` component. This button will pop up a new `Sheet` component:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`toolbar`组件的`items`部分添加另一个按钮。这个按钮将弹出一个新的`Sheet`组件：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are a lot of new things here, but some should seem familiar. Our button
    starts with the `text` value for the button to be displayed and then creates a
    `handler` value that tells the button what to do when tapped.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新东西，但有些应该看起来很熟悉。我们的按钮从按钮要显示的`text`值开始，然后创建了一个`handler`值，告诉按钮在点击时应该做什么。
- en: We then create a new `Ext.Sheet` class. As `Sheet` inherits from the panel,
    we have familiar configuration options, such as `height` and `layout`, but we
    also have a few new options. The `stretchX` and `stretchY` configurations will
    cause the `Sheet` component to expand to the full width (`stretchX`) or height
    (`stretchY`) of the screen.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个新的`Ext.Sheet`类。由于`Sheet`继承自面板，我们有一些熟悉的配置选项，如`height`和`layout`，但我们还有一些新的选项。`stretchX`和`stretchY`配置将导致`Sheet`组件扩展到屏幕的整个宽度（`stretchX`）或高度（`stretchY`）。
- en: The values for `enter` and `exit` control how the `Sheet` component will slide
    into place on the screen. You can use `top`, `bottom`, `left`, and `right`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`enter`和`exit`的值控制了`Sheet`组件如何在屏幕上滑动到位。你可以使用`top`、`bottom`、`left`和`right`。'
- en: 'Our sheet uses a `vbox` layout with two items, a `container` object for our
    text and a `button` object to hide the `Sheet` component when the user has finished
    reading it. The `button` component itself contains an interesting bit of code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单使用`vbox`布局，包含两个项目，一个用于我们的文本的`container`对象和一个用于用户阅读完毕后隐藏`Sheet`组件的`button`对象。`button`组件本身包含了一段有趣的代码：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we refer to the `this` keyword, we are referring to the `button` object,
    as the function occurs inside the `button` itself. However, we really need to
    get to the `Sheet` that the button is contained by, in order to close it when
    the button is clicked. In order to do this, we use a clever little method called
    `up`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到`this`关键字时，我们是指`button`对象，因为函数发生在`button`本身内部。然而，我们实际上需要到达包含按钮的`Sheet`，以便在按钮被点击时关闭它。为了做到这一点，我们使用了一个巧妙的小方法，叫做`up`。
- en: The `up` method will basically crawl upwards through the structure of the code,
    looking for the requested item. In this case, we are searching by `xtype` and
    we have requested the first sheet encountered by the search. We can then hide
    the sheet with the `hide()` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`up`方法基本上会向上遍历代码结构，寻找所需的项。在这种情况下，我们通过`xtype`进行搜索，并请求搜索中遇到的第一个表单。然后我们可以使用`hide()`方法隐藏表单。'
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Ext.ComponentQuery**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ext.ComponentQuery**'
- en: 'When you want to get one component, and you''ve given it an ID, you can use
    `Ext.getCmp()`, as we discussed earlier. If, instead, you want to get multiple
    components, or one component based on where it is in relation to another component,
    you can use `query()`, `up()`, and `down()`. To hide a toolbar that''s inside
    a panel, you can use the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要获取一个组件，并且已经给它指定了一个ID，你可以使用`Ext.getCmp()`，正如我们之前讨论的那样。如果你想要获取多个组件，或者根据它相对于另一个组件的位置来获取一个组件，你可以使用`query()`、`up()`和`down()`。要隐藏一个位于面板内的工具栏，你可以使用以下代码：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Additionally, to get all toolbars in your application, you could use the following
    command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要获取您应用程序中所有的工具栏，您可以使用以下命令：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once we hide the `Sheet` component, we still have a bit of a problem. The `Sheet`
    component is now hidden, but it still exists in the page. If we go back and click
    on the button again, without destroying the `Sheet`, we will just keep creating
    more and more new sheets. That means more and more memory, which also means an
    eventual death spiral for your application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们隐藏了`Sheet`组件，我们仍然有一个问题。现在`Sheet`组件是隐藏的，但它仍然存在于页面中。如果我们返回并再次点击按钮，而不销毁`Sheet`，我们就会不断创建越来越多的新的表单。这意味着越来越多的内存使用，这也意味着你的应用程序最终会走向死亡螺旋。
- en: 'What we need to do is make sure we clean up after ourselves, so that the sheets
    don''t pile up. This brings us to the last part of our code and the `listeners`
    configuration at the end:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是确保我们清理好自己的东西，这样表格就不会堆积起来。这让我们来到了我们代码的最后部分和最后的`listeners`配置：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A listener listens for a particular event, in this case, the `hide` event. When
    the `hide` event occurs, the listener then runs the additional code listed in
    the `fn` configuration. In this case, we destroy the `Sheet` component using `this.destroy();`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器监听特定事件，在这个例子中，是`hide`事件。当`hide`事件发生时，监听器然后运行`fn`配置中列出的附加代码。在这个例子中，我们使用`this.destroy();`来销毁`Sheet`组件。
- en: In the next chapter, we will cover listeners and events in detail.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将详细介绍监听器和事件。
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A word about the this variable**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于this变量的一点说明**'
- en: When we use the variable `this` in our programs, it always refers to the current
    item. In the preceding case, we used this in two separate places, and it referred
    to two separate objects. In our initial usage, we were inside the configuration
    options for the button, and so this referred to the button. When we later used
    this as part of our listener, we were inside the configuration for the sheet,
    and this referred to the sheet.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在程序中使用变量`this`时，它总是指的是当前项目。在前面的例子中，我们在两个不同的地方使用了`this`，它指的是两个不同的对象。在我们最初的用法中，我们在按钮的配置选项中，所以`this`指的是按钮。当我们后来将`this`作为监听器的一部分时，我们在表格的配置中，所以`this`指的是表格。
- en: If you find yourself getting confused, it can be very helpful to use `console.log(this);`
    to make sure you are addressing the correct component.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己感到困惑，使用`console.log(this);`可以非常有帮助，以确保您正在 addressing正确的组件。
- en: You should now be able to click on the **Sheet** button and view our new sheet.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够点击**表格**按钮并查看我们新的表格了。
- en: '![Creating a Sheet component](img/0748OS_04_14.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个表格组件](img/0748OS_04_14.jpg)'
- en: Creating an ActionSheet component
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建行动表格组件
- en: '`ActionSheet` is a variation of the standard sheet designed to display a series
    of buttons. This is a good option when you only need a quick decision from the
    user, with obvious choices that don''t require a lot of explanation. For example,
    a delete confirmation screen would be a good use for an action sheet.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionSheet`是标准表格的一种变体，设计用于显示一系列按钮。当您只需要用户做出快速决策，有明显的选择且不需要过多解释时，这是一个很好的选择。例如，删除确认屏幕就是行动表格的一个很好的用途。'
- en: 'Let''s add a new button to our layout that will pull up an `ActionSheet` component
    for a delete confirmation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的布局中添加一个新的按钮，用于弹出一个用于删除确认的`ActionSheet`组件：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `ActionSheet` object is created in much the same fashion as our previous
    sheet example. However, the action sheet assumes that all of its items are buttons,
    unless you specify a different `xtype` value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionSheet`对象以与我们的上一个表格示例非常相似的方式创建。然而，行动表格假设其所有项目都是按钮，除非您指定了不同的`xtype`值。'
- en: 'Our example has three simple buttons: **Delete**, **Save**, and **Cancel**.
    The **Cancel** button will hide the `ActionSheet` component, and the other two
    buttons are just for show.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子有三个简单的按钮：**删除**、**保存**和**取消**。**取消**按钮将隐藏`ActionSheet`组件，其他两个按钮只是装饰。
- en: As with our previous example, we also want to destroy the `ActionSheet` component
    when we hide it. This prevents copies of the `ActionSheet` component from stacking
    up in the background and creating problems.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的上一个示例一样，我们希望在隐藏它时也销毁`ActionSheet`组件。这可以防止`ActionSheet`组件的副本在后台堆积并造成问题。
- en: 'Clicking on the **ActionSheet** button in our application should now display
    the action sheet we created:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 点击我们应用程序中的**行动表格**按钮现在应该会显示我们创建的行动表格：
- en: '![Creating an ActionSheet component](img/0748OS_04_15.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个行动表格组件](img/0748OS_04_15.jpg)'
- en: Creating a Map component
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Map组件
- en: The `Map` component is a very specialized container designed to work with the
    Google Maps API. The container can be used to display most of the information
    that Google Maps display.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`组件是一个非常特殊的容器，旨在与Google Maps API一起使用。该容器可用于显示Google Maps显示的大部分信息。'
- en: We are going to create a very basic example of the `Map` container for this
    section, but we will come back to it in [Chapter 9](ch09.html "Chapter 9. Advanced
    Topics"), *Advanced Topics*, and cover some of the more advanced tricks you can
    use.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个部分创建一个`Map`容器的非常基础的例子，但我们将在此返回[第9章](ch09.html "第9章 高级主题")，*高级主题*，并介绍一些更高级的技巧。
- en: 'For this example, let''s create a new JavaScript file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个例子，让我们创建一个新的JavaScript文件：
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For this example, we are just creating a single `Container` component with
    one item. The item is a map and has the configuration `useCurrentLocation: true`.
    This means that the browser will attempt to use our current location as the center
    of the map''s display. The user is always warned when this happens, and is given
    an option to decline.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，我们只是创建了一个带有单个项目的`Container`组件。这个项目是一个地图，并且配置了`useCurrentLocation: true`。这意味着浏览器将尝试使用我们的当前位置作为地图显示的中心。当这种情况发生时，用户总是会被警告，并且会被提供拒绝的选项。'
- en: 'Before we can see how this works, we need to make one change to our standard
    `index.html` file. Underneath the line where we include our other JavaScript files,
    we need to include a new file from Google:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解这是如何工作的之前，我们需要对我们的标准`index.html`文件进行一项更改。在包含我们其他JavaScript文件的行下面，我们需要包含来自Google的一个新文件：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will include all of the functions needed for us to use the Google Maps
    API.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包括我们使用Google Maps API所需的所有函数。
- en: If you reload the page, you will be asked if you want to allow your current
    location to be used by the application. Once you accept, you should see a new
    map with your current location at the center.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新加载页面，系统会询问您是否允许当前位置被应用程序使用。一旦您接受，您应该会看到一个新的地图，您的当前位置在中心。
- en: '![Creating a Map component](img/0748OS_04_16.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个地图组件](img/0748OS_04_16.jpg)'
- en: You can also use the `map` property and the `mapOptions` configuration option
    to access the rest of the Google Maps functionality. We will explore some of these
    options and go into much greater detail in [Chapter 9](ch09.html "Chapter 9. Advanced
    Topics"), *Advanced Topics*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`map`属性以及`mapOptions`配置选项来访问Google Maps的其他功能。我们将在[第9章](ch09.html "第9章。高级主题")*高级主题*中探索一些这些选项，并且进行更详细的讲解。
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Google Maps API** **documentation**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Maps API** **文档**'
- en: The full Google Maps API documentation can be found at [http://code.google.com/apis/maps/documentation/v3/reference.html](http://code.google.com/apis/maps/documentation/v3/reference.html).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Google Maps API文档可以在[http://code.google.com/apis/maps/documentation/v3/reference.html](http://code.google.com/apis/maps/documentation/v3/reference.html)找到。
- en: Creating lists
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建列表
- en: 'Sencha Touch offers few different kinds of `list` components. Each of these
    `list` components consists of three basic parts:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch提供了几种不同的`list`组件。每个这些`list`组件都由三个基本部分组成：
- en: '**List panel**: This is in charge of gathering the other items as part of its
    configuration options'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表面板**：它负责收集其配置选项中的其他项目。'
- en: '**XTemplate**: This determines how each line in the list is displayed'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XTemplate**：这决定了列表中每一行的显示方式。'
- en: '**Data store**: This contains all of the data that will be used in the list'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：这里包含将在列表中使用的所有数据。'
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should also be noted that a store can (and typically will) have a model associated
    with it to define the data records for the store. However, it is also possible
    to simply define the fields as part of the store, which we will do in this example.
    We will cover models and stores later in the chapters related to data in this
    book.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意的是，一个存储区可以（并且通常会）与一个模型相关联，以定义存储区的数据记录。然而，也可以简单地将字段作为存储区的一部分定义，这在接下来的例子中我们会这样做。我们将在本书关于数据的章节中介绍模型和存储区。
- en: 'In one of our first examples, we created a list object similar to this one:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一个例子中，我们创建了一个与这个类似的列表对象：
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We start by creating our application as before. We then created a single container
    with a list item. The list item requires a data store, and the data store requires
    a set of fields or a data model. In this case, we will use a set of fields for
    simplicity.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先像以前一样创建我们的应用程序。然后我们创建了一个带有列表项目的单个容器。列表项目需要一个数据存储，而数据存储需要一组字段或数据模型。在这个例子中，我们将使用一组字段以简化操作。
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code gives us two potential values for each data record we will be using
    in the list: `first` and `last`. It also tells us the `type` for each value; in
    this case, both are `strings`. This lets the data store know how to handle sorting
    the data and lets the XTemplate understand how the data can be used.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为我们每个数据记录提供了两个潜在的值：`first`和`last`。它还告诉我们每个值的`type`；在这个例子中，两个都是`strings`。这使得数据存储知道如何处理数据的排序，并且让XTemplate知道数据如何被使用。
- en: 'In this example, we have set `itemTpl: ''{last}, {first}''`. This `itemTpl`
    value serves as a template or XTemplate in Sencha Touch terms. The XTemplate takes
    the data from each record in the store and tells the list to display each data
    record as: the last name, followed by a comma, and then the first name. We will
    cover the XTemplates in greater detail in [Chapter 7](ch07.html "Chapter 7. Getting
    the Data Out"), *Getting the Data Out*.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，我们设置了`itemTpl: ''{last}, {first}''`。这个`itemTpl`值作为模板或Sencha Touch中的XTemplate。XTemplate从存储中的每个记录中获取数据，并告诉列表显示每个数据记录：姓氏，后面跟着一个逗号，然后是名字。我们将在[第7章](ch07.html
    "Chapter 7. Getting the Data Out")，*获取数据外*中详细介绍XTemplates。'
- en: '![Creating lists](img/0748OS_04_17.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![创建列表](img/0748OS_04_17.jpg)'
- en: 'Note that, right now, our list is not sorted alphabetically. We need to add
    a sorter to the store underneath the configuration option for our model:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前我们的列表没有按字母顺序排序。我们需要在模型的配置选项下方添加一个排序器到存储中：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will sort our list by the value `last` (the person's last name).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按`last`（人的姓氏）值对我们的列表进行排序。
- en: Adding grouped lists
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加分组列表
- en: Grouped lists are also common to a number of applications. Typically, grouping
    is used for lists of people or other alphabetical lists of items. Address books
    or long lists of alphabetical data are great places for grouped lists. A grouped
    list places an `indexBar` component on the screen, allowing the user to jump to
    a specific point in the list.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 分组列表也常见于许多应用程序中。通常，分组用于人员或其他字母顺序的物品列表。电话簿或长字母顺序数据列表是分组列表的好地方。分组列表在屏幕上放置一个`indexBar`组件，允许用户跳转到列表中的特定点。
- en: 'To group our current list, we need to add two configuration settings to our
    `list` component. Add the following code beneath where we declare `xtype: ''list''`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '为了对我们的当前列表进行分组，我们需要向我们的`list`组件添加两个配置设置。在声明`xtype: ''list''`下方添加以下代码：'
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also need to add a function to our store that will get the string used to
    display our alphabetical `indexBar`. Add the following code in place of the `sorters`
    configuration in the `store` component:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向我们的存储添加一个函数，以获取显示我们字母`indexBar`的字符串。在`store`组件的`sorters`配置处替换以下代码：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code uses `record.get('last').substr(0,1)` to get the first letter of the
    last name of our contact. This lets the list know where to scroll to when one
    of the letters on the `indexBar` component is clicked.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用`record.get('last').substr(0,1)`来获取我们联系人的姓氏的第一个字母。这让列表知道当点击`indexBar`组件上的字母时应该滚动到哪里。
- en: '![Adding grouped lists](img/0748OS_04_18.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![添加分组列表](img/0748OS_04_18.jpg)'
- en: Adding nested lists
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加嵌套列表
- en: The `NestedList` component automates the layout and navigation of a nested data
    set. This can be very useful for situations where you have a list of items and
    details for each item in the list. For example, let's assume we have a list of
    offices where each office has a set of departments, and each department is made
    up of a number of people.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`NestedList`组件自动化嵌套数据集的布局和导航。这对于您有一个项目列表和列表中每个项目的详细信息的情况非常有用。例如，假设我们有一个办公室列表，每个办公室都有一组部门，每个部门都由一些人组成。'
- en: We can initially represent this on screen as a list of offices. Clicking on
    an office takes you to a list of departments within that office. Clicking on a
    department takes you to a list of people in that department.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以首先将此显示为办公室列表。点击一个办公室会带你到该办公室内的部门列表。点击一个部门会带你到该部门的人员列表。
- en: 'The first thing we need is a set of data to use with this list:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是一组用于此列表的数据：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is a rather large and ugly-looking array of data, but it can be broken
    down into a few simple pieces:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当庞大且看起来很丑的数据数组，但它可以分解为几个简单的部分：
- en: We have one main item called `Offices`
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为`Offices`的主要项目。
- en: '`Offices` has a list of two items, `Atlanta Office` and `Athens Office`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Offices`有一个包含两个项目的列表，`Atlanta Office`和`Athens Office`。'
- en: The two items each have two departments
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两项各有两个部门。
- en: Each department has two people
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部门有两个人。
- en: Each of the people in this list has a special attribute called `leaf`. The `leaf`
    attribute tells our program that it has reached the end of the nested data. Additionally,
    every item in our list has an attribute called `text`. This `text` attribute is
    part of the `fields` list in our `store`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中的每个人都有一个特殊的属性叫做`leaf`。`leaf`属性告诉我们的程序已经到达嵌套数据的末端。此外，我们列表中的每个项目都有一个名为`text`的属性。这个`text`属性是我们`store`中的`fields`列表的一部分。
- en: 'We can then create our store and add our data to it:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以创建我们的存储并将其数据添加到其中：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For a `NestedList` component, we need to use a `TreeStore` class and set the
    `root` configuration to point to the variable `data` array we defined earlier.
    This will tell the store where to begin looking in the first set of items in our
    data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`NestedList`组件，我们需要使用`TreeStore`类，并将`root`配置指向我们之前定义的`data`数组变量。这将告诉存储器在我们数据的第一组项目中最开始查找的位置。
- en: 'Finally, we need to create our `NestedList`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建我们的`NestedList`：
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We set the `NestedList` component to `fullscreen`, and also set the `title`
    value, tell it what field to display, and finally, we point it to our store so
    it can grab the data we created.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`NestedList`组件设置为`全屏`，同时也设置了`title`值，告诉它要显示哪个字段，最后，我们将其指向我们的存储，以便它可以获取我们创建的数据。
- en: '![Adding nested lists](img/0748OS_04_19.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![添加嵌套列表](img/0748OS_04_19.jpg)'
- en: If you click on the nested list, you will notice that the click actions have
    been added automatically. This is the same for the upper navigation and titles.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击嵌套列表，你会注意到点击动作已经被自动添加。这同样适用于上导航和标题。
- en: The `NestedList` component provides a great starting point for displaying hierarchical
    data quickly and efficiently on a small screen.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`NestedList`组件为在小型屏幕上快速有效地显示层次化数据提供了一个很好的起点。'
- en: Finding more information with the Sencha Docs
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sencha Docs查找更多信息
- en: We have covered quite a bit of information in this chapter, but it's only a
    fraction of the information that is available to you in the Sencha Touch API documentation.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了很多信息，但它只是Sencha Touch API文档中可用信息的一小部分。
- en: '![Finding more information with the Sencha Docs](img/0748OS_04_20.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sencha Docs查找更多信息](img/0748OS_04_20.jpg)'
- en: At first, the API can seem a bit overwhelming, but if you understand the organization,
    you can quickly find the information you need. Here are a couple of tips to get
    you started.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，API可能会让人感到有些不知所措，但如果你理解了其组织结构，你就可以快速找到所需的信息。这里有一些帮你入门的小贴士。
- en: Finding a component
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找组件
- en: 'The left-hand side of the API contains five tabs, which are as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: API的左侧包含五个标签页，内容如下：
- en: The home screen, which contains general marketing information for Sencha Touch
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主屏幕包含Sencha Touch的一般营销信息。
- en: The API Documentation with a list of every available component
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有列表中每个可用组件的API文档。
- en: The **Guides** section, which contains more detailed articles about the various
    components and their uses
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指南**部分，其中包含有关各种组件及其用途的更详细文章。'
- en: The **Videos** section, which has a number of video presentations covering topics
    such as layout and MVC in greater detail
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频**部分，其中包含多个视频演讲，详细介绍布局和MVC等主题。'
- en: The **Examples** section, which contains numerous examples of many of the Sencha
    Touch components and their functionalities
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**部分，其中包含许多Sencha Touch组件及其功能的多项示例。'
- en: '![Finding a component](img/0748OS_04_21.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![查找组件](img/0748OS_04_21.jpg)'
- en: If you click on the API tab, you can browse a list of components. You can also
    use the search field in the upper-right corner of the documentation page to find
    components quickly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击API标签，可以浏览一个组件列表。你还可以在文档页面上方右侧的搜索框中快速查找组件。
- en: As you click on the items in the API list, tabs will open the main part of the
    screen with detailed information about the component.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击API列表中的项目时，标签页将打开屏幕的主要部分，并详细介绍组件的信息。
- en: Understanding the component page
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解组件页面
- en: The information at the top of the individual component page provides a huge
    jump-start in understanding how the component works.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 单个组件页面顶部的信息为理解组件的工作提供了巨大的跳板。
- en: '![Understanding the component page](img/0748OS_04_22.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![理解组件页面](img/0748OS_04_22.jpg)'
- en: A quick scan of the component hierarchy, on the right, will tell you which other
    items the component inherits from. If you understand the base components, such
    as the container and panel, you can quickly use that knowledge to guide you through
    using the new component.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 快速扫描右侧的组件层次结构，会告诉你组件继承了哪些其他项目。如果你理解了基本组件，如容器和面板，你可以迅速利用这些知识来指导你使用新组件。
- en: The title at the top also lists the `xtype` value for the component right next
    to it.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部标题还列出了组件的`xtype`值。
- en: 'Underneath the title, there are a series of menus that include:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题下方，有一系列菜单，包括：
- en: '**Config**: The initial options that are used when the component is created'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Config**：组件创建时使用的初始选项。'
- en: '**Properties**: The information you can gather from the component after it
    is created'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：创建组件后您可以从组件中获取的信息'
- en: '**Methods**: The things the component knows how to do, once it''s created'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：组件创建后知道如何执行的操作'
- en: '**Events**: The things the component pays attention to, once it''s created'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：组件创建后关注的事情'
- en: '**CSS Vars**: A list of any available CSS variables you can use in styling
    the component (only on certain components)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSS变量**：可用于样式化组件（仅在某些组件上）的可用的CSS变量列表'
- en: '**CSS Mixins**: A list of any available mixins for the component (only on certain
    components)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSS混合**：组件可用的混合列表（仅在某些组件上）'
- en: There is also a textbox for filtering the class members, a menu for controlling
    what types of class members appear in the list, and a button for expanding all
    of the items on the page.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个文本框用于过滤类成员，一个菜单用于控制列表中出现的类成员类型，以及一个按钮用于展开页面上的所有项。
- en: Most of the common components include examples at the top of the page. When
    viewed in a WebKit browser (Safari or Chrome), these examples include a **Live
    Preview** / **Code Editor** option that can be toggled back and forth. This will
    display either the component, as the user would see it, or the actual code to
    create the component.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常见组件在页面的顶部都包含示例。当在WebKit浏览器（Safari或Chrome）中查看时，这些示例包括一个**实时预览** / **代码编辑器**选项，可以切换。这将显示用户看到的组件，或者是创建组件的实际代码。
- en: As the name implies, the **Code Editor** option can actually be edited to test
    different configuration options. There is also a **Select Code** option, which
    will let you copy the code and paste it into your own applications.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所暗示的，**代码编辑器**选项实际上可以编辑以测试不同的配置选项。还有一个**选择代码**选项，它将允许你复制代码并将其粘贴到自己的应用程序中。
- en: These bits of information should provide you with a starting point for learning
    any component in the API.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息应该为您学习API中的任何组件提供了一个起点。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started with a look at the base component called `Ext.Component`.
    We also looked at how components are created. We then explored the layout for
    containers in more detail, showing how it affects the child items inside the container.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先查看了一个基本组件，名为`Ext.Component`。我们还研究了组件是如何创建的。然后我们详细探讨了容器的布局，展示了它是如何影响容器内部的子项的。
- en: 'The chapter also described a number of the more common and useful components
    in Sencha Touch, including: Containers, Panels, TabPanel, Carousel, FormPanel,
    FormItem, MessageBox, Sheet, List, and NestedList. We ended the chapter with a
    bit of advice on using the Sencha Touch API.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还描述了Sencha Touch中一些更常见且实用的组件，包括：容器、面板、TabPanel、Carousel、FormPanel、FormItem、MessageBox、Sheet、列表和嵌套列表。我们在章节的最后提供了一些使用Sencha
    Touch API的建议。
- en: In the next chapter, we will cover the use of events in Sencha Touch.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Sencha Touch中事件的使用。
