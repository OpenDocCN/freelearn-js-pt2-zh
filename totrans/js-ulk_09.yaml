- en: Chapter 8. Debugging and Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging is a tricky part of programming. Bugs during development are unavoidable.
    Whatever our experience, we have to spend quite a time on hunting them. It happens.
    By the looks of the code you may not find the bug, there probably must be no problem
    with the application, yet a developer fights for hours until they run into a silly
    reason such as a misprinted property name. Much of this time could be saved by
    making a better use of browser development tools. So we will consider in this
    chapter the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to discover bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the best from a console API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to tune performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hunting bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is about finding and resolving defects that prevent the intended application
    behavior. Here, what is crucial is to find the code causing the problem. What
    do we usually do when we encounter a bug? Let's say, we have a form that is assumed
    to run a validation on a submit event, but it doesn't. First of all, we have a
    number of assumptions to be met. For example, if the reference to the form element
    is valid, if the event and method name were spelled correctly during registering
    a listener, if the object context is not lost in the body of the listener, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some bugs can be discovered automatically such as by validating input and output
    on the entry and exit points of methods (see Design by contract at: [https://en.wikipedia.org/wiki/Design_by_contract](https://en.wikipedia.org/wiki/Design_by_contract)).
    However, we have to spot other bugs manually, and here we can use two options.
    Starting from the point where the code is surely correct step by step to the problem
    point (bottom-up debugging), or on the contrary, stepping back from the break
    point to find the source of the break. Here, browser development tools can come
    in handy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most advanced one is Chrome DevTools. We can open the **Sources** panel
    in it and set breakpoints in the code. The browser stops execution while reaching
    a breakpoint and shows a pane with an actual variable scope and call stack. It
    also provides controls that one can use to *step-through* the code back and forth
    one line at a time. Following screenshot shows debugging with the help of breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hunting bugs](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, this can be tricky to navigate through codebase in DevTools. Fortunately,
    you can set a break point out of the browser directly in the IDE. You just need
    to put the debugger statement on the line where you want the browser to break.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is hard to figure out what's going on with the DOM. We can make
    DevTools to do a break on the DOM events such as node removal, node modification,
    and subtree changes. Just navigate to the HTML element in the **Sources** panel,
    right-click, and choose the **Break on...** option.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, in the **Source** panel there is a tab called **XHR Breakpoints** where
    we can set a list of URLs. The browser will then break when any of the URLs are
    requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find an icon in form of stop sign in the top of **Source** panel
    sidebar. If this button is clicked, DevTools will break on any caught exception
    and bring to you the throw location in the source code. Following screenshot shows
    how to use Pause on Caught Exception tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hunting bugs](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information, see [https://developer.chrome.com/devtools/docs/javascript-debugging](https://developer.chrome.com/devtools/docs/javascript-debugging).
  prefs: []
  type: TYPE_NORMAL
- en: Getting the best from a console API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Despite it being not a part of JavaScript, we all use console API extensively
    to find out what is really happening during an app life cycle. The API, once introduced
    by the Firebug tool, is now available in every major JavaScript agent. Most developers
    just do simple logging using methods such as error, trace, log, and the decorator
    such as info and warn. Well, when we pass any values to `console.log`, they are
    presented to the **JavaScript** **Console** panel. Usually, we pass a string describing
    a case and a list of various objects that we want to inspect. However, did you
    know that we can refer to these objects directly from the string in the manner
    of the PHP `sprintf`? So the string given as the first argument can be a template
    that contains format specifiers for the rest of the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Getting the best from a console API](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The available specifiers are `%s` for strings, `%d` for numbers, `%o` for DOM
    elements, and `%O` for JavaScript objects (the same as `console.dir`). Besides,
    there is a particular specifier that allows us to style the `console.log` report.
    This can be very useful. In practice, the application console receives too many
    log records. It gets hard to make out the desired messages among a hundred similar
    messages. What we can do is categorize the messages and style them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we defined two methods extending `console.log`. One prefixes
    console messages with **USER** on cyan and is intended for user action events.
    The second prepends reports with **EVENT** and is meant to highlight mediator
    events. Following screenshot explains colorized output with console.log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the best from a console API](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another lesser known trick is the use of `console.assert` for assertions in
    code logic. So, we assume that a condition is true and until it is everything
    is fine and we get no messages. But as soon as it fails, we get a record in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Following screenshot shows how to use console assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the best from a console API](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes we need to know how often an event happens. Here we can use the `console.count`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays in the console the specified message and an auto-updating counter
    next to it. Following screenshot shows how to use console.count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the best from a console API](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find out more about working with the console at [https://developer.chrome.com/devtools/docs/console](https://developer.chrome.com/devtools/docs/console).
  prefs: []
  type: TYPE_NORMAL
- en: Tuning performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Performance makes user experience. If it takes too long to load a page or a
    UI to respond, the user is likely to leave the application and never come back.
    It''s especially true with web apps. In [Chapter 3](part0027_split_000.html#PNV62-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 3. DOM Scripting and AJAX"), *DOM Scripting and AJAX*, we compared different
    approaches to manipulate the DOM. In order to find out how fast an approach is,
    we use a performance built-in object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`performance.now()` returns a high resolution timestamp that represents time
    in milliseconds accurate to microseconds. This is designed and widely used for
    benchmarking. However, a `time/timeEnd` console object also provides methods to
    measure time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Following screenshot shows measuring time with console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuning performance](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we need to know what exactly is going on during an operation execution,
    we can request a profile for that period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Following screenshot shows how to use console API for profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuning performance](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, we can mark the exact time of the event in the **Timeline** panel
    of DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Following screenshot shows how to mark events on Timeline during a recording
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuning performance](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When tuning performance, we have to pay particular attention to the response
    time. There are a number of techniques that can be used to improve user experience
    during bootstrap (non-blocking JavaScript and CSS loading, critical CSS, moving
    static files CDN, and others). Well, let's say you decide to load CSS asynchronously
    ([https://www.npmjs.com/package/asynccss](https://www.npmjs.com/package/asynccss))
    and cache into localStorage. But how would you test whether you gained anything
    from this? Fortunately, DevTools has a filmstrip feature. We just need to open
    the **Network** panel, enable **Screenshot capturing** and reload the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'DevTools shows us the progress of the page load frame after frame as the user
    sees the page during the load process. Besides, we can manually set a connection
    speed (throttling) for a test and find out how it affects the filmstrip. Following
    screenshot shows how to getting filmstrip of page loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuning performance](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is an integral part of web development. It can also be a pretty sluggish
    and tedious task. With browser development tools, we can reduce the time spent
    on hunting bugs. We can set breakpoints in a code and move step by step to the
    source of the problem in the same way that the program does. When using Chrome
    DevTools, we can watch for DOM modification events and for specific URL requests.
    When tuning performance, we can measure time with `time/timeEnd` and request a
    process profile with `profile/profileEnd`. Using features such as filmstrip and
    throttling, we can look at the page load on different connections.
  prefs: []
  type: TYPE_NORMAL
- en: We started this book by reviewing JavaScript core features. We've learned how
    to make a code more expressive by means of syntactic sugar, practiced object iteration
    and collection normalization, compared various approaches to declare an object
    including ES6 classes, and found out how to use the *magic methods* of JavaScript.
    Then, we dived into modular programming. We talked about module pattern and modules
    in general and reviewed three main approaches to modularization in JavaScript
    AMD, CommonJS, and ES6 modules. The next topic was about keeping high-performance
    DOM manipulations. We also examined Fetch API. We also considered some of most
    exciting HTML5 APIs such Storage, IndexedDB, workers, SSE, and WebSocket, and
    the technologies under the hood of Web Component. We considered techniques to
    leverage a JavaScript event loop and to build nonblocking applications. We practiced
    with design patterns in JavaScript and covered concern separations. We wrote a
    simple application in three frameworks, Backbone, Angular, and React. We tried
    out Node.js by creating a command-line utility and exposing a web server. We also
    created a demo desktop application with NW.js and its mobile version with PhoneGap.
    At last, we talked about bug hunting.
  prefs: []
  type: TYPE_NORMAL
