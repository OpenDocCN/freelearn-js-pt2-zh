- en: Chapter 9. Advanced Reactivity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now our blog is basically complete, as we can create and edit entries. In this
    chapter, we will make use of Meteor's reactive templates to make our interface
    timestamps update itself. We will build a reactive object that will rerun the
    template helper, which displays the time when the blog entries were created. This
    way, they will always display the correct relative time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rerunning functions manually
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a reactive object using the `Tracker` package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping reactive functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you've jumped right into the chapter and want to follow the examples, download
    the previous chapter's code examples from either the book's web page at [https://www.packtpub.com/books/content/support/17713](https://www.packtpub.com/books/content/support/17713)
    or from the GitHub repository at [https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter8](https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter8).
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These code examples will also contain all the style files, so we don't have
    to worry about adding CSS code along the way.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reactive programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already saw throughout the book, Meteor uses something called **reactivity**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: One problem that a developer has to solve when building a software application
    is the consistency of the data represented in the interface. Most modern applications
    use something called **Model-View-Controller** (**MVC**), where the controller
    of a view makes sure that it always represents the current state of the model.
    The model is mostly a server API or a JSON object in the browser memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common ways of keeping consistent interfaces are as follows (courtesy:
    [http://manual.meteor.com](http://manual.meteor.com)):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Poll and diff**: Periodically (for example, every second), fetch the current
    value of the thing, see whether it''s changed, and if so, perform the update.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**: The thing that can change emits an event when it changes. Another
    part of the program (often called a controller) arranges to listen for this event,
    gets the current value, and performs the update when the event fires.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bindings**: Values are represented by objects that implement some interface,
    such as `BindableValue`. Then, a "bind" method is used to tie two `BindableValues`
    together so that when one value changes, the other is updated automatically. Sometimes,
    as a part of setting up the binding, a transformation function can be specified.
    For example, `Foo` can be bound to `Bar` with the `toUpperCase` transformation
    function.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These patterns are good, but they still need a lot of code to maintain the consistency
    of the data represented.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Another pattern, although not yet as commonly used, is **reactive programming**.
    This pattern is a declarative way of binding data. It means when we use a reactive
    data source such as a `Session` variable or `Mongo.Collection`, we can be sure
    that reactive functions or template helpers that use these will rerun as soon
    as its value changes, always keeping the interface or calculations based on these
    values updated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The Meteor manual gives us an example use case where reactive programming comes
    in handy:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '*Reactive programming is perfect for building user interfaces, because instead
    of attempting to model all interactions in a single piece of cohesive code, the
    programmer can express what should happen upon specific changes. The paradigm
    of responding to a change is simpler to understand than modeling which changes
    affect the state of the program explicitly.*'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For example, suppose that we are writing an HTML5 app with a table of items,
    and the user can click on an item to select it or ctrl-click to select multiple
    items. We might have an <h1> tag and want the contents of the tag to be equal
    to the name of the currently selected item, capitalized, or else "Multiple selection"
    if multiple items are selected. And we might have a set of <tr> tags and want
    the CSS class on each <tr> tag to be "selected" if the items corresponding to
    that row is in the set of selected items, or the empty string otherwise.*'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To make this example happen in the aforementioned patterns, we can quickly
    see how complex it gets compared to reactive programming (courtesy: [http://manual.meteor.com](http://manual.meteor.com)):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: If we use poll and diff, the UI will be unacceptably laggy. After the user clicks,
    the screen won't actually update until the next polling cycle. Also, we have to
    store the old selection set and diff it against the new selection set, which is
    a bit of a hassle.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use events, we have to write some fairly tangled controller code to manually
    map changes to the selection or to the name of the selected item, onto updates
    to the UI. For example, when the selection changes, we have to remember to update
    both the `<h1>` tag and (typically) two affected `<tr>` tags. What's more, when
    the selection changes, we have to automatically register an event handler on the
    newly selected item so that we can remember to update `<h1>`. It is difficult
    to structure clean code and maintain it, especially as the UI is extended and
    redesigned.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use bindings, we will have to use a complex **domain-specific language**
    (**DSL**) to express the complex relationships between the variables. The DSL
    will have to include indirection (bind the contents of `<h1>` not to the name
    of any fixed item, but to the item indicated by the current selection), transformation
    (capitalize the name), and conditionals (if more than one item is selected, show
    a placeholder string).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Meteor's reactive template engine, Blaze, we can simply use the `{{#each}}`
    block helper to iterate over a list of elements and add some conditions for each
    element based on user interaction or on an item's property to add a selected class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: If the user now changes the data or the data coming in from the server changes,
    the interface will update itself to represent the data accordingly, saving us
    a lot of time and avoiding unnecessary complex code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The invalidating cycle
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One key part of understanding the reactive dependencies is the invalidate cycle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: When we use a reactive data source inside a reactive function, such as `Tracker.autorun(function(){…})`,
    the reactive data source itself sees that it is inside a reactive function and
    adds the current function as a dependency to its dependency store.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Then, when the value of the data source changes, it invalidates (reruns) all
    its dependent functions and removes them from its dependency store.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In the rerun of the reactive function, it adds the reactive function back to
    its dependency store so that they will rerun on its next invalidation (value change)
    again.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: This is the key to understand the reactive concept, as we will see in the following
    example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have two `Session` variables set to `false`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Moreover, We have the `Tracker.autorun()` function, which uses both these variables:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can now call `Session.set('second', true)`, but the reactive function will
    not rerun, because it was never called in the first run, as the `first` session
    variable was set to `false`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: If we now call `Session.set(first, true)`, the function will rerun.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if we now set `Session.set('second', false)`, it will rerun as
    well, as in the second rerun, `Session.get('second')` can add this reactive function
    as a dependency.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Because the reactive data sources source will always remove all dependencies
    from its store on every invalidation and add them back in the rerun of the reactive
    function, we can set `Session.set(first, false)` and try to switch it to `Session.set('second',
    true)`. The function will *not* rerun again, as `Session.get('second')` was never
    called in this run!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we understand this, we can make more fine-grained reactivity, keeping
    reactive updates to a minimum. The console output of the explanation looks similar
    to the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![The invalidating cycle](img/00024.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Building a simple reactive object
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw, a **reactive object** is an object that when used inside a reactive
    function, will rerun the function when its value changes. The Meteor's `Session`
    object is one example of a reactive object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a simple reactive object that will rerun our
    `{{formatTime}}` template helper at time intervals so that all the relative times
    are updated correctly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Meteor's reactivity is made possible through the `Tracker` package. This package
    is the core of all reactivity and allows us to track dependencies and rerun these
    whenever we want.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to build a simple reactive object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s add the following code to the `my-meteor-blog/main.js`
    file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will create a variable named `ReactiveTimer` on the client with a new instance
    of `Tracker.Dependency`.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Below the `ReactiveTimer` variable, but still inside the `if(Meteor.isClient)`
    condition, we will add the following code to rerun all dependencies of our `ReactiveTimer`
    object every 10 seconds:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Meteor.setInterval` will run the function every 10 seconds.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Meteor comes with its own implementation of `setInterval` and `setTimeout`.
    Even though they work exactly as their native JavaScript equivalents, Meteor needs
    these to reference the right timeout/interval for a specific user on the server
    side.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Meteor comes with its own implementation of `setInterval` and `setTimeout`.
    Even though they work exactly as their native JavaScript equivalents, Meteor needs
    these to reference the right timeout/interval for a specific user on the server
    side.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Inside the interval, we call `ReactiveTimer.changed()`. This will invalidate
    every dependent function, causing it to rerun.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Rerunning functions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have no dependency created, so let''s do that. Add the following
    code below `Meteor.setInterval`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we now get back to our browser console, we should see **Function re-run**
    every 10 seconds, as our reactive object reruns the function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We can even call `ReactiveTimer.changed()` in our browser console and the function
    will rerun as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: These are good examples, but don't make our timestamps update automatically.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to open up `my-meteor-blog/client/template-helpers.js`
    and add the following line at the top of our `formatTime` helper function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will make every `{{formatTime}}` helper in our app rerun every 10 seconds,
    updating the relative time while it passes. To see this, go to your browser and
    create a new blog entry. If you save the blog entry now and watch the time created
    text, you will see that it changes after a while:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Rerunning functions](img/00025.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Creating an advanced timer object
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example was a simple demonstration of a custom reactive object.
    To make it more useful, it is better to create a separate object that hides the
    `Tracker.Dependency` functions and adds additional functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Meteor's reactivity and dependency tracking allows us to create dependencies
    even when the `depend()` function is called from inside another function. This
    dependency chain allows more complex reactive objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will take our `timer` object and add a `start` and
    `stop` function to it. Additionally, we will also make it possible to choose a
    time interval at which the timer will rerun:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s remove the previous code examples from the `main.js` and `template-helpers.js`
    files, which we added before, and create a new file named `ReactiveTimer.js` inside
    `my-meteor-blog/client` with the following content:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This creates a classic prototype class in JavaScript, which we can instantiate
    using `new ReactiveTimer()`. In its constructor function, we instantiate a `new
    Tracker.Dependency` and attach it to the function.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will create a `start()` function, which will start a self-chosen interval:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the same code as we used before with the difference that we store the
    interval ID in `this._intervalId` so that we can stop it later in our `stop()`
    function. The interval passed to the `start()` function must be in seconds;
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we add the `stop()` function to the class, which will simply clear the
    interval:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we only need a function that creates the dependencies:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our reactive timer is ready!
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to instantiate the `timer` and start it with whatever interval we like,
    add the following code after the `ReactiveTimer` class at the end of the file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At last, we need to go back to our `{{formatTime}}` helper in the `template-helper.js`
    file, and `add` the `time.tick()` function, and every relative time in the interface
    will update as time goes by.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To see the reactive timer in action, run the following code snippet in our
    browser''s console:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We should now see **Timer ticked!** logged every 10 seconds. If we now run `time.stop()`,
    the timer will stop running its dependent functions. If we call `time.start(2)`
    again, we will see Timer ticked! now appearing every two seconds, as we set the
    interval to `2`:![Creating an advanced timer object](img/00026.jpeg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, our `timer` object is now rather flexible, and we can create
    any number of time intervals to be used throughout the app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Reactive computations
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meteor's reactivity and the `Tracker` package is a very powerful feature, as
    it allows event-like behavior to be attached to every function and every template
    helper. This reactivity is what keeps our interface consistent.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Although we only touched the `Tracker` package until now, it has a few more
    properties that we should take a look at.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We already learned how to instantiate a reactive object. We can call `new Tracker.Dependency`,
    which can create and rerun dependencies using `depend()` and `changed()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Stopping reactive functions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are inside a reactive function, we also have access to the current computational
    object, which we can use to stop further reactive behavior.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, we can use our already running `timer` and create the
    following reactive function using `Tracker.autorun()` in our browser''s console:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we create `someInnerFunction()` to show how we can access the current
    computation as well from nested functions. In this inner function, we get the
    computation using `Tracker.currentComputation`, which gives us the current `Tracker.Computation`
    object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We use the `count` variable, we created before the `Tracker.autorun()` function,
    to count up. When we reach 10, we call `Tracker.currentComputation.stop()`, which
    will stop the dependency of the inner and the `Tracker.autorun()` functions, making
    them nonreactive.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: To see the results quicker, we stop and start the `timer` object with an interval
    of two seconds at the end of the example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'If we copy and paste the previous code snippet into our browser''s console
    and run it, we should see **Running for the xx time** appearing 10 times:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Stopping reactive functions](img/00027.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: The current computational object is useful to give us control over reactive
    dependencies from inside the dependent functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Preventing run at start
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Tracker` `.Computation` object also comes with the `firstRun` property,
    which we have used in an earlier chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive functions, for example, when created using `Tracker.autorun()` also
    run when they are parsed by JavaScript for the first time. If we want to prevent
    this, we can simply stop the function before any code is executed when checking
    whether `firstRun` is `true`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don't need to get the current computation here using `Tracker.currentComputation`,
    as `Tracker.autorun()` gets it already as its first argument.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, when we stop a `Tracker.autorun()` function, as described in the following
    code, it will never create the dependency for the session variable, as `Session.get()`
    was never called in the first run:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To make sure that we make the function depending on the `myValue` session variable,
    we need to put it before the `return` statement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Advanced reactive objects
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Tracker` package has a few more advanced properties and functions that
    allow you to control when dependencies are invalidated (`Tracker.flush()` and
    `Tracker.Computation.invalidate()`) and allow you to register additional callbacks
    on it (`Tracker.onInvalidate()`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: These properties allow you to build complex reactive objects, which are out
    of the scope of this book. If you want to get a deeper understanding of the `Tracker`
    package, I recommend that you take a look at the Meteor manual at [http://manual.meteor.com/#tracker](http://manual.meteor.com/#tracker).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build our own custom reactive object. We
    learned about `Tracker.Dependency.depend()` and `Tracker.Dependency.changed()`
    and saw how reactive dependencies have their own computational objects, which
    can be used to stop its reactive behavior and prevent running at start.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'To dig deeper, take a look at the documentation for the `Tracker` package and
    see detailed property descriptions for the `Tracker.Computation` object at the
    following resources:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.meteor.com/tracker](https://www.meteor.com/tracker)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.meteor.com/#/full/tracker](https://docs.meteor.com/#/full/tracker)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.meteor.com/#/full/tracker_computation](https://docs.meteor.com/#/full/tracker_computation)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.meteor.com/#/full/tracker_dependency](https://docs.meteor.com/#/full/tracker_dependency)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find this chapter's code examples at [https://www.packtpub.com/books/content/support/17713](https://www.packtpub.com/books/content/support/17713)
    or on GitHub at [https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter9](https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter9).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的代码示例在[https://www.packtpub.com/books/content/support/17713](https://www.packtpub.com/books/content/support/17713)或者在GitHub上找到[https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter9](https://github.com/frozeman/book-building-single-page-web-apps-with-meteor/tree/chapter9)。
- en: Now that we have finalized our blog, we will take a look at how to deploy our
    app on servers in the next chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的博客，我们将在下一章看看如何将我们的应用程序部署到服务器上。
