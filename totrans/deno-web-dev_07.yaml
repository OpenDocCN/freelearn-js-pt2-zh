- en: '*Chapter 8*: Testing – Unit and Integration'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：测试 - 单元和集成
- en: Code isn't created until the respective tests have been written. Since you're
    reading this chapter, I'll assume we can agree on that statement. However, you
    might wondering, why haven't we written any tests? Fair enough.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在相应测试编写之前是不会创建的。既然您在读这一章，我将假设我们可以同意这个观点。然而，您可能想知道，为什么我们一个测试都没有写呢？合情合理。
- en: We chose not to do this because we believe it would make the content harder
    to absorb. Since we wanted to keep you focused on learning Deno while building
    an application, we decided not to do this. The second reason is that we truly
    wanted a full chapter focused on testing; that is, this one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择不这样做，因为我们相信这会使得内容更难吸收。由于我们想在构建应用程序的同时让您专注于学习Deno，所以我们决定不这样做。第二个原因是，我们真的想要一个完整的章节专注于测试，即这一章。
- en: 'Testing is a very important part of the software life cycle. It can be used
    to save time, to clearly state requirements, or just because you want to feel
    confident in rewriting and refactoring later. Independent of the motivation, one
    thing is certain: you''ll write tests. I also truly believe that testing plays
    a big role in software design. Code that is easy to test is likely easy to maintain.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件生命周期中非常重要的一部分。它可以用来节省时间，明确需求，或者只是因为你想在以后重新编写和重构时感到自信。无论动机如何，有一点是确定的：您将编写测试。我也坚信测试在软件设计中扮演着重要角色。易于测试的代码很可能易于维护。
- en: Since we're great advocates of the importance of testing, we couldn't consider
    this a complete guide to Deno without learning about it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们非常重视测试的重要性，所以在不学习测试的情况下，我们无法认为这是一本关于Deno的完整指南。
- en: In this chapter, we'll write different kinds of tests. We'll start with unit
    tests, which are very valuable tests for the developer and maintenance life cycle.
    Then, we'll move on to integration tests, where we'll run the app and perform
    a few requests on it. We'll finish by using the client we wrote in the previous
    chapter. We'll do all of this while adding tests to the application we previously
    built, going step by step, and making sure the code we previously wrote is working
    properly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写不同类型的测试。我们将从单元测试开始，这对于开发者和维护周期来说是非常有价值的测试。然后，我们将进行集成测试，在其中我们运行应用程序并对其执行几个请求。最后，我们将使用在前一章中编写的客户端。我们将在这个过程中，逐步向应用程序中添加测试，确保我们之前编写的代码正常工作。
- en: This chapter will also demonstrate how some of the architectural decisions we
    made at the beginning of this book will pay off. This will be an introduction
    to how we can write simple mocks and clean, focused tests using Deno and its toolchain.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将展示我们在这本书一开始所做的某些架构决策将得到回报。这将是使用Deno及其工具链编写简单模拟和清晰、专注测试的介绍。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing your first test in Deno
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Deno中编写您的第一个测试
- en: Writing an integration test
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: Testing the web server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试网络服务器
- en: Creating integration tests for the application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序创建集成测试
- en: Testing the API together with the client
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时测试API和客户端
- en: Benchmarking parts of the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应用程序的部分进行基准测试
- en: Let's get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code that will be used in this chapter can be found at [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将使用的代码可以在 [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections)
    找到。
- en: Writing your first test in Deno
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Deno中编写您的第一个测试
- en: Before we start writing our test, it's important to remember a few things. The
    most important of them is, why are we testing?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，记住一些事情是很重要的。其中最重要的原因是，我们为什么要进行测试？
- en: There might be multiple answers to this question, but most of them will gesture
    toward guaranteeing that the code is working. You might also say that you use
    them so that you have flexibility when it comes to refactoring, or that you value
    having short feedback cycles when it comes to implementation – we can agree to
    both of these. Since we didn't write a test before implementing these features,
    the latter doesn't apply too much to us.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可能会有多个答案，但大多数都会指向保证代码在运行。您也可能说，您使用它们以便在重构时具有灵活性，或者您重视在实施时拥有短暂的反馈周期——我们可以同意这两点。由于我们在实现这些功能之前没有编写测试，所以后者对我们来说并不适用。
- en: 'We''ll keep these objectives in mind throughout this chapter. In this section,
    we''ll write our first test. We''ll use the application we wrote in the previous
    chapters and add tests to it. We''ll write two types of tests: integration and
    unit tests.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些目标牢记在整个章节中。在本节中，我们将编写我们的第一个测试。我们将使用在前几章中编写的应用程序并向其添加测试。我们将编写两种类型的测试：集成测试和单元测试。
- en: Integration tests will test how different components of the application interact.
    Unit tests test layers in isolation. If we think of it as a spectrum, unit tests
    are closer to the code, while integration tests are closer to the user. On the
    very end of the user side, there are also end-to-end tests. Those are the tests
    that test the application by emulating the user behavior, which we won't cover
    in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试将测试应用程序不同组件之间的交互。单元测试测试隔离的层次。如果我们把它看作是一个光谱，那么单元测试更接近代码，而集成测试更接近用户。在用户端的尽头，还有端到端测试。这些测试通过模拟用户行为来测试应用程序，我们将在本章不涉及这些内容。
- en: 'Parts of the patterns we used when developing the actual application, such
    as dependency injection and inversion of control, are of great use when it comes
    to testing. Since we developed our code by injecting all its dependencies, now,
    it''s just a matter of mocking those dependencies on tests. Remember: code that
    is easy to test is normally easy to maintain.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用程序开发中使用的模式，如依赖注入和控制反转，在测试时非常有用。由于我们通过注入所有其依赖项来开发代码，现在，在测试中只需模拟这些依赖项即可。记住：易于测试的代码通常也易于维护。
- en: The first thing we'll do is write tests for the business logic. Currently, since
    our API is quite simple, it doesn't have much business logic. Most of it is living
    on `UserController`, since `MuseumController` is very simple. We'll start with
    the latter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是为业务逻辑编写测试。目前，由于我们的 API 相当简单，所以它没有太多的业务逻辑。大部分都生活在`UserController`中，因为`MuseumController`非常简单。我们从后者开始。
- en: 'To write tests in Deno, we''ll need to use the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Deno 中编写测试，我们需要使用以下内容：
- en: The Deno test runner (covered in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deno 测试运行器（在[第 2 章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)，《工具链》中介绍）
- en: The `test` method from the Deno namespace ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test))
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deno 命名空间中的`test`方法（[https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)）
- en: The assertion methods from the Deno standard library ([https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts](mailto:https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts))
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deno 标准库中的断言方法（[https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts](mailto:https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts)）
- en: These are all part of Deno, distributed and maintained by the core team. There
    are many other libraries that can be used in tests that you can find in the community.
    We'll use what's provided by default in Deno as it works just fine and allows
    us to write clear and readable tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是 Deno 的组成部分，由核心团队分发和维护。社区中还有许多其他可以在测试中使用的库。我们将使用 Deno 提供的默认设置，因为它工作得很好，并且允许我们编写清晰易读的测试。
- en: Let's go and learn how we can define a test!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来学习我们如何定义一个测试！
- en: Defining a test
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义测试
- en: Deno provides an API to define tests. This API, `Deno.test` ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)),
    provides two different ways to define a test.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 提供了一个 API 来定义测试。这个 API，`Deno.test`（[https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)），提供了两种不同的方法来定义一个测试。
- en: 'One of them is the one we showed in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*, and consists of calling it with two arguments; that is, the test
    name and a test function. This can be seen in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个是我们在[第 2 章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)，《工具链》中展示的，由两部分组成，即调用它需要两个参数；也就是说，测试名称和测试函数。这可以在以下示例中看到：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The other way we can do this is by calling the same API, this time sending
    an object as an argument. You can send the function and the name of the test,
    plus a few other options, to this object, as you can see in the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过调用相同的 API 来实现，这次将对象作为参数发送。 你可以发送函数和测试名称，还可以发送其他一些选项到这个对象，如你所见在以下示例中：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These flags behaviors are very well-explained in the documentation ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)),
    but here''s a summary for you:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志行为在文档中解释得非常清楚([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)),但这里有一个总结供您参考：
- en: '`only`: Runs only the tests that have this set to `true` and makes the test
    suite fail, so this should only be used as a temporary measure.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`only`：只运行设置为`true`的测试，使测试套件失败，因此这应仅作为临时措施使用。'
- en: '`sanitizeOps`: Makes the test fail if all the operations that started on Deno''s
    core are not successful. This flag is `true` by default.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sanitizeOps`：如果Deno核心启动的所有操作都不成功，则使测试失败。此标志默认为`true`。'
- en: '`sanitizeResources`: Makes the test fail if there are still resources running
    after the test finishes (this can indicate memory leaks). This flag makes sure
    tests have to have a teardown phase where resources are stopped, and is `true`
    by default.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sanitizeResources`：如果测试完成后仍有资源运行（这可能表明内存泄漏），则使测试失败。这个标志确保测试必须有一个清理阶段，在此阶段停止资源，默认值为`true`。'
- en: Now that we know about the APIs, let's go write our first test – a unit test
    for the `MuseumController` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了API，让我们去编写我们的第一个测试——针对`MuseumController`函数的单元测试。
- en: A unit test for MuseumController
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对`MuseumController`的单元测试
- en: In this section, we'll be writing a very simple test that will cover only the
    functionality we wrote in `MuseumController`, and no more.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个非常简单的测试，它将涵盖我们在`MuseumController`中编写的所有功能，不多也不少。
- en: 'It lists all the museums in the application, though it''s currently not doing
    much and is only working as a proxy for `MuseumRepository`. We can create the
    test file and logic for this simple functionality by following these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它列出了应用程序中的所有博物馆，尽管目前它还没有做太多工作，只是作为`MuseumRepository`的代理运行。我们可以通过以下步骤创建这个简单功能的测试文件和逻辑：
- en: Create the `src/museums/controller.test.ts` file.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`src/museums/controller.test.ts`文件。
- en: The test runner will automatically consider files that have `.test` in their
    name as test files, among other conventions, as explained in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试运行程序将自动将文件名中包含`.test`的文件视为测试文件，如[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)
    *工具链*中所解释的其他约定。
- en: 'Declare the first test with the help of `Deno.test` ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Deno.test`([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test))声明第一个测试：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, export the assertion methods from the standard library under a namespace
    named `t`, so that we can then use them on the test files, by adding the following
    to `src/deps.ts`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将标准库中的断言方法导出到一个名为`t`的命名空间中，这样我们就可以在测试文件中使用它们，通过在`src/deps.ts`中添加以下内容：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to know what assertion methods are available in the standard library,
    check out [https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts](mailto:https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts).
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想了解标准库中可用的断言方法，请查看[https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts](mailto:https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts)。
- en: 'You can now use the assertion methods from the standard library to write a
    test that instantiates `MuseumController` and calls the `getAll` method:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以使用标准库中的断言方法来编写一个实例化`MuseumController`并调用`getAll`方法的测试：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s run the test and verify that it''s working:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行测试并验证它是否正常工作：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And our first test works!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试成功了！
- en: Note how the test's output lists the name of the test, its status, and the time
    it took to run, together with a summary of the test run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试输出如何列出测试的名称、状态和运行时间，以及测试运行的摘要。
- en: The logic inside `MuseumController` is quite simple, thus this was also a very
    simple test. However, it isolated the controller's behavior, allowing us to write
    a very focused test. If you're interested in creating unit tests for other parts
    of the application, they're available in this book's repository ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MuseumController`内部的逻辑相当简单，因此这个测试也非常简单。然而，它隔离了控制器的行为，使我们能够编写非常专注的测试。如果您对为应用程序的其他部分创建单元测试感兴趣，它们可以在本书的存储库中找到([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).'
- en: In the next few sections, we'll write more interesting tests. These are the
    tests that will teach us how to check the integration between the different modules
    of the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将编写更有趣的测试。这些测试将教会我们如何检查应用程序不同模块之间的集成。
- en: Writing an integration test
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: Our first unit test, which we created in the previous section, relied on a mocked
    instance of the repository to guarantee that our controller was working. That
    test adds great value when it comes to detecting bugs in `MuseumController`, but
    it isn't worth much in terms of understanding if the controller works well with
    the repository.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的第一个单元测试依赖于存储库的模拟实例来确保我们的控制器正常工作。这个测试在检测`MuseumController`中的错误方面增加了很大价值，但它在理解控制器是否与存储库良好配合方面并不值太多。
- en: 'That''s the purpose of integration tests: they test how multiple components
    integrate with each other.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的目的是测试多个组件如何相互集成。
- en: In this section, we'll write the integration test that tests `MuseumController`
    and `MuseumRepository`. These are the tests that will closely mimic what happens
    when the application runs and will help us later in terms of detecting any problems
    between these two classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个集成测试，用于测试`MuseumController`和`MuseumRepository`。这些测试将 closely mimic
    应用程序运行时发生的事情，并帮助我们 later in terms of detecting any problems between these two
    classes.
- en: 'Let''s get started:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Create the file for this module's integration tests inside `src/museums`, called
    `museums.test.ts`, and add the first test case there.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums`中为此模块的集成测试创建一个文件，称为`museums.test.ts`，并在那里添加第一个测试用例。
- en: 'It should test whether it is possible to get all the museums, this time using
    an instance of the repository instead of a mocked one:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该测试是否可以使用存储库的实例而不是模拟实例获取所有博物馆：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll start by instantiating the repository and adding a couple of fixtures
    there:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从实例化存储库并在此添加几个测试用例开始：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have a repository, we can use it to instantiate the controller:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了存储库，我们可以用它来实例化控制器：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now write our assertions to make sure everything is working fine:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的断言来确保一切都在正常工作：
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s run the test and check the result:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行测试并检查结果：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is passing! This is all we need for our repository and controller integration
    tests! This test is useful whenever we want to change the code in `MuseumController`
    or `MuseumRepository` as it makes sure they work fine together.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过了！这就是我们需要的存储库和控制器集成测试！这个测试在我们要更改`MuseumController`或`MuseumRepository`中的代码时非常有用，因为它确保它们一起工作得很好。
- en: Again, if you are curious about how integration tests for other parts of the
    application work, we made them available in this book's repository ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您对应用程序其他部分的集成测试如何工作感到好奇，我们在这本书的仓库中提供了它们 ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
- en: In the first section, we created a unit test, and here, we created an integration
    test, but we still haven't written any tests for our application's interface –
    the web part of it, which is using HTTP. That's what we'll do in the next section.
    We'll learn how can we test the logic living in the web layer in isolation, without
    using any other modules.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们创建了一个单元测试，在这里，我们创建了一个集成测试，但我们还没有为应用程序的界面 - 网络部分编写任何测试，该部分使用HTTP。这就是我们下一部分要做的。我们将学习如何可以独立地测试网络层中的逻辑，不使用任何其他模块。
- en: Testing the web server
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试网络服务器
- en: So far, we have learned how to test different parts of the application. We started
    with the business logic, which tests how it integrated with the modules that interacted
    with persistency (the repository), but the web layer still has no tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何测试应用程序的不同部分。我们始于业务逻辑，它测试如何与与持久性交互的模块（存储库）集成，但网络层仍然没有测试。
- en: It's true that those tests are very important, but we can agree that if the
    web layer fails, the user will not have access to any of that logic.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，那些测试非常重要，但我们一致认为如果网络层失败，用户将无法访问到任何逻辑。
- en: That's what we'll do in this section. We'll spin up our web server, mock its
    dependencies, and make a few requests to it to ensure the web *unit* is working.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们这一节要做的。我们将启动我们的网络服务器，模拟它的依赖关系，并向它发送几个请求，以确保网络*单元*正在工作。
- en: 'Let''s start by creating the web module''s unit test by following these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过以下步骤创建网络模块的单元测试：
- en: Go to `src/web` and create a file named `web.test.ts`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`src/web`并创建一个名为`web.test.ts`的文件。
- en: 'Now, in order to test the web server, we need to go back to the `createServer`
    function in `src/web/index.ts` and export the `Application` object it creates
    in `src/web/index.ts`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了测试网络服务器，我们需要回到`src/web/index.ts`中的`createServer`函数，并导出它创建的`Application`对象：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We also want to be able to stop the application whenever we want. We haven't
    implemented that yet.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望能够在任何时候停止应用程序。我们还没有实现这个功能。
- en: If we look at oak's documentation, we'll see that it's very well-documented
    ([https://github.com/oakserver/oak#closing-the-server](https://github.com/oakserver/oak#closing-the-server)).
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们查看oak的文档，我们会看到它非常完善([https://github.com/oakserver/oak#closing-the-server](https://github.com/oakserver/oak#closing-the-server))。
- en: To abort the application that's started by the `listen` method, we also need
    to return `AbortController`. So, let's do that at the end of the `createServer`
    function.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了取消由`listen`方法启动的应用程序，我们还需要返回`AbortController`。所以，让我们在`createServer`函数的最后这样做。
- en: 'If you aren''t aware of what `AbortController` is, I''ll leave you with a link
    from Mozilla Developers Network ([https://developer.mozilla.org/en-US/docs/Web/API/AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)),
    which explains it very clearly. The short version is that it allows us to cancel
    an ongoing promise:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不知道`AbortController`是什么，我留下一个来自Mozilla开发者网络的链接([https://developer.mozilla.org/en-US/docs/Web/API/AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)),它解释得非常清楚。简而言之，它允许我们取消一个进行中的承诺：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note how we're instantiating `AbortController`, similar to the documentation's
    example, and returning it at the end, together with the `app` variable.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何实例化`AbortController`的，这与文档中的示例类似，并在最后返回它，还有`app`变量。
- en: 'Back to our tests, let''s create a test that checks whether the server answers
    to `hello world`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的测试中，让我们创建一个测试，检查服务器是否对`hello world`做出响应：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s get an instance of the server running using the function we previously
    created; that is, `createServer`. Remember, to call this function, we must send
    its dependencies in. Here, we''ll have to mock them:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用我们之前创建的函数来获取服务器的实例运行；也就是说，`createServer`。记住，要调用这个函数，我们必须发送它的依赖关系。在这里，我们将不得不模拟它们：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now create a test that checks whether the web server is working by answering
    the hello world request:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个测试，通过响应hello world请求来检查网络服务器是否正常工作：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last thing we need to do is close the server once the test has run. Deno
    makes the test fail by default if we don''t do this (because `sanitizeResources`
    is `true` by default), as it would probably cause a memory leak:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是在测试运行后关闭服务器。Deno默认会让测试失败如果我们不这样做（因为`sanitizeResources`默认是`true`），这可能会导致内存泄漏：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This wraps up our first test for the web layer! This was another unit test,
    and it tested the logic to spin up the server and ensured that Hello World is
    working. Next, we'll create more complete tests for the endpoints, together with
    the business logic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们针对网络层的第一个测试！这是一个单元测试，它测试了启动服务器的逻辑，并确保了Hello World正在工作。接下来，我们将为端点创建更完整的测试，包括业务逻辑。
- en: In the next section, we'll start writing integration tests for the login and
    register functionality. Those are a little more complex than the tests we wrote
    for the museum's module as they'll test the application as a whole, including
    its business logic, persistency, and web logic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始为登录和注册功能编写集成测试。这些测试比我们为博物馆模块编写的测试要复杂一些，因为它们将测试整个应用程序，包括其业务逻辑、持久性和网络逻辑。
- en: Creating integration tests for the application
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序创建集成测试
- en: The three tests we've written so far have been unit tests for a single module,
    and an integration test between two different modules. However, to be confident
    that our code is working, it would be cool if we could test the application as
    a whole. That's what we'll do here. We'll wire up our application with a testing
    configuration and run a few tests against it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止编写的三个测试单元测试了一个单一模块，以及两个不同模块之间的集成测试。然而，为了确信我们的代码正在工作，如果我们能够测试整个应用程序那就太好了。那就是我们接下来要做的。我们将为应用程序设置一个测试配置，并对它运行一些测试。
- en: We'll start by calling the same function we called to initialize the web server
    and then create instances of all its dependencies (controllers, repositories,
    and so on). We'll make sure we use things such as in-memory persistence to do
    so. This will make sure that our tests are replicable and don't need a complex
    teardown phase or a connection to a real database, as that would slow down the
    tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先调用与初始化Web服务器相同的函数，然后创建其所有依赖项（控制器、存储库等）的实例。我们将确保我们使用内存持久性等事物来做到这一点。这将确保我们的测试是可复制的，并且不需要复杂的清理阶段或真实数据库的连接，因为这会减慢测试速度。
- en: We'll start by creating a test file that, for now, will encompass the integration
    tests for the application. As the application evolves, it might make sense to
    create a test folder inside each module, but for now, this solution will work
    just fine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个测试文件，暂时包括应用程序的集成测试。随着应用程序的发展，可能在每个模块中创建一个测试文件夹是有意义的，但现在，这个解决方案完全可行。
- en: 'We''ll instantiate the application with a setup that''s very close to what
    it runs in production and make a few requests and assertions against it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以非常接近实际生产中运行的设置实例化应用程序，并对它进行一些请求和断言：
- en: 'Create the `src/index.test.ts` file, alongside the `src/index.ts` file. Inside
    it, create a test declaration that tests that a user can log in:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与`src/index.ts`文件并列的`src/index.test.ts`文件。在其中创建一个测试声明，测试用户是否可以登录：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before we start writing this test, we''ll create a helper function that will
    set up the web server for testing. It will contain all the logic for instantiating
    controllers and repositories, as well as sending configuration into the application.
    It will look something like this:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始编写这个测试之前，我们将创建一个助手函数，该函数将为测试设置Web服务器。它将包含所有实例化控制器和存储库的逻辑，以及将配置发送到应用程序的逻辑。它看起来像这样：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we''re doing here is very similar to the wiring logic we do in `src/index.ts`.
    The only difference is that we''ll explicitly import the in-memory repositories,
    not the MongoDB ones, as shown in the following code block:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里做的工作与`src/index.ts`中的布线逻辑非常相似。唯一的区别是我们将显式导入内存存储库，而不是MongoDB存储库，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For us to have access to the in-memory repositories of the `Museums` and `Users`
    modules, we need to go into these modules and export them.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让我们能够访问`Museums`和`Users`模块的内存存储库，我们需要进入这些模块并将它们导出。
- en: 'This is what the `src/users/index.ts` file should look like:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`src/users/index.ts`文件应该看起来像这样：'
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a server instance using the helper function we just created, `createTestServer`,
    and use `fetch` to make a register request to the API:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们刚刚创建的助手函数`createTestServer`创建一个服务器实例，并使用`fetch`对API发起注册请求：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we have access to the registered user, we can try to log in with that
    same user:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以访问注册用户，因此我们可以尝试使用同一个用户登录：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are now ready to develop a few assertions to check whether our login response
    is what we were expecting:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备编写几个断言来检查我们的登录响应是否如我们所期望的那样：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we need to call the `abort` function on our server:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的服务器上调用`abort`函数：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This was our first application integration test! We got the application to run,
    performed the register and login requests against it, and asserted that everything
    was working as expected. Here, we built the test step by step, but if you want
    to have a look at the complete test, it is available in this book's GitHub repository
    ([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次进行应用集成测试！我们让应用运行起来，对其进行了注册和登录请求，并断言一切按预期工作。在这里，我们逐步构建了测试，但如果您想查看完整的测试，它可以在本书的GitHub仓库中找到([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts)).
- en: 'To wrap this up, we''ll write another test. Remember that, in the previous
    chapter, we created some authorization logic that would only allow a logged in
    user to access the list of museums? Let''s check if that is working with another
    test:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这个话题，我们将编写另一个测试。还记得在上一个章节中，我们创建了一些授权逻辑，只允许已登录的用户访问博物馆列表吗？让我们用另一个测试来检查这是否有效：
- en: 'Create another test inside `src/index.test.ts` that will test whether a user
    with a valid token can access the museums list:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/index.test.ts`中创建另一个测试，以测试用户是否可以使用有效的令牌访问博物馆列表：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we want to log in and register again, we''ll extract those functions
    into a utility function that we can use in multiple tests:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想要再次登录和注册，我们将这些功能提取到一个我们可以在其多个测试中使用的工具函数中：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With these functions, we can now refactor the previous test so that it looks
    a little cleaner, as the following snippet demonstrates:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些功能，我们现在可以重构之前的测试，使其看起来更干净一些，以下代码段展示了这一点：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s get back to the test we were writing – the one that checks whether an
    authenticated user can access the museums – and use the `register` and `login`
    functions to register and authenticate a user:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们正在编写的测试——检查认证用户是否可以访问博物馆的测试，并使用`register`和`login`函数来注册和认证一个用户：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can use the token that''s returned from the `login` function in the
    `Authorization` header to make an authenticated request:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用从`login`函数返回的令牌，在`Authorization`头中进行认证请求：
- en: '[PRE29]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a test that checks that a user can''t access the `museums` route without
    a valid token. It should be very similar to the previous test, with the small
    difference that we''re sending an invalid token now:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试，检查用户是否可以在没有有效令牌的情况下访问`museums`路由来。它应该与之前的测试非常相似，唯一的不同是我们现在发送一个无效的令牌：
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can run all the tests and confirm that they''re all green:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行所有测试并确认它们都是绿色的：
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is it for the application integration tests we're going to write in this
    book! If you want to find out more, then don't worry – all the code that's been
    written in this book regarding tests is available in this book's GitHub repository
    ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本书我们要编写的应用集成测试就这些！如果您想了解更多，请不要担心——本书中编写的一切代码都可以在本书的GitHub仓库中找到([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
- en: We're now much more confident that our code is working. We've created the opportunity
    to refactor, extend, and maintain the code later with fewer worries. The architecture
    decisions we've made are paying off more and more when it comes to testing the
    code in isolation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对代码工作的信心更强了。我们创造了机会来重构、扩展和后期维护代码，担忧更少。我们在架构决策上越来越受益于在隔离测试代码方面的经验。
- en: In the previous chapter, when we created our JavaScript client, we mentioned
    that one of the advantages of having it living in the API code base is that we
    could easily write tests for the client and the API to guarantee that they work
    well together. In the next section, we'll demonstrate how can we do this. These
    tests will be very much in line with what we did here, with the small difference
    that instead of using `fetch` and doing raw requests, we'll use the API client
    we created.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，当我们创建我们的JavaScript客户端时，我们提到了将其保存在API代码库中的一个优点是，我们可以轻松地为客户端和API编写测试，以确保它们一起正常工作。在下一部分，我们将展示如何做到这一点。这些测试将与我们在这里所做的非常相似，唯一的区别是，我们将使用我们创建的API客户端，而不是使用`fetch`并进行原始请求。
- en: Testing the application together with the API client
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序与API客户端一起工作
- en: When you provide an API client to your users, you have the responsibility of
    making sure it works flawlessly with your application. One of the ways to guarantee
    this is by having a complete test suite, one that not only tests the client on
    its own but also tests its integration with the API. Here we'll take care of the
    latter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向用户提供API客户端时，你有责任确保它与你的应用程序完美无缺地工作。确保这一点的一种方法是拥有一个完整的测试套件，不仅要测试客户端本身，还要测试其与API的集成。我们将在这里处理后者。
- en: 'We''ll use one feature of the API client and create a test that makes sure
    it''s working. Once again, you''ll notice some similarities between these and
    the tests we wrote at the end of the previous section. We''ll replicate the logic
    from the previous tests, but this time we''ll use the client. Let''s get started:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用API客户端的一个功能，并创建一个测试，确保它正在工作。再次，你会注意到这些测试与我们在上一部分末尾编写的测试有一些相似之处。我们将复制先前测试的逻辑，但这次我们将使用客户端。让我们开始吧：
- en: 'Inside the same `src/index.test.ts` file, create a new test for the login functionality:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个`src/index.test.ts`文件中，为登录功能创建一个新的测试：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For this test, we know that we'll need to get access to the API client. We'll
    need to import it from the `client` module.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这次测试，我们知道我们需要访问API客户端。我们需要从`client`模块中导入它。
- en: 'Import the `getClient` function from `src/client/index.ts`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`src/client/index.ts`导入`getClient`函数：
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s get back to the `src/index.test.ts` test and import `client`, thus creating
    an instance of it. Remember that it should use the same address that the test
    web server created:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`src/index.test.ts`测试，并导入`client`，从而创建一个它的实例。记住，它应该使用测试网络服务器创建的相同地址：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, it''s just a matter of writing the logic that calls the `register` and
    `login` methods using `client`. This is what the final test will look like:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需编写使用`client`调用`register`和`login`方法的逻辑。最终测试将看起来像这样：
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note how we're using the client's methods to log in and register while keeping
    the assertions from the previous tests.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何使用客户端的方法进行登录和注册，同时保留来自先前测试的断言。
- en: By following the same guidelines, we can write tests for all the client's functionality,
    guaranteeing that it's working fine with the API, making it easy to maintain it
    with confidence.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循相同的指导原则，我们可以为客户端的所有功能编写测试，确保它与API一起正常工作，从而使我们能够自信地维护它。
- en: For brevity, and because these tests resemble the ones we previously written,
    we won't provide a step-by-step guide to writing tests for all the client's functionality
    here. However, if you're interested, you can find them in this book's GitHub repository
    ([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，并且因为这些测试与我们之前编写的测试相似，我们这里不会提供有关为客户端的所有功能编写测试的逐步指南。然而，如果你感兴趣，你可以在本书的GitHub仓库中找到它们（[https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts)）。
- en: In the next section, we'll have a sneak peek at one feature that might be further
    down the path of your applications. On day, you'll start having parts of the application
    that seem to be getting slow and you want to track their performance, and that's
    where performance tests are useful. Because of this, we'll be introducing benchmarks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将预览一个可能位于应用程序路径下方的功能。总有一天，你会发现应用程序的某些部分似乎变得很慢，你希望追踪它们的性能，这时性能测试就派上用场了。因此，我们将引入基准测试。
- en: Benchmarking parts of the application
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试应用程序的部分
- en: When it comes to writing benchmarks in JavaScript, the language itself provides
    a few functions, all of which are included in the High Resolution Time API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到用JavaScript编写基准测试时，该语言本身提供了一些函数，所有这些函数都包含在高级分辨率时间API中。
- en: As Deno is fully ES6 compatible, these same features are available. If you've
    had the time to look at Deno's standard library or the official website, you'll
    have seen that benchmarks are taken into a lot of consideration and are tracked
    across Deno versions ([https://deno.land/benchmarks](https://deno.land/benchmarks)).
    Upon checking Deno's source code, you will see that you have a very nice set of
    examples regarding how to write them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Deno完全兼容ES6，这些相同的功能都可以使用。如果你有机会查看Deno的标准库或官方网站，你会发现人们对基准测试给予了大量的关注，并且在Deno各个版本中跟踪它们([https://deno.land/benchmarks](https://deno.land/benchmarks))。在检查Deno的源代码时，你会发现有关如何编写它们的非常不错的示例集。
- en: For our application, we could easily use the APIs available on the browser,
    but Deno itself provides functionality in the standard library to help with writing
    and running benchmarks, so that's what we'll use here.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们本可以轻松地使用浏览器上可用的API，但Deno本身在其标准库中提供了帮助编写和运行基准测试的功能，因此我们将在这里使用它。
- en: To start, we need to know Deno's standard library benchmark utilities so that
    we know what we can do ([https://github.com/denoland/deno/blob/ae86cbb551f7b88f83d73a447411f753485e49e2/std/testing/README.md#benching](https://github.com/denoland/deno/blob/ae86cbb551f7b88f83d73a447411f753485e49e2/std/testing/README.md#benching)).
    In this section, we'll write a very simple benchmark using two of the available
    functions; that is, `bench` and `runBenchmarks`. The first one will define a benchmark,
    while the second one will run it and print the result to the console.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解Deno的标准库基准工具，以便我们知道可以做什么（[https://github.com/denoland/deno/blob/ae86cbb551f7b88f83d73a447411f753485e49e2/std/testing/README.md#benching](https://github.com/denoland/deno/blob/ae86cbb551f7b88f83d73a447411f753485e49e2/std/testing/README.md#benching)）。在本节中，我们将使用两个可用的函数编写一个非常简单的基准测试；即，`bench`和`runBenchmarks`。第一个将定义一个基准测试，而第二个将运行它并将结果打印到控制台。
- en: 'Remember the function we wrote in [*Chapter 5*](B16380_05_Final_JM_ePub.xhtml#_idTextAnchor124),
    *Adding Users and Migrating to Oak*, to generate a hash and a salt, which enabled
    us to store the user credentials safely on the database? We''ll write a benchmark
    test for that by following these steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第5章](B16380_05_Final_JM_ePub.xhtml#_idTextAnchor124)中编写的函数吗？*添加用户和迁移到Oak*，用于生成散列值和盐值，这使我们能够将用户凭据安全地存储在数据库上？我们将通过以下步骤为此编写基准测试：
- en: To start, create a file alongside `src/users/util.ts` named `utilBenchmarks.ts`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src/users/util.ts`旁边创建一个名为`utilBenchmarks.ts`的文件。
- en: 'Import the two functions from `util` that we want to test; that is, `generateSalt`
    and `hashWithSalt`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`util`模块中导入我们想要测试的两个函数，即`generateSalt`和`hashWithSalt`：
- en: '[PRE36]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It''s time to add the benchmark utilities to our `src/deps.ts` file and run
    the `deno cache` command (which we learned about in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*) and import it here. We''ll export it as `benchmark`, in `src/deps.ts`,
    to avoid naming conflicts:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将基准工具添加到我们的`src/deps.ts`文件中，并运行`deno cache`命令（我们在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)中了解到）*工具链*）并在此处导入它。我们将把它作为`benchmark`导出到`src/deps.ts`中，以避免命名冲突：
- en: '[PRE37]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Import the benchmark utilities into our benchmarks file and write the first
    benchmark for the `generateSalt` function. We want it to run 1,000 times:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基准工具导入我们的基准测试文件中，并为`generateSalt`函数编写第一个基准测试。我们希望它运行1000次：
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The only thing we''re missing is calling `runBenchmarks` once the benchmarks
    have been defined:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所缺少的只是定义了基准测试后调用`runBenchmarks`：
- en: '[PRE39]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's time to run this file and have a look at the results.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候运行这个文件并查看结果了。
- en: 'Remember that we''re dealing with high resolution time as we want our benchmarks
    to be precise. To let this code have access to this system feature, we need to
    run this script with the `--allow-hrtime` permission (as explained in [*Chapter
    2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056), *The Toolchain*):'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，由于我们希望我们的基准测试具有高精度，所以我们正在处理高分辨率时间。为了让这段代码能够访问这个系统特性，我们需要以`--allow-hrtime`权限运行这个脚本（如[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)中所解释的，*工具链*）：
- en: '[PRE40]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s write the benchmark for the second function; that is, `hashWithSalt`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为第二个函数编写基准测试，即`hashWithSalt`：
- en: '[PRE41]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s run it so that we get the final result:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行它，以便得到最终结果：
- en: '[PRE42]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And that's it! You can now use the code we just wrote any time you want to analyze
    the performance of these functions. You may want to do this because you've changed
    this code or just because you want to have it closely tracked. You can integrate
    it in systems such as a continuous integration server, where you can regularly
    check these values and keep them on track.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在你可以随时使用我们刚刚编写的代码来分析这些函数的性能。你可能想这样做，是因为你已经修改了这段代码，或者只是因为你想要对其进行严格跟踪。你可以将其集成到诸如持续集成服务器之类的系统中，在那里你可以定期检查这些值并保持其正常运行。
- en: This wraps up the benchmarks section of this book. We decided on giving it short
    introduction, and also demonstrating what APIs are available from on Deno to facilitate
    benchmarking needs.We believe the concepts and examples presented here will allow
    you to track how your applications are running.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本书关于基准测试的部分就到此为止。我们决定给予它一个简短的介绍，并展示从Deno获取的API，以方便进行基准测试。我们相信，这里介绍的概念和例子可以帮助你跟踪应用程序的运行情况。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this chapter, we've closed the development cycle of the application we've
    been building. We started small by writing a few simple classes with our business
    logic, wrote the web server to it, and finished by integrating it with persistence.
    We finished this section by learning how to test the features we wrote, and that's
    what we did in this chapter. We decided on going with a few different types of
    tests, instead of extensively going module by module writing all the tests, as
    we believe that's where more value is added.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一章节，我们已经完成了我们一直在构建的应用程序的开发周期。我们从编写几个简单的类开始，带有我们的业务逻辑，编写web服务器，最后将其与持久化集成。我们通过学习如何测试我们编写的功能来结束这一部分，这就是我们在这章所做的事情。我们决定选择几种不同类型的测试，而不是深入每个模块编写所有测试，因为我们认为这样做会带来更多的价值。
- en: We started with a very simple unit test for the business logic, then moved on
    to an integration test with multiple classes, and later wrote a test for the web
    server. These tests can only be written by leveraging the architecture we've created,
    following dependency injection principles, and trying to keep the code as decoupled
    as possible.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从业务逻辑的一个非常简单的单元测试开始，然后转向带有多个类的集成测试，最后为web服务器编写了一个测试。这些测试只能通过利用我们创建的架构、遵循依赖注入原则并尽量使代码解耦来编写。
- en: As the chapter proceeded, we moved on to integration tests, which closely mimic
    the que application as it will run in production, enabling us to improve the confidence
    we have in the code we just wrote. We created tests that instantiated the application
    with a testing setup that enabled us to spin up the web server with all the application
    layers (business logic, persistence, and web) and made assertions to it. In these
    tests, we could very confidently assert that the login and registry behaviors
    were working fine, as we made real requests to the API.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着章节的进行，我们转向了集成测试，这些测试紧密地模仿了将在生产环境中运行的队列应用程序，使我们能够提高对我们刚刚编写的代码的信心。我们创建了测试，使用测试设置实例化了应用程序，能够启动带有所有应用程序层（业务逻辑、持久化和网络）的web服务器，并对它进行断言。在这些测试中，我们可以非常有信心地断言登录和注册行为是否正常，因为我们向API发送了真实的请求。
- en: To wrap up this chapter, we connected it to the previous one, where we wrote
    a JavaScript client for the API. We leveraged one of the big advantages of having
    the client living in the same codebase as the API and tested the client together
    with the application itself. This is a great way of guaranteeing that everything
    is working as expected, and that we can be confident when releasing changes in
    both the API and the client.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，我们将它与前一章连接起来，我们在那里为API编写了一个JavaScript客户端。我们利用了客户端与API位于同一代码库中的一个巨大优势，并一起测试了客户端及其应用程序。这是确保一切按预期工作，并在发布API和客户端更改时保持信心的好方法。
- en: This chapter tried to demonstrate how tests can be used in Deno to increase
    our confidence in the code we've written, as well as the value they bring when
    they're used to focus on simple outcomes. Tests like these will be of great use
    later when the application changes, as we can use them to add more features or
    improve the existing ones. Here, we learned how the test suite provided by Deno
    is more than enough to write clear, readable tests without any third-party packages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章试图展示如何在Deno中使用测试来提高我们对所编写代码的信心，以及当它们用于关注简单结果时所提供的价值。这类测试在应用更改时将非常有用，因为我们可以使用它们来添加更多功能或改进现有功能。在这里，我们了解到Deno提供的测试套件足以编写清晰、可读的测试，而无需任何第三方包。
- en: The next chapter will focus on one of the most important phases of application
    development; that is, deploying. We'll configure a very simple continuous integration
    environment where we can deploy the application to the cloud. This is a very important
    chapter as we'll also experience some of the advantages of Deno when it comes
    to its ease of deployment.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点关注应用开发过程中最重要的阶段之一，那就是部署。我们将配置一个非常简单的持续集成环境，在该环境中我们可以将应用部署到云端。这一章节非常重要，因为我们将体验到Deno在部署方面的某些优势。
- en: Excited to make your application available to users? So are we – let's go!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 迫不及待地想让你的应用供用户使用吗？我们也是——让我们开始吧！
