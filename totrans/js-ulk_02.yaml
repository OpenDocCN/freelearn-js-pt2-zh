- en: Chapter 2. Modular Programming with JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。使用JavaScript的模块化编程
- en: 'Engineering in general is all about splitting large tasks into small ones and
    composing the solutions of these tasks in a system. In software engineering, we
    break the code-base into modules by following the principles of low coupling and
    high cohesion. In this chapter, we will talk about the approaches to create modules
    in JavaScript by covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，工程学就是将大型任务分解为小型任务，并在系统中组合这些任务的解决方案。在软件工程中，我们遵循低耦合和高内聚的原则，将代码库分解为模块。在本章中，我们将讨论在JavaScript中创建模块的方法，并涵盖以下主题：
- en: How to get out of a mess using modular JavaScript
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用模块化的JavaScript摆脱困境
- en: How to use asynchronous modules in the browser
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在浏览器中使用异步模块
- en: How to use synchronous modules on the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在服务器上使用同步模块
- en: JavaScript built-in module system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript内置模块系统
- en: Transpiling CommonJS for in-browser use
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CommonJS转换为浏览器使用
- en: How to get out of a mess using modular JavaScript
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用模块化的JavaScript摆脱困境
- en: How many digital photos do you have, probably thousands, or more? Just imagine
    if your image viewer had no capacity to categorize. No albums, no books, no categories,
    nothing. It would not be of much use, does it? Now let's assume that you have
    a JavaScript application in a single file and it grows. When it approaches thousand
    or more than a thousand lines of code, however good your code design is, from
    a maintainability perspective, it still turns into a useless *pile* like that
    enormous list of uncategorized photos. Instead of building a monolithic application,
    we have to write several independent modules that combine together to form an
    application. Thus, we break a complex problem into simpler tasks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少数码照片，可能成千上万，或者更多？想象一下，如果你的图片查看器没有分类能力。没有相册，没有书籍，没有分类，什么都没有。它将毫无用处，不是吗？现在假设你有一个JavaScript应用程序，它包含在一个文件中，并且它不断增长。当它接近一千行或超过一千行代码时，无论你的代码设计有多好，从可维护性的角度来看，它仍然会变成像那堆未分类照片的巨大列表一样的无用*堆*。我们不应该构建一个单块应用程序，而应该编写几个独立的模块，它们组合在一起形成一个应用程序。因此，我们将复杂问题分解为简单任务。
- en: Modules
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: So, what is a module? A module encapsulates code intended for a particular functionality.
    A module also provides an interface declaring what elements the module exposes
    and requires. A module is often packaged in a single file, which makes it easy
    to locate and deploy. A well-designed module implies low coupling (the degree
    of interdependence between modules) and high cohesion (the degree to which the
    elements of a module belong together).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，模块是什么呢？模块封装了为特定功能设计的代码。模块还提供了一个接口，声明了模块公开和需要的元素。模块通常打包在一个文件中，这使得它容易定位和部署。一个设计良好的模块意味着低耦合（模块之间的相互依赖程度）和高内聚（模块元素彼此属于的程度）。
- en: What are the advantages that modules give us in JavaScript?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在JavaScript中给我们带来了哪些优势？
- en: Cleaner global scope
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更清晰的全局作用域
- en: You know in JavaScript any assignation that we do out of any function scope
    makes a new member of the global scope (a built-in object window in a browser
    or global in Node.js/Io.js). Therefore, we are always at a risk of overriding
    accidentally an already defined property. On the contrary, whatever is declared
    in a module stays here unless we explicitly export it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你在JavaScript中知道任何在我们任何函数作用域之外进行的赋值都会在全局作用域中创建一个新的成员（在浏览器中是一个内置对象window，在Node.js/Io.js中是global）。因此，我们总是有意外覆盖已经定义属性的风险。相反，模块中声明的任何内容除非我们明确导出它，否则它将留在这里。
- en: Packaging code into files
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将代码打包成文件
- en: In server-side languages, applications consist of numerous files. One of the
    best practices here is that a file may contain only one class and have only one
    responsibility. Besides, a fully-qualified class name must reflect its file location.
    So when we run into a problem on an object, we can easily deduct where to find
    its source code. We can divide JavaScript application code into separate scripts,
    but these will share the same scope and won't give us any encapsulation. Moreover,
    when the scripts load asynchronously, the internal dependencies must be solved,
    which is not easy to do. But if we use modules, each is given a dedicated file
    and has its own scope. A module loader takes care of asynchronous dependencies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端语言中，应用程序由许多文件组成。这里的一个最佳实践是，一个文件只包含一个类，并且只负责一件事情。此外，完全限定的类名必须反映其文件位置。所以当我们遇到对象问题时，我们可以很容易地推断出在哪里可以找到其源代码。我们可以将JavaScript应用程序代码分成不同的脚本，但这些将共享同一个作用域，并且不会给我们任何封装。此外，当脚本异步加载时，内部依赖关系必须解决，这并不容易。但是，如果我们使用模块，每个模块都有一个专门的文件和自己的作用域。模块加载器负责异步依赖关系。
- en: Reuse
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重用
- en: Imagine, while working on a project, you wrote a code that solves one task—let's
    say it provides a convenient API to manage cookies. When switching to another
    project, you realize that your cookie manager would quite be in place there. In
    case of *spaghetti code*, you would have to extract the component code, decouple
    it, and bind it to the new place. If you wrote the component as a decently-designed
    module, you simply take it and plug it in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在项目工作中，你写了一段代码，解决了一个任务——比如提供了一个方便的API来管理cookie。当切换到另一个项目时，你意识到你的cookie管理器在那里会很合适。在*意大利面条代码*的情况下，你必须提取组件代码，解耦它，并将其绑定到新位置。如果你将组件作为设计得体的模块编写，你只需拿过来并插入即可。
- en: Module patterns
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块模式
- en: 'Well, we know that modules help and we want to use them. How do we implement
    a module in JavaScript? First of all, we need to detach the module code from the
    global scope. We can only do this by a wrapping module code with a function. A
    common practice here is to go with **Immediately Invoked Function Expression**
    (**IIFE**):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们知道模块有帮助，并且我们想使用它们。那么，我们在JavaScript中如何实现一个模块呢？首先，我们需要将模块代码从全局作用域中分离出来。我们只能通过用函数包装模块代码来实现这一点。这里的一个常见做法是使用**立即执行函数表达式**（**IIFE**）：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A module must also have access points with the surrounding environment. In the
    same way as we usually deal with functions, we can pass object references to IIFE
    as arguments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还必须具有与周围环境交互的接口。就像我们通常处理函数一样，我们可以将对象引用作为IIFE的参数传递。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may have also seen a pattern where a global object (window) is passed with
    arguments. This way we do not access the global object directly, but by a reference.
    There is an opinion that the access by a local reference is faster. That's not
    completely true. I've prepared a Codepen with some tests at [http://codepen.io/dsheiko/pen/yNjEar](http://codepen.io/dsheiko/pen/yNjEar).
    It shows me that in Chrome (v45), a local reference is really ~20 percent faster;
    however, in Firefox (v39), this doesn't make any considerable difference.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也看到过一种模式，即全局对象（window）通过参数传递。这种方式我们不是直接访问全局对象，而是通过引用。有一种观点认为通过局部引用访问更快。这并不完全正确。我准备了一个Codepen，里面有一些测试，在[http://codepen.io/dsheiko/pen/yNjEar](http://codepen.io/dsheiko/pen/yNjEar)。它显示，在Chrome（v45）中，局部引用确实快了20%；然而，在Firefox（v39）中，这并没有造成任何显著的差异。
- en: You can also run a pattern variation with `undefined` in the parameter list.
    A parameter that was not supplied with the arguments has an `undefined` value.
    So, we do this trick to ensure that we get the authentic `undefined` object in
    the scope even if the global `undefined` object is overridden.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在参数列表中运行模式变体 with `undefined`。没有通过参数传递的参数有一个`undefined`值。所以，我们这样做是为了确保即使在全局`undefined`对象被覆盖的情况下，我们也能在作用域中获得真实的`undefined`对象。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to expose a module element outside its scope, we can simply return
    an object. The result of the function call can be assigned to an external variable,
    as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在模块的作用域外暴露模块元素，我们可以简单地返回一个对象。函数调用的结果可以赋值给外部变量，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Augmentation
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强
- en: Sometimes we need to mix things up in a module. For example, we have a module
    that provides core functionality, and we want to plug-in extensions depending
    on the context of use. Let's say, I have a module to create objects based on pseudo-class
    declarations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要在模块中混合事物。例如，我们有一个提供核心功能的模块，我们希望根据使用上下文插入扩展。假设，我有一个基于伪类声明创建对象的模块。
- en: 'Basically, during instantiation it automatically inherits from a specified
    object and calls the constructor method. In a particular application, I want this
    to also validate the object interface against a given specification. So, I plug
    this extension to the base module. How is it done? We pass the reference of the
    base module to the plugin. The link to the original will be maintained, so we
    can modify it in the scope of the plugin:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在实例化时它自动继承自指定的对象并调用构造方法。在特定的应用程序中，我还希望这也验证对象接口是否符合给定的规范。所以，我在基础模块中插入了这个扩展。是如何做到的？我们将基础模块的引用传递给插件。将保留对原始模块的链接，因此我们可以在插件的作用域中修改它：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Module standards
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块标准
- en: We've just reviewed a few ways to implement modules. However, in practice, we
    rather follow a standardized API. These have been proved by a huge community,
    adopted by real-world projects, and recognizable by other developers. The two
    most important standards that we need to keep in mind are **AMD** and **CommonJS
    1.1**, and now we would rather look at at ES6 Module API, which is going to be
    the next big thing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经回顾了实现模块的几种方法。然而，在实践中，我们更倾向于遵循一个标准化的API。这些已经被一个庞大的社区证明，被实际世界的项目采用，并被其他开发者所认可。我们需要牢记的两个最重要的标准是**AMD**和**CommonJS
    1.1**，现在我们更愿意看看ES6模块API，这将是下一件大事。
- en: CommonJS 1.1 loads modules synchronously. The module body is executed once during
    the first load and the exported object is cached. It is designed for server-side
    JavaScript and mostly used in Node.js/Io.js.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 1.1以同步方式加载模块。模块体在第一次加载后执行一次，导出的对象被缓存。它为服务器端JavaScript设计，主要用于Node.js/Io.js。
- en: AMD loads modules asynchronously. The module body is executed once after the
    first load and the exported object is also cached. This is designed for in-browser
    use. AMD requires a script loader. The most popular are RequireJS, curl, lsjs,
    and Dojo.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: AMD以异步方式加载模块。模块体在第一次加载后执行一次，导出的对象也被缓存。这为浏览器使用而设计。AMD需要一个脚本加载器。最受欢迎的有RequireJS、curl、lsjs和Dojo。
- en: Soon, we can expect the script engines to gain native support for JavaScript
    built-in modules. The ES6 modules take the best of the two worlds. Similar to
    CommonJS, they have a compact syntax and support for cyclic dependencies, and
    similar to AMD, the modules load asynchronously and the loading is configurable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们可以期待脚本引擎获得对JavaScript内置模块的原生支持。ES6模块结合了两者的优点。与CommonJS类似，它们有紧凑的语法和支持循环依赖，与AMD类似，模块异步加载，加载可配置。
- en: How to use asynchronous modules in the browser
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在浏览器中使用异步模块
- en: To get a grasp on AMD, we will do a few examples. We will need script loader
    RequireJS ([http://requirejs.org/docs/download.html](http://requirejs.org/docs/download.html)).
    So you can download it and then address the local version in your HTML or give
    it an external link to CDN.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了掌握AMD，我们将做一些例子。我们将需要脚本加载器RequireJS([http://requirejs.org/docs/download.html](http://requirejs.org/docs/download.html)).所以你可以下载它，然后在HTML中指定本地版本，或者给它一个外部链接到CDN。
- en: 'First of all, let''s see how we can create a module and request it. We place
    the module in the `foo.js` file. We use the `define()` call to declare the module
    scope. If we pass an object to this, the object simply gets exported:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们如何创建一个模块并请求它。我们把模块放在`foo.js`文件里。我们使用`define()`调用声明模块作用域。如果我们传递一个对象给这个调用，对象简单地被导出：
- en: '**foo.js**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we pass a function, it is called and its return value is exported:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递一个函数时，它被调用，其返回值被导出：
- en: '**foo.js**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next to `foo.js`, we place `main.js`. This code can be described as follows:
    call the given callback when all the modules supplied to the first argument (here
    only `foo`, which means `./foo.js`) are loaded and available.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`foo.js`旁边放置`main.js`。这段代码可以如下描述：当第一个参数（这里只有`foo`，即`./foo.js`）提供的所有模块都被加载并可用时，调用给定的回调。
- en: '**main.js**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the HTML (`index.html`), first we load `RequireJS` and then `main.js`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从HTML（`index.html`）开始，我们首先加载`RequireJS`，然后是`main.js`：
- en: '**index.html**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**index.html**'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Loading scripts synchronously when we have a loader doesn''t feel right. However,
    we can do this with the only script element that, in addition, can be forced to
    load asynchronously:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个加载器时，同步加载脚本感觉不对。然而，我们可以用仅有的脚本元素来实现，此外，还可以强制它异步加载：
- en: '**index.html**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**index.html**'
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the `data-main` attribute, we tell the loader what module to load first,
    whenever the module is ready. As we fire up `index.html`, we will see the values
    of the `foo` module properties that we imported in `main.js`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`data-main`属性，我们告诉加载器首先加载哪个模块，无论何时模块准备就绪。当我们启动`index.html`时，我们将在`main.js`中导入的`foo`模块属性值。
- en: '`index.html` outputs the exports of the asynchronously loaded modules:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`输出异步加载模块的导出内容：'
- en: '![How to use asynchronous modules in the browser](img/00002.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何在浏览器中使用异步模块](img/00002.jpeg)'
- en: 'Now we fiddle with more dependencies. So we create the `bar.js` and `baz.js`
    modules:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处理更多的依赖关系。所以我们创建了`bar.js`和`baz.js`模块：
- en: '**bar.js**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**bar.js**'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**baz.js**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**baz.js**'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have to modify `foo.js` to access these modules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须修改`foo.js`以访问这些模块：
- en: '**foo.js**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you may have noticed, the `require`/`define` dependency lists consists of
    module identifiers. In our case, all the modules and the HTML located in the same
    directory. Otherwise, we need to build the identifiers based on relative paths
    (the `.js` file extension can be omitted). If you mess up with a path and RequireJS
    cannot resolve the dependency, it fires `Error: Script error for:<module-id>`.
    Not of much help, is it? You can improve error handling on your own. A function
    expression passed next to the module scope callback receives an exception object
    as an argument. This object has special properties such as `requireType` (a string
    containing error types such `timeout`, `nodefine`, `scripterror`) and `requireModules`
    (an array of module IDs affected by the error).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您可能注意到的，`require`/`define`依赖列表由模块标识符组成。在我们的案例中，所有模块和HTML位于同一目录中。否则，我们需要根据相对路径构建标识符（可以省略`.js`文件扩展名）。如果您路径出错，RequireJS无法解析依赖，它会发出`Error:
    Script error for:<module-id>`。这有很大帮助吗？您可以自己改进错误处理。传递给模块作用域回调的函数表达式接收一个异常对象作为参数。这个对象具有特殊属性，如`requireType`（一个包含错误类型的字符串，如`timeout`、`nodefine`、`scripterror`）和`requireModules`（受错误影响的模块ID数组）。'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In a well-grained design, modules are numerous and are allocated to a directory
    tree. In order to avoid relative path computation every time, you can configure
    the script loader once. So the loader will know where to find the dependency file
    by a specified alias:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个良好的设计中，模块众多，并且分配给一个目录树。为了避免每次都进行相对路径计算，您可以一次性配置脚本加载器。因此，加载器将通过指定的别名知道如何找到依赖文件：
- en: '**main.js**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This gives a bonus. Now if we decided to change a module file name, we do not
    need to modify every other module that requires it. We just need to change the
    configuration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个好处。现在如果我们决定更改一个模块文件名，我们不需要修改每个需要它的其他模块。我们只需要更改配置：
- en: '**main.js**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By configuring, we can also address remote modules. For example, here we refer
    to jQuery, but RequireJS knows the module endpoint from the configuration and,
    therefore, loads the module from CDN:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置，我们也可以解决远程模块。例如，这里我们引用jQuery，但RequireJS从配置中知道模块的端点，因此，从CDN加载模块：
- en: '**require.config({**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**require.config({**'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Pros and cons
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: The main advantage of the AMD approach is that modules load asynchronously.
    It also means that while deploying, we don't have to upload the entire code-base,
    but just a module is changed. And since a browser can handle multiple HTTP requests
    simultaneously, this way we improve performance. However, here comes a huge trap.
    It's really quick to load a code in a few separate pieces in parallel. But real-world
    projects have many more modules. With the HTTP/1.1 protocol, which is still dominant
    at the moment, loading all of them would take unacceptably long time. Unlike the
    new standard SPDY and HTTP/2, HTTP/1.1 doesn't cope really well with concurrency
    during the downloading of a page, and in case of a substantially long queue, this
    results in head-of-line blocking ([https://http2.github.io/faq/](https://http2.github.io/faq/)).
    RequreJS provides a tool ([http://requirejs.org/docs/optimization.html](http://requirejs.org/docs/optimization.html))
    to combine a bunch of modules. This way we don't need to load every single module,
    but only a few packages. The dependencies packaged together are resolved synchronously.
    So, one may say that partly we abandon the main benefit of AMD—asynchronous loading.
    Meanwhile, we must still load a, usually quite heavy, script loader and wrap every
    single module with the `define()` callback.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: AMD方法的优点之一是模块异步加载。这也意味着在部署时，我们不需要上传整个代码库，而只需上传一个模块。由于浏览器可以同时处理多个HTTP请求，这种方式可以提高性能。然而，这里有一个巨大的陷阱。并行加载几段代码确实很快。但是实际项目中的模块要多的多。使用目前仍占主导地位的HTTP/1.1协议，加载所有这些模块将需要很长时间。与新的SPDY和HTTP/2标准不同，HTTP/1.1在下载页面时的并发性处理并不好，如果队列很长，这将导致头阻塞([https://http2.github.io/faq/](https://http2.github.io/faq/))。RequreJS提供了一个工具([http://requirejs.org/docs/optimization.html](http://requirejs.org/docs/optimization.html))来合并多个模块。这样我们不需要加载每个单独的模块，而只需要几个包。一起打包的依赖关系是同步解析的。因此，可以说在一定程度上我们放弃了AMD的主要优点——异步加载。同时，我们仍然需要加载一个通常相当重的脚本加载器，并用`define()`回调包装每个模块。
- en: From my experience, I would rather advice you to go synchronous with the Common
    JS modules compiled into packages capable of in-browser use.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的经验来看，我更倾向于建议你使用与Common JS模块同步编译的包，这些包可以在浏览器中使用。
- en: How to – use synchronous modules on the server
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在服务器上使用同步模块
- en: The following examples require Node.js. It will take just a few minutes to install
    Node.js using the pre-built installer available at [https://nodejs.org/download/](https://nodejs.org/download/)
    or even faster via a package manager at [https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例需要Node.js。使用预编译安装器在[https://nodejs.org/download/](https://nodejs.org/download/)安装Node.js只需几分钟，甚至通过包管理器在[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)安装更快。
- en: 'We will start by putting a simple logic into a module:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在模块中放入一个简单的逻辑开始：
- en: '**foo.js**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can call the module:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用模块：
- en: '**main.js**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to run the example, we will open the console (under Windows, you can
    simply run `CMD.EXE`, but I would recommend an enhanced tool like CMDER available
    at [http://cmder.net/](http://cmder.net/)). In the console, we type the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行示例，我们将打开控制台（在Windows上，你可以直接运行`CMD.EXE`，但我建议使用像CMDER这样的增强工具，可在[http://cmder.net/](http://cmder.net/)获得）。在控制台中，我们输入以下内容：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![How to – use synchronous modules on the server](img/00003.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![如何在服务器上使用同步模块](img/00003.jpeg)'
- en: As soon as *Enter* is pressed, the console outputs **I'm running**. So when
    a module is requested, its body code is invoked. But what if we request the module
    several times?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Enter*键后，控制台输出**I'm running**。所以当请求一个模块时，其主体代码被执行。但如果我们多次请求该模块呢？
- en: '**main.js**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result is the same. It outputs **I''m running** only once. This is because
    the module body code is executed only once when the module is initially requested.
    An exported object (probably produced by the body code) is cached and acts similar
    to a singleton:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一样的。只输出了一次**I'm running**。这是因为模块主体代码只在模块首次请求时执行一次。导出的对象（可能由主体代码生成）被缓存，类似于单例：
- en: '**foo.js**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**main.js**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you will likely notice, unlike AMD we don't need any wrappers in the modules.
    But is it still isolated from a global scope?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能会注意到的，与AMD不同，我们模块中不需要任何包装器。但它仍然与全局作用域隔离吗？
- en: '**foo.js**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**main.js**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Any variables defined in a module scope are not available outside the scope.
    However, if you really want anything to be shared between the module variables
    behind the exposed interface, you can do it via a global object (Node.js is analogous
    to an in-browser Windows object).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 模块作用域中定义的任何变量在作用域外不可用。然而，如果你真的希望在暴露的接口后面的模块变量之间共享任何东西，你可以通过一个全局对象来实现（Node.js
    类似于浏览器中的 Windows 对象）。
- en: 'So what about exports? CommonJS has a preference for single export. We assign
    to `module.exports` a reference to a type or a value, and this will be the cached
    return of the required function. If we want multiple exports, we just export an
    object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于导出有什么要注意的呢？CommonJS 更倾向于单个导出。我们将 `module.exports` 赋值为一个类型或值的引用，这将是所需函数的缓存返回。如果我们想要多个导出，我们只需导出一个对象：
- en: '**foo.js**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**main.js**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the most common case in Node.js where an object constructor
    is exported:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Node.js 中最常见的情况，导出一个对象构造函数：
- en: '**foo.js**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So through a required call, we receive the constructor function with the prototype
    and can create instances:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过一个必需的调用，我们可以获得带有原型的构造函数，并可以创建实例：
- en: '**main.js**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The same way as we request the `foo` module from `main`, we can request from
    other modules as well:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从 `main` 模块请求 `foo` 模块一样，我们也可以从其他模块请求：
- en: '**bar.js**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**bar.js**'
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**baz.js**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**baz.js**'
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**foo.js**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**main.js**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But what if Node.js runs into cyclic dependencies? What if we request back
    the caller from the called module? Nothing dramatic happens. As you may remember,
    a module code is executed only once. So if we request `main.js` from `foo.js`
    after `main.js` is already performed, its body code isn''t invoked anymore:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果 Node.js 遇到循环依赖呢？如果我们从被调用模块中请求回调用者，会发生什么？并没有什么戏剧性的事情发生。正如您可能记得的，模块代码只执行一次。所以，如果在
    `main.js` 已经执行后，我们还是从 `foo.js` 请求 `main.js`，那么它的主体代码将不再被调用：
- en: '**foo.js**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**main.js**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we run `main.js` with Node.js, we get the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用 Node.js 运行 `main.js` 时，我们得到以下输出：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Pros and cons
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: CommonJS has a concise and expressive syntax. It's very easy to use. Unit tests
    are usually written to run in the command line and preferably are a part of continuous
    integration. A well-designed CommonJS module makes a perfect test unit, which
    you can access directly from a Node.js-driven test framework (for example, Mocha)
    far out of the application context. However, CommonJS implies synchronous loading,
    which is not suitable in a browser. If we want to bypass this limitation, we have
    to transpile module sources into a single script that resolves module dependencies
    internally without loading (see *"Traspiling CommonJS for in-browser use"*).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 拥有简洁而富有表现力的语法。它非常容易使用。单元测试通常编写成在命令行运行，最好是持续集成的一部分。一个设计良好的 CommonJS
    模块是一个完美的测试单元，您可以直接从 Node.js 驱动的测试框架（例如，Mocha）中访问，完全脱离应用程序上下文。然而，CommonJS 暗示了同步加载，这不适合在浏览器中使用。如果我们想绕过这个限制，我们必须将模块源代码编译成一个脚本，内部解决模块依赖关系而不加载（参见
    *"为浏览器使用编译 CommonJS"*）。
- en: UMD
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UMD
- en: If you want your module to be acceptable both in a browser as AMD and on the
    server as CommonJS, there is a trick ([https://github.com/umdjs/umd](https://github.com/umdjs/umd)).
    By adding a wrapper function, you can dynamically build the export in a desired
    format depending on the runtime environment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的模块既能在浏览器中作为 AMD 使用，又能在服务器上作为 CommonJS 使用，有一个技巧（[https://github.com/umdjs/umd](https://github.com/umdjs/umd)）。通过添加一个包装函数，你可以根据运行时环境动态构建所需的格式的导出。
- en: JavaScript's built-in module system
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 的内置模块系统
- en: Well, both AMD and CommonJS are community standards and not a part of the language
    specification. However, with EcmaScript 6th edition, JavaScript acquired its own
    module system. At the moment, no browser yet supports this feature, so we have
    to install the Babel.js transpiler to fiddle with the examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，AMD 和 CommonJS 都是社区标准，并不是语言规范的一部分。然而，随着 EcmaScript 第六版的推出，JavaScript 拥有了它自己的模块系统。目前，还没有浏览器支持这一特性，因此我们必须安装
    Babel.js 编译器来处理例子。
- en: 'Since we already have Node.js that is distributed with NPM (the Node.js package
    manager), we now can run the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 已经随 NPM 分发（NPM 是 Node.js 的包管理器），我们现在可以运行以下命令：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Named exports
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名导出
- en: 'Now we can write a module as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像下面这样编写一个模块：
- en: '**foo.es6**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.es6**'
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In ES6, we can export multiple elements. Any declaration prefixed with the
    keyword export becomes available for import:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，我们可以导出多个元素。任何用关键字 export 声明的变量或函数都可以被导入：
- en: '**main.es6**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.es6**'
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since we don''t yet have any support for ES6 modules in the browser, we will
    transpile them into CommonJS or AMD. Here Babel.js helps us:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前还没有在浏览器中支持 ES6 模块，我们将将它们转换为 CommonJS 或 AMD。在这里，Babel.js 帮助我们：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By this command, we made Babel.js translate all the `*.es6` files of the current
    directory into CommonJS modules. So, we can run the derived `main.js` module with
    Node.js:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个命令，我们让 Babel.js 将当前目录下的所有 `*.es6` 文件翻译成 CommonJS 模块。因此，我们可以用 Node.js 运行派生的
    `main.js` 模块：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Named exports](img/00004.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![命名导出](img/00004.jpeg)'
- en: 'Similarly, we translate ES6 modules to AMD:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将 ES6 模块转换为 AMD：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**index.html**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**index.html**'
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the previous example, we enlisted our named exports in the import statement.
    We could also import the entire module and refer to the named exports as properties:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们在导入语句中列出了我们的命名导出。我们也可以导入整个模块，并将命名导出作为属性引用：
- en: '**main.es6**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.es6**'
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Default export
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认导出
- en: 'Besides, we can also do a default export. This is how usually exports are done
    in Node.js:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认导出，我们还可以这样做。这是在 Node.js 中通常是如何进行导出的：
- en: '**foo.es6**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.es6**'
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**main.es6**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.es6**'
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We exported a function and came with the import. This could also be a class
    or an object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出了一个函数，并在导入时带来了它。这也可以是一个类或一个对象。
- en: 'In AMD, we receive exports as callback arguments, and in CommonJS, as local
    variables. Though ES6 doesn''t export values, but it exports the so called bindings
    (references) that are immutable. You can read their values, but if you try changing
    them, you get a type error. Babel.js triggers this error during compilation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AMD 中，我们将导出作为回调参数接收，而在 CommonJS 中，作为局部变量。尽管 ES6 没有导出值，但它导出了所谓的绑定（引用），这些引用是不可变的。您可以读取它们的值，但如果您尝试更改它们，您会得到一个类型错误。Babel.js
    在编译时触发这个错误：
- en: '**foo.es6**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.es6**'
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**main.es6**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.es6**'
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The module loader API
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块加载器 API
- en: 'In addition to declarative syntax in a separate specification ([https://github.com/whatwg/loader/](https://github.com/whatwg/loader/)),
    ES6 offers us a programmatic API. It allows us to programmatically work with modules
    and configure module loading:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在单独的规范中声明性语法([https://github.com/whatwg/loader/](https://github.com/whatwg/loader/))，ES6
    还为我们提供了一个程序化 API。它允许我们以编程方式处理模块并配置模块加载：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Unlike Node.js, the ES6 modules, due to their declarative nature, require imports
    and exports at the top level. So, this cannot be conditional. However, with the
    pragmatic loader API, we can do otherwise:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Node.js 不同，由于 ES6 模块的声明性特性，需要在顶层引入和导出。所以，这不能是条件性的。然而，有了实用的加载器 API，我们可以采取其他方式：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here we defined a callback that is invoked only when all of the three specified
    modules are loaded.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个回调函数，当三个指定的模块都加载完成后才会被调用。
- en: Conclusion
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Both AMD and CommonJS are interim standards. As soon as the JavaScript built-in
    module system gets wider support in script engines, we don't really need them
    anymore. The ES6 modules load asynchronously, and the loading can be configured
    similar to AMD. They also have a compact and expressive syntax and support for
    cyclic dependencies similar to CommonJS. In addition, ES provides declarative
    syntax for static module structure. Such structure can be statically analyzed
    (static checking, linting, optimization, and so on). ES6 also provides a programmatic
    loader API. So you can configure how modules are loaded and load modules conditionally.
    Besides, ES6 modules can be extended with macros and static types.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: AMD 和 CommonJS 都是过渡性标准。一旦 JavaScript 内置模块系统在脚本引擎中获得更广泛的支持，我们实际上就不再需要它们了。ES6
    模块异步加载，加载方式可以配置成类似于 AMD。它们还有紧凑且表达性强的语法，并支持类似于 CommonJS 的循环依赖。此外，ES 提供静态模块结构的声明性语法。这种结构可以被静态分析（静态检查、校验、优化等）。ES6
    还提供了一个程序化加载器 API。因此，您可以配置模块如何加载以及如何条件性加载模块。另外，ES6 模块可以与宏和静态类型扩展。
- en: While everything looks so unclouded, there is still a fly in the ointment. ES6
    modules can be pre-loaded synchronously (with `<script type="module"></script>`),
    but often there is asynchronous loading and this brings us to the same trap as
    in the case of AMD. Numerous requests over HTTP/1.1 cause a harmful effect on
    user response time ([https://developer.yahoo.com/performance/rules.html](https://developer.yahoo.com/performance/rules.html)).
    On the other hand, SPDY and HTTP/2 that allow multiple requests per TCP connection
    are getting wider support and eventually will take the place of the dubious HTTP/1.x.
    Furthermore, W3C works on a standard called *Packaging on the Web* ([https://w3ctag.github.io/packaging-on-the-web/](https://w3ctag.github.io/packaging-on-the-web/))
    that describes how archived files (scripts) can be accepted from a URL (hash).
    So, we will be able to bundle the entire directory with modules into an archive,
    deploy, and address them in the same way as we do when we have them in a directory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切看起来都很明朗，但仍有一只苍蝇在瓶中。ES6模块可以预先以同步方式加载（使用`<script type="module"></script>`），但通常会有异步加载，这让我们陷入了与AMD相同的陷阱中。HTTP/1.1上的多次HTTP请求对用户响应时间产生了有害影响
    ([https://developer.yahoo.com/performance/rules.html](https://developer.yahoo.com/performance/rules.html))。另一方面，SPDY和HTTP/2允许每个TCP连接发送多个请求，得到了更广泛的支持，并最终会取代可疑的HTTP/1.x。此外，W3C正在制定一个名为*Web上的打包*的标准
    ([https://w3ctag.github.io/packaging-on-the-web/](https://w3ctag.github.io/packaging-on-the-web/))，描述了如何从URL（哈希）接收归档文件（脚本）。因此，我们将能够将整个目录与模块一起打包成一个归档文件，部署它们，并以与将它们放在目录中相同的方式引用它们。
- en: Transpiling CommonJS for in-browser use
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为浏览器环境转换CommonJS
- en: While HTTP/2 and *Packaging on the Web* are still on their way, we need fast
    modular applications. As it was previously mentioned, we can divide the application
    code into CommonJS modules and transpile them for in-browser use. The most popular
    CommonJS transpiler is surely Browserify ([http://browserify.org](http://browserify.org)).
    The initial mission of this tool was to make Node.js modules reusable. They quite
    succeeded in this. It may feel like magic, but you can really use `EventEmitter`
    and some other Node.js core modules on the client. However, with the main focus
    on Node.js compatibility, the tool provides too few options for CommonJS compilation.
    For example, if you want dependency configuration, you have to use a plugin. In
    a real-world project, you will likely end up with multiple plugins, where each
    has a specific configuration syntax. So the setup in general gets over-complicated.
    Rather, we'll examine here another tool called CommonJS Compiler ([https://github.com/dsheiko/cjsc](https://github.com/dsheiko/cjsc)).
    This is a considerably small utility designed to bring CommonJS modules into the
    browser. The tool is very easy to configure and use, which makes it a good choice
    to illustrate the concept.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP/2和*Web上的打包*还在路上，我们需要快速的模块化应用程序。如前所述，我们可以将应用程序代码划分为CommonJS模块，并将它们转换为供浏览器使用。最受欢迎的CommonJS转换器无疑是Browserify
    ([http://browserify.org](http://browserify.org))。这个工具的最初任务是使Node.js模块可重用。他们在这一点上做得相当成功。这可能看起来像魔法，但你可以真正地在客户端使用`EventEmitter`和其他一些Node.js核心模块。然而，由于主要关注Node.js兼容性，该工具为CommonJS编译提供的选项太少。例如，如果你想进行依赖项配置，你必须使用一个插件。在实际项目中，你可能会最终使用多个插件，每个插件都有特定的配置语法。因此，总体设置变得过于复杂。相反，我们将在此处探讨另一个名为CommonJS
    Compiler ([https://github.com/dsheiko/cjsc](https://github.com/dsheiko/cjsc))的工具。这是一个相当小的实用程序，旨在将CommonJS模块带入浏览器。这个工具非常容易配置和使用，这使得它成为一个很好的选择来阐述这个概念。
- en: 'First of all, we install `cjsc`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们安装`cjsc`：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we can take an example from the *How to synchronous modules on the server*
    section and transpile it for in-browser use:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从*如何在服务器上同步模块*部分中取一个例子，并为浏览器环境转换它：
- en: '**bar.js**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**bar.js**'
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**foo.js**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.js**'
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**main.js**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.js**'
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The starting point is `main.js`. So, we tell `cjsc` to bundle this module with
    all the required dependencies recursively into `bundle.js`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 起点是`main.js`。因此，我们告诉`cjsc`将这个模块与所有必需的依赖递归地打包到`bundle.js`中：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![Transpiling CommonJS for in-browser use](img/00005.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![为浏览器环境转换CommonJS](img/00005.jpeg)'
- en: Let's take a look into the generated file. `cjsc` replaced all the require calls
    with `custom _require` and put them into the beginning `_require` function definition.
    This little trick allows you to run the compiled code in a Node.js/Io.js friendly
    environment such as NW.js, where the `require` function is still needed for local
    packages. Every module is wrapped in a function scope supplied with module relevant
    objects (exports and modules) plus global, which is a reference to the global
    object (`window`).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看生成的文件。`cjsc`用`custom _require`替换了所有的`require`调用，并将其放在了开头的`_require`函数定义中。这个小技巧让你可以在像NW.js这样的Node.js/Io.js友好环境中运行编译后的代码，在那里`require`函数仍然需要用于本地包。每个模块都被一个提供模块相关对象（exports和modules）以及全局对象的函数作用域（`window`）所包裹。
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The generated code is a generic JavaScript that we can surely address from
    the HTML:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码是通用JavaScript，我们肯定可以从HTML中对其进行定位：
- en: '**index.html**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**index.html**'
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Our sources are still in a CommonJS module. This means that we can access them
    directly from a Node.js-based framework for unit-testing. The official site for
    Mocha.js Test is [http://mochajs.org/](http://mochajs.org/):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的源代码仍然是CommonJS模块。这意味着我们可以在基于Node.js的框架中直接访问它们进行单元测试。Mocha.js测试的官方网站是[http://mochajs.org/](http://mochajs.org/)：
- en: '[PRE57]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`cjsc` has a number of options. But in a real project, typing a long command-line
    with every build would be annoying and unproductive:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`cjsc`有许多选项。但在实际项目中，每次构建都输入一个长命令行会令人厌烦且效率低下：'
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'That is why we use task runners such as `Grunt`, `Gulp`, `Cake`, and `Broccoli`.
    `Grunt` ([http://gruntjs.com](http://gruntjs.com)) is the most popular task runner
    at the moment and has an overwhelming number of plugins available (see the Grunt
    versus Gulp infographic at [http://sixrevisions.com/web-development/grunt-vs-gulp/](http://sixrevisions.com/web-development/grunt-vs-gulp/)).
    So, we install the `grunt` command-line interface globally:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用像`Grunt`、`Gulp`、`Cake`和`Broccoli`这样的任务运行器的原因就在于此。目前最受欢迎的任务运行器是`Grunt`([http://gruntjs.com](http://gruntjs.com))，它拥有大量的插件可供选择（参见[http://sixrevisions.com/web-development/grunt-vs-gulp/](http://sixrevisions.com/web-development/grunt-vs-gulp/)上的Grunt与Gulp对比信息图）。因此，我们需要将`grunt`命令行界面全局安装：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In order to setup a `Grunt` project, we need two configuration files, `package.json`
    ([https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json))
    and the `Gruntfile.js` file. The first one contains metadata about NPM packages
    required to run `Grunt` tasks. The second is needed to define and configure the
    tasks.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置一个`Grunt`项目，我们需要两个配置文件，`package.json`([https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json))和`Gruntfile.js`文件。第一个包含有关运行`Grunt`任务的NPM包的元数据。第二个用于定义和配置任务。
- en: 'Here we can start with a very minimalistic `package.json` that has only an
    arbitrary project name and its version in a semver ([http://semver.org/](http://semver.org/))
    format:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个非常简洁的`package.json`开始，其中只包含一个任意项目名及其版本，采用语义版本控制([http://semver.org/](http://semver.org/))格式：
- en: '**package,json**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**package.json**'
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we can install the required NPM packages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以安装所需NPM包：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Thus we get a local Grunt and a Grunt plugin for CommonJs compiler. The `--save-dev`
    special option creates `devDependencies` (if it doesn't exist) in the `package.json`
    section and populates it with the installed dependency. So for instance, when
    we pull the project sources from a version control system, we can restore all
    the dependencies by simply running `npm install`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就得到了一个本地的Grunt和一个CommonJs编译器的Grunt插件。特殊的`--save-dev`选项在`package.json`部分创建`devDependencies`（如果不存在），并将其填充为已安装的依赖项。例如，当我们从版本控制系统拉取项目源代码时，我们可以通过简单地运行`npm
    install`来恢复所有依赖项。
- en: 'In `Gruntfile.js`, we have to load the already installed `grunt-cjsc` plugin
    and configure a task called `cjsc`. In practice, we will need at least two targets
    that provide different configurations for this task. The first one, `cjsc:debug`,
    runs `cjsc` to produce uncompressed code, provided with source map. The second
    one, `cjsc:build` is used to prepare assets for deployment. So we get minified
    code in `bundle.js`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Gruntfile.js`中，我们必须加载已经安装的`grunt-cjsc`插件，并配置一个名为`cjsc`的任务。实际上，我们将需要至少两个目标，为这个任务提供不同的配置。第一个，`cjsc:debug`，运行`cjsc`以生成未压缩的代码，并提供源映射。第二个，`cjsc:build`，用于准备部署资产。所以我们得到了`bundle.js`中的压缩代码：
- en: '**Gruntfile.js**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gruntfile.js**'
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see from the configuration, `cjsc` is intended to `transpile js/src/main.js`
    into `js/bundle.js`. So we can take the module of the previous example and copy
    them into `./js/src`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置中，我们可以看到`cjsc`旨在将`js/src/main.js``transpile`成`js/bundle.js`。因此，我们可以将前面示例中的模块复制到`./js/src`。
- en: 'Now, when we have everything in place, we will run a task. For example, see
    the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一切准备就绪后，我们将运行一个任务。例如，请看以下内容：
- en: '[PRE63]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![Transpiling CommonJS for in-browser use](img/00006.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![将 CommonJS 转译以供浏览器使用](img/00006.jpeg)'
- en: 'As mentioned earlier, we can configure dependency mapping with `cjsc`. We just
    need to describe the dependencies in an object literal that can be supplied to
    `cjsc` as a JSON-file in the command-line interface or injected into a Grunt configuration:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用 `cjsc` 配置依赖映射。我们只需在一个对象字面量中描述依赖项，该字面量可以作为 JSON 文件通过命令行界面提供给 `cjsc`，或注入到
    Grunt 配置中：
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here we declare the `jquery` alias (shortcut) for a module located in `./vendors/jQuery/jqueiry.js`.
    We also state that a globally exposed `"_"` (Underscore.js) library has to be
    treated as a module. At the end, we specify the path, exports, and imports for
    a third-party component. Thus, we get this in the app (without intervention in
    its code) as a module, though it''s not a module:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了位于 `./vendors/jQuery/jqueiry.js` 的模块的 `jquery` 别名（快捷方式）。我们还说明了一个全局暴露的
    `"_"`（Underscore.js）库必须被视为一个模块。最后，我们指定了第三方组件的路径、导出和导入。因此，我们得到了这个在应用（不干预其代码）中作为一个模块的
    this，尽管它不是一个模块：
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Alternatively we can use the following Grunt configuration:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用以下 Grunt 配置：
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Bundling ES6 modules for synchronous loading
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 ES6 模块捆绑以实现同步加载
- en: 'Well, as we mentioned in the *JavaScript built-in module system* section, ES6
    modules are going to be replace the AMD and CommonJS standards. Moreover, we can
    already write ES6 code and transpile it into ES5 for now. As soon as the support
    for ES6 across script agents is good enough, we theoretically can use our code
    as it is. However, what about performance? In fact, we can compile ES6 modules
    in CommonJS and then bundle them with `cjsc` for in-browser use:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，正如我们在*JavaScript 内置模块系统*部分提到的，ES6 模块将会取代 AMD 和 CommonJS 标准。而且，我们现在就可以写 ES6
    代码并将其转译为 ES5。一旦支持 ES6 的脚本代理足够好，我们从理论上可以使用我们的代码。然而，性能呢？实际上，我们可以将 ES6 模块编译成 CommonJS
    并然后用 `cjsc` 捆绑它们以供浏览器使用：
- en: '**foo.es6**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.es6**'
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '**main.es6**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.es6**'
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'First, we compile ES6 into CommonJS modules:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 ES6 编译成 CommonJS 模块：
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, we bundle CommonJS modules into a script suitable for in-browser use:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 CommonJS 模块捆绑成一个适合浏览器使用的脚本：
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Modular programming is a concept closely related to OOP that encourages us to
    structure code for better maintainability. In particular, JavaScript modules protect
    global scope from pollution, divide application code into multiple files, and
    allow the reuse of application components.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程是与面向对象编程紧密相关的一个概念，它鼓励我们为更好的可维护性来结构化代码。特别是，JavaScript 模块保护全局作用域免受污染，将应用程序代码分成多个文件，并允许重用应用程序组件。
- en: The two module API standards that are mostly used at the moment are AMD and
    CommonJS. The first one that is designed for in-browser use assumes asynchronous
    loading. The second is synchronous and intended for server-side JavaScript. However,
    you should know that AMD has a substantial flaw. A well-grained application design
    with a plenty of modules over HTTP/1.1 may cause a disaster in terms of application
    performance. This is the major reason why, recently, the practice of transpiling
    CommonJS modules for in-browser use is on the rise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数使用的两个模块 API 标准是 AMD 和 CommonJS。第一个是为浏览器使用而设计的，假设异步加载。第二个是同步的，适用于服务器端 JavaScript。然而，你应该知道
    AMD 有的重大缺陷。一个细粒度的应用程序设计，拥有大量的通过 HTTP/1.1 的模块，可能会在应用程序性能方面造成灾难。这是最近将 CommonJS 模块转译为浏览器使用实践日益增多的主要原因。
- en: Both these APIs shall be considered as interim standards because the upcoming
    ES6 modules standard is meant to replace them. At the moment, there are no script
    engines supporting this feature, but there are transpilers (for example, Babel.js)
    that allows the translation of ES6 modules into CommonJs or AMD.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 API 都应被视为过渡性标准，因为即将到来的 ES6 模块标准旨在取代它们。目前，没有脚本引擎支持这一功能，但有一些转译器（例如，Babel.js）允许将
    ES6 模块转译成 CommonJS 或 AMD。
