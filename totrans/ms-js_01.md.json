["```js\n<!DOCTYPE html>\n<html>\n<head>\n <script type=\"text/javascript\" src=\"img/script.js\"></script>\n <script type=\"text/javascript\">\n var x = \"Hello World\";\n console.log(x);\n </script>\n</head>\n<body>\n</body>\n</html>\n```", "```js\n<script type=\"text/javascript\" src=\"img/script.js\"></script>\n```", "```js\nEN-VedA:~$ node\n>function greeter(){\n  x=\"World\"l\nSyntaxError: Unexpected identifier\n at Object.exports.createScript (vm.js:44:10)\n at REPLServer.defaultEval (repl.js:117:23)\n at bound (domain.js:254:14)\n …\n\n```", "```js\nfunction sayHello(what) {\n  return \"Hello \" + what;\n}\nconsole.log(sayHello(\"world\"));\n```", "```js\n// a one line comment\n\n/* this is a longer, \n   multi-line comment\n */\n\n/* You can't /* nest comments */ SyntaxError */\n```", "```js\nvar a;      //declares a variable but its undefined\nvar b = 0;\nconsole.log(b);    //0\nconsole.log(a);    //undefined\nconsole.log(a+b);  //NaN\n```", "```js\nconst area_code = '515';\n```", "```js\nvar aNumber = 555;\n```", "```js\nvar aFloat = 555.0;\n```", "```js\nEN-VedA:~$ node\n> 0.1+0.2\n0.30000000000000004\n> (0.1+0.2)===0.3\nfalse\n\n```", "```js\nEN-VedA:~ $ node\n> isNaN(NaN);\ntrue\n> NaN==NaN;\nfalse\n> isNaN(\"elephant\");\ntrue\n> NaN+5;\nNaN\n\n```", "```js\n> Math.E\n2.718281828459045\n> Math.SQRT2\n1.4142135623730951\n> Math.abs(-900)\n900\n> Math.pow(2,3)\n8\n\n```", "```js\n> parseInt(\"230\",10);\n230\n> parseInt(\"010\",10);\n10\n> parseInt(\"010\",8); //octal base\n8\n> parseInt(\"010\",2); //binary\n2\n> + \"4\"\n4\n\n```", "```js\nvar underterminedValue = \"elephant\";\nif (isNaN(parseInt(underterminedValue,2))) \n{\n   console.log(\"handle not a number case\");\n}\nelse\n{\n   console.log(\"handle number case\");\n}\n```", "```js\n> console.log(\"Hippopotamus chewing gum\");\nHippopotamus chewing gum\n> console.log('Single quoted hippopotamus');\nSingle quoted hippopotamus\n> console.log(\"Broken \\n lines\");\nBroken\n lines\n```", "```js\n> '\\xA9'\n'©'\n> '\\u00A9'\n'©'\n\n```", "```js\nvar s = new String(\"dummy\"); //Creates a String object\nconsole.log(s); //\"dummy\"\nconsole.log(typeof s); //\"object\"\nvar nonObject = \"1\" + \"2\"; //Create a String primitive \nconsole.log(typeof nonObject); //\"string\"\nvar objString = new String(\"1\" + \"2\"); //Creates a String object\nconsole.log(typeof objString); //\"object\"\n//Helper functions\nconsole.log(\"Hello\".length); //5\nconsole.log(\"Hello\".charAt(0)); //\"H\"\nconsole.log(\"Hello\".charAt(1)); //\"e\"\nconsole.log(\"Hello\".indexOf(\"e\")); //1\nconsole.log(\"Hello\".lastIndexOf(\"l\")); //3\nconsole.log(\"Hello\".startsWith(\"H\")); //true\nconsole.log(\"Hello\".endsWith(\"o\")); //true\nconsole.log(\"Hello\".includes(\"X\")); //false\nvar splitStringByWords = \"Hello World\".split(\" \");\nconsole.log(splitStringByWords); //[\"Hello\", \"World\"]\nvar splitStringByChars = \"Hello World\".split(\"\");\nconsole.log(splitStringByChars); //[\"H\", \"e\", \"l\", \"l\", \"o\", \" \", \"W\", \"o\", \"r\", \"l\", \"d\"]\nconsole.log(\"lowercasestring\".toUpperCase()); //\"LOWERCASESTRING\"\nconsole.log(\"UPPPERCASESTRING\".toLowerCase()); //\"upppercasestring\"\nconsole.log(\"There are no spaces in the end     \".trim()); //\"There are no spaces in the end\"\n```", "```js (Grave accent—[https://en.wikipedia.org/wiki/Grave_accent](https://en.wikipedia.org/wiki/Grave_accent)) are considered multiline. Let's see the following example:\n\n```", "```js\n\nThis kind of string is also known as a template string and can be used for string interpolation. JavaScript allows Python-like string interpolation using this syntax.\n\nNormally, you would do something similar to the following:\n\n```", "```js\n\nHowever, with string interpolation, things become a bit clearer:\n\n```", "```js\n\n### Undefined values\n\nJavaScript indicates an absence of meaningful values by two special values—null, when the non-value is deliberate, and undefined, when the value is not assigned to the variable yet. Let's see the following example:\n\n```", "```js\n\n### Booleans\n\nJavaScript Boolean primitives are represented by `true` and `false` keywords. The following rules govern what becomes false and what turns out to be true:\n\n*   False, 0, the empty string (\"\"), NaN, null, and undefined are represented as false\n*   Everything else is true\n\nJavaScript Booleans are tricky primarily because the behavior is radically different in the way you create them.\n\nThere are two ways in which you can create Booleans in JavaScript:\n\n*   You can create primitive Booleans by assigning a true or false literal to a variable. Consider the following example:\n\n    ```", "```js\n\n*   Use the `Boolean()` function; this is an ordinary function that returns a primitive Boolean:\n\n    ```", "```js\n\nBoth these methods return expected *truthy* or *falsy* values. However, if you create a Boolean object using the `new` operator, things can go really wrong.\n\nEssentially, when you use the `new` operator and the `Boolean(value)` constructor, you don't get a primitive `true` or `false` in return, you get an object instead—and unfortunately, JavaScript considers an object as *truthy*:\n\n```", "```js\n\nSo, the smart thing to do is to always avoid Boolean constructors to create a new Boolean object. It breaks the fundamental contract of Boolean logic and you should stay away from such difficult-to-debug buggy code.\n\n### The instanceof operator\n\nOne of the problems with using reference types to store values has been the use of the **typeof** operator, which returns `object` no matter what type of object is being referenced. To provide a solution, you can use the **instanceof** operator. Let's see some examples:\n\n```", "```js\n\nThe third line returns `false`. We will discuss why this is the case when we discuss prototype chains.\n\n### Date objects\n\nJavaScript does not have a date data type. Instead, you can use the **Date** object and its methods to work with dates and times in your applications. A Date object is pretty exhaustive and contains several methods to handle most date- and time-related use cases.\n\nJavaScript treats dates similarly to Java. JavaScript store dates as the number of milliseconds since January 1, 1970, 00:00:00.\n\nYou can create a Date object using the following declaration:\n\n```", "```js\n\nThe parameters for the Date object constructors can be as follows:\n\n*   No parameters creates today's date and time. For example, `var today = new Date();`.\n*   A String representing a date as `Month day, year hours:minutes:seconds`. For example, `var twoThousandFifteen = new Date(\"December 31, 2015 23:59:59\");`. If you omit hours, minutes, or seconds, the value will be set to `0`.\n*   A set of integer values for the year, month, and day. For example, `var christmas = new Date(2015, 11, 25);`.\n*   A set of integer values for the year, month, day, hour, minute, and seconds. For example, `var christmas = new Date(2015, 11, 25, 21, 00, 0);`.\n\nHere are some examples on how to create and manipulate dates in JavaScript:\n\n```", "```js\n\nFor any serious applications that require fine-grained control over date and time objects, we recommend using libraries such as **Moment.js** ([https://github.com/moment/moment](https://github.com/moment/moment)), **Timezone.js** ([https://github.com/mde/timezone-js](https://github.com/mde/timezone-js)), or **date.js** ([https://github.com/MatthewMueller/date](https://github.com/MatthewMueller/date)). These libraries simplify a lot of recurrent tasks for you and help you focus on other important things.\n\n### The + operator\n\nThe **+** operator, when used as a unary, does not have any effect on a number. However, when applied to a String, the + operator converts it to numbers as follows:\n\n```", "```js\n\nThe + operator is used often by a programmer to quickly convert a numeric representation of a String to a number. However, if the String literal is not something that can be converted to a number, you get slightly unpredictable results as follows:\n\n```", "```js\n\nWe will discuss the effects of the + operator on several other data types later in the text.\n\n### The ++ and -- operators\n\nThe ++ operator is a shorthand version of adding `1` to a value and -- is a shorthand to subtract `1` from a value. Java and C have equivalent operators and most will be familiar with them. How about this?\n\n```", "```js\n\nErr, what happened here? Shouldn't the `b` variable have the value `2`? The ++ and -- operators are unary operators that can be used either prefix or postfix. The order in which they are used matters. When ++ is used in the prefix position as `++a`, it increments the value before the value is returned from the expression rather than after as with `a++`. Let's see the following code:\n\n```", "```js\n\nMany programmers use the chained assignments to assign a single value to multiple variables as follows:\n\n```", "```js\n\nThis is fine because the assignment operator (=) results in the value being assigned. In this case, `c=0` is evaluated to `0`; this would result in `b=0`, which also evaluates to `0`, and hence, `a=0` is evaluated.\n\nHowever, a slight change to the previous example yields extraordinary results. Consider this:\n\n```", "```js\n\nIn this case, only the `a` variable is declared with `var`, while the `b` variable is created as an accidental global. (If you are in the strict mode, you will get an error for this.) With JavaScript, be careful what you wish for, you might get it.\n\n### Boolean operators\n\nThere are three Boolean operators in JavaScript—AND(&), OR(|), and NOT(!).\n\nBefore we discuss logical AND and OR operators, we need to understand how they produce a Boolean result. Logical operators are evaluated from left to right and they are tested using the following short-circuit rules:\n\n*   **Logical AND**: If the first operand determines the result, the second operand is not evaluated.\n\n    In the following example, I have highlighted the right-hand side expression if it gets executed as part of short-circuit evaluation rules:\n\n    ```", "```js\n\n*   **Logical OR**: If the first operand is true, the second operand is not evaluated:\n\n    ```", "```js\n\n    However, both logical AND and logical OR can also be used for non-Boolean operands. When either the left or right operand is not a primitive Boolean value, AND and OR do not return Boolean values.\n\nNow we will explain the three logical Boolean operators:\n\n*   Logical AND(&&): If the first operand object is *falsy*, it returns that object. If its *truthy*, the second operand object is returned:\n\n    ```", "```js\n\n*   Logical OR(||): If the first operand is *truthy*, it's returned. Otherwise, the second operand is returned:\n\n    ```", "```js\n\n    The typical use of a logical OR is to assign a default value to a variable:\n\n    ```", "```js\n\n    You will see this pattern frequently in most professional JavaScript libraries. You should understand how the defaulting is done by using a logical OR operator.\n\n*   **Logical NOT**: This always returns a Boolean value. The value returned depends on the following:\n\n    ```", "```js\n\nAdditionally, JavaScript supports C-like ternary operators as follows:\n\n```", "```js\n\nIf `(age>21)`, the expression after `?` will be assigned to the `allowedToDrive` variable and the expression after `:` is assigned otherwise. This is equivalent to an if-else conditional statement. Let's see another example:\n\n```", "```js\n\nIn this example, the `isAllowedToDrive()` function accepts one integer parameter, `age`. Based on the value of this variable, we return true or false to the calling function. This is a well-known and most familiar if-else conditional logic. Most of the time, if-else keeps the code easier to read. For simpler cases of single conditions, using the ternary operator is also okay, but if you see that you are using the ternary operator for more complicated expressions, try to stick with if-else because it is easier to interpret if-else conditions than a very complex ternary expression.\n\nIf-else conditional statements can be nested as follows:\n\n```", "```js\n\nPurely as a matter of taste, you can indent the nested `else if` as follows:\n\n```", "```js\n\nDo not use assignments in place of a conditional statement. Most of the time, they are used because of a mistake as follows:\n\n```", "```js\n\nMostly, this happens by mistake; the intended code was `if(a==b)`, or better, `if(a===b)`. When you make this mistake and replace a conditional statement with an assignment statement, you end up committing a very difficult-to-find bug. However, if you really want to use an assignment statement with an if statement, make sure that you make your intentions very clear.\n\nOne way is to put extra parentheses around your assignment statement:\n\n```", "```js\n\nAnother way to handle conditional execution is to use switch-case statements. The switch-case construct in JavaScript is similar to that in C or Java. Let's see the following example:\n\n```", "```js\n\nOne problem with this structure is that you have `break` out of every case; otherwise, the execution will fall through to the next level. If we remove the `break` statement from the first case statement, the output will be as follows:\n\n```", "```js\n\nAs you can see, if we omit the `break` statement to break the execution immediately after a condition is satisfied, the execution sequence follows to the next level. This can lead to difficult-to-detect problems in your code. However, this is also a popular style of writing conditional logic if you intend to fall through to the next level:\n\n```", "```js\n\nIn this example, we are intentionally letting the execution fall through to write a concise switch-case. If levels are either INFO, WARN, or DEBUG, we use the switch-case to fall through to a single point of execution. We omit the `break` statement for this. If you want to follow this pattern of writing switch statements, make sure that you document your usage for better readability.\n\nSwitch statements can have a `default` case to handle any value that cannot be evaluated by any other case.\n\nJavaScript has a while and do-while loop. The while loop lets you iterate a set of expressions till a condition is met. The following first example iterates the statements enclosed within `{}` till the `i<10` expression is true. Remember that if the value of the `i` counter is already greater than `10`, the loop will not execute at all:\n\n```", "```js\n\nThe following loop keeps executing till infinity because the condition is always true—this can lead to disastrous effects. Your program can use up all your memory or something equally unpleasant:\n\n```", "```js\n\nIf you want to make sure that you execute the loop at least once, you can use the do-while loop (sometimes known as a post-condition loop):\n\n```", "```js\n\nIn this example, we are asking the user for an input till we find a valid input from the user. While the user types invalid input, we keep asking for an input to the user. It is always argued that, logically, every do-while loop can be transformed into a while loop. However, a do-while loop has a very valid use case like the one we just saw where you want the condition to be checked only after there has been one execution of the loop block.\n\nJavaScript has a very powerful loop similar to C or Java—the for loop. The for loop is popular because it allows you to define the control conditions of the loop in a single line.\n\nThe following example prints `Hello` five times:\n\n```", "```js\n\nWithin the definition of the loop, you defined the initial value of the loop counter `i` to be `0`, you defined the `i<5` exit condition, and finally, you defined the increment factor.\n\nAll three expressions in the previous example are optional. You can omit them if required. For example, the following variations are all going to produce the same result as the previous loop:\n\n```", "```js\n\nYou can also omit all three of these expressions and write for loops. One interesting idiom used frequently is to use for loops with empty statements. The following loop is used to set all the elements of the array to `100`. Notice how there is no body to the for-loop:\n\n```", "```js\n\nThe empty statement here is just the single that we see after the for loop statement. The increment factor also modifies the array content. We will discuss arrays later in the book, but here it's sufficient to see that the array elements are set to the `100` value within the loop definition itself.\n\n### Equality\n\nJavaScript offers two modes of equality—strict and loose. Essentially, loose equality will perform the type conversion when comparing two values, while strict equality will check the values without any type conversion. A strict equality check is performed by === while a loose equality check is performed by ==.\n\nECMAScript 6 also offers the `Object.is` method to do a strict equality check like ===. However, `Object.is` has a special handling for NaN: -0 and +0\\. When *NaN===NaN* and *NaN==NaN* evaluates to false, `Object.is(NaN,NaN)` will return true.\n\n#### Strict equality using ===\n\nStrict equality compares two values without any implicit type conversions. The following rules apply:\n\n*   If the values are of a different type, they are unequal.\n*   For non-numerical values of the same type, they are equal if their values are the same.\n*   For primitive numbers, strict equality works for values. If the values are the same, === results in `true`. However, a NaN doesn't equal to any number and `NaN===<a number>` would be a `false`.\n\nStrict equality is always the correct equality check to use. Make it a rule to always use === instead of ==:\n\n| Condition | Output |\n| --- | --- |\n| `\"\" === \"0\"` | false |\n| `0 === \"\"` | false |\n| `0 === \"0\"` | false |\n| `false === \"false\"` | false |\n| `false === \"0\"` | false |\n| `false === undefined` | false |\n| `false === null` | false |\n| `null === undefined` | false |\n\nIn case of comparing objects, we get results as follows:\n\n| Condition | Output |\n| --- | --- |\n| `{} === {};` | false |\n| `new String('bah') === 'bah';` | false |\n| `new Number(1) === 1;` | false |\n| `var bar = {};``bar === bar;` | true |\n\nThe following are further examples that you should try on either JS Bin or Node REPL:\n\n```", "```js\n\nYou can use `!==` to handle the **Not Equal To** case while doing strict equality checks.\n\n#### Weak equality using ==\n\nNothing should tempt you to use this form of equality. Seriously, stay away from this form. There are many bad things with this form of equality primarily due to the weak typing in JavaScript. The equality operator, ==, first tries to coerce the type before doing a comparison. The following examples show you how this works:\n\n| Condition | Output |\n| --- | --- |\n| `\"\" == \"0\"` | false |\n| `0 == \"\"` | true |\n| `0 == \"0\"` | true |\n| `false == \"false\"` | false |\n| `false == \"0\"` | true |\n| `false == undefined` | false |\n| `false == null` | false |\n| `null == undefined` | true |\n\nFrom these examples, it's evident that weak equality can result in unexpected outcomes. Also, implicit type coercion is costly in terms of performance. So, in general, stay away from weak equality in JavaScript.\n\n## JavaScript types\n\nWe briefly discussed that JavaScript is a dynamic language. If you have a previous experience of strongly typed languages such as Java, you may feel a bit uncomfortable about the complete lack of type checks that you are used to. Purists argue that JavaScript should claim to have **tags** or perhaps **subtypes**, but not types. Though JavaScript does not have the traditional definition of **types**, it is absolutely essential to understand how JavaScript handles data types and coercion internally. Every nontrivial JavaScript program will need to handle value coercion in some form, so it's important that you understand the concept well.\n\nExplicit coercion happens when you modify the type yourself. In the following example, you will convert a number to a String using the `toString()` method and extract the second character out of it:\n\n```", "```js\n\nThis is an example of an explicit type conversion. Again, we are using the word **type** loosely because type was not enforced anywhere when you declared the `fortyTwo` variable.\n\nHowever, there are many different ways in which such coercion can happen. Coercion happening explicitly can be easy to understand and mostly reliable; but if you're not careful, coercion can happen in very strange and surprising ways.\n\nConfusion around coercion is perhaps one of the most talked about frustrations for JavaScript developers. To make sure that you never have this confusion in your mind, let's revisit types in JavaScript. We talked about some concepts earlier:\n\n```", "```js\n\nSo far, so good. We already knew this and the examples that we just saw reinforce our ideas about types.\n\nConversion of a value from one type to another is called **casting** or explicit coercion. JavaScript also does implicit coercion by changing the type of a value based on certain guesses. These guesses make JavaScript work around several cases and unfortunately make it fail quietly and unexpectedly. The following snippet shows cases of explicit and implicit coercion:\n\n```", "```js\n\nIt is easy to see what is happening here. When you use `\"\"+t` to a numeric value of `t` (`1`, in this case), JavaScript figures out that you are trying to concatenate *something* with a `\"\"` string. As only strings can be concatenated with other strings, JavaScript goes ahead and converts a numeric `1` to a `\"1\"` string and concatenates both into a resulting string value. This is what happens when JavaScript is asked to convert values implicitly. However, `String(t)` is a very deliberate call to convert a number to a String. This is an explicit conversion of types. The last bit is surprising. We are concatenating `null` with `\"\"`—shouldn't this fail?\n\nSo how does JavaScript do type conversions? How will an abstract value become a String or number or Boolean? JavaScript relies on `toString()`, `toNumber()`, and `toBoolean()` methods to do this internally.\n\nWhen a non-String value is coerced into a String, JavaScript uses the `toString()` method internally to do this. All primitives have a natural string form—null has a string form of `\"null\"`, undefined has a string form of `\"undefined\"`, and so on. For Java developers, this is analogous to a class having a `toString()` method that returns a string representation of the class. We will see exactly how this works in case of objects.\n\nSo essentially you can do something similar to the following:\n\n```", "```js\n\n```", "```js\n\nWhen any non-number value needs to be coerced into a number, JavaScript uses the `toNumber()` method internally: `true` becomes `1`, `undefined` becomes `NaN`, `false` becomes `0`, and `null` becomes `0`. The `toNumber()` method on strings works with literal conversion and if this fails, the method returns `NaN`.\n\nWhat about some other cases?\n\n```", "```js\n\nWell, null is an object? Yes, an especially long-lasting bug makes this possible. Due to this bug, you need to be careful while testing if a value is null:\n\n```", "```js\n\nWhat about other things that may have types, such as functions?\n\n```", "```js\n\nWhat about arrays?\n\n```", "```js\n\nSure enough, they are also objects. We will take a detailed look at functions and arrays later in the book.\n\nIn JavaScript, values have types, variables don't. Due to the dynamic nature of the language, variables can hold any value at any time.\n\nJavaScript doesn't does not enforce types, which means that the language doesn't insist that a variable always hold values of the same initial type that it starts out with. A variable can hold a String, and in the next assignment, hold a number, and so on:\n\n```", "```js\n\nThe `typeof` operator always returns a String:\n\n```", "```js\n\n## Automatic semicolon insertion\n\nAlthough JavaScript is based on the C style syntax, it does not enforce the use of semicolons in the source code.\n\nHowever, JavaScript is not a semicolon-less language. A JavaScript language parser needs the semicolons in order to understand the source code. Therefore, the JavaScript parser automatically inserts them whenever it encounters a parse error due to a missing semicolon. It's important to note that **automatic semicolon insertion** (**ASI**) will only take effect in the presence of a newline (also known as a line break). Semicolons are not inserted in the middle of a line.\n\nBasically, if the JavaScript parser parses a line where a parser error would occur (a missing expected ;) and it can insert one, it does so. What are the criteria to insert a semicolon? Only if there's nothing but white space and/or comments between the end of some statement and that line's newline/line break.\n\nThere have been raging debates on ASI—a feature justifiably considered to be a very bad design choice. There have been epic discussions on the Internet, such as [https://github.com/twbs/bootstrap/issues/3057](https://github.com/twbs/bootstrap/issues/3057) and [https://brendaneich.com/2012/04/the-infernal-semicolon/](https://brendaneich.com/2012/04/the-infernal-semicolon/).\n\nBefore you judge the validity of these arguments, you need to understand what is affected by ASI. The following statements are affected by ASI:\n\n*   An empty statement\n*   A var statement\n*   An expression statement\n*   A do-while statement\n*   A continue statement\n*   A break statement\n*   A return statement\n*   A throw statement\n\nThe idea behind ASI is to make semicolons optional at the end of a line. This way, ASI helps the parser to determine when a statement ends. Normally, it ends with a semicolon. ASI dictates that a statement also ends in the following cases:\n\n*   A line terminator (for example, a newline) is followed by an illegal token\n*   A closing brace is encountered\n*   The end of the file has been reached\n\nLet's see the following example:\n\n```", "```js\n\nThe `console` token is illegal after `1` and triggers ASI as follows:\n\n```", "```js\n\nIn the following code, the statement inside the braces is not terminated by a semicolon:\n\n```", "```js\n\nASI creates a syntactically correct version of the preceding code:\n\n```", "```js\n\n## JavaScript style guide\n\nEvery programming language develops its own style and structure. Unfortunately, new developers don't put much effort in learning the stylistic nuances of a language. It is very difficult to develop this skill later once you have acquired bad practices. To produce beautiful, readable, and easily maintainable code, it is important to learn the correct style. There are a ton of style suggestions. We will be picking the most practical ones. Whenever applicable, we will discuss the appropriate style. Let's set some stylistic ground rules.\n\n### Whitespaces\n\nThough whitespace is not important in JavaScript, the correct use of whitespace can make the code easy to read. The following guidelines will help in managing whitespaces in your code:\n\n*   Never mix spaces and tabs.\n*   Before you write any code, choose between soft indents (spaces) or real tabs. For readability, I always recommend that you set your editor's indent size to two characters—this means two spaces or two spaces representing a real tab.\n*   Always work with the *show invisibles* setting turned on. The benefits of this practice are as follows:\n\n    *   Enforced consistency.\n    *   Eliminates the end-of-line white spaces.\n    *   Eliminates blank line white spaces.\n    *   Commits and diffs that are easier to read.\n    *   Uses **EditorConfig** ([http://editorconfig.org/](http://editorconfig.org/)) when possible.\n\n### Parentheses, line breaks, and braces\n\nIf, else, for, while, and try always have spaces and braces and span multiple lines. This style encourages readability. Let's see the following code:\n\n```", "```js\n\n### Quotes\n\nWhether you prefer single or double quotes shouldn't matter; there is no difference in how JavaScript parses them. However, for the sake of consistency, never mix quotes in the same project. Pick one style and stick with it.\n\n### End of lines and empty lines\n\nWhitespace can make it impossible to decipher code diffs and changelists. Many editors allow you to automatically remove extra empty lines and end of lines—you should use these.\n\n### Type checking\n\nChecking the type of a variable can be done as follows:\n\n```", "```js\n\n### Type casting\n\nPerform type coercion at the beginning of the statement as follows:\n\n```", "```js\n\nUse `parseInt()` for Numbers and always with a radix for the type casting:\n\n```", "```js\n\nThe following example shows you how to type cast using Booleans:\n\n```", "```js\n\n### Conditional evaluation\n\nThere are various stylistic guidelines around conditional statements. Let's study the following code:\n\n```", "```js\n\n### Naming\n\nNaming is super important. I am sure that you have encountered code with terse and undecipherable naming. Let's study the following lines of code:\n\n```", "```js\n\n### The eval() method is evil\n\n```", "```js\n\n```", "```js\n\nI will refrain from showing other uses of `eval()` and make sure that you are discouraged enough to stay away from it.\n\n### The strict mode\n\nECMAScript 5 has a strict mode that results in cleaner JavaScript, with fewer unsafe features, more warnings, and more logical behavior. The normal (non-strict) mode is also called **sloppy mode**. The strict mode can help you avoid a few sloppy programming practices. If you are starting a new JavaScript project, I would highly recommend that you use the strict mode by default.\n\nYou switch on the strict mode by typing the following line first in your JavaScript file or in your `<script>` element:\n\n```", "```js\n\nNote that JavaScript engines that don't support ECMAScript 5 will simply ignore the preceding statement and continue as non-strict mode.\n\nIf you want to switch on the strict mode per function, you can do it as follows:\n\n```", "```js\n\nThis is handy when you are working with a legacy code base where switching on the strict mode everywhere may break things.\n\nIf you are working on an existing legacy code, be careful because using the strict mode can break things. There are caveats on this:\n\n#### Enabling the strict mode for an existing code can break it\n\nThe code may rely on a feature that is not available anymore or on behavior that is different in a sloppy mode than in a strict mode. Don't forget that you have the option to add single strict mode functions to files that are in the sloppy mode.\n\n#### Package with care\n\nWhen you concatenate and/or minify files, you have to be careful that the strict mode isn't switched off where it should be switched on or vice versa. Both can break code.\n\nThe following sections explain the strict mode features in more detail. You normally don't need to know them as you will mostly get warnings for things that you shouldn't do anyway.\n\n#### Variables must be declared in strict mode\n\nAll variables must be explicitly declared in strict mode. This helps to prevent typos. In the sloppy mode, assigning to an undeclared variable creates a global variable:\n\n```", "```js\n\nIn the strict mode, assigning to an undeclared variable throws an exception:\n\n```", "```js\n\n##### The eval() function is cleaner in strict mode\n\nIn strict mode, the `eval()` function becomes less quirky: variables declared in the evaluated string are not added to the scope surrounding `eval()` anymore.\n\n#### Features that are blocked in strict mode\n\nThe with statement is not allowed. (We will discuss this in the book later.) You get a syntax error at compile time (when loading the code).\n\nIn the sloppy mode, an integer with a leading zero is interpreted as octal (base 8) as follows:\n\n```", "```js\n\nIn strict mode, you get a syntax error if you use this kind of literal:\n\n```", "```js\n\n### Running JSHint\n\n**JSHint** is a program that flags suspicious usage in programs written in JavaScript. The core project consists of a library itself as well as a **command line interface** (**CLI**) program distributed as a Node module.\n\nIf you have Node.js installed, you can install JSHint using `npm` as follows:\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\nWhen we run the file using JSHint, it will warn us of a missing `break` statement in the switch case as follows:\n\n```", "```js\n\nJSHint is configurable to suit your needs. Check the documentation at [http://jshint.com/docs/](http://jshint.com/docs/) to see how you can customize JSHint according to your project needs. I use JSHint extensively and suggest you start using it. You will be surprised to see how many hidden bugs and stylistic issues you will be able to fix in your code with such a simple tool.\n\nYou can run JSHint at the root of your project and lint the entire project. You can place JSHint directives in the `.jshintrc` file. This file may look something as follows:\n\n```"]