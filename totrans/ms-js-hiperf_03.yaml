- en: Chapter 3. Understanding JavaScript Build Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about JavaScript build systems and their advantages
    for JavaScript performance testing and deployment. We will also incorporate JavaScript
    code testing into our build system using the knowledge we gained about JSLint
    in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we are going to cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a build system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a build system?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, a **build system** is an automated process that assists developers
    writing clean optimized code. We may think that such a thing would be standard
    across all programming languages. Now, compiled languages usually have a compiler;
    a **compiler** takes a program written by following a language specification,
    and creates output code compatible with the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling code by example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compilers typically work through a spec when a code file is sent for processing.
    To keep a compiler from crashing from bad code, a compiler is set up with many
    error checkers that stop the compiler beforehand and display an alert, thus blocking
    the compiling process. Now some IDEs allow you to see some of your mistakes before
    attempting to run your code. The following screenshot shows a simple Xcode Swift
    file being checked while editing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling code by example](img/7296OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Without getting too technical in iOS development, we can see that, on assigning
    a constant variable in Swift, if I attempt to change the variable as in the preceding
    screenshot, my code flags an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if I change the `let authors_name` constant to a dynamic `var` variable
    (just like in JavaScript), the error itself corrects, as shown in the following
    screenshot, and removes the error displayed in the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling code by example](img/7296OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Error-checking in a JavaScript build system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, HTML editors for JavaScript and HTML content, such as Dreamweaver,
    have done this since the creation of early web code editors.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between what's done in Xcode for a compiled language and what's
    done in a JavaScript IDE is slightly different. With a compiled language, an error
    must be fixed before a code file can run; this is usually considered as static
    type checking. JavaScript, however, can run with an error, even when overridden
    with a `try-catch` block. Simply put, as stated in [Chapter 2](ch02.html "Chapter 2. Increasing
    Code Performance with JSLint"), *Increasing Code Performance with JSLint*, JavaScript
    is an interpreted language, and the *only* language that is really tested for
    errors at run time.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, how do editors such as Dreamweaver, WebStorm, or Visual Studio
    check for errors then? Well, if you remember in [Chapter 2](ch02.html "Chapter 2. Increasing
    Code Performance with JSLint"), *Increasing Code Performance with JSLint*, we
    saw how linting tools provide feedback on potential or verifiable bugs in JavaScript
    code; this returns a list of errors.
  prefs: []
  type: TYPE_NORMAL
- en: With an IDE, the editor is coded keeping this in mind and takes each error to
    display it with the associated line and column in the JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: So, to make a build system, we will need to incorporate this sort of error checking
    just like using [http://jslint.com/](http://jslint.com/) but in a more automated
    fashion. This allows lightweight editors to use the same checking tools that are
    used in more expensive and heavier IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding optimization beyond coding standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like our Xcode example earlier in the chapter, we want our final output to be
    optimized for our project; to do this, we will add minification to our build system,
    allowing us to keep a developer version or source project to be saved in a directory
    with a distribution in another directory. Simply put, minification allows us to
    compress our JavaScript code causing our web applications to download faster,
    and run more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: This can be helpful if we are using source control to maintain our project,
    allowing us to quickly grab a stable distribution that's optimized, but not easily
    debuggable, and debug it with our source directory's files.
  prefs: []
  type: TYPE_NORMAL
- en: Now as JavaScript developers, we can even add other minification build options
    that we may need for the project, such as an image optimizer for our project's
    image directory, or minify our CSS file and add information comment blocks on
    top of our JavaScript files. By compressing our JavaScript, the JavaScript interpreter
    doesn't have to guess the distance in whitespace in our code, which creates more
    efficient and better-performing code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a build system from scratch using Gulp.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've introduced build systems and the reason for their use, let's
    go ahead and create a simple build system. Our goal is to create a distribution
    build from our source directory, a copy that's optimized and ready for production.
    We will also integrate JSLint, as we learned from the last chapter, to check our
    code as we create builds for any potential issues that might have been missed
    during development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going create a build system to test our JavaScript project.
    We will also incorporate minification into our build system, and copy files to
    our build directory. So when we are ready to deploy, our code base is already
    set to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Before setting off on this project, we will need to understand a few technologies
    specific to JavaScript, particularly the build system that we will want to take
    into account; we will especially deal with technologies such as Node.js, NPM,
    Grunt, and Gulp. If you have only heard about these before, or maybe have tinkered
    with some of these and never really got further than that, don't worry; we will
    go over each of these one-by-one and understand their advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Node.js** is a JavaScript interpreter for your operating system. For JavaScript
    developers, the concept of JavaScript code working as a backend code base like
    Java or C# may seem odd, but has been shown to work in new creative ways. For
    example, the community of Node.js developers has created plugins to create custom-built,
    JavaScript-based applications for the desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: This puts JavaScript in a very new place. When traditional application developers
    complain about JavaScript, one of the main complaints is that JavaScript cannot
    read or write files to a hard drive, which is usually a very basic feature for
    a programming language. Node.js allows custom objects to interact with the operating
    system. These include objects such as `FS` or `FileSystem` that allow for reading
    and writing files and work pretty much like a console in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, we won''t discuss Node.js in depth (that''s another book),
    but we will be installing Node.js into our OS so that we can run and test our
    build system. So let''s download Node.js and get started. First, navigate to [http://nodejs.org/](http://nodejs.org/)
    and click the green **INSTALL** button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node.js](img/7296OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Node.js is cross-platform, and so most of these instructions should work for
    you. I''ll be using a Mac with OS X for this installation''s introduction. For
    most platforms, Node.js will come with either a `.pkg` or `.exe` install wizard,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node.js](img/7296OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From here, follow the wizard, accept the user licenses and install for all users.
    By installing for all users, we allow Node.js to have full system access which
    we do want, since some plugins for Node.js may require certain features that are
    not accessible by a single user or non-administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''ve finished installing Node.js, keep in mind the paths set by the
    installer; if you want to remove Node.js in future, check out the following screenshot
    to see where the installer has added Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node.js](img/7296OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing a Node.js installation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To ensure that Node.js is properly installed, we want to check two things. The
    first thing is to check whether Node.js works in the Terminal. To validate the
    installation, we will check the current version of Node.js that's installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s open Terminal (or Command Prompt, if using Windows), and insert
    the `node --version` command as shown in the following screenshot, and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing a Node.js installation](img/7296OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If successful, we should see the version number (in my case, it''s `v0.10.32`;
    your version may be greater than my version number when attempting this) as shown
    on the next line in the Terminal in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing a Node.js installation](img/7296OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing Node Package Manager's installation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Great job! Now, the next thing to be checked for a full installation is whether
    Node Package Manager is installed as well. Before testing, let me explain what
    Node Package Manager is, especially to those who might not know what it is and
    why we need it.
  prefs: []
  type: TYPE_NORMAL
- en: About Node Package Manager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The **Node Package Manager** (**NPM**) connects to the NPM registry, an online
    repository of software libraries for Node.js. By using NPM, we can quickly set
    up a JavaScript build system and install libraries for our HTML-based JavaScript
    projects automatically, which allows us to ensure that our JavaScript libraries
    are up-to-date with the latest version of each library.
  prefs: []
  type: TYPE_NORMAL
- en: 'NPM also has a website you can use to research various JavaScript libraries
    at [https://www.npmjs.org](https://www.npmjs.org). This is also shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About Node Package Manager](img/7296OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Checking NPM installation in the Terminal
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now, to check our installation of NPM, we are going to call NPM directly, which
    should return a `help` directory for the NPM module installed. To do this, simply
    open the Terminal and insert the `npm` command. Now, we should see our Terminal
    window populating with a bunch of NPM help documentation and sample terminal commands,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking NPM installation in the Terminal](img/7296OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The basics of using NPM
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using NPM is a pretty easy process to learn. The first thing that we need to
    do before setting up NPM for a project is to create a project root directory;
    I'm going to mark this as `npm_01` for the first project, but you can name your
    root as whatever you would like. Now, we are going to open Terminal and change
    our `bash` directory to match the path to the directory I created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change your working directory in the Terminal, the command is `Change Directory`
    or `cd`. Using `cd` is pretty easy; simply type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A few things to note here are that the Terminal always points to your user home
    directory on Mac and Linux, and the tilda key (or *~*) is a shortcut to point
    to your path. For example, if your folder is in your documents directory under
    your username, an example path using cd would be `cd ~/Documents/[your_project_path]`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the Terminal is getting cluttered with information, you can use the "clear"
    command to clean your terminal's contents, without changing your directory.
  prefs: []
  type: TYPE_NORMAL
- en: Installing jQuery with NPM
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common JavaScript library is jQuery, a very popular library on NPM. We can
    even check out its repository information on [npmjs.org](http://npmjs.org), found
    at [https://www.npmjs.org/package/jquery](https://www.npmjs.org/package/jquery).
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing jQuery with NPM](img/7296OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we look at this page, we can see a command for our terminal, `npm install
    jQuery`. So, let's type that into our terminal and press *Enter* to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're a Mac or Linux user, you can drag-and-drop a folder into the Terminal,
    and it will auto-write the path of your folder for you after you type the `cd`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal, it looks like some files were downloaded, as indicated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing jQuery with NPM](img/7296OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we open our project directory, we can see that a new folder named `node_modules`
    has been created. Inside this folder, another folder is created named `jquery`.
    The contents of the `jquery` folder are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing jQuery with NPM](img/7296OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inside the `jquery` folder, there are some interesting files. We have a `README.md`
    (`.md` is short for markdown, a type of text format) file explaining jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: The folder has two JSON files, one called `bower.json` and another called `package.json`.
    The `package.json` file handles the NPM package information while the `bower.json`
    file handles any dependent packages and notifies NPM to include those as well
    on installation request.
  prefs: []
  type: TYPE_NORMAL
- en: If you're wondering what the `bower.json` file does, it's essentially another
    way to update source code from a repository. Like the NPM registry, the `bower.json`
    file uses its own; the difference is that it can use a JSON file in a project
    and update based on the setting stored in the JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the most important two folders are the `src` folder (or source folder)
    and the `dist` folder (or distribution folder). This file structure is a common
    convention for NPM, where the source of a project with debug information is saved
    in the `src` folder, while the final tested output lives in the `dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Since we aren't debugging the source for jQuery, all we really need to worry
    about is the `dist` folder, where we can find the `jquery.js` file and the `jquery.min.js`
    file—the same library files typically used in jQuery projects. It's important
    to know this for our build systems as we will want to copy those into the distribution
    folder for our build system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned the basics of Node.js and NPM, let's actually build
    a build system. We will want to point our Terminal to our project's root directory,
    and then we will want to install our build system (also called Task Runner).
  prefs: []
  type: TYPE_NORMAL
- en: About Grunt.js and Gulp.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js build systems fall within two major build system libraries: Grunt and
    Gulp. Grunt is, in many cases, the default build system for Node.js projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Grunt Task Runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Grunt was designed originally for automating tasks in JavaScript and, web development
    and due to its availability, many developers have created plugins; you can view
    them in Grunt''s plugin repository shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grunt Task Runner](img/7296OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: About Gulp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gulp is another build system for Node.js; the advantage of using Gulp is that
    it's asynchronous, and typically runs automated tasks much faster than Grunt.
    Since this book is all about performance, we will use Gulp for our build system
    as an example. That doesn't mean that Grunt is bad; it can create built systems
    as well as Gulp.js, but it may not be as fast as Gulp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Grunt, Gulp also has a plugin reference page found at [http://gulpjs.com/plugins/](http://gulpjs.com/plugins/),
    and shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About Gulp](img/7296OS_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing Gulp
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To install Gulp, we will open our terminal and type the following into our
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install Gulp globally to our Node.js and NPM resource path. If we
    are running a Windows system, `sudo` isn''t in Window''s Shell, so we will need
    to run the Command Prompt as Administrator. Now, if everything is successful,
    we should see a bunch of URL requests for files, and our Terminal should return
    to the prompt shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Gulp](img/7296OS_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With our global ("global" meaning installed for all folders in our system) dependencies
    for Gulp installed, we can install our developer dependencies, which allow our
    build system to be more portable when uploading to a source control. Essentially,
    these dependencies need to be in our root project file to enable our build system
    to run in our project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do it by typing the following code into our Terminal (again, `sudo`
    for Mac/Linux users and **Run as Administrator** for Windows users):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, your `bash` prompt should show again, pulling many URL sources
    and installing them to your project''s `node_modules` directory under `gulp` as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Gulp](img/7296OS_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a gulpfile
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `gulpfile` is a file that Gulp checks for to run a list of tasks at the root
    of our project directory. To create one, we will create a simple JavaScript file
    called `gulpfile.js` (note the case of the filename). Inside the file we are going
    to reference Gulp as a variable and create a default task, called `Default`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the main task we need to run for every `gulpfile.js`; inside it, we
    can include other tasks or output log message, just like in a web browser. As
    a simple code example for a Gulp task is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a gulpfile](img/7296OS_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running a Gulp project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Running a Gulp project is easy. In your project''s root directory, type `gulp`
    in the Terminal and press *Enter*. You should see the output in your terminal
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a Gulp project](img/7296OS_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's nice. If we look at the fourth line of our Terminal's output, we should
    see our output message as **Default task ran**. Good job! This is the same `console.log`
    message we created for our `Default` task in our `gulpfile.js`.
  prefs: []
  type: TYPE_NORMAL
- en: So you may ask, How did all this help optimize the JavaScript code? Well, if
    you remember [Chapter 2](ch02.html "Chapter 2. Increasing Code Performance with
    JSLint"), *Increasing Code Performance with JSLint*, we used JSLint to review
    JavaScript code, make improvements, and optimize files. What if we could run that
    test tool, while copying files and minifying (or even testing minified code) through
    JSLint? Well, we can, and that's the point of using build systems.
  prefs: []
  type: TYPE_NORMAL
- en: With a build system, we are improving it and optimizing our code before modifying
    it, even before it is deployed out as a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating JSLint into Gulp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we talked about Gulp''s plugin page; well one of those plugins is
    a JSLint plugin, and the installation process is pretty easy. First, check out
    the JSLint plugin page found at [https://www.npmjs.org/package/gulp-jslint/](https://www.npmjs.org/package/gulp-jslint/),
    and as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating JSLint into Gulp](img/7296OS_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, in the same way we installed Gulp, we will run the `npm` command shown
    on the page, but will include `sudo` for administrator permissions and the `-g`
    command. This is a global flag to install JSLint to the full system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will install the developer dependencies for our project, so again
    we will point to our root project directory in the Terminal and then type our
    `npm` command but with the `-save-dev` flag this time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the installation, we can check the `node_modules` folder in our project
    directory, and see the `gulp-jslint` folder, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating JSLint into Gulp](img/7296OS_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing our example file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, our build system needs a source file, and I''ve written an example while
    adding it to a new `src` project directory created in Finder. I haven''t tested
    this yet, and it''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our example file](img/7296OS_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So we have a simple Toddler JavaScript class, and it displays messages based
    on the prototype functions called; it''s pretty basic and it does have some intended
    errors, so let''s find these. Let''s go back to `gulpfile.js`; I''ve updated it
    with some JSLint examples using the same common options enabled by us and mentioned
    in [Chapter 2](ch02.html "Chapter 2. Increasing Code Performance with JSLint"),
    *Increasing Code Performance with JSLint*. Take a look at the updated `gulpfile.js`
    file, shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our example file](img/7296OS_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On lines 6 and 7, we can see conventions such as, `gulp.src()` and `pipe()`.
    The `src` function is a Gulp-specific function that sets the source file or files
    using a JavaScript array; the `pipe` function, which is also Gulp-related, allows
    us to create a list of tasks that will take the source files from `gulp.src()`
    and *pipe* them through our build system. Lines 5 to 19 here show a new `gulp.task`
    called JSLint. If we look at lines 9 to 12, we can see the same options used from
    [JSLint.com](http://JSLint.com); the option names can be found under JSLint Directives
    at the bottom of the page when we select different options on the page.
  prefs: []
  type: TYPE_NORMAL
- en: On line 22, we added an array after our *default* task, adding our *JSLint*
    task name into an array. We can add multiple tasks here, but for now we just need
    the lint task. Now let's run the script and check our terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our example file](img/7296OS_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Excellent! The red lines shown in the terminal report errors with the script
    that gives us our lint feedback in the terminal and, as we can see, we forgot
    some common things such as using *use strict*, missing semicolons, and so on.
    So we can see how we can automate the process of testing our code during a build
    using Node.js and Gulp.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Saving the best part for last, let's have Gulp handle minifying the JavaScript
    source code, copying the output to the `dist` folder, and then linting the output
    for testing. I've modified the `ExampleScript.js` file to fix most of the issues
    found earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to download a minification tool for Gulp called **Uglify**, available
    at [https://www.npmjs.org/package/gulp-uglify](https://www.npmjs.org/package/gulp-uglify).
    It''s a common minifier for JavaScript for Gulp-based projects; its installation
    is easy and follows the same procedure used for installing Gulp itself and JSlint
    for Gulp. The following command is used for installing the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I''ve updated our `gulpfile.js` with a new minify task and added it to
    the array as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a distribution](img/7296OS_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, run Gulp in the Terminal window and notice the output (shown in the next
    screenshot); in the finder folder, you'll see a brand-new minified file in the
    `dist` directory of your root project folder, while retaining your developer source
    and getting performance linting at the same time!
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a distribution](img/7296OS_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a simple JavaScript build system using
    Node.js with Gulp. We also explored other plugins and checked out Grunt Task Runner,
    which works similar to Gulp but contains many more plugins for your work.
  prefs: []
  type: TYPE_NORMAL
- en: Build systems help your performance greatly without much effort; keep in mind
    that gulp files can be reused for other projects, and so experiment and find out
    what works best for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn tips and tricks on how to use Chrome's **Developer
    tools** option to better optimize our web application code.
  prefs: []
  type: TYPE_NORMAL
