- en: Chapter 3. Syntax Validation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 语法验证
- en: To build on what we have learned in the previous chapters, we will now move
    on to a slightly tougher topic—validating JavaScript. In this chapter you can
    expect two broad topics—the issues surrounding validation and testing of JavaScript
    code, and how to use JSLint and JavaScript Lint (which is a free JavaScript validator)
    to check your JavaScript code, and how to debug them. I'll explicitly show you
    how to spot validation errors using JSLint and then, how to fix them.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了巩固我们之前学到的知识，我们现在将转向一个稍微困难的话题——验证JavaScript。在本章中，你可以期待两个主要话题——围绕JavaScript代码验证和测试的问题，以及如何使用JSLint和JavaScript
    Lint（这是一个免费的JavaScript验证器）来检查你的JavaScript代码，以及如何调试它们。我会明确地展示如何使用JSLint发现验证错误，然后，如何修复它们。
- en: We will briefly mention the difference between validating and testing JavaScript
    and some of the issues that you might have to consider when you are validating
    or testing your code. You will also understand the relationship between valid
    HTML and CSS with JavaScript, and how attempting to write quality code can help
    you reduce errors in your JavaScript code. More importantly, we will learn about
    two free tools that are often used to validate JavaScript code, how to make use
    of it to check your code, and most importantly, how to fix validation errors that
    are detected.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将简要介绍验证和测试JavaScript之间的区别以及你在验证或测试代码时可能需要考虑的一些问题。你还将了解有效的HTML和CSS与JavaScript之间的关系，以及如何尝试编写高质量的代码以帮助你减少JavaScript代码中的错误。更重要的是，我们将学习到两个常用于验证JavaScript代码的免费工具，如何利用它们检查你的代码，以及最重要的是，如何修复检测到的验证错误。
- en: 'In this chapter we shall learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: The difference between validating and testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和测试之间的区别
- en: How a good code editor can help you spot validation errors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的代码编辑器如何帮助你发现验证错误
- en: What makes a code quality code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么使代码质量高
- en: Why do we need HTML and CSS to be valid before we start working on JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在开始操作JavaScript之前需要确保HTML和CSS是有效的
- en: Why JavaScript embedded in HTML may be reported as invalid
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么嵌入在HTML中的JavaScript可能会被报告为无效
- en: Common JavaScript errors that are detected by validating
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过验证检测到的常见JavaScript错误
- en: JSLint and JavaScript Lint—how to use it to check your code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSLint和JavaScript Lint——如何使用它们检查你的代码
- en: Valid code constructs that produce validation warnings
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生验证警告的有效代码结构
- en: How to fix validation errors that are spotted by JSLint
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何修复由JSLint发现的验证错误
- en: So without further ado, let us get started with a lighter topic—the difference
    between validating and testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，不再赘述，让我们开始讨论一个较轻松的话题——验证和测试之间的区别。
- en: The difference between validating and testing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和测试之间的区别
- en: There's a thin line separating validating and testing. If you have some idea
    about sets (as in sets from mathematics), I would say that validation can lead
    to better testing results, while testing does not necessarily lead to a valid
    code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有效验证和测试之间有一条细微的界限。如果你对集合（如数学中的集合）有一些了解，我会说验证可以导致更好的测试结果，而测试不一定导致有效代码。
- en: Let us consider the scenario—you wrote a JavaScript program and tested it on
    major browsers such as the Internet Explorer and Firefox; and it worked. In this
    case, you have tested the code to make sure that it is functional.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这样一个场景——你编写了一个JavaScript程序，并在Internet Explorer和Firefox等主要浏览器上进行了测试，并且它运行正常。在这种情况下，你已经测试了代码，以确保它是功能性的。
- en: 'However, the same code that you have created may or may not be valid; valid
    code is akin to writing a code that has the following characteristics:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你所创建的同一代码可能有效也可能无效；有效代码类似于具有以下特点的代码：
- en: Well formed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式良好
- en: Has good coding style (such as proper indentation, well-commented code, properly
    spaced)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有良好的编码风格（如适当的缩进、注释良好的代码、适当的间距）
- en: Meets the specification of the language (in our case, JavaScript)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符合语言规范（在我们这个案例中，是JavaScript）
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There may come a point in time where you will notice that good coding style
    is highly subjective—there are various validators that may have different opinions
    or standards as to what is known as "good coding style". Therefore, if you do
    use different validators to validate your code, do not freak out if you see different
    advice for your coding style.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时间点，你可能会注意到良好的编码风格是非常主观的——有各种验证器可能对所谓的“良好编码风格”有不同的意见或标准。因此，如果你用不同的验证器来验证你的代码，当你看到不同的编码风格建议时，不要惊慌。
- en: This does not mean that valid code leads to code that is functional (as you
    will see later) and that code that is functional leads to validated code as both
    have different standards for comparison.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着有效的代码会导致具有功能的代码（如你所见）以及具有功能的代码会导致有效的代码，因为两者有不同的比较标准。
- en: However, valid code often leads to less errors, and code that is both functional
    and valid is often quality code. This is due to the fact that writing a piece
    of JavaScript code, that is both valid and correct, is much more difficult than
    just writing a code that is correct.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有效的代码通常会导致更少的错误，既有功能又是有效的代码通常是高质量代码。这是因为编写一段既有效又正确的JavaScript代码，比仅仅编写正确的代码要困难得多。
- en: Testing often means that we are trying to get the code working correctly; while
    validation is making sure that the code is syntactically correct, with good style
    and that it meets the specification of the language. While good coding styles
    may be subjective, there is often a coding style that is accepted by most programmers,
    such as, making sure that the code is properly commented, indented, and there
    is no pollution of the global namespace (especially in the case of JavaScript).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常意味着我们试图让代码正确运行；而验证则是确保代码在语法上是正确的，有良好的风格，并且符合语言规范。虽然良好的编码风格可能是主观的，但通常有一种被大多数程序员接受的编码风格，例如，确保代码有适当的注释、缩进，并且没有全局命名空间的污染（尤其是在JavaScript的情况下）。
- en: 'To make the case clearer, following are three situations that you can consider:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使情况更清晰，以下是三个你可以考虑的情况：
- en: Code that is valid but wrong—validation doesn't find all the errors
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码是有效的但却是错误的——验证并不能找到所有的错误。
- en: This form of errors would most probably be caused by logic errors in JavaScript.
    Consider what we have learned in the previous chapters; logic errors can be syntactically
    correct but they may be logically flawed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误形式很可能是由JavaScript中的逻辑错误引起的。考虑我们之前学到的内容；逻辑错误可能在语法上是正确的，但可能在逻辑上是错误的。
- en: A classic example would be an infinite `for` loop or infinite `while` loop.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子可能是一个无限`for`循环或无限`while`循环。
- en: Code that is invalid but right
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码是无效的但却是正确的
- en: This would most probably be the case for most functional code; a piece of JavaScript
    may be functionally correct and working, but it may be invalid. This may be due
    to poor coding style or any other characteristics in a valid code that are missing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这很可能是大多数功能性代码的情况；一段JavaScript可能是功能上正确并且运行正常，但它可能是无效的。这可能是由于编码风格不良或有效代码中缺失的其他特征引起的。
- en: Later on in this chapter, you will see a full working example of a piece of
    JavaScript code that is right but invalid.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，你将看到一个完整的、有效的JavaScript代码示例。
- en: Code that is invalid and wrong—validation finds some errors that might be difficult
    to spot any other way
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无效且错误的代码——验证可以找到一些可能用其他方法难以发现的错误
- en: In this case, the code error can be caused by all three forms of JavaScript
    errors that are mentioned in [Chapter 1](ch01.html "Chapter 1. What is JavaScript
    Testing?"), *What is JavaScript Testing*, loading errors, runtime errors, and
    logic errors. While it is more likely that errors caused by syntax errors might
    be spotted by good validators, it is also possible that some errors are buried
    deep inside the code, such that it is difficult to spot them using manual methods.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码错误可能由[第1章](ch01.html "第1章. 什么是JavaScript测试？")中提到的JavaScript错误的三个形式引起，*什么是JavaScript测试*，加载错误，运行时错误和逻辑错误。虽然由语法错误引起的错误可能更容易被好的验证器发现，但也有可能一些错误深深地隐藏在代码中，以至于使用手动方法很难发现它们。
- en: Now that we have some common understanding as to what validation and testing
    is about, let us move on to the next section which discusses the issues surrounding
    quality code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对验证和测试有了共同的理解，那么让我们继续下一部分，讨论围绕高质量代码的问题。
- en: Code quality
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码质量
- en: While there are many views as to what is quality code, I personally believe
    that there are a few agreed standards. Some of the most commonly mentioned standards
    may include code readability, ease of extension, efficiency, good coding style,
    and meeting language specifications, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于高质量代码有很多观点，我个人认为有一些公认的标准。一些最常提到的标准可能包括代码的可读性，易于扩展，效率，良好的编码风格，以及符合语言规范等。
- en: For our purpose here, we will focus on the factors that make a piece of code
    valid—coding style and meeting specifications. In general, good coding style almost
    guarantees that the code is highly readable (even to third parties) and this will
    help us to spot errors manually.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将关注使代码有效的一些因素——编码风格和符合规范。一般来说，良好的编码风格几乎可以保证代码高度可读（甚至对第三方也是如此），这将有助于我们手动发现错误。
- en: Most importantly, having a good coding style allows us to quickly understand
    the code, specially if we need to work in teams or are required to debug the code
    on our own.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，良好的编码风格使我们能够快速理解代码，特别是如果我们需要团队合作或需要独立进行代码调试时。
- en: You will notice that we will focus on the importance of code validity for testing
    purposes in later parts of the chapter. But now, let us start with the first building
    block of quality code—valid HTML and CSS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们将重点关注代码有效性对于测试目的的重要性。但现在，让我们从质量代码的第一个构建块开始——有效的HTML和CSS。
- en: HTML and CSS needs to be valid before you start on JavaScript
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始JavaScript之前，HTML和CSS需要是有效的
- en: In chapter one, we have a common understanding that JavaScript breathes life
    into a web page by manipulating the Document Object Model **(DOM)** of the HTML
    documents. This means that the DOM must be present in the code before JavaScript
    can operate on it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们有一个共同的理解，JavaScript通过操作HTML文档的文档对象模型**（DOM）**为网页注入生命力。这意味着在JavaScript可以操作DOM之前，DOM必须存在于代码中。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Heres an important fact that is directly related to HTML, CSS, and browsers
    browsers are generally forgiving towards invalid HTML and CSS code as compared
    to compilers for languages like C or Python. This is because, all browsers have
    to do is parse the HTML and CSS so as to render the web page for its browsers.
    On the other hand, compilers are generally unforgiving towards invalid code. Any
    missing tag, declarations, and so on will lead to a compilation error. Therefore,
    it is ok to write invalid or even buggy HTML and CSS, yet get a "usual" looking
    web page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个与HTML、CSS和浏览器直接相关的重要事实，相比C或Python等语言的编译器，浏览器对无效的HTML和CSS代码更加宽容。这是因为，所有浏览器需要做的就是解析HTML和CSS，以便为用户渲染网页。另一方面，编译器通常对无效代码毫不留情。任何缺失的标签、声明等都会导致编译错误。因此，编写无效的或甚至是含有错误的HTML和CSS是可以的，但仍能得到一个“通常”外观的网页。
- en: Based on the previous explanation, we should see that we would need to have
    valid HTML and CSS in order to create quality JavaScript code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的解释，我们应该明白，为了创建高质量的JavaScript代码，我们需要有效的HTML和CSS。
- en: 'A short list of reasons, based on my personal experience, as to why valid HTML
    and CSS is an important prerequisite before you start working on JavaScript are
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我根据个人经验总结的，在开始学习JavaScript之前，为什么需要具备有效的HTML和CSS知识的原因：
- en: Valid HTML and CSS helps ensure that JavaScript works as intended. For example,
    consider a situation where you might have two div elements that have the same
    `id` (In the previous chapters, we have mentioned that the `div id` attribute
    is meant to give unique IDs for each HTML elements), and your JavaScript contains
    the piece of code that is supposed to work on the above mentioned HTML element
    with the id. This will result in unintended consequences.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的HTML和CSS有助于确保JavaScript按预期工作。例如，考虑这样一种情况，你可能有两个具有相同`id`的`div`元素（在之前的章节中，我们已经提到`div
    id`属性是给每个HTML元素提供唯一ID的），而你的JavaScript包含了一段预期对具有上面提到的ID的HTML元素工作的代码。这将导致意想不到的结果。
- en: Valid HTML and CSS helps improve the predictability on how your web page will
    work; there is no point trying to fix buggy HTML or CSS using JavaScript. You
    are most probably better off if you start with valid HTML and CSS, and then apply
    JavaScript.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的HTML和CSS有助于提高你的网页行为的可预测性；试图用JavaScript修复错误的HTML或CSS是没有意义的。如果你从一开始就使用有效的HTML和CSS，然后应用JavaScript，你很可能会得到更好的结果。
- en: Invalid HTML and CSS may result in different behaviour in different browsers.
    For example, an HTML tag that is not enclosed may be rendered differently in different
    browsers.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的HTML和CSS可能会导致不同浏览器中出现不同的行为。例如，一个未闭合的HTML标签在不同浏览器中可能会有不同的显示效果。
- en: In short, one of the most important building blocks of creating quality JavaScript
    code is to have valid HTML and CSS.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，创建高质量JavaScript代码最重要的构建块之一是拥有有效的HTML和CSS。
- en: What happens if you don't validate your code
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果你不验证你的代码会发生什么
- en: You may disagree with me on the previous section as to why HTML and CSS should
    be valid. In general, validation helps you to prevent errors that are related
    to coding style and specifications. However, do take note that using different
    validators may give you different results since validators might have different
    standards in terms of code style.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会不同意我上文关于为什么HTML和CSS应该有效的观点。一般来说，验证有助于你防止与编码风格和规格相关的错误。然而，请注意，使用不同的验证器可能会给你不同的结果，因为验证器可能在代码风格方面有不同的标准。
- en: In case you are wondering if invalid code can affect your JavaScript code, I
    would advise you to make your code as valid as possible; invalid code may lead
    to sticky issues such as cross-browser incompatibility, difficulty in reading
    code, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想无效的代码是否会影响你的JavaScript代码，我会建议你尽可能让代码有效；无效的代码可能会导致棘手的问题，比如跨浏览器不兼容、代码难以阅读等。
- en: Invalidated code means that your code may not be foolproof; in the early days
    of the Internet, there were websites that were dependent on the quirks of the
    early Netscape browser. Back track to the time where the Internet Explorer 6 was
    widely used, there were also many websites that worked in quirks mode to support
    Internet Explorer 6.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无效代码意味着你的代码可能不是万无一失的；在互联网的早期，有些网站依赖于早期Netscape浏览器的怪癖。回想一下，当Internet Explorer
    6被广泛使用时，也有许多网站以怪癖模式工作以支持Internet Explorer 6。
- en: Now, most browsers are supporting or are moving towards supporting web standards
    (though slightly different, they are supporting in subtle manners), writing valid
    code is one of the best ways to ensure that your website works and appears the
    way it is intended to.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数浏览器都支持或正在支持网络标准（尽管有些细微的差异，但它们以微妙的方式支持），编写有效的代码是确保你的网站按预期工作和工作表现的最佳方式之一。
- en: How validation can simplify testing
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何通过验证简化测试
- en: 'While invalid code may not cause your code to be dysfunctional, valid code
    often simplifies testing. This is due to the focus on coding style and specifications;
    codes that are valid and have met specifications are typically more likely to
    be correct and much easier to debug. Consider the following code that is stylistically
    invalid:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无效的代码可能不会导致你的代码功能失效，但有效的代码通常可以简化测试。这是因为有效代码关注编码风格和规格，符合规格的有效代码通常更可能正确，且更容易调试。考虑以下风格上无效的代码：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Find the preceding code familiar? Or did you fail to recognize that the previous
    code snippet was taken from [Chapter 2](ch02.html "Chapter 2. Ad Hoc Testing and
    Debugging in JavaScript"),*Ad Hoc Testing and Debugging in JavaScript*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉之前的代码吗？还是没有意识到之前的代码片段来自[第二章](ch02.html "第2章. JavaScript中的即兴测试与调试")，《JavaScript中的即兴测试与调试》？
- en: The previous code is an extreme example of poor code style, especially in terms
    of indentation. Imagine if you have to manually debug the second code snippet
    that you saw earlier! I am pretty sure that you will find it frustrating to check
    the code, because you will have little visual sense of what is going on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是代码风格不佳的一个极端例子，尤其是在缩进方面。想象一下，如果你必须手动调试你之前看到的第二个代码片段！我敢肯定，你会觉得检查代码很沮丧，因为你几乎无法从视觉上了解发生了什么。
- en: More importantly, if you are working in a team, you will be required to write
    legible code; in short, writing valid code typically leads to code that is more
    legible, easier to follow, and hence, less erroneous.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，如果你在团队中工作，你将被要求编写可读的代码；总之，编写有效的代码通常会导致代码更具可读性，更容易理解，因此错误更少。
- en: Validation can help you debug your code
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证可以帮助你调试代码
- en: As mentioned in the previous section, browsers are in general forgiving towards
    invalid HTML and CSS. While this is true, there may be errors that are not caught,
    or are not rendered correctly or gracefully. This means that while the invalid
    HTML and CSS code may appear fine on a certain platform or browser, it may not
    be supported on others.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如上文所述，浏览器通常对无效的HTML和CSS比较宽容。虽然这是真的，但可能会有一些错误没有被捕捉到，或者没有正确或优雅地渲染。这意味着虽然无效的HTML和CSS代码在某个平台或浏览器上可能看起来没问题，但在其他平台上可能不受支持。
- en: This means that using valid code (valid code typically means standard code set
    by international organizations such as W3C) will give you a much greater probability
    of having your web page rendered correctly on different browsers and platforms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用有效的代码（有效的代码通常意味着由国际组织如W3C设定的标准代码集）将使你的网页在不同的浏览器和平台上正确渲染的概率大大增加。
- en: With valid HTML and CSS, you can safely write your JavaScript code and expect
    it to work as intended, assuming that your JavaScript code is equally valid and
    error free.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有了有效的 HTML 和 CSS，您可以安全地编写您的 JavaScript 代码并期望它按预期工作，前提是您的 JavaScript 代码同样有效且无错误。
- en: Validation helps you to code using good practices
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证帮助您使用好的编程实践
- en: Valid code typically requires coding using good practices. As mentioned frequently
    in this chapter, good practices include the proper enclosing of tags, suitable
    indentation to enhance code readability, and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的代码通常需要使用好的编程实践。正如本章中多次提到的，好的实践包括适当闭合标签，合适的缩进以提高代码可读性等。
- en: If you need more information about good practices when using JavaScript, feel
    free to check out the creator of JSLint, Douglas Crockford, at [http://crockford.com](http://crockford.com).
    Or you can read up John Resigs blog (the creator of JQuery) at [http://ejohn.org/](http://ejohn.org/).
    Both are great guys who know what great JavaScript is about.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多关于使用 JavaScript 的良好实践的信息，请随时查看 JSLint 的创建者，Douglas Crockford，在 [http://crockford.com](http://crockford.com)。或者您可以阅读
    John Resigs 的博客（JQuery 的创建者）在 [http://ejohn.org/](http://ejohn.org/)。他们都是很棒的人，知道什么是伟大的
    JavaScript。
- en: Validation
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证
- en: To summarize the above sections, the DOM is provided by HTML, and both CSS and
    JavaScript are applied to the DOM. This means that if there is an invalid DOM,
    there is a chance that the JavaScript that is operating on the DOM (and sometimes
    the CSS) might result in errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总结以上各节，DOM 由 HTML 提供，CSS 和 JavaScript 都应用于 DOM。这意味着如果存在无效的 DOM，那么操作 DOM 的 JavaScript（有时包括
    CSS）可能会导致错误。
- en: With this summary in mind, well focus on how you can spot validation errors
    by using color coding editors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个总结在心中，我们将重点关注如何使用颜色编码编辑器来发现验证错误。
- en: Color-coding editors—how your editor can help you to spot validation errors
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色编码编辑器—您的编辑器如何帮助您发现验证错误
- en: If you are an experienced coder, you may skip this section; if not, you might
    want to understand the value of a good coding editor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一个有经验的程序员，您可以跳过这一节；如果不是，您可能想了解一个好的编程编辑器的价值。
- en: 'In general, a good editor can help you to prevent validation errors. Based
    on our understanding of what validation is, you should understand that your editor
    should do the following activities:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，一个好的编辑器可以帮助您防止验证错误。基于我们对验证的理解，您应该明白，您的编辑器应该执行以下活动：
- en: Highlight matching brackets
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出显示匹配的括号
- en: Multiple syntax highlighting
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种语法高亮
- en: Auto indentation after keywords, brackets, and others
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字、括号等之后的自动缩进
- en: Auto completion of syntax
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动补全语法
- en: Auto completion of words that you have already typed
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动补全您已经输入的单词
- en: You may have noticed that I have left out a few points, or added a few points,
    as to what a good editor should do. But in general, the points listed previously
    are meant to help you prevent validation errors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到了，我遗漏了一些要点，或者增加了一些要点，关于好的编辑器应该做什么。但总的来说，前面列出的要点是为了帮助您防止验证错误。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a start, you can consider using Microsofts SharePoint Designer 2007, a free,
    feature-rich, HTML, CSS ,and JavaScript editor, which is available at [http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=baa3ad86-bfc1-4bd4-9812-d9e710d44f42](http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=baa3ad86-bfc1-4bd4-9812-d9e710d44f42)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个开始，您可以考虑使用微软的 SharePoint Designer 2007，这是一个免费、功能丰富的 HTML、CSS 和 JavaScript
    编辑器，可在 [http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=baa3ad86-bfc1-4bd4-9812-d9e710d44f42](http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=baa3ad86-bfc1-4bd4-9812-d9e710d44f42)获得
- en: For example, highlighting matching brackets is to ensure that your code is properly
    enclosed with brackets, and auto indentation is to ensure that you are using consistent
    spacing for your code blocks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，突出显示匹配的括号是为了确保您的代码用括号正确闭合，自动缩进是为了确保您为代码块使用了统一的空格。
- en: 'Although JavaScripts code blocks are often denoted by the use of curly brackets,
    it is important that we use indentation to visually display the structure of the
    code. Consider the following code snippets:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JavaScript 代码块通常用花括号表示，但使用缩进来 visually 显示代码结构非常重要。考虑以下代码片段：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next code snippet is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段如下：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I am quite sure that you would find the second code snippet to be messy, as
    it has inconsistent indentation, and you may have problems figuring out which
    statement belongs to which conditional block.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常确信，您会认为第二个代码片段很乱，因为它的缩进不一致，您可能会遇到分辨哪个语句属于哪个条件块的问题。
- en: Stylistically speaking, the second code sample is what we call "poor code style".
    You will be surprised that this might lead to validation errors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从风格上讲，第二个代码示例就是我们所说的“糟糕的代码风格”。您可能会惊讶这可能会导致验证错误。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In case you are wondering what `/^[a-zA-Z\s]*$/` and `/^\d+$/are`, they are
    actually regular expression objects. Regular expressions originated from Perl
    (a programing language) and, due to their usefulness, many programing languages
    now have ther own form of regular expressions. Most of them work in the same way.
    If you wish to find out more about regular expressions for JavaScript, feel free
    to visit [http://www.w3schools.com/jsref/jsref_obj_regexp.asp](http://www.w3schools.com/jsref/jsref_obj_regexp.asp)
    for a brief introduction to how regular expressions work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道`/^[a-zA-Z\s]*$/`和`/^\d+$/`是什么，它们实际上是正则表达式对象。正则表达式起源于Perl（一种编程语言），由于它们的实用性，许多编程语言现在都有自己的正则表达式形式。大多数它们的工作方式相同。如果您想了解更多关于JavaScript正则表达式的信息，请随时访问[http://www.w3schools.com/jsref/jsref_obj_regexp.asp](http://www.w3schools.com/jsref/jsref_obj_regexp.asp)以了解正则表达式是如何工作的简要介绍。
- en: Common errors in JavaScript that will be picked up by validation
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中常见的错误，将由验证工具检测到
- en: 'Ill briefly mention some of the most common validation errors that are picked
    up by validators. Following is a short list of them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我会简要提到一些由验证器检测到的最常见的验证错误。以下是它们的简短列表：
- en: Inconsistent spacing or indentation
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不一致的空格或缩进
- en: Missing semi colons
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少分号
- en: Missing closing brackets
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少闭合括号
- en: Using a function or variable that is not declared at the point of being called
    or referenced
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在调用或引用时未声明的函数或变量
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that some of the validation errors are not exactly "errors"—as
    in syntax errors—but rather stylistic ones. As mentioned in the previous sections,
    differences in coding style do not necessarily lead to functional errors but rather
    stylistic errors. But the good thing about good coding style is that it often
    leads to less errors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，一些验证错误并不是 exactly "错误"——就像语法错误——而是风格上的错误。如前所述，编码风格上的差异不一定导致功能错误，而是导致风格错误。但良好的编码风格的一个好处是，它通常会导致更少的错误。
- en: At this point, it might be difficult for you to visualize what these common
    errors actually look like. But don't worry, you will get to see such validation
    errors in action when we introduce the JavaScript validation tools.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，您可能很难想象这些常见错误实际上看起来是什么样子。但不要担心，当我们引入JavaScript验证工具时，您将能看到这些验证错误的实际操作。
- en: JSLint—an online validator
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSLint—在线验证器
- en: 'JSLint is the first JavaScript validation code that we will focus on. You can
    access JSLint by visiting this URL: [http://www.jslint.com](http://www.jslint.com).
    The JSLint online validator is a tool created by Douglas Crockford.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JSLint是我们将重点介绍的第一种JavaScript验证代码。通过访问这个URL：[http://www.jslint.com](http://www.jslint.com)，您可以访问JSLint。JSLint在线验证器是由道格拉斯·克罗克福德创建的工具。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Douglas Crockford works at Yahoo! as a JavaScript architect. He is also a member
    of the committee that designs future versions of JavaScript. His views on JavaScript
    style and coding practices are generally agreed upon . You can read more about
    him and his ideas at his website: [http://www.crockford.com](http://www.crockford.com).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 道格拉斯·克罗克福德（Douglas Crockford）在雅虎！担任JavaScript架构师。他还是设计JavaScript未来版本的委员会成员。他在JavaScript风格和编程实践方面的观点普遍受到认可。您可以在他的网站上了解更多关于他和他的想法：[http://www.crockford.com](http://www.crockford.com)。
- en: 'In general, JSLint is an online JavaScript validator. It helps to validate
    your code. At the same time, JSLint is smart enough to detect some forms of code
    errors, such as infinite loops. The JSLint website is not a particularly large
    website, but nonetheless, two important links that you must read are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，JSLint是一个在线JavaScript验证器。它帮助验证您的代码。同时，JSLint足够智能，可以检测到一些代码错误，比如无限循环。JSLint网站并不是一个特别大的网站，但无论如何，您必须阅读的两个重要链接如下：
- en: For basic instructions, visit [http://www.jslint.com/lint.html](http://www.jslint.com/lint.html)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本操作说明，请访问[http://www.jslint.com/lint.html](http://www.jslint.com/lint.html)
- en: For a list of messages, visit [http://www.jslint.com/msgs.html](http://www.jslint.com/msgs.html)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看消息列表，请访问[http://www.jslint.com/msgs.html](http://www.jslint.com/msgs.html)
- en: I will not attempt to describe to you what JSLint is about and how to use it;
    I personally believe in getting our hands dirty and giving it a test drive. Hence,
    for a start, we'll test the code that we wrote in [Chapter 2](ch02.html "Chapter 2. Ad
    Hoc Testing and Debugging in JavaScript"), *Ad Hoc Testing and Debugging in JavaScript*,
    and see what kind of validation errors (if any) occur.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会试图向你描述JSLint是关于什么以及如何使用它；我个人认为应该亲自动手试试。因此，首先，我们将测试我们在[第二章](ch02.html "Chapter 2. Ad
    Hoc Testing and Debugging in JavaScript")中编写的代码，*Ad Hoc Testing and Debugging
    in JavaScript*，看看会出现哪些验证错误（如果有的话）。
- en: Time for action—using JSLint to spot validation errors
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是行动的时候了——使用JSLint查找验证错误
- en: As mentioned earlier, well test the code that we wrote in [Chapter 2](ch02.html
    "Chapter 2. Ad Hoc Testing and Debugging in JavaScript"), *Ad Hoc Testing and
    Debugging in JavaScript*, and see what validation errors we get. Take note that
    the completed and validated code for this example can be found in `Chapter 3`
    of the `source code` folder, in the file named `perfect-code-for-JSLint.html`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，我们将测试我们在[第二章](ch02.html "Chapter 2. Ad Hoc Testing and Debugging in
    JavaScript")中编写的代码，*Ad Hoc Testing and Debugging in JavaScript*，看看我们会得到哪些验证错误。请注意，这个示例的完整验证代码可以在`source
    code`文件夹的`第三章`中找到，文件名为`perfect-code-for-JSLint.html`。
- en: Open up your web browser and navigate to [http://www.jslint.com](http://www.jslint.com).
    You should see the home page with a huge text area. This is the area where you
    are going to copy and paste your code.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的网页浏览器，导航至[http://www.jslint.com](http://www.jslint.com)。你应该会看到一个带有巨大文本区域的首页。这就是你将要复制和粘贴你的代码的地方。
- en: 'Go to the `source code` folder of `Chapter 2` and open up the file named: `getting-values-in-right-places-complete.html`.
    Then, copy and paste the source code into the text area mentioned in step 1.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请前往`第二章`的`source code`文件夹，打开名为：`getting-values-in-right-places-complete.html`的文件。然后，将源代码复制并粘贴到步骤1中提到的文本区域。
- en: Now click on the button with the name **JSLint**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击名为**JSLint**的按钮。
- en: Your page should refresh almost immediately, and you will receive some form
    of feedback. You may have noticed that you received many (yes, a lot of) validation
    errors. And, most probably, some of them do not make sense to you. However, you
    should be able to identify that some of the validation errors were introduced
    in the section on common JavaScript validation errors.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的页面应该会立即刷新，并且你会收到一些形式的反馈。你可能会注意到你收到了很多（是的，很多）验证错误。而且，很可能会有一些对你来说是不懂的。然而，你应该能够识别出一些验证错误是在关于常见JavaScript验证错误的章节中引入的。
- en: 'Now, scroll further down and you should see the following phrase in the feedback
    area:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，向下滚动，你应该在反馈区域看到以下短语：
- en: '[PRE3]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tells you that JSLint has only scanned a part of the code and stopped scanning
    the code because there were too many errors.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉你JSLint只是扫描了代码的一部分，并停止了扫描代码，因为错误太多了。
- en: What can we do about this? What if there are too many validation errors and
    you cannot spot all of them in one go?
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们能对此做些什么呢？如果验证错误太多，你一次无法找出所有的错误怎么办？
- en: Do not worry, as JSLint is robust and has option settings, which are found at
    [http://www.jslint.com/#JSLINT_OPTIONS](http://www.jslint.com/#JSLINT_OPTIONS)
    (this is actually found at the bottom of the home page of JSLint). One of the
    options that requires your input is the **maximum number of errors**. For our
    purposes, you may want to enter an insanely large number, such as 1,000,000.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要担心，因为JSLint是健壮的，并且有选项设置，这些设置可以在[http://www.jslint.com/#JSLINT_OPTIONS](http://www.jslint.com/#JSLINT_OPTIONS)找到（这实际上位于JSLint主页的底部）。需要你输入的一个选项是**最大错误数**。在我们的例子中，你可能想输入一个巨大的数字，比如1,000,000。
- en: After entering an insanely large number for the input box for **maximum number
    of errors**, click on the button **The good parts**. You will see a few checkboxes
    have been selected.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个巨大的数字作为**最大错误数**的输入框后，点击**The good parts**按钮。你会看到有几个复选框被选中了。
- en: After step 4, you have now officially selected the options known as The Good
    Parts by the author of this tool. This is a setting that automatically sets what
    the author feels are the most important validation checks.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在步骤4之后，你现在正式选择了被称为“The Good Parts”的选项，这是由本工具的作者设定的。这是一个设置，它会自动设置作者认为最重要的验证检查。
- en: 'These options include: Strict white space, allow one var statement per function,
    and so on.'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些选项包括：严格空格，每个函数允许一个var声明等等。
- en: Now click on the **JSLint** button. Your browser will show the new validated
    result. Now you may take a look at the types of validation errors that have been
    detected by JSLint.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**JSLint**按钮。你的浏览器将显示新的验证结果。现在你可以看看JSLint检测到的验证错误类型。
- en: What just happened?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'You have just used JSLint to spot for validation errors. This is a simple process
    for JSLint: copy and paste your code into the text area and click on **JSLint**.
    Do not be surprised that there are so many validation errors; we are just starting
    out and we will learn how to fix and avoid such validation errors.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才使用了JSLint来查找验证错误。这是JSLint的一个简单过程：将你的代码复制粘贴到文本区域，然后点击**JSLint**。不要对出现的这么多验证错误感到惊讶；我们才刚刚开始，我们将学习如何修复和避免这些验证错误。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that the JavaScript that is embedded in the HTML form results
    in an error that says **missing use strict statement**. This error stems from
    the fact that JSLint believes in the use of the **use strict** statement, which
    allows the code to run under strict conditions. You will learn how to fix and
    avoid such problems in later parts of this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了，嵌入在HTML表单中的JavaScript导致了一个错误，提示**缺少use strict语句**。这个错误源于JSLint相信使用**use
    strict**语句，这使得代码能够在严格条件下运行。你将在本章的后部分学习如何修复和避免这类问题。
- en: You will continue to see many errors. In my opinion, this is evidence that valid
    code is not easy to achieve; but this is what we will achieve in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你将继续看到许多错误。在我看来，这是验证代码不容易实现的一个证据；但这是我们将在下一节实现的内容。
- en: As you have seen, there are various validation options, and at this stage, it
    is good enough if we pass the set requirements for **The Good Parts**. Therefore,
    well focus on how to fix these validation errors in the next section. But before
    that, I'll quickly discuss the valid code constructs that produce validation warnings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有各种各样的验证选项，在这个阶段，我们只要能让代码通过**好部分**的设定要求就足够了。因此，我们接下来将重点放在如何修复这些验证错误上。但在那之前，我会简要讨论产生验证警告的有效代码结构。
- en: Valid code constructs that produce validation warnings
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产生验证警告的有效代码结构
- en: You may have noticed that although our code construct is valid, it has produced
    validation warnings. You may be wondering if you should fix these or not. Here's
    some basic discussion to help you to decide.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了，尽管我们的代码结构是有效的，但它产生了验证警告。你可能在想是否应该修复这些问题。以下是一些基本讨论，帮助你做出决定。
- en: Should you fix valid code constructs that produce validation warnings?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该修复产生验证警告的有效代码结构吗？
- en: This depends on your objective. As I mentioned in [Chapter 1](ch01.html "Chapter 1. What
    is JavaScript Testing?"), *What is Javascript Testing?*, a code should at least
    be correct and work the way that we intend it to. Therefore, if your objective
    is to just create functionally-correct code, then you might not want to spend
    the time and effort to correct those validation warnings.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你的目标。如我在[第1章](ch01.html "第1章 什么是JavaScript测试？")中提到的，《什么是JavaScript测试？》，代码至少应该是正确的，按我们的意图工作。因此，如果你的目标是仅创建功能上正确的代码，那么你可能不想花时间和精力来修复这些验证警告。
- en: However, because you are reading this book, it is very likely that you want
    to learn how to test JavaScript, and validation is an important part of testing
    JavaScript as you will see later in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为你正在阅读这本书，你很可能会想知道如何测试JavaScript，正如你在本章后面将看到的，验证是测试JavaScript的重要部分。
- en: What happens if you don't fix them
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果你不修复它们会发生什么
- en: The main issue with invalidated code is that it will be much more difficult
    to maintain the code, in terms of readability and scalability. This problem becomes
    enhanced when you are working in teams and others have to read or maintain your
    code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无效代码的主要问题是，它将使代码的维护变得更为困难，在可读性和可扩展性方面。当团队合作时，这个问题会变得更严重，因为其他人必须阅读或维护你的代码。
- en: Valid code promotes good coding practices, which will help you to avoid problems
    down the road.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的代码促进了良好的编程实践，这将帮助你避免将来出现的问题。
- en: How to fix validation errors
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何修复验证错误
- en: This section will continue with the errors mentioned in the previous section,
    and together we'll attempt to fix them. Wherever possible, I'll provide some form
    of explanation as to why a particular piece of code is rendered as invalid. At
    the same time, the whole process of writing valid and functionally-code can be
    cumbersome. Therefore, I'll start off with validation errors that are much easier
    to fix, before I move on to tougher ones.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将继续讨论上一节中提到的错误，并尝试一起修复它们。在可能的情况下，我会解释为什么某段代码会被认为是无效的。同时，编写有效且功能性的代码整个过程可能会很繁琐。因此，我会先从更容易修复的校验错误开始，然后再逐步转向更难的错误。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we go along fixing the validation errors that we saw in the previous section,
    you may realize that fixing validation errors may require some form of compromise
    as to how you write your code. For example, you will understand that using `alert()`
    sparingly in your code is not considered a good coding style, at least according
    to JSLint. In this case, you will have to consolidate all of your `alert()` statements
    and group them into a function, while still maintaining the functionality of your
    code. More importantly, you will also realize that (perhaps) the best way to write
    valid code is to start writing valid code right from the first line of the code;
    you will see that correcting invalid code is an extremely tedious process, and
    there are times when you can only minimize your validation errors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修复上一节中看到的校验错误的过程中，你可能会意识到修复校验错误可能需要在编写代码的方式上做出一些妥协。例如，你会了解到在代码中谨慎使用`alert()`并不是一种好的编程风格，至少根据JSLint的说法是这样的。在这种情况下，你必须将所有的`alert()`声明合并到一个函数中，同时仍保持代码的功能性。更重要的是，你也会意识到（或许）编写有效代码的最佳方式是从代码的第一行开始就编写有效的代码；你会看到修复无效代码是一个极其繁琐的过程，有时你只能尽量减少校验错误。
- en: Along the way, you will get the chance to practice important JavaScript functions
    and, at the same time, learn how to code in a better style. Thus, this is probably
    the most important section of this chapter and I urge you to get your hands dirty
    with me. Before I get started on fixing the code, I'll first summarize the types
    of errors that are spotted by JSLint.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复代码的过程中，你将有机会练习重要的JavaScript函数，并学习如何编写更好的代码风格。因此，这可能是本章最重要的部分，我鼓励你和我一起动手实践。在开始修复代码之前，我首先总结一下JSLint发现的错误类型。
- en: Missing "use `strict`" statement
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少“use `strict`”声明。
- en: Unexpected use of `++`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外使用了`++`。
- en: Missing space after `), value, ==, if, else, +`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`), value, ==, if, else, +`后面缺少空格。
- en: Function names (such as debuggingMessages) are not defined or a function was
    used before it was defined
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名（如debuggingMessages）未定义或在使用定义之前就使用了函数。
- en: Too many `var` statements
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`声明过多。'
- en: '`===` used instead of `==`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了`===`而不是`==`。
- en: '`alert` is not defined'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alert`未定义。'
- en: '`<\/` used instead of`</`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了`<\/`而不是`</`。
- en: HTML event handlers used
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了HTML事件处理程序。
- en: 'Without further ado, well get started with the first validation error: `use
    strict`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不再多说，我们直接开始讲解第一个校验错误：“use strict”。
- en: Error missing "use strict" statement
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺少“use strict”声明的错误。
- en: 'The "`use strict`" statement is a relatively new feature in JavaScript that
    allows our JavaScript to run in a strict environment. In general, it catches little-known
    errors, and "forces" you to write stricter and valid code. John Resig, an expert
    in JavaScript, has written a nice summary about this topic, and you can read about
    it by following this link: [http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “use strict”语句是JavaScript中相对较新的特性，它允许我们的JavaScript在严格环境中运行。通常，它会捕获一些鲜为人知的错误，并“强制”你编写更严格、有效的代码。JavaScript专家John
    Resig就此话题写了一篇很好的总结，你可以通过这个链接阅读它：[http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/)。
- en: Time for action—fixing "use strict" errors
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——修复"use strict"错误。
- en: 'This error is extremely easy to fix. But be careful; enabling `use strict`
    may prevent your code from working, if your code is not valid. Here''s how we
    can fix this validation error:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误非常容易修复。但小心；如果代码无效，启用`use strict`可能会导致你的代码无法正常工作。以下是修复这个校验错误的方法：
- en: 'Open up your text editor, copy and paste the same code that we have been using,
    and append the following code snippet on the first line of your JavaScript code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的文本编辑器，复制并粘贴我们一直在使用的相同代码，并在你的JavaScript代码的第一行添加以下代码片段：
- en: '[PRE4]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save your code and test it out on JSLint. You will see that the error is now
    gone.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的代码并在JSLint上测试它。你会发现，现在错误已经消失了。
- en: You may notice that there is another missing `use strict` error that is related
    to your HTML form; do not worry, we will fix that in a later sub-section of this
    chapter. Now let us move on to the next error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到还有一个关于你的HTML表单的另一个缺失的`use strict`错误；不要担心，我们会在本章的稍后部分解决这个问题。现在让我们继续下一个错误。
- en: Error—unexpected use of ++
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误—意外使用++
- en: There is nothing programmatically wrong with this line of code. What we intend
    to achieve by using `++` is to increment `globalCounter` whenever the function
    `addResponseElement()` is called.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在程序上没有问题。我们使用`++`的目的是在调用函数`addResponseElement()`时递增`globalCounter`。
- en: 'However, JSLInt believes that there is a problem with using `++`. Take the
    following code snippets as an example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JSLint认为使用`++`有问题。以下代码片段为例：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous statements would look confusing to most programmers and hence it
    is considered bad style. More importantly, both of these statements are programmatically
    different and produce different results. For these reasons, we need to avoid statements
    like `++, --`, and so on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的陈述对大多数程序员来说可能看起来很困惑，因此被认为是坏的风格。更重要的是，这两个陈述在程序上是不同的，产生不同的结果。出于这些原因，我们需要避免使用`++`、`--`等这样的语句。
- en: Time for action—fixing the error of "Unexpected use of ++"
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间—修复"意外使用++"的错误
- en: 'This error is relatively easy to fix. All we need to do is avoid `++`. So navigate
    to the `addResponseElement()` function, and look for `globalCounter++`. Then change
    `globalCounter++` to `globalCounter = globalCounter + 1`. So, now your function
    has changed from this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误相对容易修复。我们只需要避免使用`++`。所以，导航到`addResponseElement()`函数，寻找`globalCounter++`。然后将`globalCounter++`更改为`globalCounter
    = globalCounter + 1`。所以，现在你的函数已经从这个样子：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 变成了这个样子：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compare the highlighted lines, and you will see the change in the code. Now
    let us move on to the next error.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 比较突出显示的行，你会看到代码的变化。现在让我们继续下一个错误。
- en: Error—functions not defined
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误—函数未定义
- en: This error is caused by the way that JavaScript engines and web pages are being
    rendered by web browsers. In [Chapter 1](ch01.html "Chapter 1. What is JavaScript
    Testing?"), *What is Javascript Testing*, we mentioned briefly that web page (and
    JavaScript) are being parsed from top to bottom on the client side. This means
    that anything that appears at the top will be read first, followed by that at
    the bottom.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是由JavaScript引擎和网页在浏览器中渲染的方式引起的。我们在[第1章](ch01.html "第1章 什么是JavaScript测试？")*什么是JavaScript测试？*中简要提到，网页（和JavaScript）在客户端从上到下解析。这意味着出现在顶部的东西将被首先阅读，然后是底部的东西。
- en: Time for action—fixing the error of "Functions not defined"
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间—修复"函数未定义"的错误
- en: 'Because this error is caused by the incorrect flow of the JavaScript functions,
    we will need to change the sequence of the functions. What we have done in [Chapter
    2](ch02.html "Chapter 2. Ad Hoc Testing and Debugging in JavaScript"), *Ad Hoc
    Testing and Degugging in Javascript*, is that we wrote the functions that we will
    be using first. This may be incorrect, as the functions may require data or functions
    that are only defined in later parts of the JavaScript code. Here''s a very simplified
    example:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个错误是由JavaScript函数的不正确流程引起的，我们需要改变函数的顺序。我们在[第2章](ch02.html "第2章 JavaScript的即兴测试和调试")*即兴测试和调试JavaScript*中做的是先写了我们将要使用的函数。这可能是错误的，因为这些函数可能需要的是只在JavaScript代码的后部分定义的数据或函数。这是一个非常简单的例子：
- en: '[PRE8]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Based on the previous code snippet, you will realize that `addTwoNumbers()`
    requires data returned from `numberOne()` and `numberTwo()`. The issue here is
    that the JavaScript interpreter will read `addTwoNumbers()` first before reading
    `numberOne()` and `numberTwo()`. However, both `numberOne()` and `numberTwo()`
    are being called by `addTwoNumbers()`, resulting in an incorrect flow of code.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于之前的代码片段，你将意识到`addTwoNumbers()`需要从`numberOne()`和`numberTwo()`返回的数据。这里的问题在于，JavaScript解释器在阅读`addTwoNumbers()`之前会先阅读`numberOne()`和`numberTwo()`。然而，`numberOne()`和`numberTwo()`都是由`addTwoNumbers()`调用的，导致代码流程不正确。
- en: 'This means that in order for our code to work correctly, we will need to rearrange
    the order of the functions. Continuing with the previous example, this is what
    we should do:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着，为了使我们的代码正确运行，我们需要重新排列函数的顺序。继续使用之前的例子，我们应该这样做：
- en: '[PRE9]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code snippet, we have rearranged the sequence of the functions.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们已经重新安排了函数的顺序。
- en: Now, we are going to rearrange the function's sequence. For our purposes, all
    that we need to do is to arrange our functions such that the first function that
    originally appeared in our code will now be the last, and the last function will
    be the first. Similarly, the second function that originally appeared in the JavaScript
    code will now be the second-to-last function. In other words, we will reverse
    the order of the code.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将重新排列函数的顺序。对我们来说，我们只需要将我们的函数安排成这样：原来在代码中的第一个函数现在是最后一个，最后一个函数现在是第一个。同样，原来在JavaScript代码中出现的第二个函数现在是倒数第二个。换句话说，我们将反转代码的顺序。
- en: Once you have reversed the order of the functions, save the file and test the
    code on JSLint. You should notice that the validation errors relating to functions
    not being defined are now gone.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您改变了函数的顺序，保存文件并在JSLint上测试代码。您应该注意到与函数未定义相关的验证错误现在消失了。
- en: Now, let us move on to the next validation error.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个验证错误。
- en: Too many var statements
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 太多的var声明
- en: According to JSLint, we have used too many `var` statements. What does this
    mean? This means that we have used more than one `var` statement in each function;
    in our case we have obviously used more than one `var` statement in each and every
    function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JSLint，我们使用了太多的`var`声明。这意味着什么？这意味着我们在每个函数中使用了不止一个`var`声明；在我们的案例中，我们显然在每个函数中都使用了不止一个`var`声明。
- en: How did this happen? If you scroll down and check the settings of JSLint, you
    will see a checkbox selected that says **Allow one var statement per function**.
    This means that the maximum number of `var` we can use is one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么发生的呢？如果你滚动到底部并检查JSLint的设置，你会看到一个复选框被选中，上面写着**每个函数只允许一个var声明**。这意味着我们最多只能使用一个`var`。
- en: Why is this considered to be good style? Although many coders may think that
    this is cumbersome, the author of JSLint would most probably believe that a good
    function should do only one thing. This would typically mean operating on only
    one variable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这被认为是好的风格呢？虽然许多程序员可能认为这是繁琐的，但JSLint的作者可能认为一个好的函数应该只做一件事。这通常意味着只操作一个变量。
- en: There's certainly room for discussion, but as we are all here to learn, let
    us get our hands dirty by fixing this validation error.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有很多讨论的空间，但既然我们都在这里学习，让我们动手修复这个验证错误。
- en: Time for action—fixing the error of using too many var statements
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——修复使用太多var声明的错误
- en: In order to fix this error, we will need to do some form of code refactoring.
    Although code refactoring typically means consolidating your code for it to become
    more concise (that is, shorter code), you may realize that refactoring your code
    to fit validation standards is a lot of work.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个错误，我们将需要进行某种代码重构。尽管代码重构通常意味着使您的代码更加简洁（即，更短的代码），您可能意识到将代码重构以符合验证标准是一项艰巨的工作。
- en: What we will do in this section is that we will change (almost) all single `var`
    statements that save a value into a function.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们将更改（几乎）所有将值保存到函数中的单个`var`声明。
- en: 'The code that is mainly responsible for this particular validation error is
    found `checkForm` function. The statements that we will need to refactor are as
    follows:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 负责这个特定验证错误的代码是在`checkForm`函数中找到的。我们需要重构的语句如下：
- en: '[PRE10]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we''ll start to refactor our code. For each of the variables defined, we
    need to define a function with the following format:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将开始重构我们的代码。对于每个定义的变量，我们需要定义一个具有以下格式的函数：
- en: '[PRE11]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I''ll start off with an example. For instance, for `totalInputElements` this
    is what I will do:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我将从一个例子开始。例如，对于`totalInputElements`，我将这样做：
- en: '[PRE12]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Based on the previous code, do something similar to what you are going to see
    here:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于之前的代码，对您即将看到的内容做类似的事情：
- en: '[PRE13]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let us move on to the next error.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个错误。
- en: Expecting <\/ instead of <\
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期待<\/而不是<\
- en: For most of us, this error is probably one of the most intriguing. We have this
    validation error because the HTML parser is slightly different to the JavaScript
    interpreter. In general, the extra backslash is being ignored by the JavaScript
    compiler, but not by the HTML parser.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们大多数人来说，这个错误可能是最有趣的。我们之所以有这个验证错误，是因为HTML解析器与JavaScript解释器略有不同。通常，额外的反斜杠被JavaScript编译器忽略，但不被HTML解析器忽略。
- en: Such validation errors may appear unnecessary, but Doug Crockford knows that
    this has some form of impact on our web page. Therefore, let us move on to how
    to fix this error.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的验证错误可能看起来不必要，但Doug Crockford知道这对我们的网页有一定的影响。因此，让我们继续解决这个错误的方法。
- en: Time for action—fixing the expectation of '<\/' instead of '</'
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间—解决期望的'<\/'而不是'</'错误
- en: Although this error is one of the most intriguing, it is one of the easiest
    to fix. All that we need to do is to find all of the JavaScript statements that
    contain`</` and change them to`<\/`. The function that is mainly responsible for
    this error is `buildFinalResponse()`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个错误是最引人入胜的，但它是最容易解决的。我们所需要做的就是找到所有包含`</`的JavaScript语句，并将它们更改为`<\/`。主要负责这个错误的功能是`buildFinalResponse()`。
- en: 'Scroll down to the function `buildFinalResponse()`, and change all statements
    that have`</` to`<\/`. After you are done, you should have the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到`buildFinalResponse()`函数，将所有含有`</`的语句更改为`<\/`。完成后，你应该有以下代码：
- en: '[PRE14]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that all`</` have been changed to`<\/`. You may also want to search through
    the code and see if any such errors are remaining.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有`</`都已更改为`<\/`。你可能还想检查代码，看看是否有这样的错误残留。
- en: Now, with this error fixed, we can move on to the next validation error.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，解决了这个错误后，我们可以继续解决下一个验证错误。
- en: Expected '===' but found '=='
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期望'==='但找到'=='
- en: In JavaScript and in most programing languages, `==` and `===` are significantly
    different. In general, `===` is stricter than `==`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript和大多数编程语言中，`==`和`===`有显著的区别。一般来说，`===`比`==`更严格。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The key difference between `===` and `==` in JavaScript is that `===` is a strict
    equal operator and it will return a Boolean true if, and only if, both the operands
    are equal and of the same type. On the other hand, the `==` operator returns a
    Boolean true if both the operands are equal, even if they are of different types.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中`===`和`==`的主要区别在于，`===`是一个严格等于运算符，只有当两个操作数相等且类型相同时，它才会返回布尔值`true`。另一方面，`==`运算符如果两个操作数相等，即使它们类型不同，也会返回布尔值`true`。
- en: According to JSList, `===` should be used when comparing a variable to a truth
    value, because it is stricter than `==`. In terms of code strictness, JSLint is
    certainly correct in ensuring code quality. Therefore, let us now correct this
    error.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JSList，当比较变量与真理值时应使用`===`，因为它比`==`更严格。在代码严格性方面，JSLint确保代码质量是正确的。因此，现在让我们纠正这个错误。
- en: Time for action—changing == to ===
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间—将`==`更改为`===`
- en: Due to the reasons mentioned earlier, we will now change all `==` to `===`,
    for statements that require comparison. Although this error is relatively easy
    to fix, we need to understand the importance of this error. `===` is much stricter
    than `==`, and therefore it is more secure and valid to use `===` instead of `==`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面提到的原因，我们现在将所有`==`更改为`===`，用于需要比较的语句。尽管这个错误相对容易解决，但我们需要了解这个错误的重要性。`===`比`==`严格得多，因此使用`===`而不是`==`更为安全和有效。
- en: Going back to your source code, search for all comparison statements that contain
    `==` and change them to `===. ==` is found largely at `if`, and `else-if` statements,
    because it is used for comparisons.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你的源代码，搜索所有包含`==`的比较语句并将它们更改为`===`. `==`主要出现在`if`和`else-if`语句中，因为它们用于比较。
- en: Once you are done, you may want to test out your updated code at JSLint and
    see if you have cleared all such errors.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可能想测试一下你的更新后的代码是否通过了JSLint，并看看你是否清除了所有这类错误。
- en: 'Now, let us move on to yet another cumbersome error: "Alert is not defined".'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续处理另一个繁琐的错误："Alert is not defined"。
- en: Alert is not defined
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Alert is not defined
- en: In general, using `alert` by itself leads to 'pollution' of the global namespace.
    Although it is convenient, this is bad code practice according to JSLInt. Therefore,
    the strategy that we are going to use to fix this validation error is to use some
    form of code refactoring (again).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单独使用`alert`会导致全局命名空间的"污染"。尽管它很方便，但根据JSLint，这是一种不好的代码实践。因此，我们将要使用的解决这个验证错误的方法是再次进行某种代码重构。
- en: In our code, you should notice that we are largely using `alert()` to provide
    feedback in terms of the function names, error messages, and so on. We will need
    to use our `alert()` such that it can take in various forms of messages.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，你应该注意到我们主要使用`alert()`来提供关于函数名、错误消息等方面的反馈。我们需要使我们的`alert()`能够接受各种形式的消息。
- en: Time for action—fixing "Alert is not defined"
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间—解决"Alert is not defined"错误
- en: What we will do is that we will consolidate all `alert()` statements into one
    function. We can pass a parameter to that function so that we can change the messages
    in the alert box depending on the situation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做的是将所有的`alert()`语句合并到一个函数中。我们可以向该函数传递一个参数，以便根据情况改变警告框中的消息。
- en: 'Go back to your code, and define the following function at the top of your`<script>`
    tag:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你的代码，在`<script>`标签的顶部定义以下函数：
- en: '[PRE15]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`messageObject` is the parameter that we will use to hold our message.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageObject`是我们将用来保存我们消息的参数。'
- en: Now, change all `alert()` statements to `alertMessage()` such that the message
    for `alert()` is the same as `alertMessage()`. Once you are done, save the file
    and run the code in JSLint again.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将所有的`alert()`语句更改为`alertMessage()`，以确保`alert()`的消息与`alertMessage()`的消息相同。完成后，保存文件并再次运行JSLint代码。
- en: If you tried running your code in JSLint, you should see that the "damage" done
    by `alert()` has been minimized to only one time, instead of over ten to twenty
    times.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行你的代码在JSLint中，你应该看到`alert()`造成的“损害”已经减少到只有一次，而不是十到二十次。
- en: In this situation, what we can do is minimize the impact of the `alert()` because,
    for our purposes, we do not have a ready alternative to show messages in an alert
    box.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以做的是最小化`alert()`的影响，因为对于我们来说，没有一个现成的替代方案可以在警告框中显示消息。
- en: Now it is time for the next error—avoiding HTML event handlers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是避免HTML事件处理程序的下一个错误的时候了。
- en: Avoiding HTML event handlers
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用HTML事件处理程序
- en: Good coding practices often state the need to separate programing logic and
    design. In our case, we have embedded event handlers (JavaScript events) within
    the HTML code. According to JSLint, such coding could be improved by avoiding
    HTML event handlers altogether.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的编码实践通常指出需要将编程逻辑与设计分离。在我们的案例中，我们在HTML代码中嵌入了事件处理程序（JavaScript事件）。根据JSLint，这种编码可以通过完全避免HTML事件处理程序来改进。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the ideal case is to separate programing logic from design, there is
    nothing functionally wrong in using HTML intrinsic event handlers. You may want
    to consider whether it is worth it (in terms of time, maintainability, and scalability)
    to adhere to (almost) perfect coding practices. In the later part of this sub-section,
    you may find that it can be cumbersome (or even irritating) to try to validate
    (and functionally correct) code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管理想情况下是将编程逻辑与设计分离，但在使用HTML内置事件处理程序方面并没有什么功能上的问题。你可能需要考虑这是否值得（在时间、可维护性和可扩展性方面），坚持（几乎）完美的编码实践。在本节的后部分，你会发现尝试验证（并功能正确）代码可能会很繁琐（甚至令人烦恼）。
- en: In order to solve this validation error, we will need to use event listeners.
    However, due to the problems posed by the compatibility of event listeners, we
    will be using JavaScript libraries to help us to deal with inconsistencies among
    the support for event listeners. We will be using JQuery in this example.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个验证错误，我们将需要使用事件监听器。然而，由于事件监听器的兼容性问题，我们将使用JavaScript库来帮助我们处理事件监听器支持的不一致性。在这个例子中，我们将使用JQuery。
- en: 'JQuery is a JavaScript library created by John Resig. You can download JQuery
    by visiting this link: [http://jquery.com](http://jquery.com). As described on
    this website, "JQuery is a fast and concise JavaScript Library that simplifies
    HTML document traversing, event handling, and animating, and Ajax interactions
    for rapid web development." In my personal experience, JQuery certainly makes
    life easier by fixing many sticky issues such as DOM incompatibilities, providing
    built-in methods to create animation, and many other things. I certainly urge
    you to follow a starter tutorial by going to: [http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery](http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: JQuery是一个由John Resig创建的JavaScript库。你可以通过访问这个链接下载JQuery：[http://jquery.com](http://jquery.com)。正如这个网站所描述的，“JQuery是一个快速和简洁的JavaScript库，它简化了HTML文档遍历、事件处理和动画，以及Ajax交互，用于快速网页开发。”在我的个人经验中，JQuery确实通过修复许多棘手问题（如DOM不兼容性、提供内置方法创建动画等）使生活变得更容易。我当然建议你通过访问以下链接跟随一个入门教程：[http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery](http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery)
- en: Time for action—avoiding HTML event handlers
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间—避免HTML事件处理程序
- en: In this section, you will learn how to avoid HTML event handlers by coding in
    a different style. In this case, we will not only remove the JavaScript events
    embedded in each of the HTML input elements, we will also need to write new functions
    for our JavaScript application in order for it to work in the same manner. In
    addition to that, we will be using a JavaScript library that will help us to remove
    all of the difficult stuff relating to event handling and using event listeners.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何通过不同的编码方式避免HTML事件处理程序。在这种情况下，我们不仅删除了每个HTML输入元素中嵌入的JavaScript事件，还需要为我们的JavaScript应用程序编写新函数，使其以相同的方式工作。此外，我们将使用一个JavaScript库，帮助我们删除与事件处理和事件监听器相关的所有复杂内容。
- en: 'Open up the same document and scroll to the`<body>` tags. Remove all of the
    HTML event handlers that are found in the form. This is what your form''s source
    code should look like after you have removed all of the HTML event handlers:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开同一文档，滚动到`<body>`标签。删除在表单中找到的所有HTML事件处理程序。在你删除了所有的HTML事件处理程序后，你的表单源代码应该看起来像这样：
- en: '[PRE16]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now scroll to the`</style>` tag. After the`</style>` tag, enter the following
    code snippet:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在滚动到`</style>`标签。在`</style>`标签之后，输入以下代码片段：
- en: '[PRE17]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What you are doing in the preceding line is enabling JQuery in your code. This
    will allow you to make use of the JQuery library when fixing your code. Now it's
    time to write some JQuery code.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前一行中，你正在使JQuery在你的代码中生效。这将允许你在修复代码时使用JQuery库。现在该写一些JQuery代码了。
- en: 'In order to maintain the functionality of our code, we will need to use the
    `.blur()` method provided by JQuery. Scrolling to the end of your JavaScript code,
    append the following code snippet:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了维持我们代码的功能，我们将需要使用JQuery提供的`.blur()`方法。滚动到你的JavaScript代码的末尾，添加以下代码片段：
- en: '[PRE18]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s a short explanation of how JQuery works: `jQuery(document).ready(function
    ()`is used to start our code; it allows us to use the methods provided in JQuery.
    In order to select an element, we use `jQuery(''#nameOfPerson'')`. As mentioned
    earlier, we need to maintain the functionality of the code, so we will use the
    `.blur()` method provided by JQuery. In order to do that, we append `.blur()`
    to `jQuery(''#nameOfPerson'')`. We are required to call `submitValues()`, and
    we will need to enclose `submitValues()` within `.blur()`. Because `submitValues()`
    is a function, we will enclose it as such:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是对JQuery工作方式的简短解释：`jQuery(document).ready(function ()`用于启动我们的代码；它允许我们使用JQuery提供的方法。为了选择一个元素，我们使用`jQuery('#nameOfPerson')`。如前所述，我们需要保持代码的功能，所以我们将使用JQuery提供的`.blur()`方法。为此，我们将`.blur()`添加到`jQuery('#nameOfPerson')`中。我们需要调用`submitValues()`，因此我们需要将`submitValues()`包含在`.blur()`中。因为`submitValues()`是一个函数，所以我们将它这样包含：
- en: '[PRE19]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point of time, we should have completed the necessary corrections in
    order to achieve valid and functional code. I'll briefly summarize the corrections
    in the next section.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此时，我们应该已经完成了必要的修正，以实现有效和功能的代码。我在下一节中简要总结一下这些修正。
- en: Summary of the corrections we have done
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们所做修正的总结
- en: Now we will refresh our memory by quickly going through what we have done to
    fix the validation errors.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过快速回顾我们所做以修复验证错误的步骤来刷新我们的记忆。
- en: First, we pasted the original code into JSLint and noticed that we had a large
    number of validation errors. Fortunately, the validation errors could be grouped
    such that similar errors could be fixed by correcting a single code error.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将原始代码粘贴到JSLint中，并注意到我们有大量的验证错误。幸运的是，这些验证错误可以分组，这样相同的错误可以通过修正一个代码错误来解决。
- en: Next, we started off with the correction process. In general, we tried to fix
    the validation errors, starting from those which seemed to be the easiest. The
    first validation error that we fixed was the missing `use strict` statement error.
    What we did was enter `use strict` on the very first line of our JavaScript code,
    and that error was fixed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始了修正过程。一般来说，我们试图从那些看起来最容易的验证错误开始修复。我们修复的第一个验证错误是缺少`use strict`声明的错误。我们所做的是在我们的JavaScript代码的第一行输入`use
    strict`，这样就修复了错误。
- en: 'The second validation error that we fixed was the "functions not defined error".
    This was caused by an incorrect flow of the JavaScript functions. Therefore, we
    switched the flow of functions from this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修复的第二个验证错误是“函数未定义错误”。这是由于JavaScript函数的不正确流程造成的。因此，我们将函数的流程从这：
- en: '[PRE20]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个程度：
- en: '[PRE21]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we simply reversed the sequence of the functions to fix the error.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只是简单地反转了函数的顺序来修复错误。
- en: We then moved on to an error that is quite time-consuming—using too many `var`
    statements within a function. In general, our strategy was to refactor almost
    all of the `var` statements into standalone functions. These standalone functions'
    main purpose was to return a value, and that's all.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向了一个非常耗时的错误——在函数内使用太多的`var`声明。总的来说，我们的策略是将几乎所有的`var`声明重构为独立的函数。这些独立函数的主要目的是返回一个值，仅此而已。
- en: 'Next, we moved into yet another time-consuming validation error, and this was
    "expected`<\/` instead of`</`. In general, this error is referring to the closing
    HTML tags. So what we did was to change `/>` to `\/>` for all closing HTML tags.
    For example, we changed the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们又转向了另一个耗时的验证错误，那就是"expected`<\/` instead of`</`。一般来说，这个错误是指闭合的HTML标签。所以我们所做的就是将所有的闭合HTML标签中的`/>`更改为`\/>`。例如，我们将以下代码更改为：
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个：
- en: '[PRE23]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the highlighted lines are where we have changed from `/>` to `\/>`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，高亮的行是我们将`/>`更改为`\/>`的地方。
- en: After fixing the previous error, we moved on to an error that is conceptually
    more difficult to understand, but easy to solve. That is, "expected `===` instead
    of saw `==`". According to JSLint, using `===` is stricter and more secure as
    compared to using `==`. Therefore, we needed to change all `==` to `===`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复上一个错误后，我们转向了一个概念上更难以理解，但容易解决的错误。那就是，"expected `===` instead of saw `==`"。根据JSLint，使用`===`比使用`==`更严格，更安全。因此，我们需要将所有的`==`更改为`===`。
- en: The next error, "Alert is not defined", is conceptually similar to the "Too
    many `var` statement" error. What we need to do is to refactor all `alert()` statements
    to call the `alertMessage()` function that accepts a parameter `messageObject`.
    This allows us to use only one `alert()` for almost the whole JavaScript program.
    Whenever we need to use an alert box, all we need to do is to pass an argument
    into the `alertMessage()` function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个错误，"Alert is not defined"，在概念上与"Too many `var` statement"错误相似。我们需要做的是将所有的`alert()`声明重构为接受参数`messageObject`的`alertMessage()`函数。这使我们能够在几乎整个JavaScript程序中只使用一个`alert()`。每当我们需要使用一个警告框时，我们只需要向`alertMessage()`函数传递一个参数。
- en: 'Finally, we moved on to fix one of the toughest validation errors: "Avoiding
    HTML event handlers". Due to the complexities involved with event listeners, we
    engaged the help of JQuery, a popular JavaScript library, and wrote some JQuery
    code. Firstly, we removed all of the HTML event handlers from our HTML form. Our
    HTML form changed from this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们转向修复一个最棘手的验证错误："避免使用HTML事件处理程序"。由于事件监听器的复杂性，我们得到了流行的JavaScript库JQuery的帮助，并编写了一些JQuery代码。首先，我们从我们的HTML表单中移除了所有的HTML事件处理程序。我们的HTML表单从这样变成了：
- en: '[PRE24]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个：
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to support the new HTML form, we linked in the JQuery library, and
    added some code to listen for the HTML form events, like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持新的HTML表单，我们链接了JQuery库，并添加了一些代码来监听HTML表单事件，像这样：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The completed code can be found in the `source code` folder for `Chapter 3`,
    with a file name of `perfect-code-for-JSLint.html`. You can compare this with
    your edited code to see if you have understood what we were trying to do. Now,
    you may want to copy and paste the code into JSLint and see how it goes. You will
    only see errors pertaining to the use of Jquery, one validation error that complains
    about the use of `alert()`, and another error about using too many `var` statements.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的代码可以在`source code`文件夹下的`Chapter 3`中找到，文件名为`perfect-code-for-JSLint.html`。你可以将这个与你编辑的代码进行比较，看看你是否理解了我们试图做什么。现在，你可能想将代码复制粘贴到JSLint中看看效果如何。你将只会看到与Jquery使用相关的错误，一个关于使用`alert()`的验证错误，以及另一个关于使用太多`var`声明的错误。
- en: What just happened?
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have corrected the bulk of the validation errors, from an insanely large
    number of validation errors to less than ten validation errors, out of which only
    two or three of the validation errors are related to our code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经纠正了大部分的验证错误，从极其大量的验证错误减少到少于十个验证错误，其中只有两个或三个与我们的代码相关。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed the `jQuery not defined` error. Although JSLint has captured
    the JQuery library that was externally linked, it does not explicitly read the
    code, thus resulting in the `jQuery not defined` error.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`jQuery not defined`错误。尽管JSLint捕获了外部链接的JQuery库，但它并不显式阅读代码，因此导致了`jQuery
    not defined`错误。
- en: Now that we have fixed the validation errors, let us now move on to another
    free validation tool, the JavaScript Lint.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修复了验证错误，让我们接下来使用另一个免费的验证工具——JavaScript Lint。
- en: JavaScript Lint—a tool you can download
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript Lint—一个你可以下载的工具。
- en: JavaScript Lint can be downloaded at [http://www.javascriptlint.com](http://www.javascriptlint.com),
    and it works in a manner similar to JSLint. The key difference is that JavaScript
    Lint is a downloadable tool, whereas JSLint works as a web-based tool.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript Lint 可以在[http://www.javascriptlint.com](http://www.javascriptlint.com)下载，其工作方式与
    JSLint 类似。主要区别在于，JavaScript Lint 是一个可下载的工具，而 JSLint 作为一个基于网页的工具运行。
- en: 'Like JSLint, JavaScript Lint is capable of spotting the following common errors:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JSLint 一样，JavaScript Lint 能够找出以下常见错误：
- en: Missing semicolons at the end of a line
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行尾缺少分号：在每行末尾都要加上分号。
- en: Curly braces without an `if, for`, and `while`
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`if, for`和`while`的括号。
- en: Statements that do not do anything
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不执行任何操作的语句。
- en: Case statements in a switch that turn decimal points into a number
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 switch 语句中的 case 语句将小数点转换为数字。
- en: You can read more about its functionality by visiting its home page at [http://www.javascriptlint.com.](http://www.javascriptlint.com.)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问其主页[http://www.javascriptlint.com](http://www.javascriptlint.com)了解更多关于它的功能。
- en: To learn about how to use JavaScript Lint, you may follow the tutorials found
    at the website.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 JavaScript Lint，您可以跟随网站上找到的教程。
- en: If you are using Windows, you may need to read the set-up instructions found
    at [http://www.javascriptlint.com/docs/running_from_windows_explorer.htm](http://www.javascriptlint.com/docs/running_from_windows_explorer.htm)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用 Windows，您可能需要阅读在[http://www.javascriptlint.com/docs/running_from_windows_explorer.htm](http://www.javascriptlint.com/docs/running_from_windows_explorer.htm)找到的设置说明。
- en: If you are using Linux based operating systems, you can check out the instructions
    found at [http://www.javascriptlint.com/docs/running_from_the_command_line.htm](http://www.javascriptlint.com/docs/running_from_the_command_line.htm)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用基于 Linux 的操作系统，您可以查看在[http://www.javascriptlint.com/docs/running_from_the_command_line.htm](http://www.javascriptlint.com/docs/running_from_the_command_line.htm)找到的说明。
- en: Finally, if you wish to integrate JavaScript Lint into your IDE such as Visual
    Studio, you can read more about how to do this by visiting [http://www.javascriptlint.com/docs/running_from_your_ide.htm](http://www.javascriptlint.com/docs/running_from_your_ide.htm)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果您希望将 JavaScript Lint 集成到您的 IDE（如 Visual Studio）中，您可以通过访问[http://www.javascriptlint.com/docs/running_from_your_ide.htm](http://www.javascriptlint.com/docs/running_from_your_ide.htm)了解更多有关如何执行此操作的信息。
- en: We will not be discussing "how to fix validation errors spotted by JavaScript
    Lint" because the principles are similar to JSLint. However, we challenge you
    to fix the remaining errors (apart from those caused by JQuery)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会讨论如何修复由 JavaScript Lint 发现的验证错误，因为这些原则与 JSLint 相似。然而，我们挑战你修复剩余的错误（除了由 JQuery
    引起的错误）。
- en: Challenge yourself—fix the remaining errors spotted by JSLint
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战自己——修复 JSLint 发现的剩余错误。
- en: 'Ok, this is the first challenge that I will I present to you. Fix the remaining
    errors spotted by JSLint, which are as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我将向您提出的第一个挑战。修复 JSLint 发现的剩余错误，具体如下：
- en: '**alert is not defined":** This is found in the `alertMessage()` function'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"alert is not defined"：** 此错误在`alertMessage()`函数中找到。'
- en: '**too many var statements":** This error is found in the `submitValues()` function'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**太多的 var 声明：** 此错误在`submitValues()`函数中找到。'
- en: 'Here are some ideas for you to get started:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供您开始的想法：
- en: In our JavaScript application, is there any way that we can avoid the `alert()?`
    How can we display messages that can capture the attention of our audience but
    at the same time be valid?
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 JavaScript 应用程序中，有没有办法避免使用`alert()`？我们如何显示能吸引观众注意力的信息，同时又是有效的？
- en: For the error found at the `submitValues()` function, how can we refactor the
    code such that there is only one `var` statement in the function? Can we refactor
    the `var` statement into a function and have it return a Boolean value?
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于在`submitValues()`函数中发现的错误，我们如何重构代码，使得函数中只有一个`var`声明？我们可以将`var`声明重构为一个函数，并让它返回一个布尔值吗？
- en: OK, now you might want to give it a go, but be careful, because the solutions
    that you propose or intend to use may cause other validation errors. So you might
    want to think about your solutions before implementing them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你可能想试试，但要注意，你所提出的或打算使用的解决方案可能会导致其他验证错误。所以你可能会在实施之前考虑一下你的解决方案。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've finally reached the end of this chapter. I'll first start off by summarizing
    some of the strategies and tips we have used to write valid code, and follow this
    with a summary of the rest of the chapter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了这一章的结尾。我首先开始总结我们用来编写有效代码的一些策略和小贴士，然后概述了章节的其余部分。
- en: 'Some of the strategies that we have used to write valid code (according to
    JSLint) are as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来编写有效代码（根据JSLint）的某些策略如下：
- en: Properly space your code, especially after mathematical signs, `if, else, (
    )`, and so on
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当间距你的代码，特别是在数学符号后，`if, else, ( )`等地方
- en: Use only one `var` statement per function
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数中只使用一个`var`声明
- en: Consider the flow of your program; code in such a way that the required data
    or functions come at the top of the program
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑你的程序流程；编写代码时，确保所需数据或函数位于程序顶部
- en: Use the `alert()` function sparingly. Instead, consolidate your `alert()` functions
    into one function
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎使用`alert()`函数。相反，将你的`alert()`函数合并成一个函数
- en: Use `===` instead of `==`; this makes sure that your comparison statements are
    more accurate
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`===`而不是`==`；这确保了你的比较语句更加准确
- en: Avoid HTML event handlers by using listeners. Alternatively, you may engage
    the help of JavaScript libraries such as JQuery in order to provide event listeners
    to your code.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用HTML事件处理程序，而是使用监听器。另外，你可以借助JavaScript库（如JQuery）提供事件监听器给你的代码。
- en: 'Finally, we covered the following topics:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了以下主题：
- en: The difference between testing and validating
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与验证之间的区别
- en: How validation helps us to write good code
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证如何帮助我们写出好代码
- en: What issues may occur if we do not validate our code—if we do not validate our
    code, it might not be scalable, less readable, and result in unexpected errors
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不验证代码，可能会出现什么问题——如果我们不验证代码，它可能不具备可扩展性，可读性较差，并可能导致意外错误
- en: How we can use JSLint and JavaScript Lint to validate our code
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JSLint和JavaScript Lint验证我们的代码
- en: Now that we have learned how we can test JavaScript by validation tools, you
    might want to think about the strategy that we can adopt when we intend to test
    our code. As shown in the example in this chapter, writing valid code (or correcting
    invalid code) is an extremely tedious process. More importantly, there are some
    validation warnings or errors that do not affect our program in its entirety.
    In such a situation, do you think that it is worth the effort to validate our
    code? Or do you think we should be a perfectionist and write perfect code? This
    will very much depend on our testing plan, which will dictate the scope of testing,
    the things to test, and many other things. These topics will be covered in next
    chapter, [Chapter 4](ch04.html "Chapter 4. Planning to Test"), *Planning to Test*.
    So I'll end off this chapter, and see you in the next chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经学习了如何通过验证工具测试JavaScript，你可能想考虑一下当我们打算测试代码时可以采用的策略。正如本章中的示例所示，编写有效代码（或修正无效代码）是一个非常繁琐的过程。更重要的是，有些验证警告或错误并不影响我们程序的整个运行。在这种情况下，你认为验证代码值得花费精力吗？还是认为我们应该追求完美，写出完美的代码？这很大程度上取决于我们的测试计划，这将决定测试的范围、要测试的内容以及其他许多内容。这些主题将在下一章[第四章](ch04.html
    "Chapter 4. Planning to Test")，*计划测试*中介绍。所以，我将在本章结束，下章再见。
