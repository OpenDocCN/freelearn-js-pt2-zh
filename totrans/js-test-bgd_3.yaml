- en: Chapter 3. Syntax Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build on what we have learned in the previous chapters, we will now move
    on to a slightly tougher topic—validating JavaScript. In this chapter you can
    expect two broad topics—the issues surrounding validation and testing of JavaScript
    code, and how to use JSLint and JavaScript Lint (which is a free JavaScript validator)
    to check your JavaScript code, and how to debug them. I'll explicitly show you
    how to spot validation errors using JSLint and then, how to fix them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will briefly mention the difference between validating and testing JavaScript
    and some of the issues that you might have to consider when you are validating
    or testing your code. You will also understand the relationship between valid
    HTML and CSS with JavaScript, and how attempting to write quality code can help
    you reduce errors in your JavaScript code. More importantly, we will learn about
    two free tools that are often used to validate JavaScript code, how to make use
    of it to check your code, and most importantly, how to fix validation errors that
    are detected.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between validating and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a good code editor can help you spot validation errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes a code quality code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need HTML and CSS to be valid before we start working on JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why JavaScript embedded in HTML may be reported as invalid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common JavaScript errors that are detected by validating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSLint and JavaScript Lint—how to use it to check your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Valid code constructs that produce validation warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fix validation errors that are spotted by JSLint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So without further ado, let us get started with a lighter topic—the difference
    between validating and testing.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between validating and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a thin line separating validating and testing. If you have some idea
    about sets (as in sets from mathematics), I would say that validation can lead
    to better testing results, while testing does not necessarily lead to a valid
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider the scenario—you wrote a JavaScript program and tested it on
    major browsers such as the Internet Explorer and Firefox; and it worked. In this
    case, you have tested the code to make sure that it is functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the same code that you have created may or may not be valid; valid
    code is akin to writing a code that has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Well formed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has good coding style (such as proper indentation, well-commented code, properly
    spaced)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meets the specification of the language (in our case, JavaScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There may come a point in time where you will notice that good coding style
    is highly subjective—there are various validators that may have different opinions
    or standards as to what is known as "good coding style". Therefore, if you do
    use different validators to validate your code, do not freak out if you see different
    advice for your coding style.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean that valid code leads to code that is functional (as you
    will see later) and that code that is functional leads to validated code as both
    have different standards for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: However, valid code often leads to less errors, and code that is both functional
    and valid is often quality code. This is due to the fact that writing a piece
    of JavaScript code, that is both valid and correct, is much more difficult than
    just writing a code that is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Testing often means that we are trying to get the code working correctly; while
    validation is making sure that the code is syntactically correct, with good style
    and that it meets the specification of the language. While good coding styles
    may be subjective, there is often a coding style that is accepted by most programmers,
    such as, making sure that the code is properly commented, indented, and there
    is no pollution of the global namespace (especially in the case of JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the case clearer, following are three situations that you can consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Code that is valid but wrong—validation doesn't find all the errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This form of errors would most probably be caused by logic errors in JavaScript.
    Consider what we have learned in the previous chapters; logic errors can be syntactically
    correct but they may be logically flawed.
  prefs: []
  type: TYPE_NORMAL
- en: A classic example would be an infinite `for` loop or infinite `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Code that is invalid but right
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This would most probably be the case for most functional code; a piece of JavaScript
    may be functionally correct and working, but it may be invalid. This may be due
    to poor coding style or any other characteristics in a valid code that are missing.
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, you will see a full working example of a piece of
    JavaScript code that is right but invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Code that is invalid and wrong—validation finds some errors that might be difficult
    to spot any other way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, the code error can be caused by all three forms of JavaScript
    errors that are mentioned in [Chapter 1](ch01.html "Chapter 1. What is JavaScript
    Testing?"), *What is JavaScript Testing*, loading errors, runtime errors, and
    logic errors. While it is more likely that errors caused by syntax errors might
    be spotted by good validators, it is also possible that some errors are buried
    deep inside the code, such that it is difficult to spot them using manual methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some common understanding as to what validation and testing
    is about, let us move on to the next section which discusses the issues surrounding
    quality code.
  prefs: []
  type: TYPE_NORMAL
- en: Code quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are many views as to what is quality code, I personally believe
    that there are a few agreed standards. Some of the most commonly mentioned standards
    may include code readability, ease of extension, efficiency, good coding style,
    and meeting language specifications, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For our purpose here, we will focus on the factors that make a piece of code
    valid—coding style and meeting specifications. In general, good coding style almost
    guarantees that the code is highly readable (even to third parties) and this will
    help us to spot errors manually.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, having a good coding style allows us to quickly understand
    the code, specially if we need to work in teams or are required to debug the code
    on our own.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we will focus on the importance of code validity for testing
    purposes in later parts of the chapter. But now, let us start with the first building
    block of quality code—valid HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: HTML and CSS needs to be valid before you start on JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In chapter one, we have a common understanding that JavaScript breathes life
    into a web page by manipulating the Document Object Model **(DOM)** of the HTML
    documents. This means that the DOM must be present in the code before JavaScript
    can operate on it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Heres an important fact that is directly related to HTML, CSS, and browsers
    browsers are generally forgiving towards invalid HTML and CSS code as compared
    to compilers for languages like C or Python. This is because, all browsers have
    to do is parse the HTML and CSS so as to render the web page for its browsers.
    On the other hand, compilers are generally unforgiving towards invalid code. Any
    missing tag, declarations, and so on will lead to a compilation error. Therefore,
    it is ok to write invalid or even buggy HTML and CSS, yet get a "usual" looking
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the previous explanation, we should see that we would need to have
    valid HTML and CSS in order to create quality JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A short list of reasons, based on my personal experience, as to why valid HTML
    and CSS is an important prerequisite before you start working on JavaScript are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Valid HTML and CSS helps ensure that JavaScript works as intended. For example,
    consider a situation where you might have two div elements that have the same
    `id` (In the previous chapters, we have mentioned that the `div id` attribute
    is meant to give unique IDs for each HTML elements), and your JavaScript contains
    the piece of code that is supposed to work on the above mentioned HTML element
    with the id. This will result in unintended consequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Valid HTML and CSS helps improve the predictability on how your web page will
    work; there is no point trying to fix buggy HTML or CSS using JavaScript. You
    are most probably better off if you start with valid HTML and CSS, and then apply
    JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid HTML and CSS may result in different behaviour in different browsers.
    For example, an HTML tag that is not enclosed may be rendered differently in different
    browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, one of the most important building blocks of creating quality JavaScript
    code is to have valid HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you don't validate your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may disagree with me on the previous section as to why HTML and CSS should
    be valid. In general, validation helps you to prevent errors that are related
    to coding style and specifications. However, do take note that using different
    validators may give you different results since validators might have different
    standards in terms of code style.
  prefs: []
  type: TYPE_NORMAL
- en: In case you are wondering if invalid code can affect your JavaScript code, I
    would advise you to make your code as valid as possible; invalid code may lead
    to sticky issues such as cross-browser incompatibility, difficulty in reading
    code, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Invalidated code means that your code may not be foolproof; in the early days
    of the Internet, there were websites that were dependent on the quirks of the
    early Netscape browser. Back track to the time where the Internet Explorer 6 was
    widely used, there were also many websites that worked in quirks mode to support
    Internet Explorer 6.
  prefs: []
  type: TYPE_NORMAL
- en: Now, most browsers are supporting or are moving towards supporting web standards
    (though slightly different, they are supporting in subtle manners), writing valid
    code is one of the best ways to ensure that your website works and appears the
    way it is intended to.
  prefs: []
  type: TYPE_NORMAL
- en: How validation can simplify testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While invalid code may not cause your code to be dysfunctional, valid code
    often simplifies testing. This is due to the focus on coding style and specifications;
    codes that are valid and have met specifications are typically more likely to
    be correct and much easier to debug. Consider the following code that is stylistically
    invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find the preceding code familiar? Or did you fail to recognize that the previous
    code snippet was taken from [Chapter 2](ch02.html "Chapter 2. Ad Hoc Testing and
    Debugging in JavaScript"),*Ad Hoc Testing and Debugging in JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code is an extreme example of poor code style, especially in terms
    of indentation. Imagine if you have to manually debug the second code snippet
    that you saw earlier! I am pretty sure that you will find it frustrating to check
    the code, because you will have little visual sense of what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, if you are working in a team, you will be required to write
    legible code; in short, writing valid code typically leads to code that is more
    legible, easier to follow, and hence, less erroneous.
  prefs: []
  type: TYPE_NORMAL
- en: Validation can help you debug your code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned in the previous section, browsers are in general forgiving towards
    invalid HTML and CSS. While this is true, there may be errors that are not caught,
    or are not rendered correctly or gracefully. This means that while the invalid
    HTML and CSS code may appear fine on a certain platform or browser, it may not
    be supported on others.
  prefs: []
  type: TYPE_NORMAL
- en: This means that using valid code (valid code typically means standard code set
    by international organizations such as W3C) will give you a much greater probability
    of having your web page rendered correctly on different browsers and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: With valid HTML and CSS, you can safely write your JavaScript code and expect
    it to work as intended, assuming that your JavaScript code is equally valid and
    error free.
  prefs: []
  type: TYPE_NORMAL
- en: Validation helps you to code using good practices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Valid code typically requires coding using good practices. As mentioned frequently
    in this chapter, good practices include the proper enclosing of tags, suitable
    indentation to enhance code readability, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more information about good practices when using JavaScript, feel
    free to check out the creator of JSLint, Douglas Crockford, at [http://crockford.com](http://crockford.com).
    Or you can read up John Resigs blog (the creator of JQuery) at [http://ejohn.org/](http://ejohn.org/).
    Both are great guys who know what great JavaScript is about.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To summarize the above sections, the DOM is provided by HTML, and both CSS and
    JavaScript are applied to the DOM. This means that if there is an invalid DOM,
    there is a chance that the JavaScript that is operating on the DOM (and sometimes
    the CSS) might result in errors.
  prefs: []
  type: TYPE_NORMAL
- en: With this summary in mind, well focus on how you can spot validation errors
    by using color coding editors.
  prefs: []
  type: TYPE_NORMAL
- en: Color-coding editors—how your editor can help you to spot validation errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are an experienced coder, you may skip this section; if not, you might
    want to understand the value of a good coding editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, a good editor can help you to prevent validation errors. Based
    on our understanding of what validation is, you should understand that your editor
    should do the following activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Highlight matching brackets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple syntax highlighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto indentation after keywords, brackets, and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto completion of syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto completion of words that you have already typed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed that I have left out a few points, or added a few points,
    as to what a good editor should do. But in general, the points listed previously
    are meant to help you prevent validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a start, you can consider using Microsofts SharePoint Designer 2007, a free,
    feature-rich, HTML, CSS ,and JavaScript editor, which is available at [http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=baa3ad86-bfc1-4bd4-9812-d9e710d44f42](http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=baa3ad86-bfc1-4bd4-9812-d9e710d44f42)
  prefs: []
  type: TYPE_NORMAL
- en: For example, highlighting matching brackets is to ensure that your code is properly
    enclosed with brackets, and auto indentation is to ensure that you are using consistent
    spacing for your code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although JavaScripts code blocks are often denoted by the use of curly brackets,
    it is important that we use indentation to visually display the structure of the
    code. Consider the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I am quite sure that you would find the second code snippet to be messy, as
    it has inconsistent indentation, and you may have problems figuring out which
    statement belongs to which conditional block.
  prefs: []
  type: TYPE_NORMAL
- en: Stylistically speaking, the second code sample is what we call "poor code style".
    You will be surprised that this might lead to validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you are wondering what `/^[a-zA-Z\s]*$/` and `/^\d+$/are`, they are
    actually regular expression objects. Regular expressions originated from Perl
    (a programing language) and, due to their usefulness, many programing languages
    now have ther own form of regular expressions. Most of them work in the same way.
    If you wish to find out more about regular expressions for JavaScript, feel free
    to visit [http://www.w3schools.com/jsref/jsref_obj_regexp.asp](http://www.w3schools.com/jsref/jsref_obj_regexp.asp)
    for a brief introduction to how regular expressions work.
  prefs: []
  type: TYPE_NORMAL
- en: Common errors in JavaScript that will be picked up by validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ill briefly mention some of the most common validation errors that are picked
    up by validators. Following is a short list of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Inconsistent spacing or indentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing semi colons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing closing brackets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a function or variable that is not declared at the point of being called
    or referenced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that some of the validation errors are not exactly "errors"—as
    in syntax errors—but rather stylistic ones. As mentioned in the previous sections,
    differences in coding style do not necessarily lead to functional errors but rather
    stylistic errors. But the good thing about good coding style is that it often
    leads to less errors.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it might be difficult for you to visualize what these common
    errors actually look like. But don't worry, you will get to see such validation
    errors in action when we introduce the JavaScript validation tools.
  prefs: []
  type: TYPE_NORMAL
- en: JSLint—an online validator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSLint is the first JavaScript validation code that we will focus on. You can
    access JSLint by visiting this URL: [http://www.jslint.com](http://www.jslint.com).
    The JSLint online validator is a tool created by Douglas Crockford.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Douglas Crockford works at Yahoo! as a JavaScript architect. He is also a member
    of the committee that designs future versions of JavaScript. His views on JavaScript
    style and coding practices are generally agreed upon . You can read more about
    him and his ideas at his website: [http://www.crockford.com](http://www.crockford.com).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, JSLint is an online JavaScript validator. It helps to validate
    your code. At the same time, JSLint is smart enough to detect some forms of code
    errors, such as infinite loops. The JSLint website is not a particularly large
    website, but nonetheless, two important links that you must read are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For basic instructions, visit [http://www.jslint.com/lint.html](http://www.jslint.com/lint.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a list of messages, visit [http://www.jslint.com/msgs.html](http://www.jslint.com/msgs.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will not attempt to describe to you what JSLint is about and how to use it;
    I personally believe in getting our hands dirty and giving it a test drive. Hence,
    for a start, we'll test the code that we wrote in [Chapter 2](ch02.html "Chapter 2. Ad
    Hoc Testing and Debugging in JavaScript"), *Ad Hoc Testing and Debugging in JavaScript*,
    and see what kind of validation errors (if any) occur.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—using JSLint to spot validation errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, well test the code that we wrote in [Chapter 2](ch02.html
    "Chapter 2. Ad Hoc Testing and Debugging in JavaScript"), *Ad Hoc Testing and
    Debugging in JavaScript*, and see what validation errors we get. Take note that
    the completed and validated code for this example can be found in `Chapter 3`
    of the `source code` folder, in the file named `perfect-code-for-JSLint.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your web browser and navigate to [http://www.jslint.com](http://www.jslint.com).
    You should see the home page with a huge text area. This is the area where you
    are going to copy and paste your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `source code` folder of `Chapter 2` and open up the file named: `getting-values-in-right-places-complete.html`.
    Then, copy and paste the source code into the text area mentioned in step 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the button with the name **JSLint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your page should refresh almost immediately, and you will receive some form
    of feedback. You may have noticed that you received many (yes, a lot of) validation
    errors. And, most probably, some of them do not make sense to you. However, you
    should be able to identify that some of the validation errors were introduced
    in the section on common JavaScript validation errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, scroll further down and you should see the following phrase in the feedback
    area:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tells you that JSLint has only scanned a part of the code and stopped scanning
    the code because there were too many errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What can we do about this? What if there are too many validation errors and
    you cannot spot all of them in one go?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do not worry, as JSLint is robust and has option settings, which are found at
    [http://www.jslint.com/#JSLINT_OPTIONS](http://www.jslint.com/#JSLINT_OPTIONS)
    (this is actually found at the bottom of the home page of JSLint). One of the
    options that requires your input is the **maximum number of errors**. For our
    purposes, you may want to enter an insanely large number, such as 1,000,000.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After entering an insanely large number for the input box for **maximum number
    of errors**, click on the button **The good parts**. You will see a few checkboxes
    have been selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After step 4, you have now officially selected the options known as The Good
    Parts by the author of this tool. This is a setting that automatically sets what
    the author feels are the most important validation checks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These options include: Strict white space, allow one var statement per function,
    and so on.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now click on the **JSLint** button. Your browser will show the new validated
    result. Now you may take a look at the types of validation errors that have been
    detected by JSLint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have just used JSLint to spot for validation errors. This is a simple process
    for JSLint: copy and paste your code into the text area and click on **JSLint**.
    Do not be surprised that there are so many validation errors; we are just starting
    out and we will learn how to fix and avoid such validation errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that the JavaScript that is embedded in the HTML form results
    in an error that says **missing use strict statement**. This error stems from
    the fact that JSLint believes in the use of the **use strict** statement, which
    allows the code to run under strict conditions. You will learn how to fix and
    avoid such problems in later parts of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You will continue to see many errors. In my opinion, this is evidence that valid
    code is not easy to achieve; but this is what we will achieve in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, there are various validation options, and at this stage, it
    is good enough if we pass the set requirements for **The Good Parts**. Therefore,
    well focus on how to fix these validation errors in the next section. But before
    that, I'll quickly discuss the valid code constructs that produce validation warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Valid code constructs that produce validation warnings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that although our code construct is valid, it has produced
    validation warnings. You may be wondering if you should fix these or not. Here's
    some basic discussion to help you to decide.
  prefs: []
  type: TYPE_NORMAL
- en: Should you fix valid code constructs that produce validation warnings?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This depends on your objective. As I mentioned in [Chapter 1](ch01.html "Chapter 1. What
    is JavaScript Testing?"), *What is Javascript Testing?*, a code should at least
    be correct and work the way that we intend it to. Therefore, if your objective
    is to just create functionally-correct code, then you might not want to spend
    the time and effort to correct those validation warnings.
  prefs: []
  type: TYPE_NORMAL
- en: However, because you are reading this book, it is very likely that you want
    to learn how to test JavaScript, and validation is an important part of testing
    JavaScript as you will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you don't fix them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main issue with invalidated code is that it will be much more difficult
    to maintain the code, in terms of readability and scalability. This problem becomes
    enhanced when you are working in teams and others have to read or maintain your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Valid code promotes good coding practices, which will help you to avoid problems
    down the road.
  prefs: []
  type: TYPE_NORMAL
- en: How to fix validation errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will continue with the errors mentioned in the previous section,
    and together we'll attempt to fix them. Wherever possible, I'll provide some form
    of explanation as to why a particular piece of code is rendered as invalid. At
    the same time, the whole process of writing valid and functionally-code can be
    cumbersome. Therefore, I'll start off with validation errors that are much easier
    to fix, before I move on to tougher ones.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we go along fixing the validation errors that we saw in the previous section,
    you may realize that fixing validation errors may require some form of compromise
    as to how you write your code. For example, you will understand that using `alert()`
    sparingly in your code is not considered a good coding style, at least according
    to JSLint. In this case, you will have to consolidate all of your `alert()` statements
    and group them into a function, while still maintaining the functionality of your
    code. More importantly, you will also realize that (perhaps) the best way to write
    valid code is to start writing valid code right from the first line of the code;
    you will see that correcting invalid code is an extremely tedious process, and
    there are times when you can only minimize your validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, you will get the chance to practice important JavaScript functions
    and, at the same time, learn how to code in a better style. Thus, this is probably
    the most important section of this chapter and I urge you to get your hands dirty
    with me. Before I get started on fixing the code, I'll first summarize the types
    of errors that are spotted by JSLint.
  prefs: []
  type: TYPE_NORMAL
- en: Missing "use `strict`" statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unexpected use of `++`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing space after `), value, ==, if, else, +`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function names (such as debuggingMessages) are not defined or a function was
    used before it was defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too many `var` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`===` used instead of `==`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alert` is not defined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<\/` used instead of`</`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML event handlers used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without further ado, well get started with the first validation error: `use
    strict`.'
  prefs: []
  type: TYPE_NORMAL
- en: Error missing "use strict" statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The "`use strict`" statement is a relatively new feature in JavaScript that
    allows our JavaScript to run in a strict environment. In general, it catches little-known
    errors, and "forces" you to write stricter and valid code. John Resig, an expert
    in JavaScript, has written a nice summary about this topic, and you can read about
    it by following this link: [http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/).'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—fixing "use strict" errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This error is extremely easy to fix. But be careful; enabling `use strict`
    may prevent your code from working, if your code is not valid. Here''s how we
    can fix this validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your text editor, copy and paste the same code that we have been using,
    and append the following code snippet on the first line of your JavaScript code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your code and test it out on JSLint. You will see that the error is now
    gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may notice that there is another missing `use strict` error that is related
    to your HTML form; do not worry, we will fix that in a later sub-section of this
    chapter. Now let us move on to the next error.
  prefs: []
  type: TYPE_NORMAL
- en: Error—unexpected use of ++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is nothing programmatically wrong with this line of code. What we intend
    to achieve by using `++` is to increment `globalCounter` whenever the function
    `addResponseElement()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, JSLInt believes that there is a problem with using `++`. Take the
    following code snippets as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous statements would look confusing to most programmers and hence it
    is considered bad style. More importantly, both of these statements are programmatically
    different and produce different results. For these reasons, we need to avoid statements
    like `++, --`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—fixing the error of "Unexpected use of ++"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This error is relatively easy to fix. All we need to do is avoid `++`. So navigate
    to the `addResponseElement()` function, and look for `globalCounter++`. Then change
    `globalCounter++` to `globalCounter = globalCounter + 1`. So, now your function
    has changed from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Compare the highlighted lines, and you will see the change in the code. Now
    let us move on to the next error.
  prefs: []
  type: TYPE_NORMAL
- en: Error—functions not defined
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This error is caused by the way that JavaScript engines and web pages are being
    rendered by web browsers. In [Chapter 1](ch01.html "Chapter 1. What is JavaScript
    Testing?"), *What is Javascript Testing*, we mentioned briefly that web page (and
    JavaScript) are being parsed from top to bottom on the client side. This means
    that anything that appears at the top will be read first, followed by that at
    the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—fixing the error of "Functions not defined"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because this error is caused by the incorrect flow of the JavaScript functions,
    we will need to change the sequence of the functions. What we have done in [Chapter
    2](ch02.html "Chapter 2. Ad Hoc Testing and Debugging in JavaScript"), *Ad Hoc
    Testing and Degugging in Javascript*, is that we wrote the functions that we will
    be using first. This may be incorrect, as the functions may require data or functions
    that are only defined in later parts of the JavaScript code. Here''s a very simplified
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Based on the previous code snippet, you will realize that `addTwoNumbers()`
    requires data returned from `numberOne()` and `numberTwo()`. The issue here is
    that the JavaScript interpreter will read `addTwoNumbers()` first before reading
    `numberOne()` and `numberTwo()`. However, both `numberOne()` and `numberTwo()`
    are being called by `addTwoNumbers()`, resulting in an incorrect flow of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This means that in order for our code to work correctly, we will need to rearrange
    the order of the functions. Continuing with the previous example, this is what
    we should do:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous code snippet, we have rearranged the sequence of the functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we are going to rearrange the function's sequence. For our purposes, all
    that we need to do is to arrange our functions such that the first function that
    originally appeared in our code will now be the last, and the last function will
    be the first. Similarly, the second function that originally appeared in the JavaScript
    code will now be the second-to-last function. In other words, we will reverse
    the order of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have reversed the order of the functions, save the file and test the
    code on JSLint. You should notice that the validation errors relating to functions
    not being defined are now gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let us move on to the next validation error.
  prefs: []
  type: TYPE_NORMAL
- en: Too many var statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to JSLint, we have used too many `var` statements. What does this
    mean? This means that we have used more than one `var` statement in each function;
    in our case we have obviously used more than one `var` statement in each and every
    function.
  prefs: []
  type: TYPE_NORMAL
- en: How did this happen? If you scroll down and check the settings of JSLint, you
    will see a checkbox selected that says **Allow one var statement per function**.
    This means that the maximum number of `var` we can use is one.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this considered to be good style? Although many coders may think that
    this is cumbersome, the author of JSLint would most probably believe that a good
    function should do only one thing. This would typically mean operating on only
    one variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's certainly room for discussion, but as we are all here to learn, let
    us get our hands dirty by fixing this validation error.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—fixing the error of using too many var statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to fix this error, we will need to do some form of code refactoring.
    Although code refactoring typically means consolidating your code for it to become
    more concise (that is, shorter code), you may realize that refactoring your code
    to fit validation standards is a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do in this section is that we will change (almost) all single `var`
    statements that save a value into a function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code that is mainly responsible for this particular validation error is
    found `checkForm` function. The statements that we will need to refactor are as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''ll start to refactor our code. For each of the variables defined, we
    need to define a function with the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I''ll start off with an example. For instance, for `totalInputElements` this
    is what I will do:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Based on the previous code, do something similar to what you are going to see
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let us move on to the next error.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting <\/ instead of <\
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most of us, this error is probably one of the most intriguing. We have this
    validation error because the HTML parser is slightly different to the JavaScript
    interpreter. In general, the extra backslash is being ignored by the JavaScript
    compiler, but not by the HTML parser.
  prefs: []
  type: TYPE_NORMAL
- en: Such validation errors may appear unnecessary, but Doug Crockford knows that
    this has some form of impact on our web page. Therefore, let us move on to how
    to fix this error.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—fixing the expectation of '<\/' instead of '</'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this error is one of the most intriguing, it is one of the easiest
    to fix. All that we need to do is to find all of the JavaScript statements that
    contain`</` and change them to`<\/`. The function that is mainly responsible for
    this error is `buildFinalResponse()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down to the function `buildFinalResponse()`, and change all statements
    that have`</` to`<\/`. After you are done, you should have the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that all`</` have been changed to`<\/`. You may also want to search through
    the code and see if any such errors are remaining.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with this error fixed, we can move on to the next validation error.
  prefs: []
  type: TYPE_NORMAL
- en: Expected '===' but found '=='
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript and in most programing languages, `==` and `===` are significantly
    different. In general, `===` is stricter than `==`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key difference between `===` and `==` in JavaScript is that `===` is a strict
    equal operator and it will return a Boolean true if, and only if, both the operands
    are equal and of the same type. On the other hand, the `==` operator returns a
    Boolean true if both the operands are equal, even if they are of different types.
  prefs: []
  type: TYPE_NORMAL
- en: According to JSList, `===` should be used when comparing a variable to a truth
    value, because it is stricter than `==`. In terms of code strictness, JSLint is
    certainly correct in ensuring code quality. Therefore, let us now correct this
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—changing == to ===
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the reasons mentioned earlier, we will now change all `==` to `===`,
    for statements that require comparison. Although this error is relatively easy
    to fix, we need to understand the importance of this error. `===` is much stricter
    than `==`, and therefore it is more secure and valid to use `===` instead of `==`.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to your source code, search for all comparison statements that contain
    `==` and change them to `===. ==` is found largely at `if`, and `else-if` statements,
    because it is used for comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done, you may want to test out your updated code at JSLint and
    see if you have cleared all such errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us move on to yet another cumbersome error: "Alert is not defined".'
  prefs: []
  type: TYPE_NORMAL
- en: Alert is not defined
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, using `alert` by itself leads to 'pollution' of the global namespace.
    Although it is convenient, this is bad code practice according to JSLInt. Therefore,
    the strategy that we are going to use to fix this validation error is to use some
    form of code refactoring (again).
  prefs: []
  type: TYPE_NORMAL
- en: In our code, you should notice that we are largely using `alert()` to provide
    feedback in terms of the function names, error messages, and so on. We will need
    to use our `alert()` such that it can take in various forms of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—fixing "Alert is not defined"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we will do is that we will consolidate all `alert()` statements into one
    function. We can pass a parameter to that function so that we can change the messages
    in the alert box depending on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to your code, and define the following function at the top of your`<script>`
    tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`messageObject` is the parameter that we will use to hold our message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, change all `alert()` statements to `alertMessage()` such that the message
    for `alert()` is the same as `alertMessage()`. Once you are done, save the file
    and run the code in JSLint again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you tried running your code in JSLint, you should see that the "damage" done
    by `alert()` has been minimized to only one time, instead of over ten to twenty
    times.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, what we can do is minimize the impact of the `alert()` because,
    for our purposes, we do not have a ready alternative to show messages in an alert
    box.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time for the next error—avoiding HTML event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding HTML event handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good coding practices often state the need to separate programing logic and
    design. In our case, we have embedded event handlers (JavaScript events) within
    the HTML code. According to JSLint, such coding could be improved by avoiding
    HTML event handlers altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the ideal case is to separate programing logic from design, there is
    nothing functionally wrong in using HTML intrinsic event handlers. You may want
    to consider whether it is worth it (in terms of time, maintainability, and scalability)
    to adhere to (almost) perfect coding practices. In the later part of this sub-section,
    you may find that it can be cumbersome (or even irritating) to try to validate
    (and functionally correct) code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve this validation error, we will need to use event listeners.
    However, due to the problems posed by the compatibility of event listeners, we
    will be using JavaScript libraries to help us to deal with inconsistencies among
    the support for event listeners. We will be using JQuery in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'JQuery is a JavaScript library created by John Resig. You can download JQuery
    by visiting this link: [http://jquery.com](http://jquery.com). As described on
    this website, "JQuery is a fast and concise JavaScript Library that simplifies
    HTML document traversing, event handling, and animating, and Ajax interactions
    for rapid web development." In my personal experience, JQuery certainly makes
    life easier by fixing many sticky issues such as DOM incompatibilities, providing
    built-in methods to create animation, and many other things. I certainly urge
    you to follow a starter tutorial by going to: [http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery](http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery)'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—avoiding HTML event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to avoid HTML event handlers by coding in
    a different style. In this case, we will not only remove the JavaScript events
    embedded in each of the HTML input elements, we will also need to write new functions
    for our JavaScript application in order for it to work in the same manner. In
    addition to that, we will be using a JavaScript library that will help us to remove
    all of the difficult stuff relating to event handling and using event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the same document and scroll to the`<body>` tags. Remove all of the
    HTML event handlers that are found in the form. This is what your form''s source
    code should look like after you have removed all of the HTML event handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now scroll to the`</style>` tag. After the`</style>` tag, enter the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What you are doing in the preceding line is enabling JQuery in your code. This
    will allow you to make use of the JQuery library when fixing your code. Now it's
    time to write some JQuery code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to maintain the functionality of our code, we will need to use the
    `.blur()` method provided by JQuery. Scrolling to the end of your JavaScript code,
    append the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a short explanation of how JQuery works: `jQuery(document).ready(function
    ()`is used to start our code; it allows us to use the methods provided in JQuery.
    In order to select an element, we use `jQuery(''#nameOfPerson'')`. As mentioned
    earlier, we need to maintain the functionality of the code, so we will use the
    `.blur()` method provided by JQuery. In order to do that, we append `.blur()`
    to `jQuery(''#nameOfPerson'')`. We are required to call `submitValues()`, and
    we will need to enclose `submitValues()` within `.blur()`. Because `submitValues()`
    is a function, we will enclose it as such:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point of time, we should have completed the necessary corrections in
    order to achieve valid and functional code. I'll briefly summarize the corrections
    in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary of the corrections we have done
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will refresh our memory by quickly going through what we have done to
    fix the validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: First, we pasted the original code into JSLint and noticed that we had a large
    number of validation errors. Fortunately, the validation errors could be grouped
    such that similar errors could be fixed by correcting a single code error.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we started off with the correction process. In general, we tried to fix
    the validation errors, starting from those which seemed to be the easiest. The
    first validation error that we fixed was the missing `use strict` statement error.
    What we did was enter `use strict` on the very first line of our JavaScript code,
    and that error was fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second validation error that we fixed was the "functions not defined error".
    This was caused by an incorrect flow of the JavaScript functions. Therefore, we
    switched the flow of functions from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we simply reversed the sequence of the functions to fix the error.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to an error that is quite time-consuming—using too many `var`
    statements within a function. In general, our strategy was to refactor almost
    all of the `var` statements into standalone functions. These standalone functions'
    main purpose was to return a value, and that's all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we moved into yet another time-consuming validation error, and this was
    "expected`<\/` instead of`</`. In general, this error is referring to the closing
    HTML tags. So what we did was to change `/>` to `\/>` for all closing HTML tags.
    For example, we changed the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the highlighted lines are where we have changed from `/>` to `\/>`.
  prefs: []
  type: TYPE_NORMAL
- en: After fixing the previous error, we moved on to an error that is conceptually
    more difficult to understand, but easy to solve. That is, "expected `===` instead
    of saw `==`". According to JSLint, using `===` is stricter and more secure as
    compared to using `==`. Therefore, we needed to change all `==` to `===`.
  prefs: []
  type: TYPE_NORMAL
- en: The next error, "Alert is not defined", is conceptually similar to the "Too
    many `var` statement" error. What we need to do is to refactor all `alert()` statements
    to call the `alertMessage()` function that accepts a parameter `messageObject`.
    This allows us to use only one `alert()` for almost the whole JavaScript program.
    Whenever we need to use an alert box, all we need to do is to pass an argument
    into the `alertMessage()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we moved on to fix one of the toughest validation errors: "Avoiding
    HTML event handlers". Due to the complexities involved with event listeners, we
    engaged the help of JQuery, a popular JavaScript library, and wrote some JQuery
    code. Firstly, we removed all of the HTML event handlers from our HTML form. Our
    HTML form changed from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to support the new HTML form, we linked in the JQuery library, and
    added some code to listen for the HTML form events, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The completed code can be found in the `source code` folder for `Chapter 3`,
    with a file name of `perfect-code-for-JSLint.html`. You can compare this with
    your edited code to see if you have understood what we were trying to do. Now,
    you may want to copy and paste the code into JSLint and see how it goes. You will
    only see errors pertaining to the use of Jquery, one validation error that complains
    about the use of `alert()`, and another error about using too many `var` statements.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have corrected the bulk of the validation errors, from an insanely large
    number of validation errors to less than ten validation errors, out of which only
    two or three of the validation errors are related to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed the `jQuery not defined` error. Although JSLint has captured
    the JQuery library that was externally linked, it does not explicitly read the
    code, thus resulting in the `jQuery not defined` error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have fixed the validation errors, let us now move on to another
    free validation tool, the JavaScript Lint.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Lint—a tool you can download
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript Lint can be downloaded at [http://www.javascriptlint.com](http://www.javascriptlint.com),
    and it works in a manner similar to JSLint. The key difference is that JavaScript
    Lint is a downloadable tool, whereas JSLint works as a web-based tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like JSLint, JavaScript Lint is capable of spotting the following common errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Missing semicolons at the end of a line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curly braces without an `if, for`, and `while`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements that do not do anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case statements in a switch that turn decimal points into a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about its functionality by visiting its home page at [http://www.javascriptlint.com.](http://www.javascriptlint.com.)
  prefs: []
  type: TYPE_NORMAL
- en: To learn about how to use JavaScript Lint, you may follow the tutorials found
    at the website.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Windows, you may need to read the set-up instructions found
    at [http://www.javascriptlint.com/docs/running_from_windows_explorer.htm](http://www.javascriptlint.com/docs/running_from_windows_explorer.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using Linux based operating systems, you can check out the instructions
    found at [http://www.javascriptlint.com/docs/running_from_the_command_line.htm](http://www.javascriptlint.com/docs/running_from_the_command_line.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if you wish to integrate JavaScript Lint into your IDE such as Visual
    Studio, you can read more about how to do this by visiting [http://www.javascriptlint.com/docs/running_from_your_ide.htm](http://www.javascriptlint.com/docs/running_from_your_ide.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not be discussing "how to fix validation errors spotted by JavaScript
    Lint" because the principles are similar to JSLint. However, we challenge you
    to fix the remaining errors (apart from those caused by JQuery)
  prefs: []
  type: TYPE_NORMAL
- en: Challenge yourself—fix the remaining errors spotted by JSLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ok, this is the first challenge that I will I present to you. Fix the remaining
    errors spotted by JSLint, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alert is not defined":** This is found in the `alertMessage()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**too many var statements":** This error is found in the `submitValues()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some ideas for you to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In our JavaScript application, is there any way that we can avoid the `alert()?`
    How can we display messages that can capture the attention of our audience but
    at the same time be valid?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the error found at the `submitValues()` function, how can we refactor the
    code such that there is only one `var` statement in the function? Can we refactor
    the `var` statement into a function and have it return a Boolean value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK, now you might want to give it a go, but be careful, because the solutions
    that you propose or intend to use may cause other validation errors. So you might
    want to think about your solutions before implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've finally reached the end of this chapter. I'll first start off by summarizing
    some of the strategies and tips we have used to write valid code, and follow this
    with a summary of the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the strategies that we have used to write valid code (according to
    JSLint) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Properly space your code, especially after mathematical signs, `if, else, (
    )`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use only one `var` statement per function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the flow of your program; code in such a way that the required data
    or functions come at the top of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `alert()` function sparingly. Instead, consolidate your `alert()` functions
    into one function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `===` instead of `==`; this makes sure that your comparison statements are
    more accurate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid HTML event handlers by using listeners. Alternatively, you may engage
    the help of JavaScript libraries such as JQuery in order to provide event listeners
    to your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between testing and validating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How validation helps us to write good code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What issues may occur if we do not validate our code—if we do not validate our
    code, it might not be scalable, less readable, and result in unexpected errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can use JSLint and JavaScript Lint to validate our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned how we can test JavaScript by validation tools, you
    might want to think about the strategy that we can adopt when we intend to test
    our code. As shown in the example in this chapter, writing valid code (or correcting
    invalid code) is an extremely tedious process. More importantly, there are some
    validation warnings or errors that do not affect our program in its entirety.
    In such a situation, do you think that it is worth the effort to validate our
    code? Or do you think we should be a perfectionist and write perfect code? This
    will very much depend on our testing plan, which will dictate the scope of testing,
    the things to test, and many other things. These topics will be covered in next
    chapter, [Chapter 4](ch04.html "Chapter 4. Planning to Test"), *Planning to Test*.
    So I'll end off this chapter, and see you in the next chapter.
  prefs: []
  type: TYPE_NORMAL
