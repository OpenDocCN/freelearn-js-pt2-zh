- en: Chapter 9. Scaling Down
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 缩减扩展
- en: We tend to think of scaling as a unidirectional problem—we can only scale up
    from where we are currently. Unfortunately, that doesn't quite work. We can only
    scale in one direction for so long before the foundation crumbles under our feet.
    The key is in identifying the scaling limitations, and designing around them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于认为扩展是一个单向问题——我们只能从当前的位置向上扩展。不幸的是，这并不完全有效。我们只能在一条线上扩展这么久，然后基础就会在我们脚下崩溃。关键在于识别扩展限制，并围绕它们进行设计。
- en: In this chapter, we'll look at the fundamental scaling constraints faced by
    JavaScript architects in nearly every browser environment. We'll also look at
    the customer as a scaling influencer, and how new features conflict with existing
    features. Scaling down from bloated design is an essential activity as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几乎所有浏览器环境中JavaScript架构师面临的根本性扩展限制。我们还将探讨客户作为扩展影响因素，以及新特性与现有特性之间的冲突。从过度设计中缩减也是一项基本活动。
- en: The composition of our application as a whole determines how easy or how difficult
    it'll be to scale down by turning features off. It all has to do with coupling,
    and if we look closely, we'll often discover that we need to refactor our components
    so they can be easily removed later on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个应用程序的组成决定了通过关闭特性来缩减扩展的难易程度。这一切都取决于耦合，如果我们仔细观察，我们经常会发现我们需要重构我们的组件，以便它们可以稍后轻松移除。
- en: Scaling constraints
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展限制
- en: Our applications are constrained by the environments in which they run. This
    means the hardware on which the client is running, and the browser itself. What's
    interesting about web applications is that there's also the transmission of the
    code itself to consider. For example, if we're writing backend code, we can throw
    more code at any problem we face, and that's not a problem because that code doesn't
    move around—it runs in one place.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序受到它们运行的环境的限制。这意味着客户机上运行的硬件和浏览器本身。有趣的是，网络应用程序还需要考虑代码本身的传输。例如，如果我们正在编写后端代码，我们可以向任何问题投入更多的代码，这不是问题，因为代码不会移动——它在一个地方运行。
- en: With JavaScript, size matters. There's simply no way around this fact. As a
    corollary, network bandwidth matters—both for the delivery of our JavaScript artifacts,
    and our application data from the API.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript来说，大小很重要。这一点是无法回避的。作为推论，网络带宽也很重要——既包括我们的JavaScript工件的交付，也包括从API获取我们的应用程序数据。
- en: In this section, we'll address the hard scaling constraints imposed on us in
    the browser computing environment. As our application grows, we feel the pressure
    of these constraints more and more. Each of these needs to be considered when
    planning new features for our application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解决浏览器计算环境中对我们施加的硬性扩展限制。随着我们的应用程序的增长，我们感受到这些限制的压力越来越多。在为我们的应用程序规划新特性时，需要考虑这些方面。
- en: JavaScript artifact size
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript工件大小
- en: The cumulative size of our JavaScript artifacts can only grow so much. Eventually,
    the load time of our application will suffer to the point that nobody will want
    to use our application. Huge JavaScript artifacts are typically indicative of
    bloat in other areas. For example, if we're delivering huge files to the browser,
    we probably have too much of something. Maybe we don't need the features nobody
    uses, or maybe there's repetitious code spread throughout our components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript工件的累计大小只能增长到一定程度。最终，我们的应用程序的加载时间将会受到严重影响，以至于没有人愿意使用我们的应用程序。巨大的JavaScript工件通常意味着其他区域的过度膨胀。例如，如果我们向浏览器交付巨大的文件，我们可能有过多的东西。也许我们不需要那些没有人使用的特性，或者也许我们的组件中有重复的代码。
- en: Whatever the cause, the effects aren't good. Smaller is always better. How do
    we know when the file size of our JavaScript artifacts are small enough? That
    depends—there's no universal *ideal* size. Where is our application deployed,
    on the public internet? Behind a VPN for corporate users? There may be different
    acceptance criteria for the users of these types of systems. Broadly speaking,
    the public internet users are going to be less forgiving of poor load time performance
    and feature bloat. The corporate users on the other hand, generally appreciate
    more features and are more tolerant of lackluster load times.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无论原因是什么，效果都不好。越小越好。我们如何知道我们的 JavaScript 文件大小是否足够小呢？这取决于——没有普遍的“理想”大小。我们的应用程序部署在哪里，是在公共互联网上？还是企业用户背后的
    VPN？这些系统的用户可能有不同的接受标准。总的来说，公共互联网用户对我们加载时间的性能和功能膨胀的容忍度较低。另一方面，企业用户通常更欣赏更多功能，并对加载时间的不佳更加宽容。
- en: The biggest contributor to growing JavaScript artifact sizes are the new features
    we constantly add to our product. These result in new components which add weight.
    Any given feature is going to have a minimum set of files, each for the components
    that follow the pattern of our existing features. If our patterns are half decent,
    then we should be able to keep the size of our components reasonable. However,
    repetitive code always finds its way into the application when deadlines are involved.
    Even if our code is as lean as it could possibly be, we still have to implement
    features when they're asked for.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不断添加到我们产品中的新功能是 JavaScript 文件大小增长的最大贡献者。这些导致了新组件的增加，从而增加了重量。任何给定功能都至少有最小文件集，每个文件都是遵循我们现有功能模式的组件。如果我们的一半模式还可以，那么我们应该能够保持我们组件的大小合理。然而，当截止日期涉及时，重复的代码总是找到进入应用程序的方式。即使我们的代码尽可能精简，当被要求实现功能时，我们仍然必须实现它们。
- en: Compiled artifacts help us with the size problem. We can concatenate and uglify
    files, saving on the number of network requests, and the overall bandwidth. But,
    any given feature will keep these compiled artifacts growing. We can keep growing
    for some time before encountering any problems. As stated, the problems are relative,
    depending on the environment, and the users of our software. In all cases, the
    size of our JavaScript artifacts cannot grow infinitely.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过的文件可以帮助我们解决文件大小的问题。我们可以合并和压缩文件，减少网络请求次数，节省总体带宽。但是，任何特定功能都会使这些编译过的文件持续增长。我们可以在遇到任何问题之前持续增长一段时间。如前所述，问题都是相对的，取决于环境和我们软件的用户。在所有情况下，我们的
    JavaScript 文件的大小不能无限增长。
- en: '![JavaScript artifact size](img/4639_09_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![JavaScript 文件大小](img/4639_09_01.jpg)'
- en: The size of JavaScript artifacts are the aggregate result of all modules that
    make up the component
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 文件的大小是组成组件的所有模块的聚合结果。
- en: Network bandwidth
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络带宽
- en: The size of our JavaScript artifacts contributes to the overall network bandwidth
    consumption of our application. Especially as there's more user uptake—users are
    the multipliers for all our architectural woes. Coupled with our JavaScript code,
    is our application data. These API calls also contribute to the overall network
    bandwidth consumption, and user-perceived latency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 JavaScript 文件的大小贡献了我们的应用程序整体网络带宽消耗。尤其是随着更多用户的采用——用户是我们所有架构问题的乘数。与我们的 JavaScript
    代码相结合的是我们的应用程序数据。这些 API 调用也贡献了整体网络带宽消耗和用户感知的延迟。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As our application scales geographical boundaries, we'll notice a diverse range
    of connectivity issues. In many parts of the world, high-speed networks simply
    aren't an option. If reaching these markets is important to us, and it should
    be, then our architecture needs to cope with slow internet connections. Using
    CDNs to deliver the libraries our application use can help here because they take
    into consideration the geographical location of the requests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序跨越地理边界，我们会注意到各种连接问题。在世界上许多地方，高速网络根本不是一个选项。如果我们想要进入这些市场，而且我们应该这么做，那么我们的架构需要能够应对缓慢的互联网连接。使用
    CDN 传递我们的应用程序所使用的库可以帮助解决这个问题，因为它们考虑了请求的地理位置。
- en: The challenge is that any new feature is going to add new network bandwidth
    consumption. There's the size of the code, and the new API calls introduced by
    the new component. Mind you, these effects aren't felt immediately. For example,
    the new component doesn't make API calls on page load, only when the user navigates
    to a specific URI.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于，任何新功能都会增加新的网络带宽消耗。这包括代码的大小，以及新组件引入的新API调用。请注意，这些效果并不会立即显现。例如，新组件在页面加载时不会进行API调用，只有在用户导航到特定的URI时才会进行API调用。
- en: Nonetheless, new API endpoints mean more aggregate network bandwidth usage over
    time. Further, it's not just a matter of making one API call when a user navigates
    to a feature page. It sometimes takes a tangle of three or more API calls, in
    order to construct the data to be presented. We need to keep this in mind when
    we're thinking that a new API call isn't a big deal, as it usually ends up being
    more than one call, and that means more bandwidth consumption.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，新的API端点意味着随着时间的推移网络带宽使用会增加。此外，当用户导航到功能页面时，并不是只做一个API调用那么简单。有时需要三个或更多的API调用，以便构建要呈现的数据。当我们认为一个新的API调用不是什么大问题时，我们需要记住，通常这会变成多个调用，这意味着更多的带宽消耗。
- en: Is there a fundamental network bandwidth limit? Not theoretically, but it's
    like the size of our JavaScript artifacts—we can grow them to 10MB each if we
    please. All we can say with confidence is that it's not going to improve the user
    experience, and the side effects could cause a much worse experience. The same
    goes with network bandwidth consumption.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 是否存在根本的网络带宽限制？从理论上讲，并不存在，就像我们的JavaScript资源大小一样——如果我们愿意，可以把它们扩展到每个10MB。我们可以肯定的是，这不会改善用户体验，而且副作用可能会导致更糟糕的体验。网络带宽消耗也是如此。
- en: '![Network bandwidth](img/4639_09_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![网络带宽](img/4639_09_02.jpg)'
- en: Components consume network bandwidth by requesting JavaScript modules and API
    data
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 组件通过请求JavaScript模块和API数据来消耗网络带宽
- en: '''Following is an example that shows how the aggregate latency of our application
    suffers as more requests are made:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子，展示了我们的应用程序随着更多请求的发出而遭受聚合延迟的痛苦：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Memory consumption
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存消耗
- en: With every feature we implement, the memory consumed by the browser grows. This
    may seem like an obvious statement, but it's important. Memory issues not only
    hurt application performance, they can crash the entire browser tab. Therefore,
    we need to pay close attention to the memory allocation characteristics of our
    code. The profiler built into the browser can record the allocations of objects
    in memory over time. This is a useful tool for diagnosing issues, or for general
    observations about how our code behaves.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们实现每一个功能，浏览器消耗的内存也在增长。这听起来像是一个显而易见的陈述，但它很重要。内存问题不仅伤害应用程序的性能，它们可能会导致整个浏览器标签页崩溃。因此，我们需要密切关注我们代码的内存分配特性。浏览器内置的性能分析工具可以记录对象在内存中的分配情况随时间变化。这对于诊断问题，或者观察我们的代码行为非常有用。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Frequently creating and destroying objects can cause performance lags. This
    is because the objects that are no longer referenced, are garbage collected. When
    the garbage collector is running, none of our JavaScript code runs. So we have
    a conflicting requirement—we want our code to run fast, and we don't want to waste
    memory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁创建和销毁对象会导致性能滞后。这是因为不再引用的对象会被垃圾回收。当垃圾回收器运行时，我们的JavaScript代码不会运行。因此，我们有一个冲突的需求——我们希望代码运行得快，同时不想浪费内存。
- en: The idea is to not cause the garbage collector to run unnecessarily. For example,
    there are times where we can hoist the variable up to a higher scope. This means
    that the reference isn't created and destroyed several times throughout the lifetime
    of the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是不必要地触发垃圾回收器的运行。例如，有时我们可以把变量提升到更高的作用域。这意味着在整个应用程序的生命周期中，引用并没有被多次创建和销毁。
- en: Another scenario is with frequent allocations in a short timeframe, such as
    within a loop. While JavaScript engines are smart about dealing with these types
    of scenarios, they're still worth keeping an eye out for. The best resources are
    the source code of low-level libraries that take into account the garbage collector,
    and avoid unnecessary allocations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种场景是在短时间内频繁分配，例如在循环中。虽然JavaScript引擎在处理这类场景时很聪明，但仍然值得我们关注。最佳资源是考虑垃圾回收器的低级库的源代码，避免不必要的分配。
- en: The responses returned from the API also consume memory, and depending on the
    data returned, a substantial amount of memory. Something we'll want to do is ensure
    that there's a cap on how much data a given API endpoint can respond with. Many
    backend APIs do this automatically, not returning more than a 1000 entities at
    a time. If we need to make our way through the collection, then we need to provide
    an offset argument. However, we may want to further constrain the size of the
    API response, because the size of individual entities in the collection could
    occupy a lot of memory as a model in the browser.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: API返回的响应也消耗内存，具体取决于返回的数据，可能消耗大量的内存。我们希望确保给定API端点可以响应的数据量有限制。许多后端API会自动这样做，一次不超过1000个实体。如果我们需要遍历集合，那么我们需要提供一个偏移量参数。然而，我们可能还需要进一步限制API响应的大小，因为集合中单个实体的大小在浏览器中作为模型占用大量内存。
- en: While these collections are typically garbage collected as the user moves around
    from page to page, each new feature we implement presents the opportunity for
    subtle memory leak bugs. It's the subtle bugs that are difficult to deal with
    because the leaks are slow and manifest themselves differently across environments.
    When the memory leak is large and obvious, it's easier to reproduce, and thus,
    easier to locate and fix.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些集合通常会在用户从一个页面移动到另一个页面时进行垃圾回收，但我们实施的每个新功能都可能带来微妙的内存泄漏错误。这些微妙的错误难以处理，因为泄漏发生缓慢，并且在不同的环境中表现不同。当内存泄漏很大且明显时，它更容易复现，因此也更容易定位和修复。
- en: 'Next is an example that shows how quickly memory consumption can get out of
    hand:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个例子，展示了内存消耗如何迅速失控：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: CPU consumption
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU消耗
- en: One of the big factors in how responsive our user interface feels, is the CPU
    on the client. If it's available to run our code whenever there's code to be run,
    in response to a click for instance, then the UI will feel responsive. If the
    CPU is busy handling other things, our code will have to sit there and wait. And
    so will the user. Obviously there's a lot of software asking for the CPU's attention
    in a given operating environment—much of which is completely out of our control.
    We can't scale down the use of other applications outside of the browser, but
    we can scale down the use of the CPU from within our JavaScript application. But
    first, we have to understand where these JavaScript CPU cycles come from.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 影响我们用户界面响应性的一个重要因素是客户端的CPU。如果它能够在有代码需要运行时，例如在点击时运行我们的代码，那么UI将感觉是响应性的。如果CPU正在处理其他事情，我们的代码将不得不等待。用户也只能等待。显然，在给定的操作系统环境中，有很多软件要求CPU的注意力——其中大部分完全超出我们的控制。我们无法减少浏览器之外其他应用程序的使用，但我们可以从我们的JavaScript应用程序中减少CPU的使用。但首先，我们需要了解这些JavaScript
    CPU周期来自哪里。
- en: At the architectural level, we don't think about micro optimizations that make
    little sections of a single component more efficient. We care about scaling down,
    which translates to a noticeable effect on the CPU consumption while our application
    is running. We saw, in [Chapter 7](ch07.html "Chapter 7. Load Time and Responsiveness"),
    *Load Time and Responsiveness*, how to profile our code. This tells us where the
    CPU is spending it's time in our code. With profiles as our measuring stick, we
    can proceed to make changes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构层面，我们不考虑使单个组件的小部分更高效的微优化。我们关心的是缩小规模，这在应用运行时对CPU消耗有明显的影响。我们在[第7章](ch07.html
    "第7章. 加载时间和响应性")，*加载时间和响应性*，看到了如何分析我们的代码。这告诉我们CPU在我们的代码中花费的时间。用配置文件作为我们的测量标准，我们可以进行更改。
- en: The two factors that influence the use of the CPU at an architecturally significant
    level are the number of active features, and the amount of data that's used by
    these features. For example, as we add more components to our system, there's
    naturally more CPU consumption, because when things happen in the UI, the component
    code for that feature needs to respond in some way. But this isn't likely to have
    a big impact on its own. It's the API data that comes with implementing a new
    feature that makes that CPU cost dangerously expensive.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 影响CPU使用的两个因素是活动的特性数量和这些特性使用的大小。例如，当我们向系统中添加更多组件时，CPU消耗自然会更多，因为当事情在UI中发生时，该特性的组件代码需要以某种方式响应。但这一点本身不太可能产生很大的影响。是实现新特性时伴随的API数据使得CPU成本变得昂贵。
- en: '![CPU consumption](img/4639_09_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![CPU消耗](img/4639_09_03.jpg)'
- en: Combining forces that eat CPU cycles—more data, processed by more components
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 合并消耗CPU周期的力量——处理更多数据的更多组件
- en: For example, if we were to keep implementing new features and the data set never
    changed, we would start to feel the CPU cost. This is because there's more indirection,
    meaning more code to run for any given event that takes place. This slow down
    would happen at glacial speeds however—we could just keep adding hundreds and
    hundreds of features, without breaking a sweat, CPU-wise. It's the changing data
    that makes this a scaling impossibility. Because if you multiply the number of
    features by the growing data sets, the CPU cost grows exponentially.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们不断实施新功能，而数据集保持不变，我们开始感受到CPU成本。这是因为有更多的间接性，意味着对于任何给定事件需要运行更多的代码。然而，这种减慢会以冰川般的速度发生——我们可以在不费吹灰之力的情况下，不断增加数百个功能。是变化的数据使这成为一种扩展不可能性。因为如果你将功能数量乘以不断增长的数据集，CPU成本将呈指数级增长。
- en: Well, maybe not *all* our features are consuming *all* of our data. And maybe
    there's very little indirection in our design. It's still the biggest factor to
    consider when it comes to scaling down. So if we need to cut CPU costs, we need
    to remove features and the data they process—it's the only way to get a measurable
    impact.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许并非我们所有的功能都在消耗所有的数据。也许我们的设计中间接性非常少。这仍然是在缩减规模时需要考虑的最大因素。所以如果我们需要降低CPU成本，我们就需要移除功能及其处理的数据——这是唯一能产生可测量影响的方法。
- en: 'Following is an example that shows how the number of components, combined with
    the number of data items, progressively consumes more CPU time:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了组件数量和数据项数量的组合如何逐渐消耗更多的CPU时间：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Backend capabilities
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端能力
- en: The final scaling constraint we'll address is the backend that serves our static
    resources and our API data. This is a limiting factor because our code can't run
    until it reaches the browser, and we can't display information for the user until
    the raw data has arrived. These two things are up to the backend to deliver on,
    but there are a few things to keep in mind about the backend when doing frontend
    development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的最后一个扩展限制是提供我们静态资源和API数据的后端。这是一个限制因素，因为我们的代码不能在到达浏览器之前运行，我们也不能在原始数据到达之前向用户显示信息。这两件事都取决于后端来实现，但在进行前端开发时，关于后端有几点需要注意的。
- en: The first concern is the usage of our application. Just as the browser running
    our JavaScript code can't scale infinitely up, neither can our backend APIs. While
    they have some characteristics that enable them to scale up that browsers don't,
    they still feel the impact of more request volume. The second concern is the way
    that our code interacts with the API. We have to look at the how a single user
    uses our application, and look at the API requests generated from those interactions.
    If we can optimize the requests made for one user, adding more users will have
    less of an impact on the backend.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个关注点是我们应用程序的使用情况。正如运行我们JavaScript代码的浏览器不能无限扩展一样，我们的后端API也不能无限扩展。虽然它们有一些特性使它们能够扩展浏览器不具备的，但它们仍然受到更多请求量的影响。第二个关注点是我们代码与API的交互方式。我们必须观察一个用户如何使用我们的应用程序，以及这些交互产生的API请求。如果我们能够优化一个用户的请求，增加更多用户对后端的冲击会更小。
- en: For example, we don't want to make requests that we don't need to. This means,
    *don't load data until it's actually needed*. And, *don't load the same data over
    and then over again*. If a user doesn't start interacting with a feature till
    five minutes into their session, that frees up the backend to service other requests
    during that interval. Sometimes our components use the same API endpoints. What
    if they're both created at the same time, and both send the same API request in
    succession? The backend has to service both requests, unnecessarily, because they're
    going to have the same content.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不想发起我们不需要的请求。这意味着，*在实际需要之前不要加载数据*。并且，*不要反复加载相同的数据*。如果一个用户在会话开始五分钟后才开始与一个功能互动，那么在这段时间内后端就可以处理其他请求。有时我们的组件会使用相同的API端点。如果它们同时被创建，并且先后发送相同的API请求会怎样呢？后端不得不服务这两个请求，这是不必要的，因为它们将具有相同的内容。
- en: We need to structure component communication to account for scaling influencers
    such as the load generated in the backend. In this particular instance, the second
    component could look up in a *pending requests* map and return that promise instead
    of generating a completely new request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建组件通信结构，以考虑规模影响因素，如后端产生的负载。在这个特定实例中，第二个组件可以在*挂起请求*映射中查找并返回那个承诺，而不是生成一个新的请求。
- en: '![Backend capabilities](img/4639_09_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![后端能力](img/4639_09_04.jpg)'
- en: Newer components should aim to consume less bandwidth; one approach is to accomplish
    the same functionality using fewer API requests
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 新组件应致力于减少带宽消耗；一种方法是使用更少的API请求来实现相同的功能。
- en: Conflicting features
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲突的功能
- en: The lines between our features become blurred as our software grows. There's
    bound to be at least some overlap, and that can be a good thing. If there wasn't
    at least a little overlap, users would have a tough time transitioning from one
    area of our UI to another. This becomes a problem when we reach a feature threshold
    where there're multiple overlapping layers that just keep overlapping. It's a
    self-propagating problem that get's worse with every new feature added, till it
    is addressed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们软件的增长，我们功能之间的界限变得模糊。至少会有一些重叠，这是件好事。如果没有至少一点重叠，用户在从我们UI的一个区域过渡到另一个区域时会有困难。当达到一个特性阈值时，问题就出现了，因为此时有多个重叠的层次不断叠加。这是一个自我传播的问题，每增加一个新特性就会变得更糟，直到解决这个问题。
- en: Two potential causes of this problem include parts of our application that grow
    irrelevant over time, and instead of being retired, they sit around and get in
    the way. Customer demand plays a big part in this scaling influence because it
    determines the future direction of the product. This should also give us an indication
    of what's in place now, that either needs to change in order to meet demand, or
    needs to go away in the near future.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的两个潜在原因包括我们应用程序中随时间变得无关的部分，而它们并没有被退役，而是闲置妨碍。客户需求在这种规模影响中起了很大的作用，因为它决定了产品的未来方向。这也应该让我们了解到现在所拥有的，要么为了满足需求而需要改变，要么在不久的将来需要消失。
- en: Overlapping functionality
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重叠功能
- en: Over the course of our application's life, there's going to be new functionality
    that overlaps with existing functionality. That's just the nature of software
    development— building on what you already have, not starting something way out
    left-field that has nothing to do with our existing features. What's nice is when
    that overlap is unobtrusive, and serves as a bridge from existing features to
    new features and enhancements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的生命周期中，将会有与现有功能重叠的新功能。这就是软件开发的本质——建立在你已经拥有的基础上，而不是从完全无关的领域开始。当这种重叠不显眼时，作为从现有功能到新功能和增强的桥梁，这是很好的。
- en: Where this overlap doesn't work so well is when it conflicts with existing features.
    It's like trying to build a house in the woods, without removing any trees first.
    One of two things needs to happen if the overlap is going to be seamless and scalable.
    Either we need to adjust what's already in place in order to accommodate what's
    coming down the line, or we need to rethink the new functionality so that it better
    fits in the available space. It's interesting, because given what we have, we
    sometimes have to scale down features before they're even implemented—this is
    often easier than after they've been implemented.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当重叠与现有功能冲突时，这种重叠就不那么好了。这就像想在树林里建房子，而不先移走任何树。如果重叠要无缝且可扩展，需要发生两件事之一。要么我们需要调整已经存在的内容以适应即将到来的内容，要么我们需要重新思考新功能，使其更好地适应可用空间。这很有趣，因为考虑到我们所拥有的，有时我们甚至在实现功能之前就必须缩减功能——这通常比实现后更容易。
- en: The end result of nonsensical feature overlap is something that the user finds
    clunky and difficult to use, so we can expect some complaints down the road. It
    is something else that we'll likely have to fix or remove later on. We actually
    tell ourselves this quite often—it's not a great addition, but it's good enough
    for the deadline. But at what cost is it *good enough*? In addition to the forecasted
    user frustration, there's also the code to worry about. Rarely do we say things
    like—*well, the users may not like it, but the code is fantastic*. The poor user
    experience is often the result of poor feature planning, followed by poor implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不合理的功能重叠的最终结果是用户觉得功能繁琐、难以使用，因此我们预计将来会收到一些投诉。这是我们稍后可能需要修复或删除的另一件事。我们实际上经常这样说服自己——这并不是一个很大的增加，但足够满足截止日期。但这种*足够好*的代价是什么？除了预期的用户烦恼外，还有代码需要担心。我们很少说这样的话——*好吧，用户可能不喜欢它，但代码非常棒*。通常糟糕的用户体验是功能规划不当和实施不佳的结果。
- en: The solution is quite simple, as we've already seen. It's a matter of making
    room for the changes, or altering the new feature. Something we often neglect
    is documenting the potential problems. For example, if we see a problem with a
    planned feature fitting in with our current code, we need to speak up and generate
    an outline of what doesn't fit where and why. It's always better to have this
    information archived and searchable than to ignore it. This is how we scale our
    architectural ideas, by being inclusive with the team.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案其实相当简单，正如我们已经看到的。这是为变化腾出空间，或者修改新功能的问题。我们经常忽视的一点是记录潜在问题。例如，如果我们看到一个计划中的功能与我们的现有代码不匹配，我们需要提出来并概述哪些不匹配以及为什么。拥有这些信息归档并可搜索总比忽视要好。这是我们通过与团队包容来扩展我们的架构理念的方式。
- en: '![Overlapping functionality](img/4639_09_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![功能重叠](img/4639_09_05.jpg)'
- en: Overlap between old features and new features is a good starting point for scaling
    down unnecessary code
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 旧功能与新功能之间的重叠是缩减不必要的代码的一个很好的起点
- en: Irrelevant features
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不相关功能
- en: Over time some features prove their worth. Our users love them, and use them
    often. What's more—we hardly have to maintain them. They just work. On the other
    hand, some of the other features we've implemented start to rust sooner than we
    would have liked. There could be any number of signs that this is taking place.
    Maybe a handful of users love the feature, but it's buggy and difficult to maintain.
    Maybe the majority of our users love the feature but it's preventing a number
    of initiatives from taking place in the project. But the most common case is that
    nobody is really using it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，一些功能证明了自己的价值。我们的用户非常喜欢它们，并且经常使用。更重要的是——我们几乎不需要维护它们。它们就是能正常工作。另一方面，我们实现的其他一些功能开始生锈的速度比我们预期的要快。可能有无数的迹象表明这种情况正在发生。也许有一小部分用户喜欢这个功能，但它存在bug并且难以维护。也许我们的大部分用户喜欢这个功能，但它阻碍了项目中的多项举措的实施。但最常见的情况是，根本没有人使用它。
- en: Whatever the reason, features do become irrelevant. Our problem, as an industry,
    is that we like to hoard code. Sometimes we keep around irrelevant functionality
    out of necessity—we would simply break too many things, or introduce backward
    incompatibility where we need it. Other times, and this really is a frontend problem
    more than anywhere else, we keep the feature around because we don't have an explicit
    mandate to rid ourselves of it. Well that needs to happen if we want to scale
    our application I'm afraid.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无论出于何种原因，功能确实变得不相关。我们作为行业的问题是我们喜欢积累代码。有时我们出于必要保留不相关的功能——我们可能会破坏太多东西，或者在需要的地方引入向后不兼容。在其他时候，这实际上更多的是前端问题，我们保留功能是因为我们没有明确的命令来摆脱它。好吧，如果我们想要扩展应用程序，我恐怕这种情况需要发生。
- en: It's a matter of being proactive rather than reactive. As we know, every component
    contributes to our scaling constraints—be it network, memory, CPU, or otherwise.
    Who knows, maybe we could get by just fine with the feature sitting around in
    our product. It's better to get it out of the way, because there's less chance
    of it actually constraining our ability to scale. We may think it's a harmless
    piece of code, but isn't it better to rule it out completely? Further, it's simply
    a good attitude to instill in everyone around us—scale down the things we don't
    need, then think about where to go from there. If we set the precedent with all
    our stakeholders that we're ready and willing to trim the fat, we're more likely
    to convince them to ship a leaner product.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个主动而不是被动的问题。正如我们所知，每个组件都对我们扩展约束有所贡献——无论是网络、内存、CPU还是其他方面。谁知道呢，也许我们的产品里存在的功能完全可以应付。最好把它解决掉，因为这样它实际上限制我们扩展能力的可能性更小。我们可能认为它是一段无害的代码，但彻底排除不是更好吗？此外，这种态度
    Simply put, it's better to scale down the things we don't need, and then think
    about where to go from there. If we set the precedent with all our stakeholders
    that we're ready and willing to trim the fat, we're more likely to convince them
    to ship a leaner product.
- en: '![Irrelevant features](img/4639_09_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![无关功能](img/4639_09_06.jpg)'
- en: There's only so much room for our application to scale; removing irrelevant
    features frees up scaling space
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可扩展的空间有限；删除无关功能可以释放扩展空间
- en: Customer demand
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户需求
- en: Depending on the type of product we're building, and the type of users it's
    servicing, customer demand will translate to either disciplined planning and implementation,
    or to knee-jerk reactions. We all want to make our customers happy—that's why
    we're building the software. But it's these quick decisions to implement stuff
    people are screaming for that detracts from our architecture. It's like we're
    implementing the features as though they were bugs. With bugs, we implement quick
    fixes as quickly as possible because we need to get them out the door.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于我们正在构建的产品类型，以及它服务的用户类型，客户需求将转化为有序规划实施，或者冲动反应。我们都想让客户开心——这就是我们为什么要开发软件。但正是这些快速决定实施人们尖叫着要的东西，损害了我们的架构。就好像我们把功能当成错误来实施。对于错误，我们尽快实施快速修复，因为我们需要把它们赶出门。
- en: New features aren't bugs. Despite what users and management say—they'll live
    another day without the functionality they're asking for. We need to find a way
    to buy ourselves the time necessary to fit the new features customers want into
    our architecture. That's not to say that we can keep putting it off—we have to
    do so in a timely manor. Perhaps excising existing features that users care less
    about is the fastest way forward.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能不是错误。尽管用户和管理层怎么说——没有他们所要求的功能他们也能活下去。我们需要找到一种方法，为我们争取必要的时间，将客户想要的新功能纳入我们的架构中。这并不是说我们可以一直推迟——我们必须及时地这样做。也许移除用户不太关心的现有功能是前进最快的途径。
- en: '![Customer demand](img/4639_09_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![客户需求](img/4639_09_07.jpg)'
- en: Figuring out which features make it into the next version; they're either features
    we already have, or new features that customers want
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确定哪些功能会包含在下一个版本中；这些功能要么是我们已经拥有的，要么是客户希望的新功能
- en: Design failures
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计失败
- en: It's one thing to scale down by fixing our code as it stands today. For example,
    by taking features out, or by modifying existing components to accommodate newly
    planned features. But that'll only get us so far into the future. Design ideas
    that seemed like a good idea two years ago were for the features we were thinking
    about two years ago, some of which may no longer be around today.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小规模一方面是通过修复我们现有的代码。例如，通过移除功能，或者通过修改现有组件以适应新计划的功能。但这也只能让我们在未来走得更远。两年前看起来是个好主意的设计想法，是为了我们当时考虑的功能，其中一些可能今天已经不再存在。
- en: To make a lasting impact on our architecture, we have to repair broken patterns.
    They still work in our product because we make them work, even though they may
    not be the best tools for the job. Figuring out the right design isn't a one time
    event, it happens as our software changes, and as our scaling influences command.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要想对我们的架构产生持久的影响，我们必须修复破碎的模式。它们仍然在我们的产品中起作用，因为我们在让它们起作用，尽管它们可能不是完成工作的最佳工具。找出正确的设计不是一个一次性的事件，它发生在我们的软件变化中，以及我们的扩展影响命令中。
- en: In this section we'll look at a few ways we might address some flaws in our
    design. Perhaps there're a lot of moving parts we don't need. Perhaps we're processing
    our API data inefficiently, due to the complexity of our component communication
    model. Or maybe the structure of our DOM elements is leading to obtuse selector
    strings and slowing down development. These are just a handful of possibilities—defective
    patterns vary project by project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几种可能解决我们设计中一些缺陷的方法。也许有很多我们不需要的活动部件。也许由于我们组件通信模型的复杂性，我们正在效率低下地处理我们的API数据。或者，我们DOM元素的结构导致了晦涩的选择器字符串，从而减慢了开发速度。这只是可能性的一小部分——缺陷模式因项目而异。
- en: Unnecessary components
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不必要的组件
- en: When we'll first set out to design our architecture and build our software,
    we'll leverage patterns that make sense at the time. We design our components
    to be loosely coupled with one another. To get this loose coupling, we often make
    a trade-off—more moving parts. For example, to keep the responsibilities of each
    component focused, we have to split larger components into smaller ones. These
    patterns determine the composition of our feature components. If we're following
    this pattern, and it has unnecessary parts, anything new we develop will also
    contain unnecessary parts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初开始设计我们的架构和构建我们的软件时，我们将利用当时有意义的模式。我们设计组件使其彼此之间松耦合。为了实现这种松耦合，我们通常会做出权衡——增加活动部件。例如，为了保持每个组件职责的专注，我们必须将较大的组件拆分为较小的组件。这些模式决定了我们特征组件的构成。如果我们遵循这种模式，并且它有不必要的部分，我们所开发的新东西也将包含不必要的部分。
- en: It's difficult to get patterns right, because when we need to decide on which
    patterns to use, we don't have enough information. Frameworks, for example, have
    very generic patterns in place because they serve a much broader audience than
    our application does. So while we want to utilize the same patterns exposed by
    the framework, we need to adapt them to our specific features. These are the patterns
    that change, gradually, as customer demand shifts the nature of our product. We
    can embrace this natural phenomenon, and invest the time in fixing our patterns.
    Or, we can go about fixing the issues as they arise, keeping our original patterns
    intact. Being amenable to changing what we once assumed was foundational is the
    best way to scale our architecture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 很难做到模式正确，因为当我们需要决定使用哪些模式时，我们没有足够的信息。例如，框架中有很多通用的模式，因为它们服务的受众比我们的应用程序广泛得多。因此，虽然我们想要利用框架暴露的相同模式，但我们需要将它们适应到我们的特定功能中。这些是随着客户需求逐渐改变我们产品的性质而逐渐变化的模式。我们可以接受这种自然现象，并投入时间修复我们的模式。或者，我们可以随着问题的出现而解决，保持我们原始的模式不变。对我们曾经认为的基础进行调整，是我们扩展架构的最佳方式。
- en: The most common pattern flaw is unnecessary indirection. That is, components
    that are abstract, and don't really have any value. While they decouple a component
    from something else, that's about all they do. We'll notice that over time, our
    code accumulates these modules that are relatively small, and tend to all look
    the same. They're small because they don't do much, and they look the same because
    they're part of the pattern we promised to be consistent with throughout our code.
    At the time that the pattern was conceived, this component made perfect sense.
    After having implemented several components, it makes less sense. Losing the component
    doesn't detract from the design, and in fact, the whole project feels a little
    lighter now. It's funny, the disconnect between what patterns look like on paper,
    and what they look like in a real application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的模式缺陷是多余的间接性。也就是说，组件是抽象的，并没有真正的价值。虽然它们将组件与另一样东西解耦，但它们所做的也就仅此而已。我们会注意到，随着时间的推移，我们的代码积累了这些相对较小的模块，而且倾向于看起来都一样。它们之所以小，是因为它们不做太多的事情，它们看起来一样，是因为它们是我们承诺在整个代码中一致使用的模式的一部分。在模式被构思的时候，这个组件是完全有意义的。实现几个组件后，它变得不那么有意义了。失去这个组件并不会损害设计，事实上，整个项目现在感觉有点更轻了。有趣的是，模式在纸上的样子与在实际应用中的样子之间的脱节。
- en: 'Next is an example that shows a component that uses a controller, and another
    version of the component that doesn''t require a controller and has one less moving
    part:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子展示了一个使用控制器的组件，以及另一个不需要控制器且少了一个活动部件的组件版本：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inefficient data processing
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低效的数据处理
- en: Micro-optimizations don't really buy us much in efficiency. Duplicate processing
    on the other hand can lead to massive scaling problems. The challenge is that
    we might not even notice that there's duplicate processing going on until we look
    for it. It often happens when data is passed from one component to another. The
    first component performs transformations on the API data. Then, the raw data is
    passed to the second component, which then proceeds to perform the exact same
    transformations. As more components are added, these inefficiencies start to add
    up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 微优化在效率上并没有给我们带来太多好处。另一方面，重复处理可能会导致巨大的扩展问题。挑战在于，我们可能甚至不会注意到正在进行重复处理，除非我们寻找它。这通常发生在数据从一个组件传递到另一个组件时。第一个组件对API数据进行转换。然后，原始数据被传递给第二个组件，它随后执行了完全相同的转换。随着更多组件的添加，这些低效问题开始累积。
- en: The reason we seldom catch these types of problems is that we're blinded by
    our beautiful design patterns. Sometimes the inefficiencies that hurt the user
    experience are masked by our code because we're doing things consistently. That
    is, we're keeping the relationships between our components loosely coupled, and
    because of this, our architecture scales in a number of respects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少发现这类问题的原因是我们被美丽的设计模式所迷惑。有时候，那些损害用户体验的低效问题被我们的代码所掩盖，因为我们是一致地做事情。也就是说，我们保持组件之间的关联关系是松耦合的，正因为如此，我们的架构在多个方面都能扩展。
- en: The majority of the time, a little bit of repetitive data processing is a perfectly
    acceptable trade-off. It depends on what it gains us in terms of flexibility for
    dealing with other scaling influences. For example, if we're able to easily handle
    a number of different configurations, and enable/disable features where we need
    to, because of the number of disparate deployments we have, then this trade off
    might make sense. However, scaling in one regard often means *not* scaling in
    another. For example, the amount of data is likely to increase, meaning the data
    that's passed around from component to component will increase. So the duplicitous
    data transformations that weren't a problem, are now a big problem. When this
    happens, we have to scale down our data processing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，一点重复的数据处理是完全可以接受的权衡。这取决于它在处理其他扩展影响方面的灵活性给我们带来了什么。例如，如果我们能够轻松地处理多种不同的配置，并在需要时启用/禁用功能，这是因为我们有数量众多的不统一部署，那么这种权衡可能是有意义的。然而，在一个方面扩展往往意味着在另一个方面不扩展。例如，数据量很可能会增加，这意味着组件之间传递的数据会增加。所以之前没有问题的那些偷偷摸摸的数据转换，现在变成了大问题。当这种情况发生时，我们必须减少数据处理。
- en: Again, this doesn't mean we need to start introducing micro-optimizations—it
    means we have to start hunting for the big efficiency wins. The starting point
    should always be with the network calls themselves, because not getting the data
    in the first place is the biggest efficiency win for the frontend. The second
    place to look at is the data that's getting passed around from component to component.
    This is where we need to make sure that a component isn't doing the exact same
    thing as the previous component in the chain.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不意味着我们需要开始引入微优化——这意味着我们必须开始寻找大的效率胜利。起点应该始终是网络调用本身，因为前端最大的效率胜利就是一开始就没有获取到数据。要查看的第二件事是组件之间传递的数据。我们需要确保一个组件没有在前一个组件链中做完全相同的事情。
- en: 'Following is an example that shows a component that will fetch model data each
    time `fetch()` is called. It also shows an alternative implementation that doesn''t
    fetch the model when there''s already a pending request:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了每次调用`fetch()`时都会获取模型数据的组件。它还展示了一个替代实现，当已经有挂起的请求时，不会获取模型：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Making duplicate API calls is tough to avoid when our components are decoupled
    from one another. For example, let's say that one feature creates a new model,
    and fetches it. Another feature that's on the same page needs the same model,
    but knows nothing about the first component—it too creates it and fetches data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的组件之间相互独立时，避免进行重复的API调用是很困难的。比如说，一个功能创建了一个新的模型并获取它。另一个在同一页上的功能需要相同的模型，但它对第一个组件一无所知——它也创建了一个模型并获取数据。
- en: These result in the exact same API call being made, which is obviously unnecessary.
    Not only is it inefficient for the frontend because it has two separate callbacks
    for the exact same data, it's also hurting the system as a whole. When we make
    requests that aren't needed, we're clogging up the request queue in the backend,
    affecting other users. We have to keep an eye out for these types of duplicate
    calls and adjust our architecture accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些会导致完全相同的API调用，这显然是不必要的。不仅对于前端来说效率低下，因为它对于完全相同的数据有两个不同的回调，而且它还损害了整个系统。当我们发起不需要的请求时，我们会在后端堵塞请求队列，影响其他用户。我们必须留心这些重复调用，并相应地调整我们的架构。
- en: Excessively creative markup
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过度创新的标记
- en: The markup used to render our UI components can grow a little out of control.
    Because we're aiming for a specific look and feel, we have to hack the markup
    a little in order to do that. Then we hack it some more, because it doesn't look
    quite right on this browser or that browser. The result is elements deeply nested
    in other elements, to the point where they've lost any semantic meaning. We should
    strive for semantic use of tags—a test goes in `p` elements, a clickable button
    is a `button` element, the page sections are split by `section` elements and so
    on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用于渲染我们UI组件的标记可能会变得有些失控。因为我们追求的是特定的外观和感觉，所以我们必须对标记进行一些篡改才能达到目的。然后我们再继续篡改，因为在这个浏览器或那个浏览器上看起来不太对。结果是元素被深深地嵌套在其他元素中，以至于它们失去了任何语义意义。我们应该努力实现标签的语义化使用——测试放入`p`元素中，可点击的按钮是`button`元素，页面部分用`section`元素分割等等。
- en: The challenge here is that the design we're going for is usually expressed as
    a wireframe, and we need to implement it in such a way that it can be sliced up
    into pieces that our framework and components can use. So the simplicity gets
    lost as trying to keep things semantic, and at the same time dividing into standalone
    views isn't always feasible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的挑战在于，我们追求的设计通常表现为线框图，我们需要以一种方式实现它，使其可以被切成我们的框架和组件可以使用的部分。因此，随着试图保持事物语义化，简单性就丧失了，同时将事物划分为独立的视图也不总是可行的。
- en: We have to try to simplify the DOM structure where we can though, because it
    has a direct impact on the simplicity and the performance of our JavaScript code.
    For example, our components often need to find elements on the page, either to
    change their state or to read values from them. We can write selector strings
    that query the DOM and return the elements we need. The strings are found all
    throughout our view code, and they reflect the complexity of our markup.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还是需要在可能的地方简化DOM结构，因为它直接影响到我们JavaScript代码的简单性和性能。例如，我们的组件经常需要找到页面上的元素，要么改变它们的状态，要么从它们那里读取值。我们可以编写选择器字符串，查询DOM并返回我们需要的元素。这些字符串贯穿于我们的视图代码中，它们反映了我们标记的复杂性。
- en: When we stumble across convoluted selector strings in our code, even the ones
    we wrote ourselves, we have no idea what it's actually querying for—because the
    DOM structure and the tags used are of no help. So it turns out that using semantic
    markup can actually be of great help to our JavaScript code. There're also the
    performance implications of complex DOM structures—if we're frequently traversing
    deep DOM structures, we're pay a performance penalty.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码中遇到复杂的选择器字符串时，即使是我们自己写的，我们也无法弄清楚它实际上在查询什么——因为DOM结构和所使用的标签并无帮助。所以结果证明，使用语义化标记实际上对我们的JavaScript代码有很大的帮助。还有复杂DOM结构的性能影响——如果我们经常遍历深层DOM结构，我们就会付出性能上的代价。
- en: '![Excessively creative markup](img/4639_09_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![过度创新的标记](img/4639_09_08.jpg)'
- en: Excessively deep element nesting can usually be scaled down, to not use so many
    elements
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 过度深入的元素嵌套通常可以简化，减少元素的使用。
- en: Application composition
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序组合
- en: We'll close out the chapter with a section on application composition. This
    is the 10,000 foot view of our application, where we can see how individual features
    fit. In [Chapter 3](ch03.html "Chapter 3. Component Composition"), *Component
    Composition* we looked at component composition, and the same principles apply
    here. The idea being that we're operating at a slightly higher level.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个关于应用程序组成的章节结束。这是我们对应用程序的10,000英尺高空视角，在这里我们可以看到各个功能是如何组合的。[第3章](ch03.html
    "第3章 组件组合")中，*组件组合*我们研究了组件组合，同样的原则在这里也适用。这个想法是我们正在操作一个稍微高层次的东西。
- en: In [Chapter 6](ch06.html "Chapter 6. User Preferences and Defaults"), *User
    Preferences and Defaults* we looked at configurability, and this is also relevant
    to the idea of application composition. For example, turning features off, or
    turning on features that are disabled by default. The composition of our application
    as a whole has a huge impact on our ability to scale down certain aspects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章 用户偏好和默认设置")，*用户偏好和默认设置*中，我们探讨了可配置性，这也与应用程序组成的想法相关。例如，关闭功能，或者打开默认禁用的功能。我们整个应用程序的组成对缩减某些方面有很大的影响。
- en: Feature enablement
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能启用
- en: The expedient approach to scaling down is turning features off. The difficult
    part is getting stakeholders to agree that this is a good idea. Then we can just
    remove the feature, and we're all set, right? Not necessarily. We may have to
    spend some time taking the feature out. For example, what if it touches several
    entry points into the system and there's no configuration that can switch these
    off? It's no big deal, it just means we need more time spent on writing code that
    takes these out.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减的便捷方法是关闭功能。困难的部分是让利益相关者同意这是一个好主意。然后我们可以直接删除功能，一切就绪了，对吧？不一定。我们可能需要花些时间来移除功能。例如，如果它涉及到系统的几个入口点，而且没有配置可以关闭这些入口点呢？这不是什么大问题，只是意味着我们需要花更多时间编写移除这些功能的代码。
- en: The only problem is with testing the effects of taking the feature out of the
    system. For the scenario where there's no configuration that'll do the job, we
    have to spend time writing code that will do it, before we even get to test it.
    For instance, we could spend five minutes turning off configuration values, and
    then we'll get immediate results. Maybe we learn early on that there's a lot of
    work that needs to be done before we can safely remove the feature from the system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是测试从系统中移除功能的效果。对于没有配置能完成工作的场景，我们不得不花时间编写代码来做这件事，然后我们才能进行测试。例如，我们可以花五分钟关闭配置值，然后我们就会得到立即的结果。也许我们最早就能了解到，在我们可以安全地将功能从系统中移除之前，有很多工作要做。
- en: In addition to testing the runtime behavior of our application once a feature
    has been removed, we'll probably want some build-time options as well. If our
    production code is compiled into a handful of JavaScript artifacts, then we need
    a way to completely remove these features from the build. It's one thing to disable
    components through configuration. That means when our code runs, certain things
    won't load, and so on. If we take the feature out of our source code repository,
    then 'it's obviously less of a concern—our tools can't build what isn't there.
    However, if we have hundreds of potential components that can be included in our
    build artifacts, we need a way to exclude them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在删除功能后测试我们应用程序的运行行为外，我们可能还需要一些构建时的选项。如果我们的生产代码被编译成几个JavaScript工件，那么我们需要一种完全从构建中移除这些功能的方法。通过配置禁用组件是一回事，这意味着当我们的代码运行时，某些东西不会加载等等。如果我们把功能从我们的源代码仓库中移除，那么这显然不那么令人担忧——我们的工具无法构建不存在的代码。然而，如果我们有数百个可能包含在我们构建工件中的潜在组件，我们需要一种排除它们的方法。
- en: New feature impact
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能影响
- en: The next major impact on our application is the addition of new features. Yes,
    this discussion is about scaling down, but we can't ignore the addition of new
    features into our application. This is, after all, why we're scaling down in the
    first place. Not to build a smaller application that does less. It's to make room
    for features our customers want, and to improve the overall quality of our product
    over time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们应用程序的下一个重大影响是新功能的添加。是的，这个讨论是关于缩减的，但我们不能忽视新功能对我们应用程序的添加。毕竟，这就是我们最初为什么要缩减的原因。不是为了构建一个做更少的较小应用程序。这是为了给客户想要的功能腾出空间，并随着时间的推移提高我们产品的整体质量。
- en: The processes of adding features and removing features often happen in parallel.
    For example, during a development sprint, while one team implements a new feature,
    another team is responsible for the removal of a feature that's causing problems.
    Since both of these activities affect the application in major ways, we have to
    be considerate, and minimize these effects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 添加功能和删除功能的过程通常是并行的。例如，在一个开发冲刺期间，一个团队负责实现一个新功能，而另一个团队负责移除一个正在引起问题的问题功能。由于这两项活动都以重大方式影响应用程序，我们必须小心行事，并尽量减少这些影响。
- en: Essentially, that means making sure that the removal of the old feature isn't
    too disruptive to the new feature that's being added. For example, what if the
    new feature depended on something from the old feature. If our design is sound,
    then there won't be any direct dependencies. However, complexity is not well understood
    by humans—especially cause and effect through indirection. So scaling this operation
    might mean that we don't perform the two activities in parallel after all.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这意味着确保旧功能的移除不会对新添加的功能造成太大的干扰。例如，如果新功能依赖于旧功能中的某个部分。如果我们的设计是合理的，那么就不会有直接的依赖关系。然而，人类对复杂性理解不足——尤其是通过间接作用的原因和效果。因此，扩大这项操作可能意味着我们根本不能在所有活动中并行执行。
- en: '![New feature impact](img/4639_09_09.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![新功能影响](img/4639_09_09.jpg)'
- en: Depending on our inter-component communication model, the effects of adding
    new components into the system should be fairly subdued
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们组件间通信模型的不同，向系统中添加新组件的效果应该是相当温和的。
- en: Essential libraries
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心库
- en: The last pieces that impact the composition of our application are the frameworks
    and libraries we're using. It goes without saying that we only want to use what
    we need—use it or lose it, so to speak. This is mainly an issue when we're pulling
    in smaller libraries as dependencies. Frameworks, by contrast, are all inclusive
    for the most part. This means that everything you need is likely in the framework
    already. While this isn't necessarily true, it still helps us reduce the number
    of dependencies on third-party libraries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 影响我们应用组合的最后因素就是我们所使用的框架和库。不言而喻，我们只想要用我们所需要的——所谓“用进废退”。这主要是在我们引入较小库作为依赖时的问题。相比之下，框架在大部分情况下是包含一切的。这意味着你可能需要的所有东西框架里都已经有了。虽然这并不一定正确，但它仍然帮助我们减少了第三方库的依赖。
- en: Even frameworks are modular nowadays, meaning we can cherry-pick the goodness
    we want and leave the rest alone. Even still, it's easy to bring in components,
    from a framework or otherwise, that we won't really use. This happens quite a
    lot in web site development. We need this one piece of functionality, and we don't
    want to write it ourselves because that library over there already does it. Then
    it gets lost in the mix of pages. We should learn the lesson that web sites didn't—our
    applications need a focused set of dependencies, essential to getting the job
    done.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 即便框架如今也是模块化的，这意味着我们可以挑选我们想要的好东西，而把其他的留给别人。即便如此，引入组件（无论是来自框架还是其他地方）仍然很容易，而这些我们可能根本不会使用。这在网站开发中相当常见。我们需要这样的一个功能模块，我们不想亲自编写，因为那边的库已经能实现了。然后它就会迷失在页面混合中。我们应该吸取网站没有学到的教训——我们的应用需要一组专注的依赖关系，这对于完成工作至关重要。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the notion that not everything in our application is
    infinitely scalable. In fact, nothing about our application is infinitely scalable,
    as each aspect is constrained by different factors. These factors all blend together
    in unique ways, and it's up to us to make the necessary trade-offs. If we want
    to keep scaling up, we have to scale down in other areas.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了这样一个观念：我们应用中的并非一切都是无限可扩展的。实际上，我们应用中的任何方面都不是无限可扩展的，因为每个方面都受到不同因素的限制。这些因素以独特的方式融合在一起，我们必须要做出必要的权衡。如果我们想要持续扩展，我们必须在其他领域进行缩减。
- en: New features come from customer demand, and they often overlap with other features
    we've already implemented. This could be because we haven't defined the new feature
    very well, or because the existing entry points into the system aren't very well
    defined. Either way, this can make for a challenging exercise; the removal of
    existing features, in place of a new feature. We often need to remove the areas
    of overlap, as they cause confusion both at the code level and the usability level.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能源于客户需求，它们通常与我们已经实现的其他功能重叠。这可能是因为我们没有对新功能定义得很清楚，或者是因为系统现有的入口点定义得不明确。无论如何，这都可能使得一个具有挑战性的练习；用新功能替换现有功能。我们经常需要去除重叠区域，因为它们在代码层面和可用性层面都会造成混淆。
- en: Scaling down isn't just a piece by piece activity—there are the design patterns
    to think about as well. After we've removed a feature, we need to look at the
    patterns we're using and ask, *do we want to keep having to do this in the future?*
    The better, more scalable path forward, is to fix the pattern. Even after we've
    scaled down, there's always the potential for error. In the following chapter,
    we'll take a closer look at failing components, and how to deal with them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小规模不仅仅是逐个处理的活动——还需要考虑设计模式。移除一个功能后，我们需要审视我们正在使用的模式，并问自己，*我们是否希望未来一直重复这样做？* 向前发展的更好、更可扩展的方法，是修复这个模式。即使在我们缩减规模之后，仍然存在出错的可能性。在下一章中，我们将更详细地探讨失败的组件以及如何处理它们。
