- en: Chapter 1. JavaScript Primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is always difficult to pen the first few words, especially on a subject like
    JavaScript. This difficulty arises primarily because so many things have been
    said about this language. JavaScript has been the *Language of the Web*—lingua
    franca, if you will, since the earliest days of the Netscape Navigator. JavaScript
    went from a tool of the amateur to the weapon of the connoisseur in a shockingly
    short period of time.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is the most popular language on the web and open source ecosystem.
    [http://githut.info/](http://githut.info/) charts the number of active repositories
    and overall popularity of the language on GitHub for the last few years. JavaScript's
    popularity and importance can be attributed to its association with the browser.
    Google's V8 and Mozilla's SpiderMonkey are extremely optimized JavaScript engines
    that power Google Chrome and Mozilla Firefox browsers, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Although web browsers are the most widely used platforms for JavaScript, modern
    databases such as MongoDB and CouchDB use JavaScript as their scripting and query
    language. JavaScript has become an important platform outside browsers as well.
    Projects such as **Node.js** and **io.js** provide powerful platforms to develop
    scalable server environments using JavaScript. Several interesting projects are
    pushing the language capabilities to its limits, for example, **Emscripten** ([http://kripken.github.io/emscripten-site/](http://kripken.github.io/emscripten-site/))
    is a **Low-Level Virtual Machine** (**LLVM**)-based project that compiles C and
    C++ into highly optimizable JavaScript in an **asm.js** format. This allows you
    to run C and C++ on the web at near native speed.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is built around solid foundations regarding, for example, functions,
    dynamic objects, loose typing, prototypal inheritance, and a powerful object literal
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: While JavaScript is built on sound design principles, unfortunately, the language
    had to evolve along with the browser. Web browsers are notorious in the way they
    support various features and standards. JavaScript tried to accommodate all the
    whims of the browsers and ended up making some very bad design decisions. These
    bad parts (the term made famous by Douglas Crockford) overshadowed the good parts
    of the language for most people. Programmers wrote bad code, other programmers
    had nightmares trying to debug that bad code, and the language eventually got
    a bad reputation. Unfortunately, JavaScript is one of the most misunderstood programming
    languages ([http://javascript.crockford.com/javascript.html](http://javascript.crockford.com/javascript.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Another criticism leveled at JavaScript is that it lets you get things done
    without you being an expert in the language. I have seen programmers write exceptionally
    bad JavaScript code just because they wanted to get the things done quickly and
    JavaScript allowed them to do just this. I have spent hours debugging very bad
    quality JavaScript written by someone who clearly was not a programmer. However,
    the language is a tool and cannot be blamed for sloppy programming. Like all crafts,
    programming demands extreme dedication and discipline.
  prefs: []
  type: TYPE_NORMAL
- en: A little bit of history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 1993, the **Mosaic** browser of **National Center for Supercomputing Applications**
    (**NCSA**) was one of the first popular web browsers. A year later, Netscape Communications
    created the proprietary web browser, **Netscape Navigator**. Several original
    Mosaic authors worked on Navigator.
  prefs: []
  type: TYPE_NORMAL
- en: In 1995, Netscape Communications hired Brendan Eich with the promise of letting
    him implement **Scheme** (a Lisp dialect) in the browser. Before this happened,
    Netscape got in touch with Sun Microsystems (now Oracle) to include Java in the
    Navigator browser.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the popularity and easy programming of Java, Netscape decided that a
    scripting language had to have a syntax similar to that of Java. This ruled out
    adopting existing languages such as Python, **Tool Command Language** (**TCL**),
    or Scheme. Eich wrote the initial prototype in just 10 days ([http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf](http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf)),
    in May 1995\. JavaScript's first code name was **Mocha**, coined by Marc Andreessen.
    Netscape later changed it to **LiveScript**, for trademark reasons. In early December
    1995, Sun licensed the trademark Java to Netscape. The language was renamed to
    its final name, JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: How to use this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is not going to help if you are looking to get things done quickly.
    This book is going to focus on the correct ways to code in JavaScript. We are
    going to spend a lot of time understanding how to avoid the bad parts of the language
    and build reliable and readable code in JavaScript. We will skirt away from sloppy
    features of the language just to make sure that you are not getting used to them—if
    you have already learned to code using these habits, this book will try to nudge
    you away from this. There will be a lot of focus on the correct style and tools
    to make your code better.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the concepts in this book are going to be examples and patterns from
    real-world problems. I will insist that you code each of the snippets to make
    sure that your understanding of the concept is getting programmed into your muscle
    memory. Trust me on this, there is no better way to learn programming than writing
    a lot of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, you will need to create an HTML page to run an embedded JavaScript
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This sample code shows two ways in which JavaScript is embedded into the HTML
    page. First, the `<script>` tag in `<head>` imports JavaScript, while the second
    `<script>` tag is used to embed inline JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can save this HTML page locally and open it in a browser. On Firefox, you
    can open the **Developer** console (Firefox menu | **Developer** | **Web Console**)
    and you can see the **"Hello World"** text on the **Console** tab. Based on your
    OS and browser version, the screen may look different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to use this book](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can run the page and inspect it using Chrome''s **Developer Tool**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to use this book](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A very interesting thing to notice here is that there is an error displayed
    on the console regarding the missing `.js` file that we are trying to import using
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using browser developer consoles or an extension such as **Firebug** can be
    very useful in debugging error conditions in the code. We will discuss in detail
    the debugging techniques in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating such HTML scaffolds can be tedious for every exercise in this book.
    Instead, we want to use a **Read-Eval-Print-Loop** (**REPL**) for JavaScript.
    Unlike Python, JavaScript does not come packaged with an REPL. We can use Node.js
    as an REPL. If you have Node.js installed on your machine, you can just type `node`
    on the command line and start experimenting with it. You will observe that Node
    REPL errors are not very elegantly displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After this error, you will have to restart. Still, it can help you try out small
    fragments of code a lot faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tool that I personally use a lot is **JS Bin** ([http://jsbin.com/](http://jsbin.com/)).
    JS Bin provides you with a great set of tools to test JavaScript, such as syntax
    highlighting and runtime error detection. The following is a screenshot of JS
    Bin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to use this book](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Based on your preference, you can pick the tool that makes it easier to try
    out the code samples. Regardless of which tool you use, make sure that you type
    out every exercise in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No programming language should be published without a customary Hello World
    program—why should this book be any different?
  prefs: []
  type: TYPE_NORMAL
- en: 'Type (don''t copy and paste) the following code in JS Bin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Your screen should look something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hello World](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An overview of JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a nutshell, JavaScript is a prototype-based scripting language with dynamic
    typing and first-class function support. JavaScript borrows most of its syntax
    from Java, but is also influenced by Awk, Perl, and Python. JavaScript is case-sensitive
    and white space-agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript allows single line or multiple line comments. The syntax is similar
    to C or Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables are symbolic names for values. The names of variables, or identifiers,
    must follow certain rules.
  prefs: []
  type: TYPE_NORMAL
- en: A JavaScript variable name must start with a letter, underscore (_), or dollar
    sign ($); subsequent characters can also be digits (0-9). As JavaScript is case
    sensitive, letters include the characters *A* through *Z* (uppercase) and the
    characters *a* through *z* (lowercase).
  prefs: []
  type: TYPE_NORMAL
- en: You can use ISO 8859-1 or Unicode letters in variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'New variables in JavaScript should be defined with the **var** keyword. If
    you declare a variable without assigning a value to it, its type is undefined
    by default. One terrible thing is that if you don''t declare your variable with
    the var keyword, they become implicit globals. Let me reiterate that implicit
    globals are a terrible thing—we will discuss this in detail later in the book
    when we discuss variable scopes and closures, but it''s important to remember
    that you should always declare a variable with the var keyword unless you know
    what you are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `NaN` value is a special value that indicates that the entity is *not a
    number*.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create a read-only named constant with the **const** keyword. The constant
    name must start with a letter, underscore, or dollar sign and can contain alphabetic,
    numeric, or underscore characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A constant cannot change the value through assignment or be redeclared, and
    it has to be initialized to a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript supports the standard variations of types:'
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol (new in ECMAScript 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: RegExp
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Number** type can represent both 32-bit integer and 64-bit floating point
    values. For example, the following line of code declares a variable to hold an
    integer value, which is defined by the literal 555:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To define a floating point value, you need to include a decimal point and one
    digit after the decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, there's no such thing as an integer in JavaScript. JavaScript uses
    a 64-bit floating point representation, which is the same as Java's double.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, you would see something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I recommend that you read the exhaustive answer on Stack Overflow ([http://stackoverflow.com/questions/588004/is-floating-point-math-broken](http://stackoverflow.com/questions/588004/is-floating-point-math-broken))
    and ([http://floating-point-gui.de/](http://floating-point-gui.de/)), which explains
    why this is the case. However, it is important to understand that floating point
    arithmetic should be handled with due care. In most cases, you will not have to
    rely on extreme precision of decimal points but if you have to, you can try using
    libraries such as **big.js** ([https://github.com/MikeMcl/big.js](https://github.com/MikeMcl/big.js))
    that try to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: If you intend to code extremely precise financial systems, you should represent
    $ values as cents to avoid rounding errors. One of the systems that I worked on
    used to round off the **Value Added Tax** (**VAT**) amount to two decimal points.
    With thousands of orders a day, this rounding off amount per order became a massive
    accounting headache. We needed to overhaul the entire Java web service stack and
    JavaScript frontend for this.
  prefs: []
  type: TYPE_NORMAL
- en: A few special values are also defined as part of the Number type. The first
    two are `Number.MAX_VALUE` and `Number.MIN_VALUE`, which define the outer bounds
    of the Number value set. All ECMAScript numbers must fall between these two values,
    without exception. A calculation can, however, result in a number that does not
    fall in between these two numbers. When a calculation results in a number greater
    than `Number.MAX_VALUE`, it is assigned a value of `Number.POSITIVE_INFINITY`,
    meaning that it has no numeric value anymore. Likewise, a calculation that results
    in a number less than `Number.MIN_VALUE` is assigned a value of `Number.NEGATIVE_INFINITY`,
    which also has no numeric value. If a calculation returns an infinite value, the
    result cannot be used in any further calculations. You can use the `isInfinite()`
    method to verify if the calculation result is an infinity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another peculiarity of JavaScript is a special value called NaN (short for
    *Not a Number*). In general, this occurs when conversion from another type (String,
    Boolean, and so on) fails. Observe the following peculiarity of NaN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line is strange—NaN is not equal to NaN. If NaN is part of any mathematical
    operation, the result also becomes NaN. As a general rule, stay away from using
    NaN in any expression. For any advanced mathematical operations, you can use the
    `Math` global object and its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `parseInt()` and `parseFloat()` methods to convert a string
    expression to an integer or float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With `parseInt()`, you should provide an explicit base to prevent nasty surprises
    on older browsers. The last trick is just using a `+` sign to auto-convert the
    `"42"` string to a number, `42`. It is also prudent to handle the `parseInt()`
    result with `isNaN()`. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you are not sure of the type of the value that the `underterminedValue`
    variable can hold if the value is being set from an external interface. If `isNaN()`
    is not handled, `parseInt()` will cause an exception and the program can crash.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, strings are a sequence of Unicode characters (each character
    takes 16 bits). Each character in the string can be accessed by its index. The
    first character index is zero. Strings are enclosed inside `"` or `''`—both are
    valid ways to represent strings. Let''s see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line shows you how certain character literals when escaped with a
    backslash `\` can be used as special characters. The following is a list of such
    special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\n`: Newline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\t`: Tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b`: Backspace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\r`: Carriage return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\\`: Backslash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\''`: Single quote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\"`: Double quote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You get default support for special characters and Unicode literals with JavaScript
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'One important thing about JavaScript Strings, Numbers, and Booleans is that
    they actually have wrapper objects around their primitive equivalent. The following
    example shows the usage of the wrapper objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript allows multiline strings also. Strings enclosed within `` ` `` (Grave
    accent—[https://en.wikipedia.org/wiki/Grave_accent](https://en.wikipedia.org/wiki/Grave_accent))
    are considered multiline. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This kind of string is also known as a template string and can be used for string
    interpolation. JavaScript allows Python-like string interpolation using this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, you would do something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with string interpolation, things become a bit clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Undefined values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript indicates an absence of meaningful values by two special values—null,
    when the non-value is deliberate, and undefined, when the value is not assigned
    to the variable yet. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript Boolean primitives are represented by `true` and `false` keywords.
    The following rules govern what becomes false and what turns out to be true:'
  prefs: []
  type: TYPE_NORMAL
- en: False, 0, the empty string (""), NaN, null, and undefined are represented as
    false
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else is true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript Booleans are tricky primarily because the behavior is radically different
    in the way you create them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which you can create Booleans in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create primitive Booleans by assigning a true or false literal to a
    variable. Consider the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `Boolean()` function; this is an ordinary function that returns a primitive
    Boolean:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both these methods return expected *truthy* or *falsy* values. However, if you
    create a Boolean object using the `new` operator, things can go really wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, when you use the `new` operator and the `Boolean(value)` constructor,
    you don''t get a primitive `true` or `false` in return, you get an object instead—and
    unfortunately, JavaScript considers an object as *truthy*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, the smart thing to do is to always avoid Boolean constructors to create
    a new Boolean object. It breaks the fundamental contract of Boolean logic and
    you should stay away from such difficult-to-debug buggy code.
  prefs: []
  type: TYPE_NORMAL
- en: The instanceof operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the problems with using reference types to store values has been the
    use of the **typeof** operator, which returns `object` no matter what type of
    object is being referenced. To provide a solution, you can use the **instanceof**
    operator. Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The third line returns `false`. We will discuss why this is the case when we
    discuss prototype chains.
  prefs: []
  type: TYPE_NORMAL
- en: Date objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript does not have a date data type. Instead, you can use the **Date**
    object and its methods to work with dates and times in your applications. A Date
    object is pretty exhaustive and contains several methods to handle most date-
    and time-related use cases.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript treats dates similarly to Java. JavaScript store dates as the number
    of milliseconds since January 1, 1970, 00:00:00.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a Date object using the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters for the Date object constructors can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No parameters creates today's date and time. For example, `var today = new Date();`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A String representing a date as `Month day, year hours:minutes:seconds`. For
    example, `var twoThousandFifteen = new Date("December 31, 2015 23:59:59");`. If
    you omit hours, minutes, or seconds, the value will be set to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of integer values for the year, month, and day. For example, `var christmas
    = new Date(2015, 11, 25);`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of integer values for the year, month, day, hour, minute, and seconds.
    For example, `var christmas = new Date(2015, 11, 25, 21, 00, 0);`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples on how to create and manipulate dates in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For any serious applications that require fine-grained control over date and
    time objects, we recommend using libraries such as **Moment.js** ([https://github.com/moment/moment](https://github.com/moment/moment)),
    **Timezone.js** ([https://github.com/mde/timezone-js](https://github.com/mde/timezone-js)),
    or **date.js** ([https://github.com/MatthewMueller/date](https://github.com/MatthewMueller/date)).
    These libraries simplify a lot of recurrent tasks for you and help you focus on
    other important things.
  prefs: []
  type: TYPE_NORMAL
- en: The + operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **+** operator, when used as a unary, does not have any effect on a number.
    However, when applied to a String, the + operator converts it to numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The + operator is used often by a programmer to quickly convert a numeric representation
    of a String to a number. However, if the String literal is not something that
    can be converted to a number, you get slightly unpredictable results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss the effects of the + operator on several other data types later
    in the text.
  prefs: []
  type: TYPE_NORMAL
- en: The ++ and -- operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ++ operator is a shorthand version of adding `1` to a value and -- is a
    shorthand to subtract `1` from a value. Java and C have equivalent operators and
    most will be familiar with them. How about this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Err, what happened here? Shouldn''t the `b` variable have the value `2`? The
    ++ and -- operators are unary operators that can be used either prefix or postfix.
    The order in which they are used matters. When ++ is used in the prefix position
    as `++a`, it increments the value before the value is returned from the expression
    rather than after as with `a++`. Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Many programmers use the chained assignments to assign a single value to multiple
    variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is fine because the assignment operator (=) results in the value being
    assigned. In this case, `c=0` is evaluated to `0`; this would result in `b=0`,
    which also evaluates to `0`, and hence, `a=0` is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a slight change to the previous example yields extraordinary results.
    Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this case, only the `a` variable is declared with `var`, while the `b` variable
    is created as an accidental global. (If you are in the strict mode, you will get
    an error for this.) With JavaScript, be careful what you wish for, you might get
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three Boolean operators in JavaScript—AND(&), OR(|), and NOT(!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we discuss logical AND and OR operators, we need to understand how they
    produce a Boolean result. Logical operators are evaluated from left to right and
    they are tested using the following short-circuit rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical AND**: If the first operand determines the result, the second operand
    is not evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, I have highlighted the right-hand side expression
    if it gets executed as part of short-circuit evaluation rules:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Logical OR**: If the first operand is true, the second operand is not evaluated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, both logical AND and logical OR can also be used for non-Boolean operands.
    When either the left or right operand is not a primitive Boolean value, AND and
    OR do not return Boolean values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we will explain the three logical Boolean operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical AND(&&): If the first operand object is *falsy*, it returns that object.
    If its *truthy*, the second operand object is returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Logical OR(||): If the first operand is *truthy*, it''s returned. Otherwise,
    the second operand is returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The typical use of a logical OR is to assign a default value to a variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see this pattern frequently in most professional JavaScript libraries.
    You should understand how the defaulting is done by using a logical OR operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Logical NOT**: This always returns a Boolean value. The value returned depends
    on the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, JavaScript supports C-like ternary operators as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If `(age>21)`, the expression after `?` will be assigned to the `allowedToDrive`
    variable and the expression after `:` is assigned otherwise. This is equivalent
    to an if-else conditional statement. Let''s see another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `isAllowedToDrive()` function accepts one integer parameter,
    `age`. Based on the value of this variable, we return true or false to the calling
    function. This is a well-known and most familiar if-else conditional logic. Most
    of the time, if-else keeps the code easier to read. For simpler cases of single
    conditions, using the ternary operator is also okay, but if you see that you are
    using the ternary operator for more complicated expressions, try to stick with
    if-else because it is easier to interpret if-else conditions than a very complex
    ternary expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'If-else conditional statements can be nested as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Purely as a matter of taste, you can indent the nested `else if` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not use assignments in place of a conditional statement. Most of the time,
    they are used because of a mistake as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Mostly, this happens by mistake; the intended code was `if(a==b)`, or better,
    `if(a===b)`. When you make this mistake and replace a conditional statement with
    an assignment statement, you end up committing a very difficult-to-find bug. However,
    if you really want to use an assignment statement with an if statement, make sure
    that you make your intentions very clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to put extra parentheses around your assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to handle conditional execution is to use switch-case statements.
    The switch-case construct in JavaScript is similar to that in C or Java. Let''s
    see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'One problem with this structure is that you have `break` out of every case;
    otherwise, the execution will fall through to the next level. If we remove the
    `break` statement from the first case statement, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, if we omit the `break` statement to break the execution immediately
    after a condition is satisfied, the execution sequence follows to the next level.
    This can lead to difficult-to-detect problems in your code. However, this is also
    a popular style of writing conditional logic if you intend to fall through to
    the next level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are intentionally letting the execution fall through to
    write a concise switch-case. If levels are either INFO, WARN, or DEBUG, we use
    the switch-case to fall through to a single point of execution. We omit the `break`
    statement for this. If you want to follow this pattern of writing switch statements,
    make sure that you document your usage for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: Switch statements can have a `default` case to handle any value that cannot
    be evaluated by any other case.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has a while and do-while loop. The while loop lets you iterate a
    set of expressions till a condition is met. The following first example iterates
    the statements enclosed within `{}` till the `i<10` expression is true. Remember
    that if the value of the `i` counter is already greater than `10`, the loop will
    not execute at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following loop keeps executing till infinity because the condition is always
    true—this can lead to disastrous effects. Your program can use up all your memory
    or something equally unpleasant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to make sure that you execute the loop at least once, you can use
    the do-while loop (sometimes known as a post-condition loop):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are asking the user for an input till we find a valid input
    from the user. While the user types invalid input, we keep asking for an input
    to the user. It is always argued that, logically, every do-while loop can be transformed
    into a while loop. However, a do-while loop has a very valid use case like the
    one we just saw where you want the condition to be checked only after there has
    been one execution of the loop block.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has a very powerful loop similar to C or Java—the for loop. The for
    loop is popular because it allows you to define the control conditions of the
    loop in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example prints `Hello` five times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Within the definition of the loop, you defined the initial value of the loop
    counter `i` to be `0`, you defined the `i<5` exit condition, and finally, you
    defined the increment factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'All three expressions in the previous example are optional. You can omit them
    if required. For example, the following variations are all going to produce the
    same result as the previous loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also omit all three of these expressions and write for loops. One interesting
    idiom used frequently is to use for loops with empty statements. The following
    loop is used to set all the elements of the array to `100`. Notice how there is
    no body to the for-loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The empty statement here is just the single that we see after the for loop statement.
    The increment factor also modifies the array content. We will discuss arrays later
    in the book, but here it's sufficient to see that the array elements are set to
    the `100` value within the loop definition itself.
  prefs: []
  type: TYPE_NORMAL
- en: Equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript offers two modes of equality—strict and loose. Essentially, loose
    equality will perform the type conversion when comparing two values, while strict
    equality will check the values without any type conversion. A strict equality
    check is performed by === while a loose equality check is performed by ==.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECMAScript 6 also offers the `Object.is` method to do a strict equality check
    like ===. However, `Object.is` has a special handling for NaN: -0 and +0\. When
    *NaN===NaN* and *NaN==NaN* evaluates to false, `Object.is(NaN,NaN)` will return
    true.'
  prefs: []
  type: TYPE_NORMAL
- en: Strict equality using ===
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict equality compares two values without any implicit type conversions.
    The following rules apply:'
  prefs: []
  type: TYPE_NORMAL
- en: If the values are of a different type, they are unequal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-numerical values of the same type, they are equal if their values are
    the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For primitive numbers, strict equality works for values. If the values are the
    same, === results in `true`. However, a NaN doesn't equal to any number and `NaN===<a
    number>` would be a `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strict equality is always the correct equality check to use. Make it a rule
    to always use === instead of ==:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"" === "0"` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `0 === ""` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `0 === "0"` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `false === "false"` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `false === "0"` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `false === undefined` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `false === null` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `null === undefined` | false |'
  prefs: []
  type: TYPE_TB
- en: 'In case of comparing objects, we get results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `{} === {};` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `new String(''bah'') === ''bah'';` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `new Number(1) === 1;` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `var bar = {};``bar === bar;` | true |'
  prefs: []
  type: TYPE_TB
- en: 'The following are further examples that you should try on either JS Bin or
    Node REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can use `!==` to handle the **Not Equal To** case while doing strict equality
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: Weak equality using ==
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Nothing should tempt you to use this form of equality. Seriously, stay away
    from this form. There are many bad things with this form of equality primarily
    due to the weak typing in JavaScript. The equality operator, ==, first tries to
    coerce the type before doing a comparison. The following examples show you how
    this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"" == "0"` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `0 == ""` | true |'
  prefs: []
  type: TYPE_TB
- en: '| `0 == "0"` | true |'
  prefs: []
  type: TYPE_TB
- en: '| `false == "false"` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `false == "0"` | true |'
  prefs: []
  type: TYPE_TB
- en: '| `false == undefined` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `false == null` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `null == undefined` | true |'
  prefs: []
  type: TYPE_TB
- en: From these examples, it's evident that weak equality can result in unexpected
    outcomes. Also, implicit type coercion is costly in terms of performance. So,
    in general, stay away from weak equality in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly discussed that JavaScript is a dynamic language. If you have a previous
    experience of strongly typed languages such as Java, you may feel a bit uncomfortable
    about the complete lack of type checks that you are used to. Purists argue that
    JavaScript should claim to have **tags** or perhaps **subtypes**, but not types.
    Though JavaScript does not have the traditional definition of **types**, it is
    absolutely essential to understand how JavaScript handles data types and coercion
    internally. Every nontrivial JavaScript program will need to handle value coercion
    in some form, so it's important that you understand the concept well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit coercion happens when you modify the type yourself. In the following
    example, you will convert a number to a String using the `toString()` method and
    extract the second character out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of an explicit type conversion. Again, we are using the word
    **type** loosely because type was not enforced anywhere when you declared the
    `fortyTwo` variable.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are many different ways in which such coercion can happen. Coercion
    happening explicitly can be easy to understand and mostly reliable; but if you're
    not careful, coercion can happen in very strange and surprising ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confusion around coercion is perhaps one of the most talked about frustrations
    for JavaScript developers. To make sure that you never have this confusion in
    your mind, let''s revisit types in JavaScript. We talked about some concepts earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. We already knew this and the examples that we just saw reinforce
    our ideas about types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversion of a value from one type to another is called **casting** or explicit
    coercion. JavaScript also does implicit coercion by changing the type of a value
    based on certain guesses. These guesses make JavaScript work around several cases
    and unfortunately make it fail quietly and unexpectedly. The following snippet
    shows cases of explicit and implicit coercion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to see what is happening here. When you use `""+t` to a numeric value
    of `t` (`1`, in this case), JavaScript figures out that you are trying to concatenate
    *something* with a `""` string. As only strings can be concatenated with other
    strings, JavaScript goes ahead and converts a numeric `1` to a `"1"` string and
    concatenates both into a resulting string value. This is what happens when JavaScript
    is asked to convert values implicitly. However, `String(t)` is a very deliberate
    call to convert a number to a String. This is an explicit conversion of types.
    The last bit is surprising. We are concatenating `null` with `""`—shouldn't this
    fail?
  prefs: []
  type: TYPE_NORMAL
- en: So how does JavaScript do type conversions? How will an abstract value become
    a String or number or Boolean? JavaScript relies on `toString()`, `toNumber()`,
    and `toBoolean()` methods to do this internally.
  prefs: []
  type: TYPE_NORMAL
- en: When a non-String value is coerced into a String, JavaScript uses the `toString()`
    method internally to do this. All primitives have a natural string form—null has
    a string form of `"null"`, undefined has a string form of `"undefined"`, and so
    on. For Java developers, this is analogous to a class having a `toString()` method
    that returns a string representation of the class. We will see exactly how this
    works in case of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'So essentially you can do something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When any non-number value needs to be coerced into a number, JavaScript uses
    the `toNumber()` method internally: `true` becomes `1`, `undefined` becomes `NaN`,
    `false` becomes `0`, and `null` becomes `0`. The `toNumber()` method on strings
    works with literal conversion and if this fails, the method returns `NaN`.'
  prefs: []
  type: TYPE_NORMAL
- en: What about some other cases?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, null is an object? Yes, an especially long-lasting bug makes this possible.
    Due to this bug, you need to be careful while testing if a value is null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: What about other things that may have types, such as functions?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: What about arrays?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, they are also objects. We will take a detailed look at functions
    and arrays later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, values have types, variables don't. Due to the dynamic nature
    of the language, variables can hold any value at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript doesn''t does not enforce types, which means that the language doesn''t
    insist that a variable always hold values of the same initial type that it starts
    out with. A variable can hold a String, and in the next assignment, hold a number,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeof` operator always returns a String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Automatic semicolon insertion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although JavaScript is based on the C style syntax, it does not enforce the
    use of semicolons in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: However, JavaScript is not a semicolon-less language. A JavaScript language
    parser needs the semicolons in order to understand the source code. Therefore,
    the JavaScript parser automatically inserts them whenever it encounters a parse
    error due to a missing semicolon. It's important to note that **automatic semicolon
    insertion** (**ASI**) will only take effect in the presence of a newline (also
    known as a line break). Semicolons are not inserted in the middle of a line.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, if the JavaScript parser parses a line where a parser error would
    occur (a missing expected ;) and it can insert one, it does so. What are the criteria
    to insert a semicolon? Only if there's nothing but white space and/or comments
    between the end of some statement and that line's newline/line break.
  prefs: []
  type: TYPE_NORMAL
- en: There have been raging debates on ASI—a feature justifiably considered to be
    a very bad design choice. There have been epic discussions on the Internet, such
    as [https://github.com/twbs/bootstrap/issues/3057](https://github.com/twbs/bootstrap/issues/3057)
    and [https://brendaneich.com/2012/04/the-infernal-semicolon/](https://brendaneich.com/2012/04/the-infernal-semicolon/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you judge the validity of these arguments, you need to understand what
    is affected by ASI. The following statements are affected by ASI:'
  prefs: []
  type: TYPE_NORMAL
- en: An empty statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A var statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A do-while statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A continue statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A break statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A return statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A throw statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The idea behind ASI is to make semicolons optional at the end of a line. This
    way, ASI helps the parser to determine when a statement ends. Normally, it ends
    with a semicolon. ASI dictates that a statement also ends in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: A line terminator (for example, a newline) is followed by an illegal token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closing brace is encountered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end of the file has been reached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `console` token is illegal after `1` and triggers ASI as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the statement inside the braces is not terminated by
    a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'ASI creates a syntactically correct version of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript style guide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every programming language develops its own style and structure. Unfortunately,
    new developers don't put much effort in learning the stylistic nuances of a language.
    It is very difficult to develop this skill later once you have acquired bad practices.
    To produce beautiful, readable, and easily maintainable code, it is important
    to learn the correct style. There are a ton of style suggestions. We will be picking
    the most practical ones. Whenever applicable, we will discuss the appropriate
    style. Let's set some stylistic ground rules.
  prefs: []
  type: TYPE_NORMAL
- en: Whitespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Though whitespace is not important in JavaScript, the correct use of whitespace
    can make the code easy to read. The following guidelines will help in managing
    whitespaces in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Never mix spaces and tabs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you write any code, choose between soft indents (spaces) or real tabs.
    For readability, I always recommend that you set your editor's indent size to
    two characters—this means two spaces or two spaces representing a real tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Always work with the *show invisibles* setting turned on. The benefits of this
    practice are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforced consistency.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminates the end-of-line white spaces.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminates blank line white spaces.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Commits and diffs that are easier to read.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses **EditorConfig** ([http://editorconfig.org/](http://editorconfig.org/))
    when possible.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parentheses, line breaks, and braces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If, else, for, while, and try always have spaces and braces and span multiple
    lines. This style encourages readability. Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Quotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether you prefer single or double quotes shouldn't matter; there is no difference
    in how JavaScript parses them. However, for the sake of consistency, never mix
    quotes in the same project. Pick one style and stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: End of lines and empty lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whitespace can make it impossible to decipher code diffs and changelists. Many
    editors allow you to automatically remove extra empty lines and end of lines—you
    should use these.
  prefs: []
  type: TYPE_NORMAL
- en: Type checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Checking the type of a variable can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Type casting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform type coercion at the beginning of the statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `parseInt()` for Numbers and always with a radix for the type casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows you how to type cast using Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Conditional evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are various stylistic guidelines around conditional statements. Let''s
    study the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Naming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Naming is super important. I am sure that you have encountered code with terse
    and undecipherable naming. Let''s study the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The eval() method is evil
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: I will refrain from showing other uses of `eval()` and make sure that you are
    discouraged enough to stay away from it.
  prefs: []
  type: TYPE_NORMAL
- en: The strict mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ECMAScript 5 has a strict mode that results in cleaner JavaScript, with fewer
    unsafe features, more warnings, and more logical behavior. The normal (non-strict)
    mode is also called **sloppy mode**. The strict mode can help you avoid a few
    sloppy programming practices. If you are starting a new JavaScript project, I
    would highly recommend that you use the strict mode by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'You switch on the strict mode by typing the following line first in your JavaScript
    file or in your `<script>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note that JavaScript engines that don't support ECMAScript 5 will simply ignore
    the preceding statement and continue as non-strict mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to switch on the strict mode per function, you can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This is handy when you are working with a legacy code base where switching on
    the strict mode everywhere may break things.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are working on an existing legacy code, be careful because using the
    strict mode can break things. There are caveats on this:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the strict mode for an existing code can break it
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code may rely on a feature that is not available anymore or on behavior
    that is different in a sloppy mode than in a strict mode. Don't forget that you
    have the option to add single strict mode functions to files that are in the sloppy
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Package with care
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you concatenate and/or minify files, you have to be careful that the strict
    mode isn't switched off where it should be switched on or vice versa. Both can
    break code.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections explain the strict mode features in more detail. You
    normally don't need to know them as you will mostly get warnings for things that
    you shouldn't do anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Variables must be declared in strict mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All variables must be explicitly declared in strict mode. This helps to prevent
    typos. In the sloppy mode, assigning to an undeclared variable creates a global
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In the strict mode, assigning to an undeclared variable throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The eval() function is cleaner in strict mode
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In strict mode, the `eval()` function becomes less quirky: variables declared
    in the evaluated string are not added to the scope surrounding `eval()` anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: Features that are blocked in strict mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The with statement is not allowed. (We will discuss this in the book later.)
    You get a syntax error at compile time (when loading the code).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sloppy mode, an integer with a leading zero is interpreted as octal
    (base 8) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In strict mode, you get a syntax error if you use this kind of literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Running JSHint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JSHint** is a program that flags suspicious usage in programs written in
    JavaScript. The core project consists of a library itself as well as a **command
    line interface** (**CLI**) program distributed as a Node module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have Node.js installed, you can install JSHint using `npm` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the file using JSHint, it will warn us of a missing `break` statement
    in the switch case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: JSHint is configurable to suit your needs. Check the documentation at [http://jshint.com/docs/](http://jshint.com/docs/)
    to see how you can customize JSHint according to your project needs. I use JSHint
    extensively and suggest you start using it. You will be surprised to see how many
    hidden bugs and stylistic issues you will be able to fix in your code with such
    a simple tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run JSHint at the root of your project and lint the entire project.
    You can place JSHint directives in the `.jshintrc` file. This file may look something
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set some foundations around JavaScript grammar, types, and
    stylistic considerations. We have consciously not talked about other important
    aspects such as functions, variable scopes, and closures primarily because they
    deserve their own place in this book. I am sure that this chapter helps you understand
    some of the primary concepts of JavaScript. With these foundations in place, we
    will take a look at how we can write professional quality JavaScript code.
  prefs: []
  type: TYPE_NORMAL
