- en: Chapter 1. JavaScript Primer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 JavaScript 简介
- en: It is always difficult to pen the first few words, especially on a subject like
    JavaScript. This difficulty arises primarily because so many things have been
    said about this language. JavaScript has been the *Language of the Web*—lingua
    franca, if you will, since the earliest days of the Netscape Navigator. JavaScript
    went from a tool of the amateur to the weapon of the connoisseur in a shockingly
    short period of time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写文章的起初几句话总是困难的，尤其是在谈论像JavaScript这样的主题时。这种困难主要源于人们对这门语言已经有了太多的说法。自从Netscape
    Navigator的早期阶段以来，JavaScript就一直是*网络的语言*——如果你愿意，可以说是互联网的通用语。JavaScript从业余爱好者的工具迅速转变为鉴赏家的武器。
- en: JavaScript is the most popular language on the web and open source ecosystem.
    [http://githut.info/](http://githut.info/) charts the number of active repositories
    and overall popularity of the language on GitHub for the last few years. JavaScript's
    popularity and importance can be attributed to its association with the browser.
    Google's V8 and Mozilla's SpiderMonkey are extremely optimized JavaScript engines
    that power Google Chrome and Mozilla Firefox browsers, respectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是网络和开源生态系统中最受欢迎的语言。[http://githut.info/](http://githut.info/) 图表记录了过去几年中GitHub上活跃仓库的数量以及该语言的整体受欢迎程度。JavaScript的流行和重要性可以归因于它与浏览器的关联。Google的V8和Mozilla的SpiderMonkey是分别驱动Google
    Chrome和Mozilla Firefox浏览器的极度优化的JavaScript引擎。
- en: Although web browsers are the most widely used platforms for JavaScript, modern
    databases such as MongoDB and CouchDB use JavaScript as their scripting and query
    language. JavaScript has become an important platform outside browsers as well.
    Projects such as **Node.js** and **io.js** provide powerful platforms to develop
    scalable server environments using JavaScript. Several interesting projects are
    pushing the language capabilities to its limits, for example, **Emscripten** ([http://kripken.github.io/emscripten-site/](http://kripken.github.io/emscripten-site/))
    is a **Low-Level Virtual Machine** (**LLVM**)-based project that compiles C and
    C++ into highly optimizable JavaScript in an **asm.js** format. This allows you
    to run C and C++ on the web at near native speed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管网络浏览器是JavaScript最广泛使用的平台，但现代数据库如MongoDB和CouchDB使用JavaScript作为它们的脚本和查询语言。JavaScript也在浏览器之外成为了重要的平台。例如，**Node.js**
    和 **io.js** 项目提供了强大的平台，用于使用JavaScript开发可扩展的服务器环境。一些有趣的项目正在将语言能力推向极限，例如，**Emscripten**
    ([http://kripken.github.io/emscripten-site/](http://kripken.github.io/emscripten-site/))
    是一个基于**低级虚拟机** (**LLVM**) 的项目，它将C和C++编译成高度优化的JavaScript，格式为**asm.js**。这允许你在网上以接近本地速度运行C和C++。
- en: JavaScript is built around solid foundations regarding, for example, functions,
    dynamic objects, loose typing, prototypal inheritance, and a powerful object literal
    notation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript围绕坚实的基础构建，例如，函数、动态对象、松散类型、原型继承以及强大的对象字面量表示法。
- en: While JavaScript is built on sound design principles, unfortunately, the language
    had to evolve along with the browser. Web browsers are notorious in the way they
    support various features and standards. JavaScript tried to accommodate all the
    whims of the browsers and ended up making some very bad design decisions. These
    bad parts (the term made famous by Douglas Crockford) overshadowed the good parts
    of the language for most people. Programmers wrote bad code, other programmers
    had nightmares trying to debug that bad code, and the language eventually got
    a bad reputation. Unfortunately, JavaScript is one of the most misunderstood programming
    languages ([http://javascript.crockford.com/javascript.html](http://javascript.crockford.com/javascript.html)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JavaScript建立在坚实的设计原则上，但不幸的是，这门语言不得不随着浏览器一起发展。网络浏览器以支持各种特性和标准的方式而闻名。JavaScript试图适应浏览器的所有奇思妙想，结果做出了一些非常糟糕的设计决策。这些糟糕的部分（这个术语由Douglas
    Crockford闻名）使这门语言的优点对大多数人来说都显得黯淡。程序员编写了糟糕的代码，其他程序员试图调试这些糟糕代码时噩梦般地努力，这门语言最终获得了坏名声。不幸的是，JavaScript是最被误解的编程语言之一([http://javascript.crockford.com/javascript.html](http://javascript.crockford.com/javascript.html))。
- en: Another criticism leveled at JavaScript is that it lets you get things done
    without you being an expert in the language. I have seen programmers write exceptionally
    bad JavaScript code just because they wanted to get the things done quickly and
    JavaScript allowed them to do just this. I have spent hours debugging very bad
    quality JavaScript written by someone who clearly was not a programmer. However,
    the language is a tool and cannot be blamed for sloppy programming. Like all crafts,
    programming demands extreme dedication and discipline.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对JavaScript的另一种批评是，它让你在没有成为该语言专家的情况下完成事情。我见过程序员因为想快速完成事情而写出极其糟糕的JavaScript代码，而JavaScript正好允许他们这样做。我花了很多时间调试一个显然不是程序员的人写的非常糟糕的JavaScript。然而，语言是一种工具，不能因为草率的编程而受到责备。像所有工艺一样，编程需要极大的奉献和纪律。
- en: A little bit of history
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一段简短的历史
- en: In 1993, the **Mosaic** browser of **National Center for Supercomputing Applications**
    (**NCSA**) was one of the first popular web browsers. A year later, Netscape Communications
    created the proprietary web browser, **Netscape Navigator**. Several original
    Mosaic authors worked on Navigator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 1993年，**国家超级计算应用中心**（**NCSA**）的**Mosaic**浏览器是第一个流行的网页浏览器之一。一年后，网景通讯公司创建了专有的网页浏览器**Netscape
    Navigator**。几名原始Mosaic作者参与了Navigator的开发。
- en: In 1995, Netscape Communications hired Brendan Eich with the promise of letting
    him implement **Scheme** (a Lisp dialect) in the browser. Before this happened,
    Netscape got in touch with Sun Microsystems (now Oracle) to include Java in the
    Navigator browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，网景通讯公司聘请了布兰登·艾奇，承诺让他实现**Scheme**（一种Lisp方言）在浏览器中。在这一切发生之前，网景与太阳微系统公司（现在称为甲骨文）联系，希望在导航者浏览器中包含Java。
- en: Due to the popularity and easy programming of Java, Netscape decided that a
    scripting language had to have a syntax similar to that of Java. This ruled out
    adopting existing languages such as Python, **Tool Command Language** (**TCL**),
    or Scheme. Eich wrote the initial prototype in just 10 days ([http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf](http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf)),
    in May 1995\. JavaScript's first code name was **Mocha**, coined by Marc Andreessen.
    Netscape later changed it to **LiveScript**, for trademark reasons. In early December
    1995, Sun licensed the trademark Java to Netscape. The language was renamed to
    its final name, JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java的流行和易编程，网景决定脚本语言的语法必须与Java相似。这排除了采用现有的如Python、**工具命令语言**（**TCL**）或Scheme等语言。艾奇仅用10天就编写了最初的原型（[http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf](http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf)），1995年5月。JavaScript的第一个代号是**Mocha**，由马克·安德森提出。网景后来将其改为**LiveScript**，出于商标原因。1995年12月初，太阳公司将Java商标授权给网景。该语言最终被更名为JavaScript。
- en: How to use this book
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用这本书
- en: This book is not going to help if you are looking to get things done quickly.
    This book is going to focus on the correct ways to code in JavaScript. We are
    going to spend a lot of time understanding how to avoid the bad parts of the language
    and build reliable and readable code in JavaScript. We will skirt away from sloppy
    features of the language just to make sure that you are not getting used to them—if
    you have already learned to code using these habits, this book will try to nudge
    you away from this. There will be a lot of focus on the correct style and tools
    to make your code better.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望快速完成事情，这本书不会对你有所帮助。这本书将专注于用JavaScript正确编码的方法。我们将花很多时间了解如何避免该语言的缺点，并在JavaScript中构建可靠且可读的代码。我们将避免该语言的草率特性，以确保你不会习惯它们——如果你已经学会了使用这些习惯来编程，这本书将试图让你改掉这个习惯。我们将重点关注正确的风格和工具，以使你的代码变得更好。
- en: Most of the concepts in this book are going to be examples and patterns from
    real-world problems. I will insist that you code each of the snippets to make
    sure that your understanding of the concept is getting programmed into your muscle
    memory. Trust me on this, there is no better way to learn programming than writing
    a lot of code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数概念都将是来自现实世界问题的例子和模式。我会坚持让你为每个片段编写代码，以确保你对概念的理解被编程到你的肌肉记忆中。相信我，没有比写大量代码更好的学习编程的方法了。
- en: 'Typically, you will need to create an HTML page to run an embedded JavaScript
    code as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要创建一个HTML页面来运行嵌入式JavaScript代码，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This sample code shows two ways in which JavaScript is embedded into the HTML
    page. First, the `<script>` tag in `<head>` imports JavaScript, while the second
    `<script>` tag is used to embed inline JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码展示了JavaScript嵌入HTML页面的两种方式。首先，`<head>`中的`<script>`标签导入了JavaScript，而第二个`<script>`标签则用于嵌入内联JavaScript。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://www.packtpub.com](http://www.packtpub.com)下载你购买的所有Packt Publishing书籍的示例代码文件。如果你在其他地方购买了此书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便让文件直接通过电子邮件发送给你。
- en: 'You can save this HTML page locally and open it in a browser. On Firefox, you
    can open the **Developer** console (Firefox menu | **Developer** | **Web Console**)
    and you can see the **"Hello World"** text on the **Console** tab. Based on your
    OS and browser version, the screen may look different:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个HTML页面保存到本地并在浏览器中打开。在Firefox中，你可以打开**开发者**控制台（Firefox菜单 | **开发者** | **网络控制台**），你可以在**控制台**标签上看到**"Hello
    World"**文本。根据你的操作系统和浏览器版本，屏幕可能看起来会有所不同：
- en: '![How to use this book](img/00002.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用本书](img/00002.jpeg)'
- en: 'You can run the page and inspect it using Chrome''s **Developer Tool**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Chrome的**开发者工具**运行并检查页面：
- en: '![How to use this book](img/00003.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用本书](img/00003.jpeg)'
- en: 'A very interesting thing to notice here is that there is an error displayed
    on the console regarding the missing `.js` file that we are trying to import using
    the following line of code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个非常有趣的事情是，在控制台上显示了一个关于我们尝试使用以下代码行导入的缺失`.js`文件的错误：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using browser developer consoles or an extension such as **Firebug** can be
    very useful in debugging error conditions in the code. We will discuss in detail
    the debugging techniques in later chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器开发者控制台或像**Firebug**这样的扩展在调试代码错误条件时非常有用。我们将在后面的章节中详细讨论调试技术。
- en: Creating such HTML scaffolds can be tedious for every exercise in this book.
    Instead, we want to use a **Read-Eval-Print-Loop** (**REPL**) for JavaScript.
    Unlike Python, JavaScript does not come packaged with an REPL. We can use Node.js
    as an REPL. If you have Node.js installed on your machine, you can just type `node`
    on the command line and start experimenting with it. You will observe that Node
    REPL errors are not very elegantly displayed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样的HTML骨架对本书中的每一个练习来说可能会很繁琐。相反，我们想为JavaScript使用一个**读-评估-打印循环**（**REPL**）。与Python不同，JavaScript没有内置的REPL。我们可以使用Node.js作为REPL。如果你已经在你的电脑上安装了Node.js，你只需在命令行中输入`node`就可以开始与之实验。你会观察到Node
    REPL错误并不是非常优雅地显示。
- en: 'Let''s see the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After this error, you will have to restart. Still, it can help you try out small
    fragments of code a lot faster.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现此错误之后，你必须重新启动。尽管如此，它还是能让你更快地尝试小段代码。
- en: 'Another tool that I personally use a lot is **JS Bin** ([http://jsbin.com/](http://jsbin.com/)).
    JS Bin provides you with a great set of tools to test JavaScript, such as syntax
    highlighting and runtime error detection. The following is a screenshot of JS
    Bin:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人经常使用的一个工具是**JS Bin**([http://jsbin.com/](http://jsbin.com/)). JS Bin为你提供了一套很好的工具来测试JavaScript，比如语法高亮和运行时错误检测。以下是JS
    Bin的屏幕截图：
- en: '![How to use this book](img/00004.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用本书](img/00004.jpeg)'
- en: Based on your preference, you can pick the tool that makes it easier to try
    out the code samples. Regardless of which tool you use, make sure that you type
    out every exercise in this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的喜好，你可以选择一个让你更容易尝试代码示例的工具。无论你使用哪个工具，确保你在这本书中输出了每一个练习。
- en: Hello World
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: No programming language should be published without a customary Hello World
    program—why should this book be any different?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种编程语言应该没有传统的Hello World程序就被发布——这本书为什么应该有任何不同？
- en: 'Type (don''t copy and paste) the following code in JS Bin:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请（不要复制和粘贴）在JS Bin中输入以下代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your screen should look something as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕应该看起来像以下样子：
- en: '![Hello World](img/00005.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Hello World](img/00005.jpeg)'
- en: An overview of JavaScript
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript概览
- en: In a nutshell, JavaScript is a prototype-based scripting language with dynamic
    typing and first-class function support. JavaScript borrows most of its syntax
    from Java, but is also influenced by Awk, Perl, and Python. JavaScript is case-sensitive
    and white space-agnostic.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，JavaScript 是一种基于原型的脚本语言，具有动态类型和一流的函数支持。JavaScript 大部分语法借鉴了 Java，但也受到了 Awk、Perl
    和 Python 的影响。JavaScript 是大小写敏感的，且对空格不敏感。
- en: Comments
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'JavaScript allows single line or multiple line comments. The syntax is similar
    to C or Java:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许单行或多行注释。其语法与 C 或 Java 类似：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Variables
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: Variables are symbolic names for values. The names of variables, or identifiers,
    must follow certain rules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是值的符号名称。变量的名称，或标识符，必须遵循某些规则。
- en: A JavaScript variable name must start with a letter, underscore (_), or dollar
    sign ($); subsequent characters can also be digits (0-9). As JavaScript is case
    sensitive, letters include the characters *A* through *Z* (uppercase) and the
    characters *a* through *z* (lowercase).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 变量名必须以字母、下划线 (_) 或美元符号 ($) 开头；后续字符还可以是数字 (0-9)。由于 JavaScript 是大小写敏感的，所以字母包括
    *A* 至 *Z* （大写）和 *a* 至 *z* （小写）的字符。
- en: You can use ISO 8859-1 or Unicode letters in variable names.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在变量名中使用 ISO 8859-1 或 Unicode 字母。
- en: 'New variables in JavaScript should be defined with the **var** keyword. If
    you declare a variable without assigning a value to it, its type is undefined
    by default. One terrible thing is that if you don''t declare your variable with
    the var keyword, they become implicit globals. Let me reiterate that implicit
    globals are a terrible thing—we will discuss this in detail later in the book
    when we discuss variable scopes and closures, but it''s important to remember
    that you should always declare a variable with the var keyword unless you know
    what you are doing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，新变量应该使用 **var** 关键字定义。如果你声明了一个变量但没有给它赋值，那么它默认的类型是未定义。一个糟糕的事情是，如果你不使用
    var 关键字声明变量，它们会变成隐式的全局变量。让我重申一下，隐式的全局变量是一件糟糕的事情——我们将在书中讨论变量作用域和闭包时详细讨论这个问题，但重要的是要记住，除非你知道你在做什么，否则你应该总是用
    var 关键字声明变量：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `NaN` value is a special value that indicates that the entity is *not a
    number*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NaN值是一个特殊值，用来表示实体*不是数字*。
- en: Constants
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量
- en: 'You can create a read-only named constant with the **const** keyword. The constant
    name must start with a letter, underscore, or dollar sign and can contain alphabetic,
    numeric, or underscore characters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 **const** 关键字创建一个只读的命名常量。常量名必须以字母、下划线或美元符号开头，并可以包含字母、数字或下划线字符：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A constant cannot change the value through assignment or be redeclared, and
    it has to be initialized to a value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 常量不能通过赋值改变其值，也不能重新声明，并且必须初始化为一个值。
- en: 'JavaScript supports the standard variations of types:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 支持标准类型变体：
- en: Number
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Symbol (new in ECMAScript 6)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号（ECMAScript 6 新增）
- en: 'Object:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象：
- en: Function
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Array
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Date
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: RegExp
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'Null'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: Undefined
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: Number
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字
- en: 'The **Number** type can represent both 32-bit integer and 64-bit floating point
    values. For example, the following line of code declares a variable to hold an
    integer value, which is defined by the literal 555:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Number** 类型可以表示 32 位整数和 64 位浮点值。例如，以下代码行声明了一个变量来保存整数值，该值由字面量 555 定义：'
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To define a floating point value, you need to include a decimal point and one
    digit after the decimal point:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个浮点值，你需要包含一个小数点和一个小数点后的一位数字：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Essentially, there's no such thing as an integer in JavaScript. JavaScript uses
    a 64-bit floating point representation, which is the same as Java's double.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，在 JavaScript 中并没有所谓的整数。JavaScript 使用 64 位浮点表示，这与 Java 的 double 相同。
- en: 'Hence, you would see something as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你会看到如下内容：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I recommend that you read the exhaustive answer on Stack Overflow ([http://stackoverflow.com/questions/588004/is-floating-point-math-broken](http://stackoverflow.com/questions/588004/is-floating-point-math-broken))
    and ([http://floating-point-gui.de/](http://floating-point-gui.de/)), which explains
    why this is the case. However, it is important to understand that floating point
    arithmetic should be handled with due care. In most cases, you will not have to
    rely on extreme precision of decimal points but if you have to, you can try using
    libraries such as **big.js** ([https://github.com/MikeMcl/big.js](https://github.com/MikeMcl/big.js))
    that try to solve this problem.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你阅读Stack Overflow上的详尽回答([http://stackoverflow.com/questions/588004/is-floating-point-math-broken](http://stackoverflow.com/questions/588004/is-floating-point-math-broken))和([http://floating-point-gui.de/](http://floating-point-gui.de/))，它解释了为什么会这样。然而，重要的是要理解浮点数运算应该小心处理。在大多数情况下，你可能不需要依赖小数的极端精确度，但如果需要，你可以尝试使用诸如**big.js**([https://github.com/MikeMcl/big.js](https://github.com/MikeMcl/big.js))之类的库来解决这个问题。
- en: If you intend to code extremely precise financial systems, you should represent
    $ values as cents to avoid rounding errors. One of the systems that I worked on
    used to round off the **Value Added Tax** (**VAT**) amount to two decimal points.
    With thousands of orders a day, this rounding off amount per order became a massive
    accounting headache. We needed to overhaul the entire Java web service stack and
    JavaScript frontend for this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算编写极其精确的财务系统，你应该将$值表示为分，以避免舍入错误。我曾经参与过的其中一个系统过去将**增值税**（**VAT**）金额四舍五入到两位小数。每天有成千上万的订单，这个每订单的舍入金额变成了一个巨大的会计难题。我们需要彻底重构整个Java
    Web服务堆栈和JavaScript前端。
- en: A few special values are also defined as part of the Number type. The first
    two are `Number.MAX_VALUE` and `Number.MIN_VALUE`, which define the outer bounds
    of the Number value set. All ECMAScript numbers must fall between these two values,
    without exception. A calculation can, however, result in a number that does not
    fall in between these two numbers. When a calculation results in a number greater
    than `Number.MAX_VALUE`, it is assigned a value of `Number.POSITIVE_INFINITY`,
    meaning that it has no numeric value anymore. Likewise, a calculation that results
    in a number less than `Number.MIN_VALUE` is assigned a value of `Number.NEGATIVE_INFINITY`,
    which also has no numeric value. If a calculation returns an infinite value, the
    result cannot be used in any further calculations. You can use the `isInfinite()`
    method to verify if the calculation result is an infinity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些特殊值也被定义为Number类型的部分。前两个是`Number.MAX_VALUE`和`Number.MIN_VALUE`，它们定义了Number值集的外部界限。所有ECMAScript数字必须在这两个值之间，没有例外。然而，一个计算可能会产生不在这两个值之间的数字。当计算结果大于`Number.MAX_VALUE`时，它被赋予`Number.POSITIVE_INFINITY`的值，意味着它不再有数值。同样，计算结果小于`Number.MIN_VALUE`时，被赋予`Number.NEGATIVE_INFINITY`的值，也没有数值。如果计算返回一个无限值，则结果不能用于任何进一步的计算。你可以使用`isInfinite()`方法来验证计算结果是否为无限值。
- en: 'Another peculiarity of JavaScript is a special value called NaN (short for
    *Not a Number*). In general, this occurs when conversion from another type (String,
    Boolean, and so on) fails. Observe the following peculiarity of NaN:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的另一个特性是一个特殊的值，称为NaN（*Not a Number*的缩写）。通常，这发生在从其他类型（字符串、布尔值等）转换失败时。观察NaN的以下特性：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The second line is strange—NaN is not equal to NaN. If NaN is part of any mathematical
    operation, the result also becomes NaN. As a general rule, stay away from using
    NaN in any expression. For any advanced mathematical operations, you can use the
    `Math` global object and its methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行很奇怪——NaN不等于NaN。如果NaN是任何数学运算的一部分，结果也变成NaN。一般来说，避免在任何表达式中使用NaN。对于任何高级数学运算，你可以使用`Math`全局对象及其方法：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can use the `parseInt()` and `parseFloat()` methods to convert a string
    expression to an integer or float:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`parseInt()`和`parseFloat()`方法将字符串表达式转换为整数或浮点数：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With `parseInt()`, you should provide an explicit base to prevent nasty surprises
    on older browsers. The last trick is just using a `+` sign to auto-convert the
    `"42"` string to a number, `42`. It is also prudent to handle the `parseInt()`
    result with `isNaN()`. Let''s see the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`parseInt()`时，你应该提供一个明确的基数，以防止在旧浏览器上出现糟糕的惊喜。最后一个技巧就是使用`+`号自动将`"42"`字符串转换为数字`42`。谨慎地处理`parseInt()`的结果与`isNaN()`。让我们看看以下示例：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, you are not sure of the type of the value that the `underterminedValue`
    variable can hold if the value is being set from an external interface. If `isNaN()`
    is not handled, `parseInt()` will cause an exception and the program can crash.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你无法确定`underterminedValue`变量如果从外部接口设置值可能持有的类型。如果`isNaN()`没有处理，`parseInt()`将引发异常，程序可能会崩溃。
- en: String
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'In JavaScript, strings are a sequence of Unicode characters (each character
    takes 16 bits). Each character in the string can be accessed by its index. The
    first character index is zero. Strings are enclosed inside `"` or `''`—both are
    valid ways to represent strings. Let''s see the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，字符串是Unicode字符的序列（每个字符占用16位）。字符串中的每个字符可以通过它的索引来访问。第一个字符的索引是零。字符串被`"`或`'`括起来——两者都是表示字符串的有效方式。让我们看以下：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last line shows you how certain character literals when escaped with a
    backslash `\` can be used as special characters. The following is a list of such
    special characters:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行展示了当你用反斜杠`\`转义某些字符字面量时，它们可以作为特殊字符使用。以下是这样一些特殊字符的列表：
- en: '`\n`: Newline'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\n`: 换行'
- en: '`\t`: Tab'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t`: 制表符'
- en: '`\b`: Backspace'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b`: 退格'
- en: '`\r`: Carriage return'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`: 回车'
- en: '`\\`: Backslash'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\`: 反斜杠'
- en: '`\''`: Single quote'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\''`: 单引号'
- en: '`\"`: Double quote'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\"`: 双引号'
- en: 'You get default support for special characters and Unicode literals with JavaScript
    strings:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在JavaScript字符串中获得对特殊字符和Unicode字面量的默认支持：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One important thing about JavaScript Strings, Numbers, and Booleans is that
    they actually have wrapper objects around their primitive equivalent. The following
    example shows the usage of the wrapper objects:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JavaScript字符串、数字和布尔值的一个重要事情是，它们实际上有包装对象围绕它们的原始等价物。以下示例展示了包装对象的使用：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'JavaScript allows multiline strings also. Strings enclosed within `` ` `` (Grave
    accent—[https://en.wikipedia.org/wiki/Grave_accent](https://en.wikipedia.org/wiki/Grave_accent))
    are considered multiline. Let''s see the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript也支持多行字符串。用`` ` ``（重音符号—[https://en.wikipedia.org/wiki/Grave_accent](https://en.wikipedia.org/wiki/Grave_accent)）括起来的字符串被认为是多行。让我们看以下示例：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This kind of string is also known as a template string and can be used for string
    interpolation. JavaScript allows Python-like string interpolation using this syntax.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字符串也被称为模板字符串，可以用于字符串插值。JavaScript允许使用这种语法进行Python式的字符串插值。
- en: 'Normally, you would do something similar to the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会做类似以下的事情：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, with string interpolation, things become a bit clearer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在字符串插值中，事情变得更加清晰：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Undefined values
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未定义值
- en: 'JavaScript indicates an absence of meaningful values by two special values—null,
    when the non-value is deliberate, and undefined, when the value is not assigned
    to the variable yet. Let''s see the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript用两个特殊值来表示没有意义值——null，当非值是故意的，和undefined，当值还没有分配给变量。让我们看以下示例：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Booleans
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'JavaScript Boolean primitives are represented by `true` and `false` keywords.
    The following rules govern what becomes false and what turns out to be true:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript布尔原语由`true`和`false`关键字表示。以下规则决定什么变成假，什么变成真：
- en: False, 0, the empty string (""), NaN, null, and undefined are represented as
    false
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假，0，空字符串（""），NaN，null，和未定义被表示为假
- en: Everything else is true
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他一切都是真
- en: JavaScript Booleans are tricky primarily because the behavior is radically different
    in the way you create them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript布尔值之所以棘手，主要是因为创建它们的方式行为差异很大。
- en: 'There are two ways in which you can create Booleans in JavaScript:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有两种创建布尔值的方法：
- en: 'You can create primitive Booleans by assigning a true or false literal to a
    variable. Consider the following example:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将一个真或假的字面量赋给一个变量来创建原始的布尔值。考虑以下示例：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use the `Boolean()` function; this is an ordinary function that returns a primitive
    Boolean:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Boolean()`函数；这是一个普通函数，返回一个原始的布尔值：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Both these methods return expected *truthy* or *falsy* values. However, if you
    create a Boolean object using the `new` operator, things can go really wrong.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都返回预期的*真值*或*假值*。然而，如果你使用`new`操作符创建一个布尔对象，事情可能会出得很糟糕。
- en: 'Essentially, when you use the `new` operator and the `Boolean(value)` constructor,
    you don''t get a primitive `true` or `false` in return, you get an object instead—and
    unfortunately, JavaScript considers an object as *truthy*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，当你使用`new`操作符和`Boolean(value)`构造函数时，你不会得到一个原始的`true`或`false`，你得到的是一个对象——不幸的是，JavaScript认为一个对象是*真值*：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, the smart thing to do is to always avoid Boolean constructors to create
    a new Boolean object. It breaks the fundamental contract of Boolean logic and
    you should stay away from such difficult-to-debug buggy code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，明智的做法是始终避免使用Boolean构造函数来创建一个新的Boolean对象。这违反了布尔逻辑的基本合同，你应该远离这种难以调试的错误代码。
- en: The instanceof operator
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: instanceof操作符
- en: 'One of the problems with using reference types to store values has been the
    use of the **typeof** operator, which returns `object` no matter what type of
    object is being referenced. To provide a solution, you can use the **instanceof**
    operator. Let''s see some examples:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引用类型存储值的一个问题一直是使用**typeof**操作符，它无论引用的是什么类型的对象，都会返回`object`。为了解决这个问题，你可以使用**instanceof**操作符。让我们看一些例子：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The third line returns `false`. We will discuss why this is the case when we
    discuss prototype chains.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行返回`false`。当我们讨论原型链时，我们将讨论为什么会这样。
- en: Date objects
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Date对象
- en: JavaScript does not have a date data type. Instead, you can use the **Date**
    object and its methods to work with dates and times in your applications. A Date
    object is pretty exhaustive and contains several methods to handle most date-
    and time-related use cases.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有日期数据类型。相反，你可以使用**Date**对象及其方法来处理应用程序中的日期和时间。Date对象相当全面，包含了许多处理大多数与日期和时间相关用例的方法。
- en: JavaScript treats dates similarly to Java. JavaScript store dates as the number
    of milliseconds since January 1, 1970, 00:00:00.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript将日期处理方式与Java相似。JavaScript将日期存储为自1970年1月1日00:00:00以来的毫秒数。
- en: 'You can create a Date object using the following declaration:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下声明创建一个Date对象：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The parameters for the Date object constructors can be as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Date对象构造函数的参数可以是以下形式：
- en: No parameters creates today's date and time. For example, `var today = new Date();`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不带参数创建今天的日期和时间。例如，`var today = new Date();`。
- en: A String representing a date as `Month day, year hours:minutes:seconds`. For
    example, `var twoThousandFifteen = new Date("December 31, 2015 23:59:59");`. If
    you omit hours, minutes, or seconds, the value will be set to `0`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示日期为`Month day, year hours:minutes:seconds`的字符串。例如，`var twoThousandFifteen
    = new Date("December 31, 2015 23:59:59");`。如果你省略小时、分钟或秒，值将被设置为`0`。
- en: A set of integer values for the year, month, and day. For example, `var christmas
    = new Date(2015, 11, 25);`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组表示年份、月份和日期的整数值。例如，`var christmas = new Date(2015, 11, 25);`。
- en: A set of integer values for the year, month, day, hour, minute, and seconds.
    For example, `var christmas = new Date(2015, 11, 25, 21, 00, 0);`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组表示年份、月份、日、时、分和秒的整数值。例如，`var christmas = new Date(2015, 11, 25, 21, 00, 0);`。
- en: 'Here are some examples on how to create and manipulate dates in JavaScript:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于如何在JavaScript中创建和操作日期的示例：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For any serious applications that require fine-grained control over date and
    time objects, we recommend using libraries such as **Moment.js** ([https://github.com/moment/moment](https://github.com/moment/moment)),
    **Timezone.js** ([https://github.com/mde/timezone-js](https://github.com/mde/timezone-js)),
    or **date.js** ([https://github.com/MatthewMueller/date](https://github.com/MatthewMueller/date)).
    These libraries simplify a lot of recurrent tasks for you and help you focus on
    other important things.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何需要对日期和时间对象进行细粒度控制的严肃应用程序，我们推荐使用诸如**Moment.js**([https://github.com/moment/moment](https://github.com/moment/moment)),
    **Timezone.js**([https://github.com/mde/timezone-js](https://github.com/mde/timezone-js)),
    或**date.js**([https://github.com/MatthewMueller/date](https://github.com/MatthewMueller/date)))这样的库。这些库为你简化了很多重复任务，帮助你专注于其他更重要的事情。
- en: The + operator
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: +操作符
- en: 'The **+** operator, when used as a unary, does not have any effect on a number.
    However, when applied to a String, the + operator converts it to numbers as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当**+**操作符作为一元操作符使用时，对一个数字没有任何影响。然而，当应用于字符串时，+操作符将其转换为数字，如下所示：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The + operator is used often by a programmer to quickly convert a numeric representation
    of a String to a number. However, if the String literal is not something that
    can be converted to a number, you get slightly unpredictable results as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常使用+操作符快速将字符串的数值表示转换为数字。然而，如果字符串字面量不能转换为数字，你会得到稍微不可预测的结果，如下所示：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will discuss the effects of the + operator on several other data types later
    in the text.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在文本后面讨论+操作符对其他几种数据类型的影响。
- en: The ++ and -- operators
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ++和--操作符
- en: The ++ operator is a shorthand version of adding `1` to a value and -- is a
    shorthand to subtract `1` from a value. Java and C have equivalent operators and
    most will be familiar with them. How about this?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ++运算符是将值增加1的简写，--运算符是将值减少1的简写。Java和C有等效的运算符，大多数人熟悉它们。这个怎么样？
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Err, what happened here? Shouldn''t the `b` variable have the value `2`? The
    ++ and -- operators are unary operators that can be used either prefix or postfix.
    The order in which they are used matters. When ++ is used in the prefix position
    as `++a`, it increments the value before the value is returned from the expression
    rather than after as with `a++`. Let''s see the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 呃，这里发生了什么？`b`变量不应该有值`2`吗？++和--运算符是可以作为前缀或后缀使用的单目运算符。它们的使用顺序很重要。当++用作前缀形式如`++a`时，它在值从表达式返回之前增加值，而不是像`a++`那样在值返回之后增加。让我们看看以下代码：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Many programmers use the chained assignments to assign a single value to multiple
    variables as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员使用链式赋值来为多个变量分配单个值，如下所示：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is fine because the assignment operator (=) results in the value being
    assigned. In this case, `c=0` is evaluated to `0`; this would result in `b=0`,
    which also evaluates to `0`, and hence, `a=0` is evaluated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，因为赋值运算符(=)导致值被赋值。在这个例子中，`c=0`被评估为`0`；这将导致`b=0`也被评估为`0`，因此，`a=0`也被评估。
- en: 'However, a slight change to the previous example yields extraordinary results.
    Consider this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对前面例子的微小修改将产生非凡的结果。考虑这个：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, only the `a` variable is declared with `var`, while the `b` variable
    is created as an accidental global. (If you are in the strict mode, you will get
    an error for this.) With JavaScript, be careful what you wish for, you might get
    it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只有变量`a`是用`var`声明的，而变量`b`被创建成了一个意外的全局变量。（如果你处于严格模式，这将产生一个错误。）在JavaScript中，小心你所希望的，你可能会得到它。
- en: Boolean operators
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: There are three Boolean operators in JavaScript—AND(&), OR(|), and NOT(!).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有三个布尔运算符——与(&), 或(|), 非(!)。
- en: 'Before we discuss logical AND and OR operators, we need to understand how they
    produce a Boolean result. Logical operators are evaluated from left to right and
    they are tested using the following short-circuit rules:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论逻辑与和或运算符之前，我们需要了解它们是如何产生布尔结果的。逻辑运算符从左到右求值，并且它们是按照以下短路规则进行测试的：
- en: '**Logical AND**: If the first operand determines the result, the second operand
    is not evaluated.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑与**：如果第一个操作数确定了结果，第二个操作数就不会被评估。'
- en: 'In the following example, I have highlighted the right-hand side expression
    if it gets executed as part of short-circuit evaluation rules:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的示例中，我突出了如果它作为短路评估规则的一部分被执行时的右表达式：
- en: '[PRE33]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Logical OR**: If the first operand is true, the second operand is not evaluated:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑或**：如果第一个操作数是真，第二个操作数就不会被评估：'
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, both logical AND and logical OR can also be used for non-Boolean operands.
    When either the left or right operand is not a primitive Boolean value, AND and
    OR do not return Boolean values.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，逻辑与和逻辑或也可以用于非布尔操作数。当左操作数或右操作数不是原始布尔值时，与和或运算符不返回布尔值。
- en: 'Now we will explain the three logical Boolean operators:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将解释三个逻辑布尔运算符：
- en: 'Logical AND(&&): If the first operand object is *falsy*, it returns that object.
    If its *truthy*, the second operand object is returned:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑与(&&)：如果第一个操作数对象是*假值*，它返回那个对象。如果它是*真值*，第二个操作数对象将被返回：
- en: '[PRE35]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Logical OR(||): If the first operand is *truthy*, it''s returned. Otherwise,
    the second operand is returned:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑或(||)：如果第一个操作数是*真值*，它将被返回。否则，第二个操作数将被返回：
- en: '[PRE36]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The typical use of a logical OR is to assign a default value to a variable:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 逻辑或的典型用途是为变量分配默认值：
- en: '[PRE37]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You will see this pattern frequently in most professional JavaScript libraries.
    You should understand how the defaulting is done by using a logical OR operator.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将在大多数专业的JavaScript库中频繁看到这个模式。你应该理解如何使用逻辑或运算符来实现默认值。
- en: '**Logical NOT**: This always returns a Boolean value. The value returned depends
    on the following:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑非**：这总是返回一个布尔值。返回的值取决于以下情况：'
- en: '[PRE38]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Additionally, JavaScript supports C-like ternary operators as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JavaScript支持类似于C的三元运算符，如下所示：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If `(age>21)`, the expression after `?` will be assigned to the `allowedToDrive`
    variable and the expression after `:` is assigned otherwise. This is equivalent
    to an if-else conditional statement. Let''s see another example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`(age>21)`，`?`后面的表达式将被赋值给`allowedToDrive`变量，否则`:`后面的表达式将被赋值。这相当于一个if-else条件语句。让我们看另一个例子：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, the `isAllowedToDrive()` function accepts one integer parameter,
    `age`. Based on the value of this variable, we return true or false to the calling
    function. This is a well-known and most familiar if-else conditional logic. Most
    of the time, if-else keeps the code easier to read. For simpler cases of single
    conditions, using the ternary operator is also okay, but if you see that you are
    using the ternary operator for more complicated expressions, try to stick with
    if-else because it is easier to interpret if-else conditions than a very complex
    ternary expression.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`isAllowedToDrive()`函数接受一个整数参数`age`。根据这个变量的值，我们返回真或假给调用函数。这是一个众所周知且最熟悉的if-else条件逻辑。大多数时候，if-else使代码更容易阅读。对于单一条件的简单情况，使用三元运算符也可以，但如果你看到你正在为更复杂的表达式使用三元运算符，尝试坚持使用if-else，因为解析if-else条件比解析一个非常复杂的三元表达式要容易。
- en: 'If-else conditional statements can be nested as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句可以如下嵌套：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Purely as a matter of taste, you can indent the nested `else if` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹出于审美原因，你可以像下面这样缩进嵌套的`else if`：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Do not use assignments in place of a conditional statement. Most of the time,
    they are used because of a mistake as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在条件语句的地方使用赋值语句。大多数时候，它们被使用是因为下面的错误：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Mostly, this happens by mistake; the intended code was `if(a==b)`, or better,
    `if(a===b)`. When you make this mistake and replace a conditional statement with
    an assignment statement, you end up committing a very difficult-to-find bug. However,
    if you really want to use an assignment statement with an if statement, make sure
    that you make your intentions very clear.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，这是由于错误造成的；意图中的代码是`if(a==b)`，或者更好，`if(a===b)`。当你犯这个错误，并用赋值语句替换条件语句时，你最终会犯一个非常难以发现的错误。然而，如果你真的想在一个if语句中使用赋值语句，请确保你的意图非常明确。
- en: 'One way is to put extra parentheses around your assignment statement:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在你的赋值语句周围加上额外的括号：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Another way to handle conditional execution is to use switch-case statements.
    The switch-case construct in JavaScript is similar to that in C or Java. Let''s
    see the following example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 处理条件执行的另一种方法是使用switch-case语句。JavaScript中的switch-case结构与C或Java中的类似。让我们看以下例子：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'One problem with this structure is that you have `break` out of every case;
    otherwise, the execution will fall through to the next level. If we remove the
    `break` statement from the first case statement, the output will be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构的一个问题是，你有`break`语句在每一个`case`后面；否则，执行将会递归到下一级。如果我们从第一个`case`语句中移除`break`语句，输出将会如下：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, if we omit the `break` statement to break the execution immediately
    after a condition is satisfied, the execution sequence follows to the next level.
    This can lead to difficult-to-detect problems in your code. However, this is also
    a popular style of writing conditional logic if you intend to fall through to
    the next level:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果我们省略`break`语句，在条件满足后立即中断执行，执行顺序会继续递归到下一级。这可能会导致代码中难以检测到的问题。然而，如果你打算一直递归到下一级，这种写条件逻辑的方式也很流行：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, we are intentionally letting the execution fall through to
    write a concise switch-case. If levels are either INFO, WARN, or DEBUG, we use
    the switch-case to fall through to a single point of execution. We omit the `break`
    statement for this. If you want to follow this pattern of writing switch statements,
    make sure that you document your usage for better readability.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们故意让执行递归，以编写简洁的switch-case。如果级别是INFO、WARN或DEBUG，我们使用switch-case递归到单一点执行。我们省略这个`break`语句。如果你想遵循这种写switch语句的模式，请确保你记录你的使用方式，以提高可读性。
- en: Switch statements can have a `default` case to handle any value that cannot
    be evaluated by any other case.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句可以有一个`default`案例，用来处理任何不能被其他案例评估的值。
- en: 'JavaScript has a while and do-while loop. The while loop lets you iterate a
    set of expressions till a condition is met. The following first example iterates
    the statements enclosed within `{}` till the `i<10` expression is true. Remember
    that if the value of the `i` counter is already greater than `10`, the loop will
    not execute at all:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有一个while和do-while循环。while循环让你迭代一系列表达式，直到满足某个条件。以下第一个例子迭代了`{}`内的语句，直到`i<10`表达式为真。记住，如果`i`计数器的值已经大于`10`，循环根本不会执行：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following loop keeps executing till infinity because the condition is always
    true—this can lead to disastrous effects. Your program can use up all your memory
    or something equally unpleasant:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的循环会一直执行到无穷大，因为条件总是为真——这可能导致灾难性的后果。你的程序可能会耗尽你所有的内存，或者更糟糕的事情：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you want to make sure that you execute the loop at least once, you can use
    the do-while loop (sometimes known as a post-condition loop):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保至少执行一次循环，你可以使用do-while循环（有时被称为后置条件循环）：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, we are asking the user for an input till we find a valid input
    from the user. While the user types invalid input, we keep asking for an input
    to the user. It is always argued that, logically, every do-while loop can be transformed
    into a while loop. However, a do-while loop has a very valid use case like the
    one we just saw where you want the condition to be checked only after there has
    been one execution of the loop block.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们要求用户输入，直到我们找到有效的用户输入。当用户输入无效时，我们继续要求用户输入。人们总是认为，从逻辑上讲，每个do-while循环都可以转换为while循环。然而，do-while循环有一个非常有效的用例，就像我们刚才看到的那样，你希望在循环块执行一次之后才检查条件。
- en: JavaScript has a very powerful loop similar to C or Java—the for loop. The for
    loop is popular because it allows you to define the control conditions of the
    loop in a single line.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有一个非常强大的循环，类似于C或Java——for循环。for循环之所以流行，是因为它允许你在一句话中定义循环的控制条件。
- en: 'The following example prints `Hello` five times:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子会打印五次`Hello`：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Within the definition of the loop, you defined the initial value of the loop
    counter `i` to be `0`, you defined the `i<5` exit condition, and finally, you
    defined the increment factor.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的定义中，你定义了循环计数器`i`的初始值为`0`，定义了`i<5`的退出条件，最后定义了增量因子。
- en: 'All three expressions in the previous example are optional. You can omit them
    if required. For example, the following variations are all going to produce the
    same result as the previous loop:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子中的所有三个表达式都是可选的。如果需要，你可以省略它们。例如，下面的变体都将产生与之前循环相同的结果：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can also omit all three of these expressions and write for loops. One interesting
    idiom used frequently is to use for loops with empty statements. The following
    loop is used to set all the elements of the array to `100`. Notice how there is
    no body to the for-loop:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以省略这三个表达式，写for循环。一个经常使用的有趣习惯是用for循环与空语句。下面的循环用于将数组的所有元素设置为`100`。注意循环体内没有主体：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The empty statement here is just the single that we see after the for loop statement.
    The increment factor also modifies the array content. We will discuss arrays later
    in the book, but here it's sufficient to see that the array elements are set to
    the `100` value within the loop definition itself.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的空语句只是我们在for循环语句之后看到的那个单一的语句。增量因子也修改了数组内容。我们将在书的后面讨论数组，但在这里，只要看到循环定义本身将数组元素设置为`100`值就足够了。
- en: Equality
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等价
- en: JavaScript offers two modes of equality—strict and loose. Essentially, loose
    equality will perform the type conversion when comparing two values, while strict
    equality will check the values without any type conversion. A strict equality
    check is performed by === while a loose equality check is performed by ==.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了两种等价模式——严格和宽松。本质上，宽松等价在比较两个值时会执行类型转换，而严格等价则不进行任何类型转换的检查。严格等价检查由===完成，而宽松等价检查由==完成。
- en: 'ECMAScript 6 also offers the `Object.is` method to do a strict equality check
    like ===. However, `Object.is` has a special handling for NaN: -0 and +0\. When
    *NaN===NaN* and *NaN==NaN* evaluates to false, `Object.is(NaN,NaN)` will return
    true.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6还提供了`Object.is`方法来进行与===相同的严格等价检查。然而，`Object.is`对NaN有特殊的处理：-0和+0。当*NaN===NaN*和*NaN==NaN*评估为假时，`Object.is(NaN,NaN)`将返回真。
- en: Strict equality using ===
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 严格等价使用===
- en: 'Strict equality compares two values without any implicit type conversions.
    The following rules apply:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 严格等价比较两个值而不进行任何隐式的类型转换。以下规则适用：
- en: If the values are of a different type, they are unequal.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-numerical values of the same type, they are equal if their values are
    the same.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For primitive numbers, strict equality works for values. If the values are the
    same, === results in `true`. However, a NaN doesn't equal to any number and `NaN===<a
    number>` would be a `false`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strict equality is always the correct equality check to use. Make it a rule
    to always use === instead of ==:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Output |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| `"" === "0"` | false |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| `0 === ""` | false |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| `0 === "0"` | false |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| `false === "false"` | false |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| `false === "0"` | false |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| `false === undefined` | false |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| `false === null` | false |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| `null === undefined` | false |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: 'In case of comparing objects, we get results as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Output |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| `{} === {};` | false |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| `new String(''bah'') === ''bah'';` | false |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| `new Number(1) === 1;` | false |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| `var bar = {};``bar === bar;` | true |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: 'The following are further examples that you should try on either JS Bin or
    Node REPL:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can use `!==` to handle the **Not Equal To** case while doing strict equality
    checks.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Weak equality using ==
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Nothing should tempt you to use this form of equality. Seriously, stay away
    from this form. There are many bad things with this form of equality primarily
    due to the weak typing in JavaScript. The equality operator, ==, first tries to
    coerce the type before doing a comparison. The following examples show you how
    this works:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Output |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| `"" == "0"` | false |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| `0 == ""` | true |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| `0 == "0"` | true |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| `false == "false"` | false |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| `false == "0"` | true |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| `false == undefined` | false |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| `false == null` | false |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| `null == undefined` | true |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: From these examples, it's evident that weak equality can result in unexpected
    outcomes. Also, implicit type coercion is costly in terms of performance. So,
    in general, stay away from weak equality in JavaScript.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript types
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly discussed that JavaScript is a dynamic language. If you have a previous
    experience of strongly typed languages such as Java, you may feel a bit uncomfortable
    about the complete lack of type checks that you are used to. Purists argue that
    JavaScript should claim to have **tags** or perhaps **subtypes**, but not types.
    Though JavaScript does not have the traditional definition of **types**, it is
    absolutely essential to understand how JavaScript handles data types and coercion
    internally. Every nontrivial JavaScript program will need to handle value coercion
    in some form, so it's important that you understand the concept well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit coercion happens when you modify the type yourself. In the following
    example, you will convert a number to a String using the `toString()` method and
    extract the second character out of it:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is an example of an explicit type conversion. Again, we are using the word
    **type** loosely because type was not enforced anywhere when you declared the
    `fortyTwo` variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: However, there are many different ways in which such coercion can happen. Coercion
    happening explicitly can be easy to understand and mostly reliable; but if you're
    not careful, coercion can happen in very strange and surprising ways.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，强制转换发生的许多不同方式。显式强制转换可能容易理解且 mostly 可靠；但如果你不小心，强制转换可能会以非常奇怪和惊讶的方式发生。
- en: 'Confusion around coercion is perhaps one of the most talked about frustrations
    for JavaScript developers. To make sure that you never have this confusion in
    your mind, let''s revisit types in JavaScript. We talked about some concepts earlier:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕强制转换的混淆可能是JavaScript开发者谈论最多的挫折之一。为了确保你心中永远不会有这种混淆，让我们重新回顾一下JavaScript中的类型。我们之前谈过一些概念：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So far, so good. We already knew this and the examples that we just saw reinforce
    our ideas about types.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还不错。我们已经知道了这些，我们刚才看到的一些例子加强了我们对于类型的想法。
- en: 'Conversion of a value from one type to another is called **casting** or explicit
    coercion. JavaScript also does implicit coercion by changing the type of a value
    based on certain guesses. These guesses make JavaScript work around several cases
    and unfortunately make it fail quietly and unexpectedly. The following snippet
    shows cases of explicit and implicit coercion:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个类型转换到另一个类型的值的转换称为**类型转换**或显式强制转换。JavaScript也通过根据某些猜测改变值的类型来进行隐式强制转换。这些猜测使JavaScript在几种情况下发挥作用，不幸的是，它默默地、意外地失败了。以下代码段显示了显式和隐式强制转换的情况：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is easy to see what is happening here. When you use `""+t` to a numeric value
    of `t` (`1`, in this case), JavaScript figures out that you are trying to concatenate
    *something* with a `""` string. As only strings can be concatenated with other
    strings, JavaScript goes ahead and converts a numeric `1` to a `"1"` string and
    concatenates both into a resulting string value. This is what happens when JavaScript
    is asked to convert values implicitly. However, `String(t)` is a very deliberate
    call to convert a number to a String. This is an explicit conversion of types.
    The last bit is surprising. We are concatenating `null` with `""`—shouldn't this
    fail?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出这里发生了什么。当你用`""+t`对数字值`t`（在这个例子中是`1`）进行操作时，JavaScript意识到你试图将*某种东西*与一个`""`字符串连接起来。因为只有字符串才能与其他字符串连接，所以JavaScript前进并把一个数字`1`转换为一个`"1"`字符串，然后将两者连接成一个字符串值。这就是当JavaScript被要求隐式转换值时会发生的事情。然而，`String(t)`是一个明确调用数字转换为字符串的。这是一个类型的显式转换。最后的部分令人惊讶。我们正在将`null`与`""`连接——这不应该失败吗？
- en: So how does JavaScript do type conversions? How will an abstract value become
    a String or number or Boolean? JavaScript relies on `toString()`, `toNumber()`,
    and `toBoolean()` methods to do this internally.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 那么JavaScript是如何进行类型转换的呢？一个抽象值如何变成字符串或数字或布尔值？JavaScript依赖于`toString()`、`toNumber()`和`toBoolean()`方法来进行这些内部转换。
- en: When a non-String value is coerced into a String, JavaScript uses the `toString()`
    method internally to do this. All primitives have a natural string form—null has
    a string form of `"null"`, undefined has a string form of `"undefined"`, and so
    on. For Java developers, this is analogous to a class having a `toString()` method
    that returns a string representation of the class. We will see exactly how this
    works in case of objects.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个非字符串值被强制转换为字符串时，JavaScript内部使用`toString()`方法来完成这个转换。所有原始值都有自然的字符串形式——`null`的自然字符串形式是`"null"`，`undefined`的自然字符串形式是`"undefined"`，依此类推。对于Java开发者来说，这类似于一个类有一个`toString()`方法，返回该类的字符串表示。我们将看到对象的情况是如何工作的。
- en: 'So essentially you can do something similar to the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所以本质上，你可以做类似以下的事情：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When any non-number value needs to be coerced into a number, JavaScript uses
    the `toNumber()` method internally: `true` becomes `1`, `undefined` becomes `NaN`,
    `false` becomes `0`, and `null` becomes `0`. The `toNumber()` method on strings
    works with literal conversion and if this fails, the method returns `NaN`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何非数字值需要被转换为数字时，JavaScript内部使用`toNumber()`方法：`true`变成`1`，`undefined`变成`NaN`，`false`变成`0`，`null`变成`0`。字符串上的`toNumber()`方法与字面转换一起工作，如果这个失败了，方法返回`NaN`。
- en: What about some other cases?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些情况呢？
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Well, null is an object? Yes, an especially long-lasting bug makes this possible.
    Due to this bug, you need to be careful while testing if a value is null:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`null`是一个对象？是的，一个特别持久的错误使得这成为可能。由于这个错误，你在测试一个值是否为`null`时需要小心：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: What about other things that may have types, such as functions?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 那么可能还有其他具有类型的东西，比如函数呢？
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: What about arrays?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 那么数组呢？
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Sure enough, they are also objects. We will take a detailed look at functions
    and arrays later in the book.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此，它们也是对象。我们将在书的后面详细介绍函数和数组。
- en: In JavaScript, values have types, variables don't. Due to the dynamic nature
    of the language, variables can hold any value at any time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，值有类型，变量没有。由于语言的动态特性，变量可以随时持有任何值。
- en: 'JavaScript doesn''t does not enforce types, which means that the language doesn''t
    insist that a variable always hold values of the same initial type that it starts
    out with. A variable can hold a String, and in the next assignment, hold a number,
    and so on:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不强制类型，这意味着该语言不坚持变量始终持有与初始类型相同的值。变量可以持有字符串，然后在下一个赋值中持有数字，依此类推：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `typeof` operator always returns a String:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: typeof操作符总是返回一个字符串：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Automatic semicolon insertion
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动分号插入
- en: Although JavaScript is based on the C style syntax, it does not enforce the
    use of semicolons in the source code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript基于C风格语法，但它不强制在源代码中使用分号。
- en: However, JavaScript is not a semicolon-less language. A JavaScript language
    parser needs the semicolons in order to understand the source code. Therefore,
    the JavaScript parser automatically inserts them whenever it encounters a parse
    error due to a missing semicolon. It's important to note that **automatic semicolon
    insertion** (**ASI**) will only take effect in the presence of a newline (also
    known as a line break). Semicolons are not inserted in the middle of a line.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript并不是一个无分号的语言。JavaScript语言解析器需要分号来理解源代码。因此，当解析器遇到由于缺少分号而导致的解析错误时，它会自动插入分号。需要注意的是，**自动分号插入**（**ASI**）只有在存在换行符（也称为行break）时才会生效。分号不会在一行中间插入。
- en: Basically, if the JavaScript parser parses a line where a parser error would
    occur (a missing expected ;) and it can insert one, it does so. What are the criteria
    to insert a semicolon? Only if there's nothing but white space and/or comments
    between the end of some statement and that line's newline/line break.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果JavaScript解析器解析一行，在该行中会发生解析错误（缺少预期的分号）并且它可以插入一个，它会这样做。插入分号的条件是什么？只有当某些语句的末尾和该行的换行符/行break之间只有空白字符和/或注释时。
- en: There have been raging debates on ASI—a feature justifiably considered to be
    a very bad design choice. There have been epic discussions on the Internet, such
    as [https://github.com/twbs/bootstrap/issues/3057](https://github.com/twbs/bootstrap/issues/3057)
    and [https://brendaneich.com/2012/04/the-infernal-semicolon/](https://brendaneich.com/2012/04/the-infernal-semicolon/).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ASI一直有激烈的争论——一个合理地被认为是设计选择非常糟糕的功能。网络上进行了史诗般的讨论，例如[https://github.com/twbs/bootstrap/issues/3057](https://github.com/twbs/bootstrap/issues/3057)和[https://brendaneich.com/2012/04/the-infernal-semicolon/](https://brendaneich.com/2012/04/the-infernal-semicolon/)。
- en: 'Before you judge the validity of these arguments, you need to understand what
    is affected by ASI. The following statements are affected by ASI:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在判断这些论点的有效性之前，你需要了解ASI影响了什么。以下受ASI影响的声明：
- en: An empty statement
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空声明
- en: A var statement
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个var声明
- en: An expression statement
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表达式声明
- en: A do-while statement
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个do-while声明
- en: A continue statement
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个continue声明
- en: A break statement
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个break声明
- en: A return statement
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个return声明
- en: A throw statement
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个throw声明
- en: 'The idea behind ASI is to make semicolons optional at the end of a line. This
    way, ASI helps the parser to determine when a statement ends. Normally, it ends
    with a semicolon. ASI dictates that a statement also ends in the following cases:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ASI背后的想法是使分号在行的末尾成为可选。这样，ASI帮助解析器确定语句何时结束。通常，它在分号处结束。ASI规定，在以下情况下语句也以如下情况结束：
- en: A line terminator (for example, a newline) is followed by an illegal token
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 换行符（例如，换行符）后面跟着一个非法令牌
- en: A closing brace is encountered
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到一个闭合括号
- en: The end of the file has been reached
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件已达到末尾
- en: 'Let''s see the following example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE66]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `console` token is illegal after `1` and triggers ASI as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在1之后console令牌是非法的，并按照以下方式触发ASI：
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the following code, the statement inside the braces is not terminated by
    a semicolon:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，大括号内的语句没有用分号终止：
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'ASI creates a syntactically correct version of the preceding code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ASI为前面的代码创建了一个语法上正确的版本：
- en: '[PRE69]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: JavaScript style guide
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript风格指南
- en: Every programming language develops its own style and structure. Unfortunately,
    new developers don't put much effort in learning the stylistic nuances of a language.
    It is very difficult to develop this skill later once you have acquired bad practices.
    To produce beautiful, readable, and easily maintainable code, it is important
    to learn the correct style. There are a ton of style suggestions. We will be picking
    the most practical ones. Whenever applicable, we will discuss the appropriate
    style. Let's set some stylistic ground rules.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都会发展出自己的风格和结构。不幸的是，新开发者并没有付出太多努力去学习一门语言的风格细微差别。一旦养成了坏习惯，后来要发展这项技能就非常困难了。为了生成美观、可读且易于维护的代码，学习正确的风格是非常重要的。有很多样式建议。我们将选择最实用的那些。在适用的情况下，我们将讨论合适的样式。让我们设定一些风格基础规则。
- en: Whitespaces
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空白符
- en: 'Though whitespace is not important in JavaScript, the correct use of whitespace
    can make the code easy to read. The following guidelines will help in managing
    whitespaces in your code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然空白符在JavaScript中并不重要，但正确使用空白符可以使代码更易读。以下指南将帮助你在代码中管理空白符：
- en: Never mix spaces and tabs.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要混合空格和制表符。
- en: Before you write any code, choose between soft indents (spaces) or real tabs.
    For readability, I always recommend that you set your editor's indent size to
    two characters—this means two spaces or two spaces representing a real tab.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你编写任何代码之前，选择使用软缩进（空格）或真正的制表符。为了提高可读性，我总是建议你将编辑器的缩进大小设置为两个字符——这意味着两个空格或两个空格表示一个真正的制表符。
- en: 'Always work with the *show invisibles* setting turned on. The benefits of this
    practice are as follows:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终开启*显示不可见字符*设置。这种做法的好处如下：
- en: Enforced consistency.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制一致性。
- en: Eliminates the end-of-line white spaces.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除行尾的空白符。
- en: Eliminates blank line white spaces.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除行尾的空白符。
- en: Commits and diffs that are easier to read.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交和差异更容易阅读。
- en: Uses **EditorConfig** ([http://editorconfig.org/](http://editorconfig.org/))
    when possible.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下使用**EditorConfig** ([http://editorconfig.org/](http://editorconfig.org/))。
- en: Parentheses, line breaks, and braces
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 括号、换行符和括号
- en: 'If, else, for, while, and try always have spaces and braces and span multiple
    lines. This style encourages readability. Let''s see the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果、否则、for、while 和 try 总是有空格和括号，并且跨越多行。这种风格有助于提高可读性。让我们看看以下的代码：
- en: '[PRE70]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Quotes
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引号
- en: Whether you prefer single or double quotes shouldn't matter; there is no difference
    in how JavaScript parses them. However, for the sake of consistency, never mix
    quotes in the same project. Pick one style and stick with it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你更喜欢单引号还是双引号，都不应该有区别；JavaScript解析它们的方式没有区别。然而，为了保持一致性，同一个项目中不要混合引号。选择一种风格并坚持使用。
- en: End of lines and empty lines
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行尾和空行
- en: Whitespace can make it impossible to decipher code diffs and changelists. Many
    editors allow you to automatically remove extra empty lines and end of lines—you
    should use these.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 空白符可能会使代码差异和更改列表无法辨认。许多编辑器允许你自动删除额外的空行和行尾空格——你应该使用这些功能。
- en: Type checking
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型检查
- en: 'Checking the type of a variable can be done as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个变量的类型可以按照如下方式进行：
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Type casting
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'Perform type coercion at the beginning of the statement as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如下在语句开头执行类型强制：
- en: '[PRE72]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Use `parseInt()` for Numbers and always with a radix for the type casting:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对数字使用`parseInt()`，并且总是需要一个基数来进行类型转换：
- en: '[PRE73]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The following example shows you how to type cast using Booleans:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例向你展示了如何使用布尔值进行类型转换：
- en: '[PRE74]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Conditional evaluation
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件评估
- en: 'There are various stylistic guidelines around conditional statements. Let''s
    study the following code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有关条件语句的样式指南有很多。让我们研究一下以下的代码：
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Naming
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名
- en: 'Naming is super important. I am sure that you have encountered code with terse
    and undecipherable naming. Let''s study the following lines of code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 命名非常重要。我敢肯定你遇到过命名简短且难以辨认的代码。让我们研究一下以下代码行：
- en: '[PRE76]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The eval() method is evil
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eval()方法是邪恶的
- en: '[PRE77]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: I will refrain from showing other uses of `eval()` and make sure that you are
    discouraged enough to stay away from it.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我将避免展示`eval()`的其他用途，并确保你被劝阻得足够，从而远离它。
- en: The strict mode
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格模式
- en: ECMAScript 5 has a strict mode that results in cleaner JavaScript, with fewer
    unsafe features, more warnings, and more logical behavior. The normal (non-strict)
    mode is also called **sloppy mode**. The strict mode can help you avoid a few
    sloppy programming practices. If you are starting a new JavaScript project, I
    would highly recommend that you use the strict mode by default.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5有一个严格模式，结果是更干净的JavaScript，具有更少的危险功能、更多的警告和更逻辑的行为。正常（非严格）模式也称为**松散模式**。严格模式可以帮助你避免一些松散编程实践。如果你正在启动一个新的JavaScript项目，我强烈建议你默认使用严格模式。
- en: 'You switch on the strict mode by typing the following line first in your JavaScript
    file or in your `<script>` element:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要开启严格模式，你需要在你的JavaScript文件或你的`<script>`元素中首先输入以下行：
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that JavaScript engines that don't support ECMAScript 5 will simply ignore
    the preceding statement and continue as non-strict mode.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不支持ECMAScript 5的JavaScript引擎将简单地忽略前述语句，并以非严格模式继续执行。
- en: 'If you want to switch on the strict mode per function, you can do it as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为每个函数开启严格模式，你可以这样做：
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is handy when you are working with a legacy code base where switching on
    the strict mode everywhere may break things.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与遗留代码库合作时，这很方便，因为在大范围内开启严格模式可能会破坏事物。
- en: 'If you are working on an existing legacy code, be careful because using the
    strict mode can break things. There are caveats on this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理现有的遗留代码，要小心，因为使用严格模式可能会破坏事物。这一点有告诫：
- en: Enabling the strict mode for an existing code can break it
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为现有代码启用严格模式可能会破坏它
- en: The code may rely on a feature that is not available anymore or on behavior
    that is different in a sloppy mode than in a strict mode. Don't forget that you
    have the option to add single strict mode functions to files that are in the sloppy
    mode.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能依赖于不再可用的功能或与松散模式和严格模式不同的行为。不要忘记你有选项可以向处于松散模式的文件中添加单个严格模式函数。
- en: Package with care
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 小心地封装
- en: When you concatenate and/or minify files, you have to be careful that the strict
    mode isn't switched off where it should be switched on or vice versa. Both can
    break code.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当你连接和/或压缩文件时，你必须小心，确保严格模式在应该开启的地方没有关闭或相反。两者都可能破坏代码。
- en: The following sections explain the strict mode features in more detail. You
    normally don't need to know them as you will mostly get warnings for things that
    you shouldn't do anyway.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分详细解释了严格模式的功能。你通常不需要了解它们，因为你大部分时候会因为不应该做的事情而收到警告。
- en: Variables must be declared in strict mode
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在严格模式下，变量必须声明
- en: 'All variables must be explicitly declared in strict mode. This helps to prevent
    typos. In the sloppy mode, assigning to an undeclared variable creates a global
    variable:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，所有变量都必须显式声明。这有助于防止打字错误。在松散模式下，对未声明变量的赋值将创建一个全局变量：
- en: '[PRE81]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the strict mode, assigning to an undeclared variable throws an exception:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，对未声明变量的赋值会抛出异常：
- en: '[PRE82]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The eval() function is cleaner in strict mode
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在严格模式下，`eval()`函数更简洁
- en: 'In strict mode, the `eval()` function becomes less quirky: variables declared
    in the evaluated string are not added to the scope surrounding `eval()` anymore.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，`eval()`函数变得不那么怪异：在评估的字符串中声明的变量不再添加到围绕`eval()`的作用域中。
- en: Features that are blocked in strict mode
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在严格模式下被阻止的功能
- en: The with statement is not allowed. (We will discuss this in the book later.)
    You get a syntax error at compile time (when loading the code).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许使用with语句。（我们将在书中稍后讨论这个问题。）在编译时间（加载代码时）你会得到一个语法错误。
- en: 'In the sloppy mode, an integer with a leading zero is interpreted as octal
    (base 8) as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散模式下，带前导零的整数被解释为八进制（基数8）如下：
- en: '[PRE83]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In strict mode, you get a syntax error if you use this kind of literal:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，如果你使用这种字面量，你会得到一个语法错误：
- en: '[PRE84]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Running JSHint
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行JSHint
- en: '**JSHint** is a program that flags suspicious usage in programs written in
    JavaScript. The core project consists of a library itself as well as a **command
    line interface** (**CLI**) program distributed as a Node module.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSHint** 是一个程序，用于标记使用JavaScript编写的程序中的可疑用法。该项目核心包括本身作为一个库以及作为Node模块分发的**命令行界面**（**CLI**）程序。'
- en: 'If you have Node.js installed, you can install JSHint using `npm` as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了Node.js，你可以使用`npm`如下安装JSHint：
- en: '[PRE85]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'When we run the file using JSHint, it will warn us of a missing `break` statement
    in the switch case as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用JSHint运行文件时，它将警告我们在switch case中缺少`break`语句，如下所示：
- en: '[PRE88]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: JSHint is configurable to suit your needs. Check the documentation at [http://jshint.com/docs/](http://jshint.com/docs/)
    to see how you can customize JSHint according to your project needs. I use JSHint
    extensively and suggest you start using it. You will be surprised to see how many
    hidden bugs and stylistic issues you will be able to fix in your code with such
    a simple tool.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: JSHint可以根据您的需求进行配置。查看[http://jshint.com/docs/](http://jshint.com/docs/)的文档，了解如何根据您的项目需求自定义JSHint。我广泛使用JSHint，并建议您开始使用它。您会惊讶地发现，使用这样一个简单的工具，您能够在代码中修正多少隐藏的错误和风格问题。
- en: 'You can run JSHint at the root of your project and lint the entire project.
    You can place JSHint directives in the `.jshintrc` file. This file may look something
    as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目的根目录下运行JSHint，并对整个项目进行lint检查。您可以在`.jshintrc`文件中放置JSHint指令。这个文件可能如下所示：
- en: '[PRE89]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Summary
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we set some foundations around JavaScript grammar, types, and
    stylistic considerations. We have consciously not talked about other important
    aspects such as functions, variable scopes, and closures primarily because they
    deserve their own place in this book. I am sure that this chapter helps you understand
    some of the primary concepts of JavaScript. With these foundations in place, we
    will take a look at how we can write professional quality JavaScript code.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们围绕JavaScript语法、类型和风格考虑方面设定了一些基础。我们故意没有讨论其他重要方面，如函数、变量作用域和闭包，主要是因为它们应该在这本书中有自己的独立章节。我相信这一章节帮助你理解了JavaScript的一些基本概念。有了这些基础，我们将看看如何编写专业质量的JavaScript代码。
