["```js\n// Wildcards are used to match against parameters in URIs...\nconsole.log('second', (/^user\\/(.*)/i).exec('user/123'));\n//    [ 'user/123', '123' ]\n\n// Matches against the same URI, only more restrictively...\nconsole.log('third', (/^user\\/(\\d+)/i).exec('user/123'));\n//    [ 'user/123', '123' ]\n\n// Doesn't match, looking for characters and we got numbers...\nconsole.log('fourth', (/^user\\/([a-z])/i).test('user/123'));\n//    false\n\n// Matches, we got a range of characters...\nconsole.log('fifth', (/^user\\/([a-z]+)/i).exec('user/abc'));\n//    [ 'user/abc', 'abc' ]\n```", "```js\n// router.js\nimport events from 'events.js';\n\n// The router is also an event broker...\nexport default class Router {\n\n    constructor() {\n        this.routes = [];\n    }\n\n    // Adds a given \"pattern\" and triggers event \"name\"\n    // when activated.\n    add(pattern, name) {\n        this.routes.push({\n            pattern: new RegExp('^' +\n                pattern.replace(/:\\w+/g, '(.*)')),\n            name: name\n        });\n    }\n\n    // Adds any configured routes, and starts listening\n    // for navigation events.\n    start() {\n        var onHashChange = () => {\n            for (let route of this.routes) {\n                let result = route.pattern.exec(\n                    location.hash.substr(1));\n                if (result) {\n                    events.trigger('route:' + route.name, {\n                        values: result.splice(1)\n                    });\n                    break;\n                }\n            }\n        };\n\n        window.addEventListener('hashchange', onHashChange);\n        onHashChange();\n    }\n\n}\n\n// model.js\nexport default class Model {\n\n    constructor(pattern, id) {\n        this.pattern = pattern;\n        this.id = id;\n    }\n\n    // Generates the URI string for this model. The pattern is\n    // passed in as a constructor argument. This means that code\n    // that needs to generate URI strings, like DOM manipulation\n    // code, can just ask the model for the URI.\n    get uri() {\n        return '#' + this.pattern.replace(/:\\w+/, this.id);\n    }\n\n}\n\n// user.js\nimport Model from 'model.js';\n\nexport default class User extends Model {\n\n    // The URI pattern for instances of this model is\n    // encapsulated in this static method.\n    static pattern() {\n        return 'user/:id';\n    }\n\n    constructor(id) {\n        super(User.pattern(), id);\n    }\n\n}\n\n// group.js\nimport Model from 'model.js';\n\nexport default class Group extends Model {\n\n    // The \"pattern()\" method is static because\n    // all instances of \"Group\" models will use the\n    // same route pattern.\n    static pattern() {\n        return 'group/:id';\n    }\n\n    constructor(id) {\n        super(Group.pattern(), id);\n    }\n\n}\n\n// main.js\nimport Router from 'router.js';\nimport events from 'events.js';\nimport User from 'user.js';\nimport Group from 'group.js';\n\nvar router = new Router()\n\n// Add routes using the \"pattern()\" static method. There's\n// no need to hard-code any routes here.\nrouter.add(User.pattern(), 'user');\nrouter.add(Group.pattern(), 'group');\n\n// Setup functions that respond to routes...\nevents.listen('route:user', (data) => {\n    console.log(`User ${data.values[0]} activated`);\n});\n\nevents.listen('route:group', (data) => {\n    console.log(`Group ${data.values[0]} activated`);\n});\n\n// Construct new models, and user their \"uri\" property\n// in the DOM. Again, nothing related to routing patterns\n// need to be hard-coded here.\nvar user = new User(1);\ndocument.querySelector('.user').href = user.uri;\n\nvar group = new Group(1);\ndocument.querySelector('.group').href = group.uri;\n\nrouter.start();\n```", "```js\n// router.js\nimport events from 'events.js';\n\n// The router triggers events in response to\n// route changes.\nexport default class Router {\n\n    constructor() {\n        this.routes = [];\n    }\n\n    // Adds a new route, with an optional\n    // guard function.\n    add(pattern, name, guard) {\n        this.routes.push({\n            pattern: new RegExp('^' +\n                pattern.replace(/:\\w+/g, '(.*)')),\n            name: name,\n            guard: guard\n        });\n    }\n\n    start() {\n        var onHashChange = () => {\n            for (let route of this.routes) {\n                let guard = route.guard;\n                let result = route.pattern.exec(\n                    location.hash.substr(1));\n\n                // If a match is found, and there's a guard\n                // condition, evaluate it. The event is only\n                // triggered if this passes.\n                if (result) {\n                    if (typeof guard === 'function' && guard()) {\n                        events.trigger('route:' + route.name, {\n                            values: result.splice(1)\n                        });\n                    }\n                    break;\n                }\n            }\n        };\n\n        window.addEventListener('hashchange', onHashChange);\n        onHashChange();\n    }\n\n}\n\n// main.js\nimport Router from 'router.js';\nimport events from 'events.js';\n\nvar router = new Router()\n\n// Function that can be used as a guard condition\n// with any route we declare. It's returning a random\n// value to demonstrate the various outcomes, but this\n// could be anything that we want applied to all our routes.\nfunction isAuthorized() {\n    return !!Math.round(Math.random());\n}\n\n// The first route doesn't have a guard condition,\n// and will always trigger a route event. The second\n// route will only trigger a route event if the given\n// callback function returns true.\nrouter.add('open', 'open');\nrouter.add('guarded', 'guarded', isAuthorized);\n\nevents.listen('route:open', () => {\n    console.log('open route is always accessible');\n});\n\nevents.listen('route:guarded', (data) => {\n    console.log('made it past the guard function!');\n});\n\nrouter.start();\n```", "```js\n// Finds the first matching route in \"routes\" - tested\n// against \"uri\".\nfunction match() {\n    for (let route of routes) {\n        if (route.route.test(uri)) {\n            console.log('match', route.name);\n            break;\n        }\n    }\n}\n\nvar uri = 'users/abc';\n\nvar routes = [\n    { route: /^users/, name: 'users' },\n    { route: /^users\\/(\\w+)/, name: 'user' }\n];\n\nmatch();\n//    match users\n// Note that this probably isn't expected behavior\n// if we look closely at the \"uri\". This illustrates\n// the importance of order, when testing against a\n// collection of URIs specs.\n\nroutes.reverse();\n\nmatch();\n//    match user\n```"]