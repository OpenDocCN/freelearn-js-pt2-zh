- en: Chapter 4. Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've gotten just a taste of templates so far, and are now ready to dive in,
    creating a working application using the MVVM design pattern. This chapter will
    take us through the template system in depth, and show us how to implement display
    logic, add design considerations to a model (create the View-Model), and take
    care of data flow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will complete the following tasks:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Completing the Lending Library core functionality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple templates and template logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding, deleting, and updating entries in the data model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing reactivity in action and using it in your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new HTML template
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already created our categories through the use of the `categories` template.
    Now, we want to take this to the next level and display the actual items that
    we may want to let people (except STEVE!) borrow. So when we click on a category
    we should get a **list** of **items**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use that terminology. We need a place to display a `list`. So, let''s
    modify our`~/Documents/Meteor/LendLib/LendLib.html` code just a bit at the top:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We did two things by adding this code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped the `div` element with `id="categories-container"` inside of the
    `div` called `lendlib`. This is for stylistic purposes, so that our `list` will
    more or less line up with the `categories` template.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We added a `div` with `id="list"` just below it, and added a call to a new
    template: `{{> list}}.` This is our template/placeholder for the `list` of `items`,
    which we''ll see shortly in the sections that follow.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And there you have it. We've created a very easy-to-maintain structure, with
    definite boundaries in the document. We know where our `categories` are going
    to go, and we know where our `list` of `items` is going to go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see about the list template itself. Not so simple, but still not
    bad. At the very end of `LendLib.html`, below the closing `</template>` tag for
    our `categories` template, place the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s go through this step by step, so we understand what each line does:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we declare the HTML `<template>` with the name `"list"`, to match the call
    to the list template we made in the body. We create an unordered list `<ul>` and
    give it an `id` so we can refer to it later if need be.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Then we start a templated `each` statement. This time, we're going to iterate
    through `items`. We haven't created the Meteor `items` template just yet, but
    we'll get there soon enough.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, under the `each` statement, we create an `<li>` element and give it two
    class names. The `lending_item` class name is added so that we can refer to it
    in our View-Model (Meteor template code). The `alert` class name is for Bootstrap,
    so it will display all nice and pretty.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `button` that we can use, should we choose to delete the item.
    Notice, that we give it an ID `id="{{Name}}"`. This will be read from the `items`
    View-Model, and will make our jobs much easier in the future, should we want to
    delete the `item` from our `items` collection. There are also two class names
    on this one. `close` is added for Bootstrap, and `delete_item` is added so that
    we can refer to it in the View-Model when the time comes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Now, just below that we have another template placeholder for `{{Name}}`. This
    is so that we can use the title of the item (for example on a DVD item the title
    could be "Mission Impossible") inside our display element. We'll see this in action
    very soon.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we begin a series of conditional statements. The first conditional statement
    has to do with when we want to edit who is borrowing our item, or the **lendee**:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are first using an `if` statement to see if our *current mode* for this `item`
    is `lendee_editing`. That is to say, if we wanted to edit the lendee, we would
    be in "lendee editing" mode, and therefore (in our JavaScript file) `Template.list.lendee_editing`
    would return `true`. If this is the case, we need a textbox, hence the inclusion
    of the `<input>` element, with its associated `id`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Alternately—and this is the default—we just want to display who the lendee is,
    if there is one. If there isn't, we'll want to maybe change the color or something,
    but we still want it displayed. So, we create a Bootstrap-styled `label` in the
    form of a `<div>` element.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the class declarations, we see a template variable: `...{{LendClass}}"`.
    This class addition is stylistic. It will tell our CSS template whether to show
    it as "free" (someone can borrow it) or as "lent out." If it''s green, it''s free,
    if it''s red, someone has borrowed it. And what CSS class name is used to represent
    the color will be determined in `LendLib.js`, by the `item.LendClass` property,
    which we will create shortly.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the value inside the div: `{{Lendee}}` . This is also a property
    in `LendLib.js`, as the `item.Lendee` property, and it will either display the
    name of the lendee, or "free" if no one has borrowed it.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We then have the ending `</li>` tag, and our `each` comes to an end with `{{/each}}`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have our second `if` statement, and this one is actually a nested `if`.
    This one is outside of the `each` statement, so it''s not specific to items. This
    `if` statement displays either a light-green bar with a **+** sign, or a textbox
    in the form of an `<input>` element, so that we can add items to our list:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So we see our first `if`, which is conditioned on whether we're even displaying
    any list items. If we are, that means we have a list selected. Or rather, we are
    in the `list_selected` mode. Keeping track of this is part of the View-Model's
    job, so `Template.list.list_selected` is found inside `LendLib.js`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: We then create an `<li>` element, style it green with the Bootstrap `alert-success`
    class, and add the `&plus;` sign.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Next is our nested (second) `if`. This one is checking to see if we are adding
    to the list of items. If we are, we are in `list_adding` mode, so we'll display
    a textbox in the form of an `<input>` element. If not, we'll just leave the pretty
    light-green box with just the **+** sign in it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we end our nested `if`, our `</li>`, our parent `if`, our `</ul>`,
    and our `</template>`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Gluing it all together
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The View-Model (MVVM) or controller (MVC) or presenter (MVP) is considered the
    glue of an MV* application model. That's because it "glues" together all the view
    items, such as buttons or textboxes, to the model.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Pretty fancy explanation, eh? Well, you try to come up with a better explanation
    for what it does. It really does fill in the cracks, and keep the model and the
    view together. Someone else invented the term, not us, so let's continue without
    the Judgy McJudgerson viewpoint, mmmk?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll go through all the changes step-by-step that need to
    happen inside of `~/Documents/Meteor/LendLib/LendLib.js` in order to glue the
    template and the data model together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Our items View-Model
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our data model that we created in [Chapter 2](ch02.html "Chapter 2. Reactive
    Programming… It''s Alive!"), *Reactive Programming…It''s Alive!*, we added some
    sample `items` when we created a couple of the `lists`. We did so, if you recall,
    using the browser console, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You''ll notice that we have a hierarchy in there. Every `list` in the `lists`
    collection has an `items` object, which is an array:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to represent this items array to our HTML template, but we need a couple
    of extra properties, so the view knows what to do with it. Specifically, we need
    to:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Return the name of the lendee or return "free" if there is no lendee (`item.Lendee`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the CSS class (red or green), depending on if the item is lent out (`item.LendClass`)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we're going to get the `items` collection from the currently selected list,
    add the `Lendee` and `LendClass` properties, and make the template available.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Open `~/Documents/Meteor/LendLib/LendLib.js`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after the closing `}` curly bracket for the `function focusText(...`,
    add the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll walk through this step-by-step.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we're declaring the `Template.list.items` function, and checking to see
    if a `list` is selected. If a `list` is selected, the `Session` variable `current_list`
    will have a value in it. If it's null, there's no reason to return anything, so
    we'll just return null.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the View-Model at work. It is reading the contents of a given category,
    and incorporating the current state of the UI, according to whether the user has
    selected a list. This is the glue at work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: If something is selected, we need to first find the category. We'll call it
    `cats`, because it's shorter, even though it's not strictly speaking the best
    naming convention. But what do we care? We're doing this for fun, and `cats` are
    awesome!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are using the MongoDB command `findOne()`, and passing the `current_list`
    session parameter as `_id` in the selector/query. If something is selected, we
    will get a single category/list back. Let's check to make sure we do, and that
    we also get `items`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'If nothing returns, or there are no `items` in the category, we don''t really
    need to figure out the `Lendee` or the `LendClass`, do we? So let''s create an
    `if` statement, and a `for` statement inside the `if`, that will only get executed
    if we have something worth iterating over:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we check to see if `cats` and `cats.items` are not undefined/null.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate over all the values in `items` (`items` is an array, if you
    recall). To make it easier, we declare the variable `d = cats.item[i]`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Now we add the `Lendee` property, checking to see if the item is lent to anyone
    with the `LentTo` property. If it isn't (if `LentTo` doesn't exist), we'll assign
    the string `"free"` instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if `LentTo` exists, we declare the red Bootstrap label class, `label-important`
    as the `LendClass`. If the item is not lent out, we'll use the green Bootstrap
    class, `label-success` instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with our new `Lendee` and `LendClass` properties assigned, we'll return
    `cats.items`. We didn't save these properties to our model. That's because they're
    *not* part of the model. They're used by the view, so we'll only make them available
    via the View-Model template.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Additional view states
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now need to declare the templates for all the different view states. That
    is, we need to add properties to the View-Model/session that will let us know
    what we''re looking at, what we''re editing, and what should be hidden/visible.
    Specifically, we need to access the state value in four situations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Are we looking at a list? (`list_selected`)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What list are we looking at? (`list_status`)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are we adding an item to a list? (`list_adding`)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are we updating the lendee? (`lendee_editing`)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following code, just below our newly-created items template/function
    in `LendLib.js`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's go over each of these template functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Session` variable `current_list` can be either `undefined` or `null`. If
    it's `undefined`, `Session.equals('current_list'),null)` will return `true`. So
    we need to check both cases, unfortunately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`list_status` is used to tell the category button whether it should show as
    selected. The easiest way to do that is via a CSS class. Bootstrap uses `btn-inverse`
    to show white-on-black text, but that''s our default button look and feel. So,
    because we are using the exact opposite color scheme, we''ll use Bootstrap''s
    regular black-on-white appearance for the selected category.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: In other words, for the `current_list`, we'll return `""` (default button look
    and feel). For all the other lists/categories, we'll return `"btn-inverse"`, to
    change the CSS style.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering about `this._id`. `this`, in this instance, refers to the
    MongoDB record (technically document cursor), and `._id` is the unique MongoDB
    identifier for that "record". This is called the **context**, and in this case
    when using the HTML template, the context is implied to be the list/category element
    from where the template was called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This one's really straightforward. If the `Session` variable `list_adding` is
    `true`, we're adding to the list. If it isn't, we're not.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To check and see if we should be in lendee editing mode, we'll check the `Session`
    variable `lendee_input` and see `a` if it has a value, and `b` if that value is
    the `Name` of the item we just clicked on. Once again, this is the implied context.
    This time, it's not the list, it's the item. How do we know this? Because of where
    this function is called from. Remember the HTML?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how we use `lendee_editing` in the `if` statement, right after we use
    `{{Name}}`. This is showing us the context. `this.Name` in `LendLib.js` has the
    same context as `{{Name}}` in `LendLib.html`. In other words, `this.Name` is referencing
    the same property as `{{Name}}`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: While we're here in the HTML templates, there's one change we need to make to
    the HTML categories template. We waited until now, so that the change would make
    sense. When you make the following code change, you'll see how the templates `{{list_status}}`
    and `{{_id}}` are used, and why the context for `this._id` suddenly makes sense.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the following lines in `LendLib.html` (should be around line 27 or so):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And change it to look like the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding events
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to hook up all the events. Instead of doing this in the HTML
    (our view), we'll do it in the template declarations (our View-Model).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The first one takes place in the `Template.categories.events` declaration, because
    we need to add the event that will change the `Session` variable `current_list`.
    If you recall, `current_list` helps us know whether we have a selected list (`list_selected`)
    and what list that is (`list_status`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LendLib.js`, between the event declaration for `''focusout #add-category''`
    and the end `});` bracket for the `Template.categories.events` function, add the
    following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget the comma (`,`) right after the `'focusout... function(e,t){...}`
    code block.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This adds a click event for every button with the CSS class `"category"`, and
    calls the function `selectCategory()`. We'll declare that right now.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the `focusText()` function and just before the `Template.list.items`
    declaration, add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Yes, you could have put this anywhere. Yes, you could have just put a generic
    function inline with the click event declaration. So why put it here? Because
    it makes our code more readable, and we need a section for all the add/delete/update
    calls we'll need anyway, so it fits right here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: And yes, it's very simple. It just updates the `Session` variable `current_list`
    with `this._id`. The context of `this` here is the category/list, and therefore
    `_id` is the MongoDB-generated ID for the record.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, now that we have all the categories events taken care of, let''s work
    on the items events. At the very end of the `if (Meteor.is_client) {...` code
    block, just inside the closing `}` bracket, put the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Six events! It looks more monstrous than it is. As usual, let's break it down,
    step-by-step.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We declare `Template.lists.events`, and enumerate our events. The first one
    is for adding an item. The button to add an item is, funnily enough, named `btnAddItem`
    so all we have to do is add the declaration, and then write our function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We set `list_adding` to `true`. Because we use `Session.set()`, the change cascades
    through our templates. This is a reaction, or reactive programming in action.
    We also call `Meteor.flush()` to ensure the UI is cleaned up, and then, as a courtesy
    to our user, we focus the textbox (named `item_to_add`) so our beloved user can
    just start typing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about what `Meteor.flush()` does in the Meteor documentation
    at [http://docs.meteor.com/#meteor_flush](http://docs.meteor.com/#meteor_flush).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The next event is based on the `keyup` event for our `item_to_add` textbox.
    If we hit *Enter* or Return (`e.which === 13`) we're going to call the `addItem()`
    function to update the data model, and then we're going to hide the textbox. How
    do we do that? Set `list_adding = false`, of course. Again, doing it through `Session.set()`
    will cascade the change through our templates.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Something else that you may have missed: Remember when we manually added a
    category/list in [Chapter 2](ch02.html "Chapter 2. Reactive Programming… It''s
    Alive!"), *Reactive Programming – It''s Alive!*, using the console? The change
    was instantly reflected in the HTML DOM. The same thing is true here. When `addItem()`
    updates the data model, that change triggers a template refresh for `Template.list.items`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The trigger creates a situation so that if we we change our minds about adding
    an `item`, all we have to do is click away from it. If the textbox `item_to_add`
    triggers the `focusout` event, we'll set the `Session` variable `list_adding`
    to `false`, and the template will cascade.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember when we created the little [![Adding events](img/0823OS_04_05.jpg)]
    button in our HTML `lists` template? That button belongs to the CSS class `delete_item`,
    and when the user clicks on it, we will call the `removeItem()` function, passing
    the `current_list`, and the `id` from the HTML element that was clicked, which
    happens to be the item `Name` (we added `id="{{Name}}"` on line 39 of `LendingLib.html`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now focus on the `lendee` section/button. If you recall, we set up a `<div>`
    element with the CSS class `lendee` in `LendingLib.html`. We are now declaring
    that whenever one of those `<div>` elements is clicked, we''ll perform actions
    very similar to when we wanted to add an `item` to a `list`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Session` variable that controls textbox visibility to `true` (`lendee_input`).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the UI (`Meteor.flush()`).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set focus on the textbox (`focusText()`).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One more event handler:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The textbox with `id="edit_lendee"` has two `keyup` conditions attached to it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: If we hit *Enter* or Return (`e.which === 13`), we'll update the `LentTo` property
    on the data model using `updateLendee()`. We'll then hide the textbox by setting
    `lendee_input` to `null`. Keep in mind that updating the data model, and setting
    a `Session` variable will cause the templates to refresh (reactive programming
    again).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If we instead decide we don't like the changes, we're going to hit the *Esc*
    key (`e.which === 27`) in which case, we'll set `lendee_input` to `null` and let
    the reactive programming hide the textbox.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Model updates
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have two things left to do. We need to take care of making our app pretty
    (not just yet, though), and we need to create the `addItem()`, `removeItem()`
    and `updateLendee()` functions that we just made references to in the `events`
    section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s get to work! In `LendingLib.js`, in the helpers section (just above
    `Template.lists.items`, on line 68 or so) let''s add our `addItem()` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`addItem()` takes two arguments: `list_i`d and `item_name`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '`list_id` is used in the selector (the query) portion of the `update` statement,
    and `item_name` contains the value to be added to the `item.Name` property of
    the new `item` to be added.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to check to make sure we have values for `item_name` and
    `list_id`. If we don't, we'll just `return`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll call the MongoDB `update()` function on the `lists` collection. `{_id:list_id}`
    is the selector. We're telling MongoDB to find us the record with an `_id` `=
    list_id`. We then tell MongoDB what kind of update we're going to perform. In
    this case, we'll use `$addToSet`, which will append to an array. And what are
    we going to append?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`{items:...` indicates that we''re updating the `items[]` array. `{Name:item_name}`
    is what we''re adding, and it''s the `Name` property. This is equivalent to saying
    `item.Name = item_name`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Once we add this, as you might have guessed by now, the templates will automatically
    update, because a change was made to the data model. Stop for a second and think
    about that. In six lines of code, we performed an update query *and* propagated
    the change to our UI. Six lines! Pretty magical, isn't it?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s handle `removeItem()` next:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Wow, this looks really similar to the `addItem()` function. We are, in fact,
    using the same `update()` function, just with a different action this time. This
    time we'll use `$pull`, which pulls an element out of the `items[]` array, where
    `Name == item_name`. Once again, six lines is all we need. The data model and
    the UI will both update automatically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we tackle `updateLendee()`, which is a little more complex, but only because
    Meteor actually uses minimongo, which is a pared-down version of MongoDB, and
    lacks cursor variable support. That means that instead of using something like
    `items.$.Name`, where `$` is the cursor location, we instead need to go through
    the `items[]` array, update values, and then call an update where we replace the
    entire `items[]` array with our updated one. Here''s how we do it for `LendLib.js`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We get the `list_id`, the `item_name`, and the `lendee_name`, so we can identify
    the right record (we use `list_id` and `item_name` for that), and then update
    the `LentTo` property with the value in `lendee_name`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'To save some typing, we declare variable `l`, using the MongoDB `findOne()`
    function. This takes a two-part selector statement: `_id:list_id` and `"items.Name":item_name`.
    This selector is basically saying "find me *one* record where the `_id == list_id`
    and the `items[]` array has a record where `Name == item_name`."'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: If `l` has a value, and `l` also has `items`, we'll go into our `for` loop.
    Here we check specifically for whichever array element had `Name == item_name`.
    If we find one, we'll set the `LentTo` property to `lendee_name`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Once we're done with the `for` loop, we'll call the MongoDB `update()` function,
    and use the `$set` action to replace the old `items[]` array with the new one
    that is `{"items":l.items}`. Automatic updates happen again, and our UI (view)
    and data document (model) are in sync again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Style updates
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, you can run the application. It will be a visual train wreck, because
    we haven''t set any CSS styles yet, but let''s go ahead and do that real quick.
    We''d all stare at a train wreck anyway, just admit it! Make sure your application
    is running (`> meteor` in the console) and navigate to `http://localhost:3000`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Style updates](img/0823OS_04_01.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'Click on **DVDs**, and you should see the one entry for **Mission Impossible**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Style updates](img/0823OS_04_02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: It's not all that bad, besides some width/height issues, but that's because
    we are using Bootstrap. Let's go ahead and fix the remaining UI issues.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have one final change in `LendLib.js`. Change the `focusText()` function
    (located at about line 55):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It should now be:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This change just makes it so that when we go to edit something with a value
    already in it (like the lendee), the value will transfer to the textbox. This
    makes it easier for the user to see who the current lendee is. The `val ? val
    : ""` conditional statement is necessary, because if `val` isn''t passed or is
    null, `"undefined"` gets put into the textbox.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '这个更改只是使得当我们去编辑一个已经有值的东西（比如借阅人）时，这个值会传输到文本框中。这使得用户更容易看到当前借阅人是谁。`val ? val :
    ""`这个条件语句是必要的，因为如果`val`没有被传递或者是null，`"undefined"`会被放进文本框中。'
- en: 'We now want to update the CSS for all the other visual idiosyncrasies. We won''t
    be going over the CSS here, as there are probably much better ways to deal with
    it, and we''re not experts on CSS. So just add the following to `~/Documents/Meteor/LendLib/LendLib.css`,
    and save the changes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要更新所有其他视觉特性的CSS。我们在这里不会详细介绍CSS，因为有更好的方法来处理它，而且我们不是CSS专家。所以只需将以下内容添加到`~/Documents/Meteor/LendLib/LendLib.css`中，并保存更改：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you kept `http://localhost:3000` open, your browser will automatically refresh.
    If you didn''t, open it backup (make sure Meteor is running) and observe the results:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保持了`http://localhost:3000`打开，你的浏览器将自动刷新。如果你没有，重新打开它（确保Meteor正在运行）并观察结果：
- en: '![Style updates](img/0823OS_04_03.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![样式更新](img/0823OS_04_03.jpg)'
- en: Don't forget to test all your new functionality! Add new categories, add items
    to a list, change the lendee, delete the lendee, delete the items, and so on,
    and just get a feel for how fast and clean the updates to the model are.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记测试你所有的新的功能！添加新的类别，将项目添加到列表中，更改借阅人，删除借阅人，删除项目等等，只是感受一下模型更新有多快和多干净。
- en: Now, open two browsers, both pointing to `http://localhost:3000`. You'll notice
    that changes you make in one browser are reflected in the other one as well! Just
    as before, Meteor is taking care of the data model synching between the client
    and server, and any change on one client is propagated to the other clients by
    the server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开两个浏览器，都指向`http://localhost:3000`。你会注意到，在一个浏览器中做的更改在另一个浏览器中也会反映出来！就像之前一样，Meteor正在处理客户端和服务器之间的数据模型同步，任何在客户端上的更改都会通过服务器传播到其他客户端。
- en: '![Style updates](img/0823OS_04_04.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![样式更新](img/0823OS_04_04.jpg)'
- en: Once you get as many items and lists created as you'd like, move on to the next
    chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了足够多的项目和列表，就可以继续下一章。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've completed the templates, events, and data model sections
    for your Lending Library application. You've created statements to add, delete,
    and update your records, and implemented UI state changes. You've seen firsthand
    how reactive programming works, and gained a solid understanding of context. You
    are now able to create an application from scratch, using the core functionality
    of Meteor to develop quickly and with robust functionality. In the next chapter,
    you'll dive even deeper into Meteor's data caching and synching methodology, and
    harden your application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经完成了你借贷图书馆应用的模板、事件和数据模型部分。你已经创建了语句来添加、删除和更新你的记录，并实现了UI状态的改变。你亲自看到了响应式编程是如何工作的，并对你所使用的上下文有了坚实的基础。你现在能够从零开始创建一个应用，使用Meteor的核心功能快速开发并拥有健壮的功能。在下一章中，你将更深入地了解Meteor的数据缓存和同步方法，并加强你的应用。
