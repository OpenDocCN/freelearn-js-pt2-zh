- en: Chapter 4. Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。模板
- en: We've gotten just a taste of templates so far, and are now ready to dive in,
    creating a working application using the MVVM design pattern. This chapter will
    take us through the template system in depth, and show us how to implement display
    logic, add design considerations to a model (create the View-Model), and take
    care of data flow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是对模板有了一个简单的了解，现在我们准备深入其中，使用MVVM设计模式创建一个工作应用程序。本章将深入介绍模板系统，并展示如何实现显示逻辑、向模型添加设计考虑（创建视图模型）以及处理数据流。
- en: 'In this chapter, you will complete the following tasks:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将完成以下任务：
- en: Completing the Lending Library core functionality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成借阅图书馆的核心功能
- en: Creating multiple templates and template logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个模板和模板逻辑
- en: Adding, deleting, and updating entries in the data model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据模型中添加、删除和更新条目
- en: Seeing reactivity in action and using it in your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察响应性在实际工作中的应用，并在您的应用程序中使用它
- en: A new HTML template
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个新的HTML模板
- en: We've already created our categories through the use of the `categories` template.
    Now, we want to take this to the next level and display the actual items that
    we may want to let people (except STEVE!) borrow. So when we click on a category
    we should get a **list** of **items**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用`categories`模板创建了我们的分类。现在，我们想要将其提升到下一个级别，显示我们可能想让（除了STEVE之外的）人们借阅的实际项目。所以，当我们点击一个分类时，我们应该得到一个**项目**的**列表**。
- en: 'Let''s use that terminology. We need a place to display a `list`. So, let''s
    modify our`~/Documents/Meteor/LendLib/LendLib.html` code just a bit at the top:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个术语。我们需要一个地方来显示一个`list`。所以，让我们稍微修改一下`~/Documents/Meteor/LendLib/LendLib.html`代码的开头部分：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We did two things by adding this code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这段代码，我们做了两件事：
- en: We wrapped the `div` element with `id="categories-container"` inside of the
    `div` called `lendlib`. This is for stylistic purposes, so that our `list` will
    more or less line up with the `categories` template.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`id="categories-container"`的`div`元素包裹在名为`lendlib`的`div`内。这是出于样式考虑，这样我们的`list`就能与`categories`模板大致对齐。
- en: 'We added a `div` with `id="list"` just below it, and added a call to a new
    template: `{{> list}}.` This is our template/placeholder for the `list` of `items`,
    which we''ll see shortly in the sections that follow.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在它下面添加了一个`div`，`id="list"`，并添加了一个对新模板的调用：`{{> list}}`。这是我们用于`items`的`list`的模板/占位符，我们将在接下来的部分中看到。
- en: And there you have it. We've created a very easy-to-maintain structure, with
    definite boundaries in the document. We know where our `categories` are going
    to go, and we know where our `list` of `items` is going to go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个非常易于维护的结构，文档中有了明确的界限。我们知道`categories`（分类）将要放在哪里，我们也知道`items`（项目）的`list`（列表）将要放在哪里。
- en: 'Now let''s see about the list template itself. Not so simple, but still not
    bad. At the very end of `LendLib.html`, below the closing `</template>` tag for
    our `categories` template, place the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看列表模板本身。虽然不简单，但仍然不难。在`LendLib.html`的最后，我们`categories`模板的闭合`</template>`标签下方，放置以下代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s go through this step by step, so we understand what each line does:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地来看，这样我们就明白每一行代码的作用：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we declare the HTML `<template>` with the name `"list"`, to match the call
    to the list template we made in the body. We create an unordered list `<ul>` and
    give it an `id` so we can refer to it later if need be.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个HTML`<template>`，名为`"list"`，以匹配我们在主体部分调用的列表模板。我们创建了一个无序列表`<ul>`，并给它一个`id`，这样我们以后如果需要的话就可以引用它。
- en: Then we start a templated `each` statement. This time, we're going to iterate
    through `items`. We haven't created the Meteor `items` template just yet, but
    we'll get there soon enough.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始一个模板化的`each`语句。这次，我们要遍历`items`。我们还没有创建Meteor的`items`模板，但我们应该很快就会做到。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, under the `each` statement, we create an `<li>` element and give it two
    class names. The `lending_item` class name is added so that we can refer to it
    in our View-Model (Meteor template code). The `alert` class name is for Bootstrap,
    so it will display all nice and pretty.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`each`语句下，我们创建了一个`<li>`元素，并给它赋予了两个类名。`lending_item`这个类名是为了让我们能在视图模型（Meteor模板代码）中引用它。`alert`这个类名是为了Bootstrap，这样它就能漂亮地显示出来。
- en: Next, we create a `button` that we can use, should we choose to delete the item.
    Notice, that we give it an ID `id="{{Name}}"`. This will be read from the `items`
    View-Model, and will make our jobs much easier in the future, should we want to
    delete the `item` from our `items` collection. There are also two class names
    on this one. `close` is added for Bootstrap, and `delete_item` is added so that
    we can refer to it in the View-Model when the time comes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `button`，如果我们选择删除项目，我们可以使用它。注意，我们给它一个 ID `id="{{Name}}"`。这将从 `items`
    View-Model 中读取，如果我们想从我们的 `items` 集合中删除 `item`，这将使我们的工作在未来变得容易得多。这个 `button` 上还有两个类名。`close`
    是为 Bootstrap 添加的，`delete_item` 是添加的，这样我们可以在 View-Model 中引用它。
- en: Now, just below that we have another template placeholder for `{{Name}}`. This
    is so that we can use the title of the item (for example on a DVD item the title
    could be "Mission Impossible") inside our display element. We'll see this in action
    very soon.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就在那个下面，我们又有另一个模板占位符 `{{Name}}`。这样我们可以在显示元素内部使用项目的标题（例如，在 DVD 项目中，标题可能是 "Mission
    Impossible"）。我们很快就会看到它的实际应用。
- en: 'Now we begin a series of conditional statements. The first conditional statement
    has to do with when we want to edit who is borrowing our item, or the **lendee**:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始了一系列条件语句。第一个条件语句与我们需要编辑谁在借阅我们的项目，或者 **借阅者** 有关：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are first using an `if` statement to see if our *current mode* for this `item`
    is `lendee_editing`. That is to say, if we wanted to edit the lendee, we would
    be in "lendee editing" mode, and therefore (in our JavaScript file) `Template.list.lendee_editing`
    would return `true`. If this is the case, we need a textbox, hence the inclusion
    of the `<input>` element, with its associated `id`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一个 `if` 语句来检查这个 `item` 的当前模式是否为 `lendee_editing`。也就是说，如果我们想编辑借阅者，我们就会处于
    "lendee editing" 模式，因此（在我们的 JavaScript 文件中）`Template.list.lendee_editing` 会返回
    `true`。如果是这种情况，我们需要一个文本框，因此包含了 `<input>` 元素，以及它的相关 `id`。
- en: Alternately—and this is the default—we just want to display who the lendee is,
    if there is one. If there isn't, we'll want to maybe change the color or something,
    but we still want it displayed. So, we create a Bootstrap-styled `label` in the
    form of a `<div>` element.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况——这也是默认情况——我们只想显示借阅者是谁，如果有的话。如果没有，我们可能想改变颜色或其他什么，但仍然希望它显示出来。所以，我们创建一个带有
    Bootstrap 样式的 `label`，其形式为一个 `<div>` 元素。
- en: 'At the end of the class declarations, we see a template variable: `...{{LendClass}}"`.
    This class addition is stylistic. It will tell our CSS template whether to show
    it as "free" (someone can borrow it) or as "lent out." If it''s green, it''s free,
    if it''s red, someone has borrowed it. And what CSS class name is used to represent
    the color will be determined in `LendLib.js`, by the `item.LendClass` property,
    which we will create shortly.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明的末尾，我们看到一个模板变量：`...{{LendClass}}"`。这个类添加是样式上的。它将告诉我们的 CSS 模板是显示为 "free"（有人可以借阅它）还是
    "lent out"（借出）。如果是绿色，它是免费的，如果是红色，有人已经借走了。代表颜色的 CSS 类名将在 `LendLib.js` 中由 `item.LendClass`
    属性确定，我们稍后会创建它。
- en: 'Then we have the value inside the div: `{{Lendee}}` . This is also a property
    in `LendLib.js`, as the `item.Lendee` property, and it will either display the
    name of the lendee, or "free" if no one has borrowed it.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们来看一下 `div` 内的值：`{{Lendee}}`。这同样也是 `LendLib.js` 中的一个属性，作为 `item.Lendee` 属性，它会显示借阅者的名字，或者如果没有人借阅的话，显示
    "free"。
- en: We then have the ending `</li>` tag, and our `each` comes to an end with `{{/each}}`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有结束的 `</li>` 标签，以及 `each` 以 `{{/each}}` 结束。
- en: 'Now, we have our second `if` statement, and this one is actually a nested `if`.
    This one is outside of the `each` statement, so it''s not specific to items. This
    `if` statement displays either a light-green bar with a **+** sign, or a textbox
    in the form of an `<input>` element, so that we can add items to our list:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了第二个 `if` 语句，而这个实际上是嵌套的 `if`。这个 `if` 语句在 `each` 语句之外，所以它不是针对特定项目的。这个 `if`
    语句显示一个带 **+** 符号的浅绿色条，或者一个表单形式的 `<input>` 元素文本框，以便我们可以向我们的列表中添加项目：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So we see our first `if`, which is conditioned on whether we're even displaying
    any list items. If we are, that means we have a list selected. Or rather, we are
    in the `list_selected` mode. Keeping track of this is part of the View-Model's
    job, so `Template.list.list_selected` is found inside `LendLib.js`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们看到第一个 `if` 语句，它取决于我们是否甚至显示任何列表项。如果我们正在显示，这意味着我们选择了一个列表。或者说，我们处于 `list_selected`
    模式。跟踪这个是 View-Model 的工作的一部分，所以 `Template.list.list_selected` 可以在 `LendLib.js`
    中找到。
- en: We then create an `<li>` element, style it green with the Bootstrap `alert-success`
    class, and add the `&plus;` sign.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个`<li>`元素，用Bootstrap的`alert-success`类将其样式设置为绿色，并添加`+`号。
- en: Next is our nested (second) `if`. This one is checking to see if we are adding
    to the list of items. If we are, we are in `list_adding` mode, so we'll display
    a textbox in the form of an `<input>` element. If not, we'll just leave the pretty
    light-green box with just the **+** sign in it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的嵌套（第二个）`if`。这个是检查我们是否在添加项列表。如果是，我们处于`list_adding`模式，因此我们将以`<input>`元素的形式显示文本框。如果不是，我们只会保留那个漂亮的浅绿色盒子，里面只有**+**号。
- en: Finally, we end our nested `if`, our `</li>`, our parent `if`, our `</ul>`,
    and our `</template>`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们结束嵌套的`if`，我们的`</li>`，我们的父级`if`，我们的`</ul>`，和我们的`</template>`。
- en: Gluing it all together
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粘合在一起
- en: The View-Model (MVVM) or controller (MVC) or presenter (MVP) is considered the
    glue of an MV* application model. That's because it "glues" together all the view
    items, such as buttons or textboxes, to the model.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型（MVVM）或控制器（MVC）或呈现器（MVP）被认为是MV*应用程序模型的粘合剂。这是因为它将所有视图项，比如按钮或文本框，粘合到了模型上。
- en: Pretty fancy explanation, eh? Well, you try to come up with a better explanation
    for what it does. It really does fill in the cracks, and keep the model and the
    view together. Someone else invented the term, not us, so let's continue without
    the Judgy McJudgerson viewpoint, mmmk?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释很复杂，是吧？好吧，你尝试着为它做更好的解释。它确实填补了空白，并将模型和视图粘合在一起。这个术语是别人发明的，不是我们，所以让我们抛开批判性观点，继续吧？
- en: In this section, we'll go through all the changes step-by-step that need to
    happen inside of `~/Documents/Meteor/LendLib/LendLib.js` in order to glue the
    template and the data model together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步讲解需要在`~/Documents/Meteor/LendLib/LendLib.js`中进行的所有更改，以将模板和数据模型粘合在一起。
- en: Our items View-Model
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的items视图模型
- en: 'In our data model that we created in [Chapter 2](ch02.html "Chapter 2. Reactive
    Programming… It''s Alive!"), *Reactive Programming…It''s Alive!*, we added some
    sample `items` when we created a couple of the `lists`. We did so, if you recall,
    using the browser console, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在[第2章](ch02.html "第2章 响应式编程…它是有生命的！")创建的数据模型中，*响应式编程…它是有生命的！*，我们在创建几个`list`时添加了一些示例`items`。如果你还记得的话，我们是这样通过浏览器控制台操作的：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You''ll notice that we have a hierarchy in there. Every `list` in the `lists`
    collection has an `items` object, which is an array:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到那里有一个层级结构。`lists`集合中的每一个`list`都有一个`items`对象，它是一个数组：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to represent this items array to our HTML template, but we need a couple
    of extra properties, so the view knows what to do with it. Specifically, we need
    to:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这个`items`数组呈现到我们的HTML模板中，但我们还需要一些额外的属性，以便视图知道如何处理它。具体来说，我们需要做的是：
- en: Return the name of the lendee or return "free" if there is no lendee (`item.Lendee`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回借阅者姓名，如果没有借阅者则返回"free"（`item.Lendee`）
- en: Return the CSS class (red or green), depending on if the item is lent out (`item.LendClass`)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据项目是否已借出（`item.LendClass`），返回CSS类（红色或绿色）。
- en: So, we're going to get the `items` collection from the currently selected list,
    add the `Lendee` and `LendClass` properties, and make the template available.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将从当前选定的列表中获取`items`集合，添加`Lendee`和`LendClass`属性，并使模板可用。
- en: Open `~/Documents/Meteor/LendLib/LendLib.js`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`~/Documents/Meteor/LendLib/LendLib.js`。
- en: 'Immediately after the closing `}` curly bracket for the `function focusText(...`,
    add the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`function focusText(...`的闭合`}`花括号后立即添加以下代码：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll walk through this step-by-step.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步讲解这个问题。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we're declaring the `Template.list.items` function, and checking to see
    if a `list` is selected. If a `list` is selected, the `Session` variable `current_list`
    will have a value in it. If it's null, there's no reason to return anything, so
    we'll just return null.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了`Template.list.items`函数，并检查是否选择了`list`。如果选择了`list`，`Session`变量`current_list`中将有一个值。如果没有，就没有返回任何东西的必要，所以我们直接返回null。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is the View-Model at work. It is reading the contents of a given category,
    and incorporating the current state of the UI, according to whether the user has
    selected a list. This is the glue at work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是视图模型在工作。它正在读取给定类别的内容，并根据用户是否选择了列表，将当前UI状态融入其中。这是粘合剂在工作。
- en: If something is selected, we need to first find the category. We'll call it
    `cats`, because it's shorter, even though it's not strictly speaking the best
    naming convention. But what do we care? We're doing this for fun, and `cats` are
    awesome!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选中了某个项目，我们首先需要找到类别。我们称之为`cats`，因为这个名字更短，尽管它不是严格意义上的最佳命名约定。但我们在乎吗？我们这样做是为了好玩，而且`cats`很棒！
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are using the MongoDB command `findOne()`, and passing the `current_list`
    session parameter as `_id` in the selector/query. If something is selected, we
    will get a single category/list back. Let's check to make sure we do, and that
    we also get `items`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用MongoDB命令`findOne()`，并将`current_list`会话参数作为`_id`在选择器/查询中传递。如果有什么被选中，我们将得到一个单一的类别/列表。让我们确保我们确实这样做，并且我们还能得到`items`。
- en: 'If nothing returns, or there are no `items` in the category, we don''t really
    need to figure out the `Lendee` or the `LendClass`, do we? So let''s create an
    `if` statement, and a `for` statement inside the `if`, that will only get executed
    if we have something worth iterating over:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有返回任何内容，或者该类别中没有`items`，我们真的需要确定`Lendee`或`LendClass`吗？所以让我们创建一个`if`语句，和一个在`if`内的`for`语句，只有在我们有值得迭代的元素时才会执行：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we check to see if `cats` and `cats.items` are not undefined/null.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`cats`和`cats.items`是否未定义/为空。
- en: Next, we iterate over all the values in `items` (`items` is an array, if you
    recall). To make it easier, we declare the variable `d = cats.item[i]`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历`items`中的所有值（如果你还记得，`items`是一个数组）。为了更容易，我们声明变量`d = cats.item[i]`。
- en: Now we add the `Lendee` property, checking to see if the item is lent to anyone
    with the `LentTo` property. If it isn't (if `LentTo` doesn't exist), we'll assign
    the string `"free"` instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加了`Lendee`属性，检查项目是否借给了任何人，`LentTo`属性。如果没有（如果`LentTo`不存在），我们将分配字符串`"free"`。
- en: Likewise, if `LentTo` exists, we declare the red Bootstrap label class, `label-important`
    as the `LendClass`. If the item is not lent out, we'll use the green Bootstrap
    class, `label-success` instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果`LentTo`存在，我们将红色Bootstrap标签类`label-important`作为`LendClass`。如果项目没有借出，我们将使用绿色Bootstrap类`label-success`。
- en: Finally, with our new `Lendee` and `LendClass` properties assigned, we'll return
    `cats.items`. We didn't save these properties to our model. That's because they're
    *not* part of the model. They're used by the view, so we'll only make them available
    via the View-Model template.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的新`Lendee`和`LendClass`属性分配之后，我们将返回`cats.items`。我们没有将这些属性保存到我们的模型中。那是因为它们*不是*模型的一部分。它们由视图使用，因此我们只通过View-Model模板使它们可用。
- en: Additional view states
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加视图状态
- en: 'We now need to declare the templates for all the different view states. That
    is, we need to add properties to the View-Model/session that will let us know
    what we''re looking at, what we''re editing, and what should be hidden/visible.
    Specifically, we need to access the state value in four situations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为所有不同的视图状态声明模板。也就是说，我们需要向View-Model/session添加属性，这样我们才能知道我们在看什么，我们在编辑什么，以及应该隐藏/显示什么。具体来说，我们需要在四种情况下访问状态值：
- en: Are we looking at a list? (`list_selected`)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在看列表吗？（`list_selected`）
- en: What list are we looking at? (`list_status`)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在看哪个列表？（`list_status`）
- en: Are we adding an item to a list? (`list_adding`)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在向列表中添加项目吗？（`list_adding`）
- en: Are we updating the lendee? (`lendee_editing`)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在更新借阅人吗？（`lendee_editing`）
- en: 'Add the following code, just below our newly-created items template/function
    in `LendLib.js`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LendLib.js`中我们新创建的items模板/函数下方添加以下代码：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's go over each of these template functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些模板函数。
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Session` variable `current_list` can be either `undefined` or `null`. If
    it's `undefined`, `Session.equals('current_list'),null)` will return `true`. So
    we need to check both cases, unfortunately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session`变量`current_list`可以是`undefined`或`null`。如果是`undefined`，`Session.equals(''current_list''),null)`将返回`true`。所以我们需要检查这两种情况，很不幸。'
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`list_status` is used to tell the category button whether it should show as
    selected. The easiest way to do that is via a CSS class. Bootstrap uses `btn-inverse`
    to show white-on-black text, but that''s our default button look and feel. So,
    because we are using the exact opposite color scheme, we''ll use Bootstrap''s
    regular black-on-white appearance for the selected category.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_status`用于告诉类别按钮是否应显示为选中状态。最容易的方法是通过一个CSS类。Bootstrap使用`btn-inverse`显示黑白文本，但这是我们默认的按钮外观。因此，因为我们使用了完全相反的颜色方案，我们将使用Bootstrap的普通黑白外观来显示选中的类别。'
- en: In other words, for the `current_list`, we'll return `""` (default button look
    and feel). For all the other lists/categories, we'll return `"btn-inverse"`, to
    change the CSS style.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，对于`current_list`，我们将返回`""`（默认按钮的外观和感觉）。对于所有其他列表/类别，我们将返回`"btn-inverse"`，以改变CSS样式。
- en: You may be wondering about `this._id`. `this`, in this instance, refers to the
    MongoDB record (technically document cursor), and `._id` is the unique MongoDB
    identifier for that "record". This is called the **context**, and in this case
    when using the HTML template, the context is implied to be the list/category element
    from where the template was called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`this._id`。在这个实例中，`this`指的是MongoDB记录（技术上来说是文档游标），而`._id`是那个“记录”的唯一MongoDB标识符。这称为**上下文**，在这种情况下使用HTML模板时，上下文是从哪里调用模板的列表/类别元素。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This one's really straightforward. If the `Session` variable `list_adding` is
    `true`, we're adding to the list. If it isn't, we're not.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个真的很直接。如果`Session`变量`list_adding`是`true`，我们在添加到列表。如果不是，我们就不添加。
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To check and see if we should be in lendee editing mode, we'll check the `Session`
    variable `lendee_input` and see `a` if it has a value, and `b` if that value is
    the `Name` of the item we just clicked on. Once again, this is the implied context.
    This time, it's not the list, it's the item. How do we know this? Because of where
    this function is called from. Remember the HTML?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们是否应该进入借阅者编辑模式，我们将检查`Session`变量`lendee_input`，看它是否有值，以及这个值是否是我们刚刚点击物品的`Name`。再次说明，这是隐含的上下文。这次，不是列表，而是项目。我们怎么知道这个？因为函数是从哪里调用的。还记得HTML吗？
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how we use `lendee_editing` in the `if` statement, right after we use
    `{{Name}}`. This is showing us the context. `this.Name` in `LendLib.js` has the
    same context as `{{Name}}` in `LendLib.html`. In other words, `this.Name` is referencing
    the same property as `{{Name}}`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在`if`语句中使用`lendee_editing`，正好在我们使用`{{Name}}`之后。这显示了上下文。`LendLib.js`中的`this.Name`与`LendLib.html`中的`{{Name}}`具有相同的上下文。换句话说，`this.Name`引用了与`{{Name}}`相同的属性。
- en: While we're here in the HTML templates, there's one change we need to make to
    the HTML categories template. We waited until now, so that the change would make
    sense. When you make the following code change, you'll see how the templates `{{list_status}}`
    and `{{_id}}` are used, and why the context for `this._id` suddenly makes sense.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在HTML模板中，我们需要对HTML类别模板进行一次更改。我们等到现在，这样更改才有意义。当你做出以下代码更改时，你会看到模板`{{list_status}}`和`{{_id}}`的使用，以及为什么`this._id`的上下文突然变得有意义。
- en: 'Locate the following lines in `LendLib.html` (should be around line 27 or so):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LendLib.html`中找到以下行（应该在第27行左右）：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And change it to look like the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其更改为如下代码片段的样子：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding events
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加事件
- en: We are now going to hook up all the events. Instead of doing this in the HTML
    (our view), we'll do it in the template declarations (our View-Model).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将连接所有事件。不是在HTML（我们的视图）中这样做，而是在模板声明（我们的视图模型）中这样做。
- en: The first one takes place in the `Template.categories.events` declaration, because
    we need to add the event that will change the `Session` variable `current_list`.
    If you recall, `current_list` helps us know whether we have a selected list (`list_selected`)
    and what list that is (`list_status`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个发生在`Template.categories.events`声明中，因为我们需要添加一个事件，来改变`Session`变量`current_list`。如果你记得的话，`current_list`帮助我们知道是否有选中的列表（`list_selected`）以及那个列表是什么（`list_status`）。
- en: 'In `LendLib.js`, between the event declaration for `''focusout #add-category''`
    and the end `});` bracket for the `Template.categories.events` function, add the
    following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '在`LendLib.js`中，在`Template.categories.events`函数的`''focusout #add-category''`事件声明和最后的`});`括号之间，添加以下代码：'
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't forget the comma (`,`) right after the `'focusout... function(e,t){...}`
    code block.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`'focusout... function(e,t){...}`代码块后面加上逗号（`,`）。
- en: This adds a click event for every button with the CSS class `"category"`, and
    calls the function `selectCategory()`. We'll declare that right now.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这为具有CSS类`"category"`的每个按钮添加了点击事件，并调用`selectCategory()`函数。我们现在就声明那个函数。
- en: 'Just after the `focusText()` function and just before the `Template.list.items`
    declaration, add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`focusText()`函数之后，在`Template.list.items`声明之前，添加以下代码：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Yes, you could have put this anywhere. Yes, you could have just put a generic
    function inline with the click event declaration. So why put it here? Because
    it makes our code more readable, and we need a section for all the add/delete/update
    calls we'll need anyway, so it fits right here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你本可以把这个放在任何地方。是的，你本可以简单地在一个点击事件声明中嵌入一个通用函数。那么为什么放在这里呢？因为这样能让我们的代码更具可读性，而且我们需要一个部分来处理所有将要需要的添加/删除/更新调用，所以正好放在这里。
- en: And yes, it's very simple. It just updates the `Session` variable `current_list`
    with `this._id`. The context of `this` here is the category/list, and therefore
    `_id` is the MongoDB-generated ID for the record.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，很简单。它只是用`this._id`更新了`Session`变量`current_list`。这里`this`的上下文是类别/列表，因此`_id`是记录的MongoDB生成的ID。
- en: 'Alright, now that we have all the categories events taken care of, let''s work
    on the items events. At the very end of the `if (Meteor.is_client) {...` code
    block, just inside the closing `}` bracket, put the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经处理了所有类别的 events，让我们来处理项目的 events。在`if (Meteor.is_client) {...`代码块的最后一行，在闭合的`}`括号内，放入以下代码：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Six events! It looks more monstrous than it is. As usual, let's break it down,
    step-by-step.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 六个事件！看起来比实际更吓人。像往常一样，让我们一步步分解。
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We declare `Template.lists.events`, and enumerate our events. The first one
    is for adding an item. The button to add an item is, funnily enough, named `btnAddItem`
    so all we have to do is add the declaration, and then write our function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明`Template.lists.events`，并枚举我们的事件。第一个是为添加一个项目。添加项目的按钮有趣的是，命名为`btnAddItem`，所以我们只需要添加声明，然后写我们的函数。
- en: We set `list_adding` to `true`. Because we use `Session.set()`, the change cascades
    through our templates. This is a reaction, or reactive programming in action.
    We also call `Meteor.flush()` to ensure the UI is cleaned up, and then, as a courtesy
    to our user, we focus the textbox (named `item_to_add`) so our beloved user can
    just start typing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`list_adding`设置为`true`。由于我们使用`Session.set()`，这种变化会通过我们的模板级联。这是一个反应，或者说反应式编程在起作用。我们还调用`Meteor.flush()`以确保清理UI，然后，作为对用户的礼貌，我们将文本框（名为`item_to_add`）聚焦，这样我们的亲爱的用户就可以开始打字了。
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can learn more about what `Meteor.flush()` does in the Meteor documentation
    at [http://docs.meteor.com/#meteor_flush](http://docs.meteor.com/#meteor_flush).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Meteor文档中了解更多关于`Meteor.flush()`做的事情，地址是[http://docs.meteor.com/#meteor_flush](http://docs.meteor.com/#meteor_flush)。
- en: The next event is based on the `keyup` event for our `item_to_add` textbox.
    If we hit *Enter* or Return (`e.which === 13`) we're going to call the `addItem()`
    function to update the data model, and then we're going to hide the textbox. How
    do we do that? Set `list_adding = false`, of course. Again, doing it through `Session.set()`
    will cascade the change through our templates.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个事件是基于我们的`item_to_add`文本框的`keyup`事件。如果我们按下*Enter*或Return键（`e.which === 13`），我们将调用`addItem()`函数来更新数据模型，然后我们将隐藏文本框。我们怎么做呢？当然设置`list_adding
    = false`。再次强调，通过`Session.set()`来做会使这种变化通过我们的模板级联。
- en: 'Something else that you may have missed: Remember when we manually added a
    category/list in [Chapter 2](ch02.html "Chapter 2. Reactive Programming… It''s
    Alive!"), *Reactive Programming – It''s Alive!*, using the console? The change
    was instantly reflected in the HTML DOM. The same thing is true here. When `addItem()`
    updates the data model, that change triggers a template refresh for `Template.list.items`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还漏掉了一件别的事情：记得我们曾在[第 2 章](ch02.html "Chapter 2. Reactive Programming… It's
    Alive!"), *响应式编程…它是有生命的！*, 使用控制台手动添加一个类别/列表吗？变化立刻反映在 HTML DOM 中。这里也是同样的道理。当`addItem()`更新数据模型时，这个变化会触发`Template.list.items`的模板刷新。
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The trigger creates a situation so that if we we change our minds about adding
    an `item`, all we have to do is click away from it. If the textbox `item_to_add`
    triggers the `focusout` event, we'll set the `Session` variable `list_adding`
    to `false`, and the template will cascade.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器创造了一个情境，这样如果我们改变主意不想添加一个`item`，我们只需要点击离开它。如果文本框`item_to_add`触发了`focusout`事件，我们将设置`Session`变量`list_adding`为`false`，模板将会级联。
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember when we created the little [![Adding events](img/0823OS_04_05.jpg)]
    button in our HTML `lists` template? That button belongs to the CSS class `delete_item`,
    and when the user clicks on it, we will call the `removeItem()` function, passing
    the `current_list`, and the `id` from the HTML element that was clicked, which
    happens to be the item `Name` (we added `id="{{Name}}"` on line 39 of `LendingLib.html`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们曾在HTML`列表`模板中创建了那个小小的[![Adding events](img/0823OS_04_05.jpg)]按钮吗？这个按钮属于CSS类`delete_item`，当用户点击它时，我们将调用`removeItem()`函数，传递`current_list`和被点击的HTML元素中的`id`，碰巧是`Name`项（我们在`LendingLib.html`的第39行添加了`id="{{Name}}"`）。
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now focus on the `lendee` section/button. If you recall, we set up a `<div>`
    element with the CSS class `lendee` in `LendingLib.html`. We are now declaring
    that whenever one of those `<div>` elements is clicked, we''ll perform actions
    very similar to when we wanted to add an `item` to a `list`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们关注`lendee`部分/按钮。如果你还记得，我们在`LendingLib.html`中设置了一个带有CSS类`lendee`的`<div>`元素。我们现在声明，无论何时点击其中一个`<div>`元素，我们都将执行与想要向`list`添加`item`非常相似的操作：
- en: Set the `Session` variable that controls textbox visibility to `true` (`lendee_input`).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控制文本框可见性的`Session`变量设置为`true`（`lendee_input`）。
- en: Refresh the UI (`Meteor.flush()`).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新UI（`Meteor.flush()`）。
- en: Set focus on the textbox (`focusText()`).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置文本框的焦点（`focusText()`）。
- en: 'One more event handler:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个事件处理程序：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The textbox with `id="edit_lendee"` has two `keyup` conditions attached to it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`id="edit_lendee"`的文本框有两个`keyup`条件。
- en: If we hit *Enter* or Return (`e.which === 13`), we'll update the `LentTo` property
    on the data model using `updateLendee()`. We'll then hide the textbox by setting
    `lendee_input` to `null`. Keep in mind that updating the data model, and setting
    a `Session` variable will cause the templates to refresh (reactive programming
    again).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下*Enter*或Return（`e.which === 13`），我们将使用`updateLendee()`更新数据模型上的`LentTo`属性。然后通过将`lendee_input`设置为`null`来隐藏文本框。记住，更新数据模型，设置一个`Session`变量将导致模板刷新（又是反应式编程）。
- en: If we instead decide we don't like the changes, we're going to hit the *Esc*
    key (`e.which === 27`) in which case, we'll set `lendee_input` to `null` and let
    the reactive programming hide the textbox.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定不喜欢这些更改，我们将按下*Esc*键（`e.which === 27`），在这种情况下，我们将`lendee_input`设置为`null`，让反应式编程隐藏文本框。
- en: Model updates
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型更新
- en: We have two things left to do. We need to take care of making our app pretty
    (not just yet, though), and we need to create the `addItem()`, `removeItem()`
    and `updateLendee()` functions that we just made references to in the `events`
    section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还剩下两件事要做。我们需要照顾好让我们的应用变得漂亮（不过还不是现在），我们需要创建刚刚在`events`部分提到的`addItem()`、`removeItem()`和`updateLendee()`函数。
- en: 'So let''s get to work! In `LendingLib.js`, in the helpers section (just above
    `Template.lists.items`, on line 68 or so) let''s add our `addItem()` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始工作！在`LendingLib.js`中的帮助器部分（正好在`Template.lists.items`上方，第68行左右），让我们添加我们的`addItem()`函数：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`addItem()` takes two arguments: `list_i`d and `item_name`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`addItem()`函数有两个参数：`list_id`和`item_name`。'
- en: '`list_id` is used in the selector (the query) portion of the `update` statement,
    and `item_name` contains the value to be added to the `item.Name` property of
    the new `item` to be added.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_id`用于`update`语句的选择器（查询）部分，而`item_name`包含要添加到新`item`的`item.Name`属性的值。'
- en: But first, we need to check to make sure we have values for `item_name` and
    `list_id`. If we don't, we'll just `return`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要检查是否有`item_name`和`list_id`的值。如果没有，我们就会`return`。
- en: Now, we'll call the MongoDB `update()` function on the `lists` collection. `{_id:list_id}`
    is the selector. We're telling MongoDB to find us the record with an `_id` `=
    list_id`. We then tell MongoDB what kind of update we're going to perform. In
    this case, we'll use `$addToSet`, which will append to an array. And what are
    we going to append?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对`lists`集合调用MongoDB的`update()`函数。`{_id:list_id}`是选择器。我们告诉MongoDB找到具有`_id`
    `= list_id`的记录。然后我们告诉MongoDB我们将要执行哪种更新。在这种情况下，我们将使用`$addToSet`，它将追加到一个数组中。我们要追加什么？
- en: '`{items:...` indicates that we''re updating the `items[]` array. `{Name:item_name}`
    is what we''re adding, and it''s the `Name` property. This is equivalent to saying
    `item.Name = item_name`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`{items:...`表示我们正在更新`items[]`数组。`{Name:item_name}`是我们要添加的，它是`Name`属性。这相当于说`item.Name
    = item_name`。'
- en: Once we add this, as you might have guessed by now, the templates will automatically
    update, because a change was made to the data model. Stop for a second and think
    about that. In six lines of code, we performed an update query *and* propagated
    the change to our UI. Six lines! Pretty magical, isn't it?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了这个功能，正如你现在可能已经猜到的那样，模板将自动更新，因为数据模型发生了变化。停下来思考一下。在六行代码中，我们执行了一个更新查询*并*将更改传播到我们的UI。六行！这难道不是很神奇吗？
- en: 'Let''s handle `removeItem()` next:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们处理`removeItem()`：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Wow, this looks really similar to the `addItem()` function. We are, in fact,
    using the same `update()` function, just with a different action this time. This
    time we'll use `$pull`, which pulls an element out of the `items[]` array, where
    `Name == item_name`. Once again, six lines is all we need. The data model and
    the UI will both update automatically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这看起来与`addItem()`函数非常相似。事实上，我们确实使用了相同的`update()`函数，只是这次使用了不同的操作。这次我们将使用`$pull`，从`items[]`数组中删除一个元素，其中`Name
    == item_name`。再一次，我们只需要六行代码。数据模型和UI都将自动更新。
- en: 'Now we tackle `updateLendee()`, which is a little more complex, but only because
    Meteor actually uses minimongo, which is a pared-down version of MongoDB, and
    lacks cursor variable support. That means that instead of using something like
    `items.$.Name`, where `$` is the cursor location, we instead need to go through
    the `items[]` array, update values, and then call an update where we replace the
    entire `items[]` array with our updated one. Here''s how we do it for `LendLib.js`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理`updateLendee()`，这有点复杂，但只是因为Meteor实际上使用的是minimongo，这是MongoDB的一个简化版，且不支持游标变量。这意味着，我们不是使用类似于`items.$.Name`的东西，其中`$`是游标位置，而是需要遍历`items[]`数组，更新值，然后调用一个更新操作，用我们的更新后的数组替换整个`items[]`数组。下面是我们在`LendLib.js`中是这样做的：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We get the `list_id`, the `item_name`, and the `lendee_name`, so we can identify
    the right record (we use `list_id` and `item_name` for that), and then update
    the `LentTo` property with the value in `lendee_name`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取了`list_id`、`item_name`和`lendee_name`，这样我们就可以找到正确的记录（我们用`list_id`和`item_name`来做到这一点），然后用`lendee_name`中的值更新`LentTo`属性。
- en: 'To save some typing, we declare variable `l`, using the MongoDB `findOne()`
    function. This takes a two-part selector statement: `_id:list_id` and `"items.Name":item_name`.
    This selector is basically saying "find me *one* record where the `_id == list_id`
    and the `items[]` array has a record where `Name == item_name`."'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省一些打字，我们声明了一个变量`l`，使用了MongoDB的`findOne()`函数。这个函数需要一个由两部分组成的选择器语句：`_id:list_id`和`"items.Name":item_name`。这个选择器基本上是在说：“找到一个记录，其中`_id
    == list_id`且`items[]`数组中有一个记录，其中`Name == item_name`。”
- en: If `l` has a value, and `l` also has `items`, we'll go into our `for` loop.
    Here we check specifically for whichever array element had `Name == item_name`.
    If we find one, we'll set the `LentTo` property to `lendee_name`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`l`有一个值，并且`l`也有`items`，我们将进入我们的`for`循环。在这里，我们特别检查哪个数组元素具有`Name == item_name`。如果我们找到一个，我们将`LentTo`属性设置为`lendee_name`。
- en: Once we're done with the `for` loop, we'll call the MongoDB `update()` function,
    and use the `$set` action to replace the old `items[]` array with the new one
    that is `{"items":l.items}`. Automatic updates happen again, and our UI (view)
    and data document (model) are in sync again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了`for`循环，我们将调用MongoDB的`update()`函数，并使用`$set`操作用新的`{"items":l.items}`替换旧的`items[]`数组。自动更新再次发生，我们的UI（视图）和数据文档（模型）再次保持同步。
- en: Style updates
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式更新
- en: 'Right now, you can run the application. It will be a visual train wreck, because
    we haven''t set any CSS styles yet, but let''s go ahead and do that real quick.
    We''d all stare at a train wreck anyway, just admit it! Make sure your application
    is running (`> meteor` in the console) and navigate to `http://localhost:3000`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行这个应用程序。它将是一场视觉灾难，因为我们还没有设置任何CSS样式，但让我们快速搞定这件事。我们都会盯着一场车祸看的，承认吧！确保你的应用程序正在运行（在控制台输入`>
    meteor`）并导航到`http://localhost:3000`：
- en: '![Style updates](img/0823OS_04_01.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![样式更新](img/0823OS_04_01.jpg)'
- en: 'Click on **DVDs**, and you should see the one entry for **Mission Impossible**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**DVDs**，你应该会看到**Mission Impossible**的其中一个条目：
- en: '![Style updates](img/0823OS_04_02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![样式更新](img/0823OS_04_02.jpg)'
- en: It's not all that bad, besides some width/height issues, but that's because
    we are using Bootstrap. Let's go ahead and fix the remaining UI issues.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有那么糟糕，除了有些宽度和高度问题，但那是因为我们使用了Bootstrap。让我们继续解决剩下的UI问题。
- en: 'First, we have one final change in `LendLib.js`. Change the `focusText()` function
    (located at about line 55):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`LendLib.js`中有一个最后的更改。更改`focusText()`函数（位于大约第55行）：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It should now be:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该是这样的：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This change just makes it so that when we go to edit something with a value
    already in it (like the lendee), the value will transfer to the textbox. This
    makes it easier for the user to see who the current lendee is. The `val ? val
    : ""` conditional statement is necessary, because if `val` isn''t passed or is
    null, `"undefined"` gets put into the textbox.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '这个更改只是使得当我们去编辑一个已经有值的东西（比如借阅人）时，这个值会传输到文本框中。这使得用户更容易看到当前借阅人是谁。`val ? val :
    ""`这个条件语句是必要的，因为如果`val`没有被传递或者是null，`"undefined"`会被放进文本框中。'
- en: 'We now want to update the CSS for all the other visual idiosyncrasies. We won''t
    be going over the CSS here, as there are probably much better ways to deal with
    it, and we''re not experts on CSS. So just add the following to `~/Documents/Meteor/LendLib/LendLib.css`,
    and save the changes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要更新所有其他视觉特性的CSS。我们在这里不会详细介绍CSS，因为有更好的方法来处理它，而且我们不是CSS专家。所以只需将以下内容添加到`~/Documents/Meteor/LendLib/LendLib.css`中，并保存更改：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you kept `http://localhost:3000` open, your browser will automatically refresh.
    If you didn''t, open it backup (make sure Meteor is running) and observe the results:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保持了`http://localhost:3000`打开，你的浏览器将自动刷新。如果你没有，重新打开它（确保Meteor正在运行）并观察结果：
- en: '![Style updates](img/0823OS_04_03.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![样式更新](img/0823OS_04_03.jpg)'
- en: Don't forget to test all your new functionality! Add new categories, add items
    to a list, change the lendee, delete the lendee, delete the items, and so on,
    and just get a feel for how fast and clean the updates to the model are.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记测试你所有的新的功能！添加新的类别，将项目添加到列表中，更改借阅人，删除借阅人，删除项目等等，只是感受一下模型更新有多快和多干净。
- en: Now, open two browsers, both pointing to `http://localhost:3000`. You'll notice
    that changes you make in one browser are reflected in the other one as well! Just
    as before, Meteor is taking care of the data model synching between the client
    and server, and any change on one client is propagated to the other clients by
    the server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开两个浏览器，都指向`http://localhost:3000`。你会注意到，在一个浏览器中做的更改在另一个浏览器中也会反映出来！就像之前一样，Meteor正在处理客户端和服务器之间的数据模型同步，任何在客户端上的更改都会通过服务器传播到其他客户端。
- en: '![Style updates](img/0823OS_04_04.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![样式更新](img/0823OS_04_04.jpg)'
- en: Once you get as many items and lists created as you'd like, move on to the next
    chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了足够多的项目和列表，就可以继续下一章。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've completed the templates, events, and data model sections
    for your Lending Library application. You've created statements to add, delete,
    and update your records, and implemented UI state changes. You've seen firsthand
    how reactive programming works, and gained a solid understanding of context. You
    are now able to create an application from scratch, using the core functionality
    of Meteor to develop quickly and with robust functionality. In the next chapter,
    you'll dive even deeper into Meteor's data caching and synching methodology, and
    harden your application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经完成了你借贷图书馆应用的模板、事件和数据模型部分。你已经创建了语句来添加、删除和更新你的记录，并实现了UI状态的改变。你亲自看到了响应式编程是如何工作的，并对你所使用的上下文有了坚实的基础。你现在能够从零开始创建一个应用，使用Meteor的核心功能快速开发并拥有健壮的功能。在下一章中，你将更深入地了解Meteor的数据缓存和同步方法，并加强你的应用。
