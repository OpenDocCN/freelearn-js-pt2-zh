["```js\nclass NetworkService implements Runnable {\n  private final ServerSocket serverSocket;\n  private final ExecutorService pool;\n\n  public NetworkService(int port, int poolSize)throws IOException {\n    serverSocket = new ServerSocket(port);\n    pool = Executors.newFixedThreadPool(poolSize);\n  }\n\n  public void run() { // run the service\n    try {\n      for (;;) {\n        pool.execute(new Handler(serverSocket.accept()));\n      }\n    } catch (IOException ex) {\n      pool.shutdown();\n    }\n  }\n}\n\nclass Handler implements Runnable {\n  private final Socket socket;\n  Handler(Socket socket) { this.socket = socket; }\n  public void run() {\n    // read and service request on socket\n  }\n}\n```", "```js\nvoid shutdownAndAwaitTermination(ExecutorService pool) {\n  pool.shutdown(); // Disable new tasks from being submitted\n  try {\n    // Wait a while for existing tasks to terminate\n    if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n      pool.shutdownNow(); // Cancel currently executing tasks\n      // Wait a while for tasks to respond to being cancelled\n      if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n        System.err.println(\"Pool did not terminate\");\n    }\n  } catch (InterruptedException ie) {\n    // (Re-)Cancel if current thread also interrupted\n    pool.shutdownNow();\n    // Preserve interrupt status\n    Thread.currentThread().interrupt();\n  }\n}\n```", "```js\ninterface ArchiveSearcher { String search(String target); }\n\nclass App { \n\n  ExecutorService executor = ...ArchiveSearcher searcher = ...\n  void showSearch(final String target)throws InterruptedException {\n    Future<String> future\n    = executor.submit(new Callable<String>() {\n      public String call() {\n        return searcher.search(target);\n      }});\n    displayOtherThings(); // do other things while searching\n    try {\n      displayText(future.get()); // use future\n    } catch (ExecutionException ex) { cleanup(); return; }\n  }\n}\n```", "```js\nFutureTask<String> future =\n  new FutureTask<String>(new Callable<String>() {\n    public String call() {\n    return searcher.search(target);\n  }});\nexecutor.execute(future);\n```", "```js\nnew DeferredAsyncTask<HttpResponse,HttpResponse,Void>() {\n  protected abstract Resolved doInBackground() throws Exception {\n    //do your async code here\n  }\n}\n.done( new ResolveCallback<HttpResponse> {\n  public void onResolve(HttpResponse resolved) {\n    //your success code here\n  }\n})\n.fail ( new RejectCallback<HttpResponse> {\n  public void onReject(HttpResponse rejected) {\n     //your failure code here\n  }\n});\n```", "```js\nPromise<A1,B1,C1> p1 = new DeferredAsyncTask<A1,B1,C1>() { ... }; \nPromise<A2,B2,C2> p1 = new DeferredAsyncTask<A2,B2,C2>() { ... };\nPromise<A3,B3,C3> p3 = new DeferredAsyncTask<A3,B3,C3>() { ... };\n//when gives you a new promise that gets triggered when all the merged promises are resolved or one of them fails\nDeferredObject.when(p1,p2,p3)\n.done(new ResolveCallback<MergedPromiseResult3<A1,A2,A3>() {\n  public void onResolve(MergedPromiseResult3<A1,A2,A3> resolved){\n    Log.i(TAG, \"got: \" + resolved.first() + resolved.second() + resolved.third());\n  }\n})\n.fail(new RejectCallback<MergedPromiseReject>() {\n  public void onReject(MergedPromiseReject rejected) {\n    //failure handling here\n  }\n})\n.progress(new ProgressCallback<MergedPromiseProgress>() {\n  public void onProgress(final MergedPromiseProgress progress){\n    //you get notified as the merged promises keep coming in\n  }\n});\n//Merging doesn't stop you do add individual callbacks for promises that are in the merge\np1.done(...).fail(...)\n//Or even merging them in another way\nDeferredObject.when(p1,p2).done(...).fail(...)\n```", "```js\n//creating new deferred object by calling method DeferredObject();\n\nDeferred deferredObj = new DeferredObject();\n\n//now its time to make some promise\nPromise promise = deferredObj.promise();\n\npromise.done(new DoneCallback() {\n\n  public void onDone(Object result) {\n    //some code here\n  }\n\n}).fail(new FailCallback() {\n  public void onFail(Object rejection) {\n    //some more code\n  }\n}).progress(new ProgressCallback() {\n  public void onProgress(Object progress) {\n    //some code here\n\n  }\n}).always(new AlwaysCallback() {\n  public void onAlways(State state, Object result, Object rejection) {\n    //some code here\n\n  }\n});\n```", "```js\n//create Deferred Manager's object\nDeferredManager theDeferredManager = new DefaultDeferredManager();\n\n// uncomment this to specify Executor\n\n// DeferredManager theDeferredManager = new DefaultDeferredManager(myExecutorService);\n\n//add and initialize number of promises\n\nPromise pm1, pm2, pm3;\ntheDeferredManager.when(p1, p2, p3)\n\n// or you can add here .done(…)\n//or you can add the fail here using   .fail(…)\n```", "```js\nDeferredManager theDeferredManager = new DefaultDeferredManager();\n\ntheDeferredManager.when(new Callable<Integer>()\n\n{\n  public Integer call() {\n    // return something\n    // or throw a new exception\n  }\n\n}).done(new DoneCallback<Integer>() {\n  public void onDone(Integer result) {\n    ...\n  }\n\n}).fail(new FailCallback<Throwable>() {\n  public void onFail(Throwable e) {\n    ...\n  }\n\n});\n```", "```js\nfinal Deferred deferred = ...\nPromise ThePromise = deferred.promise();\nThePromise.then(…);\n\nRunnable runable = new Runnable() {\n\n  public void run() {\n    while (…) {\n      deferred.notify(myProgress);\n    }\n    deferred.resolve(\"done\");\n  }\n}\n```", "```js\nDeferredManager theDeferredManager = …;\ntheDeferredManager.when(new DeferredRunnable<Double>(){\n  public void run() {\n    while (…) {\n      notify(myProgress);\n    }\n  }\n}).then(…);\n```", "```js\nPromise promise = theDeferredManager.when(...)\n  .done(...) //when done\n  .fail(...) // when fail\n\nsynchronized (p)\n  while (promise.isPending()) {\n    try {\n      promise.wait();\n    } catch (InterruptedException e) { ... }\n  }\n}\n```", "```js\nPromise promise = theDeferredManager.when(...)\n  .done(...)\n  .fail(...)\n\ntry {\n  promise.waitSafely(); //replaced waitSafely(); \n} catch (InterruptedException e) {\n  ... \n}\n```", "```js\nDeferred d = …;\nPromise promise = d.promise();\nPromise filtered = promise.then(new DoneFilter<Integer, Integer>() {\n  public Integer filterDone(Integer result)\n    return result * 10;\n  }\n});\n\nfiltered.done(new DoneCallback<Integer>{\n  public void onDone(Integer result) {\n    // result would be original * 10\n```", "```js\nDeferred d = ...;\nPromise promise = d.promise();\n\npromise.then(new DonePipe<Integer, Integer, Exception, Void>() {\n  public Deferred<Integer, Exception, Void> pipeDone(Integer result) {\n    if (result < 100) {\n      return new DeferredObject<Integer, Void, Void>().resolve(result);\n    } else {\n    return new DeferredObject<Integer, Void, Void>().reject(new Exception(...));\n    }\n  }\n}).done(...).fail(...);\n\nd.resolve(80) -> done!\nd.resolve(100) -> fail!\n```"]