- en: Chapter 1. Reading and Writing JSON on the Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 客户端读写 JSON
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Reading and writing JSON in JavaScript
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中读写 JSON
- en: Reading and writing JSON in C++
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 中读写 JSON
- en: Reading and writing JSON in C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中读写 JSON
- en: Reading and writing JSON in Java
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 中读写 JSON
- en: Reading and writing JSON in Perl
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Perl 中读写 JSON
- en: Reading and writing JSON in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中读写 JSON
- en: In addition to reading and writing JSON in Python, we will begin by showing
    you a brief review of JSON formatting to help set the stage for what follows in
    this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 Python 中读写 JSON 之外，我们首先向您展示 JSON 格式的简要回顾，以帮助为本书后续内容奠定基础。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**JSON** stands for **JavaScript Object Notation**. It''s an open standard
    to represent data as attributes with values. Originally derived from the JavaScript
    syntax (hence its name) for use in web applications as an alternative to the more
    verbose and structured **Extensible Markup Language** (**XML**), it is now used
    for data serialization and transport in many standalone and web applications.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON** 代表 **JavaScript Object Notation**（JavaScript 对象表示法）。它是一种开放标准，用于将数据表示为带值的属性。最初来源于
    JavaScript 语法（因此得名）用于作为更冗长和结构化的 **Extensible Markup Language**（**XML**）的替代，在网页应用程序中使用，现在它被用于许多独立和网络应用程序中的数据序列化和传输。'
- en: JSON provides an ideal means to encapsulate data between the client and server.
    In this first chapter, you will learn how to work with JSON in languages specified
    at the beginning of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 提供了在客户端和服务器之间封装数据的理想方式。在本章中，你将学习如何在章节开始时指定的语言中使用 JSON。
- en: These languages are often used for client-side development, which is what we
    will focus on here. We'll look more at server-side languages in [Chapter 2](ch02.html
    "Chapter 2. Reading and Writing JSON on the Server"), *Reading and Writing JSON
    on the Server*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言通常用于客户端开发，这正是我们将要关注的内容。我们将在[第2章](ch02.html "Chapter 2. Reading and Writing
    JSON on the Server")中更多地了解服务器端语言，*服务器端读写 JSON*。
- en: 'Let''s take a look at some JSON returned by the web API, available at [http://www.aprs.fi](http://www.aprs.fi),
    and modified a bit by me to make the example clear (later, in [Chapter 4](ch04.html
    "Chapter 4. Using JSON in AJAX Applications with jQuery and AngularJS"), *Using
    JSON in AJAX Applications with jQuery and AngularJS*, you''ll learn how to fetch
    this data yourself using a web browser and JavaScript):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下由 web API 返回的 JSON 数据，该 API 的网址是 [http://www.aprs.fi](http://www.aprs.fi)，我对其进行了少许修改以使示例更清晰（在后面的[第4章](ch04.html
    "Chapter 4. Using JSON in AJAX Applications with jQuery and AngularJS")中，*使用 JSON
    在 jQuery 和 AngularJS 的 AJAX 应用程序中*，你将学习如何使用网络浏览器和 JavaScript 自己获取这些数据）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [http://www.packtpub.com](http://www.packtpub.com) 下载你购买的所有 Packt Publishing
    书籍的示例代码文件。如果你在其他地方购买了这本书，你可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以电子邮件方式直接接收这些文件。
- en: 'There are a few things to notice about this example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有几个需要注意的地方：
- en: The data is organized into attributes and values, each separated by a colon.
    (Note that a JSON document can also be a single value, such as a string, float,
    integer, or Boolean value.)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据组织成属性和值，每个属性由冒号分隔。（注意，JSON 文档也可以是一个单独的值，比如字符串、浮点数、整数或布尔值。）
- en: Attributes appear as character strings enclosed by double quotes on the left-hand
    side of a colon.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性作为双引号括起来的字符串出现在冒号的左侧。
- en: 'Values are on the right side of the colon and can be the following:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值位于冒号的右侧，可以是以下内容：
- en: Character strings (enclosed in double quotes) such as `KF6GPE`
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串（用双引号括起来的，例如 `KF6GPE`
- en: Numbers (either integers or floating point) such as `2` or `37.17667`
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字（整数或浮点数），例如 `2` 或 `37.17667`
- en: Arrays (comma-delimited values contained in square brackets), such as the value
    for `entries`
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组（由逗号分隔的值，包含在方括号中），例如 `entries` 的值
- en: Whole objects consisting of more attributes and values, such as the two-array
    values in the `entries` value
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由更多属性和值组成的全局对象，例如 `entries` 值中的两个数组值
- en: Alternatively (although this example doesn't show it), the Boolean values `true`
    and `false`
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外（虽然这个例子没有显示），布尔值 `true` 和 `false`
- en: Note that many other kinds of values, such as date/time pairs or individual
    characters are not supported by JSON.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，许多其他类型的值，如日期/时间对或单个字符，JSON是不支持的。
- en: Although it's not entirely clear from this example, whitespace is insignificant.
    There's no need to have each pair on its own line, for example, and the indentation
    is completely arbitrary.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这个例子不完全清楚，但空格是无关紧要的。例如，没有必要将每一对都放在单独的一行上，缩进是完全任意的。
- en: The attribute-name-attribute-value property of JSON, along with the ability
    to nest values and represent arrays, gives JSON a lot of flexibility. You can
    represent a lot of common objects using JSON, including most objects that don't
    have a lot of binary data (For ideas on how to represent binary data using JavaScript
    and JSON, see [Chapter 8](ch08.html "Chapter 8. Using JSON for Binary Data Transfer"),
    *Using JSON for Binary Data Transfer*). This includes primitive values (self-documenting
    because each value is accompanied by an attribute), flat objects with simple values
    including maps, and arrays of simple or complex objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JSON的属性名-属性值属性，以及嵌套值和表示数组的能力，赋予了JSON很大的灵活性。你可以使用JSON表示很多常见的对象，包括大多数不包含大量二进制数据的对象（有关如何使用JavaScript和JSON表示二进制数据的思路，请参见[第8章](ch08.html
    "第8章 使用JSON进行二进制数据传输")，*使用JSON进行二进制数据传输*）。这包括原始值（自文档化，因为每个值都伴随着一个属性），具有简单值的平面对象，包括地图，以及简单或复杂对象的数组。
- en: The self-documenting nature of JSON makes it an ideal choice for data transport
    as you develop new objects, despite its lack of support for comments as you might
    find in XML. Its plaintext nature makes it amenable to compression over the wire
    using popular compression schemes such as `gzip` (available inside most web servers
    and web clients), and its format is easier for humans to read than the more verbose
    XML.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JSON的自文档化特性使其成为数据传输的理想选择，即便它不支持XML中可能找到的注释。它所具有的纯文本特性使其在网络上使用诸如`gzip`这样的流行压缩方案进行压缩变得容易，而且与更冗长的XML相比，它的格式对人类阅读更为友好。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that JSON documents are inherently trees, and thus, do not have support
    for cyclical data structures, such as graphs, where a node points to another node
    in the same data structure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JSON文档本质上是一种树结构，因此，它不支持循环数据结构，比如图，其中节点指向数据结构中的另一个节点。
- en: If you create such a data structure using the native representation in the programming
    language you're using and try to convert that to JSON, you'll get an error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用编程语言的本地区域表示创建此类数据结构，并尝试将其转换为JSON，你会得到一个错误。
- en: Reading and writing JSON in JavaScript
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中读写JSON
- en: JSON originated as a means to carry data between web servers and JavaScript,
    so let's begin with a simple code snippet that reads and writes JSON in JavaScript
    in a web browser. We'll show the entirety of a web application using AJAX and
    JSON in [Chapter 4](ch04.html "Chapter 4. Using JSON in AJAX Applications with
    jQuery and AngularJS"), *Using JSON in AJAX Applications with jQuery and AngularJS*;
    what follows is how to obtain a JavaScript object from JSON and how to create
    a JSON string from a JavaScript object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JSON最初是一种在Web服务器和JavaScript之间传输数据的手段，因此让我们从一个简单的代码片段开始，该代码片段在Web浏览器中使用JavaScript读写JSON。我们将在[第4章](ch04.html
    "第4章 使用JSON在AJAX应用程序中与jQuery和AngularJS一起使用")，*使用JSON在AJAX应用程序中与jQuery和AngularJS一起使用*中展示一个使用AJAX和JSON的Web应用程序的全部内容；以下是如何从JSON获取JavaScript对象以及如何从JavaScript对象创建JSON字符串。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You''ll need a way to edit the JavaScript and run it in your browser. In this
    example, and nearly all examples in this book, we''ll use Google Chrome for this.
    You can download Google Chrome at [https://www.google.com/chrome/browser](https://www.google.com/chrome/browser).
    Once you install Google Chrome, you''ll want to activate the JavaScript console
    by clicking on the **Customize and control Doodle Chrome** icon on the right-hand
    side, which looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一种方法来编辑JavaScript并在浏览器中运行它。在本例中，以及本书中的几乎所有示例，我们将使用Google Chrome来完成这个任务。你可以在[https://www.google.com/chrome/browser](https://www.google.com/chrome/browser)下载Google
    Chrome。一旦你安装了Google Chrome，你希望通过点击右侧的**定制和控制Doodle Chrome**图标来激活JavaScript控制台，它看起来像这样：
- en: '![Getting ready](img/B04206_01_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/B04206_01_01.jpg)'
- en: 'Then, you''ll want to go to **More Tools | JavaScript console**. You should
    see a JavaScript console on the side of the web page, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要前往**更多工具 | JavaScript控制台**。你应该能在网页的侧面看到一个JavaScript控制台，就像这样：
- en: '![Getting ready](img/B04206_01_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/B04206_01_02.jpg)'
- en: If you prefer key commands, you can also use *Ctrl* + *Shift* + *J* on Windows
    and Linux, or *control* + *option* + *J* on a Macintosh.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用快捷键，你也可以在Windows和Linux上使用*Ctrl* + *Shift* + *J*，或者在Macintosh上使用*control*
    + *option* + *J*。
- en: From here, you can enter JavaScript on the lower right-hand corner and press
    *Enter* (*return* on a Mac OS X system) to evaluate the JavaScript.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你可以在右下角输入JavaScript代码并按下*Enter*键（在Mac OS X系统上为*return*键）来执行JavaScript。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Modern web browsers, such as Chrome, define a JSON object in the JavaScript
    runtime that can convert the string data containing JSON to JavaScript objects,
    and convert a JavaScript object to JSON. Here''s a simple example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网页浏览器，如Chrome，在JavaScript运行时定义了一个JSON对象，该对象可以将包含JSON的字符串数据转换为JavaScript对象，反之亦然。这是一个简单的示例：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this and subsequent JavaScript examples, the text you type in the JavaScript
    console is preceded by a `>` symbol, while what the JavaScript console prints
    is anything beginning with `<-` symbol.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在此及随后的JavaScript示例中，你在JavaScript控制台输入的文本前面有一个`>`符号，而JavaScript控制台打印的内容是以`<-`符号开头的。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Chrome and other modern web browsers define the `JSON` object, which has methods
    to convert between strings containing JSON and JavaScript objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome和其他现代网页浏览器定义了`JSON`对象，该对象具有将包含JSON的字符串和JavaScript对象之间相互转换的方法。
- en: In the previous example, we begin by setting the value of the `json` variable
    to a simple JSON expression consisting of one attribute `result` with the value
    `ok`. The JavaScript interpreter returns the resulting value of the variable `json`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们首先将`json`变量的值设置为一个包含一个名为`result`的属性的简单JSON表达式，其值为`ok`。JavaScript解释器返回变量`json`的结果值。
- en: 'The next line uses the `JSON` method `parse` to convert the JSON string referenced
    by `json` into a JavaScript object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用了`JSON`对象的`parse`方法，将`json`引用的JSON字符串转换为JavaScript对象：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can then access any of the values in the object, just as you would any
    other JavaScript object; it is, after all, just an object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像访问任何其他JavaScript对象一样访问对象中的任何一个值；毕竟，它就是一个对象：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, if you need to convert an object to JSON, you can do that with the
    `JSON` method `stringify`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你需要将一个对象转换成JSON格式，你可以使用`JSON`对象的`stringify`方法来实现：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'You should know two things about these methods. First of all, parse will throw
    an exception if the JSON you pass is malformed, or isn''t JSON at all:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些方法，你应该知道两件事情。首先，如果传递给parse的JSON格式不正确，或者根本不是JSON，它会抛出一个异常：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The errors aren't very helpful but better than nothing if you're debugging JSON
    sent by a less-than-fully compliant and debugged JSON encoder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息不是很有帮助，但如果你在调试由不完全符合规范且未经调试的JSON编码器发送的JSON，这总比没有强。
- en: 'Second, very old web browsers may not have a JSON object with these methods.
    In that case, you can use the JavaScript function `eval` after wrapping the JSON
    in parenthesis, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，非常旧的网页浏览器可能没有包含这些方法的JSON对象。在这种情况下，你可以使用JavaScript函数`eval`，在将JSON用括号括起来后再对其进行处理，像这样：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `eval` function evaluates the string you pass as JavaScript, and the JSON
    notation is really just a subset of JavaScript. However, you should avoid using
    `eval` whenever you can for a few reasons. First, it''s often slower than the
    methods provided by the `JSON` object. Second, it''s not safe; your string might
    contain malicious JavaScript that can crash or otherwise subvert your JavaScript
    application, which is not a threat you should take lightly. Use the `JSON` object
    whenever it''s available. Third, you can use the `parse` and `stringify` methods
    to handle simple values, such as Booleans, numbers, and strings; you''re not limited
    to the key-value pairs in the previous example. If all I wanted to do was pass
    a Boolean (such as "the transaction succeeded!"), I might just write the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`函数评估你传递给它的JavaScript字符串，而JSON表示实际上只是JavaScript的一个子集。然而，尽管理论上你可以避免使用`eval`，但有几个原因建议你这么做。首先，它通常比`JSON`对象提供的方法慢。其次，它不安全；你传递的字符串可能包含恶意的JavaScript，这可能会导致你的JavaScript应用程序崩溃或被其他方式破坏，这绝不是轻视的威胁。尽可能使用`JSON`对象。第三，你可以使用`parse`和`stringify`方法来处理简单值，比如布尔值、数字和字符串；你不仅仅限于前一个示例中的键值对。如果我只想传递一个布尔值（比如"交易成功！"），我可能会直接写如下内容：'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, it''s worth pointing out that both the `parse` and `stringify` methods
    to JSON take an optional replacer function, which is invoked on every key and
    value in the object being serialized or deserialized. You can use this function
    to perform on-the-fly data conversions as the JSON is being parsed; for example,
    you can use it to convert between the string representation of a date and the
    number of seconds since midnight at the start of the epoch, or to correct the
    capitalization of strings. I could use a replacer function for either side of
    the transformation, as shown in the following code, to make the call field lowercase:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得指出的是，JSON的`parse`和`stringify`方法都接受一个可选的替换函数，该函数在序列化或反序列化被序列化或反序列化的对象中的每个键和值时被调用。你可以使用这个函数在JSON被解析时进行实时数据转换；例如，你可以使用它将日期字符串表示和自纪元开始以来午夜的秒数之间进行转换，或者纠正字符串的大小写。我可以在以下代码中使用替换函数进行转换，使调用字段小写：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also return `undefined` to remove an item from the results; to omit
    the type field from the JSON I generate, I can execute the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以返回`undefined`以从结果中移除一个项目；为了从生成的JSON中省略类型字段，我可以执行以下操作：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Reading and writing JSON in C++
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中读写JSON
- en: C++ is a language that long-predates JSON, but is still relevant for many projects.
    There's no native support for JSON in C++ but there are a number of libraries
    that provide support for working with JSON. Perhaps the most widely used is **JsonCpp**,
    available from GitHub at [https://github.com/open-source-parsers/jsoncpp](https://github.com/open-source-parsers/jsoncpp).
    It's licensed under the MIT license or public domain if you so desire, so there
    are virtually no limitations on its use.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种早在JSON出现之前就存在的语言，但对于许多项目来说仍然相关。C++中没有对JSON的原生支持，但有许多库提供了对JSON工作的支持。或许最广泛使用的是**JsonCpp**，可在GitHub上找到[https://github.com/open-source-parsers/jsoncpp](https://github.com/open-source-parsers/jsoncpp)。它的许可证为MIT许可证或如果你愿意的话为公共领域，所以它的使用几乎没有限制。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: To use JsonCpp, you need to first go to the website and download the zip file
    with the entire library. Once you do so, you need to integrate it with your application's
    source code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JsonCpp，你首先需要前往网站下载包含整个库的压缩文件。一旦你这么做，你需要将其与你的应用程序源代码集成。
- en: 'How you integrate it with your application''s source code differs from platform
    to platform, but the general process is this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你将它在应用程序源代码中集成的方法因平台而异，但一般过程是这样的：
- en: Create an amalgamated source and header for the library using the instructions
    on the website. To do this, you'll need to have JsonCpp downloaded and Python
    2.6 or later installed. From the top level directory of JsonCpp, run `python amalgamate.py`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网站上的说明创建库的合并源和头文件。为此，你需要下载JsonCpp并安装Python 2.6或更高版本。从JsonCpp的顶级目录运行`python
    amalgamate.py`。
- en: Include the include file `dist/json/json.h` in any file where you want to use
    the JsonCpp library.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何你想使用JsonCpp库的文件中包含`dist/json/json.h`头文件。
- en: Include the source file `dist/jsoncpp.cpp` in your project's make file or build
    system.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目Makefile或构建系统中包含源文件`dist/jsoncpp.cpp`。
- en: Once you do this, you should have access to the JsonCpp interface in any file
    that includes the `json/json.h` header.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，你应该在任何包含`json/json.h`头文件的文件中访问JsonCpp接口。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行操作...
- en: 'Here''s a simple C++ application that uses JsonCpp to convert between `std::string`
    containing some simple JSON and a JSON object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的C++应用程序，它使用JsonCpp将包含一些简单JSON的`std::string`和JSON对象之间进行转换：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This example begins by including the necessary includes, including `json/json.h`,
    which defines the interface to JsonCpp. We explicitly reference the `std` namespace
    for brevity, although don't do so for the `Json` namespace, in which JsonCpp defines
    all of its interfaces.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子开始于包含必要的包含文件，包括定义JsonCpp接口的`json/json.h`。我们明确引用`std`命名空间以简化问题，尽管对于`Json`命名空间，其中JsonCpp定义了所有其接口，不要这样做。
- en: The JsonCpp implementation defines `Json::Reader` and `Json::Writer`, specifying
    the interfaces to JSON readers and writers, respectively. In practice, the `Json::Reader`
    interface is also the implementation of a JSON class that can read JSON, returning
    its values as `Json::Value`. The `Json::Writer` variable just defines an interface;
    you'll want to use a subclass of it such as `Json::FastWriter` or `Json::StyledWriter`
    to create JSON from `Json::Value` objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JsonCpp 实现定义了 `Json::Reader` 和 `Json::Writer`，分别指定 JSON 读取器和写入器的接口。实践中，`Json::Reader`
    接口也是 JSON 类的实现，可以读取 JSON，将其值返回为 `Json::Value`。`Json::Writer` 变量只是定义了一个接口；你可能需要使用其子类，如
    `Json::FastWriter` 或 `Json::StyledWriter`，从 `Json::Value` 对象创建 JSON。
- en: The previous listing begins by defining `Json::Reader` and `Json::Value`; we'll
    use the reader to read the JSON we define on the next line and store its value
    in the `Json::Value` variable `root`. (Presumably your C++ application would get
    its JSON from another source, such as a web service or local file.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个列表首先定义了 `Json::Reader` 和 `Json::Value`；我们将使用读取器读取我们接下来定义的 JSON，并将其值存储在 `Json::Value`
    变量 `root` 中。（假设你的 C++ 应用程序会从其他来源获取 JSON，比如网络服务或本地文件。）
- en: Parsing JSON is as simple as calling the reader's `parse` function, passing
    the JSON and `Json::Value` into which it will write the JSON values. It returns
    a Boolean, which will be `true` if the JSON parsing succeeds.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 JSON 只需调用读取器的 `parse` 函数，将 JSON 和将要写入 JSON 值的 `Json::Value` 传递给它。它返回一个布尔值，如果
    JSON 解析成功，则为 `true`。
- en: 'The `Json::Value` class represents the JSON object as a tree; individual values
    are referenced by the attribute name in the original JSON, and the values are
    the values of those keys, accessible through methods such as `asString`, which
    returns the value of the object as a native C++ type. These methods of `Json::Value`
    includes the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Json::Value` 类将 JSON 对象表示为树；个别值通过原始 JSON 的属性名称来引用，这些值是这些键的值，可以通过诸如 `asString`
    之类的方法访问，该方法将对象的值作为本地 C++ 类型返回。`Json::Value` 这些方法包括以下内容：'
- en: '`asString`, which returns `std::string`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asString`, 它返回 `std::string`。'
- en: '`asInt`, which returns `Int`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asInt`, 它返回 `Int`。'
- en: '`asUInt`, which returns `UInt`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asUInt`, 它返回 `UInt`。'
- en: '`asInt64`, which returns `Int64`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asInt64`, 它返回 `Int64`。'
- en: '`asFloat`, which returns `float`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asFloat`, 它返回 `float`。'
- en: '`asDouble`, which returns `double`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asDouble`, 它返回 `double`。'
- en: '`asBool`, which returns `bool`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asBool`, 它返回 `bool`。'
- en: In addition, the class provides `operator[]`, letting you access array elements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个类还提供了 `operator[]`，让你访问数组元素。
- en: 'You can also query a `Json::Value` object to determine its type using one of
    these methods:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以 also 查询一个 `Json::Value` 对象，使用这些方法之一来确定它的类型：
- en: '`isNull`, which returns `true` if the value is `null`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNull`, 如果值是 `null` 则返回 `true`。'
- en: '`isBool`, which returns `true` if the value is `bool`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isBool`, 如果值是 `bool` 类型则返回 `true`。'
- en: '`isInt`, which returns `true` if the value is `Int`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isInt`, 如果值是 `Int` 则返回 `true`。'
- en: '`isUInt`, which returns `true` if the value is `UInt`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isUInt`, 如果值是 `UInt` 则返回 `true`。'
- en: '`isIntegral`, which returns `true` if the value is an integer'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isIntegral`, 如果值是整数则返回 `true`。'
- en: '`isDouble`, which returns `true` if the value is `double`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDouble`, 如果值是 `double` 则返回 `true`。'
- en: '`isNumeric`, which returns `true` if the value is numeric'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNumeric`, 如果值是数字则返回 `true`。'
- en: '`isString`, which returns `true` if the value is a string'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isString`, 如果值是字符串则返回 `true`。'
- en: '`isArray`, which returns `true` if the value is an array'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isArray`, 如果值是一个数组则返回 `true`。'
- en: '`isObject`, which returns true if the value is another JSON object (which you
    can decompose using another `Json::Value` value)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isObject`, 如果值是另一个 JSON 对象（你可以使用另一个 `Json::Value` 值对其进行分解）则返回 `true`。'
- en: At any rate, our code uses `asString` to fetch the `std::string` value encoded
    as the `result` attribute, and writes it to the console.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们的代码使用 `asString` 来获取作为 `result` 属性的 `std::string` 值，并将其写入控制台。
- en: 'The code then defines `Json::StyledWriter` and `Json::FastWriter` to create
    some pretty-printed JSON and unformatted JSON in strings, as well as a single
    `Json::Value` object to contain our new JSON. Assigning content to the JSON value
    is simple because it overrides the `operator[]` and `operator[]=` methods with
    the appropriate implementations to convert standard C++ types to JSON objects.
    So, the following line of code creates a single JSON attribute/value pair with
    the attribute set to `result`, and the value set to `ok` (although this code doesn''t
    show it, you can create trees of JSON attribute-value pairs by assigning JSON
    objects to other JSON objects):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码然后定义了`Json::StyledWriter`和`Json::FastWriter`来创建一些格式化的JSON和未格式化的JSON字符串，以及一个`Json::Value`对象来包含我们的新JSON。赋值给JSON值很简单，因为它用适当的实现覆盖了`operator[]`和`operator[]=`方法，以将标准C++类型转换为JSON对象。因此，以下代码创建了一个带有`result`属性和`ok`值的单个JSON属性/值对（尽管这段代码没有显示，但你可以通过将JSON对象分配给其他JSON对象来创建JSON属性值树）：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We first use `StyledWriter` and then `FastWriter` to encode the JSON value in
    `newValue`, writing each string to the console.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`StyledWriter`，然后使用`FastWriter`来编码`newValue`中的JSON值，将每个字符串写入控制台。
- en: 'Of course, you can also pass single values to JsonCpp; there''s no reason why
    you can''t execute the following code if all you wanted to do was pass a double-precision
    number:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以将单个值传递给JsonCpp；如果你只是想传递一个双精度数，没有理由不执行以下代码。
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也请参阅
- en: For the documentation for JsonCpp, you can install doxygen from [http://www.stack.nl/~dimitri/doxygen/](http://www.stack.nl/~dimitri/doxygen/)
    and run it over the `doc` folder of the main JsonCpp distribution.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JsonCpp的文档，你可以从[http://www.stack.nl/~dimitri/doxygen/](http://www.stack.nl/~dimitri/doxygen/)安装doxygen，并将其运行在JsonCpp主要分布的`doc`文件夹上。
- en: There are other JSON conversion implementations for C++, too. For a complete
    list, see the list at [http://json.org/](http://json.org/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他针对C++的JSON转换实现。要查看完整的列表，请参阅[http://json.org/](http://json.org/)上的列表。
- en: Reading and writing JSON in C#
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中读写JSON
- en: C# is a common client-side language for rich applications as well as for writing
    the client implementation of web services running on ASP.NET. The .NET library
    includes JSON serialization and deserialization in the System.Web.Extensions assembly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种常见的客户端语言，用于编写丰富应用程序的客户端实现，以及运行在ASP.NET上的Web服务的客户端实现。.NET库在System.Web.Extensions程序集中包括JSON序列化和反序列化。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: This example uses the built-in JSON serializer and deserializer in the System.Web.Extensions
    assembly, one of the many .NET libraries that are available. If you've installed
    a recent version of Visual Studio (see [https://www.visualstudio.com/en-us/downloads/visual-studio-2015-downloads-vs.aspx](https://www.visualstudio.com/en-us/downloads/visual-studio-2015-downloads-vs.aspx)),
    it should be available. All you need to do to use this assembly is include it
    in the assemblies your application references in Visual Studio by right-clicking
    the **References** item in your project, choosing **Add Reference**, and scrolling
    down to **System.Web.Extensions** in the **Framework Assemblies** list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了System.Web.Extensions程序集中的内置JSON序列化和反序列化器，这是许多可用的.NET库之一。如果你安装了最近版本的Visual
    Studio（请参阅[https://www.visualstudio.com/en-us/downloads/visual-studio-2015-downloads-vs.aspx](https://www.visualstudio.com/en-us/downloads/visual-studio-2015-downloads-vs.aspx)），它应该是可以使用的。要使用这个程序集，你所需要做的就是在Visual
    Studio中通过右键点击你的项目中的**引用**项，选择**添加引用**，然后在**框架程序集**列表中滚动到底部找到**System.Web.Extensions**。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Here''s a simple application that deserializes some JSON, as a dictionary of
    attribute-object pairs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的应用程序，它反序列化了一些JSON，作为属性-对象对的字典：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The System.Web.Extensions assembly provides the `JavaScriptSerializer` class
    in the `System.Web.Script.Serialization` namespace. This code begins by defining
    a simple class, `SimpleResult`, which we'll encode as JSON in our example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: System.Web.Extensions程序集提供了`System.Web.Script.Serialization`名称空间中的`JavaScriptSerializer`类。这段代码首先定义了一个简单的类`SimpleResult`，我们将在示例中将其编码为JSON。
- en: The `Main` method first defines a `JavaScriptSerializer` instance, and then
    `string` containing our JSON. Parsing the JSON is as easy as calling the `JavaScriptSerializer`
    instance's `DeserializeObject` method, which returns an object whose type is determined
    at run-time based on the JSON you pass.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法首先定义了一个`JavaScriptSerializer`实例，然后定义了一个包含我们JSON的`string`。解析JSON只需调用`JavaScriptSerializer`实例的`DeserializeObject`方法，该方法根据传递的JSON在运行时确定返回对象的类型。'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can also use `DeserializeObject` to parse JSON in a type-safe manner, and
    then the type of the returned object matches the type you pass to the method.
    I'll show you how to do this in [Chapter 7](ch07.html "Chapter 7. Using JSON in
    a Type-safe Manner"), *Using JSON in a Type-safe Manner*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`DeserializeObject`以类型安全的方式解析JSON，然后返回对象的类型与传递给方法的类型匹配。我将在[第7章](ch07.html
    "第7章 使用JSON进行类型安全操作")*使用JSON进行类型安全操作*中向你展示如何做到这一点。
- en: '`DeserializeObject` returns a `Dictionary` of key-value pairs; the keys are
    the attributes in the JSON, and the values are objects representing the values
    of those attributes. In our example, we simply walk the keys and values in the
    dictionary, printing each. Because we know the type of the value in the JSON,
    we can simply cast it to the appropriate type (`string`, in this case) using the
    C# `as` keyword; if it wasn''t `string`, we''d receive the value `null`. You can
    use `as` or the type inference of C# to determine the type of unknown objects
    in your JSON, making it easy to parse JSON for which you lack strict semantics.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeserializeObject`返回一个键值对的`Dictionary`；键是JSON中的属性，值是表示这些属性值的对象。在我们示例中，我们简单地遍历字典中的键和值，并打印出来。因为我们知道JSON中值的类型，所以我们可以使用C#的`as`关键字将其转换为适当的类型（在这个例子中是`string`）；如果不是`string`，我们将收到`null`值。你可以使用`as`或C#的类型推导来确定JSON中未知对象的类型，这使得解析缺乏严格语义的JSON变得容易。'
- en: The `JavaScriptSerializer` class also includes a `Serialize` method; you can
    either pass it as a dictionary of attribute-value pairs, as we do with our deserialized
    result, or you can pass it as an instance of a C# class. If you pass it as a class,
    it'll attempt to serialize the class by introspecting the class fields and values.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`JavaScriptSerializer`类还包括一个`Serialize`方法；你可以将其作为属性-值对的字典传递，就像我们对反序列化结果所做的那样，或者你可以将其作为C#类的实例传递。如果你将其作为类传递，它将尝试通过内省类字段和值来序列化类。'
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The JSON implementation that Microsoft provides is adequate for many purposes,
    but not necessarily the best for your application. Other developers have implemented
    better ones that typically use the same interface as the Microsoft implementation.
    One good choice is Newtonsoft''s Json.NET, which you can get at [http://json.codeplex.com/](http://json.codeplex.com/)
    or from NuGet in Visual Studio. It supports a wider variety of .NET platforms
    (including Windows Phone), LINQ queries, XPath-like queries against the JSON,
    and is faster than the Microsoft implementation. Using it is similar to using
    the Microsoft implementation: install the package from the Web or NuGet, add a
    reference of the assembly to your application, and then use the `JsonSerializer`
    class in the `NewtonSoft.Json` namespace. It defines the same `SerializeObject`
    and `DeserializeObject` methods that the Microsoft implementation does, making
    switching to this library easy. *James Newton-King*, the author of *Json.NET*,
    makes it available under the MIT license.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供的JSON实现对于许多目的来说已经足够了，但不一定最适合你的应用程序。其他开发者实现了更好的版本，这些版本通常使用与微软实现相同的接口。一个不错的选择是Newtonsoft的Json.NET，你可以从[http://json.codeplex.com/](http://json.codeplex.com/)或者从Visual
    Studio的NuGet获取。它支持更广泛的.NET平台（包括Windows Phone），LINQ查询，对JSON的XPath-like查询，并且比微软实现更快。使用它与使用微软实现类似：从Web或NuGet安装包，将程序集引用添加到你的应用程序中，然后使用`NewtonSoft.Json`命名空间中的`JsonSerializer`类。它定义了与微软实现相同的`SerializeObject`和`DeserializeObject`方法，使得切换到这个库变得容易。*Json.NET*的作者*James
    Newton-King*将其置于MIT许可下。
- en: 'As with other languages, you can also carry primitive types through the deserialization
    and serialization process. For example, after evaluating the following code, the
    resulting dynamic variable `piResult` will contain a floating-point number, 3.14:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言一样，你也可以在反序列化和序列化过程中传递原始类型。例如，在评估以下代码后，动态变量`piResult`将包含一个浮点数，3.14：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也参见
- en: As I previously hinted, you can do this in a type-safe manner; we'll discuss
    more of this in [Chapter 7](ch07.html "Chapter 7. Using JSON in a Type-safe Manner"),
    *Using JSON in a Type-safe Manner*. You'll do this using the generic method `DeserializeObject<>`,
    passing a type variable of the type you want to deserialize into.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所暗示的，你可以以一种类型安全的方式进行操作；我们将在[第7章](ch07.html "第7章 使用JSON进行类型安全操作")*使用JSON进行类型安全操作*中讨论更多内容。你将通过使用泛型方法`DeserializeObject<>`，传入你想要反序列化的类型变量来实现。
- en: Reading and writing JSON in Java
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中读写JSON
- en: Java, like C++, predates JSON. Oracle is presently working on adding JSON support
    to Java, but in the meantime, several implementations providing JSON support are
    available on the Web. Similar to the C++ implementation you saw previously in
    this chapter, you can convert between JSON and Java using a third-party library;
    in this case, packaged as a Java archive (JAR) file, whose implementation typically
    represents JSON objects as a tree of named objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Java，像C++一样，早于JSON。甲骨文目前正致力于为Java添加JSON支持，但与此同时，网上有多个提供JSON支持的实现。与本章前面看到的C++实现类似，你可以使用第三方库将JSON和Java之间进行转换；在这个例子中，作为一个Java归档（JAR）文件，其实现通常将JSON对象表示为命名的对象的树。
- en: Perhaps the best Java implementation of JSON parsing is Gson, available from
    Google at [http://code.google.com/p/google-gson/](http://code.google.com/p/google-gson/)
    licensed under the Apache License 2.0.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最好的JSON解析Java实现是Gson，可以从谷歌的[http://code.google.com/p/google-gson/](http://code.google.com/p/google-gson/)获取，在Apache许可证2.0下发布。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'First, you''ll need to get Gson; you can do this by doing a read-only checkout
    of the repository using SVN over HTTP with SVN by using the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要获取Gson；你可以通过使用以下命令，用SVN通过HTTP进行只读检出仓库来完成这个操作：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Of course, this assumes that you have a Java development kit ([http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html))
    and SVN (TortoiseSVN is a good client for Windows available at [http://tortoisesvn.net/downloads.html](http://tortoisesvn.net/downloads.html))
    installed. Many Java IDEs include support for SVN.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这假设你已经安装了一个Java开发工具包（[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)）和SVN（Windows上的TortoiseSVN是一个好的客户端，可在[http://tortoisesvn.net/downloads.html](http://tortoisesvn.net/downloads.html)获得）。许多Java
    IDE包括对SVN的支持。
- en: Once you check out the code, follow the instructions that come with it to build
    the Gson JAR file, and add the JAR file to your project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你检查了代码，按照随附的说明构建吉森JAR文件，并将JAR文件添加到你的项目中。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'To begin, you need to create a `com.google.gson.Gson` object. This class defines
    the interface you''ll use to convert between JSON and Java:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，你需要创建一个`com.google.gson.Gson`对象。这个类定义了你将用来在JSON和Java之间转换的接口：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `JsonObject` class defines the top-level object for containing a JSON object;
    you use its `get` and `add` methods to get and set attributes, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonObject`类定义了包含JSON对象的顶级对象；你使用它的`get`和`add`方法来获取和设置属性，像这样：'
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The Gson library uses the `JsonElement` class to encapsulate a single JSON
    value; it has the following methods that let you get the value contained in `JsonElement`
    as a plain Java type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 吉森库使用`JsonElement`类来封装单个JSON值；它有以下方法，可以让您将`JsonElement`中的值作为普通的Java类型获取：
- en: '`getAsBoolean`, which returns the value as `Boolean`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsBoolean`，返回值为`Boolean`'
- en: '`getAsByte`, which returns the value as `byte`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsByte`，返回值为`byte`'
- en: '`getAsCharacter`, which returns the value as `char`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsCharacter`，返回值为`char`'
- en: '`getAsDouble`, which returns the value as `double`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsDouble`，返回值为`double`'
- en: '`getAsFloat`, which returns the value as `float`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsFloat`，返回值为`float`'
- en: '`getAsInt`, which returns the value as `int`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsInt`，返回值为`int`'
- en: '`getAsJsonArray`, which returns the value as `JsonArray`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsJsonArray`，返回值为`JsonArray`'
- en: '`getAsJsonObject`, which returns the value as `JsonObject`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsJsonObject`，返回值为`JsonObject`'
- en: '`getAsLong`, which returns the value as `long`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsLong`，返回值为`long`'
- en: '`getAsShort`, which returns the value as `short`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsShort`，返回值为`short`'
- en: '`getAsString`, which returns the value as `String`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsString`，返回值为`String`'
- en: 'You can also learn about the type in `JsonElement` using one of the following
    methods:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下方法之一了解`JsonElement`中的类型：
- en: '`isJsonArray`, which returns `true` if the element is an array of objects'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isJsonArray`，如果元素是一个对象数组则返回`true`'
- en: '`isJsonNull`, which returns `true` if the element is null'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isJsonNull`，如果元素为null则返回`true`'
- en: '`isJsonObject`, which returns `true` if the element is a composite object (another
    JSON tree) instead of a single type'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isJsonObject`，如果元素是一个复合对象（另一个JSON树）而不是单个类型则返回`true`'
- en: '`isJsonPrimitive`, which returns true if the element is a primitive type, such
    as a number or string'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isJsonPrimitive`，如果元素是基本类型，如数字或字符串，则返回`true`'
- en: There's more…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can also convert instances of your classes directly to JSON, writing something
    like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接将类的实例转换为JSON，像这样编写代码：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This defines a class `SimpleResult`, which we use to create a single instance,
    and then use the `Gson` object instance to convert to a string containing the
    JSON using the `Gson` method `toJson`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个`SimpleResult`类，我们用它来创建一个实例，然后使用`Gson`对象实例将转换为包含JSON的字符串，使用`Gson`方法的`toJson`。
- en: 'Finally, because `JsonElement` encapsulates a single value, you can also handle
    simple values expressed in JSON, like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为`JsonElement`封装了一个单独的值，你也可以处理表示为JSON的简单值，比如这样：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This converts the primitive value `3.14` in JSON to a Java `double`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将JSON中的原始值`3.14`转换为Java `double`。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: Like the C# example, you can convert directly from JSON to a plain old Java
    object (POJO) in a type-safe manner. You'll see how to do this in [Chapter 7](ch07.html
    "Chapter 7. Using JSON in a Type-safe Manner"), *Using JSON in a Type-safe Manner*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#示例类似，你可以直接从JSON转换为普通的旧Java对象（POJO），并以类型安全的方式进行转换。你将在[第7章](ch07.html "Chapter 7. Using
    JSON in a Type-safe Manner") *以类型安全的方式使用JSON*中看到如何做到这一点。
- en: There are other JSON conversion implementations for Java, too. For a complete
    list, see the list at [http://json.org/](http://json.org/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他针对Java的JSON转换实现。要获取完整列表，请查看[http://json.org/](http://json.org/)上的列表。
- en: Reading and writing JSON in Perl
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Perl中读写JSON。
- en: Perl predates JSON, although there's a good implementation of JSON conversion
    available from CPAN, the Comprehensive Perl Archive Network.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Perl早于JSON，尽管CPAN有一个很好的JSON转换实现，即综合Perl存档网络（Comprehensive Perl Archive Network）。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To begin with, download the JSON module from CPAN and install it. Typically,
    you''ll download the file, unpack it, and then run the following code on a system
    that already has Perl and make configured:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从CPAN下载JSON模块并安装它。通常，你会下载文件，解压它，然后在已经配置了Perl和make的系统上运行以下代码：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s a simple example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单示例：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's look at the interface the JSON module provides.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看JSON模块提供的接口。
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The CPAN module defines the `decode_json` and `encode_json` methods to decode
    and encode JSON respectively. These methods interconvert between Perl objects,
    such as literal values and associative arrays, and strings containing JSON respectively.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: CPAN模块定义了`decode_json`和`encode_json`方法来分别解码和编码JSON。这些方法在Perl对象（如字面值和关联数组）和包含JSON的字符串之间进行相互转换。
- en: The code begins by importing the JSON and `Data::Dumper` modules. Next, it defines
    a single string, `$json`, which contains the JSON we want to parse.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先导入了JSON和`Data::Dumper`模块。接下来，它定义了一个单一字符串`$json`，其中包含我们要解析的JSON。
- en: With the JSON in `$json`, we define `%result` to be the associative array containing
    the objects defined in the JSON, and dump the values in the hash on the next line.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了JSON中的`$json`，我们定义`%result`为包含JSON中定义的对象的关联数组，并在下一行倾倒散列中的值。
- en: Finally, we re-encode the hash as JSON and print the results to the terminal.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将散列重新编码为JSON，并将结果输出到终端。
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: For more information and to download the JSON CPAN module, visit [https://metacpan.org/pod/JSON](https://metacpan.org/pod/JSON).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多信息并下载JSON CPAN模块，请访问[https://metacpan.org/pod/JSON](https://metacpan.org/pod/JSON)。
- en: Reading and writing JSON in Python
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中读写JSON。
- en: Python has had native support for JSON since Python 2.6 through the `json` module.
    Using the module is as simple as using the `import` statement to import the module
    and then accessing the encoder and decoder through the `json` object that it defines.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 2.6开始，Python就拥有对JSON的本地支持，通过`json`模块。使用该模块就像使用`import`语句导入模块一样简单，然后通过它定义的`json`对象访问编码器和解码器。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'Simply enter the following in your source code to be able to reference the
    JSON facility:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在源代码中输入以下内容，就可以引用JSON功能：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Here''s a simple example from the Python interpreter:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Python解释器中的一个简单示例：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's look at `loads` and `dumps` further.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看`loads`和`dumps`。
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python has great support for associative arrays through its object hierarchy.
    The `json` module offers a `json` object with `loads` and `dumps` method that
    convert from JSON in text strings to associative arrays, and from associative
    arrays to JSON in text strings. If you're familiar with the Python `marshal` and
    `pickle` modules, the interface is similar; you use the `loads` method to obtain
    a Python object from its JSON representation and the `dumps` method to convert
    an object into its JSON equivalent.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python** 语言通过其对象层次结构对关联数组提供了很好的支持。`json` 模块提供了一个 `json` 对象以及 `loads` 和 `dumps`
    方法，这些方法可将文本字符串中的 JSON 转换为关联数组，反之亦然。如果你熟悉 Python 的 `marshal` 和 `pickle` 模块，这个接口是相似的；你使用
    `loads` 方法从其 JSON 表示中获取 Python 对象，使用 `dumps` 方法将一个对象转换为其 JSON 等价物。'
- en: The previous listing does just this. It defines a variable `j` that contains
    our JSON, and then obtains a Python object `result` using `json.loads`. Fields
    in the JSON are accessible as named objects in the resulting Python object. (Note
    that we can't call our JSON string `json` because it would shadow the definition
    of the interface to the module.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表正是这样做。它定义了一个变量 `j` 来包含我们的 JSON 数据，然后使用 `json.loads` 获得一个 Python 对象 `result`。JSON
    中的字段作为命名的对象在生成的 Python 对象中是可访问的。（注意我们不能将我们的 JSON 字符串命名为 `json`，因为这会遮蔽模块接口的定义。）
- en: To convert to JSON, we use the `json.dumps` method. By default, `dumps` creates
    a compact machine-readable version of JSON with minimum whitespace; this is best
    used for over-the-wire transmissions or for storage in a file. When you're debugging
    your JSON, it helps to pretty-print it with indentation and some whitespace around
    separators; you can do this using the optional `indent` and `separators` arguments.
    The `indent` argument indicates the number of spaces that each successive nested
    object should be indented in the string, and `separators` indicates the separators
    between each object and between each attribute and value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换为 JSON，我们使用 `json.dumps` 方法。默认情况下，`dumps` 创建一个紧凑的、机器可读的 JSON 版本，最小化空白；这最适合用于网络传输或文件存储。当你在调试你的
    JSON 时，使用缩进和分隔符周围的一些空白来美化打印它是有帮助的；你可以使用可选的 `indent` 和 `separators` 参数来实现。`indent`
    参数指定了每个嵌套对象在字符串中应缩进的空格数，而 `separators` 参数指定了每个对象之间以及每个属性和值之间的分隔符。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more documentation on the `json` module, see the Python documentation at
    [https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `json` 模块的更多文档，请参阅 Python 文档中的 [https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)。
