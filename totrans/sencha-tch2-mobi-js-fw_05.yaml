- en: Chapter 5. Events and Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。事件和控制器
- en: In the previous chapter, we took a closer look at the components available in
    Sencha Touch. However, simply creating components isn't enough to build an application.
    The components still need to communicate with each other in order to make our
    application do anything truly useful. This is where events and controllers come
    into play.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细查看了Sencha Touch中可用的组件。然而，仅仅创建组件还不足以构建一个应用程序。组件仍然需要彼此通信，以便我们的应用程序做些真正有用的事情。事件和控制器就在这里发挥作用。
- en: 'In this chapter, we will examine events and controllers in Sencha Touch: what
    they are, why we need them, and how they work. We will discuss how to use listeners
    and handlers to make your application react to the user''s touch as well as to
    events happening behind the scenes. We will also cover some helpful concepts such
    as observable capture and event delegation. We will finish up with a walkthrough
    of the touch-specific events and a look at how you can get more information from
    the Sencha Touch API.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Sencha Touch中的事件和控制器：它们是什么，为什么我们需要它们，以及它们是如何工作的。我们将讨论如何使用监听器和处理程序使您的应用程序对用户的触摸以及后台发生的事件做出反应。我们还将介绍一些有用的概念，例如可观察的捕获和事件代理。最后，我们将通过查看触摸特定事件和如何从Sencha
    Touch API获取更多信息来完成本章。
- en: 'The chapter will cover the following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Listeners and handlers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听器和处理程序
- en: Controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: Listener options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听器选项
- en: Scope
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域
- en: Removing events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除事件
- en: Handlers and buttons
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序和按钮
- en: Common events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见事件
- en: Additional information on events
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于事件的其他信息
- en: Exploring events
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索事件
- en: As programmers, we tend to think of code as an orderly sequence of instructions,
    executing one line after another. It's easy to lose sight of the fact that our
    code really spends a lot of time sitting and waiting for the user to do something.
    It's waiting for the user to click on a button, open a window, or select from
    a list. The code is waiting for an event to occur.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们倾向于将代码视为一个有序的指令序列，逐行执行。很容易忽视的事实是，我们的代码实际上花费了很多时间坐着等待用户做些什么。它正在等待用户点击一个按钮，打开一个窗口，或者从列表中选择。代码正在等待一个事件的发生。
- en: Typically, an event occurs right before or immediately after a component performs
    a specific task. When the task is performed, the event is broadcasted to the rest
    of the system, where it can trigger a specific code or can be used by other components
    to trigger new actions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，事件发生在组件执行特定任务之前或立即之后。当任务执行时，事件被广播到系统其余部分，在那里它可以触发特定的代码，或者可以被其他组件用来触发新的动作。
- en: For example, a button in Sencha Touch will trigger an event whenever it is tapped.
    This tap can execute code inside the button that creates a new dialog box, or
    a panel component can "listen" to what the button is doing and change its color
    when it "hears" the button trigger a `tap` event.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Sencha Touch中，每当点击按钮时，按钮就会触发一个事件。这个点击可以执行按钮内的代码，创建一个新的对话框，或者一个面板组件可以“监听”按钮正在做什么，并在听到按钮触发`tap`事件时改变其颜色。
- en: Given that most applications are intended for human interaction, it's safe to
    say that a lot of the functionality of your programs will come from responding
    to events. From a user's perspective, the events are what make the program actually
    "do" something. The program is responding to the user's request.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数应用程序都是为了人机交互而设计的，所以说程序的大部分功能都来自于对事件的响应是安全的。从用户的角度来看，事件是使程序实际“做”事情的东西。程序正在响应用户的请求。
- en: In addition to responding to requests, events also have an important role to
    play in making sure that things happen in the correct order.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了响应请求外，事件在确保事情按正确顺序发生方面也起着重要的作用。
- en: Asynchronous versus synchronous actions
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步与同步操作
- en: 'Albert Einstein once remarked:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 爱因斯坦曾经说过：
- en: '"The only reason for time is so that everything doesn''t happen at once."'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 时间存在的唯一原因是让一切不同时发生。
- en: While this might seem like an offhand comment, it actually has a great deal
    of relevance when it comes to writing code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来像是一个随意的评论，但实际上在编写代码时与之有很大的关联。
- en: As we write our code in Sencha Touch, we are directing the web browser to create
    and destroy components on the user's screen. The obvious limitation of this process
    is that we can neither manipulate a component before it gets created nor after
    it's destroyed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha Touch中编写代码时，我们正在指导网络浏览器在用户的屏幕上创建和销毁组件。这个过程的明显限制是，我们既不能在组件创建之前操纵它，也不能在它被销毁之后操纵它。
- en: This seems pretty straightforward at first glance. You would never write a line
    of code that tries to talk to a component on the line before you actually create
    the component, so what's the problem?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来在第一眼似乎相当直接。你永远不会在实际创建组件之前写一行试图与组件交谈的代码，那么问题是什么？
- en: The problem has to do with asynchronous actions within the code. While most
    of our code will execute sequentially or in a synchronous fashion, there are a
    number of cases where we will need to send out a request and get back a response
    before we can proceed. This is especially true with web-based applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与代码中的异步动作有关。尽管我们的大部分代码将按顺序或以同步方式执行，但有许多情况我们需要发出一个请求并得到回应才能继续。这在基于web的应用程序中尤为正确。
- en: For example, let's say we have a line of code that builds a map using a request
    from Google Maps. We will need to wait until we have received a response from
    Google and render our map before we can start working on it. However, we don't
    want the rest of our application to freeze while we wait on the response. So we
    make an asynchronous request, one that happens in the background, while the rest
    of our application goes about its business.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一行代码，它使用来自Google地图的请求来构建一个地图。我们需要等待我们从Google那里得到回应并渲染我们的地图，然后我们才能开始在地图上工作。然而，我们不想让我们的应用程序的其他部分在我们等待回应时冻结。因此我们发起一个异步请求，这个请求在后台进行，而我们的应用程序的其他部分继续它的业务。
- en: Such asynchronous requests are called Ajax requests. **Ajax** stands for **Asynchronous
    JavaScript and XML**. If we configure one of our buttons to send out an AJAX request,
    the user can still do other things while the application is waiting for a response.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异步请求称为Ajax请求。"**Ajax**"代表**异步JavaScript和XML**。如果我们配置我们其中一个按钮发出一个AJAX请求，用户在应用程序等待回应时仍然可以执行其他操作。
- en: On the interface side of things, you will probably want to let the user know
    that we made the request and are currently waiting for a response. In most cases,
    this means displaying a loading message or an animated graphic.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面方面，你可能想要让用户知道我们已经发出了请求，并正在等待回应。在大多数情况下，这意味着显示一个加载信息或一个动画图形。
- en: Using events in Sencha Touch, we can show the loading graphic by tying into
    the `beforerequest` event in the Ajax component. Since we need to know when to
    make the loading message disappear, our component will wait for the `requestcomplete`
    event from our Ajax request. Once that event fires, we can execute some code to
    tell the loading message to go away. We can also use the `requestexception` event
    to inform the user whether errors occurred during the request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha Touch中使用事件，我们可以通过绑定到Ajax组件的`beforerequest`事件来显示加载图形。由于我们需要知道何时让加载信息消失，因此我们的组件将等待来自Ajax请求的`requestcomplete`事件。一旦这个事件触发，我们就可以执行一些代码来告诉加载信息消失。我们还可以使用`requestexception`事件来告知用户在请求过程中是否出现错误。
- en: Using this type of event-driven design allows you to respond quickly to the
    user's actions, without making them wait for some of the more time-consuming requests
    your code needs to perform. You can also use the events to inform the user about
    the errors. The key to events is getting your other components to "listen" for
    the event, and then telling them how to handle the information they receive.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种事件驱动的设计允许你快速响应用户的操作，而不需要让他们等待你的代码需要执行的一些更耗时的请求。你还可以用事件来告知用户关于错误的信息。事件的关键在于让你的其他组件“监听”到这个事件，然后告诉他们如何处理收到的信息。
- en: Adding listeners and handlers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加监听器和处理程序
- en: Every component in Sencha Touch has a long list of events that it generates.
    Given the number of components you will likely have in your application, you can
    expect a lot of chatter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个Sencha Touch组件都能生成一大串事件。** 鉴于你应用中可能会有大量的组件，你可以预期会有很多交互。'
- en: Imagine a party with 100 people, all having lots of different conversations.
    Now imagine trying to pick out all of the useful information from each conversation.
    It's impossible. You have to focus on a specific conversation in order to gather
    anything useful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个有100个人的聚会，每个人都在进行着许多不同的对话。现在想象一下，试图从每个对话中提取所有有用的信息。这是不可能的。你必须专注于某个特定的对话，才能收集到有用的信息。
- en: In the same way, components also have to be told what to listen for, or else
    our unfortunate partygoer would quickly be overwhelmed. Fortunately for us, there's
    a configuration for that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的，组件也需要被告知要监听什么，否则我们可怜的聚会参与者很快就会感到不知所措。幸运的是，我们有针对这一点的配置。
- en: 'The `listeners` configuration tells the component what events it needs to pay
    attention to. Listeners can be added like any other configuration option in Sencha
    Touch. For example, the configuration option on a panel might look like the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`listeners`配置告诉组件需要关注哪些事件。监听器可以像Sencha Touch中的任何其他配置选项一样添加。例如，面板的配置选项可能如下所示：'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This configuration option tells the panel to listen for the `singletap` event
    when the user taps once on the element (on the inside) of the panel. When the
    `singletap` event occurs, we execute the function listed in the `fn` configuration
    option (this is typically referred to as a handler). In this case, we pop up a
    message box with the message alert `Single Tap`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置选项告诉面板在用户在面板内部元素上单击一次时监听`singletap`事件。当`singletap`事件发生时，我们执行`fn`配置选项中列出的函数（这通常被称为处理程序）。在这种情况下，我们弹出一个带有消息警告`Single
    Tap`的消息框。
- en: 'Note that the items in our `listeners` configuration are always part of an
    object (curly braces on either side), even if there is only one event we are listening
    for. If we were to add a second event, it would look like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们`listeners`配置中的项目总是作为一个对象的一部分（无论是否只有一个事件我们正在监听），即使我们只监听一个事件也是如此。如果我们添加第二个事件，它将如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the event has no other properties, you can also shorten the event declaration
    like this: `hide: function(){ this.destroy(); }`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '如果事件没有其他属性，你也可以像这样缩短事件声明：`hide: function(){ this.destroy(); }`'
- en: 'We can also get information back from the listener and use it in our handler
    functions. For example, the `singletap` event sends back the `event` object, the
    DOM element that was clicked, and the `listener` object itself, if we have the
    following listener on a panel:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从监听器中获取信息并用在我们的处理函数中。例如，`singletap`事件会返回`event`对象，被点击的DOM元素以及我们如果在面板上有以下监听器的话，还会返回`listener`对象本身：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the user taps inside the panel, we will get a view on our console, something
    similar to this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在面板内单击时，我们将在控制台上获得一个视图，类似于以下内容：
- en: '![Adding listeners and handlers](img/748OS_05_1.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Adding listeners and handlers](img/748OS_05_1.jpg)'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Arguments for events**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件参数**'
- en: You will notice that certain values are passed to our event by default. These
    default values can be found in the Sencha Touch API event documentation for each
    component at [http://docs.sencha.com/touch/2.2.1/](http://docs.sencha.com/touch/2.2.1/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到某些默认值会被传递到我们的事件中。这些默认值可以在每个组件的[http://docs.sencha.com/touch/2.2.1/](http://docs.sencha.com/touch/2.2.1/)中找到。
- en: Each event will have its own default values. Select a component from the Sencha
    API documentation, and then click on `Events` at the top of the page to see a
    list of all events of the component. The description of each event will include
    its default arguments.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都将有它自己的默认值。选择一个组件从Sencha API文档，然后点击页面顶部的`Events`查看组件的所有事件。每个事件的描述将包括其默认参数。
- en: As you can see from the console, our `event` object contains a Unix `timeStamp`
    for when the tap occurred, the `pageX` and `pageY` coordinates of the tap itself,
    as well as the entire content of the `div` tag that was tapped. You may have also
    noticed that our `tap` event is referred to as a `mouseup` event in our debug
    output. In Sencha Touch, the `singletap` and `mouseup` events are aliases of one
    another. This preserves compatibility between the desktop browser's traditional
    `mouseup` event and the mobile browser's `singletap` event.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制台可以看出，我们的`event`对象包含了一个在单击发生时的Unix`timeStamp`，以及单击本身`pageX`和`pageY`坐标，还有被单击的`div`标签的整个内容。您可能还注意到我们的`tap`事件在我们的调试输出中被称为`mouseup`事件。在Sencha
    Touch中，`singletap`和`mouseup`事件是彼此的别名。这保留了与桌面浏览器传统的`mouseup`事件和移动浏览器`singletap`事件之间的兼容性。
- en: We can use all of this information inside our function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们函数内部使用所有这些信息。
- en: 'For this example, we will create a simple panel with a red container. Our `singletap`
    listener will change the size of the red box to match where we tap on the screen,
    as shown in the following code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个例子，我们将创建一个带有红色容器的简单面板。我们的`singletap`监听器将改变红色盒子的尺寸以匹配我们屏幕上的单击位置，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we run this code with the console open, we can see that the x and y coordinates
    of the location where we tap will appear in the console. Our box also grows or
    shrinks to match these values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开控制台运行这段代码，我们可以看到我们单击的位置的x和y坐标会在控制台出现。我们的盒子也会根据这些值来匹配大小。
- en: '![Adding listeners and handlers](img/748OS_05_2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Adding listeners and handlers](img/748OS_05_2.jpg)'
- en: 'As you can see in the preceding code, we listen for the `tap` event. We then
    grab the `container` component using `Ext.getCmp(''tapTarget'');`, and change
    the size of the red box based on the value we got back from the `tap` event:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面代码中看到的，我们监听了`tap`事件。然后我们使用`Ext.getCmp('tapTarget');`获取`container`组件，并根据从`tap`事件返回的值改变红色盒子的尺寸：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a very simple example of using events in Sencha Touch. However, most
    of our applications will typically do more than one simple thing. We can also
    use IDs and grab them with `Ext.getCmp()`. In a large application it gets very
    easy to accidentally create components with the same ID, or create a component
    with an ID that is already used by Sencha Touch. This will typically lead to the
    spiraling death of your application and much hair pulling.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用Sencha Touch事件的基本示例。然而，我们的大多数应用程序通常会做不止一件简单的事情。我们还可以使用ID和`Ext.getCmp()`获取它们。在大型应用程序中，不小心创建具有相同ID的组件或在已由Sencha
    Touch使用的ID创建组件是非常容易的。这通常会导致应用程序的螺旋死亡和大量扯头发。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As the best practice, it is a good idea to avoid IDs for addressing components.
    In the next few sections, we will begin showing you more reliable ways to address
    our various components.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种最佳实践，避免为 addressing components 使用ID是个好主意。在接下来的几节中，我们将开始向您展示更可靠的方法来引用我们各个组件。
- en: If we are going to build anything more complex than this kind of "one-trick
    pony", we probably want to start thinking about splitting our events and actions
    out into a proper controller, and find a better way to address our different components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算构建比这种“单招马”更复杂的应用程序，我们可能想要开始考虑将我们的事件和动作分离到适当的控制器中，并找到一种更好地引用我们不同组件的方法。
- en: Controllers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: In [Chapter 3](ch03.html "Chapter 3. Styling the User Interface"), *Styling
    the User Interface*, we talked a bit about the **Model View Controller** (**MVC**)
    architecture. This architecture splits our files out into datafiles (`Models`
    and `Stores`), interface files (`Views`), and files that handle functionality
    (`Controllers`). In this section, we will focus on the controller part of the
    MVC.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章 用户界面样式") *用户界面样式*中，我们稍微谈到了**模型视图控制器**（**MVC**）架构。这种架构将我们的文件划分为数据文件（`Models`和`Stores`）、界面文件（`Views`）以及处理功能（`Controllers`）的文件。在本节中，我们将重点关注MVC的控制器部分。
- en: At its most basic level, a controller assigns listeners and actions within the
    application. Unlike our previous example, where the single component is responsible
    for handling an event, the controller will handle the events for every component
    in our application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本层面上，控制器在应用程序中分配监听器和动作。与我们的前一个示例不同，在那里单个组件负责处理事件，控制器将处理我们应用程序中每个组件的事件。
- en: 'This division of labor offers a few different advantages when creating an application;
    they are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种劳动分工在创建应用程序时提供了几个不同的优势，如下所述：
- en: The code is easier to navigate when we know that our functions are all in the
    controller and separate from the display logic.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们知道我们的函数都在控制器中，并且与显示逻辑分离时，代码更容易导航。
- en: The controller offers an easier communications layer between the various display
    components in our application.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器为应用程序中各个显示组件提供了一个更简单的通信层。
- en: Controllers can be divided into separate files based on the functionality. For
    example, we can have a user controller that handles events and listeners for our
    user data and a separate company controller that handles events and listeners
    for our company data. This means that if a form for saving new users is not working
    correctly, we know which file to look at to try and find out the problem.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器可以根据功能划分为不同的文件。例如，我们可以有一个用户控制器，它处理用户数据的事件和监听器，还有一个单独的公司控制器，它处理公司数据的事件和监听器。这意味着如果一个用于保存新用户的表单不能正确工作，我们知道要查看哪个文件来尝试找出问题所在。
- en: 'Let''s take a look at an example to see what we are talking about. We will
    start with the basic starter application we generate from Sencha Cmd using the
    following command line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看我们在谈论什么。我们将从使用Sencha Cmd生成的基本启动应用程序开始，使用以下命令行：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Controllers](img/748OS_05_3.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Controllers](img/748OS_05_3.jpg)'
- en: The path will vary based on your setup, but this will give us the basic application
    we will add our controller to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 路径将根据您的设置而变化，但这将给我们提供我们将添加控制器的基本应用程序。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a review of the basics of Sencha Cmd and MVC, see [Chapter 3](ch03.html
    "Chapter 3. Styling the User Interface"), *Styling the User Interface*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想回顾一下Sencha Cmd和MVC的基础知识，请参见[第3章](ch03.html "Chapter 3. Styling the User Interface")，*用户界面样式*。
- en: 'If we look in the `app`/`controller` folder of our newly generated application,
    we will see that it is empty. Let''s start by creating a `Main.js` file here.
    Inside the new file, we will add:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们新创建的应用程序的`app`/`controller`文件夹，我们会发现它是空的。让我们先在这里创建一个`Main.js`文件。在新文件中，我们将添加：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This extends the base `Ext.app.Controller` component, but doesn''t really do
    anything else. Our controller needs to understand a few basic things in order
    to function correctly; they are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这扩展了基本的`Ext.app.Controller`组件，但其他什么也没做。我们的控制器需要理解一些基本的东西，以便正确地工作；它们如下：
- en: What pieces of the application does the controller control?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器控制了应用程序的哪些部分？
- en: What component events should it be listening to?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该监听哪些组件事件？
- en: What should it do when one of those events is fired?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其中一个事件被触发时，它应该做什么？
- en: The first part of this puzzle is handled by the references (`refs`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的第一部分是由引用（`refs`）处理的。
- en: Refs and control
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Refs and control
- en: The `refs` section uses the `ComponentQuery` syntax to create internal references
    to the components in your application. The `ComponentQuery` syntax allows us to
    find components based on ID, xtype, and any other configuration option.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`refs`部分使用`ComponentQuery`语法来创建对应用程序中组件的内部引用。`ComponentQuery`语法允许我们根据ID、xtype和其他任何配置选项来查找组件。'
- en: 'For example, we have a `Main.js` file in our `app/view` directory (it was automatically
    generated by Sencha Cmd). The `view` component has an `xtype` value of `main`.
    We can add this view file to our controller as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的`app/view`目录中有一个`Main.js`文件（它是由Sencha Cmd自动生成的）。`view`组件有一个`xtype`值为`main`。我们可以像以下这样将这个视图文件添加到我们的控制器中：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This tells our controller that it has control of the `TouchStart.views.Main`
    view file and that we will be referencing that particular component with a shorthand
    m(this is an utterly arbitrary name of our choice). By creating this reference,
    we automatically create a getter function for the component. This means that when
    we need to refer to this component elsewhere in the controller, for example if
    we need to add a new tab to our tab panel, we can just grab the component using
    `this.getMainView()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的控制器，它控制着`TouchStart.views.Main`视图文件，并且我们将用一个简写m（这是我们的选择）来引用这个特定的组件。通过创建这个引用，我们自动为该组件创建了一个getter函数。这意味着当我们在控制器中需要引用这个组件的其他地方时，例如如果我们需要向我们的标签面板添加一个新的标签，我们只需使用`this.getMainView()`来获取组件。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tip
- en: This is another spot where capitalization can attack without warning. You will
    notice that despite the fact that we named our reference with a lowercase `m`,
    the get function uses an uppercase `M`. If we had named our reference `mainPanel`,
    the get function would be `this.getMainPanel()`. The first letter will always
    be in uppercase.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里又是大小写可以悄无声息地攻击你的另一个地方。你会注意到，尽管我们用小写的`m`给我们的引用命名，但get函数使用的是大写的`M`。如果我们给我们的引用命名为`mainPanel`，get函数将是`this.getMainPanel()`。第一个字母总是是大写的。
- en: 'Let''s add some elements to our basic application to see exactly how this works.
    First we need to add a button to the `Main.js` view file. Inside our first panel
    (the one with the title), modify the items section as follows to add a button:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的基本应用程序添加一些元素，以确切了解这是如何工作的。首先我们需要在`Main.js`视图文件中添加一个按钮。在我们第一个面板（带有标题的那个）中，将项目部分修改如下以添加一个按钮：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that we don''t add a handler here this time, but we do have an `action`
    of `addtab`, which we will use to reference the button inside our controller:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们没有在这里添加处理程序，但我们确实有一个`action`的`addtab`，我们将用它来在我们的控制器中引用按钮：
- en: '![Refs and control](img/748OS_05_4.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Refs and control](img/748OS_05_4.jpg)'
- en: 'Back in our `Main.js` file located at `app/controller/`, we will add a `refs`
    and `control` section as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们位于`app/controller/`的`Main.js`文件，我们将添加一个`refs`和`control`部分如下：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now have a new reference for our button:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了按钮的新引用：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tip
- en: 'It should be noted that our `action` configuration on the button is totally
    arbitrary. We could call it `myPurposeInLife: ''addtab''` and it would make no
    difference to the component itself. We would have simply referenced the button
    as `addBtn: ''button[myPurposeInLife = addtab]''` in that case. The term `action`
    is typically used by convention but it is not a default configuration option for
    the button. It is simply a value that we will use to find the button later on
    in our controller using `ComponentQuery`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '需要注意的是，我们按钮上的`action`配置完全是任意的。我们可以称它为`myPurposeInLife: ''addtab''`，这对组件本身没有任何影响。在这种情况下，我们只是将按钮引用为`addBtn:
    ''button[myPurposeInLife = addtab]''`。术语`action`通常是按惯例使用的，但它不是按钮的默认配置选项。它只是我们稍后将在控制器中使用`ComponentQuery`查找按钮的值。'
- en: 'Now that we have our reference, we can use `addBtn` when we set our control.
    This `control` section is where we set a listener for this particular button:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了引用，我们可以在设置控制时使用`addBtn`。这个`control`部分是我们为这个特定按钮设置监听器的地方：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This `control` section says that we want our controller to listen to the tap
    event on the `addBtn button` and fire the `addNewTab` function when the user taps
    the button. Next, we need to add this `addNewTab` function at the bottom of our
    controller just after the `config` section (don''t forget to put a comma between
    the end of the `config` section and the new function), as shown in the following
    code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`control`部分表示我们希望我们的控制器监听`addBtn`按钮的轻触事件，并在用户轻触按钮时触发`addNewTab`函数。接下来，我们需要将这个`addNewTab`函数添加到我们控制器的底部，位于`config`部分之后（不要忘记在`config`部分的末尾和新的函数之间加上逗号），如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This function uses our `this.getMainView()` function to grab our main tab panel
    and add a new tab to it. When we click on the button now, we should get a new
    tab with a star icon and our HTML text:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用我们的`this.getMainView()`函数来获取我们的主标签面板，并向其添加一个新的标签。现在我们点击按钮，我们应该会看到一个带有星形图标和我们HTML文本的新标签：
- en: '![Refs and control](img/748OS_05_5.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Refs和control](img/748OS_05_5.jpg)'
- en: Each controller file can contain any number of views, references, and functions.
    However, it's often best to split your controllers into separate files based on
    the kind of data they handle (a controller for users, one for companies, another
    for messages, and so on). This code organization is entirely up to the coder,
    but it helps a great deal when trying to hunt down problems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器文件可以包含任意数量的视图、引用和函数。然而，通常最好将您的控制器根据它们处理的数据类型分成单独的文件（一个用于用户，一个用于公司，另一个用于消息，等等）。这种代码组织完全取决于程序员，但它有助于大大减少寻找问题的难度。
- en: Referencing multiple items with ComponentQuery
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ComponentQuery引用多个项目
- en: As we have seen in our previous examples, the `refs` section gives us shorthand
    reference names for our components and the `control` section lets us assign listeners
    and functions to our components. While we can use the control section to assign
    a single function to multiple components, the items we include in our `refs` section
    can only be singular. We cannot create a single reference for multiple components
    in our `refs` section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前的示例所看到的，`refs`部分为我们组件提供了简写式的引用名称，而`control`部分允许我们将监听器和函数分配给我们的组件。尽管我们可以使用`control`部分将单个函数分配给多个组件，但我们在`refs`部分包含的项目只能是单数的。我们无法在`refs`部分为多个组件创建一个单一的引用。
- en: However, we can get around this by using `Ext.ComponentQuery`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过使用`Ext.ComponentQuery`来解决这个问题。
- en: 'To demonstrate this, let''s take a look at a real-world example: a list of
    items, with buttons for adding, editing, and deleting. The **Add** button should
    always be enabled but the **Edit** and **Delete** buttons should only be active
    when something in the list is selected.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们来看一个真实世界的例子：一个带有添加、编辑和删除按钮的条目列表。**添加**按钮应该始终是可用的，而**编辑**和**删除**按钮只有在列表中选择了某个项目时才应该是活动的。
- en: '![Referencing multiple items with ComponentQuery](img/748OS_05_6.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![使用ComponentQuery引用多个项目](img/748OS_05_6.jpg)'
- en: 'We will create our list in a separate file called `PersonList.js` in the `view`
    folder, as shown in the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`PersonList.js`的列表，位于`view`文件夹中，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is similar to the list we created in [Chapter 5](ch05.html "Chapter 5. Events
    and Controllers"), *Events and Controllers*, except we have made it into a separate
    `view` component by using `Ext.define` and extending the `Ext.dataview.List` object.
    We could have simply made it part of our `Main.js` view file, but splitting it
    out allows us to define a custom `xtype` of `personlist`, which will make it easier
    to reference later on in our controller.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于我们在[第5章](ch05.html "第5章. 事件和控制器")，*事件和控制器*中创建的列表，只不过我们通过使用`Ext.define`并扩展`Ext.dataview.List`对象，将其变成了一个独立的`view`组件。我们本可以将它简单地作为我们的`Main.js`视图文件的一部分，但将其分离出来允许我们定义一个自定义的`xtype`为`personlist`，这将使我们在控制器中引用它变得更容易。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity, we have left `store` as part of our view instead
    of splitting it out into its own separate file in the `store` directory. We will
    talk about how that gets done in [Chapter 7](ch07.html "Chapter 7. Getting the
    Data Out"), *Getting the Data Out*, and [Chapter 8](ch08.html "Chapter 8. Creating
    the Flickr Finder Application"), *Creating the Flickr Finder Application*, where
    we cover stores and models.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将`store`作为我们视图的一部分，而不是将其分离到`store`目录中的单独文件中。我们将在[第7章](ch07.html "第7章. 获取数据")，*获取数据*和[第8章](ch08.html
    "第8章. 创建Flickr查找器应用程序")，*创建Flickr查找器应用程序*中讨论如何实现，其中我们将介绍存储和模型。
- en: 'Now that we have our `personlist` view, we need to add it into our `Main.js`
    view file. Let''s replace the second panel in the `Main.js` file (the one with
    the video link in it). The new panel will look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`personlist`视图，我们需要将其添加到我们的`Main.js`视图文件中。让我们替换`Main.js`文件中的第二个面板（其中包含视频链接的那个）。新面板将看起来像这样：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code creates a new panel with a `fit` layout and two items inside it. The
    first item is a toolbar docked at the top of the panel. The second item (down
    at the very bottom) is our `personlist` component.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个带有`fit`布局和两个项目的新面板。第一个项目是一个工具栏，固定在面板的顶部。第二个项目（在非常底部）是我们的`personlist`组件。
- en: 'The toolbar has its own items, which consist of three buttons with the text:
    `Add`, `Edit`, and `Delete`. Each of these buttons has its own individual `action`
    configuration, and the `Edit` and `Delete` buttons have an extra configuration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏有自己的项目，包括三个带有文本`添加`、`编辑`和`删除`的按钮。每个按钮都有自己的独立`action`配置，而`编辑`和`删除`按钮有一个额外的配置：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that like `action`, the `enableOnSelection` configuration is an arbitrary
    value and not a default configuration for a button component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`action`一样，`enableOnSelection`配置是任意值，而不是按钮组件的默认配置。
- en: The individual `action` configurations will let us assign functions to each
    of those buttons. The shared `enableOnSelection` configuration will allow us to
    grab both the `Edit` and `Delete` buttons with a single reference. Let's head
    back to our `Main.js` controller to see how this works.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 单个`action`配置将允许我们将函数分配给每个按钮。共享的`enableOnSelection`配置将允许我们用一个引用抓取`编辑`和`删除`按钮。让我们回到我们的`Main.js`控制器看看这是如何工作的。
- en: 'The first thing we want to do is let the `Main.js` controller know that it
    is responsible for our new `personlist` view. We do this by adding it to the list
    of `views` in our controller, as shown in the following code snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要做的是让`Main.js`控制器知道它负责我们的新`personlist`视图。我们通过将其添加到控制器中的`views`列表来实现，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we need to create our references in the `refs` section, as shown in the
    following code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`refs`部分创建我们的引用，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will then modify our `control` section to look as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将修改我们的`control`部分，使其如下所示：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we have set our `personList` component to listen for the `select` event
    and fire the `enableItemButtons` function when the event occurs. We have also
    assigned a single `tempFunction` function to the `tap` event of our three buttons.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`personList`组件设置为监听`select`事件，并在事件发生时触发`enableItemButtons`函数。我们还为我们的三个按钮的`tap`事件分配了一个单独的`tempFunction`函数。
- en: 'Our `tempFunction` is added after the existing `addNewTab` function and looks
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`tempFunction`在现有的`addNewTab`函数之后添加，如下所示：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is just a placeholder function for demonstration purposes (we will cover
    adding, editing, and deleting actions in more detail in [Chapter 7](ch07.html
    "Chapter 7. Getting the Data Out"), *Getting the Data Out*, and [Chapter 8](ch08.html
    "Chapter 8. Creating the Flickr Finder Application"), *Creating the Flickr Finder
    Application* ). For now, this temporary function just logs the arguments that
    are sent to it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了演示目的而暂时使用的函数（我们将在[第7章](ch07.html "第7章。获取数据")，*获取数据*和[第8章](ch08.html "第8章。创建Flickr查找器应用程序")，*创建Flickr查找器应用程序*中更详细地介绍添加、编辑和删除操作）。现在，这个临时函数只是记录发送给它的参数。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `arguments` variable is a special variable in JavaScript and it contains
    many variables that are passed to the function. It's great for use with console
    logs where you might not be clear on which variables your function is receiving,
    their order, or their format.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`arguments`是一个特殊的变量，它包含了传递给函数的许多变量。这对于使用控制台日志来说非常棒，因为你可能不清楚你的函数接收到的变量，它们的顺序，或者它们的格式。
- en: 'The second function will handle our list selection:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数将处理我们的列表选择：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we noted previously, we cannot simply create a `refs` listing for our two
    disabled buttons. If we had tried `myButtons: ''button[enableOnSelection]''` in
    our `refs` section, we would only get back the first one.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们之前所提到的，我们不能简单地为我们的两个禁用按钮创建一个`refs`列表。如果我们尝试在我们的`refs`部分使用`myButtons: ''button[enableOnSelection]''`，我们只能得到第一个按钮。'
- en: However, we can use the exact same selector with `Ext.ComponentQuery.query('button[enableOnSelection]');`
    and get back both of our buttons as an array of button objects. We can then use
    `Ext.each` to step through each of the buttons in turn and run a function on them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用完全相同的选择器`Ext.ComponentQuery.query('button[enableOnSelection]');`，得到两个按钮作为一个按钮对象的数组。然后我们可以使用`Ext.each`逐一遍历每个按钮，并在它们上面运行一个函数。
- en: In this case, we just run `button.enable();` on each button. Now when an item
    is selected in the list, both of our buttons will be enabled.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是在每个按钮上运行`button.enable();`。现在当列表中选择一个项目时，我们的两个按钮都将被启用。
- en: '![Referencing multiple items with ComponentQuery](img/748OS_05_7.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![使用ComponentQuery引用多个项目](img/748OS_05_7.jpg)'
- en: By using `Ext.ComponentQuery`, a single event can easily affect multiple components
    based on their attributes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Ext.ComponentQuery`，一个事件可以轻松地根据它们的属性影响多个组件。
- en: Getting more out of events
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从事件中获取更多内容
- en: Now that we have seen how events and controllers fit together, we need to take
    a look at the other uses and options available to us with events.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了事件和控制器是如何结合在一起的，我们需要看看事件的其他用途和可用选项。
- en: Custom events
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义事件
- en: While Sencha Touch components respond to a large number of events, it can sometimes
    be helpful to fire custom events within your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Sencha Touch组件响应大量的事件，但有时在应用程序内部触发自定义事件可能会有所帮助。
- en: 'For example, you could fire a custom event called `vikinginvasion`, which might
    trigger additional actions within your application. For this example, we will
    assume we have a component called `cmp`. We can fire events with this component
    simply by calling:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以触发一个名为`vikinginvasion`的自定义事件，这可能会触发你应用程序中的其他操作。在这个例子中，我们将假设我们有一个名为`cmp`的组件。我们可以通过调用这个组件来触发事件：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can then add a listener to any component in the `control` section of your
    controller for `vikinginvasion`, along with a function to handle the event. If
    we want to add the listener for our custom event to a component called `trebuchet`,
    it might look as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在控制器的`control`部分为`vikinginvasion`添加一个监听器，以及一个处理事件的函数。如果我们想为自定义事件添加监听器到名为`trebuchet`的组件，它可能如下所示：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also check a component to see if it has a specific listener, using
    the `hasListener()` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查一个组件是否具有特定的监听器，使用`hasListener()`方法：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are also a number of helpful options you can use to control how listeners
    will check for events.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多有用的选项，你可以使用它们来控制监听器如何检查事件。
- en: Exploring listener options
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索监听器选项
- en: 'For the most part, listeners can simply be configured with the event name,
    handler, and scope, but sometimes you need a bit more control. Sencha Touch provides
    a number of helpful options to modify how the listener works; they are:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，监听器可以通过事件名称、处理程序和作用域来配置，但有时你需要更多的控制。Sencha Touch提供了一系列有用的选项来修改监听器的工作方式；它们包括：
- en: '`delay`: This will delay the handler from acting after the event is fired.
    It is given in milliseconds.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`：这将延迟事件触发后处理程序的执行。它以毫秒为单位给出。'
- en: '`single`: This provides a one-shot handler that executes after the next event
    fires and then removes itself.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`single`: 这提供了一个一次性处理器，在下一个事件触发后执行，然后将自己移除。'
- en: '`buffer`: This causes the handler to be scheduled to run as part of an `Ext.util.DelayedTask`
    component. This means that if an event is fired, we wait a certain amount of time
    before we execute the handler. If the same event fires again within our delay
    time, we reset the timer before executing the handler (only once). This can be
    useful for monitoring the change event in a textfield—wait 300 ms after the user''s
    last change before firing the function for the event.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`：这会导致处理器作为`Ext.util.DelayedTask`组件的一部分被调度运行。这意味着如果一个事件被触发，我们在执行处理器之前等待一段时间。如果在我们的延迟时间内再次触发相同的事件，我们在执行处理器之前重置计时器（只执行一次）。这在对文本字段的变化事件进行监控时可能很有用——在用户最后一次更改后等待300毫秒才触发事件的功能。'
- en: '`element`: This allows us to specify a specific element within the component.
    For example, we can specify a body within a panel for a `tap` event. This would
    ignore taps to the docked items and only listen for a tap on the body of the panel.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element`：这允许我们在组件内指定一个特定的元素。例如，我们可以在面板的`tap`事件上指定一个正文。这将忽略附着项的点击，只监听面板正文的点击。'
- en: '`target`: This will limit the listener to the events coming from the target
    and it will ignore the same event coming from any of its children.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这将限制监听器仅接收来自目标的事件，并忽略来自其子元素的同类事件。'
- en: 'Using the different listener options, the code would look something like the
    following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的监听器选项，代码可能看起来像以下这样：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example would add a listener for `vikinginvasion` and execute a function
    called `handleInvasion` in this scope. The handler would only execute once, after
    a 100-millisecond delay. It would then remove itself from the component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将为`vikinginvasion`添加一个监听器，并在本作用域中执行一个名为`handleInvasion`的函数。处理器只会执行一次，在100毫秒的延迟后。然后将自己从组件中移除。
- en: 'If you are inside a controller, you can accomplish the same thing in the `control`
    section like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个控制器内，你可以这样在`control`部分完成同样的事情：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since we are setting options on the event listener for `vikinginvasion`, it
    becomes its own configuration object. In turn, our `handleInvasion` function becomes
    a configuration option called `fn`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`vikinginvasion`的事件监听器上设置选项，它变成了自己的配置对象。反过来，我们的`handleInvasion`函数变成了一个名为`fn`的配置选项。
- en: This basic list of configuration options gives you quite a bit of flexibility
    when adding listeners. However, there is one additional configuration option available
    in listeners that will require a bit more explanation. It's called `scope`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本的配置选项在添加监听器时给你带来了相当大的灵活性。然而，在监听器中还有一个可用的附加配置选项，需要稍作解释。它叫做`scope`。
- en: Taking a closer look at scope
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细查看作用域
- en: 'Within your handler function is a special variable called `this`. Usually,
    `this` refers to the component that fired the event, in which case, the `scope`
    would typically be set to `scope: this`. However, it''s possible to specify a
    different value for `scope` in your listener configuration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '在你的处理函数中有一个特殊的变量叫做`this`。通常，`this`指的是触发事件的组件，在这种情况下，`scope`通常设置为`scope: this`。然而，在监听器配置中指定`scope`的不同值是可能的：'
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we create a button called `btn` and a panel called `Mainpanel`. We then
    attach two listeners. The first one is on the button's `painted` event. This event
    fires as soon as the button is "painted" (appears) on screen. In this case, the
    function's scope is the `button` as we would expect by default.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在此我们创建了一个名为`btn`的按钮和一个名为`Mainpanel`的面板。然后附上两个监听器。第一个是在按钮的`painted`事件上。这个事件在按钮“绘制”（出现在）屏幕上时立即触发。在这种情况下，函数的作用域是`button`，这是我们可以预期的默认情况。
- en: The second is on the `tap` event for the `button`. The `tap` event has a `scope`
    of `Mainpanel`. This means that even though the listener is attached to the button,
    the function treats `this` as the `Mainpanel` component and not the button.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是在`button`的`tap`事件上。`tap`事件的`scope`是`Mainpanel`。这意味着，尽管监听器附着在按钮上，但函数将`this`视为`Mainpanel`组件，而不是按钮。
- en: While `scope` may be a hard concept to grasp, it is a very useful part of the
    listener configuration.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`scope`这个概念可能难以理解，但它是监听器配置中的一个非常实用的部分。
- en: Removing listeners
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除监听器
- en: Normally, listeners are removed automatically when a component is destroyed.
    However, sometimes you will want to remove the listener before the component is
    destroyed. To do so, you'll need a reference to the handler function you created
    the listener with.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当组件被销毁时，监听器会自动移除。然而，有时您会在组件被销毁之前想要移除监听器。为此，你需要一个你创建监听器时创建的处理函数的引用。
- en: 'So far, we''ve been using anonymous functions to create our listeners, but
    if we''re going to remove the listener, we have to do it a bit differently:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用匿名函数来创建我们的监听器，但如果我们想要移除监听器，我们需要稍有不同的方法：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This can be a good practice as it allows you to define the handler functions
    once and re-use them wherever you need them. It also allows you to remove the
    handler later:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好习惯，因为它允许你一次性定义处理函数，并在需要的地方重复使用它们。它还允许你稍后移除处理程序：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Sencha parlance, `on()` is an alias for `addListener()` and `un()` is an
    alias for `removeListener()`, meaning that they do the exact same thing. Feel
    free to use whichever you prefer, when dealing with events.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha的术语中，`on()`是`addListener()`的别名，而`un()`是`removeListener()`的别名，这意味着它们做完全相同的事情。在处理事件时，你可以自由选择使用你喜欢的方法。
- en: It should also be noted that listeners that are added as part of the `control`
    section of a controller are never removed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意的是，作为控制器`control`部分添加的监听器永远不会被移除。
- en: Using handlers and buttons
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用处理程序和按钮
- en: 'As you might have noticed from some of our previous code, buttons have a default
    configuration called `handler`. This is because the purpose of a button is generally
    to be clicked or tapped. The `handler` configuration is just useful shorthand
    for adding the `tap` listener. As such, the following two pieces of code do exactly
    the same thing:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能从我们之前的某些代码中注意到的，按钮有一个默认配置称为`handler`。这是因为按钮的一般目的是被点击或轻触。`handler`配置只是添加`tap`监听器的有用简写。因此，下面的两段代码完全相同：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next we will take a look at some common events.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一些常见事件。
- en: Exploring common events
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索常见事件
- en: Let's take a look at our old friend `Ext.Component` and see some of the common
    events available to us. Remember, since most of our components will inherit from
    `Ext.Component`, these events will be common across most of the components we
    use. The first of these events revolves around the creation of the component.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的老朋友`Ext.Component`，并了解一些我们可以使用的一些常见事件。记住，由于我们的大多数组件将继承自`Ext.Component`，这些事件将贯穿我们使用的大多数组件。这些事件中的第一个与组件的创建有关。
- en: When the web browser executes your Sencha Touch code, it writes the components
    into the web page as a series of `div`, `span`, and other standard HTML tags.
    These elements are also linked to the code within Sencha Touch that standardizes
    the look and functionality of the component for all supported web browsers. This
    process is commonly referred to as rendering the component. The event that governs
    this rendering in Sencha Touch is called `painted`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web浏览器执行你的Sencha Touch代码时，它将组件写入网页作为一系列`div`、`span`和其他标准HTML标签。这些元素还与Sencha
    Touch中的代码链接在一起，以标准化所有支持Web浏览器的组件的外观和功能。这个过程通常被称为渲染组件。在Sencha Touch中控制这个渲染的事件称为`painted`。
- en: 'Some other common events include:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些常见事件包括：
- en: '`show`: This is fired when the `show` method is used on the component'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`：当在组件上使用`show`方法时触发'
- en: '`hide`: This is fired when the `hide` method is used on the component'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hide`：当在组件上使用`hide`方法时触发'
- en: '`destroy`: This is fired when the component is destroyed'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy`：当组件被销毁时触发'
- en: '`disabledchange`: This is fired when the `disabled` configuration is changed
    by `setDisabled`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disabledchange`：当通过`setDisabled`更改`disabled`配置时触发'
- en: '`widthchange`: This is fired when `setWidth` is called on the component'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widthchange`：当在组件上调用`setWidth`时触发'
- en: '`heightchange`: This is fired when `setHeight` is called on the component'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightchange`：当在组件上调用`setHeight`时触发'
- en: These events provide a way to base the actions of your code on what is being
    done by, or done to, your components.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件为您提供了一种基于组件正在执行或对组件执行的操作来编写代码的方法。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Every event whose name ends with `changed` is fired as a result of a `config`
    option that has changed; for example, `setWidth`, `setHeight`, and `setTop`. Although
    listening to these events is like listening to any other event, it is useful to
    know this convention.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 名称以`changed`结尾的每个事件都是由于`config`选项已更改而触发的；例如，`setWidth`、`setHeight`和`setTop`。虽然监听这些事件与监听任何其他事件类似，但了解这个约定是有用的。
- en: Each component will also have some specific events associated with it. For a
    list of these events, please consult the documentation available at [http://docs.sencha.com/touch/2.2.1](http://docs.sencha.com/touch/2.2.1).
    Select a component from the list on the left-hand side and click on the **Events**
    button at the top of the page.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件还将有一些与之关联的特定事件。有关这些事件的列表，请参阅可用的文档[http://docs.sencha.com/touch/2.2.1](http://docs.sencha.com/touch/2.2.1)。在左侧列表中选择一个组件，然后点击页面顶部的**事件**按钮。
- en: Additional information
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息
- en: information about events is the Sencha Docs at [http://docs.sencha.com/touch/2.2.1](http://docs.sencha.com/touch/2.2.1).
    Select a component in the list on the left, and look for the **Events** button
    at the top. You can click on **Events** to go to the beginning of the section
    or hover your mouse pointer to see the full list of events and select a specific
    event from that list.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于事件的信息可以在Sencha Docs中找到[http://docs.sencha.com/touch/2.2.1](http://docs.sencha.com/touch/2.2.1)。在左侧列表中选择一个组件，然后在顶部寻找**事件**按钮。您可以点击**事件**以跳转到该部分的开始，或者将鼠标悬停在上面以查看完整的事件列表并从中选择特定事件。
- en: Clicking on the down arrow next to the event will display a list of parameters
    for the event and any available examples on how the event can be used.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 点击事件旁边的向下箭头将显示事件的参数列表以及关于如何使用事件的任何可用示例。
- en: Another good place to find out about touch-specific events is the Kitchen Sink
    example application ([http://dev.sencha.com/deploy/touch/examples/kitchensink/](http://dev.sencha.com/deploy/touch/examples/kitchensink/)).
    Inside the application is a **Touch Events** section. This section allows you
    to tap or click on the screen to see which events are generated from the different
    taps and gestures.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个了解触摸特定事件的好地方是Kitchen Sink示例应用程序([http://dev.sencha.com/deploy/touch/examples/kitchensink/](http://dev.sencha.com/deploy/touch/examples/kitchensink/))。在应用程序中有一个**触摸事件**部分。这个部分允许您轻触或点击屏幕以查看不同轻触和手势生成的哪些事件。
- en: The WebKit team at Sencha Touch has also created an event recorder for Android.
    You can find more information at [http://www.sencha.com/blog/event-recorder-for-android-web-applications/](http://www.sencha.com/blog/event-recorder-for-android-web-applications/).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch的WebKit团队还创建了一个用于Android的事件记录器。您可以在[http://www.sencha.com/blog/event-recorder-for-android-web-applications/](http://www.sencha.com/blog/event-recorder-for-android-web-applications/)找到更多信息。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered a basic overview of events, and how to use
    listeners and handlers to get your program to respond to these events. We took
    a deeper look at controllers and how they use references and the `control` section
    to attach listeners to components. We covered `Ext.ComponentQuery()` for grabbing
    components inside the event handlers. We talked about custom events, handlers
    in buttons, and listed some of the common events.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了事件的基本概述，以及如何使用监听器和处理程序使程序对这些事件做出响应。我们深入探讨了控制器及其如何使用引用和`control`部分来附加监听器到组件。我们介绍了`Ext.ComponentQuery()`，用于在事件处理程序中获取组件。我们谈论了自定义事件、按钮中的处理程序，并列出了一些常见事件。
- en: In the next chapter, we will cover how to get and store data in Sencha Touch,
    using JSON, data stores, models, and forms.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何在Sencha Touch中获取和存储数据，使用JSON、数据存储、模型和表单。
