- en: '*Chapter 8*: Testing – Unit and Integration'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：测试 – 单元和集成'
- en: Code isn't created until the respective tests have been written. Since you're
    reading this chapter, I'll assume we can agree on that statement. However, you
    might wondering, why haven't we written any tests? Fair enough.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在相应的测试编写完成后才会创建。既然你正在阅读这一章，那么我可以假设我们可以同意这个观点。然而，你可能想知道，为什么我们一个测试都没有编写呢？这是可以理解的。
- en: We chose not to do this because we believe it would make the content harder
    to absorb. Since we wanted to keep you focused on learning Deno while building
    an application, we decided not to do this. The second reason is that we truly
    wanted a full chapter focused on testing; that is, this one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择不这样做，因为我们认为这会让内容更难吸收。由于我们希望你在构建应用程序的同时专注于学习Deno，所以我们决定不这样做。第二个原因是，我们确实希望有一个完整的章节专注于测试；即这一章。
- en: 'Testing is a very important part of the software life cycle. It can be used
    to save time, to clearly state requirements, or just because you want to feel
    confident in rewriting and refactoring later. Independent of the motivation, one
    thing is certain: you''ll write tests. I also truly believe that testing plays
    a big role in software design. Code that is easy to test is likely easy to maintain.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件生命周期中的一个非常重要的部分。它可以用来节省时间，明确需求，或者只是因为你希望在以后重新编写和重构时感到自信。无论动机是什么，有一点是肯定的：你会编写测试。我也真心相信测试在软件设计中扮演着重要的角色。容易测试的代码很可能容易维护。
- en: Since we're great advocates of the importance of testing, we couldn't consider
    this a complete guide to Deno without learning about it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们非常倡导测试的重要性，所以我们不能不学习它就认为这是一本完整的Deno指南。
- en: In this chapter, we'll write different kinds of tests. We'll start with unit
    tests, which are very valuable tests for the developer and maintenance life cycle.
    Then, we'll move on to integration tests, where we'll run the app and perform
    a few requests on it. We'll finish by using the client we wrote in the previous
    chapter. We'll do all of this while adding tests to the application we previously
    built, going step by step, and making sure the code we previously wrote is working
    properly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将编写不同类型的测试。我们将从单元测试开始，这对于开发者和维护周期来说是非常有价值的测试。然后，我们将进行集成测试，在那里我们将运行应用程序并对其执行几个请求。最后，我们将使用在前一章中编写的客户端。在这个过程中，我们将向之前构建的应用程序添加测试，一步一步地进行，并确保我们之前编写的代码正常工作。
- en: This chapter will also demonstrate how some of the architectural decisions we
    made at the beginning of this book will pay off. This will be an introduction
    to how we can write simple mocks and clean, focused tests using Deno and its toolchain.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将展示我们在这本书的开始时做出的某些架构决策将如何得到回报。这将是介绍我们如何使用Deno及其工具链编写简单的模拟和干净、专注的测试的入门。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍以下主题：
- en: Writing your first test in Deno
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Deno中编写你的第一个测试
- en: Writing an integration test
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: Testing the web server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试网络服务器
- en: Creating integration tests for the application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序创建集成测试
- en: Testing the API together with the client
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一起测试API和客户端
- en: Benchmarking parts of the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试应用程序的部分
- en: Let's get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code that will be used in this chapter can be found at [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将使用的代码可以在 [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections)
    找到。
- en: Writing your first test in Deno
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Deno中编写你的第一个测试
- en: Before we start writing our test, it's important to remember a few things. The
    most important of them is, why are we testing?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，记住一些事情是很重要的。其中最重要的原因是，我们为什么要测试？
- en: There might be multiple answers to this question, but most of them will gesture
    toward guaranteeing that the code is working. You might also say that you use
    them so that you have flexibility when it comes to refactoring, or that you value
    having short feedback cycles when it comes to implementation – we can agree to
    both of these. Since we didn't write a test before implementing these features,
    the latter doesn't apply too much to us.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，可能会有多个答案，但大多数都会指向保证代码正在运行。你也可能说，你使用它们以便在重构时具有灵活性，或者你重视在实施时拥有短暂的反馈周期——我们可以同意这两点。由于我们在实现这些功能之前没有编写测试，所以后者对我们来说并不适用。
- en: 'We''ll keep these objectives in mind throughout this chapter. In this section,
    we''ll write our first test. We''ll use the application we wrote in the previous
    chapters and add tests to it. We''ll write two types of tests: integration and
    unit tests.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将保持这些目标。在本节中，我们将编写我们的第一个测试。我们将使用在前几章中编写的应用程序并为其添加测试。我们将编写两种类型的测试：集成和单元测试。
- en: Integration tests will test how different components of the application interact.
    Unit tests test layers in isolation. If we think of it as a spectrum, unit tests
    are closer to the code, while integration tests are closer to the user. On the
    very end of the user side, there are also end-to-end tests. Those are the tests
    that test the application by emulating the user behavior, which we won't cover
    in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试将测试应用程序不同组件之间的交互。单元测试测试隔离的层。如果我们把它看作是一个光谱，那么单元测试更接近代码，而集成测试更接近用户。在用户端的尽头，还有端到端测试。这些测试通过模拟用户行为来测试应用程序，我们将在本章不涉及这些内容。
- en: 'Parts of the patterns we used when developing the actual application, such
    as dependency injection and inversion of control, are of great use when it comes
    to testing. Since we developed our code by injecting all its dependencies, now,
    it''s just a matter of mocking those dependencies on tests. Remember: code that
    is easy to test is normally easy to maintain.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开发实际应用程序时使用的部分模式，如依赖注入和控制反转，在测试时非常有用。由于我们的代码通过注入其所有依赖关系来开发，现在，只需在测试中模拟这些依赖关系即可。记住：易于测试的代码通常也易于维护。
- en: The first thing we'll do is write tests for the business logic. Currently, since
    our API is quite simple, it doesn't have much business logic. Most of it is living
    on `UserController`, since `MuseumController` is very simple. We'll start with
    the latter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是为业务逻辑编写测试。目前，由于我们的 API 相当简单，所以它没有太多的业务逻辑。大部分都存在于`UserController`中，因为`MuseumController`非常简单。我们从后者开始。
- en: 'To write tests in Deno, we''ll need to use the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Deno 中编写测试，我们需要使用以下内容：
- en: The Deno test runner (covered in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第 2 章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)，*工具链*中介绍的 Deno 测试运行器
- en: The `test` method from the Deno namespace ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test))
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Deno 命名空间的`test`方法([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test))
- en: The assertion methods from the Deno standard library ([https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts](mailto:https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts))
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Deno 标准库的断言方法([https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts](mailto:https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts))
- en: These are all part of Deno, distributed and maintained by the core team. There
    are many other libraries that can be used in tests that you can find in the community.
    We'll use what's provided by default in Deno as it works just fine and allows
    us to write clear and readable tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是 Deno 的组成部分，由核心团队分发和维护。社区中还有许多其他可以在测试中使用的库。我们将使用 Deno 中提供的默认设置，因为它工作得很好，并允许我们编写清晰易读的测试。
- en: Let's go and learn how we can define a test!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去学习我们如何定义一个测试！
- en: Defining a test
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义测试
- en: Deno provides an API to define tests. This API, `Deno.test` ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)),
    provides two different ways to define a test.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 提供了一个定义测试的 API。这个 API，`Deno.test` ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test))，提供了两种不同的定义测试的方法。
- en: 'One of them is the one we showed in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*, and consists of calling it with two arguments; that is, the test
    name and a test function. This can be seen in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个是我们在[第 2 章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)*中所展示的*，*工具链*，由两部分组成；也就是说，测试名称和测试函数。这可以在以下示例中看到：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The other way we can do this is by calling the same API, this time sending
    an object as an argument. You can send the function and the name of the test,
    plus a few other options, to this object, as you can see in the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做另一种方式是调用相同的 API，这次发送一个对象作为参数。 你可以发送函数和测试名称，以及几个其他选项，到这个对象，如你在以下示例中所见：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These flags behaviors are very well-explained in the documentation ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)),
    but here''s a summary for you:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志行为在文档中解释得非常清楚([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test))，但这里有一个总结供您参考：
- en: '`only`: Runs only the tests that have this set to `true` and makes the test
    suite fail, so this should only be used as a temporary measure.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`only`：只运行设置为`true`的测试，并使测试套件失败，因此这应该只用作临时措施。'
- en: '`sanitizeOps`: Makes the test fail if all the operations that started on Deno''s
    core are not successful. This flag is `true` by default.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sanitizeOps`：如果Deno的核心启动的所有操作都不成功，则测试失败。这个标志默认是`true`。'
- en: '`sanitizeResources`: Makes the test fail if there are still resources running
    after the test finishes (this can indicate memory leaks). This flag makes sure
    tests have to have a teardown phase where resources are stopped, and is `true`
    by default.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sanitizeResources`：如果测试结束后仍有资源在运行，则测试失败（这可能表明内存泄漏）。这个标志确保测试必须有一个清理阶段，其中资源被停止，默认情况下是`true`。'
- en: Now that we know about the APIs, let's go write our first test – a unit test
    for the `MuseumController` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了API，那就让我们去编写我们的第一个测试——对`MuseumController`函数的单元测试。
- en: A unit test for MuseumController
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对MuseumController的单元测试
- en: In this section, we'll be writing a very simple test that will cover only the
    functionality we wrote in `MuseumController`, and no more.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个非常简单的测试，它将只涵盖我们在`MuseumController`中编写的功能，不多不少。
- en: 'It lists all the museums in the application, though it''s currently not doing
    much and is only working as a proxy for `MuseumRepository`. We can create the
    test file and logic for this simple functionality by following these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它列出了应用程序中的所有博物馆，尽管目前它还没有做什么，只是作为`MuseumRepository`的代理工作。我们可以通过以下步骤创建这个简单功能的测试文件和逻辑：
- en: Create the `src/museums/controller.test.ts` file.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`src/museums/controller.test.ts`文件。
- en: The test runner will automatically consider files that have `.test` in their
    name as test files, among other conventions, as explained in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试运行器将自动将名称中包含`.test`的文件视为测试文件，以及其他在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)《工具链》中解释的约定，*章节目录*.
- en: 'Declare the first test with the help of `Deno.test` ([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test)):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Deno.test`([https://doc.deno.land/builtin/stable#Deno.test](https://doc.deno.land/builtin/stable#Deno.test))声明第一个测试：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, export the assertion methods from the standard library under a namespace
    named `t`, so that we can then use them on the test files, by adding the following
    to `src/deps.ts`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从标准库中导出断言方法，并将其命名空间命名为`t`，这样我们就可以在测试文件中使用它们，通过在`src/deps.ts`中添加以下内容：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to know what assertion methods are available in the standard library,
    check out [https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts](mailto:https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts).
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想了解标准库中可用的断言方法，请查看[https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts](mailto:https://doc.deno.land/https/deno.land/std@0.83.0/testing/asserts.ts)。
- en: 'You can now use the assertion methods from the standard library to write a
    test that instantiates `MuseumController` and calls the `getAll` method:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用标准库中的断言方法来编写一个测试，该测试实例化`MuseumController`并调用`getAll`方法：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s run the test and verify that it''s working:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行测试并验证它是否正常工作：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And our first test works!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试成功了！
- en: Note how the test's output lists the name of the test, its status, and the time
    it took to run, together with a summary of the test run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试输出如何列出测试的名称、状态以及运行所需的时间，同时还包括测试运行的摘要。
- en: The logic inside `MuseumController` is quite simple, thus this was also a very
    simple test. However, it isolated the controller's behavior, allowing us to write
    a very focused test. If you're interested in creating unit tests for other parts
    of the application, they're available in this book's repository ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MuseumController`内部的逻辑相当简单，因此这也一个非常简单的测试。然而，它隔离了控制器的行为，允许我们编写一个非常专注的测试。如果您对为应用程序的其他部分创建单元测试感兴趣，它们可以在本书的存储库中找到([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).'
- en: In the next few sections, we'll write more interesting tests. These are the
    tests that will teach us how to check the integration between the different modules
    of the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将编写更多有趣的测试。这些测试将教会我们如何检查应用程序不同模块之间的集成。
- en: Writing an integration test
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: Our first unit test, which we created in the previous section, relied on a mocked
    instance of the repository to guarantee that our controller was working. That
    test adds great value when it comes to detecting bugs in `MuseumController`, but
    it isn't worth much in terms of understanding if the controller works well with
    the repository.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节创建的第一个单元测试依赖于仓库的模拟实例，以保证我们的控制器正在工作。这个测试在检测`MuseumController`中的错误时增加了很大的价值，但它在了解控制器是否与仓库良好工作时并不重要。
- en: 'That''s the purpose of integration tests: they test how multiple components
    integrate with each other.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是集成测试的目的：它们测试多个组件如何相互集成。
- en: In this section, we'll write the integration test that tests `MuseumController`
    and `MuseumRepository`. These are the tests that will closely mimic what happens
    when the application runs and will help us later in terms of detecting any problems
    between these two classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个集成测试，用于测试`MuseumController`和`MuseumRepository`。这些测试将紧密模仿应用程序运行时发生的情况，并有助于我们后来在检测这两个类之间的任何问题时提供帮助。
- en: 'Let''s get started:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Create the file for this module's integration tests inside `src/museums`, called
    `museums.test.ts`, and add the first test case there.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums`中为这个模块的集成测试创建一个文件，称为`museums.test.ts`，并在其中添加第一个测试用例。
- en: 'It should test whether it is possible to get all the museums, this time using
    an instance of the repository instead of a mocked one:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该测试是否可以获取所有博物馆，这次使用仓库的实例而不是模拟的一个：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll start by instantiating the repository and adding a couple of fixtures
    there:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先实例化仓库并在其中添加几个测试用例：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have a repository, we can use it to instantiate the controller:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个仓库，我们可以用它来实例化控制器：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now write our assertions to make sure everything is working fine:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的断言，以确保一切正常工作：
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s run the test and check the result:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行测试并查看结果：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is passing! This is all we need for our repository and controller integration
    tests! This test is useful whenever we want to change the code in `MuseumController`
    or `MuseumRepository` as it makes sure they work fine together.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过了！这就是我们需要的仓库和控制器集成测试的全部！当我们要更改`MuseumController`或`MuseumRepository`中的代码时，这个测试很有用，因为它确保它们在一起工作时没有问题。
- en: Again, if you are curious about how integration tests for other parts of the
    application work, we made them available in this book's repository ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对应用程序其他部分的集成测试如何工作感到好奇，我们在这本书的仓库中提供了它们([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
- en: In the first section, we created a unit test, and here, we created an integration
    test, but we still haven't written any tests for our application's interface –
    the web part of it, which is using HTTP. That's what we'll do in the next section.
    We'll learn how can we test the logic living in the web layer in isolation, without
    using any other modules.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们创建了一个单元测试，在这里，我们创建了一个集成测试，但我们还没有为应用程序的界面编写任何测试——Web部分，它使用HTTP。那就是我们下一节要做的。我们将学习如何孤立地测试Web层中的逻辑，不使用任何其他模块。
- en: Testing the web server
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Web服务器
- en: So far, we have learned how to test different parts of the application. We started
    with the business logic, which tests how it integrated with the modules that interacted
    with persistency (the repository), but the web layer still has no tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何测试应用程序的不同部分。我们始于业务逻辑，它测试如何与与持久性（仓库）交互的模块集成，但Web层仍然没有测试。
- en: It's true that those tests are very important, but we can agree that if the
    web layer fails, the user will not have access to any of that logic.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，那些测试非常重要，但我们可以说，如果Web层失败，用户将无法访问任何逻辑。
- en: That's what we'll do in this section. We'll spin up our web server, mock its
    dependencies, and make a few requests to it to ensure the web *unit* is working.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本节中做的事情。我们将启动我们的web服务器，模拟其依赖项，并向其发送几个请求以确保web*单元*正在工作。
- en: 'Let''s start by creating the web module''s unit test by following these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建web模块的单元测试：
- en: Go to `src/web` and create a file named `web.test.ts`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`src/web`，并创建一个名为`web.test.ts`的文件。
- en: 'Now, in order to test the web server, we need to go back to the `createServer`
    function in `src/web/index.ts` and export the `Application` object it creates
    in `src/web/index.ts`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了测试web服务器，我们需要回到`src/web/index.ts`中的`createServer`函数，并导出它创建的`Application`对象：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We also want to be able to stop the application whenever we want. We haven't
    implemented that yet.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望能够在任何时候停止应用程序。我们还没有实现这一点。
- en: If we look at oak's documentation, we'll see that it's very well-documented
    ([https://github.com/oakserver/oak#closing-the-server](https://github.com/oakserver/oak#closing-the-server)).
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们查看oak的文档，我们会看到它非常完善([https://github.com/oakserver/oak#closing-the-server](https://github.com/oakserver/oak#closing-the-server))。
- en: To abort the application that's started by the `listen` method, we also need
    to return `AbortController`. So, let's do that at the end of the `createServer`
    function.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要取消由`listen`方法启动的应用程序，我们还需要返回`AbortController`。所以，让我们在`createServer`函数的最后这样做。
- en: 'If you aren''t aware of what `AbortController` is, I''ll leave you with a link
    from Mozilla Developers Network ([https://developer.mozilla.org/en-US/docs/Web/API/AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)),
    which explains it very clearly. The short version is that it allows us to cancel
    an ongoing promise:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不知道`AbortController`是什么，我将留下一个来自Mozilla开发者网络的链接([https://developer.mozilla.org/en-US/docs/Web/API/AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)),它解释得非常清楚。简而言之，它允许我们取消一个进行中的承诺：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note how we're instantiating `AbortController`, similar to the documentation's
    example, and returning it at the end, together with the `app` variable.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何实例化`AbortController`的，与文档中的示例类似，并在最后返回它，以及`app`变量。
- en: 'Back to our tests, let''s create a test that checks whether the server answers
    to `hello world`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的测试中，让我们创建一个测试，以检查服务器是否响应`hello world`：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s get an instance of the server running using the function we previously
    created; that is, `createServer`. Remember, to call this function, we must send
    its dependencies in. Here, we''ll have to mock them:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用之前创建的函数来启动服务器的实例；也就是说，`createServer`。记住，要调用这个函数，我们必须发送它的依赖项。在这里，我们需要模拟它们：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now create a test that checks whether the web server is working by answering
    the hello world request:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个测试，通过响应hello world请求来检查web服务器是否正常工作：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last thing we need to do is close the server once the test has run. Deno
    makes the test fail by default if we don''t do this (because `sanitizeResources`
    is `true` by default), as it would probably cause a memory leak:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是在测试运行后关闭服务器。Deno默认让我们测试失败，如果我们不做这件事（因为`sanitizeResources`默认是`true`），这可能会导致内存泄漏：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This wraps up our first test for the web layer! This was another unit test,
    and it tested the logic to spin up the server and ensured that Hello World is
    working. Next, we'll create more complete tests for the endpoints, together with
    the business logic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们web层的第一个测试结束！这是一个单元测试，它测试了启动服务器的逻辑，并确保Hello World运行正常。接下来，我们将为端点编写更完整的测试，包括业务逻辑。
- en: In the next section, we'll start writing integration tests for the login and
    register functionality. Those are a little more complex than the tests we wrote
    for the museum's module as they'll test the application as a whole, including
    its business logic, persistency, and web logic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始为登录和注册功能编写集成测试。这些测试比我们为博物馆模块编写的测试要复杂一些，因为它们将测试整个应用程序，包括其业务逻辑、持久性和web逻辑。
- en: Creating integration tests for the application
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序创建集成测试
- en: The three tests we've written so far have been unit tests for a single module,
    and an integration test between two different modules. However, to be confident
    that our code is working, it would be cool if we could test the application as
    a whole. That's what we'll do here. We'll wire up our application with a testing
    configuration and run a few tests against it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止编写的三个测试都是针对单一模块的单元测试以及两个不同模块之间的集成测试。然而，为了确信我们的代码正在工作，如果我们可以测试整个应用程序的话，那将会很酷。那就是我们在这里要做的。我们将用测试配置设置我们的应用程序，并对它运行一些测试。
- en: We'll start by calling the same function we called to initialize the web server
    and then create instances of all its dependencies (controllers, repositories,
    and so on). We'll make sure we use things such as in-memory persistence to do
    so. This will make sure that our tests are replicable and don't need a complex
    teardown phase or a connection to a real database, as that would slow down the
    tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用用于初始化Web服务器的同一个函数，然后创建所有其依赖项（控制器、存储库等）的实例。我们会确保使用诸如内存持久化之类的东西来做到这一点。这将确保我们的测试是可复制的，并且不需要复杂的拆卸阶段或连接到真实数据库，因为这将减慢测试速度。
- en: We'll start by creating a test file that, for now, will encompass the integration
    tests for the application. As the application evolves, it might make sense to
    create a test folder inside each module, but for now, this solution will work
    just fine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个测试文件开始，这个文件现在将包含整个应用程序的集成测试。随着应用程序的发展，可能很有必要在每个模块内部创建一个测试文件夹，但现在，这个解决方案将完全没问题。
- en: 'We''ll instantiate the application with a setup that''s very close to what
    it runs in production and make a few requests and assertions against it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与生产环境中运行的非常接近的设置实例化应用程序，并对它进行一些请求和断言：
- en: 'Create the `src/index.test.ts` file, alongside the `src/index.ts` file. Inside
    it, create a test declaration that tests that a user can log in:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`src/index.test.ts`文件，与`src/index.ts`文件并列。在它里面，创建一个测试声明，测试用户是否可以登录：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before we start writing this test, we''ll create a helper function that will
    set up the web server for testing. It will contain all the logic for instantiating
    controllers and repositories, as well as sending configuration into the application.
    It will look something like this:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始编写这个测试之前，我们将创建一个帮助函数，该函数将为测试设置Web服务器。它将包含实例化控制器和存储库的所有逻辑，以及向应用程序发送配置。它看起来像这样：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we''re doing here is very similar to the wiring logic we do in `src/index.ts`.
    The only difference is that we''ll explicitly import the in-memory repositories,
    not the MongoDB ones, as shown in the following code block:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里所做的是非常类似于我们在`src/index.ts`中做的布线逻辑。唯一的区别是，我们将显式导入内存存储库，而不是MongoDB存储库，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For us to have access to the in-memory repositories of the `Museums` and `Users`
    modules, we need to go into these modules and export them.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让我们能够访问`Museums`和`Users`模块的内存存储库，我们需要进入这些模块并将它们导出。
- en: 'This is what the `src/users/index.ts` file should look like:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是`src/users/index.ts`文件应该看起来像的样子：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a server instance using the helper function we just created, `createTestServer`,
    and use `fetch` to make a register request to the API:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们刚刚创建的帮助函数`createTestServer`创建一个服务器实例，并使用`fetch`向API发送注册请求：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we have access to the registered user, we can try to log in with that
    same user:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以访问注册的用户，我们可以尝试使用同一个用户登录：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are now ready to develop a few assertions to check whether our login response
    is what we were expecting:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备开发一些断言来检查我们的登录响应是否是我们预期的那样：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we need to call the `abort` function on our server:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的服务器上调用`abort`函数：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This was our first application integration test! We got the application to run,
    performed the register and login requests against it, and asserted that everything
    was working as expected. Here, we built the test step by step, but if you want
    to have a look at the complete test, it is available in this book's GitHub repository
    ([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次进行应用程序集成测试！我们让应用程序运行起来，对它执行注册和登录请求，并断言一切按预期进行。在这里，我们逐步构建了测试，但如果你想要查看完整的测试，它可在本书的GitHub仓库中找到（[https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts)）。
- en: 'To wrap this up, we''ll write another test. Remember that, in the previous
    chapter, we created some authorization logic that would only allow a logged in
    user to access the list of museums? Let''s check if that is working with another
    test:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本节，我们将再写一个测试。还记得在前一章节中，我们创建了一些授权逻辑，只允许已登录的用户访问博物馆列表吗？让我们用另一个测试来检查这个逻辑是否生效：
- en: 'Create another test inside `src/index.test.ts` that will test whether a user
    with a valid token can access the museums list:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/index.test.ts`中创建另一个测试，用于检测带有有效令牌的用户是否可以访问博物馆列表：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we want to log in and register again, we''ll extract those functions
    into a utility function that we can use in multiple tests:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想要再次登录和注册，我们将提取这些功能到一个我们可以用于多个测试的实用函数中：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With these functions, we can now refactor the previous test so that it looks
    a little cleaner, as the following snippet demonstrates:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些函数，我们现在可以重构之前的测试，使其看起来更简洁，如下面的代码段所示：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s get back to the test we were writing – the one that checks whether an
    authenticated user can access the museums – and use the `register` and `login`
    functions to register and authenticate a user:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们正在编写的测试——那个检查已认证用户是否可以访问博物馆的测试——并使用`register`和`login`函数来注册和认证一个用户：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can use the token that''s returned from the `login` function in the
    `Authorization` header to make an authenticated request:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`login`函数返回的令牌，在`Authorization`头中进行认证请求：
- en: '[PRE29]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a test that checks that a user can''t access the `museums` route without
    a valid token. It should be very similar to the previous test, with the small
    difference that we''re sending an invalid token now:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试，检查用户是否可以在没有有效令牌的情况下访问`museums`路由。它应该与之前的测试非常相似，只是我们现在发送一个无效的令牌：
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can run all the tests and confirm that they''re all green:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行所有测试并确认它们都通过了：
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is it for the application integration tests we're going to write in this
    book! If you want to find out more, then don't worry – all the code that's been
    written in this book regarding tests is available in this book's GitHub repository
    ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将要编写的应用程序集成测试就到这里为止！如果你想要了解更多，请不要担心——关于测试的所有代码都可在本书的GitHub仓库中找到（[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)）。
- en: We're now much more confident that our code is working. We've created the opportunity
    to refactor, extend, and maintain the code later with fewer worries. The architecture
    decisions we've made are paying off more and more when it comes to testing the
    code in isolation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对代码的信心大大增强。我们创造了机会，可以在以后更少的担忧下重构、扩展和维护代码。在隔离测试代码方面，我们所做的架构决策越来越显示出其价值。
- en: In the previous chapter, when we created our JavaScript client, we mentioned
    that one of the advantages of having it living in the API code base is that we
    could easily write tests for the client and the API to guarantee that they work
    well together. In the next section, we'll demonstrate how can we do this. These
    tests will be very much in line with what we did here, with the small difference
    that instead of using `fetch` and doing raw requests, we'll use the API client
    we created.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们创建我们的JavaScript客户端时，我们提到了将其保存在API代码库中的一个优点是，我们可以轻松地为客户端和API编写测试，以确保它们能很好地一起工作。在下一节中，我们将展示如何做到这一点。这些测试将与我们在这里所做的非常相似，唯一的区别是，我们使用的是我们创建的API客户端，而不是使用`fetch`进行原始请求。
- en: Testing the application together with the API client
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与应用和API客户端一起测试
- en: When you provide an API client to your users, you have the responsibility of
    making sure it works flawlessly with your application. One of the ways to guarantee
    this is by having a complete test suite, one that not only tests the client on
    its own but also tests its integration with the API. Here we'll take care of the
    latter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向用户提供API客户端时，你有责任确保它与你的应用程序完美配合。确保这种配合的一种方法是拥有一个完整的测试套件，不仅测试客户端本身，还测试它与API的集成。在这里我们将处理后者。
- en: 'We''ll use one feature of the API client and create a test that makes sure
    it''s working. Once again, you''ll notice some similarities between these and
    the tests we wrote at the end of the previous section. We''ll replicate the logic
    from the previous tests, but this time we''ll use the client. Let''s get started:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用API客户端的一个特性，并创建一个测试，确保它正在工作。再次，你会注意到这些测试与我们在上一部分末尾编写的测试有一些相似之处。我们将复制之前测试的逻辑，但这次我们将使用客户端。让我们开始吧：
- en: 'Inside the same `src/index.test.ts` file, create a new test for the login functionality:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个`src/index.test.ts`文件中，为登录功能创建一个新的测试：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For this test, we know that we'll need to get access to the API client. We'll
    need to import it from the `client` module.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了这次测试，我们知道我们需要访问API客户端。我们需要从`client`模块中导入它。
- en: 'Import the `getClient` function from `src/client/index.ts`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`src/client/index.ts`导入`getClient`函数：
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s get back to the `src/index.test.ts` test and import `client`, thus creating
    an instance of it. Remember that it should use the same address that the test
    web server created:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`src/index.test.ts`测试，导入`client`，从而创建一个它的实例。记住，它应该使用测试网络服务器创建的相同地址：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, it''s just a matter of writing the logic that calls the `register` and
    `login` methods using `client`. This is what the final test will look like:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需编写调用使用`client`的`register`和`login`方法的逻辑即可。最终测试将如下所示：
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note how we're using the client's methods to log in and register while keeping
    the assertions from the previous tests.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何使用客户端的方法进行登录和注册，同时保留来自先前测试的断言。
- en: By following the same guidelines, we can write tests for all the client's functionality,
    guaranteeing that it's working fine with the API, making it easy to maintain it
    with confidence.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循相同的指南，我们可以为客户端的所有功能编写测试，确保它与API一起正常工作，从而使我们能够自信地维护它。
- en: For brevity, and because these tests resemble the ones we previously written,
    we won't provide a step-by-step guide to writing tests for all the client's functionality
    here. However, if you're interested, you can find them in this book's GitHub repository
    ([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，而且因为这些测试类似于我们之前编写的测试，我们在这里不会提供为客户端所有功能编写测试的逐步指南。然而，如果你感兴趣，你可以在本书的GitHub存储库中找到它们([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter08/sections/7-final-tested-version/museums-api/src/index.test.ts)).
- en: In the next section, we'll have a sneak peek at one feature that might be further
    down the path of your applications. On day, you'll start having parts of the application
    that seem to be getting slow and you want to track their performance, and that's
    where performance tests are useful. Because of this, we'll be introducing benchmarks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍一个可能位于应用程序路径末端的特性。总有一天，你会发现应用程序的某些部分似乎变得很慢，你希望追踪它们的性能，这时性能测试就派上用场了。因此，我们将引入基准测试。
- en: Benchmarking parts of the application
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试应用程序的部分
- en: When it comes to writing benchmarks in JavaScript, the language itself provides
    a few functions, all of which are included in the High Resolution Time API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在JavaScript中编写基准测试时，该语言本身提供了一些函数，所有这些函数都包含在高级分辨率时间API中。
- en: As Deno is fully ES6 compatible, these same features are available. If you've
    had the time to look at Deno's standard library or the official website, you'll
    have seen that benchmarks are taken into a lot of consideration and are tracked
    across Deno versions ([https://deno.land/benchmarks](https://deno.land/benchmarks)).
    Upon checking Deno's source code, you will see that you have a very nice set of
    examples regarding how to write them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Deno完全兼容ES6，这些相同的功能都可以使用。如果你有时间查看Deno的标准库或官方网站，你会发现人们对基准测试给予了大量的关注，并且跟踪了Deno各个版本中的基准测试([https://deno.land/benchmarks](https://deno.land/benchmarks))。在检查Deno的源代码时，你会发现有关如何编写它们的非常不错的示例集。
- en: For our application, we could easily use the APIs available on the browser,
    but Deno itself provides functionality in the standard library to help with writing
    and running benchmarks, so that's what we'll use here.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们可以轻松地使用浏览器上可用的API，但Deno本身在其标准库中提供了功能，以帮助编写和运行基准测试，因此我们将在这里使用它。
- en: To start, we need to know Deno's standard library benchmark utilities so that
    we know what we can do ([https://github.com/denoland/deno/blob/ae86cbb551f7b88f83d73a447411f753485e49e2/std/testing/README.md#benching](https://github.com/denoland/deno/blob/ae86cbb551f7b88f83d73a447411f753485e49e2/std/testing/README.md#benching)).
    In this section, we'll write a very simple benchmark using two of the available
    functions; that is, `bench` and `runBenchmarks`. The first one will define a benchmark,
    while the second one will run it and print the result to the console.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解Deno的标准库基准测试工具，这样我们才知道我们可以做什么（[https://github.com/denoland/deno/blob/ae86cbb551f7b88f83d73a447411f753485e49e2/std/testing/README.md#benching](https://github.com/denoland/deno/blob/ae86cbb551f7b88f83d73a447411f753485e49e2/std/testing/README.md#benching)）。在本节中，我们将使用两个可用的函数编写一个非常简单的基准测试；即`bench`和`runBenchmarks`。第一个将定义一个基准测试，而第二个将运行它并将结果打印到控制台。
- en: 'Remember the function we wrote in [*Chapter 5*](B16380_05_Final_JM_ePub.xhtml#_idTextAnchor124),
    *Adding Users and Migrating to Oak*, to generate a hash and a salt, which enabled
    us to store the user credentials safely on the database? We''ll write a benchmark
    test for that by following these steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第5章](B16380_05_Final_JM_ePub.xhtml#_idTextAnchor124)《添加用户和迁移到Oak》中写的函数吗？该函数用于生成一个散列和一个盐，使我们能够将用户凭据安全地存储在数据库上。我们将按照以下步骤为此编写一个基准测试：
- en: To start, create a file alongside `src/users/util.ts` named `utilBenchmarks.ts`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src/users/util.ts`旁边创建一个名为`utilBenchmarks.ts`的文件。
- en: 'Import the two functions from `util` that we want to test; that is, `generateSalt`
    and `hashWithSalt`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们要测试的`util`中的两个函数，即`generateSalt`和`hashWithSalt`：
- en: '[PRE36]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It''s time to add the benchmark utilities to our `src/deps.ts` file and run
    the `deno cache` command (which we learned about in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*) and import it here. We''ll export it as `benchmark`, in `src/deps.ts`,
    to avoid naming conflicts:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将基准测试工具添加到我们的`src/deps.ts`文件中，并运行`deno cache`命令（我们在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)《工具链》中了解到它），在此处导入它。我们将把它作为`benchmark`导出到`src/deps.ts`中，以避免命名冲突：
- en: '[PRE37]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Import the benchmark utilities into our benchmarks file and write the first
    benchmark for the `generateSalt` function. We want it to run 1,000 times:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基准测试工具导入到我们的基准文件中，并为`generateSalt`函数编写第一个基准测试。我们希望它运行1000次：
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The only thing we''re missing is calling `runBenchmarks` once the benchmarks
    have been defined:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所缺少的就是在基准测试定义之后调用`runBenchmarks`：
- en: '[PRE39]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's time to run this file and have a look at the results.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候运行这个文件并查看结果了。
- en: 'Remember that we''re dealing with high resolution time as we want our benchmarks
    to be precise. To let this code have access to this system feature, we need to
    run this script with the `--allow-hrtime` permission (as explained in [*Chapter
    2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056), *The Toolchain*):'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，由于我们希望我们的基准测试精确，所以我们正在处理高级分辨率时间。为了让这段代码访问这个系统特性，我们需要以`--allow-hrtime`权限运行这个脚本（如[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)《工具链》中所解释）：
- en: '[PRE40]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s write the benchmark for the second function; that is, `hashWithSalt`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为第二个函数编写基准测试，即`hashWithSalt`：
- en: '[PRE41]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s run it so that we get the final result:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行它，以便我们得到最终结果：
- en: '[PRE42]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And that's it! You can now use the code we just wrote any time you want to analyze
    the performance of these functions. You may want to do this because you've changed
    this code or just because you want to have it closely tracked. You can integrate
    it in systems such as a continuous integration server, where you can regularly
    check these values and keep them on track.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在您可以随时使用我们刚刚编写的代码来分析这些函数的性能。您可能需要这样做，是因为您已经更改了此代码，或者只是因为您想对其进行严格跟踪。您可以将其集成到诸如持续集成服务器之类的系统中，这样您就可以定期检查这些值并保持其正常运行。
- en: This wraps up the benchmarks section of this book. We decided on giving it short
    introduction, and also demonstrating what APIs are available from on Deno to facilitate
    benchmarking needs.We believe the concepts and examples presented here will allow
    you to track how your applications are running.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分结束了本书的基准测试部分。我们决定给它一个简短的介绍，并展示从Deno获取的哪些API可以促进基准测试需求。我们相信，这里介绍的概念和示例将允许您跟踪应用程序的运行情况。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this chapter, we've closed the development cycle of the application we've
    been building. We started small by writing a few simple classes with our business
    logic, wrote the web server to it, and finished by integrating it with persistence.
    We finished this section by learning how to test the features we wrote, and that's
    what we did in this chapter. We decided on going with a few different types of
    tests, instead of extensively going module by module writing all the tests, as
    we believe that's where more value is added.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，我们已经完成了我们一直在构建的应用程序的开发周期。我们开始时编写了一些简单的类和业务逻辑，编写了web服务器，最后将其与持久化集成。我们通过学习如何测试我们编写的功能来结束这一部分，这就是我们在这章所做的。我们决定使用几种不同类型的测试，而不是深入每个模块编写所有测试，因为我们认为这样做会带来更多的价值。
- en: We started with a very simple unit test for the business logic, then moved on
    to an integration test with multiple classes, and later wrote a test for the web
    server. These tests can only be written by leveraging the architecture we've created,
    following dependency injection principles, and trying to keep the code as decoupled
    as possible.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为业务逻辑编写了一个非常简单的单元测试，然后进行了一个带有多个类的集成测试，后来编写了一个针对web服务器的测试。这些测试只能通过利用我们创建的架构、遵循依赖注入原则，并尽可能使代码解耦来编写。
- en: As the chapter proceeded, we moved on to integration tests, which closely mimic
    the que application as it will run in production, enabling us to improve the confidence
    we have in the code we just wrote. We created tests that instantiated the application
    with a testing setup that enabled us to spin up the web server with all the application
    layers (business logic, persistence, and web) and made assertions to it. In these
    tests, we could very confidently assert that the login and registry behaviors
    were working fine, as we made real requests to the API.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着章节的进展，我们转向了集成测试，这些测试紧密地模仿了将在生产环境中运行的队列应用程序，使我们能够提高对我们刚刚编写的代码的信心。我们创建了测试，这些测试通过测试环境实例化了应用程序，使我们能够启动带有所有应用程序层（业务逻辑、持久化和网络）的web服务器，并对它进行断言。在这些测试中，我们可以非常有信心地断言登录和注册行为是否正常工作，因为我们向API发送了真实的请求。
- en: To wrap up this chapter, we connected it to the previous one, where we wrote
    a JavaScript client for the API. We leveraged one of the big advantages of having
    the client living in the same codebase as the API and tested the client together
    with the application itself. This is a great way of guaranteeing that everything
    is working as expected, and that we can be confident when releasing changes in
    both the API and the client.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我们将它与前一章连接起来，我们在那一章为API编写了一个JavaScript客户端。我们利用了客户端与API位于同一代码库中的一个巨大优势，并一起测试了客户端及其应用程序。这是确保一切按预期工作，并在发布API和客户端更改时保持信心的一种很好的方式。
- en: This chapter tried to demonstrate how tests can be used in Deno to increase
    our confidence in the code we've written, as well as the value they bring when
    they're used to focus on simple outcomes. Tests like these will be of great use
    later when the application changes, as we can use them to add more features or
    improve the existing ones. Here, we learned how the test suite provided by Deno
    is more than enough to write clear, readable tests without any third-party packages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节试图展示如何在Deno中使用测试来提高我们对所编写代码的信心，以及当它们用于关注简单结果时所体现的价值。这类测试在应用更改时将非常有用，因为我们可以使用它们来添加更多功能或改进现有功能。在这里，我们了解到Deno提供的测试套件足以编写清晰、可读的测试，而无需任何第三方包。
- en: The next chapter will focus on one of the most important phases of application
    development; that is, deploying. We'll configure a very simple continuous integration
    environment where we can deploy the application to the cloud. This is a very important
    chapter as we'll also experience some of the advantages of Deno when it comes
    to its ease of deployment.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章节将关注应用开发过程中最重要的阶段之一，那就是部署。我们将配置一个非常简单的持续集成环境，在该环境中我们可以将应用部署到云端。这是一个非常重要的章节，因为我们还将体验到Deno在部署方面的某些优势。
- en: Excited to make your application available to users? So are we – let's go!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 迫不及待地想让你的应用供用户使用吗？我们也是——让我们开始吧！
