["```js\n// stuff.js\n// Export something we can call from another module...\nexport default function doStuff() {\n    console.log('doing stuff');\n}\n\n// main.js\n// Don't import \"doStuff()\" till the link\n// is clicked.\ndocument.getElementById('do-link')\n    .addEventListener('click', function(e) {\n        e.preventDefault();\n\n        // In ES6, it's just \"System.import()\" - which isn't easy\n        // to do across environments yet.\n        var loader = new traceur.runtime.BrowserTraceurLoader();\n        loader.import('stuff.js').then(function(stuff) {\n            stuff.default();\n        });\n    });\n```", "```js\n// delay.js\n\nvar i = 10000000;\n\n// Eat some CPU cycles, causing a delay in any\n// modules that import this one.\nconsole.log('delay', 'active');\nwhile (i--) {\n    for (let c = 0; c < 1000; c++) {\n\n    }\n}\nconsole.log('delay', 'complete');\n\n// main.js\n\n// Importing this module will block, because\n// it runs some expensive code.\nimport 'delay.js';\n\n// The link is displayed, and it looks clickable,\n// but nothing happens. Because there's no event\n// handler setup yet.\ndocument.getElementById('do-link')\n    .addEventListener('click', function(e) {\n        e.preventDefault();\n        console.log('clicked');\n    });\n```", "```js\n// component.js\nimport events from 'events.js';\n\n// A generic component...\nexport default class Component {\n\n    // When created, this component triggers an\n    // event. It also adds a listener for that\n    // same event, and does some expensive work.\n    constructor() {\n        events.trigger('CreateComponent');\n        events.listen('CreateComponent', () => {\n            var i = 100000;\n            while (--i) {\n                for (let c = 0; c < 100; c++) {}\n            }\n        });\n    }\n\n};\n\n// main.js\nimport Component from 'component.js';\n\n// A place to hold our created components...\nvar components = [];\n\n// Any time the add button is clicked, a new\n// component is created. As more and more components\n// are added, we can see a noticeable impact on\n// the overall latency of the system.\n// Click this button for long enough, and the browser\n// tab crashes.\ndocument.getElementById('add')\n    .addEventListener('click', function() {\n        console.clear();\n        console.time('event overhead');\n        components.push(new Component());\n        console.timeEnd('event overhead');\n        console.log('components', components.length);\n    });\n```", "```js\n// Eat some CPU cycles, and call other functions\n// to establish a profilable call stack...\nfunction whileLoop() {\n    var i = 100000;\n\n    while (--i) {\n        forLoop1(i);\n        forLoop2(i);\n    }\n}\n\n// Eat some CPU cycles...\nfunction forLoop1(max) {\n    for (var i = 0; i < max; i++) {\n        i * i;\n    }\n}\n\n// Eat less CPU cycles...\nfunction forLoop2(max) {\n    max /= 2;\n    for (var i = 0; i < max; i ++) {\n        i * i;\n    }\n}\n\n// Creates the profile in the \"profile\" tab\n// of dev tools.\nconsole.profile('main');\nwhileLoop();\nconsole.profileEnd('main');\n// 1177.9ms 1.73% forLoop1\n// 1343.2ms 1.98% forLoop2\n```", "```js\n// This function mutates the object that's\n// passed in as an argument.\nfunction withSideEffects(model) {\n    if (model.state === 'running') {\n        model.state = 'off';\n    }\n\n    return model;\n}\n\n// This function, on the other hand, does not\n// introduce side-effects because instead of\n// mutating the \"model\", it returns a new\n// instance.\nfunction withoutSideEffects(model) {\n    return Object.assign({}, model, model.state === 'off' ?\n        { state: 'running' } : {});\n}\n\nvar first = { state: 'running' },\n    second = { state: 'off' },\n    result;\n\n// We can see that \"withSideEffects()\" causes\n// some unexpected side-effects because it\n// changes the state of something that's used\n// elsewhere.\nresult = withSideEffects(first);\nconsole.log('with side effects...');\nconsole.log('original', first.state);\nconsole.log('result', result.state);\n\n// By creating a new object, \"withoutSideEffects()\",\n// doesn't change the state of anything. It can't\n// possibly introduce side-effects somewhere else in\n// our code.\nresult = withoutSideEffects(second);\nconsole.log('without side effects...');\nconsole.log('original', second.state);\nconsole.log('result', result.state);\n```", "```js\n// This calls the passed-in \"func\" after setting a\n// timeout. This \"defers\" the call till the next\n// available opportunity.\nfunction defer(func, ...args) {\n    setTimeout(function() {\n        func(...args[0]);\n    }, 1);\n}\n\n// Perform some expensive work...\nfunction work() {\n    var i = 100000;\n    while (--i) {\n        for (let c = 0; c < 100; c++) {\n            i * c;\n        }\n    }\n}\n\nfunction iterate(coll=[], pos=0) {\n    // Eat some CPU cycles...\n    work();\n\n    // Update the progress in the DOM...\n    document.getElementById('progress').textContent =\n        Math.round(pos / coll.length * 100) + '%';\n\n    // Defer the next call to \"iterate()\", giving the\n    // DOM a chance to display the updated percentage.\n    if (++pos < coll.length) {\n        defer(iterate, [ coll, pos ]);\n    }\n}\n\niterate(new Array(1000).fill(true));\n```"]