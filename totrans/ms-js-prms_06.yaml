- en: Chapter 6. Promises in Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Node.js中的承诺
- en: In the previous chapter, we learned about promises in WinRT and how they are
    implemented using the Microsoft platform. The promises concept has had wider coverage
    than other languages. This is one of the fastest growing concepts in open source
    technologies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了WinRT中的承诺以及它们是如何使用微软平台来实现的。承诺的概念比其他语言有更广泛的覆盖。这是开源技术中增长最快的概念之一。
- en: In this chapter, we will discuss an implementation of JavaScript that is dramatically
    changing the course of modern web development and enhancing our ways to real-time
    web. This amazing piece of technology is called Node.js, a platform written in
    JavaScript and based on the V8 Engine by Google. Promises in Node.js are far more
    interesting, evolving, and productive than any other platform or implementation
    can offer. Let's dive into the details and find out what promises in Node.js have
    to offer for real-time web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一种正在彻底改变现代网络开发进程并增强我们实时网络方法的JavaScript实现。这项令人惊叹的技术被称为Node.js，它是一个用JavaScript编写的平台，基于Google的V8引擎。Node.js中的承诺比其他任何平台或实现都要有趣、演变快和富有成效。让我们深入了解Node.js中的承诺能为我们实时网络提供什么。
- en: The V8 engine – the mechanics
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: V8引擎 – 机械结构
- en: A term that was only known to Formula One racers and sports car manufacturers
    was brought into web browsers in 2008 when Google first launched its amazing web
    browser, Google Chrome.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只有F1赛车手和跑车制造商才知道的术语，在2008年Google首次推出其惊人的网络浏览器Google Chrome时，被引入到了网络浏览器中。
- en: Like many real-life products and their mechanisms were being copied and depicted
    in computing industry, the V8 engine is one the true examples of such modeling
    in recent times. Since the scope of this book is focused on promises, let's take
    a brief look at what the V8 engine is in reality.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多现实生活中的产品和它们的机制被计算机行业复制和描绘一样，V8引擎是近年来此类建模的真实例子之一。由于本书的重点是承诺，所以我们简要地看看V8引擎实际上是什么。
- en: The V8 engine is a nontraditional engine with eight cylinders mounted on a crankshaft
    to produce extra horsepower. This engine is smoother than a V6 (another V-shaped
    engine), and less expensive than a V12 engine.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: V8引擎是一个非传统的带有八个气缸安装在曲轴上以产生额外马力的引擎。这个引擎比V6（另一种V型引擎）更平稳，比V12引擎更便宜。
- en: The V8 engine in Google Chrome
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Chrome中的V8引擎
- en: 'An open source project that makes Google number one in the web browser race
    is Google Chrome. Chrome is built on an exclusively designed JavaScript Engine
    called the V8\. Based on V8, Chrome has gained popularity and attention from users
    all around the world in a very short space of time. It was first rolled out on
    September 2, 2008\. However, what does this V8 JavaScript engine do which makes
    it faster and exceptional than any other program? It doesn''t go into compiling
    the high-level language interpreter to machine code. It basically skips the middle
    part of code interpreting and converts the high-level code to machine code then
    and there. This is the reason why Chrome is much faster:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使Google在网络浏览器竞赛中位居首位的开源项目就是Google Chrome。Chrome是基于一种独特设计的JavaScript引擎V8构建的。基于V8，Chrome在很短的时间内就获得了全球用户的热烈欢迎和关注。它最初于2008年9月2日发布。然而，这个V8
    JavaScript引擎究竟做了什么，使它比其他任何程序都更快、更出色呢？它并不涉及将高级语言解释器编译成机器代码。它基本上跳过了代码解释的中间部分，并将高级代码直接转换为机器代码。这就是Chrome之所以如此快速的原因：
- en: '![The V8 engine in Google Chrome](img/5500OS_06_02.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Google Chrome中的V8引擎](img/5500OS_06_02.jpg)'
- en: The evolution of Node.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的发展
- en: After the release of Google Chrome as an open source web browser, people started
    to take interest in it. There were two main reasons for this rapid interest. From
    a common user's perspective, it was much faster than any other web browser available,
    and from a developer's perspective, it was something that had revolutionized the
    browser technology by converting the high-level instructions into machine code
    instantly, removing a complete layer of middleware of compiler or interpreter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Google Chrome作为开源网络浏览器发布以来，人们开始对它产生兴趣。这种迅速的兴趣主要有两个原因。从普通用户的视角来看，它比任何其他网络浏览器都要快得多，而从开发者的视角来看，它通过将高级指令瞬间转换为机器代码，去除了完整的编译器或解释器的中间层，从而革命化了浏览器技术。
- en: Many developers started exploring the code base to find the possibilities of
    solutions they were involved in and to get the most out of this new amazing compilation
    of codebase.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者开始探索代码库，寻找他们参与的解决方案的可能性，并充分利用这个新的、令人惊叹的代码库。
- en: Ryan Dahl was among those developers who wanted to give a shot to V8 JavaScript
    engine as he was busy trying to solve a problem while working at Joyent. The problem
    was making a browser know how much time is left for an upload process. Inspired
    by the recent release of V8 and Ruby's Mongrel web server, he drafted the codebase
    that later evolved into Node.js.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ryan Dahl 是那些想尝试 V8 JavaScript 引擎的开发者之一，当时他在 Joyent 工作，忙于解决问题。问题是在上传过程中让浏览器知道还剩多少时间。受到最近发布的
    V8 和 Ruby 的 Mongrel web 服务器的影响，他起草了后来演变成 Node.js 的代码基础。
- en: A brief introduction to Node.js
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 Node.js 的简要介绍
- en: What Dahl had created was the first release of a brand new concept in the modern
    web app development, Node.js.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Dahl 创建的是现代 web 应用开发中的一个全新概念——Node.js 的第一个版本。
- en: In plain words, its server-side JavaScript is built on Google's V8 engine. Node.js
    is an event-based and nonblocking I/O. It's lightweight, efficient, and best suited
    for data-intensive real-time web apps that run on distributed devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，Node.js 的服务器端 JavaScript 是基于谷歌的 V8 引擎构建的。Node.js 是一个基于事件和非阻塞 I/O 的平台。它轻量级、高效，最适合用于运行在分布式设备上的数据密集型实时
    web 应用。
- en: Download and install Node.js
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载并安装 Node.js
- en: You can download Node.js from its official website at [http://nodejs.org/download](http://nodejs.org/download).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 Node.js 的官方网站 [http://nodejs.org/download](http://nodejs.org/download)
    下载 Node.js。
- en: Node.js is available for a variety of platforms. Select your operating system
    and the installer will guide you through the rest.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 适用于多种平台。选择你的操作系统，安装程序将引导你完成剩余步骤。
- en: Node.js is also available on GitHub as an open source project at [https://github.com/joyent/node](https://github.com/joyent/node)
    for developers around the world to contribute to its evolution and development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 作为开源项目也托管在 GitHub 上，位于 [https://github.com/joyent/node](https://github.com/joyent/node)，供全世界的开发者贡献其发展和开发。
- en: The installation instructions are quite simple and easy to understand, just
    follow the installers related to your operating systems. This is quite straightforward
    and the process gets completed without much hassle. All you need to do is just
    follow the onscreen instructions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明非常简单易懂，只需按照与你的操作系统相关的安装程序操作。这个过程非常直接，无需太多麻烦即可完成。你只需要按照屏幕上的提示操作即可。
- en: Node Package Manager – NPM
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node 包管理器——NPM
- en: One of the best virtues of using Node.js is NPM or Node Package Manager. It's
    an effective way for developers to collaborate on ideas by sharing codebase in
    a much faster way. However, this is not it. The best use of NPM is to download
    and install a different simple directory of code called the **package**. It can
    be done easily by just typing in simple commands (such as `npm install express`)
    that will download and install the entire package on your machine. With every
    package, there is a `.json` file that has the metadata about the package. In Unix-based
    environments, Node Package Managers not only help in downloading and setting up
    other packages, but are also able to update Node.js itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node.js 的一个最大优点是 NPM（Node Package Manager），即 Node 包管理器。这是开发者通过更快的共享代码库来协作想法的有效方式。然而，这并不是全部。NPM
    最好的用途之一是下载并安装一个称为**包**的不同简单代码目录。这可以通过简单地输入命令（如 `npm install express`）轻松完成，这将下载并在你的机器上安装整个包。每个包都有一个
    `.json` 文件，其中包含有关该包的元数据。在类 Unix 环境中，Node 包管理器不仅可以帮助下载和设置其他包，还可以更新 Node.js 本身。
- en: NPM is also another reason why Node.js is getting popular in the community of
    JavaScript developers. Unlike other languages where uploading libraries and binaries
    are very time-consuming and permission-oriented. With NPM, it's a much faster
    and less-permission oriented model that fascinates developers to upload and share
    their work throughout the community.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: NPM 也是 Node.js 在 JavaScript 开发者社区中变得越来越受欢迎的另一个原因。与其他语言相比，在其他语言中上传库和二进制文件是非常耗时且需要权限的。而
    NPM 是一个更快、更少关注权限的模型，吸引了开发者上传并与其他社区成员分享他们的作品。
- en: For more information on NPM and to add your contributions, check out [https://www.npmjs.com/](https://www.npmjs.com/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 NPM 的更多信息以及如何贡献你的代码，请访问 [https://www.npmjs.com/](https://www.npmjs.com/)。
- en: In later sections, we will see how NPM will help us in installing and using
    packages of our choice and how much faster and sleeker it is to work with NPM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将看到 NPM 如何帮助我们安装和使用我们选择的包，以及使用 NPM 工作是多么的快速和流畅。
- en: Choice of environment
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境选择
- en: Node.js is platform independent in a way that it has all the installations,
    setups, and libraries available for all the major operating systems currently
    available. It's available for all Unix-based operating systems, as well as Mac
    and Windows platforms. Since our prime focus here is to make you understand what
    the link is between Node.js and promises, we will base our code examples on the
    Windows 7 (any edition) platform since it's widely available and Node.js is also
    available for Windows 7 in stable conditions. Plus, it's very simple and less
    time-consuming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js在平台独立性方面具有所有安装，设置和库，适用于目前可用的所有主要操作系统。它适用于所有基于Unix的操作系统，以及Mac和Windows平台。由于我们主要关注让您了解Node.js与承诺之间的联系，因此我们将基于Windows
    7（任何版本）平台进行代码示例，因为它是广泛可用的，并且Node.js在Windows 7上也可用且稳定。此外，它非常简单且节省时间。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please remember that using Windows-based systems won't make any difference to
    code and their outputs. This will remain the same for every operating system with
    no change of any kind. You can easily use the same codebase on any other operating
    system without any hesitation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用基于Windows的系统对代码及其输出没有任何影响。这对于任何操作系统都是相同的，没有任何更改。您可以毫不犹豫地将在任何其他操作系统上使用相同的代码库。
- en: Setting up the environment for Node.js
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Node.js设置环境
- en: Let's familiarize ourselves with the environment and how things are getting
    done using Node.js. First things first, we must know how to set up things to compile
    the code and run it over our machine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉一下环境以及如何使用Node.js完成事情。首先，最重要的是，我们必须知道如何设置以编译代码并在我们的机器上运行。
- en: If you are reading this section, it's assumed that you already have Node.js
    installed on your machine with the latest release; otherwise, please refer to
    the earlier section to download and install Node.js.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读此部分，则假定您已经在计算机上安装了Node.js的最新版本；否则，请参阅前面的部分以下载和安装Node.js。
- en: 'After you have set up Node.js, check which version of Node.js and NPM is available
    on your machine by typing in the following commands:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在您设置Node.js之后，通过输入以下命令检查您计算机上可用的Node.js和NPM版本：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should be similar to the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该与以下截图类似：
- en: '![Setting up the environment for Node.js](img/5500OS_06_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![为Node.js设置环境](img/5500OS_06_03.jpg)'
- en: Checking versions of Node.js and NPM
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Node.js和NPM的版本
- en: Please note that the current version of Node.js is 0.10.31 and the current version
    of NPM is 1.4.23\. Our examples will be based on these versions, not lesser than
    these versions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当前的Node.js版本是0.10.31，当前的NPM版本是1.4.23。我们的示例将基于这些版本，不会低于这些版本。
- en: A simple node server
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的Node服务器
- en: Now, we have our environment ready to do some experiments, let's get the most
    obvious activity done by trying a simple node server. For this, you only need
    two pieces of software. One is your default text editor such as Notepad in Windows
    or Nano for Ubuntu and a web browser. For the web browser, we prefer to use Google
    Chrome as it's easily available for all platforms and is native to Node.js.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进行一些实验，让我们尝试一个简单的node服务器。为此，您只需要两款软件。一个是默认的文本编辑器，如Windows中的记事本或Ubuntu中的Nano，以及一个网络浏览器。对于网络浏览器，我们建议使用Google
    Chrome，因为它在所有平台上都很容易获得，并且与Node.js原生兼容。
- en: 'So, type the following code in your favorite text editor:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在您喜欢的文本编辑器中输入以下代码：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the file by any name with the `.js` extension. For our example, we use
    the name `server_example.js`. Save this file in a directory (such as `Promises_in_Node`)
    and open your terminal program. For Windows, it will be Command Prompt. Navigate
    to the directory where you have saved your file and type in the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何名字以`.js`扩展名保存文件。在我们的示例中，我们使用名称`server_example.js`。将此文件保存在目录（例如`Promises_in_Node`）中，然后打开您的终端程序。对于Windows，它是命令提示符。导航到您保存文件的目录，并输入以下命令：
- en: '![A simple node server](img/5500OS_06_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的Node服务器](img/5500OS_06_04.jpg)'
- en: 'If the code has no errors, it will compile and show the following output on
    the screen:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码没有错误，它将编译并在屏幕上显示以下输出：
- en: '![A simple node server](img/5500OS_06_05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的Node服务器](img/5500OS_06_05.jpg)'
- en: 'Now, open Chrome and type `http://127.0.0.1:1337/` in the address bar and hit
    *Enter*. This screen will show you the successful output from the Node.js server:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开Chrome浏览器，在地址栏输入`http://127.0.0.1:1337/`并按下*Enter*键。这个屏幕会显示Node.js服务器的成功输出：
- en: '![A simple node server](img/5500OS_06_06.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的Node服务器](img/5500OS_06_06.jpg)'
- en: That's it! You are now ready to take a deep dive in to promises in Node.js.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这些！现在您已经准备好深入研究Node.js中的承诺。
- en: Things we learned so far
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到目前为止我们所学的
- en: Let's sum up what we have learned so far. We learned what V8 engine is and how
    it's developed by Google Chrome as a JavaScript engine, what Node.js is and how
    it was started as a problem-solving technique to a full-fledged application development
    platform. We learned about the Node Package Manager and how it can be used in
    the Node.js application development. We then learned about where to download Node.js,
    how to install it, and what dependencies we have to take in consideration while
    developing for Node.js, and finally, we learned to write a simple server using
    Node.js and seen its output in a browser. This is a check point and if you are
    still confused about Node.js, please read through again and then move on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们已经学到了什么。我们了解了V8引擎是什么，以及它是如何由Google Chrome作为JavaScript引擎开发的，Node.js是什么，以及它是如何作为一个问题解决技术发展成为一个完整的应用程序开发平台的。我们学习了Node包管理器以及如何在Node.js应用程序开发中使用它。然后我们学习了如何下载Node.js，如何安装它，以及开发Node.js时需要考虑的依赖项，最后，我们学习了如何使用Node.js编写简单的服务器并在浏览器中查看其输出。这是一个检查点，如果你对Node.js仍然感到困惑，请再次阅读，然后继续。
- en: The following sections will let you understand more about Node.js and promises
    and how promises are gaining so much respect from Node.js developers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将让您更好地了解Node.js和承诺，以及承诺为何在Node.js开发者中获得如此多的尊重。
- en: Node.js with the Q library
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Q库的Node.js
- en: In [Chapter 2](ch02.html "Chapter 2. The JavaScript Asynchronous Model"), *The
    JavaScript Asynchronous Model*, we discussed what callback hell is and how we
    are dealing with using promises. With every language, implementation also changes.
    The same case is with Node.js. promises in Node.js are implemented in a different
    way. In Node.js, promises are not only used for dealing with callback hell, instead
    if a function cannot return a value or throw an exception, it can easily pass
    on a promise. This is a little different from what we have seen in the previous
    chapters. From the perspective of Node.js, a promise is an object that represents
    the return value or that can throw an exception Furthermore, it can also be used
    as a proxy for a remote object to improve latency.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html "第2章 JavaScript异步模型")《JavaScript异步模型》中，我们讨论了回调地狱是什么以及我们如何使用承诺来处理它。每种语言的实现也会有所不同。Node.js也是如此。Node.js中的承诺是以一种不同的方式实现的。在Node.js中，承诺不仅用于处理回调地狱，如果一个函数不能返回一个值或抛出一个异常，它也可以轻松地传递一个承诺。这与我们之前看到的章节有些不同。从Node.js的角度来看，一个承诺是一个代表返回值或能够抛出异常的对象，此外，它还可以作为远程对象的代理来提高延迟。
- en: 'Let''s have a look at the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下下面的代码：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Messy, isn''t it? Not only is it messy, but also very confusing and hard to
    maintain. Now, look at the following code using promise:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 乱七八糟，不是吗？不仅乱七八糟，而且非常令人困惑，难以维护。现在，看看使用承诺以下的代码：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, this code is less confusing, more productive, and it has one additional
    quality, which is an implicit error propagation like we have `try`-`catch` and
    `finally` blocks in Java that catch any unwanted exception and save the program
    from crashing totally when encountered with an unexpected condition.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码更清晰、更高效，并且有一个额外的特点，即隐式的错误传播，就像我们在Java中的`try`-`catch`和`finally`块一样，捕获任何不必要的异常，并在遇到意外条件时防止程序完全崩溃。
- en: The callback approach is known as the inversion of control, a function that
    is capable of accepting a callback rather than returning a value. Such a mechanism
    can more easily be described as the phrase, *Don't call me, I will call you*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 回调方法被称为控制反转，它是一个能够接受回调而不是返回值的函数。这种机制可以更容易地被描述为“不要调用我，我会调用你”的说法。
- en: Promises in Q have a very special tendency as it's clearly made independent
    the input arguments from control flow arguments. One can only be able to see its
    true benefits when using and creating APIs, particularly, variadic, rest, and
    spread arguments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Q中的承诺有一个非常特别的倾向，因为它清楚地使输入参数与控制流程参数独立。只有在使用和创建API时，尤其是在变长参数、剩余参数和展开参数方面，才能真正看到它的真正好处。
- en: Moving ahead with Q
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续学习Q
- en: After a brief introduction to Node.js and Q, let's see how we can develop applications.
    First, we need to get the Q library to set up the modules for it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍了Node.js和Q之后，让我们看看如何开发应用程序。首先，我们需要获取Q库以设置其模块。
- en: 'Using the Node Package Manager, install the Q library as shown in the following
    screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node包管理器，按照以下截图安装Q库：
- en: '![Moving ahead with Q](img/5500OS_06_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用Q前进](img/5500OS_06_07.jpg)'
- en: As you can see, the prompt says its `q` at version 1.2.0, which is stable and
    also backward compatible. We will use this release for all our examples in this
    chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，提示说它的`q`版本是1.2.0，这是稳定版本，也向后兼容。我们将使用这个版本作为本章所有示例的依据。
- en: With this installation and past upgrades in our environment, we are now able
    to sample some of the common yet fruitful features that promises give us in Q.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的环境和过去的升级中，我们现在可以尝试一些常见的、富有成效的承诺特性。
- en: Promises have a `then` method, which you can use to get the eventual return
    value (fulfillment) or throw an exception (rejection). By now, we all know it,
    after reading the previous chapters of this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺有一个`then`方法，你可以用它来获取最终的返回值（满足）或抛出异常（拒绝）。到现在，我们都在阅读这本书的前几章后知道了这一点。
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is how the preceding line of code works:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面的代码行是如何工作的：
- en: If `iPromiseSomething` returns a promise that gets fulfilled later with a return
    value, the first function (the fulfillment handler) will be called
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`iPromiseSomething`返回一个稍后得到满足的承诺，并带有返回值，第一个函数（满足处理器）将被调用
- en: If the `iPromiseSomething` function gets rejected later by a thrown exception,
    the second function (the rejection handler) will be called with the exception
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`iPromiseSomething`函数后来被抛出的异常拒绝，第二个函数（拒绝处理器）将被调用，并带有异常
- en: As you can see, the resolution of a promise is always asynchronous, which means
    the fulfillment or rejection handler will always be called in the next turn of
    the event loop (that is, `process.nextTick` in Node.js). This mechanism ensures
    that it will always return a value either before the fulfillment or rejection
    handlers are executed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，承诺的解决总是异步的，这意味着满足或拒绝处理器总是在事件循环的下一轮（即Node.js中的`process.nextTick`）被调用。这种机制确保在满足或拒绝处理器被执行之前，它总是返回一个值。
- en: Propagation in Q
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Q中的传播
- en: The `then` method always returns a promise that will either be handled or rejected.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`then`方法总是返回一个承诺，该承诺要么被处理，要么被拒绝。'
- en: 'In our example code, we assign the output to the `reapPromise` variable, which
    will hold the value:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们将输出分配给`reapPromise`变量，它将持有该值：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `reapPromise` variable is the new promise for the return value of either
    handler. Only one handler will ever be called and it will be responsible for resolving
    `reapPromise` as a function, which can only either return a value (a future value)
    or throw an exception.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`reapPromise`变量是任一处理器的返回值的新的承诺。只有一个处理器会被调用，并且它将负责以函数的形式解决`reapPromise`，该函数只能返回一个值（一个未来的值）或抛出一个异常。'
- en: 'Whatever is the case, there will be the following possible outcomes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论情况如何，都可能有以下几种结果：
- en: If you return a value in a handler, `reapPromise` will get fulfilled
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在处理器中返回一个值，`reapPromise`将被满足
- en: If an exception is thrown in a handler, `reapPromise` will get rejected
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在处理器中抛出了异常，`reapPromise`将被拒绝
- en: If a promise is returned in a handler, `reapPromise` will become that promise
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在处理器中返回一个承诺，`reapPromise`将变成那个承诺
- en: As it will become a new promise, it will be useful for managing delays, combining
    results, or recovering from errors.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它将成为一个新的承诺，所以它在管理延迟、组合结果或从错误中恢复时将很有用。
- en: 'If the `getInputPromise()` promise gets rejected and you forget the rejection
    handler, the error will go to `reapPromise`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`getInputPromise()`承诺被拒绝，而你忘记了拒绝处理器，错误将传递给`reapPromise`：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the input promise gets fulfilled and you fail the fulfillment handler, the
    value will go to `reapPromise`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入承诺得到满足，而你失败了满足处理器，值将传递给`reapPromise`：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you are only interested in handling the error, Q promises to provide a
    fail shorthand:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只对处理错误感兴趣时，Q承诺提供了一个fail简写：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you are writing JavaScript for modern engines only or using CoffeeScript,
    you may use catch instead of fail.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只为现代引擎编写JavaScript或者使用CoffeeScript，你可以使用catch而不是fail。
- en: Promises also provide a `fin` function that is like a `finally` clause. The
    final handler gets called, with no arguments, when the promise returned by `getInputPromise()`
    either returns a value or throws an error.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺还提供了一个`fin`函数，它类似于一个`finally`子句。当`getInputPromise()`返回的承诺要么返回一个值，要么抛出一个错误时，最终处理器将被调用，不带任何参数。
- en: 'The value returned or error thrown by `getInputPromise()` passes directly to
    `reapPromise` unless the final handler fails, and may be delayed if the final
    handler returns a promise:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`getInputPromise()`返回的值或抛出的错误，除非最终处理失败，否则会直接传递给`reapPromise`；如果最终处理返回一个承诺，可能会延迟：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In short:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：
- en: If the handler returns a value, the value is ignored
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理程序返回一个值，该值将被忽略
- en: If the handler throws an error, the error passes to `reapPromise`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理程序抛出错误，错误将传递给`reapPromise`
- en: If the handler returns a promise, `reapPromise` gets postponed
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理程序返回一个承诺，`reapPromise`将被推迟
- en: The eventual value or error has the same effect as an immediate return value
    or thrown error; a value would be ignored, an error would be forwarded.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的值或错误与立即返回的值或抛出的错误有相同的效果；一个值将被忽略，一个错误将被传递。
- en: So when we are looking for propagation, we need to keep in mind what we want
    to see from our returning value. The `then`, `fail`, and `fin` functions are the
    keys to remember while using propagations in Q.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们寻找传播时，我们需要记住我们从返回值中想看到什么。在使用Q的传播时，`then`、`fail`和`fin`函数是记住的关键。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are writing JavaScript for modern engines, you may use `finally` instead
    of `fin`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为现代引擎写JavaScript，你可能用`finally`代替`fin`。
- en: Chaining and nesting promises
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式和嵌套承诺
- en: Remember chaining in promises in [Chapter 2](ch02.html "Chapter 2. The JavaScript
    Asynchronous Model"), *The JavaScript Asynchronous Model*, where we learned all
    the things about chaining and callback hell handling? This is just same for Node.js
    using Q.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第二章](ch02.html "第2章 JavaScript异步模型")中学习过的承诺链吗？*JavaScript异步模型*，我们了解了所有关于链式调用和回调地狱处理的事情？使用Q的Node.js版本与此相同。
- en: 'There are two ways you can chain a promise in Node.js using Q: one is you can
    chain a promise inside a handler and the other is outside of it.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中使用Q链式承诺有两种方法：一种是在处理程序内部链式承诺，另一种是在其外部。
- en: 'Let''s suppose we are doing multiple things at a time, we can set up the promise
    chain like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们同时在做很多事情，我们可以像这样设置承诺链：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, we can say that the `ANY_promise()` function can contain some behavior,
    and this will return a promise object that leads to eventually return a result.
    As soon as the real result is returned, it will set off the next function in the
    chain.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以说`ANY_promise()`函数可以包含一些行为，这将返回一个承诺对象，最终返回一个结果。一旦真实结果返回，它将触发链中的下一个函数。
- en: This looks good now, what if you want to set off an asynchronous function and
    wait until we get a result before executing the behavior of the next promise in
    the chain?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来不错，如果你想在异步函数中设置一个点，并在我们获得结果后再执行链中下一个承诺的行为，那会怎样？
- en: Q has a solution for this. Using `.defer()` and `deferred.resolve()`, you can
    get it in a much more manageable and predictable manner.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Q针对此问题有一个解决方案。使用`.defer()`和`deferred.resolve()`，你可以以更加可管理和可预测的方式得到结果。
- en: Sequences in Q
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Q中的序列
- en: Like chaining, sequences is another way to stage your result in the way you
    want. Sequence is the way you can use in a predefined manner to get the outcome
    of the situation as desired. To hold it more tightly and to generate the result,
    Q provides sequences in a unique way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 链式调用（chaining）之外，序列（sequences）也是另一种按照你的意愿来组织结果的方法。序列是一种预定义的方式来获得你所期望的场景结果。为了更紧密地控制结果并生成它们，Q提供了一种独特的序列方式。
- en: 'Suppose you have a number of promise-generating functions, all of them need
    to be run in a sequence. You can do it manually like this example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有多个生成承诺的函数，它们都需要按顺序运行。你可以像这个例子这样手动完成：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You have to make sure that every `then()` must be in a sequence with another
    `then();` to maintain the sequence. Failing to do so will break the sequence,
    and you will not be able to get another value later.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须确保每个`then()`都必须与其他`then();`在序列中，以保持序列。否则，序列将会中断，你将无法稍后获得另一个值。
- en: The other way is to instruct your sequence dynamically. This can be faster but
    needs more attention while executing the code as unpredictable code may harm the
    overall sequence.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是动态地指导你的序列。这可能会更快，但在执行代码时需要更多的注意力，因为不可预测的代码可能会损害整个序列。
- en: 'Here is a snippet of how you can do it dynamically:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个动态实现的代码片段：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If this looks like you are using too many lines of code, use `reduce`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来你使用了太多的代码行，使用`reduce`：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Combination in Q
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Q的组合
- en: 'With Q, you have a unique facility in Node.js to write cleaner and manageable
    code if you want to combine a list of array of promises. This can help you to
    write a more complex level of sequential data structure in a more manageable way.
    How can we get there? Use `all`. Consider the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Q，你在Node.js中就有了一个独特的功能，如果你想组合一个承诺列表的数组，就可以写出更干净、易管理的代码。这可以帮助你以更易管理的方式编写更复杂级别的顺序数据结构。我们如何达到这个目标呢？使用`all`。考虑以下示例：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Q.all([func1(), func2()]);` function will be the generic form of the preceding
    code. You can also use `spread` to replace `then`. Can we replace another new
    thing with Q? Not really! The `spread` function spreads the values over the arguments
    of the fulfillment handler. For the rejection handler, it will get the first signal
    of failure. So, any of the promises destined to fail first will get it handled
    by a rejection handler:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q.all([func1(), func2()]);`函数将是前述代码的通用形式。你也可以使用`spread`来替换`then`。我们可以用Q替换另一个新东西吗？事实上不行！`spread`函数将值扩散到完成处理器的参数中。对于拒绝处理器，它将获取失败的第一个信号。因此，任何注定要首先失败的承诺都将由拒绝处理器处理：'
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you call the function, it will return `allSettled`. Within this function,
    a promise will be returned as an array that holds the value. When this promise
    has been fulfilled, the array contains the fulfillment values of the original
    promise within the same sequence as those promises. The beauty is, if any promise
    is rejected, it will be rejected immediately, not waiting for the rest of others
    to come and share their statuses:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数时，它将返回`allSettled`。在这个函数内部，一个承诺将被作为数组返回，该数组持有值。当这个承诺被履行时，该数组包含原始承诺的履行值，在相同的序列中这些承诺。美妙的是，如果任何承诺被拒绝，它将立即被拒绝，而不是等待其他人到来并分享他们的状态：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `any` function takes in an array of promises to return a promise that is
    fulfilled by the first given promise to be fulfilled, or rejected, provided all
    the given promises were rejected:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`函数接受一个承诺数组，返回一个由第一个被履行的承诺实现的承诺，或者在所有给定的承诺都被拒绝时被拒绝：'
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to handle errors in Q in Node.js
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在Node.js中处理Q错误
- en: There are times when rejection occurs with the promises creating errors. These
    errors are clever enough to dodge the handler assigned to take care of such errors.
    So, we need to take care of them explicitly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，承诺创建错误时会发生拒绝。这些错误足够聪明，可以避开分配来处理这些错误的处理程序。因此，我们需要明确地处理它们。
- en: 'Let''s have a look at the following snippet and see how it can be handled:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下片段，看看它如何被处理：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Why is this case happening? Suppose the parallelism between promises and `try`/`catch`
    and while we are trying to execute `scenario()`, the error handler represents
    a `catch` for `scenario()`, while the fulfillment handler represents code that
    happens after the `try`/`catch` block. Now, this code needs its own `try`/`catch`
    block.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会出现这种情况？假设承诺之间的并行性和`try`/`catch`，在我们尝试执行`scenario()`时，错误处理器代表`scenario()`的`catch`，而履行处理器代表`try`/`catch`块之后的代码。现在，这段代码需要自己的`try`/`catch`块。
- en: 'The `try`/`catch` block is not a new concept for all of you who have written
    code for some major languages. Since Node.js is based on JavaScript and Q is handling
    it at the moment, the syntax might be a bit different but the functionality is
    more or less the same like the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`catch`块对于那些为一些主要语言编写代码的人来说并不是一个新概念。由于Node.js基于JavaScript，而Q此刻正在处理它，所以语法可能有点不同，但功能基本上与以下代码相同：'
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Simply put, in terms of promises, it means you are chaining your rejection handlers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，在承诺方面，这意味着你在串联你的拒绝处理程序。
- en: Making progress with promises
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺进行进度管理
- en: 'Unlike other libraries, a promise has a unique communication ability. It can
    update you on its progress if you want it to talk to you. Preferably, these are
    notifications programmed by developers in a way that it can notify them on specified
    intervals of time to tell them what is the progress. We can do it by using our
    favorite `then()` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他库不同，承诺有一个独特的通信能力。如果你想让它与你交谈，它可以更新你的进度。最好是，这些是通过开发者编程的方式，在指定的时间间隔内通知他们进展情况。我们可以通过使用我们最喜欢的`then()`函数来实现：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are more than enough advantages of using Q. For this specific topic, it
    provides us a short call progress which minimizes our effort to only one line
    using `*.progress();`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Q有很多优点。对于这个特定主题，它提供了一个简短的调用进度，通过使用`*.progress();`，将我们的努力减少到只有一行。
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Getting to the end of a chain of promises
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到达承诺链的末端
- en: When we are talking about ending a promise chain, we have to make sure that
    any error doesn't get handled before the end, as it will get rethrown and reported.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论结束一个承诺链时，我们必须确保在任何错误没有在结束前得到处理，因为如果处理不当，它会被重新抛出并报告。
- en: This is a temporary solution. We are exploring ways to make unhandled errors
    visible without any explicit handling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个临时解决方案。我们正在探索使未处理的错误可见，而无需任何显式处理的方法。
- en: 'So, returned like the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，返回的代码如下所示：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why are we doing this? Why do we need to invoke the mechanism like this? The
    answer is very simple, you have to end the chain or have to return it to another
    promise. This is due to the fact that since handlers catch errors, it's an unfortunate
    pattern that the exceptions can go unobserved.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这样做？我们为什么需要以这种方式调用机制？答案非常简单，你必须结束链或必须将其返回给另一个承诺。这是因为处理程序捕获错误，这是一个不幸的模式，异常可能会被忽视。
- en: 'Every once in a while, you will need to create a promise from scratch. This
    is quite normal; you can either create your own promise or get it from another
    chain. Whatever the case is, consider that it''s a beginning. There are a number
    of ways in which you can create a new promise using Q. Here are some of them:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你需要从零开始创建一个承诺。这是很正常的；你可以自己创建一个承诺，或者从另一个链中获取它。无论哪种情况，都要考虑到这是一个开始。使用Q，你可以以多种方式创建新的承诺。以下是一些示例：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Not only this, `fcall();` can also be used to get an exception-handled promise
    that looks like the following snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，`fcall();`还可以用来获取一个异常处理的承诺，它看起来像以下代码片段：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since `fcall();` can call functions, or even promised functions, this uses
    the `eventualAdd();` function to add two numbers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fcall();`可以调用函数，甚至可以调用承诺函数，因此它使用`eventualAdd();`函数来添加两个数字：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Callback-based promises versus Q-based promises
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于回调的承诺与基于Q的承诺
- en: 'Say you have to interlink with callback-based instead of promise-based, what
    would be your options? The answer is Q provides `Q.nfcall()` and `friends();`,
    but most of the time, we have to rely on `deferred`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你必须与基于回调而不是基于承诺的接口进行交互，你的选择会是什么？答案是Q提供了`Q.nfcall()`和`friends();`，但大多数时候，我们不得不依赖`deferred`：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Normally, we can achieve it like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以像这样实现它：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A few words on delay, timeout, and notify
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于延迟、超时和通知的一些话
- en: There are situations when we want to make the output of our functions a bit
    delayed or slower than normal. This is when we are waiting for a certain event
    to occur such as checking the password's strength at the strength indicator.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们想要让函数的输出有一定的延迟或比正常情况更慢。这时我们正在等待某个事件的发生，比如在强度指示器中检查密码的强度。
- en: 'For all such needs, Q provides a collection of functions to give you this kind
    of control. These functions are:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些需求，Q提供了一系列函数来给你这种控制。这些函数包括：
- en: '`Q.delay()`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.delay()`'
- en: '`Q.notify()`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.notify()`'
- en: '`deferred.notify()`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deferred.notify()`'
- en: The preceding functions are not only able to create delays when required but
    also notify when the delay is likely to occur. If you want to defer the notification,
    `deferred.notify()` will serve the purpose.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数不仅能够在需要时创建延迟，还能在延迟可能发生时进行通知。如果你想要推迟通知，可以使用`deferred.notify()`来实现目的。
- en: Q.delay()
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Q.delay()
- en: 'The following code is a simplified implementation of `Q.delay`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`Q.delay`的简化实现：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Q.timeout()
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Q.timeout()
- en: 'A simple way to work with `Q.timeout`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Q.timeout`的简单方法：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: deferred.notify()
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: deferred.notify()
- en: Finally, you can send a progress notification to the promise with `deferred.notify()`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`deferred.notify()`向承诺发送进度通知。
- en: 'There is a wrapper for XML HTTP requests in the browser:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中有一个XML HTTP请求的包装器：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is an example of how to use this `requestOkText` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用这个`requestOkText`函数的示例：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Q.Promise() – another way to create promises
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Q.Promise() – 创建承诺的另一种方法
- en: '`Q.Promise` is an alternative promise-creation API that has the same power
    as the deferred concept, but without introducing another conceptual entity.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q.Promise`是一个承诺创建的API，它的功能与deferred概念相同，但不会引入另一个概念实体。'
- en: 'Let''s rewrite the preceding `requestOkText` example using `Q.Promise`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`Q.Promise`重写前面的`requestOkText`示例：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If `requestOkText` were to throw an exception, the returned promise will be
    rejected with this thrown exception as the reason for its rejection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`requestOkText`抛出异常，返回的承诺将被拒绝，并以抛出的异常作为其拒绝的原因。
- en: Static methods of Q
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Q的静态方法
- en: Typecasting of promises objects is a must and you must have to convert promises
    generated from different sources in Q type promises. This is because of the simple
    fact that not all promise libraries have the same warranties as Q and certainly
    don't provide all of the same methods.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对 promises 对象的类型转换是必须的，并且你必须将不同来源生成的 promises 转换为 Q 类型的 promises。这是因为一个简单的事实，即不是所有的
    promise 库都提供与 Q 相同的保证，当然也不提供所有相同的方法。
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Most libraries only provide a partially functional `then` method. Q, on the
    other hand, is quite different to others:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数库只提供部分功能的 `then` 方法。另一方面，Q 与其他库非常不同：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If there is any way that the promise you have got is not a Q promise as provided
    by your library, you should wrap it using a Q function. You can even use `Q.invoke();`
    as shorthand, as shown in the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到的 promise 不是由你的库提供的 Q 类型的 promise，你应该使用 Q 函数来包装它。你甚至可以使用 `Q.invoke();`
    作为简写，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Promise as a proxy
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise 作为代理
- en: One marvelous thing about a promise that distinguishes it from the rest is that
    it can act as a proxy for another object, not only for local objects but also
    for a remote object. There are methods that let you confidently employ properties
    or call functions. All of these exchanges return promises, so that they can be
    chained.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区分 promise 的奇妙之处在于，它不仅可以作为本地对象，也可以作为远程对象的代理。有一些方法让你自信地使用属性或调用函数。所有这些交换都返回
    promises，以便它们可以被链式调用。
- en: 'Here is list of functions you can use as proxies of a promise:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用作 promise 代理的函数列表：
- en: '| Direct manipulation | Using a promise as a proxy |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: 直接操作 | 使用 promise 作为代理 |
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `value.foo` | `promise.get("foo")` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `value.foo` | `promise.get("foo")` |'
- en: '| `value.foo = value` | `promise.put("foo", value)` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `value.foo = value` | `promise.put("foo", value)` |'
- en: '| `delete value.foo` | `promise.del("foo")` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `delete value.foo` | `promise.del("foo")` |'
- en: '| `value.foo(...args)` | `promise.post("foo", [args])` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `value.foo(...args)` | `promise.post("foo", [args])` |'
- en: '| `value.foo(...args)` | `promise.invoke("foo", ...args)` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `value.foo(...args)` | `promise.invoke("foo", ...args)` |'
- en: '| `value(...args)` | `promise.fapply([args])` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `value(...args)` | `promise.fapply([args])` |'
- en: '| `value(...args)` | `promise.fcall(...args)` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `value(...args)` | `promise.fcall(...args)` |'
- en: You can trim round-trips by using these functions instead of `then()` if the
    promise is a proxy for a remote object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用这些函数而不是 `then()` 来减少往返，如果 promise 是远程对象的代理。
- en: 'Even in the case of local objects, these methods can be used as shorthand for
    particularly-simple gratification handlers. For example, you can replace:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在本地对象的情况下，这些方法也可以作为特别简单的满足处理器的简写。例如，你可以替换：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Familiarizing Node.js – the Q way
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 Node.js —— Q 方式
- en: 'When you''re working with functions that make use of the Node.js callback pattern,
    where callbacks are in the form of *function(err, result)*, Q provides a few advantageous
    service functions for adapting between them. The two most important functions
    are: `Q.nfcall()` and `Q.nfapply()`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用遵循 Node.js 回调模式的功能时，其中回调以 `function(err, result)` 的形式出现，Q 提供了一些有利的服务函数来适应它们之间。最重要的两个函数是：`Q.nfcall()`
    和 `Q.nfapply()`：
- en: '`Q.nfcall()`: The Node.js function call'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.nfcall()`：Node.js 函数调用'
- en: '[PRE38]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Q.nfapply()`: The Node.js function apply'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.nfapply()`：Node.js 函数应用'
- en: '[PRE39]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: They are both used for calling functions with the same resemblance of Node.js
    so that they can generate promises.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都用于调用具有类似 Node.js 外观的函数，以便它们可以生成 promises。
- en: Unbinds and its solution
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解绑及其解决方案
- en: 'When you are working with methods, instead of simple functions, it''s highly
    likely that you can easily run into the common problems where passing a method
    to another function—such as `Q.nfcall`—unbinds the method from its owner. Q has
    to offer its services here too so that you can avoid this, by adopting any of
    these two ways:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用方法而不是简单函数时，你很可能会轻易遇到常见的问题，即传递一个方法到另一个函数（如 `Q.nfcall`）会解除方法与其所有者的绑定。Q 也提供了它的服务，以便你可以避免这个问题，通过采用这两种方式之一：
- en: Use `Function.prototype.bind()`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Function.prototype.bind()`
- en: 'Use these methods provided by Q:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Q 提供的这些方法：
- en: '[PRE40]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There is yet another way you can create reusable wrappers, using:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种创建可重用包装器的方法，使用：
- en: '`Q.denodeify`:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.denodeify`：'
- en: '[PRE41]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`Q.nbind`:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.nbind`：'
- en: '[PRE42]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Q support for tracing stacks
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Q 对跟踪堆栈的支持
- en: Q also extends its optional support for long stack traces; this helps developers
    to manage the stack property of an error by providing the entire reasons of errors
    and rejection reason rather to simply halt without any meaningful or readable
    error.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Q还扩展了对长堆栈跟踪的可选支持；这帮助开发者通过提供错误的整个原因和拒绝原因，而不仅仅是简单地停止，没有意义或可读的错误。
- en: 'The following function is one such example where the error was not handled
    in a meaningful manner and when someone tried to execute this snippet, he/she
    experienced meaningless and untraceable errors:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的函数就是这样一个例子，其中错误没有以有意义的方式处理，当有人尝试执行这段代码时，他/她经历了没有意义且无法追踪的错误：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will gives us a raw-looking unhelpful stack trace looking similar to this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个看起来原始且不怎么有用的堆栈跟踪，类似于这样：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, if you turn this feature on by setting `Q.longStackSupport = true`,
    then this will give us a nice-looking helpful stack trace looking similar to this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你通过设置`Q.longStackSupport = true`来启用这个功能，那么这将给我们一个看起来类似这样的有用的堆栈跟踪：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Unlike most of the time, in JavaScript, we use breakpoints or use `alert()`
    to see where the error occurred, which is quite frustrating and time consuming.
    Q has not only given us an elegant way to get to a point where the error is happening,
    but also the entire trace can be read and analyzed to solve the problem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数时候不同，在JavaScript中，我们使用断点或使用`alert()`来查看错误发生在哪里，这相当令人沮丧且耗时。Q不仅给了我们一种优雅的方式来到达错误发生的地方，而且整个跟踪也可以被阅读和分析来解决问题。
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '-   提示'
- en: 'In Node.js, this feature can also be enabled through the `Q_DEBUG` environment
    variable:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，这个特性也可以通过设置`Q_DEBUG`环境变量来启用：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will enable long stack support at every instance of Q.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用Q的每个实例的长堆栈支持：
- en: Making promise-based actions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作基于承诺的动作
- en: 'Starting off with Q, perform actions that return promises. Let''s say, make
    Node.js action `http.get` as the promised action:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从Q开始，执行返回promises的动作。比如说，把Node.js动作`http.get`作为承诺动作：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Later, you can use: `httpGet(...).then(function (res) {...});` but you have
    to make sure that functions return promises. The first `Q.defer()` returns a set
    of an empty promise and operations for it. The `deferred.promise` is the empty
    promise which fixes a certain value:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，你可以使用：`httpGet(...).then(function (res) {...});`，但你需要确保函数返回promises。第一个`Q.defer()`返回一个空承诺和对其的操作集合。`deferred.promise`是空承诺，它固定了一个特定的值：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This prints `Hello World` to the console. In general, you can transform usual
    callback actions:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将“Hello World”打印到控制台。通常，你可以将普通的回调动作转换为：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To promise actions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺动作：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Object handling promises
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象处理promises
- en: 'We learned a great deal about how promises help object handling whether these
    are local objects or remote ones. As mentioned earlier, the `then` callback can
    use the result in any way. Also, each handling is decomposed primitives of property
    accesses or function calls, for example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了很多关于承诺如何帮助对象处理的知识，无论是本地对象还是远程对象。正如前面提到的，`then`回调可以使用结果以任何方式。此外，每个处理都被分解为属性访问或函数调用的基本操作，例如：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Decomposition of primitive access
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始访问的分解
- en: 'Q can decompose continuous actions of each primitive access. Let''s have a
    look at the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '-   `Q`可以分解每个原始访问的连续动作。让我们看一下以下的代码：'
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There is another good thing about promises of Q. They have a support method
    of primitive access as a promise.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Q的promises还有一个好处。它们有一个支持原始访问的承诺方法。
- en: 'By them, the decomposed actions also translate to:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过它们，分解的动作也翻译为：
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: View revisited
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看重访
- en: 'The `view()` method helps in mirroring all the values into Q-based promises
    without any distinction, either it comes from a value or any other function. There
    are two methods that can make this possible:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`view()`方法帮助将所有值镜像到基于Q的promises中，而无需任何区分，无论是来自一个值还是任何其他函数。有两种方法可以实现这一点：'
- en: '`promise.post(name)`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`promise.post(name)`'
- en: '`promise.send(name)`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`promise.send(name)`'
- en: This converts a method of the promise value to a promise of the method result.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将promise值的操作方法转换为方法结果的promise。
- en: 'A result of `view()` has methods for all methods of the promise value. You
    can use `view` in the `then` callback of `view()`, for example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`view()`的结果拥有promise值的所有方法。你可以在`view()`的`then`回调中使用`view`，例如：'
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Aborting a promise
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放弃一个promise
- en: We saw how `done();` is used earlier, but here it comes in with a total impression.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了如何使用`done();`，但这里它以一种全面的影响出现。
- en: 'Using `done();`, we can conclude our promise and abort our program. I always
    have a way to chain the promises:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`done();`，我们可以结束我们的承诺并放弃我们的程序。我总是有一种方法来链接承诺：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the promise is vetted (and did not catch the error before), the `done()`
    function forcibly spawns an uncatchable error (for example, `setTimeout(function
    () {throw ex;}, 0)`).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果承诺已经被验证（并且在之前没有捕获到错误），`done()`函数将强制产生一个无法捕获的错误（例如，`setTimeout(function ()
    {throw ex;}, 0)`）。
- en: On Node.js REPL, run `Q.reject("uncaught").done()`, then exit with an error.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js REPL中，运行`Q.reject("uncaught").done()`，然后以错误退出。
- en: If the error reached to the `done()` function, you can think of it just a programming
    bug (not an exception state).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误已经传递到`done()`函数，你可以认为这只是编程中的一个错误（并不是异常状态）。
- en: Q utilities for Node.js
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子工具箱（Q）用于Node.js
- en: 'In this chapter, we came to know that promises are getting more easy to use
    within Node.js. The following is the set of all major utilities offered by Q for
    using Node.js:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们了解到承诺在Node.js中使用起来越来越方便。以下是由Q为Node.js提供的主要工具集合：
- en: '`Q.nfapply(fs.readFile, [filename, encoding]).then(console.log);`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.nfapply(fs.readFile, [filename, encoding]).then(console.log);`'
- en: '`Q.nfcall(fs.readFile, filename, encoding).then(console.log);`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.nfcall(fs.readFile, filename, encoding).then(console.log);`'
- en: '`Q.nfbind(fs.readFile)(filename, encoding).then(console.log);`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.nfbind(fs.readFile)(filename, encoding).then(console.log);`'
- en: '`Q.npost(fs, "readFile", [filename, encoding]).then(console.log);`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.npost(fs, "readFile", [filename, encoding]).then(console.log);`'
- en: '`Q.nsend(fs, "readFile", filename, encoding).then(console.log);`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q.nsend(fs, "readFile", filename, encoding).then(console.log);`'
- en: Q has more to offer, but the preceding ones are the best and most used and sensible
    use of these can help us write a more manageable, cleaner, and dynamically controlled
    mechanism.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Q还有更多功能，但前面提到的是一些最好用、最常用、最合理的用法，这些可以帮助我们编写更易管理、更干净、更具有动态控制的机制。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was an amazing journey from start to finish, and it has taught
    us from the very beginning about Node.js. We didn't opt for explaining stuff in
    computer science terminology, instead we went to the mechanical part of the V8
    engine, and from there we saw how real-world objects can be mapped into computing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章从开始到结束都是一次美妙的旅程，并且从一开始就教导我们关于Node.js的知识。我们没有选择用计算机科学术语来解释东西，而是直接深入到了V8引擎的机械部分，从那里我们看到了真实世界对象如何映射到计算中。
- en: We learned what Node.js is, from where this most amazing library started, who
    built it, and why and how it's helping us create real-time web apps.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了Node.js是什么，这个最惊人的库是从哪里开始的，是谁建造的，以及为什么和如何它帮助我们创建实时web应用。
- en: Then we moved to Q, the best way to offer promises to Node.js. We saw how we
    can install Q and then we saw different ways of using Q along with Node.js. We
    have also achieved our purpose of using Q as a promises implementation of Node.js.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向了Q，这是向Node.js提供承诺的最佳方式。我们看到了如何安装Q，然后我们看到了与Node.js一起使用Q的不同方法。我们也实现了使用Q作为Node.js的承诺实现的目标。
- en: This chapter will encourage you to start working on Node.js, especially on how
    to take advantage of Q as the library of promises for Node.js.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将鼓励你开始在Node.js上工作，特别是如何利用Q作为Node.js的承诺库。
- en: In the next chapter, we will be looking in-depth in the world of Angular.js
    and how it got promises implementation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨Angular.js的世界以及它是如何实现承诺（promises）的。
