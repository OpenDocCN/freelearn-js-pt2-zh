- en: Chapter 9. Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animations in an application are common nowadays. Animating visual transitions
    often gives some sense of fluidity, and a well-used animation can be the best
    way to communicate something to the user, more so than icons, images, or yet another
    chunk of text.
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia's templating engine has been designed to support animations. It uses
    an abstraction layer that allows for pluggable animation libraries, and the Aurelia
    ecosystem already offers multiple implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll start by going over the Animator API, and see how the
    templating engine interacts with it. Then, we'll add some simple CSS-based animations
    to our contact-management application to get a taste of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The Animator API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `aurelia-templating` library, the `TemplatingEngine` class needs to work
    with an animator service to perform view transitions. By default, it uses a class
    named `Animator`, which acts as a null object and, incidentally, describes the
    expected interface of an `Animator`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Null Object** design pattern describes an object or class that acts as
    an empty implementation of an interface. This object can be used instead of a
    null reference and removes the need to check for null before referencing it. You
    can get further information about this pattern at [https://sourcemaking.com/design_patterns/null_object](https://sourcemaking.com/design_patterns/null_object).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the most commonly used methods from the Animator API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enter(element: HTMLElement): Promise<boolean>`: Animates the addition of the
    element in the DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`leave(element: HTMLElement): Promise<boolean>`: Animates the removal of the
    element from the DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addClass(element: HTMLElement, className: string): Promise<boolean>`: Adds
    a CSS class to an element, which can trigger an animation, depending on the implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeClass(element: HTMLElement, className: string): Promise<boolean>`: Removes
    a CSS class from an element, which can trigger an animation, depending on the
    implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`animate(element: HTMLElement|HTMLElement[], className: string): Promise<boolean>`:
    Executes a single animation on an element or an array of elements. The `className`
    is either the CSS class triggering the animation, the name of the effect to apply,
    or the properties to animate, depending on the animator implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runSequence(animations: CssAnimation[]): Promise<boolean>`: Runs a series
    of animations in sequence. `CssAnimation` is an interface fulfilled by an object
    having both an `element: HTMLElement` and a `className: string` property. For
    each animation, the `className` is either the CSS class triggering the animation,
    the name of the effect to apply, or the properties to animate, depending on the
    animator implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these methods return a `Promise` resolving to a `boolean` value. This value
    will typically be `true` when an animation was indeed performed and `false` when
    one wasn't. This last scenario can occur, for example, when trying to animate
    an element using a CSS class that doesn't define any animation.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the usage of the animator by the templating engine is
    limited to calling the `enter` method for an element when adding it to the DOM
    and then calling the `leave` method when removing it. The other methods are not
    used by the framework, but will be by our own code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, animating an element is done on an opt-in basis. The templating engine
    will call `enter` when rendering an element, and `leave` when removing it from
    the DOM, only if the element has the `au-animate` CSS class. This is for performance
    reasons; without this opt-in mechanism, a lot of useless code would be executed
    every time any element is rendered and unrendered, when typically, only a few
    selected elements have animated transitions.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS animator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `aurelia-animator-css` library is a CSS-based animator implementation. We'll
    install it and use it to add simple CSS-based animations in our contact-management
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by opening a console in the project directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, it needs to be added to the vendor bundle. In the `aurelia_project/aurelia.json`
    file, under `build`, in the `bundles` section, at the following line to the `dependencies`
    of the bundle named `vendor-bundle.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to load the plugin so the templating engine uses it instead
    of the default `Animator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this point, everything is ready to handle CSS animations.
  prefs: []
  type: TYPE_NORMAL
- en: Animating view transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, before getting our hands dirty, let's quickly walk through the high
    level algorithm and see how the `enter` and `leave` methods of the CSS-based animator
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the templating engine adds a rendered element to the DOM, the following
    process takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: The templating engine adds the element to the DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The templating engine checks if the element has the `au-animate` class. If it
    does, it calls the animator's `enter` method. If it doesn't, the animator is bypassed
    altogether and the process ends here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator adds the `au-enter` class to the element. This class can be used
    in a CSS rule that describes styles for the element that will be constant during
    the whole animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator adds the `au-enter-active` class to the element. This class should
    be used in a CSS rule triggering an animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator checks if the element's computed style contains an animation. If
    it doesn't, it removes both `au-enter` and `au-enter-active` classes from it and
    resolves the resulting `Promise` with `false`. The process ends here. If it does,
    it starts listening for an `animationend` event from the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `animationend` event is received, the animator removes the `au-enter`
    and the `au-enter-active` classes from the element and resolves the resulting
    `Promise` with `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The process to remove an element from the DOM is pretty similar, but in reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: The templating engine checks if the element has the `au-animate` class. If it
    does, it calls the animator's `leave` method. If it doesn't, the animator is bypassed
    altogether and the process directly goes to step 6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator adds the `au-leave` class to the element. This class can be used
    in a CSS rule that describes styles for the element that will be constant during
    the whole animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator adds the `au-leave-active` class to the element. This class should
    be used in a CSS rule triggering an animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator checks if the element's computed style contains an animation. If
    it does, it starts listening for an `animationend` event from the browser. If
    it doesn't, it removes both `au-leave` and `au-leave-active` classes from it and
    resolves the resulting `Promise` with `false`. The process jumps directly to step
    6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `animationend` event is received, the animator removes the `au-leave`
    and the `au-leave-active` classes from the element and resolves the resulting
    `Promise` with `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The templating engine removes the element from the DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we understand how the CSS-based animator handles things, let's start
    by animating the `list-editor` component.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the list-editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `list-editor` component we wrote in [Chapter 5](ch05.html "Chapter 5. Making
    Reusable Components"), *Making Reusable Components*, has features that allow the
    user to add and remove items. It shouldn't be hard to make added items appear,
    such as a blind being pulled down, and removed items disappear, such as a blind
    being pulled up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we''ll first need to define the CSS animations for our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by defining the CSS rule used when adding an item; the item's
    `max-height` will be animated from 0 to 80 pixels in 0.2 seconds, during which
    its overflowing content will be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the CSS rule used when removing an item. It is pretty much the
    same thing as when adding one, but in reverse; its `max-height` is animated from
    80 pixels to 0 in 0.2 seconds. Its overflowing content will also be hidden during
    this animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we need to load this new CSS file with the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to hint to the templating engine that the items should be animated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a string interpolation expression in the `class` attribute, which
    adds the `au-animate` class to the `div` element of an item only when the `animated`
    property is truthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the view-model, the `animated` property will be initially set to `false`,
    so the items are not animated when the component is rendered. It will be set to
    `true` only when the component is fully attached to the DOM, so operations such
    as adding a new item or removing an existing item are properly animated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Why do we not just set `animated` to `true` in the `attached` callback method?
    Why the class to `setTimeout`? Well, if you remember the animation process described
    in the previous section, the element is first attached to the DOM, meaning that
    the `attached` callback is called at the same time, then the animator checks for
    the `au-animate` CSS class. If the `attached` callback synchronously sets `animated`
    to `true`, the `au-animate` CSS class will be present on the element when the
    animator checks if it needs to be animated, and the items will be animated during
    their initial rendering, which we want to prevent. Instead, we push the setting
    of `animated` to `true` on the browser's event queue, so the component's rendering
    is completed when the `au-animate` CSS class is added to the item's `div` elements.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you run the application, navigate to either the contacts `creation`
    or `edition` component, and play around with the list editors; you should see
    the animations play.
  prefs: []
  type: TYPE_NORMAL
- en: Manually triggering an animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to animated transitions, the animator also supports manually triggered
    animations. Manual animations work differently than animated transitions; there
    are no `au-enter` or `au-leave` CSS classes. Instead, animations are manually
    triggered a using user-defined CSS class.
  prefs: []
  type: TYPE_NORMAL
- en: The basic methods used to manually trigger animations are addClass and removeClass.
    These methods allow you to add a CSS class to, or remove one from an element,
    with an animated transition between the two states.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s imagine we have a CSS class named `A`. If we call `animator.addClass(''A'')`,
    the following process happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The animator adds the `A-add` class to the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator checks if the element's computed style contains an animation. If
    it doesn't, it adds the `A` class to the element, then removes the `A-add` class
    from it, and resolves the resulting `Promise` with `false`. The process ends here.
    If it does, it starts listening for an `animationend` event from the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `animationend` event is received, the animator adds the `A` class to
    the element, then removes the `A-add` class from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, this process allows you to add a CSS class to an element, with
    an animated state transition between the element without the class and the element
    with the class, which should be triggered by the intermediary class with the `-add`
    suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, when calling `animator.removeClass(''A'')` on the same element,
    the following process happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The animator removes the `A` class from the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator adds the `A-remove` class to the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animator checks if the element's computed style contains an animation. If
    it doesn't, it removes the `A-remove` class from it and resolves the resulting
    `Promise` with `false`. The process ends here. If it does, it starts listening
    for an `animationend` event from the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `animationend` event is received, the animator removes the `A-remove`
    class from the element and resolves the resulting `Promise` with `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process allows you to remove a CSS class from an element, with an animated
    state transition between the element with the class and the element without the
    class, which should be triggered by the intermediary class with the `-remove`
    suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `animate` method allows to trigger both `addClass` and `removeClass`
    in sequence. In such a case, an animation can be triggered either by the `-add`
    class, the `-remove` class, or both.
  prefs: []
  type: TYPE_NORMAL
- en: Emphasizing validation errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's try this out in our contact-management application by adding an animation
    that will make the validation errors blink a couple of times when the user tries
    to save a contact and the form is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create the CSS animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/form.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply define a CSS rule that will make the matched elements blink
    twice in half a second. The class triggering the animation is named `blink-add`,
    so it means we could trigger it by calling `addClass` on the elements to trigger
    it. However, since making the error messages blink is not a state transition and
    we don't want to leave our error messages with the `blink` class, we will trigger
    it by calling `animate`, so we are sure `blink` is removed at the end of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To favor code reuse, let''s transform the contact `form` component, which is
    currently a template-only component, into a full-blown component. To do this,
    we need to create a view-model for the form. In this view-model, we will add a
    method to emphasize the errors by making them blink:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/form.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by defining the view-model, in which we move the declaration
    of the bindable `contact` property; then we inject the component's DOM element
    and the `animator` instance. Next, we define an `emphasizeErrors` method, which
    retrieves all validation errors within the element and calls `animate` on them
    using the `blink` effect.
  prefs: []
  type: TYPE_NORMAL
- en: When `animate` is called, the `animator` will go through the process of adding
    `blink-add` to the elements, which will trigger the animation. When the animation
    completes, it will remove `blink`, add `blink-remove` and, since `blink-remove`
    triggers no animation, will remove it right away, leaving the elements in the
    state they were in at the beginning of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to remove the `bindable` attribute from the template, since `contact`
    is now defined by the view-model, and load the CSS file containing the new animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/form.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s update the `creation` component. We first need to change the
    `require` statement for the `form` by removing the `.html` suffix so the templating
    engine knows that the component is not just a template but also has a view-model.
    We also need to retrieve a reference of the `form` view-model in the `creation`
    component''s template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/creation.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By adding the `view-model.ref="form"` attribute on the `contact-form` custom
    element, a reference of the `form` view-model will be assigned to the `creation`
    view-model as a new `form` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use this `form` property to call the `emphasizeErrors` method when
    the validation fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/creation.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At this point, if you run the application, click the `New` button, type gibberish
    in the **Birthday** field, and click **Save**, the validation error message should
    appear and blink twice. It should blink again every time you click the **Save**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the `edition` component should also be modified the same way. I'll
    leave it as an exercise to the reader. This chapter's sample application can be
    used as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Animating route transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another area that could benefit from an animated transition is the router.
    Let''s add a simple fade-in/fade-out animation to the route transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create CSS rules that will make `section` elements fade in upon entering
    and fade out upon leaving.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we simply need to add the `au-animate` class to the `section` element
    of each route component.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the application at this point, route changes should smoothly transition
    using the new animation.
  prefs: []
  type: TYPE_NORMAL
- en: Swap order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When performing a route transition, the `router-view` element swaps the old
    view with the new one. By default, this swapping process first animates the removal
    of the old view, then the insertion of the new one. If none of the views are animated,
    the process is immediate. If both views are animated, the animations run one after
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the `router-view` handles view swapping is called a swap strategy,
    and can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`before`: The new view is added first, then the old view is removed. If the
    new view is animated, the process waits for its `enter` animation to complete
    before animating the removal of the old view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with`: The new view is added and the old view is removed simultaneously. Both
    animations run in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after`: The default swap strategy. The old view is removed, then the new view
    is added. If the old view is animated, the new view''s insertion is animated only
    once the old view''s removal animation is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our fade-in/fade-out transition works fine because it follows the default swap
    strategy: the old view is first animated out, then the new view is animated in.
    However, some animations may need a different swap strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the effect you want to implement when navigating from one route
    to another is to see the new view slide in from the right while the old view slides
    out to the left, you'll want the animation of the old view's removal and the animation
    of the new view's addition to run simultaneously, so you'll want to use the `with`
    swap strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, a `router-view` element''s swap strategy can be changed by setting
    its `swap-order` attribute to the name of the proper strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating an Aurelia application is pretty easy. The CSS-based implementation
    allows you to easily and quickly add animations to an existing application.
  prefs: []
  type: TYPE_NORMAL
- en: When the need for more complex animations arises, an adapter plugin over your
    favorite animation library can be easily written if it doesn't exist. At the time
    of writing, the official Aurelia libraries comprise `aurelia-velocity`, an adapter
    plugin for the popular `velocity.js` library. I'm sure that the community will
    eventually come up with adapters for other animation solutions, so I strongly
    suggest you keep an eye on it.
  prefs: []
  type: TYPE_NORMAL
