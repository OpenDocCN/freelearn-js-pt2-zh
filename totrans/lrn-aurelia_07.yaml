- en: Chapter 7. Test All the Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated testing has become an important part of most modern software development
    processes. Agile methodologies and approaches such as software craftsmanship emphasize
    the importance of automated tests and often advocate the practice of full-blown
    test-driven development, or TDD.
  prefs: []
  type: TYPE_NORMAL
- en: A good suite of automated tests adds tremendous value to a project, because
    it assures the team that any code change that breaks existing features won't go
    unnoticed. As such, tests build confidence. Thanks to them, developers are not
    afraid to change things, to play with ideas, to refactor, to make the code better.
    They are in control of their own code base.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you practice TDD or not, it is likely that you may wish to automatically
    test your Aurelia application to some extent. This is what this chapter is about.
  prefs: []
  type: TYPE_NORMAL
- en: To make testing Aurelia projects easier, the Aurelia team selected a set of
    libraries that is commonly used to test JavaScript projects, **Jasmine**, **Karma**,
    and **Protractor**, and included them in the project skeletons and the CLI project
    generator, along with their respective configuration and the tasks to run the
    tests in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine is a popular testing framework for JS that we will use for both unit
    and end-to-end tests. It can be found at [http://jasmine.github.io/](http://jasmine.github.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karma is a test runner that is used under the hood by testing tasks. It can
    be found at [https://karma-runner.github.io/](https://karma-runner.github.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protractor is an end-to-end testing framework that offers a rich API to interact
    with the browser. It can be found at [http://www.protractortest.org/](http://www.protractortest.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will explore how we can unit-test an Aurelia application,
    mainly by adding unit tests in our contact management application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not familiar with Jasmine, you should keep its documentation handy,
    as you may want to look it up while reading this chapter: [http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Projects created using the CLI include a task to run unit tests. This task is
    defined in the `aurelia_project/tasks/test.js` file and simply launches Karma
    using the configuration file, `karma.conf.js`, located at the root of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This task can be executed by opening a console in the project directory and
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command will launch a single test run and will output the result in the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `run` task, the `test` task can be modified with the `watch`
    switch to make it watch the test files and rerun every time a change is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will launch a test run and will monitor the test files to rerun
    the tests after each change.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you took a peek at the code of `aurelia-validation`, you have probably noticed
    that this plugin needs to be loaded before the `ValidationRules` class can be
    used. This is because the methods exposed by `ValidationRules` expect the class
    to be statically initialized with a `ValidationParser` instance in order to, among
    other things, parse string interpolation in error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Since our model classes,  `Contact`, `PhoneNumber`, `Address`, and so on, rely
    on the `ValidationRules` class in their constructor, we won't be able to use any
    of those model classes in any of our tests if we don't initialize it first. Additionally,
    our custom validation rules must also be loaded before they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, let''s add a setup file, which will initialize validation at the start
    of every test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/setup-validation.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by importing the `rules` file, so our custom validation rules
    are properly registered.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a DI container and initialize the binding language implementation
    needed by the parser, then use it to create a `ValidationParser` instance, which
    we use to initialize the `ValidationRules` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s add this file to the unit test setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/aurelia-karma.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply add the `setup-validation.js` file to the list of files loaded
    by Karma using `require` when starting a test run.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Bluebird warnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s also configure the Bluebird Promise library''s warnings so our console
    is not flooded with warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/setup.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply copy and paste the `Promise` configuration that sits at the
    top of `src/main.js`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can start writing unit tests comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `test/unit/app.spec.js` file contains sample tests for the `app` component
    created by the CLI when initiating the project. As this component has completely
    changed since we started, those tests are no longer relevant and will fail, so
    you should delete this file.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, files containing unit tests have the `.spec.js` extension. The
    default Karma configuration in Aurelia projects expects tests to sit in files
    following this naming convention, so we will follow it in our contact management
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by testing model classes. They contain a couple of critical features
    that we want to make sure are properly working.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s first make sure that our bundles are up-to-date by opening
    a console and running a build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to make the process of writing tests flow more easily, let''s first launch
    a console and start a continuous test process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The task should start running, and should show something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The test run returns an error simply because it cannot find any test to run.
    Let's change that.
  prefs: []
  type: TYPE_NORMAL
- en: Testing static factory methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first test we will write will make sure that calling the `fromObject` method
    with an empty object creates an empty `PhoneNumber` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/models/phone-number.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a single test case that calls the `fromObject` static method
    using an empty object, then makes sure the result is equal to an empty `PhoneNumber`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you save the file and take a look at the console, you should see a message
    that looks somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write another test, which will test another angle of `fromObject`. It
    will make sure scalar properties are properly copied to the new `PhoneNumber`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/models/phone-number.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, our new test calls the `fromObject` static method using an object with
    the expected scalar properties: `type` and `number`. Then,  we ensure each property
    has been properly copied to the resulting `PhoneNumber` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Such tests should also be added for the `EmailAddress`, `Address`, and `SocialProfile`
    classes, each in its own file:  `email-address.spec.js`, `address.spec.js`, and
    `social-profile.spec.js`, following the same pattern. I''ll leave this as an exercise
    to the reader. The chapter''s sample application can be used as a reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the list item classes are tested, let''s write tests for the `Contact`
    class. We''ll start with the same kind of tests we wrote previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/models/contact.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `Contact` class'' `fromObject` method does a little more than
    just copying properties, it also maps the list items to their respective model
    classes. Let''s add tests to ensure this works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/models/contact.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add `import` statements for the list item classes. Then we add four
    test cases, one for each list item classes, making sure in each case that an array
    of objects is properly mapped to the corresponding class.
  prefs: []
  type: TYPE_NORMAL
- en: Testing computed properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to unit testing, computed properties are no different from functions.
    Let''s write some tests to cover the `Contact` class'' `isPerson` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/models/contact.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add four test cases to make sure the `isPerson` property behaves correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variable storing the instance on which the tests will apply is named `sut`,
    which stands for system under test. It is considered a standard term by many authors
    in automated testing. I like to use this acronym, as it clearly identifies who
    the subject of the test is.
  prefs: []
  type: TYPE_NORMAL
- en: I'll leave it as an exercise to the reader to write test cases for the `fullName`
    and the `firstLetter` properties. This chapter's sample application can be used
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing services is also pretty straightforward. In our contact management
    application, we have a single service: the `ContactGateway`. It is however not
    very testing-friendly at the moment, mainly because of its constructor, which
    configures the `HttpClient` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing configuration from the gateway constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s refactor our gateway to make it more easily testable. We will move the
    `HttpClient` configuration to the feature''s `configure` function, so the constructor
    of `ContactGateway` doesn''t contain any configuration logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create an instance of `HttpClient` using the DI container and configure
    it, then create a `ContactGateway` instance, which we register in the DI container.
    You may notice that we don't register the `HttpClient` itself in the container.
    In most applications, it would be totally OK to do so. However, since we want
    our features to be as independent as possible and other features could possibly
    use distinct `HttpClient` instances to call different backends, we don't register
    this one because it could mess with the other features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can remove the configuration code from the constructor of `ContactGateway`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/services/gateway.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of `ContactGateway` is now free of any configuration logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we changed code in our application, we need to rebuild it before adding
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing read methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by writing a couple of tests for the two read methods of `ContactGateway`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/services/gateway.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by defining a test setup using Jasmine's `beforeEach` function.
    This test setup will be executed before each test case. In this setup, we first
    create a mock for the `HttpClient`, then we create the `ContactGateway` instance
    on which our test will apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define two helper functions: the first one to create a `Contact` object,
    and the second one to create a mock for a response object with a JSON body. Those
    two functions will be used by our test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we write test cases to verify that the `getAll` and the `getById` methods
    work properly. The two test cases are asynchronous tests, so they ask for a `done`
    function to be passed as parameter, which they will call when the test is completed.
    They both follow the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `Contact` object(s) that should be returned by the tested method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the mocked `fetch` method of `HttpClient`, so it returns a `Promise`
    resolving to a mocked response object, which exposes the data to return as a JSON
    body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the tested method and, when it resolves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the returned `Promise` resolves to the expected data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that the `fetch` method of `HttpClient` was called with the proper arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing write methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Testing write methods is pretty similar. However, it needs a little more work,
    as the HTML5 File API offers no easy way to compare `Blob` objects at the moment.
    So in order to test the bodies of the requests sent by our gateway, we need to
    write some helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/services/gateway.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first helper function, named `readBlob`, simply takes a `Blob` object as
    its parameter and returns a `Promise`, which resolves to the content of the `Blob`
    as a string. Since the process of reading `Blob` content is asynchronous, it just
    wraps this process in a `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: The second helper function, named `expectBlobsToBeEqual`, expects two `Blob`
    objects as its parameters. It first compares their `type` and `size` properties
    to make sure they are equal, then uses `readBlob` to retrieve the content of the
    two `Blob` objects and compares the results to make sure they also are equal,
    returning the resulting `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: The last helper function, named `expectFetchToHaveBeenCalled`, receives the
    expected path and the expected request properties. It first extracts the expected
    body from the expected request properties, if any, and deletes it from the object.
    Then, it ensures that the mocked `fetch` method of `HttpClient` has been called
    with the expected path and the expected request properties minus the body, because
    comparing `Blob` objects is an asynchronous process that must be performed separately.
    Lastly, if an expected body was provided, it calls the `expectBlobsToBeEqual`
    function using both the body passed to the last call to `fetch` and the expected
    body, and returns the resulting `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last helper function will help us write assertions on how our gateway
    calls the `fetch` method of its `HttpClient`. Let''s start with a test for the
    `create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/services/gateway.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by importing the `json` function from the Fetch client. We will
    use it to transform the expected request payload in a JSON-encoded `Blob` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test by itself is pretty straightforward and sets the path for the next
    tests, which will follow the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Contact` object that will be passed to the tested method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the mocked `fetch` method of `HttpClient` so it returns a resolved
    `Promise`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the tested method and, when it resolves, check that the `fetch` method
    of `HttpClient` was called with the proper arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The tests for the `update` and `updatePhoto` methods are pretty similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/services/gateway.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Those two tests follow the same pattern as the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing value converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing value converters is not much different from testing services. Of course,
    it depends on the complexity of the converters you need to test. In our contact
    management application, the value converters are pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a test or two for our `orderBy` value converter to get a feel
    for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/value-converters/order-by.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first define a simple test setup that creates the test subject, then
    we add two test cases. The first one verifies that the array passed to the `toView`
    method is properly sorted using the specified property. The second verifies that
    the array passed to the `toView` method is sorted in reverse order when `"desc"`
    is passed as the third parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if the value converter to the test supports two-way binding and has
    a `fromView` method, additional test cases should be added to cover this second
    method.
  prefs: []
  type: TYPE_NORMAL
- en: I'll leave it as an exercise to the reader to write tests for the `groupBy`
    and `filterBy` value converters. This chapter's sample application can be used
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing custom elements and attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the tests we've written so far have little to do with Aurelia. The code
    we tested could be used in a whole different UI framework, and the chances are
    nothing would need to change. This is because we didn't test anything visual yet.
  prefs: []
  type: TYPE_NORMAL
- en: When testing custom elements and attributes, we could settle for the types of
    test we wrote previously and test only their view-models. The tests would cover
    only the behavioral aspect of the components. However, having tests that can cover
    components as a whole, including their view counterpart, would be much more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The component tester
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thankfully, Aurelia offers the `aurelia-testing` library, which can be used
    to fully test components. As such, it exports two important classes: `StageComponent`
    and `ComponentTester`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StageComponent` class has a single static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This method simply creates an instance of the `ComponentTester` class behind
    the scenes, calls its own `withResources` method, and then returns it. `StageComponent`
    is basically just API sugar over the component tester. The two following lines
    could be switched without any effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ComponentTester` class offers an API to configure a short-lived, sandboxed
    Aurelia application, in which the tested component will live during the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '`withResources(resources: string | string[]): ComponentTester`: Loads the provided
    resources as global resources in the sandbox application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inView(html: string): ComponentTester`: Uses the provided HTML as the root
    view of the sandbox application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boundTo(bindingContext: any): ComponentTester`: Uses the provided value as
    the binding context for the root view of the sandbox application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manuallyHandleLifecycle(): ComponentTester`: Tells the component tester that
    the life cycle of the application should be handled manually by the test case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bootstrap(configure: (aurelia: Aurelia) => void): void`: Uses the provided
    function to configure the sandboxed Aurelia application. By default, the application
    is configured using `aurelia.use.standardConfiguration()`. This method can be
    used to load additional plugins or features required by a component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create(bootstrap: (aurelia: Aurelia) => Promise<void>): Promise<void>`: Creates
    the sandbox application using the provided bootstrapping function. Most commonly,
    the `aurelia-bootstrapper` library''s `bootstrap` function will be used here.
    The returned `Promise` is resolved when the application is loaded and has booted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bind(): Promise<void>`: Binds the sandbox application. It can only be used
    when the application life cycle is handled manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attached(): Promise<void>`: Attaches the sandbox application to the DOM. It
    can only be used when the application life cycle is handled manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detached(): Promise<void>`: Detaches the sandbox application from the DOM.
    It can only be used when the application life cycle is handled manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unbind(): Promise<void>`: Unbinds the sandbox application. It can only be
    used when the application life cycle is handled manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispose()`: Disposes all resources of the sandbox application and completely
    removes it from the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, the `aurelia-testing` library is still in beta, so there
    will probably be some new features added to it before its release.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the file-drop-target attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how to use the component tester by writing a test suite for the
    `file-drop-target` custom attribute we wrote in [Chapter 5](ch05.html "Chapter 5. Making
    Reusable Components"), *Making Reusable Components*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by creating an empty test suite, which contains a test setup
    using the `beforeEach` function and a test teardown using the `afterEach` function.
    In the test setup, we first create a `viewModel` object with a `files` property,
    which will be bound to our `file-drop-target` attribute. Secondly, we use the
    `StageComponent` class to create a sandboxed Aurelia application in which our
    custom attribute will live during each test.
  prefs: []
  type: TYPE_NORMAL
- en: This sandboxed application will load the `file-drop-target` attribute as a global
    resource. Its root view will be a `div` element with the `file-drop-target` attribute
    on it, bound to the `files` property of the root binding context, which will be
    the `viewModel` object.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a `create` helper function, which will create and boot the sandboxed
    application and will retrieve the `element` hosting our `file-drop-target` attribute
    once the application is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the test teardown, we simply `dispose` the sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test the `file-drop-target` custom attribute, we will need to fire
    drag and drop events on the `element` hosting the tested attribute. As such, let''s
    start by writing a factory function to create such events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function is pretty straightforward. It simply creates an `Event` object
    using the `type` of event passed as a parameter. It also tells the event that
    it should bubble up the DOM when fired. Lastly, it assigns the provided `dataTransfer`
    object on the event, before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this function in a bunch of other functions, which will be used
    to trigger the various steps of a drag and drop process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These three functions each create and dispatch a specific drag and drop event.
    They also return a `Promise` whose resolution will occur once the browser's event
    queue has been emptied.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a binding is often an asynchronous process, depending on the type of
    binding. Aurelia's binding engine heavily relies on the browser's event loop to
    make the process of updating bindings as smooth as possible.
  prefs: []
  type: TYPE_NORMAL
- en: As such, returning a `Promise` whose `resolve` function is pushed at the end
    of the browser's event queue using `setTimeout` is a technique used in tests to
    make sure that bindings that may need to react to a property being updated or
    an event being dispatched have the time to update themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we will need to create `File` objects to use in our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have all the tools we need to write a first test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This test makes sure that, when dragging and then dropping a list of files on
    the element hosting our custom attribute, the files in the drop event are assigned
    to the property bound to the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: This test starts by creating a list of `files` and dispatching a `dragover`
    event, which is useless in itself but is there just to follow the standard process
    of a drag and drop operation. Next, it dispatches a `drop` event using the `files`
    created previously. Lastly, it makes sure that the `files` were correctly assigned
    to the `files` property of the `viewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s add another test case to make sure that the event''s data is
    properly cleared:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you run the tests now, they should all be green.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the list-editor element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unit-testing a custom element is very similar. Let''s see how it works by testing
    the `list-editor` custom element we wrote previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by creating a test suite with a test setup that creates an empty
    array of `items` and mocks a function to create new items. It also creates a component
    tester that will load the `list-editor` as a global resource, use the `list-editor`
    element in its root view, and define as the root binding context an object containing
    the array of `items` and the mocked `createItem` function, which will be bound
    to the `list-editor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a `create` function, which will create and bootstrap the sandboxed
    application in which the tested element will live during each test. It will also
    retrieve the `list-editor` DOM element once the application is booted.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we define a test teardown that will simply `dispose` the component tester.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we''ll need objects to use as items. Let''s create a simple class
    that we can use in our test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This simple `Item` class expects a `text` value in its constructor, and returns
    this `text` when converted to string.
  prefs: []
  type: TYPE_NORMAL
- en: In our tests, we'll need to retrieve various elements that are rendered by the
    `list-editor`, either to check that some things are properly rendered or to trigger
    actions. As such, let add some CSS classes in the view of `list-editor`. Those
    classes will help us select specific elements without relying on the HTML structure
    itself, which would make the tests brittle, because any change to the HTML structure
    could break them.
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply add a `le-item` CSS class on each element acting as the root
    of each item. We also add a `le-remove-btn` CSS class to each button allowing
    us to remove items from the list. Lastly, we add a `le-add-btn` CSS class to the
    button allowing us to add an item to the list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `le` prefix stands for list editor. It's not an attempt to write French
    cartoon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we did before, we have to rebuild the application, so the bundles
    are up-to-date and include the new CSS classes in the `list-editor` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a couple of helper functions to retrieve elements, perform actions,
    or assert results on the rendered DOM inside our tested element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getItemsViews`: Retrieves elements (the roots of each `items`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clickRemoveButtonAt`: Retrieves the **Remove** button for the item at the
    given index and triggers a `click` event on it. It returns a `Promise` that will
    resolve when the browser''s event queue is emptied, to make sure all bindings
    are up-to-date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clickAddButton`: Retrieves the **Add** button and triggers a `click` event
    on it. It returns a `Promise` that will resolve when the browser''s event queue
    is emptied, to make sure all bindings are up-to-date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isItemRendered`: Returns `true` if the provided item has been rendered in
    the DOM of `list-editor` and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`areAllItemsRendered`: Returns `true` if the items have all been rendered in
    the DOM of `list-editor` and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we have everything we need to write our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first verify that all the items are properly rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add tests to make sure that, when clicking on an item''s **Remove**
    button, the item gets deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s add a test case to make sure that a click on the **Add** button
    will create a new item and will add it to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: At this point, all the tests should pass.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing route components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, there is no way to test a route component using `ComponentTester`.
    We can only test the view-model's behavior in unit tests, and rely on end-to-end
    tests to verify the view. The Aurelia team, however, plans to add this feature;
    you should check it out, in case it has already been released when you read this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit-testing the view-model of such components is not very different from most
    of the tests we already wrote, but let''s see a quick example by writing a test
    suite for the contact creation component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/components/creation.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by creating a test suite with a test setup that creates a bunch
    of mocks, and then creates the SUT using those mocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a helper function to create a validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/components/creation.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s add a first test case to make sure nothing happens when trying
    to save an invalid contact, and a second test case to make sure that saving a
    valid contact does the right thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/unit/contacts/components/creation.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This gives a good idea of how to test the view-model of a route component. I'll
    leave it as an exercise to the reader to add tests for the other route components
    in the `contacts` feature. This chapter's sample application can be used as a
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the purpose of unit tests is to verify units of code in isolation, end-to-end
    (**E2E**) tests are intended to validate the application as a whole. Those tests
    can go to various depths. Their scope may be limited to the client application
    itself. In such a case, any distant service used by the application needs be mocked
    one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: They can also cover the whole system. Most of the time, this means that the
    services backing the application must be deployed to a test location and initialized
    with well-controlled test data.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever your end-to-end test strategy is, the technology stays pretty much
    the same. In this section, we will see how to leverage Protractor to write functional
    test scenarios for our contact management application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting things up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, the CLI doesn't include a Protractor setup. Since we
    started our project using the CLI, let's see how we can add support for end-to-end
    tests to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to install the `protractor` plugin for Gulp, along with the `del`
    library. Open a console in the project''s directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to store some configuration values about the end-to-end testing
    process. Let''s add these to the `aurelia.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This new section contains paths and transpiler options that will be used by
    our E2E task.
  prefs: []
  type: TYPE_NORMAL
- en: 'This task is pretty straightforward: it transpiles the test suite using Babel,
    so it can run on Node, and then launches Protractor. Let''s first write the task
    descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/tasks/e2e.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s write the task itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/tasks/e2e.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not familiar with Gulp, let me quickly explain what this task does:'
  prefs: []
  type: TYPE_NORMAL
- en: It updates WebDriver if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cleans the output directory, where the transpiled test suite sits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It transpiles the test suite in the output directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It launches Protractor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Protractor is mostly an API that sits over Selenium, which is the actual engine
    allowing us to play scenarios in a browser. WebDriver is the Node bindings that
    allow us to communicate with Selenium.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You may have noticed that a configuration file path is passed to Protractor.
    Let''s write this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`protractor.conf.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Exploring Protractor in any depth is outside the scope of this book. However,
    you can probably understand from this configuration that it will use Google Chrome
    to run the tests, that it expects the test files to sit in the `test/e2e/dist`
    directory, which is where we configured our task to transpile our test suite,
    and that a plugin is loaded from the `aurelia-tools` package. The `aurelia-tools`
    library is already included in CLI-based projects, so there no need to install
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This last part is pretty important, since this plugin adds some Aurelia-specific
    methods to the Protractor API. We'll see those in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our contact management application does not live by itself. It sits over an
    HTTP-based API, which allows the application to access data and perform actions.
    As such, we need a controlled version of the API, a kind of mock, actually, which
    will contain a predefined set of data, and which we can reset to its original
    state before each test.
  prefs: []
  type: TYPE_NORMAL
- en: You can take this mocked API from this book's artifacts. Simply copy the `chapter-7\app\test\e2e\api-mock`
    directory from the samples and paste it in the `test\e2e` directory of your own
    project. You will probably need to create the `e2e` directory first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, make sure you restore all dependencies needed by the API
    mock by opening a console in the `api-mock` directory and running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The API mock is now ready to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to reset the data set before each test, we''ll need a helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/api-mock.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In case you didn't know, Protractor runs on Node, not in the browser. As such,
    we start by importing the `http` Node module. Next, we define and export a `resetApi`
    function, which simply sends a `POST` request to the `/reset` endpoint of our
    HTTP API. It also returns a `Promise`, which is resolved when the HTTP request
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: This function tells the backend to reset its dataset to its original state.
    We will call it before every test, so each test can be sure to work with the same
    set of data, even if a previous test created a new contact or updated an existing
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The page object pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A typical E2E test will load a given URL, retrieve one or many DOM elements
    from the document, perform an action or dispatch an event on this or those elements,
    and then verify that the expected outcome was achieved.
  prefs: []
  type: TYPE_NORMAL
- en: As such, selecting elements and performing actions on them can quickly bloat
    the test code. Additionally, it is fairly common to have to select a given set
    of elements in multiple test cases. Having to duplicate the selection code in
    many places makes the code rigid and hard to change. The tests becomes more restrictive
    than liberating.
  prefs: []
  type: TYPE_NORMAL
- en: To make our tests more self-descriptive and easier to change, we will use the
    page object pattern. This pattern describes how we create a class to represent
    the UI of a given page or component in order to encapsulate the logic of selecting
    specific elements and performing actions on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate this by creating such a class for the contact list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/list.po.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This class starts with a `getAllContacts` method. This method uses the Protractor
    API to select all elements with the `cl-details-link` CSS class, and then maps
    them to their text content. This method allows us to get an array containing the
    full name of all displayed contacts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it exposes a `clickContactLink` method, which retrieves the element at
    the provided `index` among those with the `cl-details-link` CSS class, and then
    gets its text content to assign it as the `fullName` property on a `result` object,
    before performing a click on the element. It then uses one of the extension methods
    provided by Aurelia's Protractor plugin to wait for the router to complete its
    navigation cycle, which would be triggered by clicking on the link and return
    the resulting `Promise`, whose result is changed for the `result` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned before, exploring Protractor in depth is outside the scope of this
    book. However, if you are unfamiliar with it, it is important to understand that
    all methods in the Protractor API return `Promise`s, but that it is often unnecessary
    to chain them using `then` because Protractor internally queues all asynchronous
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly suggest that you get familiar with this aspect of Protractor before
    trying to write extensive E2E test suites.
  prefs: []
  type: TYPE_NORMAL
- en: The `clickNewButton` method is pretty simple; it selects the element with the
    `cl-create-btn` CSS class and performs a click on it, before waiting for the router
    to complete its navigation cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The `setFilter` method uses another of the Protractor's Aurelia plugin extension
    methods to select the element data-bound to the `filter` property and decorated
    with the `debounce` binding behavior. It then clears its value and sends a given
    sequence of key strokes to it, before letting the browser sleep for 200 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `clickClearFilter` method selects the element with the `cl-clear-filter-btn`
    CSS class and performs a click on it. It then makes the browser sleep for 200
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, a `sleep` instruction after an action is necessary to
    make sure all bindings that may need to react to the action have been updated.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a page object is to encapsulate and abstract away interactions
    with the view. Since all the code dealing with the component's HTML is centralized
    in a single class, the impacts of modifying the component's view will be limited
    to this class. Additionally, as we will see in the next section, the test cases
    themselves will only have to deal with this high-level API over the view, not
    with the intricacies of the HTML structure itself. Most calls to the Protractor
    API will be hidden inside our page objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that most selectors in the previous code snippet use new
    CSS classes to select elements. Let''s add those to the contacts list template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/list.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, before diving in our first test case, let''s quickly add two other
    page objects we''ll need in our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/creation.po.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`test/e2e/src/contacts/details.po.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first page object encapsulates the contact creation component. It simply
    exposes a `getTitle` method, which selects the `h1` element and returns its text
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The second one is for the contact details component. It has a `getFullName`
    method, which allows us to retrieve the displayed full name of the contact by
    selecting the `h1` element and returning its text content.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a first test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that all the tools we need are ready, let''s write a first test case for
    the contacts list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/list.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start with a test setup, which creates an instance of the contacts
    list page object, resets the API, then uses another of the extension methods offered
    by Aurelia's Protractor plugin to load a given URL, and then wait for the Aurelia
    application to finish booting.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a first test case, which uses the page object's methods to ensure
    that some contacts are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though tests running using Protractor are asynchronous, most of the time
    there is no need to use Jasmine's `done` function to let the framework know when
    a test case is finished, because Protractor modifies Jasmine's functions to handle
    asynchronicity itself using its own internal task queue.
  prefs: []
  type: TYPE_NORMAL
- en: The exception to this rule is when performing an asynchronous operation that
    is not handled by Protractor, such as in the `beforeEach` function where we reset
    the API using an asynchronous HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we have everything ready and run our E2E tests. To do this,
    we first need to run the API mock, by opening a console in the `test/e2e/api-mock`
    directory inside our project and executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the API is running, we must also launch the application itself, by opening
    a console in the project''s directory and running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Those two commands are necessary, because the E2E tests will need to load our
    application in a browser in order to execute, and will need to call the API to
    reset its data before each test. Of course, the application itself also needs
    the API to request data and perform actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the API mock and the application are both running, we can launch the E2E
    tests by opening a third console in the project directory and running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the task start, and during the process a Chrome instance will
    show up. You will see the application load and the test case scenario play live
    before your eyes, before Chrome shuts down and the task completes. The complete
    output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running tests](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `e2e` task may occasionally take some time to start when the WebDriver needs
    to update itself first.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the contacts list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know that everything works correctly, let''s add some tests for
    the contacts list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/list.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first of those new test cases makes sure that, when clicking on a contact
    entry in the list, the application navigates to the contact's details component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one makes sure that, when clicking on the **New** button, the application
    navigates to the contact creation component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third one makes sure that, when typing a search term in the filter textbox,
    the list is filtered down using this search term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the fourth one makes sure that, when clearing the filter textbox after
    a search, the list is restored unfiltered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This test suite now covers all the features of the contacts list component.
    If you run the E2E tests at this point, you should see the five test cases pass.
  prefs: []
  type: TYPE_NORMAL
- en: Testing contact creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's try to complicate things a bit by adding a test suite for the contact
    creation component, which includes a complex form with validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll write a reusable class following the page object pattern, which
    will encapsulate the contact form view. This way, we'll be able to use this class
    to test contact creation, and also to eventually test the contact edition.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a base page object for list editors. This class will encapsulate
    the details about how to access and perform actions on parts of one of the `list-editor`
    elements on the contact form component.
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/form.po.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we start by defining a base class named `ListEditorPO`. This class encapsulates
    interaction with a single `list-editor` element in the contact form and knows
    how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a given `option` in a `select` bound to a given property at a given index
    in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a given sequence of keys into a field bound to a given property at a given
    index in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Remove** button at a given index in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll extend this class by writing four specialized page objects, one
    for each type of item a contact can have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/form.po.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a bunch of classes that extend the base `ListEditorPO` class:
    `PhoneNumberListEditorPO`, `EmailAddressListEditorPO`, `AddressListEditorPO`,
    and `SocialProfileListEditorPO`. They all:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the property which the underlying `list-editor` element is bound to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add specialized methods to set the value of the fields of each item in the underlying
    `list-editor`, such as `setType` and `setNumber` for phone numbers, or `setStreet`
    and `setCity` for addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, we''ll write a page object for the contact form itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/form.po.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, we export a class named `ContactFormPO`, which encapsulates interaction
    with the view of the contact form. It has one instance of each of the classes
    extending `ListEditorPO`, so tests can interact with the various `list-editor`
    elements for phone numbers, e-mail addresses, addresses, and social profiles.
    It also has methods allowing us to set the value of the first name, last name,
    company, birthday, and note. Finally, it has a method allowing us to retrieve
    all the validation error messages on the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before being able to write our new tests, we need to connect this form page
    object with the page object for the contact creation component. We''ll also add
    a couple of methods to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/creation.po.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first make the `ContactCreationPO` class inherit the `ContactFormPO`
    class, Then, we add a first method to click on the **Save** button, and another
    method to click on the **Cancel** link.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this ready, it is pretty straightforward to write a test suite for the
    contact creation component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test/e2e/src/contacts/creation.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this test suite's setup, we start by creating page objects for the list and
    the creation components. We reset the API's data, then load the application, and
    click on the **New** button to navigate to the contact creation component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now enrich this test suite with some cases that verify the behavior
    of the contact creation component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define three test cases. The first one makes sure that, when the form
    is in an invalid state and the **Save** button is clicked, no navigation occurs
    and the proper validation messages are displayed. The second one makes sure that,
    when the form is in a valid state and the **Save** button is clicked, the application
    navigates back to the contacts list component. It also ensures that the new contact
    is displayed in the list. The third test case makes sure that clicking on **Cancel**
    makes the application navigate back to the contacts list component. It also ensures
    that no new contact is displayed in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Further testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter could go on much longer by adding tests for other features in our
    application, but writing additional tests would add little value to the learning
    experience of Aurelia in itself. End-to-end testing an Aurelia application with
    Protractor is a topic that deserves its own book. However, the goal of the present
    section was to give you a taste of it and get you started. Hopefully, it did.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to test at both the micro level using unit tests and at the macro
    level using end to end tests is a very valuable quality for a framework. Thanks
    to its modular architecture and its orientation towards components, Aurelia makes
    it fairly easy to write such tests.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, automated testing is a vast subject. Books are written about this topic,
    so it would be vain to try and cover it in depth in a single chapter. However,
    you should have at this point the minimum knowledge to start writing automated
    tests for your own Aurelia application.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the book, most of the major tools required to build a single-page
    application using Aurelia should be on your belt. You may not have mastered them
    all yet, but you know what they are and what their purpose is.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are still a couple of subjects missing, and one of them is internationalization.
    This is what we'll talk about in the next chapter.
  prefs: []
  type: TYPE_NORMAL
