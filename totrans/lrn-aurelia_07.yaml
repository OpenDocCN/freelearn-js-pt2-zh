- en: Chapter 7. Test All the Things
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 测试所有事物
- en: Automated testing has become an important part of most modern software development
    processes. Agile methodologies and approaches such as software craftsmanship emphasize
    the importance of automated tests and often advocate the practice of full-blown
    test-driven development, or TDD.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试已经成为大多数现代软件开发过程的重要组成部分。敏捷方法论和软件工艺等方法强调自动化测试的重要性，并经常提倡进行全面测试驱动开发（TDD）的实践。
- en: A good suite of automated tests adds tremendous value to a project, because
    it assures the team that any code change that breaks existing features won't go
    unnoticed. As such, tests build confidence. Thanks to them, developers are not
    afraid to change things, to play with ideas, to refactor, to make the code better.
    They are in control of their own code base.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一套良好的自动化测试可以为项目增加巨大价值，因为它确保了任何破坏现有特性的代码更改都不会被忽视。因此，测试建立了信心。多亏了它们，开发者才不怕更改事物，玩转想法，重构，让代码变得更好。他们控制着自己的代码库。
- en: Whether you practice TDD or not, it is likely that you may wish to automatically
    test your Aurelia application to some extent. This is what this chapter is about.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否实践TDD，你可能都希望对你的Aurelia应用进行一定程度的自动测试。这就是这一章要讲的内容。
- en: To make testing Aurelia projects easier, the Aurelia team selected a set of
    libraries that is commonly used to test JavaScript projects, **Jasmine**, **Karma**,
    and **Protractor**, and included them in the project skeletons and the CLI project
    generator, along with their respective configuration and the tasks to run the
    tests in the project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试Aurelia项目更容易，Aurelia团队选择了一组通常用于测试JavaScript项目的库**Jasmine**、**Karma**和**Protractor**，并将它们包括在项目骨架和CLI项目生成器中，以及它们相应的配置和项目中的测试运行任务。
- en: Jasmine is a popular testing framework for JS that we will use for both unit
    and end-to-end tests. It can be found at [http://jasmine.github.io/](http://jasmine.github.io/).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine 是一个流行的JS测试框架，我们将用它来进行单元测试和端到端测试。它的位置在 [http://jasmine.github.io/](http://jasmine.github.io/)。
- en: Karma is a test runner that is used under the hood by testing tasks. It can
    be found at [https://karma-runner.github.io/](https://karma-runner.github.io/).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Karma 是一个测试运行器，被测试任务在幕后使用。它的位置在 [https://karma-runner.github.io/](https://karma-runner.github.io/)。
- en: Protractor is an end-to-end testing framework that offers a rich API to interact
    with the browser. It can be found at [http://www.protractortest.org/](http://www.protractortest.org/).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protractor 是一个端到端测试框架，提供了一个丰富的API来与浏览器交互。它的位置在 [http://www.protractortest.org/](http://www.protractortest.org/)。
- en: Unit tests
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In the following section, we will explore how we can unit-test an Aurelia application,
    mainly by adding unit tests in our contact management application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何对Aurelia应用进行单元测试，主要是通过在我们的联系人管理应用中添加单元测试。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are not familiar with Jasmine, you should keep its documentation handy,
    as you may want to look it up while reading this chapter: [http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉Jasmine，你应该将其文档放在手边，因为阅读这一章时你可能需要查阅： [http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html)。
- en: Running unit tests
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: Projects created using the CLI include a task to run unit tests. This task is
    defined in the `aurelia_project/tasks/test.js` file and simply launches Karma
    using the configuration file, `karma.conf.js`, located at the root of the project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CLI创建的项目包括一个运行单元测试的任务。这个任务定义在`aurelia_project/tasks/test.js`文件中，它只是使用位于项目根目录的配置文件`karma.conf.js`来启动Karma。
- en: 'This task can be executed by opening a console in the project directory and
    running the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务可以通过在项目目录中打开控制台并运行以下命令来执行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will launch a single test run and will output the result in the
    console.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将启动单个测试运行，并在控制台输出结果。
- en: 'Similar to the `run` task, the `test` task can be modified with the `watch`
    switch to make it watch the test files and rerun every time a change is detected:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `run` 任务类似，`test` 任务可以通过添加 `watch` 开关来修改，使其监视测试文件，并在检测到任何更改时重新运行：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will launch a test run and will monitor the test files to rerun
    the tests after each change.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将启动一个测试运行，并监视测试文件，在每次更改后重新运行测试。
- en: Configuring validation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置验证
- en: If you took a peek at the code of `aurelia-validation`, you have probably noticed
    that this plugin needs to be loaded before the `ValidationRules` class can be
    used. This is because the methods exposed by `ValidationRules` expect the class
    to be statically initialized with a `ValidationParser` instance in order to, among
    other things, parse string interpolation in error messages.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看了`aurelia-validation`的代码，你可能会注意到这个插件需要在`ValidationRules`类使用之前加载。这是因为`ValidationRules`暴露的方法需要类的静态初始化，用一个`ValidationParser`实例，以便在错误消息中解析字符串插值等。
- en: Since our model classes,  `Contact`, `PhoneNumber`, `Address`, and so on, rely
    on the `ValidationRules` class in their constructor, we won't be able to use any
    of those model classes in any of our tests if we don't initialize it first. Additionally,
    our custom validation rules must also be loaded before they can be used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模型类，如`Contact`、`PhoneNumber`、`Address`等，在其构造函数中依赖于`ValidationRules`类，如果我们不首先初始化它，我们将无法在任何一个测试中使用这些模型类。另外，我们的自定义验证规则在使用之前也必须加载。
- en: 'As such, let''s add a setup file, which will initialize validation at the start
    of every test run:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加一个设置文件，它将在每次测试运行开始时初始化验证：
- en: '`test/unit/setup-validation.js`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/setup-validation.js`'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we start by importing the `rules` file, so our custom validation rules
    are properly registered.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先导入`rules`文件，以便我们的自定义验证规则被正确注册。
- en: Next, we create a DI container and initialize the binding language implementation
    needed by the parser, then use it to create a `ValidationParser` instance, which
    we use to initialize the `ValidationRules` class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个DI容器并初始化解析器所需的绑定语言实现，然后使用它来创建一个`ValidationParser`实例，我们用它来初始化`ValidationRules`类。
- en: 'Lastly, let''s add this file to the unit test setup:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将此文件添加到单元测试设置中：
- en: '`test/aurelia-karma.js`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/aurelia-karma.js`'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we simply add the `setup-validation.js` file to the list of files loaded
    by Karma using `require` when starting a test run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需将`setup-validation.js`文件添加到Karma在开始测试运行时使用`require`加载的文件列表中。
- en: Configuring Bluebird warnings
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Bluebird警告
- en: 'Let''s also configure the Bluebird Promise library''s warnings so our console
    is not flooded with warnings:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也配置Bluebird Promise库的警告，以便我们的控制台不会充斥着警告：
- en: '`test/unit/setup.js`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/setup.js`'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we simply copy and paste the `Promise` configuration that sits at the
    top of `src/main.js`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需复制并粘贴`src/main.js`顶部的`Promise`配置。
- en: At this point, we can start writing unit tests comfortably.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以开始舒适地编写单元测试。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `test/unit/app.spec.js` file contains sample tests for the `app` component
    created by the CLI when initiating the project. As this component has completely
    changed since we started, those tests are no longer relevant and will fail, so
    you should delete this file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/app.spec.js`文件包含了由CLI在初始化项目时创建的`app`组件的示例测试。因为自我们开始以来这个组件已经完全改变了，所以这些测试不再相关并且会失败，所以你应该删除这个文件。'
- en: By convention, files containing unit tests have the `.spec.js` extension. The
    default Karma configuration in Aurelia projects expects tests to sit in files
    following this naming convention, so we will follow it in our contact management
    application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，包含单元测试的文件具有`.spec.js`扩展名。Aurelia项目中的默认Karma配置期望测试位于遵循此命名约定的文件中，因此在我们联系管理应用程序中我们将遵循这一约定。
- en: Unit-testing models
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型单元测试
- en: We will start by testing model classes. They contain a couple of critical features
    that we want to make sure are properly working.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先测试模型类。它们包含一些关键功能，我们想确保它们能正常工作。
- en: 'However, let''s first make sure that our bundles are up-to-date by opening
    a console and running a build:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们首先确保我们的包是最新的，通过打开一个控制台并运行一个构建：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, to make the process of writing tests flow more easily, let''s first launch
    a console and start a continuous test process:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了让编写测试的过程更加流畅，让我们首先启动一个控制台并开始持续测试过程：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The task should start running, and should show something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 任务应该开始运行，并且应该显示类似这样的内容：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The test run returns an error simply because it cannot find any test to run.
    Let's change that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行返回一个错误，因为它找不到要运行的任何测试。让我们改变这个。
- en: Testing static factory methods
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试静态工厂方法
- en: 'The first test we will write will make sure that calling the `fromObject` method
    with an empty object creates an empty `PhoneNumber` object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要写的第一个测试将确保用一个空对象调用`fromObject`方法创建一个空的`PhoneNumber`对象：
- en: '`test/unit/contacts/models/phone-number.spec.js`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/models/phone-number.spec.js`'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we define a single test case that calls the `fromObject` static method
    using an empty object, then makes sure the result is equal to an empty `PhoneNumber`
    object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个测试用例，使用一个空对象调用`fromObject`静态方法，然后确保结果等于一个空`PhoneNumber`对象。
- en: 'If you save the file and take a look at the console, you should see a message
    that looks somewhat like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存文件并查看控制台，你应该会看到类似这样的消息：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s write another test, which will test another angle of `fromObject`. It
    will make sure scalar properties are properly copied to the new `PhoneNumber`
    object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个测试，测试`fromObject`方法的另一个角度。它会确保标量属性被正确地复制到新的`PhoneNumber`对象中：
- en: '`test/unit/contacts/models/phone-number.spec.js`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/models/phone-number.spec.js`'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, our new test calls the `fromObject` static method using an object with
    the expected scalar properties: `type` and `number`. Then,  we ensure each property
    has been properly copied to the resulting `PhoneNumber` object.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的新测试使用一个具有预期标量属性的对象调用`fromObject`静态方法：`type`和`number`。然后，我们确保每个属性都被正确地复制到结果的`PhoneNumber`对象中。
- en: 'Such tests should also be added for the `EmailAddress`, `Address`, and `SocialProfile`
    classes, each in its own file:  `email-address.spec.js`, `address.spec.js`, and
    `social-profile.spec.js`, following the same pattern. I''ll leave this as an exercise
    to the reader. The chapter''s sample application can be used as a reference.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的测试也应添加到`EmailAddress`、`Address`和`SocialProfile`类中，每个类在自己的文件中：`email-address.spec.js`、`address.spec.js`和`social-profile.spec.js`，遵循相同的模式。我将留下这个作为读者的练习。本章节的示例应用程序可以作为参考。
- en: 'Now that the list item classes are tested, let''s write tests for the `Contact`
    class. We''ll start with the same kind of tests we wrote previously:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然已经测试了列表项类，让我们为`Contact`类写测试。我们从之前写的相同类型的测试开始：
- en: '`test/unit/contacts/models/contact.spec.js`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/models/contact.spec.js`'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, the `Contact` class'' `fromObject` method does a little more than
    just copying properties, it also maps the list items to their respective model
    classes. Let''s add tests to ensure this works properly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Contact`类的`fromObject`方法不仅仅是复制属性，它还将列表项映射到相应的模型类。让我们添加一些测试来确保这能正常工作：
- en: '`test/unit/contacts/models/contact.spec.js`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/models/contact.spec.js`'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we add `import` statements for the list item classes. Then we add four
    test cases, one for each list item classes, making sure in each case that an array
    of objects is properly mapped to the corresponding class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了列表项类的`import`语句。然后我们添加了四个测试用例，每个测试用例对应一个列表项类，确保每个情况下对象数组被正确地映射到相应的类中。
- en: Testing computed properties
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试计算属性
- en: 'When it comes to unit testing, computed properties are no different from functions.
    Let''s write some tests to cover the `Contact` class'' `isPerson` property:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到单元测试时，计算属性与函数没有什么不同。让我们写一些测试来覆盖`Contact`类的`isPerson`属性：
- en: '`test/unit/contacts/models/contact.spec.js`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/models/contact.spec.js`'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we add four test cases to make sure the `isPerson` property behaves correctly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了四个测试用例，以确保`isPerson`属性正确地行为。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The variable storing the instance on which the tests will apply is named `sut`,
    which stands for system under test. It is considered a standard term by many authors
    in automated testing. I like to use this acronym, as it clearly identifies who
    the subject of the test is.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 存储测试将应用的实例的变量名为`sut`，代表被测试的系统。许多自动化测试的作者认为这是一个标准术语。我喜欢使用这个缩写，因为它能清楚地标识测试的对象。
- en: I'll leave it as an exercise to the reader to write test cases for the `fullName`
    and the `firstLetter` properties. This chapter's sample application can be used
    as a reference.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留给读者作为练习来编写`fullName`和`firstLetter`属性的测试用例。本章节的示例应用程序可以作为参考。
- en: Unit-testing services
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试服务
- en: 'Testing services is also pretty straightforward. In our contact management
    application, we have a single service: the `ContactGateway`. It is however not
    very testing-friendly at the moment, mainly because of its constructor, which
    configures the `HttpClient` instance.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测试服务也是非常直接的。在我们的联系人管理应用程序中，我们有一个服务：`ContactGateway`。然而目前它并不是非常便于测试，主要问题是它的构造函数，它配置了`HttpClient`实例。
- en: Removing configuration from the gateway constructor
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从网关构造函数中移除配置
- en: 'Let''s refactor our gateway to make it more easily testable. We will move the
    `HttpClient` configuration to the feature''s `configure` function, so the constructor
    of `ContactGateway` doesn''t contain any configuration logic:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的网关，使其更容易测试。我们将把`HttpClient`的配置移动到功能的`configure`函数中，这样`ContactGateway`的构造函数就不包含任何配置逻辑：
- en: '`src/contacts/index.js`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/index.js`'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we create an instance of `HttpClient` using the DI container and configure
    it, then create a `ContactGateway` instance, which we register in the DI container.
    You may notice that we don't register the `HttpClient` itself in the container.
    In most applications, it would be totally OK to do so. However, since we want
    our features to be as independent as possible and other features could possibly
    use distinct `HttpClient` instances to call different backends, we don't register
    this one because it could mess with the other features.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用DI容器创建一个`HttpClient`实例并对其进行配置，然后创建一个`ContactGateway`实例，我们在DI容器中注册它。您可能会注意到我们没有在容器中注册`HttpClient`本身。在大多数应用程序中，这样做是完全没问题的。然而，由于我们希望功能尽可能独立，其他功能可能会使用不同的`HttpClient`实例来调用不同的后端，所以我们不注册这个，因为它可能会与其他功能发生冲突。
- en: 'Next, we can remove the configuration code from the constructor of `ContactGateway`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以从`ContactGateway`的构造函数中删除配置代码：
- en: '`src/contacts/services/gateway.js`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/services/gateway.js`'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The constructor of `ContactGateway` is now free of any configuration logic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactGateway`的构造函数现在没有任何配置逻辑。'
- en: 'Since we changed code in our application, we need to rebuild it before adding
    tests:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在应用程序中更改了代码后，在添加测试之前我们需要重新构建它：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing read methods
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试读方法
- en: 'Let''s start by writing a couple of tests for the two read methods of `ContactGateway`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为`ContactGateway`的两个读方法编写一些测试：
- en: '`test/unit/contacts/services/gateway.spec.js`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/services/gateway.spec.js`'
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we start by defining a test setup using Jasmine's `beforeEach` function.
    This test setup will be executed before each test case. In this setup, we first
    create a mock for the `HttpClient`, then we create the `ContactGateway` instance
    on which our test will apply.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用Jasmine的`beforeEach`函数定义一个测试设置。这个测试设置将在每个测试用例之前执行。在这个设置中，我们首先为`HttpClient`创建一个模拟对象，然后我们创建一个`ContactGateway`实例，我们的测试将对其进行操作。
- en: 'Next, we define two helper functions: the first one to create a `Contact` object,
    and the second one to create a mock for a response object with a JSON body. Those
    two functions will be used by our test cases.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了两个帮助函数：第一个用于创建一个`Contact`对象，第二个用于创建一个具有JSON正文的响应对象的模拟。这两个函数将被我们的测试用例使用。
- en: 'Lastly, we write test cases to verify that the `getAll` and the `getById` methods
    work properly. The two test cases are asynchronous tests, so they ask for a `done`
    function to be passed as parameter, which they will call when the test is completed.
    They both follow the same pattern:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编写测试用例以验证`getAll`和`getById`方法是否正常工作。这两个测试用例都是异步测试，所以它们需要一个`done`函数作为参数，当测试完成后它们将调用这个函数。它们都遵循相同的模式：
- en: Create the `Contact` object(s) that should be returned by the tested method.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应该由测试方法返回的`Contact`对象。
- en: Configure the mocked `fetch` method of `HttpClient`, so it returns a `Promise`
    resolving to a mocked response object, which exposes the data to return as a JSON
    body.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置模拟的`HttpClient`的`fetch`方法，使其返回一个`Promise`，该`Promise`解析为一个模拟的响应对象，它暴露出作为JSON正文返回的数据。
- en: 'Call the tested method and, when it resolves:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用测试方法，当它解析时：
- en: Check that the returned `Promise` resolves to the expected data
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查返回的`Promise`解析为预期的数据
- en: Check that the `fetch` method of `HttpClient` was called with the proper arguments
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`HttpClient`的`fetch`方法是否用适当的参数调用
- en: Testing write methods
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试写方法
- en: 'Testing write methods is pretty similar. However, it needs a little more work,
    as the HTML5 File API offers no easy way to compare `Blob` objects at the moment.
    So in order to test the bodies of the requests sent by our gateway, we need to
    write some helper functions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 测试写方法相当相似。然而，它需要做一些额外的工作，因为目前HTML5 File API没有提供一种简单的方法来比较`Blob`对象。所以为了测试我们网关发送的请求的正文，我们需要编写一些帮助函数：
- en: '`test/unit/contacts/services/gateway.spec.js`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/services/gateway.spec.js`'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first helper function, named `readBlob`, simply takes a `Blob` object as
    its parameter and returns a `Promise`, which resolves to the content of the `Blob`
    as a string. Since the process of reading `Blob` content is asynchronous, it just
    wraps this process in a `Promise`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个助手函数，名为`readBlob`，简单地接受一个`Blob`对象作为其参数，并返回一个`Promise`，该`Promise`解析为`Blob`内容作为一个字符串。由于读取`Blob`内容的过程是异步的，它只是用一个`Promise`包装这个过程。
- en: The second helper function, named `expectBlobsToBeEqual`, expects two `Blob`
    objects as its parameters. It first compares their `type` and `size` properties
    to make sure they are equal, then uses `readBlob` to retrieve the content of the
    two `Blob` objects and compares the results to make sure they also are equal,
    returning the resulting `Promise`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个助手函数，名为`expectBlobsToBeEqual`，期望两个`Blob`对象作为其参数。它首先比较它们的`type`和`size`属性以确保它们相等，然后使用`readBlob`来检索两个`Blob`对象的内容并比较结果以确保它们也相等，返回结果`Promise`。
- en: The last helper function, named `expectFetchToHaveBeenCalled`, receives the
    expected path and the expected request properties. It first extracts the expected
    body from the expected request properties, if any, and deletes it from the object.
    Then, it ensures that the mocked `fetch` method of `HttpClient` has been called
    with the expected path and the expected request properties minus the body, because
    comparing `Blob` objects is an asynchronous process that must be performed separately.
    Lastly, if an expected body was provided, it calls the `expectBlobsToBeEqual`
    function using both the body passed to the last call to `fetch` and the expected
    body, and returns the resulting `Promise`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个助手函数，名为`expectFetchToHaveBeenCalled`，接收预期的路径和预期的请求属性。它首先从预期的请求属性中提取预期的主体，如果有，从对象中删除它。然后，它确保`HttpClient`的模拟`fetch`方法已经用预期的路径和减去主体的预期请求属性被调用，因为比较`Blob`对象是一个必须单独执行的异步过程。最后，如果提供了预期的主体，它使用传递给最后一个`fetch`调用的主体和预期的主体调用`expectBlobsToBeEqual`函数，并返回结果`Promise`。
- en: 'This last helper function will help us write assertions on how our gateway
    calls the `fetch` method of its `HttpClient`. Let''s start with a test for the
    `create` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的助手函数将帮助我们编写关于我们的网关如何调用其`HttpClient`的`fetch`方法的断言。让我们从一个`create`方法的测试开始：
- en: '`test/unit/contacts/services/gateway.spec.js`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/services/gateway.spec.js`'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we start by importing the `json` function from the Fetch client. We will
    use it to transform the expected request payload in a JSON-encoded `Blob` object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从Fetch客户端导入`json`函数。我们将使用它将预期的请求负载转换为JSON编码的`Blob`对象。
- en: 'The test by itself is pretty straightforward and sets the path for the next
    tests, which will follow the same pattern:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试本身相当直接，为接下来的测试设定了路径，这些测试将遵循相同的模式：
- en: Create a `Contact` object that will be passed to the tested method.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Contact`对象，将被传递给被测试的方法。
- en: Configure the mocked `fetch` method of `HttpClient` so it returns a resolved
    `Promise`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`HttpClient`的模拟`fetch`方法，使其返回一个解决的`Promise`。
- en: Call the tested method and, when it resolves, check that the `fetch` method
    of `HttpClient` was called with the proper arguments.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用被测试的方法，当它解决时，检查`HttpClient`的`fetch`方法是否用正确的参数被调用。
- en: 'The tests for the `update` and `updatePhoto` methods are pretty similar:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`和`updatePhoto`方法的压力测试非常相似：'
- en: '`test/unit/contacts/services/gateway.spec.js`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/services/gateway.spec.js`'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Those two tests follow the same pattern as the previous one.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试遵循与之前一个相同的模式。
- en: Unit-testing value converters
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对值转换器进行单元测试
- en: Testing value converters is not much different from testing services. Of course,
    it depends on the complexity of the converters you need to test. In our contact
    management application, the value converters are pretty simple.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试值转换器与测试服务并没有太大区别。当然，这取决于你需要测试的转换器的复杂性。在我们的联系人管理应用程序中，值转换器相当简单。
- en: 'Let''s write a test or two for our `orderBy` value converter to get a feel
    for it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`orderBy`值转换器写一个或两个测试来了解一下它：
- en: '`test/unit/resources/value-converters/order-by.spec.js`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/value-converters/order-by.spec.js`'
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we first define a simple test setup that creates the test subject, then
    we add two test cases. The first one verifies that the array passed to the `toView`
    method is properly sorted using the specified property. The second verifies that
    the array passed to the `toView` method is sorted in reverse order when `"desc"`
    is passed as the third parameter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义一个简单的测试设置，创建测试主题，然后我们添加两个测试用例。第一个验证传递给`toView`方法的数组是否正确地使用指定的属性进行排序。第二个验证当`"desc"`作为第三个参数传递时，传递给`toView`方法的数组是否按降序排序。
- en: Of course, if the value converter to the test supports two-way binding and has
    a `fromView` method, additional test cases should be added to cover this second
    method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果测试支持的值转换器支持双向绑定并且有一个`fromView`方法，应该添加额外的测试用例来涵盖这个第二个方法。
- en: I'll leave it as an exercise to the reader to write tests for the `groupBy`
    and `filterBy` value converters. This chapter's sample application can be used
    as a reference.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留给读者一个练习，为`groupBy`和`filterBy`值转换器编写测试。本章的示例应用程序可以作为参考。
- en: Unit-testing custom elements and attributes
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试自定义元素和属性
- en: All the tests we've written so far have little to do with Aurelia. The code
    we tested could be used in a whole different UI framework, and the chances are
    nothing would need to change. This is because we didn't test anything visual yet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所写的所有测试都与Aurelia关系不大。我们测试的代码可以在一个完全不同的UI框架中使用，而且很可能不需要做任何改变。这是因为我们还没有测试任何视觉方面。
- en: When testing custom elements and attributes, we could settle for the types of
    test we wrote previously and test only their view-models. The tests would cover
    only the behavioral aspect of the components. However, having tests that can cover
    components as a whole, including their view counterpart, would be much more powerful.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试自定义元素和属性时，我们可能会满足于我们之前编写的测试类型，并且只测试它们的视图模型。这些测试将只涵盖组件的行为方面。然而，能够涵盖组件整体的测试，包括它们的视图对应部分，将会更加强大。
- en: The component tester
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件测试器
- en: 'Thankfully, Aurelia offers the `aurelia-testing` library, which can be used
    to fully test components. As such, it exports two important classes: `StageComponent`
    and `ComponentTester`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Aurelia提供了`aurelia-testing`库，可以用来全面测试组件。因此，它导出两个重要的类：`StageComponent`和`ComponentTester`。
- en: 'The `StageComponent` class has a single static method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageComponent`类有一个单一的静态方法：'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method simply creates an instance of the `ComponentTester` class behind
    the scenes, calls its own `withResources` method, and then returns it. `StageComponent`
    is basically just API sugar over the component tester. The two following lines
    could be switched without any effect:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法简单地在幕后创建一个`ComponentTester`类的实例，调用它自己的`withResources`方法，然后返回它。`StageComponent`基本上只是对组件测试器的API糖。以下两行可以互换而不产生任何效果：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `ComponentTester` class offers an API to configure a short-lived, sandboxed
    Aurelia application, in which the tested component will live during the test:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComponentTester`类提供了一个API来配置一个短暂存在的、沙盒化的Aurelia应用程序，在该应用程序中，被测试的组件将在测试期间运行：'
- en: '`withResources(resources: string | string[]): ComponentTester`: Loads the provided
    resources as global resources in the sandbox application.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withResources(resources: string | string[]): ComponentTester`: 将提供的资源作为全局资源加载到沙盒应用程序中。'
- en: '`inView(html: string): ComponentTester`: Uses the provided HTML as the root
    view of the sandbox application.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inView(html: string): ComponentTester`: 使用提供的HTML作为沙盒应用程序的根视图。'
- en: '`boundTo(bindingContext: any): ComponentTester`: Uses the provided value as
    the binding context for the root view of the sandbox application.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boundTo(bindingContext: any): ComponentTester`: 使用提供的值作为沙盒应用程序的根视图的绑定上下文。'
- en: '`manuallyHandleLifecycle(): ComponentTester`: Tells the component tester that
    the life cycle of the application should be handled manually by the test case.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manuallyHandleLifecycle(): ComponentTester`: 告诉组件测试器应用程序的生命周期应该由测试用例手动处理。'
- en: '`bootstrap(configure: (aurelia: Aurelia) => void): void`: Uses the provided
    function to configure the sandboxed Aurelia application. By default, the application
    is configured using `aurelia.use.standardConfiguration()`. This method can be
    used to load additional plugins or features required by a component.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap(configure: (aurelia: Aurelia) => void): void`: 使用提供的函数配置沙盒Aurelia应用程序。默认情况下，应用程序使用`aurelia.use.standardConfiguration()`进行配置。这个方法可以用来加载组件所需的额外插件或功能。'
- en: '`create(bootstrap: (aurelia: Aurelia) => Promise<void>): Promise<void>`: Creates
    the sandbox application using the provided bootstrapping function. Most commonly,
    the `aurelia-bootstrapper` library''s `bootstrap` function will be used here.
    The returned `Promise` is resolved when the application is loaded and has booted.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create(bootstrap: (aurelia: Aurelia) => Promise<void>): Promise<void>`：使用提供的引导函数创建沙盒应用程序。通常，这里会使用`aurelia-bootstrapper`库的`bootstrap`函数。返回的`Promise`在应用程序加载并启动后解决。'
- en: '`bind(): Promise<void>`: Binds the sandbox application. It can only be used
    when the application life cycle is handled manually.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind(): Promise<void>`：绑定沙盒应用程序。它只能在手动处理应用程序生命周期时使用。'
- en: '`attached(): Promise<void>`: Attaches the sandbox application to the DOM. It
    can only be used when the application life cycle is handled manually.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attached(): Promise<void>`：将沙盒应用程序附加到DOM。它只能在手动处理应用程序生命周期时使用。'
- en: '`detached(): Promise<void>`: Detaches the sandbox application from the DOM.
    It can only be used when the application life cycle is handled manually.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detached(): Promise<void>`：将沙盒应用程序从DOM中分离。它只能在手动处理应用程序生命周期时使用。'
- en: '`unbind(): Promise<void>`: Unbinds the sandbox application. It can only be
    used when the application life cycle is handled manually.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unbind(): Promise<void>`：解绑沙盒应用程序。它只能在手动处理应用程序生命周期时使用。'
- en: '`dispose()`: Disposes all resources of the sandbox application and completely
    removes it from the DOM.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispose()`：清理沙盒应用程序的所有资源并完全将其从DOM中移除。'
- en: At the time of writing, the `aurelia-testing` library is still in beta, so there
    will probably be some new features added to it before its release.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`aurelia-testing`库仍处于测试阶段，因此在发布之前可能会向其添加一些新功能。
- en: Testing the file-drop-target attribute
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试file-drop-target属性
- en: 'Let''s see how to use the component tester by writing a test suite for the
    `file-drop-target` custom attribute we wrote in [Chapter 5](ch05.html "Chapter 5. Making
    Reusable Components"), *Making Reusable Components*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个针对我们在[第5章](ch05.html "Chapter 5. Making Reusable Components")，*创建可复用组件*中编写的`file-drop-target`自定义属性的测试套件，看看如何使用组件测试器：
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/attributes/file-drop-target.spec.js`'
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we start by creating an empty test suite, which contains a test setup
    using the `beforeEach` function and a test teardown using the `afterEach` function.
    In the test setup, we first create a `viewModel` object with a `files` property,
    which will be bound to our `file-drop-target` attribute. Secondly, we use the
    `StageComponent` class to create a sandboxed Aurelia application in which our
    custom attribute will live during each test.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个空的测试套件，它包含使用`beforeEach`函数的测试设置和使用`afterEach`函数的测试清理。在测试设置中，我们首先创建一个具有`files`属性的`viewModel`对象，该属性将绑定到我们的`file-drop-target`属性。其次，我们使用`StageComponent`类创建一个沙盒Aurelia应用程序，在该应用程序中，我们的自定义属性将在每次测试中运行。
- en: This sandboxed application will load the `file-drop-target` attribute as a global
    resource. Its root view will be a `div` element with the `file-drop-target` attribute
    on it, bound to the `files` property of the root binding context, which will be
    the `viewModel` object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个沙盒应用程序将`file-drop-target`属性作为全局资源加载。其根视图将是一个带有`file-drop-target`属性的`div`元素，绑定到根绑定上下文的`files`属性，这将是`viewModel`对象。
- en: We also define a `create` helper function, which will create and boot the sandboxed
    application and will retrieve the `element` hosting our `file-drop-target` attribute
    once the application is rendered.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`create`辅助函数，该函数将创建和引导沙盒应用程序，并在应用程序渲染后检索托管我们的`file-drop-target`属性的`element`。
- en: Lastly, in the test teardown, we simply `dispose` the sandbox.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在测试清理过程中，我们只需`dispose`沙盒。
- en: 'In order to test the `file-drop-target` custom attribute, we will need to fire
    drag and drop events on the `element` hosting the tested attribute. As such, let''s
    start by writing a factory function to create such events:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`file-drop-target`自定义属性，我们将需要在我们正在测试的属性托管的`element`上触发拖放事件。因此，让我们先编写一个工厂函数来创建此类事件：
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/attributes/file-drop-target.spec.js`'
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function is pretty straightforward. It simply creates an `Event` object
    using the `type` of event passed as a parameter. It also tells the event that
    it should bubble up the DOM when fired. Lastly, it assigns the provided `dataTransfer`
    object on the event, before returning it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当直接。它只是使用作为参数传递的事件的`type`创建一个`Event`对象。它还告诉事件在触发时应该在DOM上冒泡。最后，它在返回之前将提供的`dataTransfer`对象分配给事件。
- en: 'We will use this function in a bunch of other functions, which will be used
    to trigger the various steps of a drag and drop process:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在许多其他函数中使用这个函数，这些函数将用于触发拖放过程的各种步骤：
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/attributes/file-drop-target.spec.js`'
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These three functions each create and dispatch a specific drag and drop event.
    They also return a `Promise` whose resolution will occur once the browser's event
    queue has been emptied.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数各自创建并派发一个特定的拖放事件。它们还返回一个`Promise`，其解决将在浏览器的事件队列被清空时发生。
- en: Updating a binding is often an asynchronous process, depending on the type of
    binding. Aurelia's binding engine heavily relies on the browser's event loop to
    make the process of updating bindings as smooth as possible.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更新绑定通常是一个异步过程，取决于绑定类型。Aurelia的绑定引擎严重依赖于浏览器的事件循环，以使更新绑定的过程尽可能平滑。
- en: As such, returning a `Promise` whose `resolve` function is pushed at the end
    of the browser's event queue using `setTimeout` is a technique used in tests to
    make sure that bindings that may need to react to a property being updated or
    an event being dispatched have the time to update themselves.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，返回一个`Promise`，其`resolve`函数被推送到浏览器事件队列的末尾，使用`setTimeout`是一种在测试中使用的技术，以确保需要对属性进行更新或事件派发时，有足够的时间更新绑定。
- en: 'Lastly, we will need to create `File` objects to use in our tests:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建`File`对象以在我们的测试中使用：
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/attributes/file-drop-target.spec.js`'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we have all the tools we need to write a first test case:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了编写第一个测试用例所需的所有工具：
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/attributes/file-drop-target.spec.js`'
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This test makes sure that, when dragging and then dropping a list of files on
    the element hosting our custom attribute, the files in the drop event are assigned
    to the property bound to the attribute.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试确保，当拖动然后将一个文件列表拖放到承载我们自定义属性的元素上时，事件中的文件被分配给绑定属性的属性。
- en: This test starts by creating a list of `files` and dispatching a `dragover`
    event, which is useless in itself but is there just to follow the standard process
    of a drag and drop operation. Next, it dispatches a `drop` event using the `files`
    created previously. Lastly, it makes sure that the `files` were correctly assigned
    to the `files` property of the `viewModel`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试首先创建一个`files`列表并派发一个`dragover`事件，本身没有用，但只是为了遵循拖放操作的标准过程。接下来，它使用之前创建的`files`派发一个`drop`事件。最后，它确保`files`被正确分配给`viewModel`的`files`属性。
- en: 'Lastly, let''s add another test case to make sure that the event''s data is
    properly cleared:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加另一个测试用例，以确保事件数据被正确清除：
- en: '`test/unit/resources/attributes/file-drop-target.spec.js`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/attributes/file-drop-target.spec.js`'
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you run the tests now, they should all be green.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，它们都应该通过。
- en: Testing the list-editor element
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试list-editor元素
- en: 'Unit-testing a custom element is very similar. Let''s see how it works by testing
    the `list-editor` custom element we wrote previously:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对自定义元素进行单元测试非常相似。让我们通过测试我们之前编写的`list-editor`自定义元素来看看它是如何工作的：
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/elements/list-editor.spec.js`'
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we start by creating a test suite with a test setup that creates an empty
    array of `items` and mocks a function to create new items. It also creates a component
    tester that will load the `list-editor` as a global resource, use the `list-editor`
    element in its root view, and define as the root binding context an object containing
    the array of `items` and the mocked `createItem` function, which will be bound
    to the `list-editor` instance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个测试套件，它有一个创建一个空`items`数组的测试设置，并模拟一个用于创建新项目的函数。它还创建了一个组件测试器，将`list-editor`作为全局资源加载，在其根视图中使用`list-editor`元素，并将包含`items`数组和模拟的`createItem`函数的对象定义为根绑定上下文，该函数将绑定到`list-editor`实例。
- en: We also define a `create` function, which will create and bootstrap the sandboxed
    application in which the tested element will live during each test. It will also
    retrieve the `list-editor` DOM element once the application is booted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`create`函数，它将创建并引导沙盒应用程序，在该应用程序中，测试元素将在每次测试期间运行。它在应用程序启动后还会检索`list-editor`
    DOM元素。
- en: Lastly, we define a test teardown that will simply `dispose` the component tester.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个测试清理函数，它将简单地`dispose`组件测试器。
- en: 'Of course, we''ll need objects to use as items. Let''s create a simple class
    that we can use in our test cases:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要用项目作为对象。让我们创建一个简单的类，我们可以在测试用例中使用：
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/elements/list-editor.spec.js`'
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This simple `Item` class expects a `text` value in its constructor, and returns
    this `text` when converted to string.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的`Item`类在构造函数中期望有一个`text`值，当转换为字符串时返回这个`text`。
- en: In our tests, we'll need to retrieve various elements that are rendered by the
    `list-editor`, either to check that some things are properly rendered or to trigger
    actions. As such, let add some CSS classes in the view of `list-editor`. Those
    classes will help us select specific elements without relying on the HTML structure
    itself, which would make the tests brittle, because any change to the HTML structure
    could break them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们需要检索由`list-editor`渲染的各种元素，以检查某些事情是否正确渲染，或者触发操作。因此，让我们在`list-editor`的视图中添加一些CSS类。这些类将帮助我们选择特定的元素，而不依赖于HTML结构本身，这会使测试变得脆弱，因为任何对HTML结构的更改都可能破坏它们。
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.html`'
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we simply add a `le-item` CSS class on each element acting as the root
    of each item. We also add a `le-remove-btn` CSS class to each button allowing
    us to remove items from the list. Lastly, we add a `le-add-btn` CSS class to the
    button allowing us to add an item to the list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地在每个作为每个项目根的元素上添加了一个`le-item` CSS类。我们还在每个允许我们从列表中删除项目的按钮上添加了一个`le-remove-btn`
    CSS类。最后，我们在允许向列表中添加项目的按钮上添加了一个`le-add-btn` CSS类。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `le` prefix stands for list editor. It's not an attempt to write French
    cartoon.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`le`前缀代表列表编辑器。这不是尝试写法语卡通。'
- en: 'Just like we did before, we have to rebuild the application, so the bundles
    are up-to-date and include the new CSS classes in the `list-editor` template:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们必须重新构建应用程序，以便包是更新的，并且包括在`list-editor`模板中的新CSS类：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s add a couple of helper functions to retrieve elements, perform actions,
    or assert results on the rendered DOM inside our tested element:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些助手函数，以便在我们的测试元素内检索元素、执行操作或断言渲染DOM的结果：
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/elements/list-editor.spec.js`'
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we define the following functions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了以下函数：
- en: '`getItemsViews`: Retrieves elements (the roots of each `items`).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getItemsViews`：检索元素（每个`items`的根）。'
- en: '`clickRemoveButtonAt`: Retrieves the **Remove** button for the item at the
    given index and triggers a `click` event on it. It returns a `Promise` that will
    resolve when the browser''s event queue is emptied, to make sure all bindings
    are up-to-date.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clickRemoveButtonAt`：检索给定索引处的项目的**删除**按钮，并在其上触发一个`click`事件。它返回一个`Promise`，当浏览器的事件队列清空时，它将解决，以确保所有绑定都是最新的。'
- en: '`clickAddButton`: Retrieves the **Add** button and triggers a `click` event
    on it. It returns a `Promise` that will resolve when the browser''s event queue
    is emptied, to make sure all bindings are up-to-date.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clickAddButton`：检索**添加**按钮，并在其上触发一个`click`事件。它返回一个`Promise`，当浏览器的事件队列清空时，它将解决，以确保所有绑定都是最新的。'
- en: '`isItemRendered`: Returns `true` if the provided item has been rendered in
    the DOM of `list-editor` and `false` otherwise.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isItemRendered`：如果提供的项目已经在`list-editor`的DOM中渲染，则返回`true`，否则返回`false`。'
- en: '`areAllItemsRendered`: Returns `true` if the items have all been rendered in
    the DOM of `list-editor` and `false` otherwise.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`areAllItemsRendered`：如果所有项目已经在`list-editor`的DOM中渲染，则返回`true`，否则返回`false`。'
- en: At this point, we have everything we need to write our tests.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经有了编写测试所需的一切。
- en: 'Let''s first verify that all the items are properly rendered:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先验证所有项目是否正确渲染：
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/elements/list-editor.spec.js`'
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let''s add tests to make sure that, when clicking on an item''s **Remove**
    button, the item gets deleted:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一些测试，以确保当点击项目的**删除**按钮时，该项目会被删除：
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/elements/list-editor.spec.js`'
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lastly, let''s add a test case to make sure that a click on the **Add** button
    will create a new item and will add it to the list:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个测试用例，以确保点击**添加**按钮将创建一个新项目，并将其添加到列表中：
- en: '`test/unit/resources/elements/list-editor.spec.js`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/resources/elements/list-editor.spec.js`'
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At this point, all the tests should pass.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，所有测试都应该通过。
- en: Unit-testing route components
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试路由组件
- en: At the time of writing, there is no way to test a route component using `ComponentTester`.
    We can only test the view-model's behavior in unit tests, and rely on end-to-end
    tests to verify the view. The Aurelia team, however, plans to add this feature;
    you should check it out, in case it has already been released when you read this
    book.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，没有一种方法可以利用`ComponentTester`测试路由组件。我们只能在单元测试中测试视图模型的行为，并依赖端到端测试来验证视图。然而，Aurelia团队计划添加这个功能；你应该查看一下，以防在你阅读这本书时它已经被发布了。
- en: 'Unit-testing the view-model of such components is not very different from most
    of the tests we already wrote, but let''s see a quick example by writing a test
    suite for the contact creation component:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对这类组件的视图模型进行单元测试与我们已经编写的大多数测试并没有太大区别，但让我们通过编写一个联系人创建组件的测试套件来举一个快速的例子：
- en: '`test/unit/contacts/components/creation.spec.js`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/components/creation.spec.js`'
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we start by creating a test suite with a test setup that creates a bunch
    of mocks, and then creates the SUT using those mocks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们首先创建一个测试套件，该套件包含一个测试设置，用于创建一组模拟对象，然后使用这些模拟对象创建被测试系统（SUT）。
- en: 'Let''s also add a helper function to create a validation error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个帮助函数来创建验证错误：
- en: '`test/unit/contacts/components/creation.spec.js`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/components/creation.spec.js`'
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Lastly, let''s add a first test case to make sure nothing happens when trying
    to save an invalid contact, and a second test case to make sure that saving a
    valid contact does the right thing:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个测试用例，以确保在尝试保存无效联系人时什么也不会发生，再添加一个测试用例，以确保保存有效联系人时能做正确的事情：
- en: '`test/unit/contacts/components/creation.spec.js`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/unit/contacts/components/creation.spec.js`'
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This gives a good idea of how to test the view-model of a route component. I'll
    leave it as an exercise to the reader to add tests for the other route components
    in the `contacts` feature. This chapter's sample application can be used as a
    reference.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个很好的测试路由组件视图模型的想法。我将留给读者作为练习，为`contacts`特性中的其他路由组件添加测试。本章节的示例应用程序可以作为参考。
- en: End-to-end tests
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: While the purpose of unit tests is to verify units of code in isolation, end-to-end
    (**E2E**) tests are intended to validate the application as a whole. Those tests
    can go to various depths. Their scope may be limited to the client application
    itself. In such a case, any distant service used by the application needs be mocked
    one way or another.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的目的是验证代码单元的隔离，而端到端（**E2E**）测试的目的是验证整个应用程序。这些测试可以有不同的深度。它们的范围可能限于客户端应用程序本身。在这种情况下，应用程序所使用的任何远程服务都需要以某种方式被模拟。
- en: They can also cover the whole system. Most of the time, this means that the
    services backing the application must be deployed to a test location and initialized
    with well-controlled test data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以涵盖整个系统。大多数时候，这意味着支持应用程序的服务必须部署到一个测试位置，并用受控的测试数据进行初始化。
- en: Whatever your end-to-end test strategy is, the technology stays pretty much
    the same. In this section, we will see how to leverage Protractor to write functional
    test scenarios for our contact management application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的端到端测试策略是什么，技术上基本保持不变。在本节中，我们将了解如何利用Protractor为我们的联系人管理应用程序编写功能测试场景。
- en: Setting things up
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: At the time of writing, the CLI doesn't include a Protractor setup. Since we
    started our project using the CLI, let's see how we can add support for end-to-end
    tests to our application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，CLI不包括Protractor的设置。由于我们是用CLI开始项目的，让我们看看如何向我们的应用程序添加端到端测试的支持。
- en: 'We first need to install the `protractor` plugin for Gulp, along with the `del`
    library. Open a console in the project''s directory and run the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要安装Gulp的`protractor`插件以及`del`库。在项目的目录中打开一个控制台，并运行以下命令：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we need to store some configuration values about the end-to-end testing
    process. Let''s add these to the `aurelia.json` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要存储一些关于端到端测试过程的配置值。让我们把这些添加到`aurelia.json`文件中：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This new section contains paths and transpiler options that will be used by
    our E2E task.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新部分包含路径和转换器选项，这些将被我们的端到端任务使用。
- en: 'This task is pretty straightforward: it transpiles the test suite using Babel,
    so it can run on Node, and then launches Protractor. Let''s first write the task
    descriptor:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务相当直接：它使用Babel转换测试套件，因此可以在Node上运行，然后启动Protractor。让我们首先编写任务描述符：
- en: '`aurelia_project/tasks/e2e.json`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/tasks/e2e.json`'
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, let''s write the task itself:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写任务本身：
- en: '`aurelia_project/tasks/e2e.js`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/tasks/e2e.js`'
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you are not familiar with Gulp, let me quickly explain what this task does:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉Gulp，让我快速解释一下这个任务做什么：
- en: It updates WebDriver if needed
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有需要，它将更新WebDriver。
- en: It cleans the output directory, where the transpiled test suite sits
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它清理输出目录，那里存放着编译后的测试套件。
- en: It transpiles the test suite in the output directory
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将测试套件编译到输出目录中。
- en: It launches Protractor.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启动了Protractor。
- en: Note
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Protractor is mostly an API that sits over Selenium, which is the actual engine
    allowing us to play scenarios in a browser. WebDriver is the Node bindings that
    allow us to communicate with Selenium.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Protractor主要是一个API，它建立在Selenium之上，Selenium是允许我们在浏览器中播放场景的实际引擎。WebDriver是Node绑定，允许我们与Selenium通信。
- en: 'You may have noticed that a configuration file path is passed to Protractor.
    Let''s write this configuration:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了一个配置文件路径被传递给了Protractor。让我们编写这个配置：
- en: '`protractor.conf.js`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`protractor.conf.js`'
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Exploring Protractor in any depth is outside the scope of this book. However,
    you can probably understand from this configuration that it will use Google Chrome
    to run the tests, that it expects the test files to sit in the `test/e2e/dist`
    directory, which is where we configured our task to transpile our test suite,
    and that a plugin is loaded from the `aurelia-tools` package. The `aurelia-tools`
    library is already included in CLI-based projects, so there no need to install
    it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探索Protractor超出了本书的范围。然而，从这个配置中，你可能可以理解到它将使用Google Chrome来运行测试，它期望测试文件位于`test/e2e/dist`目录中，这是我们配置任务以编译我们的测试套件的地方，并且从`aurelia-tools`包中加载了一个插件。`aurelia-tools`库已经包含在基于CLI的项目中，所以不需要安装。
- en: This last part is pretty important, since this plugin adds some Aurelia-specific
    methods to the Protractor API. We'll see those in the following section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分相当重要，因为这个插件向Protractor API添加了一些Aurelia特定的方法。我们将在下一节中看到这些方法。
- en: Mocking the backend
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟后端
- en: Our contact management application does not live by itself. It sits over an
    HTTP-based API, which allows the application to access data and perform actions.
    As such, we need a controlled version of the API, a kind of mock, actually, which
    will contain a predefined set of data, and which we can reset to its original
    state before each test.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的联系人管理应用程序并不是独立存在的。它建立在一个基于HTTP的API之上，该API允许应用程序访问数据和执行操作。因此，我们需要一个受控的API版本，实际上是一个模拟，它将包含一组预定义的数据，并且我们可以在每次测试之前将其重置为原始状态。
- en: You can take this mocked API from this book's artifacts. Simply copy the `chapter-7\app\test\e2e\api-mock`
    directory from the samples and paste it in the `test\e2e` directory of your own
    project. You will probably need to create the `e2e` directory first.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的工件中获取这个模拟的API。只需将`samples`中的`chapter-7\app\test\e2e\api-mock`目录复制到您自己项目的`test\e2e`目录中。您可能需要先创建`e2e`目录。
- en: 'Once this is done, make sure you restore all dependencies needed by the API
    mock by opening a console in the `api-mock` directory and running the following
    command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个步骤，请确保通过在`api-mock`目录中打开控制台并运行以下命令来恢复API模拟器所需的所有依赖项：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The API mock is now ready to run.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: API模拟器现在准备运行。
- en: 'In order to reset the data set before each test, we''ll need a helper function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在每次测试之前重置数据集，我们将需要一个帮助函数：
- en: '`test/e2e/src/contacts/api-mock.js`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/api-mock.js`'
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In case you didn't know, Protractor runs on Node, not in the browser. As such,
    we start by importing the `http` Node module. Next, we define and export a `resetApi`
    function, which simply sends a `POST` request to the `/reset` endpoint of our
    HTTP API. It also returns a `Promise`, which is resolved when the HTTP request
    completes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道，Protractor是在Node上运行的，而不是在浏览器中。因此，我们首先导入Node的`http`模块。接下来，我们定义并导出一个`resetApi`函数，该函数简单地向我们HTTP
    API的`/reset`端点发送一个`POST`请求。它还返回一个`Promise`，当HTTP请求完成时解析。
- en: This function tells the backend to reset its dataset to its original state.
    We will call it before every test, so each test can be sure to work with the same
    set of data, even if a previous test created a new contact or updated an existing
    one.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数告诉后端将它的数据集重置为其原始状态。我们将在每个测试之前调用它，所以每个测试都可以确信它是在相同的数据集上工作，即使之前的测试创建了一个新的联系人或更新了一个现有的联系人。
- en: The page object pattern
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面对象模式
- en: A typical E2E test will load a given URL, retrieve one or many DOM elements
    from the document, perform an action or dispatch an event on this or those elements,
    and then verify that the expected outcome was achieved.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的端到端测试将加载一个给定的URL，从文档中检索一个或多个DOM元素，对这个或这些元素执行一个动作或分发一个事件，然后验证是否达到了预期的结果。
- en: As such, selecting elements and performing actions on them can quickly bloat
    the test code. Additionally, it is fairly common to have to select a given set
    of elements in multiple test cases. Having to duplicate the selection code in
    many places makes the code rigid and hard to change. The tests becomes more restrictive
    than liberating.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择元素并在它们上执行操作可以迅速使测试代码膨胀。另外，通常需要在多个测试用例中选择一组给定的元素。在很多地方重复选择代码使得代码变得僵硬且难以更改。测试变得比解放更具有限制性。
- en: To make our tests more self-descriptive and easier to change, we will use the
    page object pattern. This pattern describes how we create a class to represent
    the UI of a given page or component in order to encapsulate the logic of selecting
    specific elements and performing actions on them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的测试更具描述性且更容易更改，我们将使用页面对象模式。这个模式描述了我们如何创建一个类来表示给定页面或组件的UI，以封装选择特定元素并在它们上执行操作的逻辑。
- en: 'Let''s illustrate this by creating such a class for the contact list component:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为联系人列表组件创建这样的类来说明这一点：
- en: '`test/e2e/src/contacts/list.po.js`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/list.po.js`'
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This class starts with a `getAllContacts` method. This method uses the Protractor
    API to select all elements with the `cl-details-link` CSS class, and then maps
    them to their text content. This method allows us to get an array containing the
    full name of all displayed contacts.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类以一个`getAllContacts`方法开始。这个方法使用Protractor API选择所有具有`cl-details-link` CSS类的元素，然后将它们映射到它们的文本内容。这个方法允许我们获取一个包含所有显示联系人的全名的数组。
- en: Next, it exposes a `clickContactLink` method, which retrieves the element at
    the provided `index` among those with the `cl-details-link` CSS class, and then
    gets its text content to assign it as the `fullName` property on a `result` object,
    before performing a click on the element. It then uses one of the extension methods
    provided by Aurelia's Protractor plugin to wait for the router to complete its
    navigation cycle, which would be triggered by clicking on the link and return
    the resulting `Promise`, whose result is changed for the `result` object.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它暴露了一个`clickContactLink`方法，该方法检索具有`cl-details-link` CSS类的那些元素中的第`index`个元素，然后获取其文本内容，将其分配给`result`对象上的`fullName`属性，在执行元素上的点击操作之前。然后，它使用Aurelia的Protractor插件提供的扩展方法之一来等待路由完成其导航周期，这将是通过点击链接触发的，并返回结果`Promise`，其结果被改变为`result`对象。
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned before, exploring Protractor in depth is outside the scope of this
    book. However, if you are unfamiliar with it, it is important to understand that
    all methods in the Protractor API return `Promise`s, but that it is often unnecessary
    to chain them using `then` because Protractor internally queues all asynchronous
    operations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，深入探索Protractor超出了本书的范围。然而，如果你不熟悉它，了解所有Protractor API中的方法返回`Promise`是很重要的，但通常没有必要使用`then`来链接它们，因为Protractor内部会为所有异步操作排队。
- en: I strongly suggest that you get familiar with this aspect of Protractor before
    trying to write extensive E2E test suites.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你在尝试编写广泛的端到端测试套件之前，先熟悉Protractor这一方面。
- en: The `clickNewButton` method is pretty simple; it selects the element with the
    `cl-create-btn` CSS class and performs a click on it, before waiting for the router
    to complete its navigation cycle.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`clickNewButton`方法相当简单；它选择具有`cl-create-btn` CSS类的元素并对其执行点击操作，然后等待路由完成其导航周期。'
- en: The `setFilter` method uses another of the Protractor's Aurelia plugin extension
    methods to select the element data-bound to the `filter` property and decorated
    with the `debounce` binding behavior. It then clears its value and sends a given
    sequence of key strokes to it, before letting the browser sleep for 200 milliseconds.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFilter`方法使用Protractor的Aurelia插件提供的另一个扩展方法来选择与`filter`属性绑定且具有`debounce`绑定行为的元素。它然后清除其值并向其发送给定的一系列键盘输入，然后让浏览器休眠200毫秒。'
- en: Lastly, the `clickClearFilter` method selects the element with the `cl-clear-filter-btn`
    CSS class and performs a click on it. It then makes the browser sleep for 200
    milliseconds.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`clickClearFilter`方法选择具有`cl-clear-filter-btn` CSS类的元素并执行点击操作。然后让浏览器休眠200毫秒。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, a `sleep` instruction after an action is necessary to
    make sure all bindings that may need to react to the action have been updated.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，在操作后使用`sleep`指令是必要的，以确保所有可能需要对操作做出反应的绑定都已更新。
- en: The purpose of a page object is to encapsulate and abstract away interactions
    with the view. Since all the code dealing with the component's HTML is centralized
    in a single class, the impacts of modifying the component's view will be limited
    to this class. Additionally, as we will see in the next section, the test cases
    themselves will only have to deal with this high-level API over the view, not
    with the intricacies of the HTML structure itself. Most calls to the Protractor
    API will be hidden inside our page objects.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 页面对象的目的是封装并抽象掉与视图的交互。由于所有与组件HTML相关的代码都集中在一个单一的类中，因此修改组件视图的影响将限于这个类。另外，正如我们将在下一节中看到的，测试用例本身只需要处理与视图的高级API，而不需要处理HTML结构本身的复杂性。大多数对Protractor
    API的调用都将隐藏在我们的页面对象内部。
- en: 'You may have noticed that most selectors in the previous code snippet use new
    CSS classes to select elements. Let''s add those to the contacts list template:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，前面代码片段中的大多数选择器都使用新的CSS类来选择元素。让我们将这些添加到联系人列表模板中：
- en: '`src/contacts/components/list.html`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/list.html`'
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Lastly, before diving in our first test case, let''s quickly add two other
    page objects we''ll need in our tests:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们进入第一个测试用例之前，让我们快速添加两个我们将在测试中需要的其他页面对象：
- en: '`test/e2e/src/contacts/creation.po.js`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/creation.po.js`'
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`test/e2e/src/contacts/details.po.js`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/details.po.js`'
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first page object encapsulates the contact creation component. It simply
    exposes a `getTitle` method, which selects the `h1` element and returns its text
    content.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个页面对象封装了联系人创建组件。它简单地暴露了一个`getTitle`方法，该方法选择`h1`元素并返回其文本内容。
- en: The second one is for the contact details component. It has a `getFullName`
    method, which allows us to retrieve the displayed full name of the contact by
    selecting the `h1` element and returning its text content.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个页面对象是用于联系详情组件的。它有一个`getFullName`方法，该方法允许我们通过选择`h1`元素并返回其文本内容来检索联系人的显示全名。
- en: Writing a first test case
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写第一个测试用例
- en: 'Now that all the tools we need are ready, let''s write a first test case for
    the contacts list component:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有我们需要的工具都已经准备好了，让我们为联系人列表组件编写第一个测试用例：
- en: '`test/e2e/src/contacts/list.spec.js`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/list.spec.js`'
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we start with a test setup, which creates an instance of the contacts
    list page object, resets the API, then uses another of the extension methods offered
    by Aurelia's Protractor plugin to load a given URL, and then wait for the Aurelia
    application to finish booting.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从测试设置开始，该设置创建了一个联系人列表页面对象的实例，重置了API，然后使用了Aurelia的Protractor插件提供的另一个扩展方法来加载给定URL，然后等待Aurelia应用程序完成启动。
- en: Next, we define a first test case, which uses the page object's methods to ensure
    that some contacts are displayed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个第一个测试用例，该测试用例使用页面对象的方法来确保某些联系人被显示。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though tests running using Protractor are asynchronous, most of the time
    there is no need to use Jasmine's `done` function to let the framework know when
    a test case is finished, because Protractor modifies Jasmine's functions to handle
    asynchronicity itself using its own internal task queue.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用Protractor运行的测试是异步的，但大多数情况下，没有必要使用Jasmine的`done`函数来让框架知道测试用例何时完成，因为Protractor修改了Jasmine的函数，使其自身使用自己的内部任务队列来处理异步性。
- en: The exception to this rule is when performing an asynchronous operation that
    is not handled by Protractor, such as in the `beforeEach` function where we reset
    the API using an asynchronous HTTP request.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则的例外是在执行Protractor未处理的异步操作时，比如在`beforeEach`函数中，我们使用异步HTTP请求重置API。
- en: Running tests
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'At this point, we have everything ready and run our E2E tests. To do this,
    we first need to run the API mock, by opening a console in the `test/e2e/api-mock`
    directory inside our project and executing the following command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们已经准备就绪并运行了我们的E2E测试。为此，我们首先需要运行API模拟，通过在我们的项目中的`test/e2e/api-mock`目录中打开一个控制台并执行以下命令：
- en: '[PRE53]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once the API is running, we must also launch the application itself, by opening
    a console in the project''s directory and running the command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦API运行，我们还需要启动应用程序本身，通过在项目的目录中打开一个控制台并运行以下命令来实现：
- en: '[PRE54]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Those two commands are necessary, because the E2E tests will need to load our
    application in a browser in order to execute, and will need to call the API to
    reset its data before each test. Of course, the application itself also needs
    the API to request data and perform actions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令是必要的，因为端到端测试需要在我们应用程序中加载浏览器来执行，并且需要在每次测试前调用API来重置其数据。当然，应用程序本身也需要API来请求数据和执行操作。
- en: 'Once the API mock and the application are both running, we can launch the E2E
    tests by opening a third console in the project directory and running the following
    command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦API模拟和应用程序都在运行，我们就可以通过在项目目录中打开第三个控制台并运行以下命令来启动端到端测试：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You will see the task start, and during the process a Chrome instance will
    show up. You will see the application load and the test case scenario play live
    before your eyes, before Chrome shuts down and the task completes. The complete
    output should be similar to this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到任务开始，在过程中会出现一个Chrome实例。你会看到应用程序加载并且测试案例场景在你眼前播放，然后Chrome关闭并且任务完成。完整的输出应该类似于这样：
- en: '![Running tests](img/image_07_001.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试](img/image_07_001.jpg)'
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `e2e` task may occasionally take some time to start when the WebDriver needs
    to update itself first.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`e2e`任务在WebDriver需要首先更新自己时，偶尔可能需要一些时间才能启动。'
- en: Testing the contacts list
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试联系人列表
- en: 'Now that we know that everything works correctly, let''s add some tests for
    the contacts list component:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道一切工作正常，让我们为联系人列表组件添加一些测试：
- en: '`test/e2e/src/contacts/list.spec.js`'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/list.spec.js`'
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first of those new test cases makes sure that, when clicking on a contact
    entry in the list, the application navigates to the contact's details component
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些新测试案例中的第一个确保点击列表中的一个联系人条目时，应用程序导航到联系人的详细信息组件
- en: The second one makes sure that, when clicking on the **New** button, the application
    navigates to the contact creation component
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试确保点击**新建**按钮时，应用程序导航到联系人创建组件
- en: The third one makes sure that, when typing a search term in the filter textbox,
    the list is filtered down using this search term
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个确保当在筛选文本框中输入搜索词时，列表使用这个搜索词进行筛选。
- en: Lastly, the fourth one makes sure that, when clearing the filter textbox after
    a search, the list is restored unfiltered
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，第四个测试确保在搜索后清除筛选文本框，列表将恢复未筛选状态
- en: This test suite now covers all the features of the contacts list component.
    If you run the E2E tests at this point, you should see the five test cases pass.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试套件现在覆盖了联系人列表组件的所有功能。如果你在这个时候运行端到端测试，你应该看到五个测试案例通过。
- en: Testing contact creation
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试联系人创建
- en: Let's try to complicate things a bit by adding a test suite for the contact
    creation component, which includes a complex form with validation rules.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过为联系人创建组件添加一个测试套件来使事情变得复杂一些，该组件包括一个带有验证规则的复杂表单。
- en: First, we'll write a reusable class following the page object pattern, which
    will encapsulate the contact form view. This way, we'll be able to use this class
    to test contact creation, and also to eventually test the contact edition.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个可重用的类，遵循页面对象模式，该类将封装联系人表单视图。这样，我们就能使用这个类来测试联系人创建，也能最终测试联系人的编辑。
- en: We'll start with a base page object for list editors. This class will encapsulate
    the details about how to access and perform actions on parts of one of the `list-editor`
    elements on the contact form component.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从为列表编辑器编写基本页面对象开始。这个类将封装如何访问并在联系表单组件的`list-editor`元素上执行操作的细节。
- en: '`test/e2e/src/contacts/form.po.js`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/form.po.js`'
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we start by defining a base class named `ListEditorPO`. This class encapsulates
    interaction with a single `list-editor` element in the contact form and knows
    how to:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义一个名为`ListEditorPO`的基本类。这个类封装与联系表单中的单个`list-editor`元素的交互，并知道如何：
- en: Select a given `option` in a `select` bound to a given property at a given index
    in the list.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在绑定给定属性的列表中给定索引的`select`中选择给定的`option`。
- en: Send a given sequence of keys into a field bound to a given property at a given
    index in the list.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向绑定给给定属性的列表中给定索引的字段发送给定的一系列键。
- en: Click the **Remove** button at a given index in the list.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击列表中给定索引的**删除**按钮。
- en: Click the **Add** button.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮。
- en: 'Next, we''ll extend this class by writing four specialized page objects, one
    for each type of item a contact can have:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过编写四个特殊化的页面对象来扩展这个类，每个对象对应联系人可以有的每种类型的项目：
- en: '`test/e2e/src/contacts/form.po.js`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/form.po.js`'
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, we define a bunch of classes that extend the base `ListEditorPO` class:
    `PhoneNumberListEditorPO`, `EmailAddressListEditorPO`, `AddressListEditorPO`,
    and `SocialProfileListEditorPO`. They all:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一些扩展基本`ListEditorPO`类的类：`PhoneNumberListEditorPO`、`EmailAddressListEditorPO`、`AddressListEditorPO`和`SocialProfileListEditorPO`。它们都：
- en: Specify the property which the underlying `list-editor` element is bound to
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定底层`list-editor`元素绑定的属性
- en: Add specialized methods to set the value of the fields of each item in the underlying
    `list-editor`, such as `setType` and `setNumber` for phone numbers, or `setStreet`
    and `setCity` for addresses
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加专用方法来设置底层`list-editor`中每个项目的字段值，例如用于电话号码的`setType`和`setNumber`，或用于地址的`setStreet`和`setCity`。
- en: 'Lastly, we''ll write a page object for the contact form itself:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为联系表单本身编写一个页面对象：
- en: '`test/e2e/src/contacts/form.po.js`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/form.po.js`'
- en: '[PRE59]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we export a class named `ContactFormPO`, which encapsulates interaction
    with the view of the contact form. It has one instance of each of the classes
    extending `ListEditorPO`, so tests can interact with the various `list-editor`
    elements for phone numbers, e-mail addresses, addresses, and social profiles.
    It also has methods allowing us to set the value of the first name, last name,
    company, birthday, and note. Finally, it has a method allowing us to retrieve
    all the validation error messages on the form.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导出一个名为`ContactFormPO`的类，它封装了与联系表单视图的交互。它有每个扩展`ListEditorPO`类的实例，因此测试可以与电话号码、电子邮件地址、地址和社会资料的各个`list-editor`元素交互。它还有允许我们设置名字、姓氏、公司、生日和备注值的方法。最后，它有一个允许我们检索表单上所有验证错误消息的方法。
- en: 'Before being able to write our new tests, we need to connect this form page
    object with the page object for the contact creation component. We''ll also add
    a couple of methods to it:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够编写我们的新测试之前，我们需要将此表单页面对象与联系创建组件的页面对象连接。我们还将向其中添加几个方法：
- en: '`test/e2e/src/contacts/creation.po.js`'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/creation.po.js`'
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we first make the `ContactCreationPO` class inherit the `ContactFormPO`
    class, Then, we add a first method to click on the **Save** button, and another
    method to click on the **Cancel** link.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使`ContactCreationPO`类继承`ContactFormPO`类，然后添加一个方法来点击**保存**按钮，另一个方法来点击**取消**链接。
- en: 'With this ready, it is pretty straightforward to write a test suite for the
    contact creation component:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个准备，编写联系创建组件的测试套件就相当直接了：
- en: '`test/e2e/src/contacts/creation.spec.js`'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/e2e/src/contacts/creation.spec.js`'
- en: '[PRE61]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this test suite's setup, we start by creating page objects for the list and
    the creation components. We reset the API's data, then load the application, and
    click on the **New** button to navigate to the contact creation component.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试套件的设置中，我们首先创建列表和创建组件的页面对象。我们重置API的数据，然后加载应用程序，点击**新建**按钮导航到联系创建组件。
- en: 'We can now enrich this test suite with some cases that verify the behavior
    of the contact creation component:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以丰富这个测试套件，添加一些验证联系创建组件行为的测试用例：
- en: '[PRE62]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we define three test cases. The first one makes sure that, when the form
    is in an invalid state and the **Save** button is clicked, no navigation occurs
    and the proper validation messages are displayed. The second one makes sure that,
    when the form is in a valid state and the **Save** button is clicked, the application
    navigates back to the contacts list component. It also ensures that the new contact
    is displayed in the list. The third test case makes sure that clicking on **Cancel**
    makes the application navigate back to the contacts list component. It also ensures
    that no new contact is displayed in the list.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了三个测试用例。第一个确保当表单处于无效状态并且点击**保存**按钮时，不会发生导航并且显示适当的验证消息。第二个确保当表单处于有效状态并且点击**保存**按钮时，应用程序导航回到联系人列表组件。它还确保新联系人在列表中显示。第三个测试用例确保点击**取消**使应用程序导航回到联系人列表组件。它还确保列表中没有显示新联系人。
- en: Further testing
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步测试
- en: This chapter could go on much longer by adding tests for other features in our
    application, but writing additional tests would add little value to the learning
    experience of Aurelia in itself. End-to-end testing an Aurelia application with
    Protractor is a topic that deserves its own book. However, the goal of the present
    section was to give you a taste of it and get you started. Hopefully, it did.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节本可以更长，通过添加我们应用程序中其他功能的测试来扩展，但编写额外的测试对Aurelia本身的学习体验增加的价值不大。使用Protractor对Aurelia应用程序进行端到端测试是一个值得单独成书的话题。然而，当前节点的目标只是让你稍稍了解一下并开始入门。希望，它做到了。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Being able to test at both the micro level using unit tests and at the macro
    level using end to end tests is a very valuable quality for a framework. Thanks
    to its modular architecture and its orientation towards components, Aurelia makes
    it fairly easy to write such tests.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 能够既使用单元测试在微观层面测试，又使用端到端测试在宏观层面测试，对于一个框架来说是非常有价值的品质。得益于其模块化架构和面向组件的特性，Aurelia使得编写这类测试相对容易。
- en: Indeed, automated testing is a vast subject. Books are written about this topic,
    so it would be vain to try and cover it in depth in a single chapter. However,
    you should have at this point the minimum knowledge to start writing automated
    tests for your own Aurelia application.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，自动化测试是一个广泛的主题。有专门关于这个话题的书籍，因此试图在单个章节中深入探讨它是徒劳的。然而，此时你应该已经拥有开始为你的Aurelia应用程序编写自动化测试的最基本知识了。
- en: At this point in the book, most of the major tools required to build a single-page
    application using Aurelia should be on your belt. You may not have mastered them
    all yet, but you know what they are and what their purpose is.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的这个阶段，构建使用Aurelia的单页应用程序所需的大部分主要工具应该已经掌握在你手中了。你可能还没有完全掌握它们，但你知道它们是什么以及它们的用途是什么。
- en: However, there are still a couple of subjects missing, and one of them is internationalization.
    This is what we'll talk about in the next chapter.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些主题尚未涉及，其中之一就是国际化。这是我们将在下一章讨论的内容。
