- en: Chapter 8. Portability and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 可移植性与测试
- en: Web applications have come a long way from only a few years ago. Gone are the
    days when JavaScript code was embedded, sort of as an afterthought, inside a webpage.
    In today's web, we build JavaScript applications, and if you're reading this book,
    applications that scale. This means our architecture needs to be designed with
    portability in mind; the idea that the backend that serves our application and
    feeds it data, is replaceable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用已经走了很长的路，仅仅几年前还只是简单地在网页中嵌入JavaScript代码。如今，我们在构建JavaScript应用程序，如果你在读这本书，那么是在构建可扩展的应用程序。这意味着我们的架构需要考虑到可移植性；后端服务于我们的应用程序并为其提供数据，是可替换的。
- en: Along with portability comes the idea of testability. We can't make assumptions
    about the backend when we're developing large scale JavaScript code, and that
    means having the ability to run with no backend at all. This chapter looks at
    these two closely related topics and what they mean for us in the face of changing
    scaling influences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与可移植性相伴的是测试性的想法。当我们开发大规模的JavaScript代码时，我们不能对后端做出假设，这意味着有能力在没有后端的情况下运行。本章将探讨这两个密切相关的话题以及它们在面对不断变化的扩展影响时对我们意味着什么。
- en: Decoupling the backend
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦后端
- en: If we need any further motivation that JavaScript is no longer just for scriptable
    web pages, look no further than NodeJS. It doesn't require the full browser environment,
    just the V8 JavaScript engine. Node was created primarily as a backend server
    environment, but it still serves as a great showcase for how far JavaScript as
    a language has come. In the same vein, we want our code to be portable, running
    with any backend infrastructure we can throw at it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还需要更多的动机来证明JavaScript不再只用于可脚本的网页，那就看看Node.js吧。它不需要完整的浏览器环境，只需要V8 JavaScript引擎。Node主要是作为后端服务器环境创建的，但它仍然很好地展示了JavaScript语言已经取得了多大的进步。同样，我们希望我们的代码是可移植的，能够与任何我们可以投入的后端基础设施一起运行。
- en: In this section, we'll look at the reasons why we want to loosen the coupling
    between our frontend JavaScript code, and the APIs it talks to in the backend.
    We'll then introduce the first steps to mocking APIs, negating the need for a
    backend entirely.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨为什么我们要松耦合我们前端JavaScript代码与其后端API之间的联系。然后，我们将介绍模拟API的第一步，完全不需要后端。
- en: Mocking the backend API
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟后端API
- en: If we're developing a large scale JavaScript application, we'll have the beginnings
    of a backend infrastructure. So why then, would we consider detaching our code
    from that backend so that it no longer depends on it? It's always a good idea
    to support loosely coupled components when striving for something that scales,
    and that's true of the coupling between the frontend and backend environments
    in a web application. Even if the backend API never changes, we can never assume
    that the technologies and the frameworks used to build the API never will. There
    are other benefits to loosening this dependency too—like the ability to update
    the UI independently of the rest of the system. But the main scaling benefit to
    mocking our backend APIs comes from the development and testing perspectives.
    There's simply no substitute for being able throw together new API endpoints and
    hammer them with requests. Mock APIs are the crash test dummies for our JavaScript
    code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在开发一个大规模的JavaScript应用程序，我们将有一个后端基础设施的初步构建。那么，为什么我们还要考虑将我们的代码与这个后端分离，使其不再依赖于它呢？在追求可扩展性时，支持松耦合的组件总是好的，这对于Web应用程序中前端和后端环境之间的耦合也是正确的。即使后端API永远不会改变，我们也不能假设构建API所使用的技术和框架永远不会改变。松耦合这种依赖关系还有其他好处——比如能够独立于系统其他部分更新UI。但模拟后端API的主要扩展好处来自于开发和测试的角度。能够快速搭建新的API端点并对其进行请求测试是没有替代品的。模拟API是我们JavaScript代码的碰撞测试假人。
- en: Like it or not, it sometimes feels like we're creating demo-ware—in the middle
    of a development sprint, we have to show off what we have to an interested stakeholder.
    Rather than letting this lead to despair, we'll gain confidence from our mock
    data. Demoing is no longer a big deal, and with the confidence of our mocked data,
    we'll start to view these events as little challenges for ourselves. Of course,
    we always have to maintain the outward appearance of a heroic programmer—for management's
    sake!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不管喜欢与否，有时我们感觉自己好像在创建演示软件——在开发冲刺中间，我们必须向感兴趣的利益相关者展示我们所拥有的东西。与其让这导致绝望，我们应该从我们的模拟数据中获得信心。演示不再是大问题，而且有了我们模拟数据的信心，我们将开始将这些事件视为对自己的小挑战。当然，我们总是要维护一个英雄程序员的外表——为了管理人员的利益！
- en: Given how awesome mock data is, what are the downsides? Like anything else in
    our product, it's a piece of software that has to be maintained—and that always
    carries risk. For example, the mock API loses some of its value if it falls out
    of sync with the actual API, or if it creates confusion between what's functional
    in the UI versus what's mocked. To deal with these risks, we have to put processes
    in place around how we design and implement our features, which we'll go over
    here shortly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到模拟数据有多棒，那么它的缺点是什么呢？就像我们产品中的任何东西一样，它是一种需要维护的软件——这总是伴随着风险。例如，如果模拟API与实际API不同步，或者它
    creates confusion between what's functional in the UI versus what's mocked，那么它的价值就会降低。为了应对这些风险，我们必须制定围绕我们设计和实现功能的过程，我们稍后会讨论这些。
- en: '![Mocking the backend API](img/4639_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![模拟后端API](img/4639_08_01.jpg)'
- en: The mock API sites outside of any component that communicates with the actual
    API; when the mock is removed, the component doesn't know any better
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟API位于任何与实际API通信的组件之外；当移除模拟时，组件并不会知道更好
- en: Frontend entry points
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端入口点
- en: Where does the seam of our frontend meet with the backend? This is where we'd
    like to make the switch, between mock data and what's normally returned by the
    API. The seam might actually be located behind the web server—in which case we're
    still making real HTTP requests, just not interacting with the real application.
    In the other case, we're mocking entirely within the web browser, where HTTP requests
    are intercepted by the mocking library handlers before they ever leave the browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端接口的边界在哪里？这是我们希望进行切换的地方，在模拟数据和API正常返回的数据之间。这个边界实际上可能位于web服务器后面——在这种情况下，我们仍然在进行真实的HTTP请求，只是没有与真实应用程序交互。在其他情况下，我们完全在浏览器中进行模拟，HTTP请求在离开浏览器之前被模拟库处理程序拦截。
- en: In both kinds of mocking, there's a conceptual seam between our frontend application—which
    is what we're trying to establish. This is key, once we find it, because it represents
    our independence from the backend. It's not that there's anything wrong with being
    tightly coupled to the backend in production—that's what it's there for. In other
    circumstances, such as during development, being able to orchestrate what happens
    when our components send API requests is a crucial scaling tactic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种模拟方式中，我们前端应用程序之间都有一个概念上的边界——这是我们试图建立的。一旦我们找到它，这是关键，因为它代表了我们与后端的独立性。在生产中紧密耦合后端并没有什么问题——那就是它的目的。在其他情况下，例如在开发过程中，能够编排我们的组件发送API请求时发生的事情，是一种关键的扩展策略。
- en: There's the possibility of creating mock data modules using models and collections
    directly. For example, if we're running in mock mode, we would import this module
    and we'd have mock data to work with. The problem with this approach is that our
    application knows it's not really working with the backend. We don't want that.
    Because we want our code to run as though it's running in a production environment.
    Otherwise we're going to experience some side effects of manually instantiating
    the mocks—it needs to be as far-removed from our actual code as possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能直接使用模型和集合创建模拟数据模块。例如，如果我们正在运行在模拟模式，我们会导入这个模块，我们就会有模拟数据可以工作。这种方法的问题是，我们的应用程序知道它实际上并没有与后端真正工作。我们不希望这样。因为我们希望我们的代码运行得好像它在生产环境中运行一样。否则，我们将会经历手动实例化模拟的一些副作用——它需要尽可能地远离我们实际的代码。
- en: Whichever mocking mechanism we decide to go with, it needs to be modular. In
    other words, we need the ability to turn it off and take it out of the build entirely.
    In production environments, there should be no mocks. In fact, our mocking code
    shouldn't even be present in production builds. This is a little easier to achieve
    if our mocks are served up by a web server. If our mock handlers reside in the
    browser, we need to take them out somehow, which requires a build option of some
    sort. There'll be more on build tools later on in the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们决定采用哪种模拟机制，它都需要是模块化的。换句话说，我们需要有能力将其关闭并完全从构建中移除。在生产环境中，不应该有模拟。实际上，我们的模拟代码甚至不应该出现在生产构建中。如果我们通过web服务器提供模拟数据，这一点要容易实现一些。如果我们的模拟处理程序存在于浏览器中，我们需要以某种方式将它们移除，这需要某种构建选项。关于构建工具，我们稍后在第章节中会有更多介绍。
- en: '![Frontend entry points](img/4639_08_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![前端入口点](img/4639_08_02.jpg)'
- en: Mocking API requests in the browser, intercept calls at the XHR level. If there's
    mocking code there, it will look for mock APIs. When the mock is taken out, the
    native HTTP requests function as usual.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中模拟API请求，拦截XHR级别的调用。如果有模拟代码，它会寻找模拟API。当模拟被移除时，原生HTTP请求功能如常。
- en: Mocking tools
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟工具
- en: As mentioned in the preceding section, there're two main approaches to mocking
    the backend API. The first approach involves bringing in a library such as Mockjax
    into our application to intercept XHR requests. The second approach is having
    a real HTTP server in place, but one that isn't actually touching the real application—it
    serves up mock data the same way as the Mockjax approach.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一部分所述，模拟后端API主要有两种方法。第一种方法是引入像Mockjax这样的库到我们的应用程序中以拦截XHR请求。第二种方法是在那里放置一个真实的HTTP服务器，但这个服务器实际上并没有接触到真正的应用程序——它像Mockjax方法一样提供模拟数据。
- en: The way Mockjax works is simple yet clever. It works under the assumption that
    the application is using jQuery `ajax()` calls to make HTTP requests, which is
    a fairly safe assumption since most frameworks use this under the hood. When Mockjax
    is called, it overrides some core jQuery XHR functionality with its own. This
    is run whenever an XHR request is made. It checks if there's a route spec that
    matches the requested URI, and will run the handler if one is found. Otherwise,
    it'll just pass through and attempt making a request to the backend—which is kind
    of useful if we wanted to combine real API requests with mocked requests. We'll
    dig into that combination later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Mockjax的工作方式简单而巧妙。它基于这样的假设：应用程序正在使用jQuery `ajax()`调用来进行HTTP请求，这是一个相对安全的假设，因为大多数框架都在幕后使用这个。当调用Mockjax时，它用自己的功能覆盖了一些核心jQuery
    XHR功能。这是在每次进行XHR请求时运行的。它检查是否有与请求URI匹配的路由规范，如果找到，就会运行处理程序。否则，它将直接传递并尝试向后端发起请求——如果我们想将真实API请求与模拟请求结合起来，这还是挺有用的。我们稍后会深入研究这种结合。
- en: Any given handler can return JSON data, or any other format for that matter,
    just as our real API would. The key is that our core code—our models and collections
    that initiate the requests—know nothing about Mockjax because it's all happening
    at a lower layer. The same model and collection code runs unmodified against the
    production backend. All we have to do is *unplug* the module where Mockjax is
    called when deploying against the real API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定的处理程序都可以返回JSON数据，或者任何其他格式，就像我们真实的API一样。关键在于我们的核心代码——我们的模型和集合初始化请求——对Mockjax一无所知，因为所有这些都是在更低的层次上发生的。同样的模型和集合代码在没有对生产后端进行修改的情况下运行。我们只需要在部署到真实API时，*拔掉*调用Mockjax的模块即可。
- en: We can achieve the same property—running unmodified code—using the mock web
    server technique as well. It's actually the exact same idea as hijacking the XHR
    requests, only done at another level. The main advantage being that we don't have
    any special steps to take during deployment. It's either a mock server or a real
    one, and in production environments, it's unlikely there's a mock server running.
    The disadvantage is that we do need a server running, which isn't a lot to ask—it
    is an added step though. And we do lose a little bit of portability. For example,
    we can package up a mock build and send it to someone. If it doesn't require a
    web server, the entire application can be demonstrated in the browser.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模拟Web服务器技术实现相同的属性——运行未修改的代码。这实际上是劫持XHR请求的完全相同的想法，只是在一个不同的层面上进行。主要优点是我们不需要在部署过程中采取任何特殊步骤。要么是模拟服务器，要么是真实服务器，在生产环境中，不太可能运行模拟服务器。缺点是我们确实需要一个正在运行的服务器，这对我们要求不高——但这确实是一个额外的步骤。而且我们确实失去了一些可移植性。例如，我们可以打包一个模拟构建发送给某人。如果它不需要Web服务器，整个应用程序可以在浏览器中演示。
- en: '![Mocking tools](img/4639_08_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![模拟工具](img/4639_08_03.jpg)'
- en: Mocking APIs from the browser, or behind a web server; both approaches achieve
    the same result–our code doesn't know it's talking to a mock.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从浏览器或后台Web服务器模拟API；两种方法达到相同的结果——我们的代码不知道它正在与模拟通信。
- en: Generating mock data sets
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成模拟数据集
- en: Now that we know what the options are for declaring the mocked API endpoints,
    we need data. Assuming our API is returning JSON data, we could store our mock
    data in JSON files. For example, the mock module can pull in these JSON modules
    as dependencies, and the mock handlers can use them as a data source. But where
    does this data come from?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道声明模拟API端点的选项，那么我们需要数据。假设我们的API返回JSON数据，我们可以将模拟数据存储在JSON文件中。例如，模拟模块可以将这些JSON模块作为依赖项引入，模拟处理程序可以将其作为数据源。但是这些数据从哪里来呢？
- en: As we start building mocks, there's most likely an API in existence, running
    somewhere. Using our browser, we can look at the data returned by various API
    endpoints and manually curate our mocked data. This process is a lot simpler if
    the API is documented, because then we'll have a clue as to the allowable values
    for any given field in any given entity. Sometimes we don't actually have a starting
    point for the creation of our mock data—we'll go over that in the feature design
    process section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建模拟数据时，很可能存在一个API，它正在某个地方运行。使用我们的浏览器，我们可以查看各种API端点返回的数据，并手动策划我们的模拟数据。如果API有文档，这个过程会简单得多，因为那样我们就会有线索，了解任何给定实体中任何给定字段允许的值。有时我们实际上没有创建模拟数据的起点——我们将在功能设计过程部分讨论这个问题。
- en: The advantage of manually creating our mock data sets like this is that we can
    ensure that it is accurate. That is, we don't want to create something that's
    not reflective of the data we're mocking, because that would defeat the whole
    purpose. Not to mention the scaling bottleneck of keeping up with changes in the
    API. What would be nice, is using a tool to automate the task of generating mock
    data sets. It would just need to know the schema for a given entity and it could
    take care of the rest, accepting a few arguments and throwing in some randomness
    for good measure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建我们的模拟数据集的优点是，我们可以确保它是准确的。也就是说，我们不希望创建与我们要模拟的数据不反映的东西，因为这将是整个目的的失败。更不用说跟上API变化的速度瓶颈了。理想的情况是使用一个工具来自动化生成模拟数据集的任务。它只需要知道给定实体的模式，然后就可以处理剩余的工作，接受几个参数并在其中加入一些随机性。
- en: Another useful mock data generation tool would be something that extracts the
    real API data from a given deployment, and stores them as JSON files. For instance,
    say there's a staging environment where our code is showing signs of issues. We
    could run our data extraction tool against that environment to get the mock data
    we need. Since we want to leave the staging environment more or less intact, this
    approach is safe since any damage we do to the mock data while diagnosing, is
    in memory and easily wiped clean.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的模拟数据生成工具可能是从给定部署中提取真实API数据的功能，并将其作为JSON文件存储。例如，假设有一个预演环境，我们的代码表现出问题。我们可以针对该环境运行我们的数据提取工具以获取所需的数据。由于我们希望尽量保持预演环境不变，这种方法是安全的，因为我们在诊断过程中对模拟数据造成的任何损害，都在内存中，可以轻松清除。
- en: Performing actions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行操作
- en: One challenging aspect of implementing mock APIs is performing actions. These
    are requests other than GET, and usually need to change the state of some resource.
    For example, changing the value of a resource property, or removing a resource
    entirely. We need some common code that our handlers can leverage to perform these
    actions, since our API endpoints should follow the same patterns when it comes
    to performing actions on them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实施模拟 API 的一个挑战性方面是执行操作。这些是除了 GET 以外的请求，通常需要改变某个资源的状态。例如，改变资源属性的值，或者彻底删除资源。我们需要一些通用的代码，我们的处理程序可以利用它来执行这些操作，因为我们的
    API 端点在执行它们上的动作时应该遵循相同的模式。
- en: How manageable this is to actually implement depends on the complexity of our
    API action workflow. An easy to implement action would be modifying the property
    value of a resource then returning `200` successful. However, our application
    most likely has more complex workflows, such as long-running actions. For example,
    these types of actions might return the ID of a newly created *action* resource,
    and from there, we'll need to monitor the state of that action. Our frontend code
    already does this, since that's what it needs to do with the real API—it's the
    mock where we need to implement these subtleties of our application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上能否容易地实施取决于我们 API 动作工作流的复杂度。一个容易实施的动作可能就是修改资源的一个属性值然后返回`200`表示成功。然而，我们的应用程序很可能有更复杂的工作流，比如长时间运行的动作。例如，这类动作可能会返回一个新创建的*动作*资源的
    ID，从那里，我们需要监控该动作的状态。我们的前端代码已经做到了这一点，因为那正是它需要与真实 API 一起工作的地方——我们需要在模拟中实现这些应用程序的细微差别。
- en: The actions can get quite messy, fast. Especially if the application is a large
    one, with lots of entity types, and lots of actions. The idea is to strive for
    the minimum viable success path for mocking these actions. Don't go into great
    detail in trying to simulate, step by step, everything the application does—it
    doesn't scale.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 操作可能会很快变得非常复杂。尤其是如果应用程序很大，有很多实体类型和很多操作。这里的想法是努力实现模拟这些操作的最小可行性成功路径。不要试图详细地模拟应用程序所做的每一件事——这不会扩展。
- en: Feature design process
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能设计流程
- en: We're not creating mock APIs for the fun of it, we're creating them to aid in
    the development of features. Given that we could have a rather large API, and
    thus lots to mock, we need a process in place that somewhat governs the order
    in which we do things. For example, do we need to wait for an API to be in place
    before we go ahead and start implementing a feature? If we can mock the API, then
    we shouldn't have to, but the API itself still needs to be designed, and there
    are lots of API stakeholders.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是为了好玩而创建模拟 API，我们是为了帮助开发功能。考虑到我们可能有一个相当大的 API，因此有很多要模拟的内容，我们需要一个过程来规范我们做事情的顺序。例如，我们需要等待
    API 实施后再开始实现一个功能吗？如果我们能够模拟 API，那么我们就不必等待，但是 API 本身仍然需要设计，而且 API 有许多利益相关者。
- en: In this section we'll go over some of the necessary steps to ensure that we're
    using mocks correctly, and in a way that scales alongside our feature development.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些确保我们正确使用模拟，并以与我们的功能开发同步的方式进行操作的必要步骤。
- en: Designing the API
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 API
- en: Some API endpoints are generic enough to support multiple features. These are
    the entities that are central to our application. Typically, there're a handful
    of entities that play a vital role, and most features use them. On the other hand,
    most new features we develop will require an expansion of our API. This could
    mean one new API endpoint, or several. It's a question of how our backend resources
    are composed, and this involves some level of design work.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 API 端点足够通用，可以支持多个功能。这些是我们应用程序中的核心实体。通常，有一小部分实体扮演着至关重要的角色，大多数功能都会使用它们。另一方面，我们开发的大多数新功能将需要扩展我们的
    API。这意味着一个新的 API 端点，或者几个。这取决于我们的后端资源是如何组合的，这涉及到一定程度的设计工作。
- en: The problem with trying to scale our feature development is that implementing
    a new API could take a really long time. So if we need the API in place before
    we start working on the frontend feature, we end up delaying the feature, which
    isn't ideal. We want to start working on something while it's fresh. If something
    sits in a backlog as a to-do, it often stays there forever. Having a mock API
    in place for the proposed feature lets us get the ball rolling without delay,
    which is crucial for scaling development.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 试图扩展我们的功能开发的问题在于，实现一个新的API可能需要花费很长时间。所以如果我们需要在开始开发前端功能之前就有API，我们最终会推迟功能，这并不是理想的。我们希望在新鲜的时候开始做某件事。如果某件事在待办事项列表中积压，它经常永远留在那里。为拟议的功能实现一个模拟API让我们可以不拖延地开始滚动，这对于扩展开发是至关重要的。
- en: When we implement the mock of a new API endpoint, we enter greenfield design
    territory. This means that we have to take into account the considerations of
    those who may not necessarily do frontend development. And we may or may not touch
    the actual implementation of the real API—it all depends on our team structure.
    That said, whoever the subject matter experts are, they'll need transparent access
    into the design of our proposed API. They can provide suggestions, changes, and
    so on. There's no point in continuing down the path of the impossible. Another
    approach might be to get a backend programmer to sketch out a possible API spec.
    This is strictly big picture stuff; only the essential endpoints with minimal
    properties and actions. The rest are details that can easily be changed in our
    mocks and in our actual code after the fact.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现一个新API端点的模拟时，我们进入了绿色地带设计领域。这意味着我们必须考虑到那些可能不一定会进行前端开发的人的考虑。而且我们可能触及也可能不触及真实API的实际实现——这完全取决于我们的团队结构。话说回来，无论主题专家是谁，他们都需要透明地访问我们拟议的API的设计。他们可以提供建议、进行更改等等。继续走不可能的道路是没有意义的。另一种方法可能是让后端程序员草拟一个可能的API规范。这是纯粹的大局观；只包含最基本的端点，带有最小的属性和操作。其他的都是可以在我们模拟和实际代码之后轻易更改的细节。
- en: Implementing features using mock APIs before the backend code is touched, can
    help prevent costly mistakes. For example, let's say we implement some feature
    in the frontend, using mock APIs, to the point where it's demonstrable. This gives
    other engineers with specific backend domain knowledge an opportunity to call
    out the infeasibility of the feature, and we get to avoid avoid making a costly
    mistake in the future.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接触后端代码之前，使用模拟API实现功能可以帮助防止犯下昂贵的错误。例如，假设我们使用模拟API在前端实现了一些功能，直到它具有可演示性。这给了具有特定后端领域知识的工程师一个机会来指出功能的不可行性，从而让我们避免在未来犯下昂贵的错误。
- en: '![Designing the API](img/4639_08_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![设计API](img/4639_08_04.jpg)'
- en: The cycle of designing a mock API, and implementing features against it
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模拟API的循环，以及针对它实现功能
- en: Implementing the mock
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现模拟
- en: Now that we've been tasked with implementing a feature, the first step is implementing
    a mock API to support the development of our frontend code. As we saw in the preceding
    section, we should be interacting closely with whoever will ultimately implement
    the real API. The first step is to figure out what the API will look like at a
    high level. The rest we can fine-tune as we move closer to having to implement
    the real API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经接到实现一个功能的任务，第一步是实现一个模拟API来支持我们前端代码的开发。正如我们在上一节所看到的，我们应该与最终将实现真实API的人紧密合作。第一步是要确定高层次的API看起来是什么样的。其余的我们可以随着我们接近实现真实API而进行微调。
- en: However, we don't always have to depend on the API team members for hand-holding
    during the development of our mocks. We probably have some API endpoints, and
    they're probably already used by some of our frontend components. That said, there's
    probably a discernible pattern that we can follow, especially if the mock is just
    another mundane entity type that we just happen to be missing. If we follow a
    good pattern, then that's a good starting point because there's less chance of
    radical changes later on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开发我们的模拟数据时，我们并不总是必须依赖API团队成员的手把手指导。我们可能有一些API端点，它们可能已经被我们的一些前端组件使用。话说回来，可能有一个可识别的模式我们可以遵循，尤其是如果模拟只是一个我们碰巧缺失的平凡实体类型的话。如果我们遵循一个好的模式，那么这就是一个好的起点，因为以后进行激进更改的机会更小。
- en: When we know what our mock API looks like, and what we can do with it, we need
    to populate it with mock data. If we have tools in place that generate data for
    other mocks, we need to figure out how to extend that. Or, we need to just manually
    create some test entities to get started. We don't want to spend a lot of time
    up-front entering data. We only need the minimum viable number of entities to
    prove our approach is feasible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道我们的模拟 API 看起来是什么样子，以及我们可以对其做些什么时，我们需要用模拟数据来填充它。如果我们已经有一些为其他模拟生成数据的工具，我们需要找出如何扩展这些工具。或者，我们只需要手动创建一些测试实体来开始。我们不想在前面花费太多时间输入数据。我们只需要最少的有效实体数量来证明我们的方法是可行的。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We might not always want to start off with the actual mock endpoint before creating
    the data. Instead, we may want to work from the data upward—designing the right
    entity rather than worrying about the mechanics of the API itself. This is because,
    the data ultimately needs to be stored somewhere, which is an important activity.
    Working on the data lets us work in a different mindset. Choose the approach that
    best fits the task at hand.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能并不总是想在创建数据之前就启动实际的模拟端点。相反，我们可能更愿意从数据出发，向上设计——设计正确的实体，而不是担心 API 本身的技术细节。这是因为，数据最终需要在某个地方进行存储，这是一个重要的活动。专注于数据让我们以不同的思维方式工作。选择最适合手头任务的处理方法。
- en: The mocks we create aren't always creating something brand new. That is, the
    API we're mocking may already exist, or the implementation of it is underway.
    This actually makes the mock much easier to implement, because we can ask the
    API author for sample data, or help in general, in order to build our mocks. Remember,
    if we want to be portable, we have to be able to remove the frontend from the
    backend, which means we'll need to mock the API in its entirety.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所创建的模拟并不总是创造全新的东西。也就是说，我们模拟的 API 可能已经存在，或者其实现正在进行中。这实际上使得模拟的实现变得容易得多，因为我们可以向
    API 作者请求示例数据，或者寻求帮助，以构建我们的模拟。记住，如果我们想要实现可移植性，我们必须能够将前端从后端中分离出来，这意味着我们需要模拟整个 API。
- en: Implementing the feature
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施功能
- en: Now that we have our mock API in place, it's time to profit. It's not all said
    and done—the mock APIs are tweaked all the time. But it's enough for us to get
    going with the real frontend code. And right away, we'll find problems. These
    could be problems with the proposed API, or problems with the component that talks
    to the API. We can't let these discourage us, because that's exactly what we're
    looking for—early problem detection. You just don't get this without mock APIs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的模拟 API，是时候受益了。事情并没有结束——模拟 API 经常进行微调。但这足以让我们开始编写真实的前端代码。立即，我们会发现一些问题。这些问题可能是拟议的
    API 的问题，或者是与 API 通信的组件的问题。我们不能让这些问题沮丧，因为这正是我们所寻找的——早期发现问题。没有模拟 API 是无法获得这些的。
- en: If the API is generally acceptable, and our component code works, we could discover
    performance bottlenecks in our design. This is especially easy to find if we have
    tools that generate mock data for us, because it's nothing to generate 100,000
    entities, and see what happens with our frontend code. Sometimes this is a quick
    refactoring, other times it's a complete change in approach. The point is that
    we need to find these issues earlier rather than later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 API 普遍可行，而且我们的组件代码工作正常，我们可能会发现我们设计中的性能瓶颈。如果我们有生成模拟数据的工具，这尤其容易发现，因为生成 100,000
    个实体轻而易举，看看我们的前端代码会发生什么。有时这需要快速重构，有时则需要完全改变方法。关键是我们要尽早而不是稍后找到这些问题。
- en: Something else we can do with mocks that's otherwise difficult is to demo often.
    That's not easy to do when we're heavily dependent on a large backend environment
    with lots of overhead. If it takes less than a couple minutes to get a feature
    up and running for demonstration, we can confidently show off what we're doing.
    Maybe it's wrong, maybe the stakeholders think of something they missed, having
    seen their idea come to life. This is how mocks help us scale the feature development
    life cycle through early and continuous feedback.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过模拟来做一件其他难以实现的事情，那就是经常进行演示。当我们严重依赖具有大量开销的大型后端环境时，这并不容易。如果少于几分钟就能让一个功能运行起来进行演示，我们可以自信地展示我们所做的。也许它是错误的，也许利益相关者会想到一些他们错过的事情，当他们看到他们的想法变为现实时。这就是模拟如何帮助我们通过早期和持续的反馈来扩展特征开发生命周期。
- en: '![Implementing the feature](img/4639_08_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![实施功能](img/4639_08_05.jpg)'
- en: The internals of a component under development, communicating with mock API
    endpoints
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正在开发中的组件的内部，与模拟 API 端点通信
- en: Reconciling mock data with API data
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模拟数据与API数据协调一致
- en: At this point, the feature is implemented, and how we reconcile the mock we've
    created for our feature depends on the state of the real API. For example, if
    we're just mocking something in the API that's been around for a while, then it's
    safe to assume nothing needs to happen as long as there's high fidelity between
    our mock and the real thing. However, if we're mocking a greenfield API, there's
    a good chance that something will have changed, even subtly. It's important that
    we capture these changes to make sure our existing mocks stay relevant in subsequent
    releases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，功能已经实现，我们如何协调为功能创建的模拟数据取决于实际API的状态。例如，如果我们只是模拟API中已经存在一段时间的东西，那么只要我们模拟和真实数据之间有高保真度，就可以安全地假设什么也不需要发生。然而，如果我们模拟的是一个全新的API，有很大几率会发生一些变化，哪怕是微小的变化。重要的是我们要捕捉这些变化，确保我们的现有模拟数据在后续版本中保持相关性。
- en: This is the part of the mocking process that's tough to scale, and generally
    unpleasant. There're so many different ways that our mocks can get out of sync
    with what's in the real API, it's daunting to even try to keep up. If we have
    tools for generating mocks, it's a lot easier. We might even be able to generate
    the entire API based on specs the API team creates. But this is problematic too,
    because while the mock generation can be automated, the specs themselves need
    to be created, somewhere, somehow. So it might be best to implement a tool that
    can generate mock data, but have our own code process requests. As long as we
    don't repeat ourselves too much, and the API has a decent pattern, we should be
    able to keep up with our mocks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模拟过程中难以扩展且通常令人不愉快的一部分。我们的模拟数据有如此多的不同方式与实际API中的数据不同步，以至于很难尝试去跟上。如果我们有生成模拟数据的工具，那就容易多了。我们甚至可能能够根据API团队创建的规范生成整个API。但这也存在问题，因为虽然模拟生成可以自动化，但规范本身需要在某个地方、以某种方式创建。因此，最好实现一个可以生成模拟数据的工具，但让我们的代码处理请求。只要我们不要重复自己太多，并且API有一个合理的模式，我们应该能够跟上我们的模拟数据。
- en: Another possibility is turning off certain mock API endpoints while leaving
    others on. Think of it as a sort of pass through—where the granularity of mock
    endpoints can be specified, instead of only being able to toggle the entire mock
    API. For example, this capability could come in handy if we're trying to troubleshoot
    a specific problem in our application, and we'll need to coax certain API endpoints
    to return specific responses in order to replicate the problem. We can do this
    in libraries such as Mockjax, because requests that don't match a request path
    spec are just forwarded on to the native XHR mechanism.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种做法是在关闭某些模拟API端点的同时保留其他端点。可以把它看作是一种穿透——在这里，可以指定模拟端点的粒度，而不是只能切换整个模拟API。例如，这种能力如果在调试应用程序中的特定问题时会非常有用，我们需要引导某些API端点返回特定的响应以复制问题。我们可以在Mockjax等库中实现这一点，因为不匹配请求路径规的请求只是被转发给本地的XHR机制。
- en: '![Reconciling mock data with API data](img/4639_08_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![将模拟数据与API数据协调一致](img/4639_08_06.jpg)'
- en: One component uses a mock API, while another uses the actual API
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件使用模拟API，而另一个使用实际API
- en: Unit testing tools
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试工具
- en: It's time to turn our attention to testing, having covered the basics of mocking
    API endpoints at scale. Our ability to mock APIs is highly relevant to testing
    our code, because we can test against those same mocks, or at least the same data.
    This means that if our tests fail, we can start interacting with the UI if we
    need to, using the same data that failed the test, trying to figure out what's
    happening.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将注意力转向测试了，我们在学习了大规模模拟API端点的基础知识之后。我们模拟API的能力对于测试代码非常有用，因为我们可以使用同样的模拟数据或至少是同样的数据来进行测试。这意味着，如果我们的测试失败，我们可以开始与UI交互（如果需要的话），使用测试失败的相同数据，试图找出发生了什么。
- en: We'll look into using the unit testing tools that ship with JavaScript frameworks,
    and figure out where their value lies. We'll also look at using more generic standalone
    testing frameworks that run with any code. We'll close out the section with a
    look at how our tests can be automated, and how this automation fits into our
    development workflow.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨使用随JavaScript框架提供的单元测试工具，并找出它们的价值观所在。我们还将研究使用更通用的独立测试框架，这些框架可以与任何代码一起运行。在本节结束时，我们将看看我们的测试如何自动化，以及这种自动化如何融入我们的开发工作流程。
- en: Tools built into frameworks
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架内置工具
- en: If we're using one of the larger, all-encompassing JavaScript application frameworks,
    there's a good chance that it will ship with some unit testing tools. These aren't
    meant to replace the existing unit testing tools that are framework-agnostic.
    Rather, they're meant to augment them—providing specific support for writing tests
    in the flavor of the framework.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是较大型的、全面的JavaScript应用程序框架，那么有很大概率它会自带一些单元测试工具。这些工具并不是要取代框架无关的现有单元测试工具。相反，它们是为了补充这些工具——为编写符合框架口味的测试提供特定支持。
- en: What that ultimately means for us is writing less unit test code. If we're following
    the patterns of the framework, then there're lots of unit testing tools that already
    know about our code. For example, if it already knows the types of components
    we'll be using to implement our features, then it can stub out tests for us. This
    is a huge help, not having to repeat ourselves, and it leads to us ultimately
    getting more test coverage on our code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这意味着我们需要编写更少的单元测试代码。如果我们遵循框架的模式，那么已经有很多单元测试工具了解我们的代码。例如，如果它已经知道我们将使用哪些组件来实现我们的功能，那么它可以为我们生成测试。这极大地帮助我们避免重复，并最终使我们的代码获得更全面的测试覆盖。
- en: In addition to generating the skeleton of our tests for us, framework testing
    facilities can provide utility functions for us to use within our tests. This
    means less unit test code for us to maintain, and this is only possible because
    the framework knows what kinds of things we'll want to do within our tests, and
    can abstract them out for us in the form of utility functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为我们生成测试骨架之外，框架测试设施还可以为我们提供测试中可用的实用函数。这意味着我们无需维护那么多单元测试代码，这之所以可能，是因为框架知道我们将在测试中想要做什么，并以实用函数的形式为我们抽象出这些操作。
- en: The challenge with relying on framework-specific testing tools is that we'll
    be coupling our product with a specific framework. This is unlikely to be a problem
    for us, because once a framework is chosen, we're going to stick with it, right?
    Well, not necessarily. Not in today's tumultuous JavaScript ecosystem. Part of
    being portable requires a level of agility in our architecture, meaning we have
    to be adaptable to change. This is perhaps why more of today's projects rely less
    on mega frameworks and more on a composition of libraries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖框架特定的测试工具的挑战在于，我们将把我们的产品与特定的框架耦合在一起。这对我们来说可能不是一个问题，因为一旦选定了一个框架，我们就会坚持使用它，对吧？嗯，不一定。在今天动荡的JavaScript生态系统中更是如此。在可移植性方面的一部分要求我们的架构具有一定程度的灵活性，意味着我们必须适应变化。这或许也是为什么如今越来越多的项目依赖于大型框架，而更多依赖于库的组合。
- en: '![Tools built into frameworks](img/4639_08_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![框架内建的工具](img/4639_08_07.jpg)'
- en: Unit test is tightly coupled to components and unit testing tools from the framework
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试与框架的组件和单元测试工具有紧密的耦合关系
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There's a lot of asynchronous code in large-scale JavaScript applications, and
    this async code shouldn't be ignored by our unit tests. For example, we need to
    make sure that our model units are able to fetch data and perform actions. These
    types of functions return promises, and we want to ensure that they resolve or
    fail as expected.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型JavaScript应用程序中有很多异步代码，我们的单元测试不应忽略这些异步代码。例如，我们需要确保我们的模型单元能够获取数据并执行操作。这类函数返回承诺，我们需要确保它们如预期般正确解决或失败。
- en: This is much easier to achieve with a mock API in place. Using either the in-browser
    approach or the web server approach is fine, because our code still treats them
    as real asynchronous operations. Something else we might consider mocking is a
    web socket connection. This is a little trickier to do in the browser because
    we have to override the built-in web socket class. We can use a real web socket
    connection to test with if our mock sits behind a web server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟API可以大大简化这一过程。无论是采用浏览器内方法还是Web服务器方法都可以，因为我们的代码仍然将它们视为真正的异步操作。我们可能还需要考虑模拟的是WebSocket连接。在浏览器中这样做稍微有些棘手，因为我们必须覆盖内置的WebSocket类。如果我们的模拟位于Web服务器后面，我们可以使用真实的WebSocket连接进行测试。
- en: Either way, mocking web sockets is difficult, because we have to mock the logic
    that triggers web socket messages in response to something else happening, such
    as an API action. However, we still might want to consider mocking web sockets
    after we have more basic test coverage, because if our application depends on
    them, it's important to automate tests for them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，模拟WebSocket都是困难的，因为我们必须模拟在某些其他事情发生时触发WebSocket消息的逻辑，例如API操作。然而，在获得更基本的测试覆盖后，我们仍然可能想要考虑模拟WebSocket，因为如果我们的应用程序依赖于它们，自动化测试它们是很重要的。
- en: Standalone unit testing tools
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立的单元测试工具
- en: Another approach to unit testing tools is to use a stand-alone framework. That
    is, a unit testing tool that doesn't care which JavaScript application framework
    or libraries we're using. Jasmine is the standard for this purpose, as it provides
    a clean and concise way for us to declare test specifications. Out-of-the-box,
    it has a test runner that works in the browser, which gives us nicely formatted
    output for tests that pass, and tests that fail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试工具的另一种方法是使用独立的框架。也就是说，一个不关心我们使用哪个JavaScript应用程序框架或库的单元测试工具。Jasmine是这一目的的标准，因为它为我们提供了一种清晰简洁的方式来声明测试规格。开箱即用，它有一个在浏览器中工作的测试运行器，为我们提供了格式化的测试通过和测试失败的输出。
- en: Most other stand-alone unit testing facilities use Jasmine as their base, and
    extend it to provide additional capabilities. For example, there's the Jest project,
    which is essentially Jasmine with additional capabilities such as module loading
    and mocks built-in. Again, something like this is framework-agnostic; it's focused
    purely on the tests. Using these types of stand-alone tools for unit testing is
    a good portability tactic, because it means that should we decide to move to different
    technologies in our code, our tests will still be valid and can actually help
    make the transition run smoothly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他独立的单元测试设施都使用Jasmine作为基础，并扩展它以提供额外的功能。例如，有Jest项目，它本质上是对Jasmine进行了扩展，增加了模块加载和模拟等功能。同样，这种类型的工具是框架无关的；它纯粹关注测试。使用这些独立的工具进行单元测试是一个很好的可移植性策略，因为这意味着，如果我们决定将代码转移到不同的技术，我们的测试仍然有效，并且实际上可以帮助使过渡顺利进行。
- en: Jasmine isn't the only game in town, it's simply the most generic and gives
    us a lot of freedom in how we structure our tests. Qunit, for instance, has been
    around for a long time. It's applicable to any framework, but was originally conceived
    as a testing tool for jQuery projects. We might even want to roll our own testing
    tools, should we feel that the available testing tools are too heavy, and don't
    give us the kind of flexibility or the kind of output our project needs. Something
    we probably don't want to write ourselves is a test runner. Our unit tests aren't
    run haphazardly, whenever we feel like it. They're often part of a large chain
    of tasks we want to automate.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine并不是市面上唯一的游戏，它只是最通用，给了我们在结构测试方面很大的自由。例如，Qunit已经存在很长时间了。它适用于任何框架，但最初是为jQuery项目设计的测试工具。如果我们觉得现有的测试工具太重，或者不给我们项目所需的灵活性或输出，我们甚至可能想要自己开发测试工具。我们可能不想编写自己的测试运行器。我们的单元测试不是随意运行的，
    whenever we feel like it。它们通常是我们要自动化的大量任务链的一部分。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some code is more testable than other code. This simply means that depending
    on how our components are structured, it may be easy to break them down into testable
    units, or it could be difficult. For example, code with a lot of moving parts,
    and a lot of side effects means that we have to write a relatively large suite
    of tests for this component if we want decent test coverage on it. If our code
    is loosely coupled, with relatively few side effects, it will be much easier to
    write tests for.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有些代码比其他代码更容易测试。这意味着，根据我们的组件是如何组织的，可能很容易将它们分解为可测试的单元，或者可能很难。例如，具有许多活动部件和许多副作用的代码意味着，如果我们想要在组件上获得良好的测试覆盖率，我们必须为这个组件编写相对较大的测试套件。如果我们代码的耦合度较低，副作用较少，那么编写测试就会容易得多。
- en: While we want to strive for testable code, to make the process of writing unit
    tests easier, it isn't always possible. So if it means sacrificing coverage, sometimes
    that's the better option. We want to avoid re-writing code, or worse, changing
    around the architecture we're happy with, for the sake of writing more tests.
    We should only do this if we feel that our component is sufficiently large that
    it deserves more test coverage. If it gets to this point, we should probably re-think
    our design anyway. Good code is naturally easy to test.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望编写可测试的代码，以使编写单元测试的过程更容易，但并不总是可能的。所以如果这意味着牺牲覆盖率，有时候这是更好的选择。我们不想为了编写更多的测试而重写代码，或者更糟糕的是，改变我们满意的架构。只有当我们认为我们的组件足够大，值得有更全面的测试覆盖时，我们才应该这样做。如果到了这个地步，我们可能需要重新思考我们的设计。好的代码自然容易测试。
- en: Toolchains and automation
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具链和自动化
- en: As our application grows more large and complex, a lot needs to happen "offline",
    as part of the ongoing development process. Running unit tests is just one task
    we want to automate. For example, before we even run our tests, we'll probably
    want to use a tool that lints our code to ensure we're not committing anything
    too sloppy. After the tests pass, we might need to build our component artifacts,
    so they can be used by a running instance of our application. If we're generating
    mock data, this might also be part of the same process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变得更大更复杂，有很多事情需要在“离线”状态下进行，作为持续开发过程的一部分。运行单元测试是我们希望自动化的任务之一。例如，在我们甚至运行测试之前，我们可能需要使用一个工具来检查我们的代码，以确保我们没有提交太草率的代码。测试通过后，我们可能需要构建我们的组件工件，以便它们可以被我们应用程序的运行实例使用。如果我们正在生成模拟数据，这可能也是同一过程的一部分。
- en: Collectively, we have a toolchain that can automate all of these tasks for us.
    These tasks are often smaller steps in a larger, more coarse-grained task, like
    *build production* or *build develop*. Larger tasks are just a composition of
    smaller tasks, as defined by us. This is a flexible approach because the **toolchain**
    can handle the sequence of tasks, in the order they need to happen, or, we can
    just run tasks piecemeal. For instance, we might only want to run tests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们有一个工具链可以自动化所有这些任务。这些任务通常是一个更大、更粗粒度任务中的较小步骤，比如*构建生产*或*构建开发*。更复杂的任务只是我们定义的较小任务的组合。这是一种灵活的方法，因为**工具链**可以处理任务的顺序，按照它们需要发生的顺序，或者，我们可以单独运行任务。例如，我们可能只想运行测试。
- en: The most popular toolchain is a task runner called Grunt. Other similar tools,
    such as Gulp, are gaining traction too. What's nice about these tools is that
    they have a thriving ecosystem of plugins that do much of what we need—we just
    need to configure the individual tasks that use these plugins, and the larger
    tasks that we want to compose. It takes very little effort on our part to setup
    a toolchain that can automate much of our development process—pretty much everything
    aside from writing the code itself. Without toolchains, it ranges from very difficult
    to impossible, to scale our development efforts to more than just a few contributors.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的工具链是一个任务运行器，名为Grunt。其他类似的工具，如Gulp，也越来越受欢迎。这些工具的好处在于它们有一个充满插件的活跃生态系统，这些插件能完成我们大部分需要做的事情——我们只需要配置使用这些插件的个别任务以及我们想要组合的更复杂的任务。对于我们来说，设置一个可以自动化我们开发过程大部分步骤的工具链，所需的努力非常小——基本上除了编写代码本身，其他事情都可以自动化。如果没有工具链，要使我们的开发工作扩展到多于几个贡献者，会非常困难甚至是不可能的。
- en: Another bonus of using toolchains for automated tasks is that we can change
    the type of artifacts we're building on-the-fly. For example, when we're right
    in the middle of developing a feature, we won't necessarily want to build the
    production artifacts with every change. Doing so can really slow us down, in fact.
    It's better if our tools can just deploy the raw source modules, which can also
    make debugging a lot easier too. Then when we're closer to being done, we start
    with the production builds, and test against those. Our unit tests can run against
    both the raw source code and the resulting artifact builds—because we never know
    what can be introduced after compilation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具链进行自动化任务的另一个好处是我们可以随时更改正在构建的工件类型。例如，当我们正中间开发一个功能时，我们不一定希望每次更改都构建生产工件。实际上这样做会大大减慢我们的速度。如果我们的工具可以仅仅部署原始源模块，那也会使调试变得容易很多。然后当我们接近完成时，我们开始构建生产版本，并针对那些版本进行测试。我们的单元测试可以同时针对原始源代码和生成的工件构建运行——因为我们永远不知道编译后可能会引入什么。
- en: Testing mock scenarios
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模拟场景
- en: The more our application scales, the more scenarios it'll have to deal with.
    This is the result of more users using more features, and all the ensuing complexity
    our code has to handle. Having mock data and unit tests can really help put these
    scenarios to the test. In this section, we'll go over some of the options available
    to us for creating these mock scenarios and then testing them, both with our unit
    tests and by interacting with the system as a user.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序规模越大，它需要处理的场景就越多。这是因为更多用户使用更多功能，我们的代码需要处理的复杂性也随之增加。拥有模拟数据和单元测试确实可以帮助我们测试这些场景。在本节中，我们将介绍一些可用于创建这些模拟场景并对其进行测试的选项，包括我们的单元测试以及像用户一样与系统交互。
- en: Mock APIs and test fixtures
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟API和测试数据
- en: Mock data is valuable to us for many reasons, one of which is unit tests. If
    we're mocking the API, we can run our unit tests as though our code is hitting
    a real API. We have fine-grained control over individual data points in our mock
    data, and we're free to change it how we see fit—it's sandboxed data, it has no
    negative effect on the outside world. Even if we're generating our mock data using
    a tool, we can get in there and shuffle things about.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟数据对我们很有价值，其中之一就是单元测试。如果我们模拟API，我们可以运行我们的单元测试，好像我们的代码正在击中真实的API。我们对模拟数据中的个别数据点有精细的控制，并且可以随意更改——它是沙盒中的数据，对外部世界没有负面影响。即使我们使用工具生成模拟数据，我们也可以进去调整。
- en: Some unit testing tools accept fixtures, data used for the sole purpose of running
    the tests. This isn't all that different from the data we would use with an API
    mocking tool like Mockjax. The main difference is that fixtures aren't much use
    to us outside of the unit testing framework that consumes them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些单元测试工具接受测试数据，这些数据仅用于运行测试。这和我们在像Mockjax这样的API模拟工具中使用的数据并没有太大区别。主要区别是，测试数据在我们使用的单元测试框架之外并没有多大用处。
- en: Well, what if we could use it for both testing and mocking? For instance, say
    that we want to utilize the fixture data capabilities of our unit testing framework.
    It's got some automated features that we couldn't use if we didn't feed it fixture
    data. On the other hand, we also want to mock the API for development purposes,
    interacting with the feature, detachment from the backend, and so on. There's
    nothing stopping us from feeding the fixture data into both the unit tests, and
    into the API mocks. That way, we could use any mock data generators we've created
    to generate scenarios that are shared by our tests, and by the user interactions
    in the browser.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们既能用于测试又能用于模拟呢？例如，假设我们想利用单元测试框架的测试数据功能。它有一些自动化特性，如果我们不提供测试数据，我们就无法使用。另一方面，我们还想为开发目的模拟API，以便与功能交互，与后端分离等。没有任何东西阻止我们将测试数据既用于单元测试，又用于API模拟。这样，我们就可以使用我们创建的任何模拟数据生成器来生成测试和浏览器中用户交互共享的场景。
- en: '![Mock APIs and test fixtures](img/4639_08_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![模拟API和测试数据](img/4639_08_08.jpg)'
- en: Unit tests can hit the mock API with requests, or use fixture data directly;
    if the mock API serves the same data, then it's easier to figure out what's wrong
    with failed tests
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以通过请求击中模拟API，或者直接使用测试数据；如果模拟API提供相同的数据，那么更容易找出失败测试中的问题。
- en: Scenario generation tools
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景生成工具
- en: Over time we'll accumulate new features and more scenarios in which our customers
    will use those features. Therefore, it would be immensely helpful to have, as
    part of our toolchain, a utility for generating mock data. Taking things a step
    further, this utility could accept arguments for generating mocks. These could
    be simply course-grained arguments, but that's usually all we need to turn randomly
    generated mock data into a curated scenario we need.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们将积累新的功能和更多客户使用这些功能的场景。因此，我们工具链中有一个生成模拟数据的工具将非常有帮助。更进一步，这个工具可以接受生成模拟数据的参数。这些参数可能只是粗粒度的，但我们通常只需要将随机生成的模拟数据转换为我们需要的精心策划的场景。
- en: The individual mock scenarios we'll generate won't vary a great deal from one
    another. That's kind of the point—we need something that serves as a baseline,
    so that if we do make interesting discoveries about our scenarios, we can ask—*what's
    different about this data?* If we do start generating lots of scenarios because
    we have a tool that enables us to do so, we need to make sure we do in fact have
    a "gold" mock data set—which is something that we know works as expected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成的单个模拟场景彼此之间不会有太大差异。这是有点意思的地方——我们需要一个作为基线的东西，这样如果我们确实对我们的场景做出了有趣的发现，我们可以问——*这个数据有什么不同？*
    如果我们开始生成很多场景，因为我们有一个可以让我们这样做工具，我们需要确保我们确实有一个“黄金”模拟数据集——这是我们确信其按预期工作的东西。
- en: The types of changes we would need to make to the gold mock data are things
    like changing the number of entities in a collection. For example, let's say we
    wanted to see how something performs on a given page. So we create a million mock
    entities, and see what happens. The page breaks entirely—further investigation
    reveals a `reduce()` function that tries to sum a number greater than the maximum
    safe integer. Scenarios can reveal interesting bugs like this. Even if the scenario
    we're using is far fetched and unlikely to occur in production, we should still
    fix the bug because other less extreme scenarios could certainly trigger it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对黄金模拟数据进行的更改类型包括更改集合中实体的数量等。例如，假设我们想看看某事物在给定页面上的表现如何。那么我们创建一百万个模拟实体，看看会发生什么。页面完全崩溃——进一步调查发现了一个`reduce()`函数，该函数试图对一个大于最大安全整数的数字进行求和。这种情况可以揭示有趣的错误。即使我们使用的场景牵强附会，不太可能在生产中发生，我们仍然应该修复错误，因为其他不那么极端的场景肯定会导致它触发。
- en: '![Scenario generation tools](img/4639_08_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![场景生成工具](img/4639_08_09.jpg)'
- en: Changing the scenario can cause our tests to fail; usually we create scaling
    scenarios to see where our code falls apart
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更改场景可能会导致我们的测试失败；通常我们会创建扩展场景，看看我们的代码在哪里崩溃
- en: There's a huge number of possibilities we could simulate. For example, we could
    mangle some of the data by deleting properties from entities, ensuring that our
    frontend components have sane defaults for things it expects, or that it fails
    gracefully. This latter point is actually really important. As we scale our JavaScript
    code, there're more and more scenarios that we cannot fix, and we just have to
    make sure our failure mode is acceptable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以模拟大量的可能性。例如，我们可以通过删除实体的属性来扭曲一些数据，确保我们的前端组件对它期望的东西有合理的默认值，或者它以优雅的方式失败。后者实际上非常重要。随着我们扩展JavaScript代码，我们有越来越多无法修复的场景，我们只需要确保我们的失败模式是可以接受的。
- en: End-to-end tests and continuous integration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试和持续集成
- en: The final piece of the puzzle is putting together end-to-end tests for our feature,
    and hooking it into our continuous integration process. Unit tests are one thing,
    they leave us confident that our components are solid—when they pass. Users don't
    care about unit tests, end-to-end tests serve as a proxy for our users that interact
    with our UI. For instance, there's probably a set of use cases embedded within
    the requirements of any given feature we implement. The end-to-end tests should
    be designed around these.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将端到端测试组合到我们的功能中，并将其连接到我们的持续集成过程中。单元测试是一回事，它们让我们确信我们的组件是坚固的——当它们通过时。用户不在乎单元测试，端到端测试作为与我们的UI交互的用户的代表。例如，可能在我们实施的任何给定功能的规格说明中嵌入了一组用例。端到端测试应该围绕这些用例设计。
- en: Tools like Selenium make automating end-to-end tests possible. They record the
    test as a set of steps we perform as a user. Those same steps can then be repeated
    whenever we tell it to. For example, an end-to-end test might involve the creation,
    modification, and deletion of a resource. The tool knows what to look for in the
    UI as a success path. When this doesn't happen, we know the test has failed, and
    there's something we need to go fix. Automating these types of tests is essential
    to scaling, as the number of ways users can interact with our application grows
    as we add features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 像Selenium这样的工具使自动化端到端测试成为可能。它们将测试记录为作为用户执行的一系列步骤。同样的步骤可以在我们告诉它时重复。例如，一个端到端测试可能涉及资源的创建、修改和删除。该工具知道在UI中寻找成功路径的什么。当这种情况不发生时，我们知道测试失败了，我们需要去修复它。自动化这类测试对于扩展是至关重要的，因为随着我们添加功能，用户与我们的应用程序互动的方式越来越多。
- en: We can look to our toolchain for help here once more, since it's already automating
    all our other tasks, it should probably automate our end-to-end tests as well.
    The toolchain is essential for our continuous integration process as well. We'll
    probably share a CI server that builds other aspects of our system as well, only
    they're done differently. The toolchain makes it easy for us to integrate with
    a CI process, because we simply need to script the appropriate toolchain commands.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次可以向我们的工具链寻求帮助，因为既然它已经在自动化我们所有的其他任务，它可能也应该自动化我们的端到端测试。工具链对于我们的持续集成过程也是至关重要的。我们可能会共享一个CI服务器来构建我们系统的其他方面，只是它们是以不同的方式完成的。工具链使我们容易与CI过程集成，因为我们只需要脚本适当的工具链命令即可。
- en: Having mock data in place can help us run end-to-end tests, because if the tool
    is going to behave as a user would, it's going to have to make backend API requests.
    This gets us consistency, and helps us rule out the tests themselves as being
    problem sources. With mock APIs, we can develop unit tests, and end-to-end test
    against the same source.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中设置模拟数据可以帮助我们进行端到端的测试，因为如果工具要像用户那样操作，那么它就必须发出后端API请求。这样做可以确保我们的一致性，并帮助我们排除测试本身作为问题来源的可能。借助模拟API，我们可以开发单元测试，并对同一来源进行端到端的测试。
- en: '![End-to-end tests and continuous integration](img/4639_08_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![端到端测试和持续集成](img/4639_08_10.jpg)'
- en: The toolchain, the mock data, and our tests, all running in a CI environment;
    the code we're developing is the input
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链、模拟数据以及我们的测试，所有这些都运行在CI环境中；我们所开发的代码是输入。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: This chapter introduced the concept of portability in frontend JavaScript applications.
    Portability in this context means not being tightly coupled with the backend.
    The main advantage of being portable means that we can treat our UI as its own
    application, it doesn't require any specific backend technologies to be in place.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了前端JavaScript应用程序的可移植性概念。在此上下文中，可移植性意味着与后端不是紧密耦合的。具有可移植性的主要优势在于，我们可以将UI视为其独立的应用程序，它不需要任何特定的后端技术。
- en: To help our frontend achieve independence, we can mock the backend API it depends
    on. Mocking also lets us focus strictly on UI development—eliminating the possibility
    of backend issues from hindering our development.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们的前端实现独立，我们可以模拟它依赖的后端API。模拟也让我们可以严格专注于UI开发——消除了后端问题阻碍我们开发的的可能性。
- en: Mocks can help us test our code as well. There're a number of unit testing libraries,
    each with their own approach, that we can utilize. If we're using the same mock
    data to run our tests, then we can rule out inconsistencies with what we see in
    the browser. Our tests need to be automated, alongside several other tasks that
    take place as part of our development process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟数据可以帮助我们测试代码。有许多单元测试库，每个库都有自己的方法，我们可以利用它们。如果我们使用相同的模拟数据来运行测试，那么我们可以在浏览器中看到的不一致性中排除不一致性。我们的测试需要自动化，还有其他几个发生在我们开发过程中的任务也需要自动化。
- en: The toolchain we implement fits in nicely with a continuous integration server—an
    essential scaling tool. This is also where end-to-end tests are automated, which
    gives us a better idea of what the user will encounter when they use our software.
    Now it's time to switch gears and take a hard look at the limits of scaling our
    application. We can't scale up infinitely, and the next chapter will look at how
    to avoid hitting a wall, as we scale beyond a certain size.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所实现的工具链与持续集成服务器完美契合——这是实现规模扩张的关键工具。端到端的测试也是在这里自动完成的，这使我们能更好地了解用户在使用我们的软件时可能会遇到的问题。现在，是时候转换思路，认真审视应用扩展的局限性了。我们不能无限扩展，下一章节将探讨在我们达到一定规模后如何避免撞墙。
