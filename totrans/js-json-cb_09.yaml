- en: Chapter 9. Querying JSON with JSONPath and LINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用JSONPath和LINQ查询JSON
- en: 'Sometimes, all you may want to do is extract a field or two from some JSON-formatted
    data, rather than parse a JSON blob into a class and work with all of its fields.
    With JSONPath or LINQ (using Json.NET), you can do just that. Here, you''ll find
    the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能只想从一些JSON格式的数据中提取一两个字段，而不是将JSON块解析为一个类并处理其所有字段。使用JSONPath或LINQ（使用Json.NET），您可以做到这一点。在这里，您会找到以下食谱：
- en: Using the JSONPath dot-notation to query JSON documents
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSONPath点表示法查询JSON文档
- en: Using JSONPath bracket-notation to query JSON documents
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSONPath方括号表示法查询JSON文档
- en: Using JSONPath scripting to construct more complicated queries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSONPath脚本构建更复杂的查询
- en: Using JSONPath in your web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的Web应用程序中使用JSONPath
- en: Using JSONPath in your Node.js application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的Node.js应用程序中使用JSONPath
- en: Using JSONPath in your PHP application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的PHP应用程序中使用JSONPath
- en: Using JSONPath in your Python application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的Python应用程序中使用JSONPath
- en: Using JSONPath in your Java application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的Java应用程序中使用JSONPath
- en: Using JSONPath with SelectToken to query for JSONPath expressions in your C#
    application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SelectToken在您的C#应用程序中查询JSONPath表达式
- en: Using LINQ with Json.NET to query JSON in your C# application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Json.NET和LINQ在您的C#应用程序中查询JSON
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: One of the biggest strengths of XML is XPath, the query-oriented language to
    query subsections of an XML document. Stefan Goessner proposed the JSONPath query
    language, a language with features similar to XPath that lets you extract just
    the bits of a JSON document your application needs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: XML最大的优点之一是XPath，它是一种查询语言，用于查询XML文档的子部分。Stefan Goessner提出了JSONPath查询语言，这是一种与XPath类似具有相似特性的语言，可以让您提取JSON文档中应用程序需要的部分。
- en: 'Note that something''s still doing the parsing: you don''t get something for
    nothing, and JSONPath implementations require JSON parsing with at least similar
    memory and runtime characteristics. However, if there''s a JSONPath library for
    the platform you''re developing, JSONPath can lead to more readable code, as you
    don''t need to mock entire classes only to extract a field or two or summarize
    a field across a collection of JSON values.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仍然有人在解析东西：没有免费的午餐，JSONPath实现需要至少具有相似内存和运行时特性的JSON解析。然而，如果您的平台上有JSONPath库，那么JSONPath可以使代码更易读，因为您不需要模拟整个类仅仅是为了提取一个或两个字段，或者是在一系列JSON值中对某个字段进行汇总。
- en: If you're used to developing for Microsoft platforms, you're certainly aware
    of Microsoft's **Language Independent Query** (**LINQ**) language that lets you
    use write declarative queries on enumerable data structures. While the .NET implementations
    of JSON parsing provide only rudimentary LINQ support, the indomitable Json.NET
    library's implementation supports LINQ as well as JSONPath, letting you make declarative
    queries of JSON documents using either fluent or statement syntax.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯于为Microsoft平台开发，您肯定知道Microsoft的**语言独立查询**（**LINQ**）语言，它允许您对可枚举数据结构编写声明式查询。尽管.NET实现的JSON解析只提供基本的LINQ支持，但不屈不挠的Json.NET库的实现支持LINQ以及JSONPath，让您可以使用流畅的或语句语法对JSON文档进行声明式查询。
- en: 'To use either JSONPath or LINQ, you''ll need a library that supports it. As
    I write this, there are libraries that support JSONPath for JavaScript, the flavour
    of JavaScript of Node.js, PHP, C#, Python, and Java. Of course, if you want to
    use LINQ, you''ll need to be running your application on the .NET platform using
    a language such as C#, F#, or Visual Basic. Consequently, most of the recipes
    that follow have two steps: what to do to download a library that supports JSONPath
    and then the actual steps to call the JSONPath code in your application.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JSONPath或LINQ，您需要一个支持它们的库。在我写这篇文章的时候，有支持JavaScript的JSONPath库，支持Node.js的JavaScript，以及支持PHP、C#、Python和Java的库。当然，如果您想要使用LINQ，您需要在.NET平台上运行您的应用程序，使用C#、F#或Visual
    Basic等语言。因此，接下来的大多数食谱都有两个步骤：第一步是下载一个支持JSONPath的库，然后是实际在应用程序中调用JSONPath代码的步骤。
- en: 'Most JSONPath examples use Goessner''s example document, consisting of records
    from a hypothetical bookstore, and in this chapter, we''ll stick with that example
    as well. Our JSON document looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JSONPath示例都使用了Goessner的示例文档，该文档包含了假设书店的记录，在本章中，我们将同样使用这个示例。我们的JSON文档看起来是这样的：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we have a store object, which has a collection of books and
    a single bicycle. Each book has a category, an author, a title, and a price. Representing
    a JSON document like this as a class would be difficult because of the very different
    structures of the book records as opposed to the bicycle record; you could use
    the type-unsafe query methods that we discussed in [Chapter 1](ch01.html "Chapter 1. Reading
    and Writing JSON on the Client"), *Reading and Writing JSON on the Client*, and
    [Chapter 2](ch02.html "Chapter 2. Reading and Writing JSON on the Server"), *Reading
    and Writing JSON on the Server*, to parse a document like this and traverse its
    document, although a better choice for most applications is JSONPath, as you'll
    soon see. Let's begin with how to query the document for individual fields.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有一个商店对象，它有一个书籍集合和一个单一的自行车。每本书都有一个类别、一个作者、一个标题和一个价格。像这样表示 JSON 文档作为一个类将很困难，因为书籍记录的结构与自行车记录的结构非常不同；您可以使用我们在第
    [1](ch01.html "第 1 章。在客户端读写 JSON") 章和第 [2](ch02.html "第 2 章。在服务器上读写 JSON") 章中讨论的不安全查询方法来解析这样的文档并遍历它的文档，尽管对于大多数应用程序来说，JSONPath
    是一个更好的选择，您很快就会看到。让我们从如何查询文档中的单个字段开始。
- en: Using the JSONPath dot-notation to query JSON documents
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSONPath 点表示法查询 JSON 文档
- en: JSONPath uses *expressions* written in either the dot-notation or bracket-notation
    to denote a traversal of fields in the JSON document. Dots separate field names,
    as if they were object attributes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JSONPath 使用点表示法或方括号表示法编写表达式，以表示 JSON 文档中的字段遍历。点分隔字段名称，就像它们是对象属性一样。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Here are a few examples of dot-notation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些点表示法的示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the first line, we reference the first (counting from zero) book in the store,
    returning the title field. The second line is similar, except that it returns
    a collection of all titles of all the books. The third example returns a collection
    of all price fields in all records in the store collection. The fourth example
    finds the fourth book item in the store.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们引用了商店中的第一个书籍（从零开始计数），返回标题字段。第二行类似，只不过它返回了所有书籍的标题集合。第三个例子返回了商店集合中所有记录的价格字段集合。第四个例子找到了商店中的第四本书项。
- en: The notation is fairly intuitive, except for the use of `..` and `*`. These
    are examples of some of the special characters used by JSONPath to denote slices
    across the document.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该表示法相当直观，除了 `..` 和 `*` 的使用。这些都是 JSONPath 用来表示文档中切片的一些特殊字符的例子。
- en: There's more…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'JSONPath defines the following special characters you can use when writing
    queries:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JSONPath 定义了以下特殊字符，您在编写查询时可以使用：
- en: The `$` symbol refers to the root object or element.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` 符号指的是根对象或元素。'
- en: The `@` symbol refers to the current object or element.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@` 符号指的是当前对象或元素。'
- en: The `.`operator is the dot-child operator, which you use to denote a child element
    of the current element.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.` 操作符是点子操作符，您使用它来指定当前元素的子元素。'
- en: The `[]` operator is the subscript operator, which you use to denote a child
    element of the current element (by name or index).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]` 操作符是下标操作符，您使用它来指定当前元素的子元素（按名称或索引）。'
- en: The `*` operator is a wildcard, returning all objects or elements regardless
    of their names.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 操作符是一个通配符，返回所有对象或元素，而不管它们的名称是什么。'
- en: The`,` operator is the union operator, which returns the union of the children
    or indexes indicated.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`,` 操作符是并集操作符，它返回所指示的子项或索引的并集。'
- en: The `:` operator is the array slice operator, so you can slice collections using
    the syntax `[start:end:step]` to return a subcollection of a collection.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:` 操作符是数组切片操作符，因此您可以使用语法 `[start:end:step]` 来返回集合的一个子集。'
- en: The `()` operator lets you pass a script expression in the underlying implementation's
    script language. It's not supported by every implementation of JSONPath, however.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()` 操作符允许您在底层实现的脚本语言中传递一个脚本表达式。然而，并非所有的 JSONPath 实现都支持它。'
- en: See also
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: The definitive JSONPath documentation is available at Goessner's website at
    [http://goessner.net/articles/JsonPath/](http://goessner.net/articles/JsonPath/).
    Of course, you should check the documentation for the implementation of JSONPath
    that you choose for specific implementation details.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JSONPath 的权威文档可以在 Goessner 的网站上找到，网址为 [http://goessner.net/articles/JsonPath/](http://goessner.net/articles/JsonPath/)。当然，您应该查看您选择的
    JSONPath 的文档，以了解特定的实现细节。
- en: 'One handy thing on the Web is a JSONPath expression tester; [http://jsonpath.curiousconcept.com/](http://jsonpath.curiousconcept.com/)
    is one such site. By pasting JSON and a JSONPath expression in the tester, you
    can evaluate the JSONPath and see what the result is. This is a very easy way
    to dynamically debug your JSONPath expressions as you first start. Here''s an
    example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的一个方便的功能是一个JSONPath表达式测试器；[http://jsonpath.curiousconcept.com/](http://jsonpath.curiousconcept.com/)就是这样一个网站。通过在测试器中粘贴JSON和JSONPath表达式，你可以评估JSONPath并查看结果是什么。这是你在最初开始时动态调试你的JSONPath表达式的一个非常简单的方法。这是一个例子：
- en: '![See also](img/B04206_09_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![参见](img/B04206_09_01.jpg)'
- en: Using JSONPath bracket-notation to query JSON documents
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSONPath方括号表示法查询JSON文档
- en: JSONPath provides an alternate notation, bracket-notation, which works just
    like dot-notation to query fields. The syntax is reminiscent of how you access
    fields in associative arrays, where you pass the field name as the selector to
    `operator[]` to obtain the value in the named field.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JSONPath提供了一种替代表示法，即方括号表示法，它与点表示法一样用于查询字段。这个语法让你想起了如何访问关联数组中的字段，你只需要将字段名作为选择器传递给`operator[]`，以获取命名字段中的值。
- en: How to do it…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'In bracket notation, we will write the previous recipe''s example as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在方括号表示法中，我们将之前的例子的公式写作如下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As seen earlier, the first example extracts the title of the first book in the
    object in the field named store. The second example extracts all titles of all
    books in the store. The third example returns a collection of all price fields
    for every item in the store, and the fourth example returns the fourth book in
    the store.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所见，第一个例子提取了对象中名为store的字段中的第一个书籍的标题。第二个例子提取了商店中所有书籍的标题。第三个例子返回了商店中每个项目的所有价格字段的一个集合，第四个例子返回了商店中的第四本书。
- en: Using JSONPath scripting to construct more complicated queries
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSONPath脚本构建更复杂的查询
- en: Sometimes, what you really want to do is query all items that meet a certain
    criteria, such as those exceed a particular threshold. JSONPath provides the `?()`
    predicate, which lets you execute simple comparison scripts of individual fields
    in your JSONPath.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你真正想做的事情是查询满足某些条件的所有项目，比如那些超过特定阈值的项目。JSONPath提供了`?()`谓词，它可以让你执行JSONPath中单个字段的简单比较脚本。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s an example that queries all books costing less than `10` currency units:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个查询所有价格低于`10`货币单位的书籍的例子：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The query begins by specifying all book items in the store; the `?()` predicate
    then selects each item in that category using the `@` selector to obtain the value
    of the current item, and then selects prices less than `10`. The resulting items
    have their title field extracted. This query yields the following results:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 查询从指定商店中的所有书籍项目开始；`?()`谓词然后使用`@`选择器获取当前项目的值，然后选择价格低于`10`的项目。最后提取结果项目的标题字段。这个查询产生了以下结果：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Queries like this don't work with all implementations of JSONPath. Checking
    the JSONPath Expression tester at [http://jsonpath.curiousconcept.com/](http://jsonpath.curiousconcept.com/),
    I found that it worked using the flow communications JSONPath 0.1.1 but not Goessner's
    implementation of JSONPath in version 0.8.3.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的查询并不是所有JSONPath实现都能工作的。在[http://jsonpath.curiousconcept.com/](http://jsonpath.curiousconcept.com/)检查JSONPath表达式测试器，我发现它使用flow
    communications JSONPath 0.1.1工作，但Goessner在版本0.8.3中的JSONPath实现不能工作。
- en: 'Any expression that returns a Boolean can be used in the `?()` predicate. Here''s
    another example that queries all books in the fiction category in our collection:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 任何返回布尔值的表达式都可以用在`?()`谓词中。这是一个查询我们集合中所有小说类别的书籍的另一个例子：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The beginning is the same, that is, selecting for all books; instead of filtering
    by price and returning books costing less than `10`, this returns all items in
    the collection where a specific item in the book collection has a category field
    equal to fiction.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开始的部分是一样的，那就是选择所有书籍；不是通过价格筛选并返回价格低于`10`的书籍，而是返回集合中某个特定书籍集合中的特定项目类别字段等于小说的所有项目。
- en: Using JSONPath in your web application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的网络应用程序中使用JSONPath
- en: Using JSONPathwith JavaScript in your web application is easy. You only need
    to include the `jsonpath.js` implementation in your application, and then use
    its `jsonPath` function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络应用程序中使用JSONPath与JavaScript结合是非常简单的。你只需要在你的应用程序中包含`jsonpath.js`实现，然后使用它的`jsonPath`函数。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: 'Before you begin, you need to download the JavaScript `jsonpath` library from
    [https://code.google.com/p/jsonpath/](https://code.google.com/p/jsonpath/) and
    include it in the scripts your HTML page uses with a script tag, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你需要从[https://code.google.com/p/jsonpath/](https://code.google.com/p/jsonpath/)下载JavaScript
    `jsonpath`库，并使用script标签将其包含在HTML页面使用的脚本中，像这样：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `jsonPath` function takes a JSON object (not as a string, but as a JavaScript
    object) and applies the path operation to the contents, returning either the matched
    values or a normalized path. Let's see an example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonPath`函数接受一个JSON对象（不是作为字符串，而是作为JavaScript对象）并对内容应用路径操作，返回匹配的值或规范化的路径。让我们看一个例子。'
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s an example that returns a list of titles from the JSON object I showed
    in the introduction:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，它从我在引言中展示的JSON对象中返回一个标题列表：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that if you have the object as a string, you''ll have to parse it first
    using `JSON.parse`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你有对象作为字符串，你将需要首先使用`JSON.parse`解析它：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The preceding code uses the `jsonPath` function to extract all titles from the
    currently passed object. The `jsonPath` function takes a JavaScript object, path,
    and an optional result type that indicates whether the return value should be
    the value or the path to the value. The incoming object can either be a structured
    object or an array, of course.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`jsonPath`函数从当前传递的对象中提取所有标题。`jsonPath`函数接受一个JavaScript对象、路径和一个可选的结果类型，指示返回值应该是值还是值的路径。当然，传入的对象可以是结构化对象或数组。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: Goessner's original documentation for the original implementation of JSONPath
    is at [http://goessner.net/articles/JsonPath/](http://goessner.net/articles/JsonPath/).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Goessner关于JSONPath原始实现的原始文档在[http://goessner.net/articles/JsonPath/](http://goessner.net/articles/JsonPath/)。
- en: Using JSONPath in your Node.js application
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的Node.js应用程序中使用JSONPath
- en: There's an npm package available that contains an implementation of the JavaScript
    JSONPath implementation, so if you want to use JSONPath from Node.js, you only
    need to install the JSONPath module and call it directly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个npm包可用，其中包含JavaScript JSONPath实现的实现，所以如果你想在Node.js中使用JSONPath，你只需要安装JSONPath模块并直接调用它。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'To install the JSONPath module, run the following command to include the module
    in your current application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`JSONPath`模块，运行以下命令将模块包含在你的当前应用程序中：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, you can run the following command to include it for all projects
    on your system:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以运行以下命令将其包括在你系统上的所有项目中：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, you''ll have to require the module in your source code, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在你的源代码中要求模块，像这样：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This loads the `JSONPath` module into your environment, storing a reference
    in the `jsonPath` variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`JSONPath`模块加载到你的环境中，并将引用存储在`jsonPath`变量中。
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'The JSONPath module for Node.js defines a single method, `eval`, which takes
    a JavaScript object and a path to evaluate. For example, to obtain a list of the
    titles in our example document, we would need to execute the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的JSONPath模块定义了一个单一的方法`eval`，该方法接受一个JavaScript对象和一个要评估的路径。例如，为了获得我们示例文档中的标题列表，我们需要执行以下代码：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you''re going to be applying a path to JSON in string form, be sure to parse
    it first:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算将路径应用于以字符串形式的JSON，请确保先解析它：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The `eval` method of the `JSONPath` module takes a JavaScript object (not a
    string containing JSON) and applies the path you pass to return the corresponding
    values from the object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONPath`模块的`eval`方法接受一个JavaScript对象（不是包含JSON的字符串）并应用你传递的路径以返回对象中的对应值。'
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: For documentation about the JSONPath module for Node.js, see [https://www.npmjs.com/package/JSONPath](https://www.npmjs.com/package/JSONPath).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Node.js的JSONPath模块的文档，请参阅[https://www.npmjs.com/package/JSONPath](https://www.npmjs.com/package/JSONPath)。
- en: Using JSONPath in your PHP application
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的PHP应用程序中使用JSONPath
- en: Using JSONPath in your PHP application requires you to include the JSONPath
    PHP implementation available at [https://code.google.com/p/jsonpath/](https://code.google.com/p/jsonpath/),
    and parsing the JSON string to a PHP mixed object before applying the JSONPath
    path you want to extract data from with the `jsonPath` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的PHP应用程序中使用JSONPath需要你包含位于[https://code.google.com/p/jsonpath/](https://code.google.com/p/jsonpath/)的JSONPath
    PHP实现，并在应用你想要用`jsonPath`函数从其中提取数据的JSONPath路径之前，将JSON字符串解析为PHP混合对象。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: You'll need to download `jsonpath.php` from [code.google.com](http://code.google.com)
    at [https://code.google.com/p/jsonpath/](https://code.google.com/p/jsonpath/)
    and include it in your application with the `require_once` instruction. You'll
    also need to ensure that your PHP implementation includes `json_decode`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从[code.google.com](http://code.google.com)下载`jsonpath.php`，位于[https://code.google.com/p/jsonpath/](https://code.google.com/p/jsonpath/)，并通过`require_once`指令将其包含在你的应用程序中。你还需要确保你的PHP实现包括了`json_decode`。
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s a simple example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The preceding code begins by requiring the PHP JSONPath implementation, which
    defines the `jsonPath` function. It then decodes the JSON string using `json_decode`,
    before extracting the titles in the mixed PHP object that `json_decode` returns.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先引入了PHP JSONPath实现，该实现定义了`jsonPath`函数。然后使用`json_decode`解码JSON字符串，再提取`json_decode`返回的混合PHP对象中的标题。
- en: 'Like the JavaScript version of `jsonPath`, the PHP version takes three arguments:
    the object from which to perform the extraction, the path to extract, and an optional
    third argument that specifies whether to return the data or return the path to
    the data in the structure.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与JavaScript版本的`jsonPath`类似，PHP版本接受三个参数：要执行提取的对象、要提取的路径以及一个可选的第三个参数，用于指定是返回数据还是返回数据结构的路径。
- en: See also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: For more information about the PHP implementation of JSONPath, see Stefan Goessner's
    web site at [http://goessner.net/articles/JsonPath/](http://goessner.net/articles/JsonPath/).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP实现JSONPath的更多信息，请参阅Stefan Goessner的网站[http://goessner.net/articles/JsonPath/](http://goessner.net/articles/JsonPath/)。
- en: Using JSONPath in your Python application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的Python应用程序中使用JSONPath
- en: There are several implementations of JSONPath for Python, too. The best is `jsonpath-rw`
    library, which provides language extensions so that paths are first-class language
    objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 也为Python提供了几个JSONPath实现。最好的是`jsonpath-rw`库，它提供了语言扩展，使路径成为一等语言对象。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'You''ll need to install the `jsonpath-rw` library using pip:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用pip安装`jsonpath-rw`库：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, of course, you will need to include the necessary bits of the library
    when using them:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还需要在使用它们时包含库所需的部分：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s a simple example using our store contents in the introduction stored
    in the variable `object`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，使用存储在变量`object`中的介绍中的商店内容：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Processing a path expression using this library is a little like matching a
    regular expression; you parse out the JSONPath expression and then apply it to
    the Python object you want to slice using path's `find` method. This code defines
    the object and then creates a path expression storing it in path, parsing the
    JSONPath that fetches all titles. Finally, creates an array of values found by
    the path in the object you pass to the path.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个库处理路径表达式有点像匹配正则表达式；你解析出JSONPath表达式，然后使用路径的`find`方法将其应用于你想要切片的Python对象。这段代码定义了对象，然后创建了一个路径表达式将其存储在路径中，解析获取所有标题的JSONPath。最后，在传递给路径的你要切片的对象中创建了一个由路径找到的值的数组。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: The documentation for the Python JSONPath library is at [https://pypi.python.org/pypi/jsonpath-rw](https://pypi.python.org/pypi/jsonpath-rw).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python JSONPath库的文档位于[https://pypi.python.org/pypi/jsonpath-rw](https://pypi.python.org/pypi/jsonpath-rw)。
- en: Using JSONPath in your Java application
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的Java应用程序中使用JSONPath
- en: There's an implementation of JSONPath for Java, too, written by **Jayway**.
    It's available from GitHub, or you can obtain it through the **Central Maven Repository**
    if your project uses the Maven build system. It matches the original JSONPath
    API, returning Java objects and collections for fields in JSON objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个为Java编写的JSONPath实现，由**Jayway**编写。它可以从GitHub获取，或者如果你的项目使用Maven构建系统，你还可以通过**中央Maven仓库**获取。它与原始JSONPath
    API相匹配，为JSON对象中的字段返回Java对象和集合。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'You''ll need to either download the code from GitHub at [https://github.com/jayway/JsonPath](https://github.com/jayway/JsonPath),
    or, if you''re using Maven as your build system, include the following dependency:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从GitHub上下载代码[https://github.com/jayway/JsonPath](https://github.com/jayway/JsonPath)，或者，如果你使用Maven作为你的构建系统，请包含以下依赖项：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'The Java implementation parses your JSON and exports a J`sonPath` class with
    a method read that reads JSON, parses it, and then extracts the contents at the
    path you pass:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Java实现解析你的JSON，并导出一个`JsonPath`类，该类有一个`read`方法，用于读取JSON，解析它，然后提取你传递的路径的内容：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The read method parses the JSON you pass, and then applies the path you pass
    to extract the values from the JSON. If you have to extract more than one path
    from the same document, it''s best to parse the document only once, and then call
    read on the parsed document, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 读取方法解析传递给它的JSON，然后将传递给它的路径应用于提取JSON中的值。如果你需要从同一文档中提取多个路径，最好只解析文档一次，然后对解析后的文档调用读取方法，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's more…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The Java JSONPath library also provides a fluent syntax, where the implementation
    of read and other methods returns a context on which you can continue to invoke
    other JSONPath library methods. For example, to obtain a list of books with a
    price more than `10`, I can also execute the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Java JSONPath库还提供了一种流畅的语法，其中读取和其他方法的实现返回一个上下文，你可以继续调用其他JSONPath库方法。例如，为了获取价格超过`10`的书籍列表，我还可以执行以下代码：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This configures `JsonPath` using the configuration, parses the JSON you pass,
    and then invokes read with a path selector that selects all book objects with
    a price greater than the value `10`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这配置了`JsonPath`，使用了配置，解析了传递给它的JSON，然后使用路径选择器调用`read`，选择所有价格超过值`10`的书籍对象。
- en: 'The JsonPath library in Java attempts to cast its result objects to the primitive
    classes you expect: lists, strings, and so forth. Some path operations—`..`, `?()`,
    and `[number:number:number]`—always return a list, even if the resulting value
    is a single object.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的JsonPath库试图将结果对象转换为你期望的基本类：列表、字符串等等。一些路径操作—`..`、`?()`和`[number:number:number]`—总是返回一个列表，即使结果值是一个单一的对象。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For the documentation on the Java JSONPath implementation, see [https://github.com/jayway/JsonPath](https://github.com/jayway/JsonPath).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Java JSONPath实现的文档，请参阅[https://github.com/jayway/JsonPath](https://github.com/jayway/JsonPath)。
- en: Using JSONPath with SelectToken to query for JSONPath expressions in your C#
    application
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSONPath和SelectToken在C#应用程序中查询JSONPath表达式
- en: If you use Newonsoft's Json.NET for the .NET environment, you can use its `SelectToken`
    implementation to make JSONPath queries of JSON documents. First, you'll parse
    the JSON into `JObject` and then make a query.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是.NET环境中的Newonsoft Json.NET，你可以使用其`SelectToken`实现对JSON文档进行JSONPath查询。首先，你需要将JSON解析为`JObject`，然后进行查询。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: You'll need to include the Json.NET assembly in your application. To do this,
    follow the steps in [Chapter 7](ch07.html "Chapter 7. Using JSON in a Type-safe
    Manner"), *Using JSON in a Type-safe Manner*, in the *Getting ready* section of
    the *How to Deserialize an object with Json.NET* recipe.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的应用程序中包含Json.NET库。为此，请按照*如何使用Json.NET反序列化对象*食谱中的*准备*部分中的[第7章](ch07.html
    "第7章 使用类型安全的JSON")*使用类型安全的JSON*中的步骤操作。
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行…
- en: 'Here''s how to extract all titles of all books from the example in the introduction
    and get the first result:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是提取所有书籍标题的步骤以及得到的第一结果：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `SelectTokens` method of `JObject` takes a JSONPath expression and applies
    it to the object. Here, we extract a list of `JObject` instances, one for each
    item matching the top-level `$.store.book` path, and then invoke the `Values`
    method to obtain coerced string values for each of the title fields in each of
    the returned `JObject` instances. Of course, the original JSON needs to be parsed,
    which we do with `JObject.parse`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`JObject`的`SelectTokens`方法接受一个JSONPath表达式，并将其应用于对象。在这里，我们提取匹配顶级`$.store.book`路径的每个项目的`JObject`实例列表，然后调用`Values`方法获取每个返回的`JObject`实例中的每个标题字段的强制字符串值。当然，原始JSON需要解析，我们使用`JObject.parse`进行解析。'
- en: Note that `SelectTokens` returns an enumerable collection, which you can further
    process using LINQ expressions, as we do here by invoking `First`. Strictly speaking,
    `SelectTokens` returns `IEnumberable<JToken>`, where each `JToken` is a single
    JSON collection. JObject also provides the `SelectToken` method, which returns
    a single instance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`SelectTokens`返回一个可枚举的集合，你可以使用LINQ表达式进一步处理，就像我们在这里通过调用`First`一样。严格来说，`SelectTokens`返回`IEnumberable<JToken>`，其中每个`JToken`都是单个JSON集合。JObject还提供`SelectToken`方法，返回一个实例。
- en: Be careful not to confuse `SelectToken` and `SelectTokens`, however. The former
    can *only* return a single `JToken`, while the latter is required anytime you
    want to return a collection of items in your JSONPath query.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要小心不要混淆`SelectToken`和`SelectTokens`。前者*只能*返回一个`JToken`，而后者在你想要返回JSONPath查询中的项目集合时是必需的。
- en: 'Filtering is supported, too. For example, to obtain `JObject` containing the
    data about the book *Moby Dick*, I might write:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 也支持过滤。例如，为了获得包含关于书籍*Moby Dick*的数据的`JObject`，我可能会写：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This selects the document with `title` matching "`Moby Dick`" from the `book`
    collection in the `store` field.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此选择从`store`字段中的`book`集合中选择标题匹配"`Moby Dick`"的文档。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请也参阅
- en: See the documentation and more examples for `SelectToken` and `SelectTokens`
    at Jason Newton-King's website at [http://james.newtonking.com/archive/2014/02/01/json-net-6-0-release-1-%E2%80%93-jsonpath-and-f-support](http://james.newtonking.com/archive/2014/02/01/json-net-6-0-release-1-%E2%80%93-jsonpath-and-f-support),
    or the Json.NET documentation at [http://www.newtonsoft.com/json/help/html/QueryJsonSelectToken.htm](http://www.newtonsoft.com/json/help/html/QueryJsonSelectToken.htm).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 参阅Jason Newton-King网站上关于`SelectToken`和`SelectTokens`的文档和更多示例，网址为[http://james.newtonking.com/archive/2014/02/01/json-net-6-0-release-1-%E2%80%93-jsonpath-and-f-support](http://james.newtonking.com/archive/2014/02/01/json-net-6-0-release-1-%E2%80%93-jsonpath-and-f-support)，或者Json.NET文档[http://www.newtonsoft.com/json/help/html/QueryJsonSelectToken.htm](http://www.newtonsoft.com/json/help/html/QueryJsonSelectToken.htm)。
- en: Using LINQ with Json.NET to query JSON in your C# application
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Json.NET和LINQ查询C#应用程序中的JSON
- en: If you're developing for .NET, you might just want to skip JSONPath entirely
    and use Json.NET's support to subscribe based on field name and support for LINQ.
    Json.NET supports LINQ out of the box, letting you craft any query you want against
    your JSON in either fluent or statement syntax.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为.NET开发，你可能想完全跳过JSONPath，并使用Json.NET的支持基于字段名称进行订阅，并支持LINQ。Json.NET内置支持LINQ，让你可以针对你的JSON使用流畅或语句语法编写任何查询。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: As with the previous recipe, your .NET project needs to use Json.NET. To include
    Json.NET in your project, follow the steps I show you in [Chapter 7](ch07.html
    "Chapter 7. Using JSON in a Type-safe Manner"), *Using JSON in a Type-safe Manner*,
    in the *Getting Started* section of the *How to Deserialize an Object with Json.NET*
    recipe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的食谱一样，你的.NET项目需要使用Json.NET。要将在项目中包含Json.NET，请按照我在[第7章](ch07.html "第7章 以类型安全的方式使用JSON")*以类型安全的方式使用JSON*中的*入门*部分所示的步骤操作，该章节为*如何使用Json.NET反序列化对象*食谱。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'You''ll parse the JSON to `JObject`, and then you can just evaluate LINQ expressions
    against the resulting `JObject`, like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你将解析JSON以`JObject`，然后你可以针对结果`JObject`评估LINQ表达式，如下所示：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Of course, because it''s LINQ, fluent syntax is supported, too:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，因为是LINQ，也支持流畅语法：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first example selects all `title` objects, one from each `book` field, casting
    each to a string before returning the result. The second example performs a selection
    on all `price` fields of `book`, casting the resulting value to a double and invoking
    `Sum` method on the list to obtain the total price of all of the books.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例选择所有的`title`对象，每个`book`字段中的一个，返回结果之前将每个对象转换为字符串。第二个示例对所有`book`的`price`字段进行选择，将结果值转换为双精度浮点数，并在列表上调用`Sum`方法，以获得所有书籍的总价格。
- en: 'Something to look out for is that the usual return type of a sub-field in a
    Json.NET LINQ query is `JObject`, so you have to use the `Value` and `Values`
    methods of the `JObject` template to obtain the values of those objects when you''re
    writing an expression in fluent syntax. Your first attempt at calculating the
    sum might have read something like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要留心的是，Json.NET LINQ查询中的子字段的通常返回类型是`JObject`，所以你在使用流畅语法编写表达式时，必须使用`JObject`模板的`Value`和`Values`方法来获取这些对象的价值。你第一次尝试计算总和可能如下所示：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, this won't work because the return value of the selection is a list
    of `JObject`s, which can't be summed directly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会起作用，因为选择返回的值是一个`JObject`对象的列表，不能直接相加。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When writing LINQ expressions, LINQPad ([http://www.linqpad.net](http://www.linqpad.net))
    is especially helpful. If you're doing a lot of LINQ and JSON, investing in the
    Developer or Premium versions may be wise, as these versions support integration
    with NuGet that let you include Json.NET right in your test queries.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写LINQ表达式时，LINQPad（[http://www.linqpad.net](http://www.linqpad.net)）非常有帮助。如果你做大量的LINQ和JSON，投资开发人员或高级版本可能是明智的，因为这些版本支持与NuGet的集成，让你可以将Json.NET直接包含在你的测试查询中。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请也参阅
- en: For more information about LINQ and Json.NET, see the Json.NET documentation
    at [http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于LINQ和Json.NET的更多信息，请参阅位于[http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm)的Json.NET文档。
