- en: Chapter 4. Forms, and How to Validate Them
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。表单及其验证方式
- en: In this chapter, we will see how data binding works for user input elements,
    such as `input`, `select`, and `textarea`. We will also see how the Fetch client
    works when dealing with scenarios more complex than simple GET requests, such
    as POST or PUT requests with JSON bodies, or requests to upload files to a server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解数据绑定如何适用于用户输入元素，如`input`、`select`和`textarea`。我们还将了解当处理比简单GET请求更复杂的场景时，Fetch客户端如何工作，例如带有JSON主体的POST或PUT请求，或者向服务器上传文件的需求。
- en: Additionally, we will see how we can validate forms, by using the `aurelia-validation`
    plugin.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将了解如何使用`aurelia-validation`插件验证表单。
- en: Lastly, we will discuss various strategies to create complex forms, from inline
    list edition to modal edition windows using the `aurelia-dialog` plugin.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论使用`aurelia-dialog`插件创建复杂表单的各种策略，从内联列表编辑到使用模态窗口编辑。
- en: Binding to form inputs
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定表单输入
- en: Aurelia supports two-way binding to all official HTML5 user input elements.
    Some of them are pretty simple to use, such as the `text input`, which we have
    already explored in many examples in previous chapters. Some others, such as radio
    buttons or checkboxes, are less straightforward. Let's go over all of them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia支持所有官方HTML5用户输入元素的双向绑定。其中一些相当简单易用，比如`text input`，我们已经在前面的章节中用许多示例探索过。其他的，如单选按钮或复选框，则不太直接。让我们逐一了解它们。
- en: The code snippets in the following sections are excerpts from `chapter-4/samples/binding-forms`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分中的代码片段摘自`chapter-4/samples/binding-forms`。
- en: select elements
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择元素
- en: 'For a `select` element, we typically bind to its `value` attribute, and often
    use `repeat.for` to render its `option` elements:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`select`元素，我们通常绑定到它的`value`属性，并且经常使用`repeat.for`来渲染它的`option`元素：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, the `select` element's `value` attribute is bound two-way by default,
    so the `value` attribute of the selected `option` element will be assigned to
    the expression bound to the `value` of `select`. In this example, the `selectedCountry`
    property will be assigned the selected `country` value.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`select`元素的`value`属性默认绑定双向，所以选中的`option`元素的`value`将分配给绑定到`select`的`value`属性的表达式。在此示例中，`selectedCountry`属性将被分配选中的`country`值。
- en: 'The `value` attribute of an `option` element expects string values only. In
    the previous example, the `countries` property is an array of strings, so the
    `value` of each `option` is bound to a string. To render an `option` bound to
    any other type of value--an object, for example--the special `model` attribute
    must be used:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`option`元素的`value`属性只期望字符串值。在前一个示例中，`countries`属性是一个字符串数组，因此每个`option`的`value`绑定到一个字符串。要渲染绑定到任何其他类型值的`option`——例如一个对象——必须使用特殊的`model`属性：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the `selectedCulture` property will be assigned to the selected `culture`
    object, because the `cultures` property is an array of objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，`selectedCulture`属性将被赋值为选中的`culture`对象，因为`cultures`属性是一个对象数组。
- en: 'Alternatively, if you need to select a key property, such as an ID, instead
    of the whole array item, you can still use the `value` attribute on the `option`
    elements, given that the key property is a string value:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你需要选择一个键属性，比如一个ID，而不是整个数组项，你仍然可以使用`option`元素的`value`属性，前提是键属性是一个字符串值：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `value` of the selected `option` is bound to the corresponding
    item's `isoCode` property, which is a string, so this property of the selected
    item will be assigned to `selectedCultureIsoCode`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，选中的`option`的`value`绑定到相应项的`isoCode`属性，这是一个字符串，因此选中项的此属性将被分配给`selectedCultureIsoCode`。
- en: Of course, during rendering, the value of the expression bound to the `value`
    of the `select` attribute will be evaluated and, if any `option` has a matching
    `value` or `model` attribute, this `option` will be rendered as selected.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在渲染过程中，绑定到`select`属性的`value`表达式的值将被求值，如果任何`option`具有匹配的`value`或`model`属性，这个`option`将被渲染为选中状态。
- en: Multi-selection
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多选
- en: 'When a `select` element has the `multiple` attribute, the expression bound
    to its `value` attribute is expected to be an array:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当`select`元素具有`multiple`属性时，绑定到其`value`属性的表达式预期是一个数组：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the values of the selected options will be added to the `selectedCountries`
    array.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，选中的选项的值将被添加到`selectedCountries`数组中。
- en: When the user selects an item, the selected value is always appended at the
    end of the selection array.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择一个项目时，选中的值总是添加到选择数组的末尾。
- en: 'Of course, the same rule applies when rendering an array of non-string values
    into a multi-select list; each array item should be bound to its `option``model`
    attribute:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当将非字符串值的数组渲染到多选列表时，也适用于相同的规则；数组的每个项目应绑定到其`option`的`model`属性上：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the selected `culture` objects will be added to the `selectedCultures`
    array.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所选的`culture`对象将被添加到`selectedCultures`数组中。
- en: 'The alternative, using a key string property, also works the same with multi-selection:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键字符串属性的替代方案，在多选中同样适用：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the `isoCode` property of the selected `culture` objects will
    be added to the `selectedCulturesIsoCodes` array, which is an array of strings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，所选`culture`对象的`isoCode`属性将被添加到`selectedCulturesIsoCodes`数组中，这是一个字符串数组。
- en: Matchers
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配器
- en: When using the `model` attribute, it may happen that the object assigned to
    the `value` of `select` has the same identity, but is not the same instance, as
    the ones assigned to the `option``model`. In such a case, Aurelia won't be able
    to render the proper `option` as selected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`model`属性时，可能会发生这种情况：分配给`select`的`value`属性的对象具有相同的身份，但与分配给`option`的`model`属性的对象不是同一个实例。在这种情况下，Aurelia将无法渲染正确的`option`作为选中项。
- en: 'The `matcher` attribute has been designed for this kind of scenario:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`matcher`属性正是为这种场景设计的：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, when trying to find which `option` should be selected, the `select` element
    will delegate the equality comparison to the `matchCulture` function, which should
    somehow look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当尝试找出哪个`option`应该被选中时，`select`元素会将等价比较委托给`matchCulture`函数，该函数应大致如下所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, this function expects two culture objects, which possibly have the same
    identity and represent the same culture. It will return `true` if the two objects
    have the same identity, and `false` otherwise.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这个函数期望有两个文化对象，它们可能具有相同的身份，代表相同的文化。如果这两个对象具有相同的身份，将返回`true`，否则返回`false`。
- en: input elements
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入元素
- en: 'Binding to `input` elements is straightforward in most cases, but it actually
    depends on the `type` attribute. For example, for `text` inputs, the `value` attribute
    is bound two-way by default, and can be used to get the user''s input:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到`input`元素在大多数情况下是很简单的，但实际上取决于`type`属性。例如，对于`text`输入，`value`属性默认是双向绑定的，可以用来获取用户的输入：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the initial value of the `title` property would be displayed in the `input`,
    and any change performed by the user to the `input` value would also be applied
    to the `title` property. Similarly, any change performed to the `title` property
    will also be applied to the `value` of the `input`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`title`属性的初始值将在`input`中显示，用户对`input`值的任何更改也将应用到`title`属性上。类似地，对`title`属性的任何更改也将应用到`input`的`value`上。
- en: 'The usage is the same for most other types of `input`: `color`, `date`, `email`,
    `number`, `password`, `tel`, or `url`, just to name a few. There are however some
    special cases, which are described as follows.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数其他类型的`input`，使用方式相同：`color`、`date`、`email`、`number`、`password`、`tel`或`url`等。然而，也有一些特殊情况，如下所述。
- en: File pickers
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件选择器
- en: 'The `input` element, when its `type` attribute is `file`, exposes its `files`
    property as an attribute. It uses two-way binding by default:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当`input`元素的`type`属性为`file`时，它暴露其`files`属性作为一个属性。它默认使用双向绑定：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the `input``files` property is bound to the view-model's `images`
    property. When thee user selects a file, `images` is assigned a `FileList` object
    containing the selected file as a single `File` object. If the `input` has the
    `multiple` attribute, the user is able to select multiple files, and the resulting
    `FileList` object contains as many `File` objects as selected by the user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`input`元素的`files`属性被绑定到视图模型的`images`属性上。当用户选择一个文件时，`images`被赋予一个包含所选文件的`FileList`对象。如果`input`元素具有`multiple`属性，用户可以选择多个文件，结果的`FileList`对象将包含用户选择的多个`File`对象。
- en: The `FileList` and `File` classes are part of the HTML5 File API, and can be
    used with the Fetch API to send files selected by the user to a server. We will
    see an example of this when building the photo-editing component in our contact
    application, later in this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileList`和`File`类是HTML5文件API的一部分，可以与Fetch API一起使用，将用户选择的文件发送到服务器。在本书稍后的章节中，我们将看到在构建联系人应用程序的照片编辑组件时的一个示例。'
- en: The Mozilla Developer Network has extensive documentation about the File API.
    Details about the `FileList` class can be found at [https://developer.mozilla.org/en-US/docs/Web/API/FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla开发者网络有关于文件API的详尽文档。关于`FileList`类的详细信息可以在[https://developer.mozilla.org/en-US/docs/Web/API/FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)找到。
- en: Radio buttons
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单选按钮
- en: Similarly to a `select` element's `option`, radio buttons can use either the
    `value` or the `model` attribute to specify the value used when the button is
    selected. The `value` attribute expects only string values, so the `model` attribute
    must be used for any other types of value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与`select`元素的`option`类似，单选按钮可以使用`value`或`model`属性来指定按钮选中时的值。`value`属性只期望字符串值，所以对于任何其他类型的值，必须使用`model`属性。
- en: Additionally, radio buttons can bind their `checked` attribute, which is two-way
    by default, to an expression that will be assigned the `value` or `model` of the
    button when selected.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单选按钮可以绑定它们的`checked`属性，该属性默认是双向的，到一个表达式，当选中时将被分配按钮的`value`或`model`。
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, a group of radio buttons is rendered using an array of strings named `countries`.
    The `country` of the selected radio button, bound to the `value` attribute, will
    be assigned to the `selectedCountry` property.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一组单选按钮使用名为`countries`的字符串数组进行渲染。选中的单选按钮的`country`，绑定到`value`属性，将被分配给`selectedCountry`属性。
- en: 'Just like with the `option` elements, when binding to values that are not strings,
    the `model` attribute should be used instead of `value`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与`option`元素一样，当绑定到不是字符串的值时，应使用`model`属性而不是`value`：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, a group of radio buttons is rendered using an array of `culture` objects.
    The `culture` of the selected radio button, bound to the `model` attribute, will
    be assigned to the `selectedCulture` property.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一组单选按钮使用一个`culture`对象的数组进行渲染。选中的单选按钮的`culture`，绑定到`model`属性，将被分配给`selectedCulture`属性。
- en: Similarly to the `select` element, radio buttons that use the `model` attribute
    can also use the `matcher` attribute to customize the equality comparison logic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与`select`元素类似，使用`model`属性的单选按钮也可以使用`matcher`属性来自定义等价比较逻辑。
- en: 'All previous examples used `repeat.for` bound to an array to render a dynamic
    list of radio buttons. What if you need to render a static list of radio buttons
    and the expected output is a Boolean, for example? In this case, no need to iterate
    on an array:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的示例都使用了`repeat.for`绑定到数组来渲染动态的单选按钮列表。如果你需要渲染一个静态的单选按钮列表，并且期望的输出是一个布尔值，例如呢？在这种情况下，不需要在数组上迭代：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, a static list of radio buttons is rendered, each bound to a
    different scalar value using their `model` attribute. Their `checked` attribute
    is bound to the `isMultilingual` property, which will be assigned either `null`,
    `true`, or `false`, depending on which button is selected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，渲染了一个静态的单选按钮列表，每个按钮都使用它们的`model`属性绑定到不同的标量值。它们的`checked`属性绑定到`isMultilingual`属性，这将根据选择哪个按钮而被分配为`null`、`true`或`false`。
- en: Of course, during rendering, if the expression bound to the `checked` attribute
    of the buttons of a group has a value matching one of the button's `value` or
    `model` attributes, this button will be rendered as selected.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在渲染过程中，如果绑定到按钮组`checked`属性的表达式有一个值与按钮的`value`或`model`属性匹配，这个按钮将被渲染为选中状态。
- en: Checkboxes
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复选框
- en: 'A list of checkboxes is similar in its typical usage to a `select` element
    with the `multiple` attribute. Each `input` element has either a `value` or a
    `model` attribute. Additionally, a `checked` attribute is expected to be bound
    to an array, to which the `value` or `model` of all checked `input`s will be added:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框列表在其典型用法上与带`multiple`属性的`select`元素相似。每个`input`元素都有`value`或`model`属性。此外，预期`checked`属性将被绑定到数组，到这个数组中将会添加所有选中的`input`的`value`或`model`：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, a group of checkboxes is rendered using an array of strings named `countries`.
    The `country` of the selected checkboxes, bound to the `value` attribute, will
    be added to the `selectedCountries` array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一组复选框使用名为`countries`的字符串数组进行渲染。选中的复选框的`country`，绑定到`value`属性，将被添加到`selectedCountries`数组。
- en: 'Just like with `option` elements or radio buttons, the `value` attribute expects
    string values only. When binding to any other types of value, the `model` attribute
    should be used:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与`option`元素或单选按钮一样，`value`属性只期望字符串值。当绑定到任何其他类型的值时，应使用`model`属性：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, a group of checkboxes is rendered using an array of `culture` objects.
    The `culture` of the selected checkboxes, bound using the `model` attribute, will
    be added to the `selectedCultures` array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，一组复选框使用`culture`对象的数组进行渲染。选中的复选框的`culture`，通过`model`属性绑定，将被添加到`selectedCultures`数组中。
- en: Similarly to the `select` element and to radio buttons, checkboxes that use
    the `model` attribute can also use the `matcher` attribute to customize the equality
    comparison logic.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与`select`元素和单选按钮类似，使用`model`属性的复选框也可以使用`matcher`属性来自定义等价比较逻辑。
- en: 'Of course, if, when rendering an array of objects, the selected values are
    some sort of string IDs, the `value` attribute can still be used:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果渲染对象数组时，选中的值是某种字符串ID，仍然可以使用`value`属性：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, a group of checkboxes is rendered using an array of `culture` objects.
    The `isoCode` property of the selected checkboxes `culture`, bound to the `value`
    attribute, will be added to the `selectedCulturesIsoCodes` array of strings.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，一组复选框使用`culture`对象的数组进行渲染。选中的复选框的`culture`的`isoCode`属性，绑定到`value`属性，将被添加到`selectedCulturesIsoCodes`字符串数组中。
- en: Of course, during rendering, if the array bound to the `checked` attribute contains
    the value bound to the `value` or `model` attribute, this checkbox will be rendered
    as selected.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在渲染过程中，如果绑定到`checked`属性的数组包含绑定到`value`或`model`属性的值，此复选框将被渲染为选中状态。
- en: 'Alternatively, checkboxes can be bound to distinct Boolean expressions instead
    of a single array. This can be achieved by omitting any `value` or `model` attribute:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Alternatively，复选框可以绑定到不同的布尔表达式，而不是一个单一的数组。这可以通过省略任何`value`或`model`属性来实现：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, each `checkbox` is bound to a distinct property, which will
    be assigned `true` or `false` depending on whether the checkbox is checked or
    not.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，每个`checkbox`绑定到不同的属性，这将根据复选框是否被选中分配`true`或`false`。
- en: textarea
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`textarea`'
- en: 'Binding to a `textarea` element is identical to binding to a `text``input`
    element:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到`textarea`元素与绑定到`text``input`元素相同：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the initial value of the `text` property will be displayed inside the
    `textarea` and, as the binding on a `value` attribute of `textarea` is two-way
    by default, all modifications performed by the user on the content of the `textarea`
    will be reflected on the `text` property.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，`text`属性的初始值将在`textarea`内显示，由于`textarea`的`value`属性的绑定是默认的双向的，用户对`textarea`内容的所有修改都将反映在`text`属性上。
- en: Disabling an element
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用元素
- en: 'Disabling an `input`, `select`, `textarea`, or `button` element is only a matter
    of binding to its `disabled` attribute:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用`input`、`select`、`textarea`或`button`元素只需绑定到其`disabled`属性即可：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `input` and the `button` elements will both be disabled when `isSending`
    is `true`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当`isSending`为`true`时，`input`和`button`元素都将被禁用。
- en: Making an element read-only
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置元素只读
- en: 'Similarly, making an `input` or `textarea` element read-only is just a matter
    of binding to its `readonly` attribute:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使`input`或`textarea`元素只读只需将其`readonly`属性绑定即可：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the `input` will be read-only when `canEdit` is `false`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，当`canEdit`为`false`时，`input`将变为只读。
- en: Adding forms to our application
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的应用程序添加表单
- en: Now that we know how to work with user input elements, we can add forms to create
    and edit contacts in our contact management application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何处理用户输入元素，我们可以在我们的联系人管理应用程序中添加表单以创建和编辑联系人。
- en: Adding new routes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新路由
- en: 'We need to add three new routes: one to create new contacts, another to edit
    an existing contact, and the last one to upload the photo of a contact. Let''s
    add them in our root component:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加三个新路由：一个用于创建新联系人，另一个用于编辑现有联系人，最后一个用于上传联系人的照片。让我们在根组件中添加它们：
- en: 'The `src/app.js` file will be as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`文件将如下所示：'
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The three new routes are highlighted in the preceding code snippet.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，三个新路由被突出显示。
- en: The positioning is important here. The `contact-creation` route is placed before
    the `contact-details` route because of their respective `route` property. When
    trying to find a matching route upon a URL change, the router drills down through the
    route definitions in the order they were defined in. Since the pattern for `contact-details`
    matches any path starting with `contacts/` and followed by a second part interpreted
    as a parameter, the path `contacts/new` matches this pattern, so the `contact-creation`
    route would be unreachable if it was defined later, and the `contact-details`
    route would be reached instead with an `id` parameter equal to `new`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定位很重要。`contact-creation`路径在`contact-details`路径之前，这是因为它们的`route`属性。在尝试查找URL更改时的匹配路径时，路由器会按照它们被定义的顺序深入路由定义。由于`contact-details`的模式匹配任何以`contacts/`开头，后跟第二个部分作为参数的解释，因此路径`contacts/new`符合此模式，所以如果`contact-creation`路径定义在后面，它将无法到达，而`contact-details`路径将使用等于`new`的`id`参数到达。
- en: A better alternative to relying on the order of the routes would be to change
    the patterns so there is no possible collision. For example, we could change the
    pattern of `contact-details` to something like `contacts/:id/details`. In such
    a case, the order of the routes would not matter anymore.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于路由顺序的更好替代方法是将模式更改，以避免可能的冲突。例如，我们可以将`contact-details`的模式更改为类似于`contacts/:id/details`。在这种情况下，路由的顺序将不再重要。
- en: You may have noticed that two of the new routes have the same `moduleId`. This
    is because we will use the same component for both creating a new contact and
    editing an existing one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到两个新路径具有相同的`moduleId`。这是因为我们将为创建新联系人和编辑现有联系人使用相同的组件。
- en: Adding links to the new routes
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新路径的链接
- en: 'The next step will be to add links leading to the routes we just added. We
    will first add a link to the `contact-creation` route in the `contact-list` component:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是添加刚刚添加的路由的链接。我们首先在`contact-list`组件中添加一个到`contact-creation`路径的链接：
- en: '`src/contact-list.html`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.html`'
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we add an `a` element and leverage the `route-href` attribute to render
    the URL for the `contact-creation` route.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`a`元素，并利用`route-href`属性渲染`contact-creation`路径的URL。
- en: 'We also need to add links to the `contact-photo` and the `contact-edition`
    routes. We will do this in the `contact-details` component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加到`contact-photo`和`contact-edition`路径的链接。我们将在`contact-details`组件中完成这个任务：
- en: '`src/contact-details.html`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-details.html`'
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we first refactor the template displaying `fullName` and `company` if the
    contact is a person, by adding an enclosing `div` and moving the `col-sm-10` CSS
    class from the titles to this `div`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先重构显示`fullName`和`company`（如果联系人是人）的模板，通过添加一个外部的`div`并将`col-sm-10`CSS类从标题移动到这个`div`。
- en: Next, we wrap the `img` element displaying the contact's photo inside an anchor
    navigating to the `contact-photo` route, using the contact's `id` as a parameter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将显示联系人性照的`img`元素包裹在一个导航到`contact-photo`路径的锚点中，使用联系人的`id`作为参数。
- en: Lastly, we add another anchor leading to the `contact-edition` route, using
    the contact's `id` as a parameter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加另一个指向`contact-edition`路径的锚点，使用联系人的`id`作为参数。
- en: Updating models
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新模型
- en: In order to reuse code, we will stick with the `Contact` class and use it in
    our form component. We will also create classes for phone numbers, email addresses,
    addresses, and social profiles, so our `contact-edition` component won't have
    to know the details of how to create empty instances of those objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重用代码，我们将坚持使用`Contact`类，并在我们的表单组件中使用它。我们还将为电话号码、电子邮件地址、地址和社会资料创建类，这样我们的`contact-edition`组件就无需知道创建这些对象空实例的详细信息。
- en: We need to add the ability to create empty instances of our models, and have
    all their properties initialized to proper default values. As such, we will add
    default values for all properties on our model classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加创建我们模型空实例的能力，并将其所有属性初始化为适当的默认值。因此，我们将为我们的模型类添加所有属性的默认值。
- en: Lastly, we need to update the `Contact``fromObject` factory method so all list
    items are properly mapped to instances of our model classes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新`Contact`的`fromObject`工厂方法，以便所有列表项都正确映射到我们的模型类实例。
- en: '`src/models.js`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/models.js`'
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we first add classes for a `PhoneNumber`, an `EmailAddress`, an `Address`,
    and a `SocialProfile`. Each of those classes has a static `fromObject` factory
    method and its properties are properly initialized with default values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先添加了`PhoneNumber`、`EmailAddress`、`Address`和`SocialProfile`类的类。每个类都有一个静态的`fromObject`工厂方法，其属性都使用默认值正确初始化。
- en: Next, we add the properties of a `Contact`, initialized with default values,
    and change its `fromObject` factory method so the list items are properly mapped
    to their respective classes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了一个`Contact`对象属性，其初始值为默认值，并更改了其`fromObject`工厂方法，以便列表项能够正确映射到它们相应的类中。
- en: Creating the form component
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表单组件
- en: Now we can create our new `contact-edition` component. As mentioned earlier,
    this component will be used for both creating and editing. It will be able to
    detect if it is used to create a new contact or to edit an existing one by checking
    whether it receives an `id` parameter in its `activate` callback method. Indeed,
    the pattern for the `contact-creation` route defines no parameter, so when our
    form component gets activated by this route, it won't receive any `id` parameter.
    On the other hand, since the pattern for the `contact-edition` route does define
    an `id` parameter, our form component will receive the parameter when activated
    by this route.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们新的`contact-edition`组件了。如早前所提，这个组件将用于创建和编辑。它能够通过检查在其`activate`回调方法中是否接收了一个`id`参数来检测它是用于创建新的联系人还是编辑现有的联系人。确实，`contact-creation`路由的模式定义了无参数，所以当我们的表单组件通过这个路由被激活时，它不会接收任何`id`参数。另一方面，由于`contact-edition`路由的模式确实定义了一个`id`参数，所以当我们的表单组件通过这个路由被激活时，它会接收到这个参数。
- en: We can do this because, in the scope of our contacts management application,
    the creation and editing processes are almost identical. However, in many cases,
    it might be a better design to have separate components for creating and editing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做，因为在我们联系管理应用程序的范围内，创建和编辑过程几乎是一致的。然而，在许多情况下，最好是为创建和编辑分别设计单独的组件。
- en: Activating the view-model
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活视图模型
- en: 'Let''s first start with the view-model and the `activate` callback method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从视图模型和`activate`回调方法开始：
- en: '`src/contact-edition.js`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.js`'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we start by injecting an instance of the `ContactGateway` class into our
    view-model. Then, in the `activate` callback method, we first define an `isNew`
    property, based on the existence of an `id` parameter. This property will be used
    by our component to know if it is being used to create a new contact or to edit
    an existing one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先向我们的视图模型注入`ContactGateway`类的实例。然后，在`activate`回调方法中，我们首先定义了一个`isNew`属性，该属性基于是否存在`id`参数。这个属性将用于我们的组件，使其知道它是被用来创建一个新的联系人还是编辑一个现有的联系人。
- en: Next, based on this `isNew` property, we initialize the component. If we are
    creating a new contact, then we simply create a `contact` property and assign
    to it a new, empty `Contact` instance; otherwise, we use the `ContactGateway`
    to retrieve the proper contact based on the `id` parameter and, when the `Promise`
    resolves, assign the `Contact` instance to the `contact` property and set the
    document title to the contact's `fullName` property.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，基于这个`isNew`属性，我们初始化组件。如果我们正在创建一个新的联系人，那么我们只需创建一个`contact`属性并将其分配给一个新的、空的`Contact`实例；否则，我们使用`ContactGateway`根据`id`参数检索适当的联系人，当`Promise`解决时，将`Contact`实例分配给`contact`属性，并将文档标题设置为联系人的`fullName`属性。
- en: Once the activation cycle completes, the view-model has a `contact` property
    properly initialized to a `Contact` object, and an `isNew` property indicating
    if the contact is a new or existing one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦激活周期完成，视图模型将有一个适当初始化为`Contact`对象的`contact`属性和一个指示联系人是新的还是现有的`isNew`属性。
- en: Building the form layout
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建表单布局
- en: Next, let's build the template to display the form. This template being pretty
    big, I will break it down in parts, so you can build it gradually and test it
    at each step if you want.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建一个用于显示表单的模板。由于这个模板相当大，我将把它分成几部分，这样你就可以逐步构建它并在每个步骤进行测试（如果需要的话）。
- en: 'The template consists of a header, followed by a `form` element, which will
    enclose the rest of the template:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 模板由一个头部组成，后面是一个`form`元素，它将包含模板的其余部分：
- en: '`src/contact-edition.html`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the header, we use the `isNew` property to display either a static title
    telling the user he is creating a new contact or a dynamic title displaying the
    `id` of the contact being edited.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部，我们使用`isNew`属性来显示是告诉用户他正在创建一个新的联系人还是显示正在编辑的联系人`id`的动态标题。
- en: Editing scalar properties
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑标量属性
- en: 'Next, we will add blocks, containing input elements, to edit the `firstName`,
    `lastName`, `company`, `birthday`, and `note` of the contact, inside the `form`
    element defined in the previous code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向`form`元素中添加块，其中包含输入元素，以编辑联系人的`firstName`、`lastName`、`company`、`birthday`和`note`，如前一个代码片段中定义的那样：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we simply define a `form-group` for each property to edit. The first three
    properties are each bound to a `text input` element. Additionally, the `birthday`
    property is bound to a `date` input, making it easier to edit a date--for browsers
    supporting it, of course--and the `note` property is bound to a `textarea` element.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅为每个属性定义一个`form-group`以进行编辑。前三个属性各自绑定到一个`text input`元素。此外，`birthday`属性绑定到一个`date`输入，使其更容易编辑日期——当然，仅限支持它的浏览器，而`note`属性则绑定到一个`textarea`元素。
- en: Editing phone numbers
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑电话号码
- en: After this, we need to add editors for lists. Since the data contained in each
    list is not very complex, we will render inline editors, so the user can edit
    any field of any item directly, in the minimum number of clicks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要为列表添加编辑器。由于每个列表中包含的数据并不复杂，我们将使用内联编辑器，这样用户就可以在最少的点击次数内直接编辑任何项目的任何字段。
- en: We will discuss more complicated editing models, using dialogs, later in this
    chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论更复杂的编辑模型，使用对话框。
- en: 'Let''s start with the phone numbers:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从电话号码开始：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This phone number list editor can be broken down into parts, the most important
    of which are highlighted. First, a `form-group` is repeated for each `phoneNumber`
    in the contact's `phoneNumbers` array.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电话号码列表编辑器可以分解为几个部分，其中最重要的是突出显示的。首先，为联系的`phoneNumbers`数组中的每个`phoneNumber`重复一个`form-group`。
- en: For each `phoneNumber`, we define a `select` element, whose `value` is bound
    to the `type` property of `phoneNumber`, along with a `tel input`, whose `value`
    is bound to the `number` property of `phoneNumber`. Additionally, we define a
    `button` whose `click` event splices the phone number out of the `phoneNumbers`
    array of `contact`, using the current `$index`, which, as you may remember from
    the previous chapter, is added to the binding context by the `repeat` attribute.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`phoneNumber`，我们定义一个`select`元素，其`value`绑定到`phoneNumber`的`type`属性，以及一个`tel`输入，其`value`绑定到`phoneNumber`的`number`属性。此外，我们定义了一个`button`，当点击时，使用当前的`$index`（正如您可能记得的前一章中提到的，这是通过`repeat`属性添加到绑定上下文的），从`contact`的`phoneNumbers`数组中拼接出电话号码。
- en: Lastly, after the list of phone numbers, we define a `button` whose `click`
    event calls the `addPhoneNumber` method in `contact`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在电话号码列表之后，我们定义了一个`button`，其`click`事件调用`contact`中的`addPhoneNumber`方法。
- en: Adding the missing method
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加缺失的方法
- en: 'One of the buttons we added in the previous template calls a method that is
    not defined yet. Let''s add this method to the `Contact` class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个模板中添加的按钮之一调用了一个尚未定义的方法。让我们把这个方法添加到`Contact`类中：
- en: '`src/models.js`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/models.js`'
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first method in this code snippet is used to add an empty phone number to
    the list, by simply pushing a new `PhoneNumber` instance in the `phoneNumbers`
    array.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段中的第一个方法用于向列表中添加一个空电话号码，简单地在`phoneNumbers`数组中推入一个新的`PhoneNumber`实例。
- en: Editing the other lists
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑其他列表
- en: The templates for the other lists, email addresses, addresses, and social profiles,
    are pretty similar. Only the fields being edited change, but the main concepts--repeating
    form groups, having a remove button for each item and an add button at the end
    of the list--are the same.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其他列表的模板，如电子邮件地址、地址和社会资料，都非常相似。只有正在编辑的字段会改变，但主要概念——重复的表单组、每个条目都有一个删除按钮和一个在列表末尾的添加按钮——是相同的。
- en: 'Let''s start with `emailAddresses`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`emailAddresses`开始：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This template is very similar to the phone numbers' template. The main difference
    is that the available types are not exactly the same, and the `input` `type` is
    `email`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板与电话号码的模板非常相似。主要区别在于可用的类型并不完全相同，而且`input`的`type`是`email`。
- en: 'As you can imagine, the editor for addresses will be a little bigger:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，地址的编辑器会更大一些：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the left part contains six different inputs, allowing us to edit the various
    text properties that an address has.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，左侧包含六个不同的输入，允许我们编辑地址的各种文本属性。
- en: 'At this point, you probably have some idea what the template for the social
    profiles looks like:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，您可能已经对社交资料的模板有一个大致的了解：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Of course, the methods to add items for each list need to be added to the `Contact`
    class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每个列表添加项目的方法都需要添加到`Contact`类中：
- en: '`src/models.js`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/models.js`'
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, those methods are almost identical to the ones we wrote previously
    for the phone numbers. Additionally, the template snippets for each list are also
    mostly identical to each other. All this redundancy screams for refactoring. We
    will see in [Chapter 5](ch05.html "Chapter 5. Making Reusable Components"), *Making
    Reusable Components*, how we can extract common behaviors and template snippets
    into a component, which we will reuse to manage each list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些方法与我们之前为电话号码编写的那些几乎完全相同。此外，每个列表的模板片段也基本上彼此相同。所有这种冗余都呼吁进行重构。我们将在[第5章](ch05.html
    "第5章. 可复用的组件")，*制作可复用的组件*中看到，如何将常见行为和模板片段提取到一个组件中，我们将重新使用它来管理每个列表。
- en: Saving and canceling
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和取消
- en: 'The last thing missing for our form to be (at least visually) complete is a
    Save and a Cancel button at the end of the enclosing `form` element:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们表单（至少在视觉上）完整的最后一件缺失的事情是在包含`form`元素的末尾添加一个保存和取消按钮：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we bind a call to the `save` method to the `form` element's `submit`
    event, then we add a last `form-group` containing a `submit` button named `Save.`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将一个对`save`方法的调用绑定到`form`元素的`submit`事件，然后我们添加了一个包含一个名为`Save`的`submit`按钮的最后一个`form-group`。
- en: 'Next, we add two `Cancel` links: one displayed when creating a new contact
    to navigate back to the contacts list, and another displayed when editing an existing
    contact to navigate back to the contact''s details.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了两个`Cancel`链接：一个在创建新联系人时显示，用于导航回到联系人列表；另一个在编辑现有联系人时显示，用于导航回到联系人的详细信息。
- en: 'We also need to add the `save` method to the view-model. This method will ultimately
    delegate to the `ContactGateway` but, in order to test that everything we''ve
    done upto this point, works, let''s just write a dummy version of the method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将`save`方法添加到视图模型中。这个方法最终将委派给`ContactGateway`，但为了测试我们到目前为止所做的一切是否工作，让我们只写一个方法版本：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point, you should be able to run the application and try to create or
    edit a contact. When clicking the **Save** button, you should see an alert displaying
    the contact, serialized as JSON.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，你应该能够运行应用程序并尝试创建或编辑一个联系人。点击**保存**按钮时，你应该会看到一个显示联系人的警报，该联系人作为JSON序列化格式。
- en: Sending data with fetch
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fetch发送数据
- en: 'We can now add methods to create and update contacts to the `ContactGateway`
    class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向`ContactGateway`类添加创建和更新联系人的方法：
- en: '`src/contact-gateway.js`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-gateway.js`'
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first thing to do is `import` the `json` function from `fetch-client`. This
    function takes any JS value as an argument and returns a `Blob` object containing
    the received parameter serialized as JSON.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的第一件事是`import`从`fetch-client`中`json`函数。这个函数接受任何JS值作为参数，并返回一个包含接收参数序列化为JSON的`Blob`对象。
- en: Next, we add a `create` method, which takes a `contact` as a parameter and calls
    the HTTP client's `fetch` method, passing to it the relative URL to call, followed
    by a configuration object. This object contains properties that will be assigned
    to the underlying `Request` object. Here, we specify a `method` property, telling
    the client to perform a `POST` request, and we indicate that the `body` of the
    request will be the `contact` serialized as JSON. Finally, the `fetch` method
    returns a `Promise`, which is returned by our new `create` method, so callers
    can react when the request completes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了一个`create`方法，它接受一个`contact`作为参数，并调用HTTP客户端的`fetch`方法，传递要调用的相对URL，然后是一个配置对象。这个对象包含将分配给底层`Request`对象的属性。在这里，我们指定一个`method`属性，告诉客户端执行一个`POST`请求，我们指示请求的`body`将是序列化为JSON的`contact`。最后，`fetch`方法返回一个`Promise`，这是我们新`create`方法返回的，所以调用者可以在请求完成后做出反应。
- en: 'The `update` method is very similar. The first difference is the parameters:
    the contact''s `id` is first expected, followed by the `contact` object itself.
    Secondly, the `fetch` call is slightly different; it sends a request to a different
    URL, using the `PUT` method, but its body is the same.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法非常相似。第一个区别是参数：首先期望联系人的`id`，然后是`contact`对象本身。其次，`fetch`调用略有不同；它发送一个到不同URL的请求，使用`PUT`方法，但其主体相同。'
- en: The `body` of a Fetch `Request` is expected to be either a `Blob`, a `BufferSource`,
    a `FormData`, an `URLSearchParams`, or an `USVString` object. Documentation about
    this can be found on the Mozilla Developer Network, at [https://developer.mozilla.org/en-US/docs/Web/API/Request/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Fetch`Request`的`body`预期是一个`Blob`、一个`BufferSource`、一个`FormData`、一个`URLSearchParams`或一个`USVString`对象。关于这方面的文档可以在Mozilla开发者网络上找到，网址为[https://developer.mozilla.org/en-US/docs/Web/API/Request/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request)。
- en: 'In order to test that our new methods work, let''s replace our dummy `save`
    method in the view-model of the `contact-edition` component with the real deal:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们新方法是否有效，让我们将`contact-edition`组件的视图模型中的模拟`save`方法替换为真实的方法：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we first import the `Router` and inject an instance of it in the view-model.
    Next, we change the body of the `save` method: if the component is creating a
    new contact, we first call the `create` method from `ContactGateway`, passing
    the `contact` object to it, then navigate back to the `contacts` route when the
    `Promise` resolves; otherwise, when the component is editing an existing contact,
    we first call the `update` method of `ContactGateway`, passing the contact''s
    `id` and the `contact` object to it, then navigate back to the contact''s details
    when the `Promise` resolves.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先导入`Router`，并在视图模型中注入它的一个实例。接下来，我们改变`save`方法的主体：如果组件正在创建一个新的联系人，我们首先调用`ContactGateway`的`create`方法，将`contact`对象传递给它，然后在`Promise`解决时返回至`contacts`路由；否则，当组件正在编辑一个现有的联系人时，我们首先调用`ContactGateway`的`update`方法，将联系人的`id`和`contact`对象传递给它，然后在`Promise`解决时返回至该联系人的详情路由。
- en: At this point, you should be able to create or update a contact. However, some
    create or update requests may return responses with a 400 bad Request status.
    Don't be alarmed; since the HTTP endpoint performs some validation, and our form
    does not at this point, this is expected to happen-if you leave some field empty,
    for example. We will add validation to our form later in this chapter, which will
    prevent this class of error.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该能够创建或更新一个联系人。然而，一些创建或更新的请求可能会返回状态码为400的响应，表示“坏的请求”。不必惊慌；因为HTTP端点会执行一些验证，而我们的表单目前不会，所以这种情况是预料之中的，例如，如果你留下了一些字段是空的。我们将在本章后面为我们的表单添加验证，这将防止这类错误的发生。
- en: Uploading a contact's photo
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传联系人的照片
- en: Now that we can create and edit a contact, let's add a component to upload its
    photo. This component will be named `contact-photo`, and will be activated by
    the route with the same name, which we already added earlier in this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们能够创建和编辑联系人，现在让我们添加一个组件来上传其照片。这个组件将被命名为`contact-photo`，并通过我们已经在本章早些时候添加的具有相同名称的路由来激活。
- en: This component will use a `file input` element to let the user select an image
    file on his file system, and will leverage the HTML5 File API along with the Fetch
    client to send a PUT request containing the selected image file to our HTTP end-point.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将使用一个`file input`元素让用户从他的文件系统中选择一个图片文件，并将利用HTML5文件API以及Fetch客户端将选定的图片文件发送到我们的HTTP端点。
- en: Building the template
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建模板
- en: 'The template for this component simply reuses a couple of the concepts we already
    covered:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的模板简单地重用了我们已经在前面讲解过的几个概念：
- en: '`src/contact-photo.html`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-photo.html`'
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we first display the `fullName` of the contact as the page title. Then,
    inside a `form` element whose `submit` event triggers a `save` method, we add
    a `file input` and buttons to **Save** or **Cancel** the photo upload. The `file
    input` has an `accept` attribute, forcing the browser's file selection dialog
    to display only image files, and its `files` attribute is bound to the `photo`
    property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将联系人的`fullName`作为页面标题显示出来。然后，在一个`form`元素中，其`submit`事件会触发一个`save`方法，我们添加了一个`file
    input`和两个按钮，用于**保存**或**取消**上传照片。`file input`有一个`accept`属性，迫使浏览器的文件选择对话框只显示图片文件，并且它的`files`属性被绑定到`photo`属性。
- en: Creating the view-model
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建视图模型
- en: 'The view-model looks a lot like the `contact-edition` view-model, at least
    when comparing imports, constructors, and `activate` methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型与`contact-edition`视图模型非常相似，至少在比较导入、构造函数和`activate`方法时是这样的：
- en: '`src/contact-photo.js`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-photo.js`'
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This view-model expects both an instance of `ContactGateway` and a `Router`
    instance to be injected in its constructor. In its `activate` method, it then
    loads a `Contact` instance using its `id` parameter, and initializes the document
    title using the `fullName` for the `contact`. This is all pretty similar to the
    `contact-edition` view-model.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图模型期望在其构造函数中注入`ContactGateway`的一个实例和`Router`的一个实例。在其`activate`方法中，它然后使用其`id`参数加载一个`Contact`实例，并使用`contact`的`fullName`初始化文档标题。这与`contact-edition`视图模型非常相似。
- en: The `save` method is a little different however. It first checks if a file has
    been selected; if not, it does nothing for now. Otherwise, it calls the `updatePhoto`
    method of the `ContactGateway` method, passing the contact's `id` and the selected
    file to it, and navigates back to the contact's details when the `Promise` resolves.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`方法有一点不同。它首先检查是否已经选择了文件；如果没有，现在什么也不做。否则，它调用`ContactGateway`的`updatePhoto`方法，将联系人的`id`和选定的文件传递给它，并在`Promise`解决时返回到联系人的详细信息。'
- en: Uploading files with fetch
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用fetch上传文件
- en: 'The last step in getting our photo upload feature working is the `uploadPhoto`
    method in the `ContactGateway` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的照片上传功能正常工作的最后一步是在`ContactGateway`类中的`uploadPhoto`方法：
- en: '`src/contact-gateway.js`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-gateway.js`'
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our HTTP backend''s `contacts/{id}/photo` endpoint expects a PUT request, with
    the proper `Content-Type` header and the image binary as its body. This is exactly
    what the call to `fetch` does here: it uses the `file` argument, which is expected
    to be an instance of the `File` class, and sets the `Content-Type` header using
    its `type` property, then sends the `file` itself as the request body.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们HTTP后端的`contacts/{id}/photo`端点期望一个PUT请求，带有正确的`Content-Type`头和图像二进制作为其主体。这正是这里`fetch`调用的作用：它使用`file`参数，这被期望是一个`File`类的实例，并使用它的`type`属性设置`Content-Type`头，然后将`file`本身作为请求体发送。
- en: As mentioned earlier, the `File` class is part of the HTML5 File API. The Mozilla
    Developer Network has extensive documentation about this API. Details about the
    `File` class can be found at [https://developer.mozilla.org/en-US/docs/Web/API/File](https://developer.mozilla.org/en-US/docs/Web/API/File).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如早先所述，`File`类是HTML5文件API的一部分。Mozilla开发者网络提供了关于这个API的详尽文档。关于`File`类的细节可以在[https://developer.mozilla.org/en-US/docs/Web/API/File](https://developer.mozilla.org/en-US/docs/Web/API/File)找到。
- en: As usual, the `updatePhoto` method returns the `Promise` resolved by the HTTP
    request, so the caller can act when the operation is completed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，`updatePhoto`方法返回由HTTP请求解决的`Promise`，所以调用者可以在操作完成时采取行动。
- en: At this point, you should be able to run the application and update the photo
    of a contact by uploading a new image file.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，你应该能够运行应用程序并通过上传新图像文件来更新联系人的照片。
- en: Deleting a contact
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除联系人
- en: 'At this point, our application allows us to create, read, and update contacts.
    Obviously, one of the letters from **create, read, update, delete** (**CRUD**)
    is missing here: we can''t delete a contact yet. Let''s quickly implement this
    feature.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们的应用程序允许我们创建、读取和更新联系人。显然，**创建、读取、更新、删除**（**CRUD**）这四个字母中有一个缺失了：我们还不能删除一个联系人。让我们快速实现这个功能。
- en: 'First, let''s add a **Delete** button to the contact''s `details` component:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在联系人的`details`组件中添加一个**删除**按钮：
- en: '`src/contact-details.html`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-details.html`'
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The new **Delete** button will call the `tryDelete` method when clicked:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 新的**删除**按钮将在点击时调用`tryDelete`方法：
- en: '`src/contact-details.js`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-details.js`'
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `tryDelete` method first asks the user to `confirm` deletion, then calls
    the gateway's `delete` method with the contact's `id`. When the returned `Promise`
    resolves, it navigates back to the contacts list.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`tryDelete`方法首先要求用户进行**确认**删除，然后使用联系人的`id`调用网关的`delete`方法。当返回的`Promise`解决时，它返回到联系人列表。'
- en: 'Lastly, the `ContactGateway` class'' `delete` method just performs a Fetch
    call to the backend''s proper path, using the `DELETE` HTTP method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ContactGateway`类的`delete`方法只是执行一个到后端适当路径的Fetch调用，使用`DELETE`HTTP方法：
- en: '`src/contact-gateway.js`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-gateway.js`'
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At this point, if you click on the **Delete** button for a contact and approve
    the confirmation dialog, you should be redirected to the contacts list and the
    contact should be gone.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，如果你点击一个联系人的**删除**按钮并批准确认对话框，你应该会被重定向到联系人列表，并且联系人应该消失了。
- en: Validation
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: If you try to save a contact with either an invalid birthday, or an empty phone
    number, address, email, or social profile username, while your browser's debug
    console is open, you will see that the HTTP endpoint rejects the request with
    a 400 Bad Request response. This is because the backend performs some validation
    on the contact being created or updated.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试保存一个生日无效、电话号码为空、地址、电子邮件或社交资料用户名为空的联系人，而你的浏览器的调试控制台是打开的，你会看到HTTP端点用400 Bad
    Request响应拒绝这个请求。这是因为后端在对创建或更新的联系人执行一些验证。
- en: Having a remote service performing some form of validation is pretty common;
    the opposite is actually considered bad architecture, as a remote service should
    not trust its clients for valid data. However, in order to provide a better end
    user experience, it is common to see validation also performed by client applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个执行某种验证的远程服务是很常见的；相反的，实际上被认为是糟糕的架构，因为远程服务不应该信任其客户端的有效数据。然而，为了提供更佳的用户体验，通常也会看到客户端应用程序也执行验证。
- en: Aurelia offers the `aurelia-validation` library, which defines an interface
    for validation providers, along with various mechanisms to plug validation inside
    components. It also offers a default implementation of this interface, providing
    a simple yet powerful validation mechanism.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia提供了`aurelia-validation`库，该库为验证提供者定义了一个接口，以及将验证插入组件的各种机制。它还提供了这个接口的默认实现，提供了一个简单而强大的验证机制。
- en: Let's see how we can use those libraries to validate to our contact form.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这些库来验证我们的联系人表单。
- en: This section is but an overview of the most common features offered by `aurelia-validation`.
    In fact, this library is much more flexible and powerful than what is depicted
    here, so I invite you to dig it further after reading this book.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节只是对`aurelia-validation`提供的最常见特性的概述。实际上，这个库比这里描述的要灵活得多，功能也更强大，所以我在阅读这本书后邀请你进一步挖掘它。
- en: Installing the library
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装库
- en: 'To install the library, you simply have to run the following command in the
    project''s directory:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这个库，你只需要在项目的目录下运行以下命令：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we need to make this library available in the application''s bundles.
    In `aurelia_project/aurelia.json`, under `build`, then `bundles`, in the `dependencies`
    array of the bundle named `vendor-bundle.js`, add the following entry:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使这个库在应用程序的包中可用。在`aurelia_project/aurelia.json`中，在`build`下的`bundles`中，在名为`vendor-bundle.js`的包的`dependencies`数组中，添加以下条目：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This configuration entry will tell Aurelia's bundler to include the newly installed
    library in the vendor bundle.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置项将告诉Aurelia的打包器将新安装的库包含在供应商包中。
- en: Configuration
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: The `aurelia-validation` library needs a little configuration before it can
    be used. Additionally, being an Aurelia plugin, it needs to be loaded when our
    application starts.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-validation`库在使用前需要一些配置。此外，作为一个Aurelia插件，它需要在我们的应用程序启动时加载。'
- en: We could do all of this inside our main `configure` function. However, this
    situation is a really good candidate for an Aurelia feature. If you remember,
    features are similar to plugins, except they are defined inside the application
    itself. By introducing a `validation` feature, we can isolate configuring the
    validation, and this would give us a central location where we can put additional
    services and custom validation rules.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们主要的`configure`函数里完成这一切。然而，这种情况真的是一个很好的Aurelia特性的候选。如果你记得的话，特性类似于插件，只不过它们是在应用程序本身内定义的。通过引入一个`validation`特性，我们可以隔离验证的配置，这会给我们一个可以放置额外服务和自定义验证规则的中央位置。
- en: 'Let''s start by creating our `validation` feature:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建我们的`validation`特性：
- en: '`src/validation/index.js`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/index.js`'
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `configure` function of our new feature simply loads the `aurelia-validation`
    plugin.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新特性的`configure`函数只是加载了`aurelia-validation`插件。
- en: 'Next, we need to load this feature inside our main `configure` function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们主要的`configure`函数中加载这个特性：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we simply chain an additional call to the `feature` method of the bootstrapping
    fluent API to load our `validation` feature.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是链接了引导式API的`feature`方法的额外调用，以加载我们的`validation`特性。
- en: Validating the contact form
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证联系人表单
- en: Now that everything is correctly configured, let's add validation to our `contact-edition`
    form.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 既然一切配置都正确，那就让我们在我们的`contact-edition`表单中添加验证吧。
- en: Setting up the template
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置模板
- en: 'In order to tell the validation mechanism what needs to be validated, all the
    two-way bindings used to retrieve user input that we want validated have to be
    decorated with the `validate` binding behavior, which is also provided by `aurelia-validation`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉验证机制需要验证什么，所有用于获取待验证用户输入的双向绑定都必须用`validate`绑定行为装饰，这由`aurelia-validation`提供：
- en: '`src/contact-edition.html`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we add the `validate` binding behavior to every two-way bindings. The
    snippet doesn't depict all bindings of the `contact-edition` form; I'll leave
    it as an exercise to the reader to add `validate` to the bindings on the `value`
    attributes of all `input`, `textarea`, and `select` elements in the template.
    This chapter's sample application from the book's assets can be looked up as a
    reference.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在每个双向绑定中添加了`validate`绑定行为。代码片段没有展示`contact-edition`表单的所有绑定；我留给读者一个练习，即在模板中所有`input`、`textarea`和`select`元素的`value`属性上添加`validate`。本书的示例应用程序可以作为参考。
- en: The `validate` binding behavior has two tasks. It first registers the binding
    instruction to the `ValidationController`, which orchestrates validation for a
    given component, so the validation mechanism knows about the property bound by
    the instruction and can validate it when needed. Secondly, it can hook into the
    binding instruction, so the property bound to the element can be validated on
    the spot when the value of the element targeted by the binding instruction changes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate`绑定行为有两个任务。首先，它将绑定指令注册到`ValidationController`，该控制器为给定组件组织验证，所以验证机制知道指令绑定的属性，并在需要时对其进行验证。其次，它可以连接到绑定指令，所以绑定到元素的属性可以在元素的目标值变化时立即验证。'
- en: Using ValidationController
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ValidationController
- en: '`ValidationController` acts as a conductor in the validation process. It keeps
    track of a set of bindings that needs to be validated, exposes methods to manually
    trigger validation, and keeps records of current validation errors.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationController`在验证过程中扮演着指挥者的角色。它跟踪一组需要验证的绑定，提供方法手动触发验证，并记录当前的验证错误。'
- en: 'In order to leverage `ValidationController`, we must first inject an instance
    in our component:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用`ValidationController`，我们首先必须在组件中注入一个实例：
- en: '`src/contact-edition.js`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.js`'
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we inject a brand new instance of `ValidationController` into our view-model.
    The use of the `NewInstance` resolver is important, because by default the DI
    container considers all services as application singletons, and we really want
    a distinct instance for each component, so they are considered in isolation when
    being validated.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向视图模型中注入了一个全新的`ValidationController`实例。使用`NewInstance`解析器很重要，因为默认情况下，DI容器认为所有服务都是应用程序单例，而我们确实希望每个组件都有一个独特的实例，以便在验证时它们可以被孤立考虑。
- en: 'Next, we simply need to make sure the form is valid before saving any contact:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要确保在保存任何联系人之前表单是有效的：
- en: '`src/contact-edition.js`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.js`'
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we encapsulate the code calling the gateway's `create` or `update` methods
    so it is executed after validation (completes and only if there are no errors).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将调用网关的`create`或`update`方法的代码封装起来，以便在验证（完成且没有错误时）执行：
- en: The `validate` method returns a `Promise`, which is resolved with an array containing
    the validation errors. This means that validation rules can be asynchronous. For
    example, a custom rule could perform an HTTP call to a backend to check for data
    unicity or to perform some further data validation, and the `validate` method's
    resulting `Promise` would be resolved when the HTTP call completes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate`方法返回一个`Promise`，该`Promise`用验证错误数组解决。这意味着验证规则可以是异步的。例如，自定义规则可以执行HTTP调用到后端以检查数据唯一性或执行进一步的数据验证，`validate`方法的返回`Promise`将在HTTP调用完成时解决。'
- en: If the `Promise` of an asynchronous rule gets rejected, if the HTTP call fails,
    for example, the `Promise` returned by `validate` will also be rejected, so make
    sure you handle rejection at this level when using such asynchronous, remote validation
    rules, so the user knows what happens.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异步规则的`Promise`被拒绝，例如HTTP调用失败，`validate`返回的`Promise`也将被拒绝，所以当使用此类异步、远程验证规则时，确保在这个层次上处理拒绝，这样用户就知道发生了什么。
- en: Adding ValidationRules
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加验证规则
- en: 'At this point, validation is ready to roll but won''t do anything, because
    we still haven''t defined any validation rules on our models. Let''s start with
    the `Contact` class:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，验证已经准备就绪，但不会做任何事情，因为我们还没有在模型上定义任何验证规则。让我们从`Contact`类开始：
- en: '`src/models.js`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/models.js`'
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, we use `aurelia-validation`''s fluent API to add validation rules to
    some properties of `Contact`: the `firstName`, `lastName` and `company` properties
    cannot be longer than 100 characters, and the `note` property cannot be longer
    than 2,000 characters.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`aurelia-validation`的流式API，为`Contact`的某些属性添加验证规则：`firstName`、`lastName`和`company`属性的长度不能超过100个字符，`note`属性的长度不能超过2000个字符。
- en: Additionally, we use the `satisfies` method to define an inline, custom rule
    for the `birthday` property. This rule ensures that `birthday` will be valid only
    if it is an empty value or a string that can be parsed into a valid `Date` object.
    We also use the `withMessage` method to specify the template of the error message
    that should be displayed when our custom rule is violated.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`satisfies`方法为`birthday`属性定义内联的自定义规则。这个规则确保`birthday`只有在它是空值或可以解析为有效`Date`对象的字符串时才是有效的。我们还使用`withMessage`方法指定当我们的自定义规则被违反时应显示的错误消息模板。
- en: The message template uses the same string interpolation syntax as Aurelia's
    templating engine, and can use a context variable named `$displayName`, which
    contains the display name of the property being validated.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 消息模板使用与Aurelia的模板引擎相同的字符串插值语法，并且可以使用一个名为`$displayName`的上下文变量，它包含正在验证的属性的显示名称。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Custom validation rules should always accept empty values. This is to maintain
    separation of concerns; the `required` rule already takes care of rejecting empty
    values, so your custom rule should only focus on its own, specific validation
    logic. This way, developers can use your custom rule with or without `required`,
    depending on what they want to do.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义验证规则应始终接受空值。这是为了保持关注点的分离；`required`规则已经负责拒绝空值，所以你的自定义规则应只关注其自己的特定验证逻辑。这样，开发者可以根据他们想做什么，选择性地使用你的自定义规则，或不与`required`一起使用。
- en: Lastly, the `on` method attaches the set of rules just built to the `Contact`
    instance's metadata. This way, when validating properties of a `Contact` object,
    the validation process can retrieve the validation rules that should apply.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`on`方法将刚刚构建的规则集附加到`Contact`实例的元数据中。这样，当验证`Contact`对象的属性时，验证过程可以检索应适用的验证规则。
- en: 'We also need to add validation rules to all the classes representing a list
    item in `Contact`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为`Contact`中代表列表项的所有类添加验证规则：
- en: '`src/models.js`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/models.js`'
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we make every property `required` and specify a maximum length for each
    of them. Additionally, we make sure the `address` property of the `EmailAddress`
    class is a valid email.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将每个属性设置为`required`，并为它们指定最大长度。此外，我们确保`EmailAddress`类的`address`属性是一个有效的电子邮件地址。
- en: Rendering validation errors
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染验证错误
- en: At this point, the `save` method doesn't send any HTTP request to the backend
    if our form is invalid, which is the correct behavior. However, it still doesn't
    display any error message. Let's see how we can display validation errors to the
    user.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果我们的表单无效，`save`方法不会向后端发送任何HTTP请求，这是正确的行为。然而，它仍然不显示任何错误消息。让我们看看如何向用户显示验证错误。
- en: The errors property
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误属性
- en: 'The controller has an `errors` property containing current validation errors.
    This property can be used, for example, to render a validation summary:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器有一个`errors`属性，其中包含当前的验证错误。这个属性可以用来，例如，渲染一个验证摘要：
- en: '`src/contact-edition.html`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we add an unordered list, which will be rendered only when
    the validation controller has errors. Inside this list, we repeat a list item
    for each `error`. In each list item, we render the error's `message`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了一个无序列表，它将在验证控制器有错误时渲染。在这个列表内部，我们为每个`error`重复一个列表项。在每个列表项中，我们渲染错误的`message`。
- en: The validation-errors attribute
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证错误属性
- en: It is also possible to retrieve, not all validation errors, but only those from
    a narrower scope, using the `validation-errors` custom attribute.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`validation-errors`自定义属性，也可以检索到不是所有的验证错误，而是只检索来自更窄范围的错误。
- en: When added to a given element, this attribute gathers the validation errors
    of all the validated binding instructions under its hosting element, and uses
    two-way binding to assign those errors to the property it is bound to.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加到给定元素时，此属性会收集其宿主元素下所有验证过的绑定指令的验证错误，并使用双向绑定将这些错误分配给它所绑定的属性。
- en: 'For example, let''s remove the validation summary from the previous example
    and use the `validation-errors` attribute to render errors for a specific field
    in our form:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们从上一个示例中移除验证摘要，并使用`validation-errors`属性为表单中的特定字段渲染错误：
- en: '`src/contact-edition.html`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we add the `validation-errors` attribute to the `form-group div` containing
    the editor for the `birthday` property, which we bind to a new `birthdayErrors`
    property. We also add the `has-error` CSS class to the `form-group div` if `birthday`
    has any error. Lastly, we add a `help-block span`, which is repeated for each
    error in the `birthdayErrors` array and displays the error's `message`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在包含`birthday`属性的`form-group div`中添加了`validation-errors`属性，我们将其绑定到新的`birthdayErrors`属性。如果`birthday`有任何错误，我们还向`form-group
    div`添加了`has-error` CSS类。最后，我们添加了一个`help-block span`，它针对`birthdayErrors`数组中的每个错误重复出现，并显示错误的`message`。
- en: Creating a custom ValidationRenderer
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义ValidationRenderer
- en: The `validation-errors` attribute allows us to display errors scoped to specific
    areas in the template. However, it would quickly become tedious - and ineffective
    - if we had to add this code for every single property in the form. Thankfully,
    `aurelia-validation` offers a mechanism to extract this logic in a dedicated service,
    named a validation renderer.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`validation-errors`属性允许我们在模板中显示特定区域的错误。然而，如果我们必须为表单中的每个属性添加此代码，这将很快变得繁琐且无效。幸运的是，`aurelia-validation`提供了一个机制，可以在一个名为验证渲染器的专用服务中提取此逻辑。'
- en: A validation renderer is a class that implements a `render` method. This method
    receives a validation rendering instruction object as its first argument. This
    instruction object contains information about which errors should be displayed
    and which should be removed. It is basically a delta between the previous and
    the current validation state, so the renderer knows what changes it must apply
    to the error messages displayed in the DOM.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 验证渲染器是一个实现`render`方法的类。这个方法以其第一个参数接收到一个验证渲染指令对象。这个指令对象包含了关于应显示哪些错误和哪些应移除的信息。它基本上是前一次和当前验证状态之间的差异，因此渲染器知道它必须对DOM中显示的错误消息应用哪些更改。
- en: 'At the time of writing, no validation renderers are available as part of Aurelia.
    Chances are some community plugins will shortly provide renderers for major CSS
    frameworks. In the meantime, let''s implement this ourselves:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Aurelia中还没有可用的验证渲染器。很可能一些社区插件很快就会提供针对主要CSS框架的渲染器。与此同时，让我们自己实现这个功能：
- en: '`src/validation/bootstrap-form-validation-renderer.js`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/bootstrap-form-validation-renderer.js`'
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we export a class named `BootstrapFormValidationRenderer`, which contains
    a `render` method. This method simply iterates on the `instruction`'s errors to
    `unrender`, then on each of the error's `elements`, and calls a `remove` method
    - which we'll write in a moment. Next, it loops on the `instruction`'s errors
    to `render`, then on each of the error's `elements`, and calls an `add` method.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导出一个名为`BootstrapFormValidationRenderer`的类，其中包含一个`render`方法。这个方法简单地遍历`instruction`的错误来进行`unrender`，然后遍历每个错误`elements`，并调用一个`remove`方法（我们马上就会写）。接下来，它遍历`instruction`的错误来进行`render`，然后遍历每个错误`elements`，并调用一个`add`方法。
- en: 'Next, we need to tell our class how to display a validation error, by writing
    the `add` method to our validation renderer class:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉我们的类如何显示验证错误，通过编写我们的验证渲染器类中的`add`方法：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we retrieve the element with the `form-group` CSS class closest to the
    element hosting the binding instruction that triggered the error, to which we
    add the `has-error` CSS class. Next, we create a `help-block span`, which will
    contain the error's `message`. We also set its `id` attribute using the error's
    `id`, so we can easily find it when it needs to be removed. Lastly, we insert
    this message element in the DOM, right after the element that triggered the error.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检索到离承载绑定指令触发错误的元素的`form-group` CSS类最近的元素，并向其添加`has-error` CSS类。接下来，我们创建一个`help-block
    span`，它将包含错误的`message`。我们还设置其`id`属性使用错误的`id`，这样在需要删除时可以轻松找到它。最后，我们将这个消息元素插入DOM，紧随触发错误的元素之后。
- en: 'To complete our renderer, let''s write the method that will remove a previously
    rendered validation error:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的渲染器，让我们编写一个将删除先前渲染的验证错误的方法：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we first retrieve the element with the `form-group` CSS class closest
    to the element hosting the binding instruction which triggered the error. We then
    retrieve the message element using the error's `id`, and we remove it from the
    DOM. Lastly, if the `form-group` doesn't contain any more error messages, we remove
    the `has-error` CSS class from it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先获取到离触发错误的绑定说明的宿主元素最近的具有`form-group`类的元素。然后我们使用错误的`id`获取消息元素，并将其从DOM中移除。最后，如果`form-group`不再包含任何错误消息，我们将其`has-error`类移除。
- en: 'Our validation renderer must now be made available to the application through
    the dependency injection container. Logically, we will do this in the `configure`
    function of our `validation` feature:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的验证渲染器现在必须通过依赖注入容器向应用程序提供。逻辑上，我们会在我们`validation`特性的`configure`函数中进行此操作：
- en: '`src/validation/index.js`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/index.js`'
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we register our validation renderer under the name `bootstrap-form`.
    We can then use this name in our `contact-edition` form to tell the validation
    controller that this renderer should be used to display the `form`''s validation
    errors:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以`bootstrap-form`的名称注册我们的验证渲染器。我们可以在我们的`contact-edition`表单中使用这个名称，告诉验证控制器应该使用这个渲染器来显示`form`的验证错误：
- en: '`src/contact-edition.html`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `validation-renderer` attribute will resolve an instance of our `BootstrapFormValidationRenderer`
    using the name provided as its value and will register it to the current validation
    controller. The controller will then notify the renderer every time a change occurs
    in the validation state, so any new error can be rendered and any resolved error
    can be removed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`validation-renderer`属性将根据提供的值解析我们的`BootstrapFormValidationRenderer`实例，并将其注册到当前的验证控制器。然后控制器会在验证状态发生更改时通知渲染器，以便可以渲染新的错误并移除已解决的错误。'
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fact that renderers are registered using string keys enables the registration
    of multiple validation renderers under different names, so different renderers
    can be used in different forms.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串键注册渲染器使得可以注册多个不同名称的验证渲染器，因此不同的渲染器可以在不同的表单中使用。
- en: Changing the validation trigger
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改验证触发器
- en: 'By default, the validation of a property is performed when the element it is
    bound to loses focus. However, this behavior can be changed, by setting the controller''s
    `validateTrigger` property:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当元素失去焦点时验证属性，但是可以通过设置控制器的`validateTrigger`属性来更改这种行为：
- en: '`src/contact-edition.js`'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.js`'
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we first import the `validateTrigger` enumeration, and we tell the `ValidationController`
    that it should revalidate properties every time the value of the element they
    are bound to changes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先导入`validateTrigger`枚举，并告诉`ValidationController`当它们绑定的元素的值发生变化时应该重新验证属性。
- en: 'In addition to `change`, the `validateTrigger` enumeration has three other
    values:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`change`，`validateTrigger`枚举还有另外三个值：
- en: '`blur`: The property is validated when the element hosting the binding instruction
    loses focus. This is the default value.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur`：当绑定说明的宿主元素失去焦点时验证属性。这是默认值。'
- en: '`changeOrBlur`: The property is validated when the binding instruction changes
    or when the hosting element loses focus. It basically combines the behavior of
    both `change` and `blur`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changeOrBlur`：当绑定说明发生变化时或当宿主元素失去焦点时验证属性。它基本上结合了`change`和`blur`两种行为。'
- en: '`manual`: Automatic validation is completely disabled. In this case, only a
    call to the controller''s `validate` method, like we do in the `save` method,
    can trigger validation, and it is performed on all registered bindings at once.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manual`：完全禁用自动验证。在这种情况下，只有调用控制器的`validate`方法，如我们在`save`方法中所做的那样，才能触发验证，并且它一次性对所有注册的绑定进行验证。'
- en: Of course, even if the `validateTrigger` is `blur`, `change`, or `blurOrChange`,
    an explicit call to the `validate` method will always perform validation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，即使`validateTrigger`是`blur`、`change`或`blurOrChange`，显式调用`validate`方法总是执行验证。
- en: Creating custom ValidationRules
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义ValidationRules
- en: The `aurelia-validation` library makes it easy to add custom validation rules.
    To illustrate this, we will first move the rule we applied to the `birthday` property
    of `Contact` into a reusable `date` validation rule. Then, we will also add validation
    to our contact photo upload component, which will require some custom rules to
    validate files.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-validation`库可以轻松添加自定义验证规则。为了说明这一点，我们首先将应用于`Contact`的`birthday`属性的规则移动到一个可重用的`date`验证规则中。然后，我们还将向我们的联系人照片上传组件添加验证，这需要一些自定义规则来验证文件。'
- en: Validating a date
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证日期
- en: 'Let''s start by creating a file which will declare and register our various
    custom rules:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个文件，该文件将声明并注册我们各种自定义规则：
- en: '`src/validation/rules.js`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/rules.js`'
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This file doesn't export anything. It just imports the `ValidationRules` class,
    and uses its `customRule` static method to register a new `date` rule, which reuses
    the criteria and the message we previously defined in the `Contact` class.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件没有导出任何内容。它只是导入了`ValidationRules`类，并使用其`customRule`静态方法注册了一个新的`date`规则，该规则重用了我们在`Contact`类中之前定义的准则和消息。
- en: 'Next, we need to import this file somewhere so the rule is registered and made
    available to the application. The best place to do this is the `validation` feature''s
    `configure` function:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在某个地方导入这个文件，以便注册规则并将其提供给应用程序。最好在`validation`功能的`configure`函数中执行此操作：
- en: '`src/validation/index.js`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/index.js`'
- en: '[PRE61]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: By importing the `rules` file, the `date` custom rule is registered, so it will
    be usable as soon as the `validation` feature is imported by Aurelia.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入`rules`文件，`date`自定义规则被注册，因此一旦通过Aurelia导入`validation`功能，它就可以使用。
- en: 'Lastly, we can now change `ValidationRules` for the `Contact`''s `birthday`
    property, so it uses this rule instead:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在可以更改`Contact`的`birthday`属性的`ValidationRules`，使其使用这个规则：
- en: '`src/models.js`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/models.js`'
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we simply remove the call to `satisfies` for the `birthday` property and
    replace it with a call to `satisfiesRule`, which expects the name of the rule
    as its first parameter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地移除了对`birthday`属性的`satisfies`调用，并将其替换为对`satisfiesRule`的调用，该调用期望规则名称作为其第一个参数。
- en: Validating that files are selected
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证文件是否被选择
- en: 'At this point, the contact photo upload component doesn''t do anything when
    the user clicks on the **Save** button if no file was selected. The first thing
    we can do validation-wise is to make sure a file was selected. As such, we will
    create a new rule named `notEmpty`, which will make sure that the validated value
    has a `length` property greater than zero:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果未选择任何文件，联系人照片上传组件在用户点击**保存**按钮时不会做任何事情。我们在验证方面可以做的第一件事是确保已选择文件。因此，我们将创建一个名为`notEmpty`的新规则，以确保验证的值有一个`length`属性大于零：
- en: '`src/validation/rules.js`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/rules.js`'
- en: '[PRE63]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we use the `ValidationRules` class'' `customRule` static method to globally
    register our validation rule. This method expects the following parameters:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`ValidationRules`类的`customRule`静态方法全局注册我们的验证规则。此方法期望以下参数：
- en: The name of the rule. It must be unique.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则的名称。它必须是唯一的。
- en: The condition function, which is passed the value and the parent object, if
    any. It is expected to return `true` if the rule is fulfilled or `false` if the
    rule is violated. It can also return a `Promise` resolving to a `boolean`.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件函数，它接收值和（如果有）父对象。如果规则得到满足，它预期返回`true`，如果规则被违反，则返回`false`。它还可以返回一个`Promise`，其解析结果为`boolean`。
- en: The message error template.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误消息模板。
- en: This rule will be able to work with any value having a `length` property. It
    can be used for example on an array or on a `FileList` instance.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则能够与具有`length`属性的任何值一起工作。例如，它可以用于数组或`FileList`实例。
- en: Validating the size of files
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证文件大小
- en: 'Next, we will create a validation rule to make sure that all files in a `FileList`
    instance weigh less than a maximum size:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个验证规则，以确保`FileList`实例中的所有文件重量小于最大尺寸：
- en: '`src/validation/rules.js`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/rules.js`'
- en: '[PRE64]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we first define a new `maxFileSize` validation rule, which ensures that
    the `size` of every file in the `FileList` does not exceed a given `maximum`.
    The rule applies only if the value is a `FileList` instance and if the `FileList`
    is not empty.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义一个新的`maxFileSize`验证规则，确保`FileList`中的每个文件的大小不超过给定的`maximum`。该规则仅在值为`FileList`实例且`FileList`不为空时适用。
- en: This rule expects a `maximum` parameter. When using such a rule, any argument
    passed to the `satisfiesRule` fluent method is then passed to the underlying condition
    function so it can use it to evaluate the condition. However, in order to be available
    for the message template, the rule arguments must be aggregated inside a single
    object. As such, `customRule` can be passed a fourth argument, which is expected
    to be a function that will aggregate the rule's parameters into a single object.
    This object is then made available to the message template as `$config`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则期望一个`maximum`参数。使用此类规则时，传递给`satisfiesRule`流畅方法的任何参数都将传递给底层的条件函数，以便它使用它来评估条件。然而，为了对消息模板可用，规则参数必须在单个对象中聚合。因此，`customRule`可以传递第四个参数，预期是一个函数，它将规则参数聚合到单个对象中。此对象随后作为`$config`对消息模板可用。
- en: 'This is what we see in our `maxFileSize` rule; it expects to be called with
    a parameter, here named `maximum`, which is the maximum file size in bytes. This
    parameter is expected to be passed to the `satisfiesRule` method when adding the
    rule to a property:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在`maxFileSize`规则中所看到的；它期望以一个名为`maximum`的参数被调用，这是以字节为单位的最大文件大小。当向属性添加规则时，此参数预期传递给`satisfiesRule`方法：
- en: '[PRE65]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This parameter is then passed to the condition function, so the size of all
    files in the `FileList` instance can be validated. It is also passed to the aggregation
    function, which returns an object containing `maximum` as a property. This object
    is then available to the message template as `$config`, so the template can display
    the `maximum` in the error message.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数随后传递给条件函数，以便可以验证`FileList`实例中所有文件的大小。它还传递给聚合函数，该函数返回一个包含`maximum`属性的对象。此对象随后作为`$config`对消息模板可用，因此模板可以在错误消息中显示`maximum`。
- en: Here, our custom rule has only one parameter, but a rule can have as many parameters
    as you need. They will all be passed to the condition function and to the aggregation
    function in the same order in which they are passed to `satisfiesRule`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的自定义规则只有一个参数，但一个规则可以有尽可能多的参数。它们都将以相同的顺序传递给条件函数和聚合函数，顺序与传递给`satisfiesRule`的顺序相同。
- en: Validating file extensions
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证文件扩展名
- en: 'Lastly, let''s create a rule to ensure that all files in a `FileList` instance
    have an extension that is inside a specific set of values:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个规则，以确保`FileList`实例中的所有文件扩展名都在特定的一组值中：
- en: '`src/validation/rules.js`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/validation/rules.js`'
- en: '[PRE66]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This rule, named `fileExtension`, expects an array of file extensions as a parameter,
    and makes sure that the names of all files in the `FileList` end with one of the
    extensions. Like `maxFileSize`, it applies only if the validated value is a `FileList`
    instance that is not empty.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则名为`fileExtension`，期望一个文件扩展名数组作为参数，并确保`FileList`中的所有文件名以扩展名之一结尾。与`maxFileSize`一样，仅当验证的值是一个不为空的`FileList`实例时，它才适用。
- en: Validating the contact photo selector
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证联系照片选择器
- en: 'Now that we have defined all the rules we need to validate the contact photo
    component, let''s set the view-model up, just like we did with the `contact-edition`
    component:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了验证联系照片组件所需的所有规则，让我们像对`contact-edition`组件一样设置视图模型：
- en: Inject a `NewInstance` of `ValidationController` in the `ContactPhoto` view-model
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContactPhoto`视图模型中注入`ValidationController`的`NewInstance`
- en: Explicitly call the `validate` method in `save`, and omit calling `updatePhoto`
    if there are any validation errors
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`save`中显式调用`validate`方法，如果有任何验证错误，则省略调用`updatePhoto`
- en: Add the `validation-renderer="bootstrap-form"` attribute to the `form` element
    in the `contact-photo.html` template
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`contact-photo.html`模板中的`form`元素添加`validation-renderer="bootstrap-form"`属性
- en: Add the `validate` binding behavior to the binding of the `files` property on
    the `file input`
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`validate`绑定行为添加到`file input`上`files`属性的绑定
- en: Those tasks being identical to what we have already done for the `contact-edition`
    component, I'll leave them as an exercise to the reader.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务与我们对`contact-edition`组件已经完成的任务相同，我将留给读者作为练习。
- en: 'Next, we need to add validation rules to the `photo` property of the view-model:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向视图模型的`photo`属性添加验证规则：
- en: '`src/contact-photo.js`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-photo.js`'
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we tell the validation controller that the `photo` must contain at least
    one file, which must be either a JPEG or a PNG and must be at most 2 MBs. We also
    customize the message displayed when no file is selected, using the `withMessage`
    method.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉验证控制器`photo`必须至少包含一个文件，这个文件必须是JPEG或PNG，并且最大不超过2 MB。我们还使用`withMessage`方法定制当没有选择文件时显示的消息。
- en: 'If you test this, it should work properly. However, the fact that the validation
    is triggered when the `file input` loses focus makes usability a bit strange.
    In order to have the form validated right when the user closes the browser''s
    file selection dialog, which will display potential error messages right away,
    let''s change the validation controller''s `validateTrigger` to `change`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您测试这个，它应该能正常工作。然而，验证在`file input`失去焦点时触发，使得可用性有些奇怪。为了在用户关闭浏览器的文件选择对话框时立即验证表单，从而立即显示可能的错误消息，让我们将验证控制器的`validateTrigger`更改为`change`：
- en: '`src/contact-photo.js`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-photo.js`'
- en: '[PRE68]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you test after doing this change, you should find that the usability is much
    better, as the file is validated as soon as the user closes the file selection
    dialog.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在做出此更改后进行测试，您应该发现可用性得到了很大改善，因为文件在用户关闭文件选择对话框时就会进行验证。
- en: Editing complex structures
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑复杂结构
- en: In the previous sections, we created a form to edit, among others, lists of
    items, using a strategy that is referred to as inline edition. The form includes
    input elements for every list item. This strategy reduces to a minimum the number
    of clicks the user has to do to edit or add new list items, because he or she
    can already edit all fields of all list items directly in the form.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们创建了一个表单，用于编辑项目列表（如电话号码、电子邮件地址、地址和社会资料等），这种策略称为内联编辑。表单包括每个列表项的输入元素。这种策略将用户编辑或添加新列表项所需的点击次数降到最低，因为用户可以直接在表单中编辑所有列表项的所有字段。
- en: However, when a form needs to manage lists of more complex items, one solution
    is to display only the most relevant information in the list as read-only, and
    to use a modal dialog to create or edit items. A dialog leaves much more room
    to display a complex form for a single item.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当表单需要管理更复杂项目的列表时，一个解决方案是只显示列表中最具相关性的信息作为只读，并使用模态对话框创建或编辑项目。对话框为单个项目显示复杂表单提供了更多的空间。
- en: The `aurelia-dialog` plugin exposes a dialog functionality, which we can leverage
    to create modal editors. To illustrate this, we will fork our contact management
    application and change the `contact-edition` component so it uses dialog edition
    instead of inline edition for list items.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-dialog`插件暴露了一个对话框功能，我们可以利用它来创建模态编辑器。为了说明这一点，我们将克隆我们的联系人管理应用程序，并更改`contact-edition`组件，使其使用对话框编辑而不是列表项的内联编辑。'
- en: The following code snippets are excerpts of `chapter-4/samples/list-edition-models`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是`chapter-4/samples/list-edition-models`的摘录。
- en: Installing the dialog plugin
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装对话框插件
- en: 'To install the `aurelia-dialog` plugin, simply fire up a console in the project
    directory and run the following command:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`aurelia-dialog`插件，只需在项目目录中打开一个控制台，并运行以下命令：
- en: '[PRE69]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Once installation is completed, we also need to add the plugin to the vendor
    bundle configuration. To do this, open `aurelia_project/aurelia.json` and, under
    `build`, then `bundles`, in the `dependencies` array of the bundle named `vendor-bundle.js`,
    add the following entry:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们还需要将插件添加到供应商包配置中。为此，请打开`aurelia_project/aurelia.json`，然后在`build`下的`bundles`中，在名为`vendor-bundle.js`的包的`dependencies`数组中添加以下条目：
- en: '[PRE70]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Lastly, we need to load the plugin in our main `configure` function:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的主`configure`函数中加载插件：
- en: '`src/main.js`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`'
- en: '[PRE71]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: At this point, the services and components exposed by `aurelia-dialog` are ready
    to be used in our application.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`aurelia-dialog`暴露的服务和组件已准备好在我们的应用程序中使用。
- en: Creating the edition dialogs
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建编辑对话框
- en: The dialog plugin uses composition to display a component as a dialog. This
    means that the next step is to create the components that will be used to edit
    a new or an existing item.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框插件使用组合来将组件作为对话框显示。这意味着下一步是创建将用于编辑新或现有项目的组件。
- en: 'Since the behavior behind dialog edition will be the same whatever the type
    of the item being edited, we will create a single view-model, which we will reuse
    for phone numbers, email addresses, addresses, and social profiles:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无论编辑的项目类型如何，对话框编辑的背后的行为都将相同，我们将创建一个单一的视图模型，我们将在电话号码、电子邮件地址、地址和社会资料等项目中重复使用：
- en: '`src/dialogs/edition-dialog.js`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/dialogs/edition-dialog.js`'
- en: '[PRE72]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we create a component in which we inject a `DialogController` and a `NewInstance`
    of the `ValidationController` class. Next, we define an `activate` method receiving
    the `model`, which will be the item to edit - the phone number, email address,
    address, or social profile. We also define an `ok` method which validates the
    form and, if there are no errors, calls the `ok` method of `DialogController` with
    the updated `model` as the dialog's output. Finally, we define a `cancel` method,
    which simply delegates to the `cancel` method of `DialogController`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个组件，在该组件中注入了`DialogController`和`ValidationController`类的`NewInstance`。接下来，我们定义了一个接收`model`的`activate`方法，该`model`将是需要编辑的项目
    - 电话号码、电子邮件地址、地址或社会资料。我们还定义了一个`ok`方法，该方法验证表单，如果没有错误，则使用更新后的`model`作为对话框的输出调用`DialogController`的`ok`方法。最后，我们定义了一个`cancel`方法，它简单地将调用委托给`DialogController`的`cancel`方法。
- en: A `DialogController`, when injected in a component displayed as a dialog, is
    used to control the dialog into which the component is displayed. Its `ok` and
    `cancel` methods can be used to close the dialog and to return a response to the
    caller. This response can then be used by the caller to determine if the dialog
    was canceled or not and to retrieve its output, if any.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当`DialogController`被注入到一个作为对话框显示的组件中时，它被用来控制显示组件的对话框。它的`ok`和`cancel`方法可以用来关闭对话框，并向调用者返回一个响应。这个响应随后可以被调用者用来确定对话框是否被取消以及检索其输出（如果有）。
- en: 'Even though we will reuse the same view-model class for all item types, the
    templates must be different for each item type. Let''s start with the dialog edition
    for phone numbers:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将为所有项目类型重用相同的视图模型类，但每个项目类型的模板必须是不同的。让我们从电话号码的对话框编辑开始：
- en: '`src/dialogs/phone-number-dialog.html`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/dialogs/phone-number-dialog.html`'
- en: '[PRE73]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, the notable parts are the `ai-dialog`, `ai-dialog-body`, and `ai-dialog-footer`
    elements, which are containers for an Aurelia dialog. Additionally, the `attach-focus="true"`
    attribute on the `select` element makes sure that this element is given the focus
    when the dialog is displayed. Lastly, the `submit` event of `form` delegates to
    the `ok` method, while a `click` on the cancel `button` delegates to the `cancel`
    method.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是`ai-dialog`、`ai-dialog-body`和`ai-dialog-footer`元素，它们是Aurelia对话框的容器。此外，`select`元素上的`attach-focus="true"`属性确保当对话框显示时这个元素获得焦点。最后，`form`的`submit`事件委托给`ok`方法，而点击取消按钮则委托给`cancel`方法。
- en: The rest of the template should be familiar. The user input elements are bound
    to the properties of `model`, and those bindings are decorated with the `validate`
    binding behavior so the properties are properly validated.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的其余部分应该很熟悉。用户输入元素绑定到`model`的属性，这些绑定被`validate`绑定行为装饰，以便属性得到适当验证。
- en: 'We also need to create the templates for the other item types: `src/dialogs/email-address-dialog.html`,
    `src/dialogs/address-dialog.html`, and `src/dialogs/social-profile-dialog.html`.
    At this point, those templates should be easy to create. I''ll leave it as an
    exercise to the reader to write them; the `list-edition-models` sample can be
    used as a reference.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为其他项目类型创建模板：`src/dialogs/email-address-dialog.html`、`src/dialogs/address-dialog.html`和`src/dialogs/social-profile-dialog.html`。此时，这些模板应该很容易创建。我将留给读者一个练习来编写它们；`list-edition-models`示例可以作为参考。
- en: Using edition dialogs
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用编辑对话框
- en: 'The last step to leverage our new view-model and templates is to change the
    behavior of the `contact-edition` component:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们新的视图模型和模板的最后一步是改变`contact-edition`组件的行为：
- en: '`src/contact-edition.js`'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.js`'
- en: '[PRE74]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we add a new dependency to our `ContactEdition` view-model by injecting
    a `DialogService` into its constructor. We next define a `_openEditDialog` method,
    which defines a common behavior to open an edition dialog.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过在构造函数中注入`DialogService`来向我们的`ContactEdition`视图模型添加一个新的依赖。接下来，我们定义了一个`_openEditDialog`方法，它定义了打开编辑对话框的通用行为。
- en: This method calls the `open` method of `DialogService` to open a dialog, using
    the `edition-dialog` view-model and a given item type's template, composed as
    a single component. A given `model` is also passed to it, which will be injected
    in the `activate` method of `edition-dialog`. This should be familiar if you read
    the section about composition in [Chapter 3](ch03.html "Chapter 3. Displaying
    Data"), *Displaying Data*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用`DialogService`的`open`方法来打开一个对话框，使用`edition-dialog`视图模型和给定项目类型的模板，组合成一个单一组件。还传递了一个`model`，它将在`edition-dialog`的`activate`方法中注入。如果你阅读了[第3章](ch03.html
    "Chapter 3. Displaying Data")*显示数据*中的组合部分，这应该会很熟悉。
- en: Additionally, the method returns a `Promise`, which will be resolved when the
    user clicks **Ok**, but rejected when he clicks **Cancel**. This way, when using
    this method, the resulting Promise will be resolve only when the user confirms
    its modifications by clicking **Ok** and will be rejected otherwise.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该方法返回一个 `Promise`，当用户点击 **确定** 时解析，但当用户点击 **取消** 时拒绝。这样，在使用这个方法时，只有当用户通过点击
    **确定** 来确认其修改时，结果的 `Promise` 才会被解析，否则会被拒绝。
- en: The `editPhoneNumber` method uses the `_openEditDialog` method to display the
    phone number edition dialog. A copy of the `phoneNumber` to edit is passed as
    the `model` because, if we pass the original `phoneNumber` object, it will be
    modified even if the user cancels its modifications. When the `Promise` resolves,
    which happens when the user confirms its modifications, the updated `model` properties
    are assigned back to the original `phoneNumber`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`editPhoneNumber` 方法使用 `_openEditDialog` 方法来显示电话号码编辑对话框。要编辑的 `phoneNumber`
    的副本作为 `model` 传递，因为如果我们传递原始 `phoneNumber` 对象，即使用户取消其修改，它也会被修改。当用户确认其修改时，`Promise`
    解析，这时更新后的 `model` 属性会被回赋给原始的 `phoneNumber`。'
- en: Similarly, the `addPhoneNumber` method uses the `_openEditDialog` method, but
    passes a new `PhoneNumber` instance as the model. Additionally, when the `Promise`
    resolves, the new phone number is added to the `phoneNumbers` array of `contact`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`addPhoneNumber` 方法使用了 `_openEditDialog` 方法，但传递了一个新的 `PhoneNumber` 实例作为模型。另外，当
    `Promise` 解析时，新的电话号码会被添加到 `contact` 的 `phoneNumbers` 数组中。
- en: 'Lastly, the template must be changed, so the list of phone numbers is displayed
    as read-only, and a new **Edit** button must be added for each phone number:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模板必须更改，以便电话号码列表以只读方式显示，并为每个电话号码添加一个新的 **编辑** 按钮：
- en: '`src/contact-edition.html`'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE75]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, we remove the `select` and `input` elements and replace them with string
    interpolation instructions to display the `type` and `number` properties of `phoneNumber`.
    We also add an **Edit** button, which, when clicked, calls the new `editPhoneNumber`
    method. Lastly, we change the **Add** button so it calls the new `addPhoneNumber`
    method.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们移除了 `select` 和 `input` 元素，并用字符串插值指令来显示 `phoneNumber` 的 `type` 和 `number`
    属性。我们还添加了一个 **编辑** 按钮，当点击时，调用新的 `editPhoneNumber` 方法。最后，我们更改了 **添加** 按钮，使其调用新的
    `addPhoneNumber` 方法。
- en: Of course, the same changes must be applied to both the view-model and the template
    of the `contact-edition` component for the other item types. However, changing
    the inline edition strategy for the email addresses, the addresses, and the social
    profiles for dialog edition should be straightforward to you now; I'll leave this
    as an exercise to the reader.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于 `contact-edition` 组件的视图模型和模板，以及其他项目类型的更改也必须应用相同的更改。然而，对于电子邮件地址、地址和社会资料的内联编辑策略的更改，现在对您来说应该是很直接的；我将把这个留给读者作为一个练习。
- en: Summary
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Creating forms is simple with Aurelia, it is mostly a matter of leveraging two-way
    binding. Validating forms is also easy, thanks to the validation plugin. Additionally,
    the abstraction layer in the validation plugin allows us to use the validation
    library we want, even though the default implementation provided by the plugin
    is already pretty powerful.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Aurelia 创建表单很简单，主要是利用双向绑定。验证表单也很容易，得益于验证插件。此外，验证插件的抽象层允许我们使用我们想要的验证库，尽管插件提供的默认实现已经相当强大。
- en: The power of Aurelia will really start to become clear in the next chapter.
    By leveraging what we saw up to now, and adding custom attributes, custom elements,
    and content projection to the mix, we will be able to create extremely powerful,
    reusable, and extensible components, composing them into modular and testable
    applications. Of course, while covering those topics, we will heavily refactor
    our contact management application to extract components and reusable behaviors
    from our existing code base, while we add features that would be undoable without
    custom elements and attributes.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，Aurelia 的力量将真正开始变得清晰。通过利用我们迄今为止看到的内容，并添加自定义属性、自定义元素和内容投射到混合中，我们将能够创建极其强大、可重用和可扩展的组件，将它们组合成模块化和可测试的应用程序。当然，在覆盖这些主题的同时，我们将对我们的联系人管理应用程序进行大量重构，以提取组件和可重用行为，同时添加在没有自定义元素和属性时无法实现的特性。
