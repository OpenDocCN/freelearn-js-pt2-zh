- en: Chapter 4. Forms, and How to Validate Them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see how data binding works for user input elements,
    such as `input`, `select`, and `textarea`. We will also see how the Fetch client
    works when dealing with scenarios more complex than simple GET requests, such
    as POST or PUT requests with JSON bodies, or requests to upload files to a server.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will see how we can validate forms, by using the `aurelia-validation`
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will discuss various strategies to create complex forms, from inline
    list edition to modal edition windows using the `aurelia-dialog` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to form inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aurelia supports two-way binding to all official HTML5 user input elements.
    Some of them are pretty simple to use, such as the `text input`, which we have
    already explored in many examples in previous chapters. Some others, such as radio
    buttons or checkboxes, are less straightforward. Let's go over all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippets in the following sections are excerpts from `chapter-4/samples/binding-forms`.
  prefs: []
  type: TYPE_NORMAL
- en: select elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a `select` element, we typically bind to its `value` attribute, and often
    use `repeat.for` to render its `option` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `select` element's `value` attribute is bound two-way by default,
    so the `value` attribute of the selected `option` element will be assigned to
    the expression bound to the `value` of `select`. In this example, the `selectedCountry`
    property will be assigned the selected `country` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `value` attribute of an `option` element expects string values only. In
    the previous example, the `countries` property is an array of strings, so the
    `value` of each `option` is bound to a string. To render an `option` bound to
    any other type of value--an object, for example--the special `model` attribute
    must be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `selectedCulture` property will be assigned to the selected `culture`
    object, because the `cultures` property is an array of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you need to select a key property, such as an ID, instead
    of the whole array item, you can still use the `value` attribute on the `option`
    elements, given that the key property is a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `value` of the selected `option` is bound to the corresponding
    item's `isoCode` property, which is a string, so this property of the selected
    item will be assigned to `selectedCultureIsoCode`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, during rendering, the value of the expression bound to the `value`
    of the `select` attribute will be evaluated and, if any `option` has a matching
    `value` or `model` attribute, this `option` will be rendered as selected.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a `select` element has the `multiple` attribute, the expression bound
    to its `value` attribute is expected to be an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the values of the selected options will be added to the `selectedCountries`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: When the user selects an item, the selected value is always appended at the
    end of the selection array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the same rule applies when rendering an array of non-string values
    into a multi-select list; each array item should be bound to its `option``model`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the selected `culture` objects will be added to the `selectedCultures`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative, using a key string property, also works the same with multi-selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `isoCode` property of the selected `culture` objects will
    be added to the `selectedCulturesIsoCodes` array, which is an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Matchers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `model` attribute, it may happen that the object assigned to
    the `value` of `select` has the same identity, but is not the same instance, as
    the ones assigned to the `option``model`. In such a case, Aurelia won't be able
    to render the proper `option` as selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matcher` attribute has been designed for this kind of scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, when trying to find which `option` should be selected, the `select` element
    will delegate the equality comparison to the `matchCulture` function, which should
    somehow look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, this function expects two culture objects, which possibly have the same
    identity and represent the same culture. It will return `true` if the two objects
    have the same identity, and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: input elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Binding to `input` elements is straightforward in most cases, but it actually
    depends on the `type` attribute. For example, for `text` inputs, the `value` attribute
    is bound two-way by default, and can be used to get the user''s input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the initial value of the `title` property would be displayed in the `input`,
    and any change performed by the user to the `input` value would also be applied
    to the `title` property. Similarly, any change performed to the `title` property
    will also be applied to the `value` of the `input`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is the same for most other types of `input`: `color`, `date`, `email`,
    `number`, `password`, `tel`, or `url`, just to name a few. There are however some
    special cases, which are described as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: File pickers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `input` element, when its `type` attribute is `file`, exposes its `files`
    property as an attribute. It uses two-way binding by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `input``files` property is bound to the view-model's `images`
    property. When thee user selects a file, `images` is assigned a `FileList` object
    containing the selected file as a single `File` object. If the `input` has the
    `multiple` attribute, the user is able to select multiple files, and the resulting
    `FileList` object contains as many `File` objects as selected by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileList` and `File` classes are part of the HTML5 File API, and can be
    used with the Fetch API to send files selected by the user to a server. We will
    see an example of this when building the photo-editing component in our contact
    application, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Mozilla Developer Network has extensive documentation about the File API.
    Details about the `FileList` class can be found at [https://developer.mozilla.org/en-US/docs/Web/API/FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList).
  prefs: []
  type: TYPE_NORMAL
- en: Radio buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly to a `select` element's `option`, radio buttons can use either the
    `value` or the `model` attribute to specify the value used when the button is
    selected. The `value` attribute expects only string values, so the `model` attribute
    must be used for any other types of value.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, radio buttons can bind their `checked` attribute, which is two-way
    by default, to an expression that will be assigned the `value` or `model` of the
    button when selected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, a group of radio buttons is rendered using an array of strings named `countries`.
    The `country` of the selected radio button, bound to the `value` attribute, will
    be assigned to the `selectedCountry` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with the `option` elements, when binding to values that are not strings,
    the `model` attribute should be used instead of `value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, a group of radio buttons is rendered using an array of `culture` objects.
    The `culture` of the selected radio button, bound to the `model` attribute, will
    be assigned to the `selectedCulture` property.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the `select` element, radio buttons that use the `model` attribute
    can also use the `matcher` attribute to customize the equality comparison logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'All previous examples used `repeat.for` bound to an array to render a dynamic
    list of radio buttons. What if you need to render a static list of radio buttons
    and the expected output is a Boolean, for example? In this case, no need to iterate
    on an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a static list of radio buttons is rendered, each bound to a
    different scalar value using their `model` attribute. Their `checked` attribute
    is bound to the `isMultilingual` property, which will be assigned either `null`,
    `true`, or `false`, depending on which button is selected.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, during rendering, if the expression bound to the `checked` attribute
    of the buttons of a group has a value matching one of the button's `value` or
    `model` attributes, this button will be rendered as selected.
  prefs: []
  type: TYPE_NORMAL
- en: Checkboxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A list of checkboxes is similar in its typical usage to a `select` element
    with the `multiple` attribute. Each `input` element has either a `value` or a
    `model` attribute. Additionally, a `checked` attribute is expected to be bound
    to an array, to which the `value` or `model` of all checked `input`s will be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, a group of checkboxes is rendered using an array of strings named `countries`.
    The `country` of the selected checkboxes, bound to the `value` attribute, will
    be added to the `selectedCountries` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with `option` elements or radio buttons, the `value` attribute expects
    string values only. When binding to any other types of value, the `model` attribute
    should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, a group of checkboxes is rendered using an array of `culture` objects.
    The `culture` of the selected checkboxes, bound using the `model` attribute, will
    be added to the `selectedCultures` array.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the `select` element and to radio buttons, checkboxes that use
    the `model` attribute can also use the `matcher` attribute to customize the equality
    comparison logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if, when rendering an array of objects, the selected values are
    some sort of string IDs, the `value` attribute can still be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, a group of checkboxes is rendered using an array of `culture` objects.
    The `isoCode` property of the selected checkboxes `culture`, bound to the `value`
    attribute, will be added to the `selectedCulturesIsoCodes` array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, during rendering, if the array bound to the `checked` attribute contains
    the value bound to the `value` or `model` attribute, this checkbox will be rendered
    as selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, checkboxes can be bound to distinct Boolean expressions instead
    of a single array. This can be achieved by omitting any `value` or `model` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, each `checkbox` is bound to a distinct property, which will
    be assigned `true` or `false` depending on whether the checkbox is checked or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: textarea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Binding to a `textarea` element is identical to binding to a `text``input`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the initial value of the `text` property will be displayed inside the
    `textarea` and, as the binding on a `value` attribute of `textarea` is two-way
    by default, all modifications performed by the user on the content of the `textarea`
    will be reflected on the `text` property.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling an element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Disabling an `input`, `select`, `textarea`, or `button` element is only a matter
    of binding to its `disabled` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `input` and the `button` elements will both be disabled when `isSending`
    is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Making an element read-only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, making an `input` or `textarea` element read-only is just a matter
    of binding to its `readonly` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `input` will be read-only when `canEdit` is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding forms to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to work with user input elements, we can add forms to create
    and edit contacts in our contact management application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to add three new routes: one to create new contacts, another to edit
    an existing contact, and the last one to upload the photo of a contact. Let''s
    add them in our root component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src/app.js` file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The three new routes are highlighted in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: The positioning is important here. The `contact-creation` route is placed before
    the `contact-details` route because of their respective `route` property. When
    trying to find a matching route upon a URL change, the router drills down through the
    route definitions in the order they were defined in. Since the pattern for `contact-details`
    matches any path starting with `contacts/` and followed by a second part interpreted
    as a parameter, the path `contacts/new` matches this pattern, so the `contact-creation`
    route would be unreachable if it was defined later, and the `contact-details`
    route would be reached instead with an `id` parameter equal to `new`.
  prefs: []
  type: TYPE_NORMAL
- en: A better alternative to relying on the order of the routes would be to change
    the patterns so there is no possible collision. For example, we could change the
    pattern of `contact-details` to something like `contacts/:id/details`. In such
    a case, the order of the routes would not matter anymore.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that two of the new routes have the same `moduleId`. This
    is because we will use the same component for both creating a new contact and
    editing an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Adding links to the new routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step will be to add links leading to the routes we just added. We
    will first add a link to the `contact-creation` route in the `contact-list` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-list.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here we add an `a` element and leverage the `route-href` attribute to render
    the URL for the `contact-creation` route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add links to the `contact-photo` and the `contact-edition`
    routes. We will do this in the `contact-details` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-details.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we first refactor the template displaying `fullName` and `company` if the
    contact is a person, by adding an enclosing `div` and moving the `col-sm-10` CSS
    class from the titles to this `div`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we wrap the `img` element displaying the contact's photo inside an anchor
    navigating to the `contact-photo` route, using the contact's `id` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we add another anchor leading to the `contact-edition` route, using
    the contact's `id` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Updating models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to reuse code, we will stick with the `Contact` class and use it in
    our form component. We will also create classes for phone numbers, email addresses,
    addresses, and social profiles, so our `contact-edition` component won't have
    to know the details of how to create empty instances of those objects.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add the ability to create empty instances of our models, and have
    all their properties initialized to proper default values. As such, we will add
    default values for all properties on our model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to update the `Contact``fromObject` factory method so all list
    items are properly mapped to instances of our model classes.
  prefs: []
  type: TYPE_NORMAL
- en: '`src/models.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first add classes for a `PhoneNumber`, an `EmailAddress`, an `Address`,
    and a `SocialProfile`. Each of those classes has a static `fromObject` factory
    method and its properties are properly initialized with default values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the properties of a `Contact`, initialized with default values,
    and change its `fromObject` factory method so the list items are properly mapped
    to their respective classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the form component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can create our new `contact-edition` component. As mentioned earlier,
    this component will be used for both creating and editing. It will be able to
    detect if it is used to create a new contact or to edit an existing one by checking
    whether it receives an `id` parameter in its `activate` callback method. Indeed,
    the pattern for the `contact-creation` route defines no parameter, so when our
    form component gets activated by this route, it won't receive any `id` parameter.
    On the other hand, since the pattern for the `contact-edition` route does define
    an `id` parameter, our form component will receive the parameter when activated
    by this route.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this because, in the scope of our contacts management application,
    the creation and editing processes are almost identical. However, in many cases,
    it might be a better design to have separate components for creating and editing.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the view-model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s first start with the view-model and the `activate` callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by injecting an instance of the `ContactGateway` class into our
    view-model. Then, in the `activate` callback method, we first define an `isNew`
    property, based on the existence of an `id` parameter. This property will be used
    by our component to know if it is being used to create a new contact or to edit
    an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Next, based on this `isNew` property, we initialize the component. If we are
    creating a new contact, then we simply create a `contact` property and assign
    to it a new, empty `Contact` instance; otherwise, we use the `ContactGateway`
    to retrieve the proper contact based on the `id` parameter and, when the `Promise`
    resolves, assign the `Contact` instance to the `contact` property and set the
    document title to the contact's `fullName` property.
  prefs: []
  type: TYPE_NORMAL
- en: Once the activation cycle completes, the view-model has a `contact` property
    properly initialized to a `Contact` object, and an `isNew` property indicating
    if the contact is a new or existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Building the form layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, let's build the template to display the form. This template being pretty
    big, I will break it down in parts, so you can build it gradually and test it
    at each step if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template consists of a header, followed by a `form` element, which will
    enclose the rest of the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the header, we use the `isNew` property to display either a static title
    telling the user he is creating a new contact or a dynamic title displaying the
    `id` of the contact being edited.
  prefs: []
  type: TYPE_NORMAL
- en: Editing scalar properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will add blocks, containing input elements, to edit the `firstName`,
    `lastName`, `company`, `birthday`, and `note` of the contact, inside the `form`
    element defined in the previous code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply define a `form-group` for each property to edit. The first three
    properties are each bound to a `text input` element. Additionally, the `birthday`
    property is bound to a `date` input, making it easier to edit a date--for browsers
    supporting it, of course--and the `note` property is bound to a `textarea` element.
  prefs: []
  type: TYPE_NORMAL
- en: Editing phone numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After this, we need to add editors for lists. Since the data contained in each
    list is not very complex, we will render inline editors, so the user can edit
    any field of any item directly, in the minimum number of clicks.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss more complicated editing models, using dialogs, later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the phone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This phone number list editor can be broken down into parts, the most important
    of which are highlighted. First, a `form-group` is repeated for each `phoneNumber`
    in the contact's `phoneNumbers` array.
  prefs: []
  type: TYPE_NORMAL
- en: For each `phoneNumber`, we define a `select` element, whose `value` is bound
    to the `type` property of `phoneNumber`, along with a `tel input`, whose `value`
    is bound to the `number` property of `phoneNumber`. Additionally, we define a
    `button` whose `click` event splices the phone number out of the `phoneNumbers`
    array of `contact`, using the current `$index`, which, as you may remember from
    the previous chapter, is added to the binding context by the `repeat` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, after the list of phone numbers, we define a `button` whose `click`
    event calls the `addPhoneNumber` method in `contact`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the missing method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the buttons we added in the previous template calls a method that is
    not defined yet. Let''s add this method to the `Contact` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/models.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first method in this code snippet is used to add an empty phone number to
    the list, by simply pushing a new `PhoneNumber` instance in the `phoneNumbers`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the other lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The templates for the other lists, email addresses, addresses, and social profiles,
    are pretty similar. Only the fields being edited change, but the main concepts--repeating
    form groups, having a remove button for each item and an add button at the end
    of the list--are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `emailAddresses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This template is very similar to the phone numbers' template. The main difference
    is that the available types are not exactly the same, and the `input` `type` is
    `email`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, the editor for addresses will be a little bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, the left part contains six different inputs, allowing us to edit the various
    text properties that an address has.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you probably have some idea what the template for the social
    profiles looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the methods to add items for each list need to be added to the `Contact`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/models.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, those methods are almost identical to the ones we wrote previously
    for the phone numbers. Additionally, the template snippets for each list are also
    mostly identical to each other. All this redundancy screams for refactoring. We
    will see in [Chapter 5](ch05.html "Chapter 5. Making Reusable Components"), *Making
    Reusable Components*, how we can extract common behaviors and template snippets
    into a component, which we will reuse to manage each list.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and canceling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing missing for our form to be (at least visually) complete is a
    Save and a Cancel button at the end of the enclosing `form` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, we bind a call to the `save` method to the `form` element's `submit`
    event, then we add a last `form-group` containing a `submit` button named `Save.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add two `Cancel` links: one displayed when creating a new contact
    to navigate back to the contacts list, and another displayed when editing an existing
    contact to navigate back to the contact''s details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add the `save` method to the view-model. This method will ultimately
    delegate to the `ContactGateway` but, in order to test that everything we''ve
    done upto this point, works, let''s just write a dummy version of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be able to run the application and try to create or
    edit a contact. When clicking the **Save** button, you should see an alert displaying
    the contact, serialized as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data with fetch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now add methods to create and update contacts to the `ContactGateway`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-gateway.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to do is `import` the `json` function from `fetch-client`. This
    function takes any JS value as an argument and returns a `Blob` object containing
    the received parameter serialized as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add a `create` method, which takes a `contact` as a parameter and calls
    the HTTP client's `fetch` method, passing to it the relative URL to call, followed
    by a configuration object. This object contains properties that will be assigned
    to the underlying `Request` object. Here, we specify a `method` property, telling
    the client to perform a `POST` request, and we indicate that the `body` of the
    request will be the `contact` serialized as JSON. Finally, the `fetch` method
    returns a `Promise`, which is returned by our new `create` method, so callers
    can react when the request completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` method is very similar. The first difference is the parameters:
    the contact''s `id` is first expected, followed by the `contact` object itself.
    Secondly, the `fetch` call is slightly different; it sends a request to a different
    URL, using the `PUT` method, but its body is the same.'
  prefs: []
  type: TYPE_NORMAL
- en: The `body` of a Fetch `Request` is expected to be either a `Blob`, a `BufferSource`,
    a `FormData`, an `URLSearchParams`, or an `USVString` object. Documentation about
    this can be found on the Mozilla Developer Network, at [https://developer.mozilla.org/en-US/docs/Web/API/Request/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test that our new methods work, let''s replace our dummy `save`
    method in the view-model of the `contact-edition` component with the real deal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we first import the `Router` and inject an instance of it in the view-model.
    Next, we change the body of the `save` method: if the component is creating a
    new contact, we first call the `create` method from `ContactGateway`, passing
    the `contact` object to it, then navigate back to the `contacts` route when the
    `Promise` resolves; otherwise, when the component is editing an existing contact,
    we first call the `update` method of `ContactGateway`, passing the contact''s
    `id` and the `contact` object to it, then navigate back to the contact''s details
    when the `Promise` resolves.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be able to create or update a contact. However, some
    create or update requests may return responses with a 400 bad Request status.
    Don't be alarmed; since the HTTP endpoint performs some validation, and our form
    does not at this point, this is expected to happen-if you leave some field empty,
    for example. We will add validation to our form later in this chapter, which will
    prevent this class of error.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a contact's photo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can create and edit a contact, let's add a component to upload its
    photo. This component will be named `contact-photo`, and will be activated by
    the route with the same name, which we already added earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This component will use a `file input` element to let the user select an image
    file on his file system, and will leverage the HTML5 File API along with the Fetch
    client to send a PUT request containing the selected image file to our HTTP end-point.
  prefs: []
  type: TYPE_NORMAL
- en: Building the template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The template for this component simply reuses a couple of the concepts we already
    covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-photo.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first display the `fullName` of the contact as the page title. Then,
    inside a `form` element whose `submit` event triggers a `save` method, we add
    a `file input` and buttons to **Save** or **Cancel** the photo upload. The `file
    input` has an `accept` attribute, forcing the browser's file selection dialog
    to display only image files, and its `files` attribute is bound to the `photo`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the view-model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The view-model looks a lot like the `contact-edition` view-model, at least
    when comparing imports, constructors, and `activate` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-photo.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This view-model expects both an instance of `ContactGateway` and a `Router`
    instance to be injected in its constructor. In its `activate` method, it then
    loads a `Contact` instance using its `id` parameter, and initializes the document
    title using the `fullName` for the `contact`. This is all pretty similar to the
    `contact-edition` view-model.
  prefs: []
  type: TYPE_NORMAL
- en: The `save` method is a little different however. It first checks if a file has
    been selected; if not, it does nothing for now. Otherwise, it calls the `updatePhoto`
    method of the `ContactGateway` method, passing the contact's `id` and the selected
    file to it, and navigates back to the contact's details when the `Promise` resolves.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading files with fetch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last step in getting our photo upload feature working is the `uploadPhoto`
    method in the `ContactGateway` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-gateway.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Our HTTP backend''s `contacts/{id}/photo` endpoint expects a PUT request, with
    the proper `Content-Type` header and the image binary as its body. This is exactly
    what the call to `fetch` does here: it uses the `file` argument, which is expected
    to be an instance of the `File` class, and sets the `Content-Type` header using
    its `type` property, then sends the `file` itself as the request body.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the `File` class is part of the HTML5 File API. The Mozilla
    Developer Network has extensive documentation about this API. Details about the
    `File` class can be found at [https://developer.mozilla.org/en-US/docs/Web/API/File](https://developer.mozilla.org/en-US/docs/Web/API/File).
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the `updatePhoto` method returns the `Promise` resolved by the HTTP
    request, so the caller can act when the operation is completed.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be able to run the application and update the photo
    of a contact by uploading a new image file.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a contact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, our application allows us to create, read, and update contacts.
    Obviously, one of the letters from **create, read, update, delete** (**CRUD**)
    is missing here: we can''t delete a contact yet. Let''s quickly implement this
    feature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a **Delete** button to the contact''s `details` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-details.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The new **Delete** button will call the `tryDelete` method when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-details.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `tryDelete` method first asks the user to `confirm` deletion, then calls
    the gateway's `delete` method with the contact's `id`. When the returned `Promise`
    resolves, it navigates back to the contacts list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the `ContactGateway` class'' `delete` method just performs a Fetch
    call to the backend''s proper path, using the `DELETE` HTTP method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-gateway.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At this point, if you click on the **Delete** button for a contact and approve
    the confirmation dialog, you should be redirected to the contacts list and the
    contact should be gone.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you try to save a contact with either an invalid birthday, or an empty phone
    number, address, email, or social profile username, while your browser's debug
    console is open, you will see that the HTTP endpoint rejects the request with
    a 400 Bad Request response. This is because the backend performs some validation
    on the contact being created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: Having a remote service performing some form of validation is pretty common;
    the opposite is actually considered bad architecture, as a remote service should
    not trust its clients for valid data. However, in order to provide a better end
    user experience, it is common to see validation also performed by client applications.
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia offers the `aurelia-validation` library, which defines an interface
    for validation providers, along with various mechanisms to plug validation inside
    components. It also offers a default implementation of this interface, providing
    a simple yet powerful validation mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can use those libraries to validate to our contact form.
  prefs: []
  type: TYPE_NORMAL
- en: This section is but an overview of the most common features offered by `aurelia-validation`.
    In fact, this library is much more flexible and powerful than what is depicted
    here, so I invite you to dig it further after reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the library, you simply have to run the following command in the
    project''s directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to make this library available in the application''s bundles.
    In `aurelia_project/aurelia.json`, under `build`, then `bundles`, in the `dependencies`
    array of the bundle named `vendor-bundle.js`, add the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This configuration entry will tell Aurelia's bundler to include the newly installed
    library in the vendor bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `aurelia-validation` library needs a little configuration before it can
    be used. Additionally, being an Aurelia plugin, it needs to be loaded when our
    application starts.
  prefs: []
  type: TYPE_NORMAL
- en: We could do all of this inside our main `configure` function. However, this
    situation is a really good candidate for an Aurelia feature. If you remember,
    features are similar to plugins, except they are defined inside the application
    itself. By introducing a `validation` feature, we can isolate configuring the
    validation, and this would give us a central location where we can put additional
    services and custom validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating our `validation` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/validation/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `configure` function of our new feature simply loads the `aurelia-validation`
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to load this feature inside our main `configure` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply chain an additional call to the `feature` method of the bootstrapping
    fluent API to load our `validation` feature.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the contact form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that everything is correctly configured, let's add validation to our `contact-edition`
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to tell the validation mechanism what needs to be validated, all the
    two-way bindings used to retrieve user input that we want validated have to be
    decorated with the `validate` binding behavior, which is also provided by `aurelia-validation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add the `validate` binding behavior to every two-way bindings. The
    snippet doesn't depict all bindings of the `contact-edition` form; I'll leave
    it as an exercise to the reader to add `validate` to the bindings on the `value`
    attributes of all `input`, `textarea`, and `select` elements in the template.
    This chapter's sample application from the book's assets can be looked up as a
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: The `validate` binding behavior has two tasks. It first registers the binding
    instruction to the `ValidationController`, which orchestrates validation for a
    given component, so the validation mechanism knows about the property bound by
    the instruction and can validate it when needed. Secondly, it can hook into the
    binding instruction, so the property bound to the element can be validated on
    the spot when the value of the element targeted by the binding instruction changes.
  prefs: []
  type: TYPE_NORMAL
- en: Using ValidationController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ValidationController` acts as a conductor in the validation process. It keeps
    track of a set of bindings that needs to be validated, exposes methods to manually
    trigger validation, and keeps records of current validation errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to leverage `ValidationController`, we must first inject an instance
    in our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we inject a brand new instance of `ValidationController` into our view-model.
    The use of the `NewInstance` resolver is important, because by default the DI
    container considers all services as application singletons, and we really want
    a distinct instance for each component, so they are considered in isolation when
    being validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we simply need to make sure the form is valid before saving any contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we encapsulate the code calling the gateway's `create` or `update` methods
    so it is executed after validation (completes and only if there are no errors).
  prefs: []
  type: TYPE_NORMAL
- en: The `validate` method returns a `Promise`, which is resolved with an array containing
    the validation errors. This means that validation rules can be asynchronous. For
    example, a custom rule could perform an HTTP call to a backend to check for data
    unicity or to perform some further data validation, and the `validate` method's
    resulting `Promise` would be resolved when the HTTP call completes.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Promise` of an asynchronous rule gets rejected, if the HTTP call fails,
    for example, the `Promise` returned by `validate` will also be rejected, so make
    sure you handle rejection at this level when using such asynchronous, remote validation
    rules, so the user knows what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ValidationRules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, validation is ready to roll but won''t do anything, because
    we still haven''t defined any validation rules on our models. Let''s start with
    the `Contact` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/models.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `aurelia-validation`''s fluent API to add validation rules to
    some properties of `Contact`: the `firstName`, `lastName` and `company` properties
    cannot be longer than 100 characters, and the `note` property cannot be longer
    than 2,000 characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we use the `satisfies` method to define an inline, custom rule
    for the `birthday` property. This rule ensures that `birthday` will be valid only
    if it is an empty value or a string that can be parsed into a valid `Date` object.
    We also use the `withMessage` method to specify the template of the error message
    that should be displayed when our custom rule is violated.
  prefs: []
  type: TYPE_NORMAL
- en: The message template uses the same string interpolation syntax as Aurelia's
    templating engine, and can use a context variable named `$displayName`, which
    contains the display name of the property being validated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom validation rules should always accept empty values. This is to maintain
    separation of concerns; the `required` rule already takes care of rejecting empty
    values, so your custom rule should only focus on its own, specific validation
    logic. This way, developers can use your custom rule with or without `required`,
    depending on what they want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `on` method attaches the set of rules just built to the `Contact`
    instance's metadata. This way, when validating properties of a `Contact` object,
    the validation process can retrieve the validation rules that should apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add validation rules to all the classes representing a list
    item in `Contact`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/models.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make every property `required` and specify a maximum length for each
    of them. Additionally, we make sure the `address` property of the `EmailAddress`
    class is a valid email.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering validation errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, the `save` method doesn't send any HTTP request to the backend
    if our form is invalid, which is the correct behavior. However, it still doesn't
    display any error message. Let's see how we can display validation errors to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: The errors property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The controller has an `errors` property containing current validation errors.
    This property can be used, for example, to render a validation summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we add an unordered list, which will be rendered only when
    the validation controller has errors. Inside this list, we repeat a list item
    for each `error`. In each list item, we render the error's `message`.
  prefs: []
  type: TYPE_NORMAL
- en: The validation-errors attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to retrieve, not all validation errors, but only those from
    a narrower scope, using the `validation-errors` custom attribute.
  prefs: []
  type: TYPE_NORMAL
- en: When added to a given element, this attribute gathers the validation errors
    of all the validated binding instructions under its hosting element, and uses
    two-way binding to assign those errors to the property it is bound to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s remove the validation summary from the previous example
    and use the `validation-errors` attribute to render errors for a specific field
    in our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add the `validation-errors` attribute to the `form-group div` containing
    the editor for the `birthday` property, which we bind to a new `birthdayErrors`
    property. We also add the `has-error` CSS class to the `form-group div` if `birthday`
    has any error. Lastly, we add a `help-block span`, which is repeated for each
    error in the `birthdayErrors` array and displays the error's `message`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom ValidationRenderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `validation-errors` attribute allows us to display errors scoped to specific
    areas in the template. However, it would quickly become tedious - and ineffective
    - if we had to add this code for every single property in the form. Thankfully,
    `aurelia-validation` offers a mechanism to extract this logic in a dedicated service,
    named a validation renderer.
  prefs: []
  type: TYPE_NORMAL
- en: A validation renderer is a class that implements a `render` method. This method
    receives a validation rendering instruction object as its first argument. This
    instruction object contains information about which errors should be displayed
    and which should be removed. It is basically a delta between the previous and
    the current validation state, so the renderer knows what changes it must apply
    to the error messages displayed in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, no validation renderers are available as part of Aurelia.
    Chances are some community plugins will shortly provide renderers for major CSS
    frameworks. In the meantime, let''s implement this ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/validation/bootstrap-form-validation-renderer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, we export a class named `BootstrapFormValidationRenderer`, which contains
    a `render` method. This method simply iterates on the `instruction`'s errors to
    `unrender`, then on each of the error's `elements`, and calls a `remove` method
    - which we'll write in a moment. Next, it loops on the `instruction`'s errors
    to `render`, then on each of the error's `elements`, and calls an `add` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to tell our class how to display a validation error, by writing
    the `add` method to our validation renderer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, we retrieve the element with the `form-group` CSS class closest to the
    element hosting the binding instruction that triggered the error, to which we
    add the `has-error` CSS class. Next, we create a `help-block span`, which will
    contain the error's `message`. We also set its `id` attribute using the error's
    `id`, so we can easily find it when it needs to be removed. Lastly, we insert
    this message element in the DOM, right after the element that triggered the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our renderer, let''s write the method that will remove a previously
    rendered validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first retrieve the element with the `form-group` CSS class closest
    to the element hosting the binding instruction which triggered the error. We then
    retrieve the message element using the error's `id`, and we remove it from the
    DOM. Lastly, if the `form-group` doesn't contain any more error messages, we remove
    the `has-error` CSS class from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our validation renderer must now be made available to the application through
    the dependency injection container. Logically, we will do this in the `configure`
    function of our `validation` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/validation/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we register our validation renderer under the name `bootstrap-form`.
    We can then use this name in our `contact-edition` form to tell the validation
    controller that this renderer should be used to display the `form`''s validation
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `validation-renderer` attribute will resolve an instance of our `BootstrapFormValidationRenderer`
    using the name provided as its value and will register it to the current validation
    controller. The controller will then notify the renderer every time a change occurs
    in the validation state, so any new error can be rendered and any resolved error
    can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fact that renderers are registered using string keys enables the registration
    of multiple validation renderers under different names, so different renderers
    can be used in different forms.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the validation trigger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the validation of a property is performed when the element it is
    bound to loses focus. However, this behavior can be changed, by setting the controller''s
    `validateTrigger` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first import the `validateTrigger` enumeration, and we tell the `ValidationController`
    that it should revalidate properties every time the value of the element they
    are bound to changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `change`, the `validateTrigger` enumeration has three other
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blur`: The property is validated when the element hosting the binding instruction
    loses focus. This is the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`changeOrBlur`: The property is validated when the binding instruction changes
    or when the hosting element loses focus. It basically combines the behavior of
    both `change` and `blur`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manual`: Automatic validation is completely disabled. In this case, only a
    call to the controller''s `validate` method, like we do in the `save` method,
    can trigger validation, and it is performed on all registered bindings at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, even if the `validateTrigger` is `blur`, `change`, or `blurOrChange`,
    an explicit call to the `validate` method will always perform validation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom ValidationRules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `aurelia-validation` library makes it easy to add custom validation rules.
    To illustrate this, we will first move the rule we applied to the `birthday` property
    of `Contact` into a reusable `date` validation rule. Then, we will also add validation
    to our contact photo upload component, which will require some custom rules to
    validate files.
  prefs: []
  type: TYPE_NORMAL
- en: Validating a date
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by creating a file which will declare and register our various
    custom rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/validation/rules.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This file doesn't export anything. It just imports the `ValidationRules` class,
    and uses its `customRule` static method to register a new `date` rule, which reuses
    the criteria and the message we previously defined in the `Contact` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to import this file somewhere so the rule is registered and made
    available to the application. The best place to do this is the `validation` feature''s
    `configure` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/validation/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: By importing the `rules` file, the `date` custom rule is registered, so it will
    be usable as soon as the `validation` feature is imported by Aurelia.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can now change `ValidationRules` for the `Contact`''s `birthday`
    property, so it uses this rule instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/models.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply remove the call to `satisfies` for the `birthday` property and
    replace it with a call to `satisfiesRule`, which expects the name of the rule
    as its first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Validating that files are selected
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, the contact photo upload component doesn''t do anything when
    the user clicks on the **Save** button if no file was selected. The first thing
    we can do validation-wise is to make sure a file was selected. As such, we will
    create a new rule named `notEmpty`, which will make sure that the validated value
    has a `length` property greater than zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/validation/rules.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `ValidationRules` class'' `customRule` static method to globally
    register our validation rule. This method expects the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the rule. It must be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The condition function, which is passed the value and the parent object, if
    any. It is expected to return `true` if the rule is fulfilled or `false` if the
    rule is violated. It can also return a `Promise` resolving to a `boolean`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message error template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule will be able to work with any value having a `length` property. It
    can be used for example on an array or on a `FileList` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the size of files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will create a validation rule to make sure that all files in a `FileList`
    instance weigh less than a maximum size:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/validation/rules.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first define a new `maxFileSize` validation rule, which ensures that
    the `size` of every file in the `FileList` does not exceed a given `maximum`.
    The rule applies only if the value is a `FileList` instance and if the `FileList`
    is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: This rule expects a `maximum` parameter. When using such a rule, any argument
    passed to the `satisfiesRule` fluent method is then passed to the underlying condition
    function so it can use it to evaluate the condition. However, in order to be available
    for the message template, the rule arguments must be aggregated inside a single
    object. As such, `customRule` can be passed a fourth argument, which is expected
    to be a function that will aggregate the rule's parameters into a single object.
    This object is then made available to the message template as `$config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we see in our `maxFileSize` rule; it expects to be called with
    a parameter, here named `maximum`, which is the maximum file size in bytes. This
    parameter is expected to be passed to the `satisfiesRule` method when adding the
    rule to a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This parameter is then passed to the condition function, so the size of all
    files in the `FileList` instance can be validated. It is also passed to the aggregation
    function, which returns an object containing `maximum` as a property. This object
    is then available to the message template as `$config`, so the template can display
    the `maximum` in the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Here, our custom rule has only one parameter, but a rule can have as many parameters
    as you need. They will all be passed to the condition function and to the aggregation
    function in the same order in which they are passed to `satisfiesRule`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating file extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lastly, let''s create a rule to ensure that all files in a `FileList` instance
    have an extension that is inside a specific set of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/validation/rules.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This rule, named `fileExtension`, expects an array of file extensions as a parameter,
    and makes sure that the names of all files in the `FileList` end with one of the
    extensions. Like `maxFileSize`, it applies only if the validated value is a `FileList`
    instance that is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the contact photo selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have defined all the rules we need to validate the contact photo
    component, let''s set the view-model up, just like we did with the `contact-edition`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject a `NewInstance` of `ValidationController` in the `ContactPhoto` view-model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explicitly call the `validate` method in `save`, and omit calling `updatePhoto`
    if there are any validation errors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `validation-renderer="bootstrap-form"` attribute to the `form` element
    in the `contact-photo.html` template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `validate` binding behavior to the binding of the `files` property on
    the `file input`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Those tasks being identical to what we have already done for the `contact-edition`
    component, I'll leave them as an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add validation rules to the `photo` property of the view-model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-photo.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we tell the validation controller that the `photo` must contain at least
    one file, which must be either a JPEG or a PNG and must be at most 2 MBs. We also
    customize the message displayed when no file is selected, using the `withMessage`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test this, it should work properly. However, the fact that the validation
    is triggered when the `file input` loses focus makes usability a bit strange.
    In order to have the form validated right when the user closes the browser''s
    file selection dialog, which will display potential error messages right away,
    let''s change the validation controller''s `validateTrigger` to `change`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-photo.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If you test after doing this change, you should find that the usability is much
    better, as the file is validated as soon as the user closes the file selection
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Editing complex structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we created a form to edit, among others, lists of
    items, using a strategy that is referred to as inline edition. The form includes
    input elements for every list item. This strategy reduces to a minimum the number
    of clicks the user has to do to edit or add new list items, because he or she
    can already edit all fields of all list items directly in the form.
  prefs: []
  type: TYPE_NORMAL
- en: However, when a form needs to manage lists of more complex items, one solution
    is to display only the most relevant information in the list as read-only, and
    to use a modal dialog to create or edit items. A dialog leaves much more room
    to display a complex form for a single item.
  prefs: []
  type: TYPE_NORMAL
- en: The `aurelia-dialog` plugin exposes a dialog functionality, which we can leverage
    to create modal editors. To illustrate this, we will fork our contact management
    application and change the `contact-edition` component so it uses dialog edition
    instead of inline edition for list items.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippets are excerpts of `chapter-4/samples/list-edition-models`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the dialog plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the `aurelia-dialog` plugin, simply fire up a console in the project
    directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installation is completed, we also need to add the plugin to the vendor
    bundle configuration. To do this, open `aurelia_project/aurelia.json` and, under
    `build`, then `bundles`, in the `dependencies` array of the bundle named `vendor-bundle.js`,
    add the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to load the plugin in our main `configure` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the services and components exposed by `aurelia-dialog` are ready
    to be used in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the edition dialogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dialog plugin uses composition to display a component as a dialog. This
    means that the next step is to create the components that will be used to edit
    a new or an existing item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the behavior behind dialog edition will be the same whatever the type
    of the item being edited, we will create a single view-model, which we will reuse
    for phone numbers, email addresses, addresses, and social profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/dialogs/edition-dialog.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a component in which we inject a `DialogController` and a `NewInstance`
    of the `ValidationController` class. Next, we define an `activate` method receiving
    the `model`, which will be the item to edit - the phone number, email address,
    address, or social profile. We also define an `ok` method which validates the
    form and, if there are no errors, calls the `ok` method of `DialogController` with
    the updated `model` as the dialog's output. Finally, we define a `cancel` method,
    which simply delegates to the `cancel` method of `DialogController`.
  prefs: []
  type: TYPE_NORMAL
- en: A `DialogController`, when injected in a component displayed as a dialog, is
    used to control the dialog into which the component is displayed. Its `ok` and
    `cancel` methods can be used to close the dialog and to return a response to the
    caller. This response can then be used by the caller to determine if the dialog
    was canceled or not and to retrieve its output, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we will reuse the same view-model class for all item types, the
    templates must be different for each item type. Let''s start with the dialog edition
    for phone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/dialogs/phone-number-dialog.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Here, the notable parts are the `ai-dialog`, `ai-dialog-body`, and `ai-dialog-footer`
    elements, which are containers for an Aurelia dialog. Additionally, the `attach-focus="true"`
    attribute on the `select` element makes sure that this element is given the focus
    when the dialog is displayed. Lastly, the `submit` event of `form` delegates to
    the `ok` method, while a `click` on the cancel `button` delegates to the `cancel`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the template should be familiar. The user input elements are bound
    to the properties of `model`, and those bindings are decorated with the `validate`
    binding behavior so the properties are properly validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create the templates for the other item types: `src/dialogs/email-address-dialog.html`,
    `src/dialogs/address-dialog.html`, and `src/dialogs/social-profile-dialog.html`.
    At this point, those templates should be easy to create. I''ll leave it as an
    exercise to the reader to write them; the `list-edition-models` sample can be
    used as a reference.'
  prefs: []
  type: TYPE_NORMAL
- en: Using edition dialogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step to leverage our new view-model and templates is to change the
    behavior of the `contact-edition` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a new dependency to our `ContactEdition` view-model by injecting
    a `DialogService` into its constructor. We next define a `_openEditDialog` method,
    which defines a common behavior to open an edition dialog.
  prefs: []
  type: TYPE_NORMAL
- en: This method calls the `open` method of `DialogService` to open a dialog, using
    the `edition-dialog` view-model and a given item type's template, composed as
    a single component. A given `model` is also passed to it, which will be injected
    in the `activate` method of `edition-dialog`. This should be familiar if you read
    the section about composition in [Chapter 3](ch03.html "Chapter 3. Displaying
    Data"), *Displaying Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the method returns a `Promise`, which will be resolved when the
    user clicks **Ok**, but rejected when he clicks **Cancel**. This way, when using
    this method, the resulting Promise will be resolve only when the user confirms
    its modifications by clicking **Ok** and will be rejected otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The `editPhoneNumber` method uses the `_openEditDialog` method to display the
    phone number edition dialog. A copy of the `phoneNumber` to edit is passed as
    the `model` because, if we pass the original `phoneNumber` object, it will be
    modified even if the user cancels its modifications. When the `Promise` resolves,
    which happens when the user confirms its modifications, the updated `model` properties
    are assigned back to the original `phoneNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `addPhoneNumber` method uses the `_openEditDialog` method, but
    passes a new `PhoneNumber` instance as the model. Additionally, when the `Promise`
    resolves, the new phone number is added to the `phoneNumbers` array of `contact`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the template must be changed, so the list of phone numbers is displayed
    as read-only, and a new **Edit** button must be added for each phone number:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-edition.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, we remove the `select` and `input` elements and replace them with string
    interpolation instructions to display the `type` and `number` properties of `phoneNumber`.
    We also add an **Edit** button, which, when clicked, calls the new `editPhoneNumber`
    method. Lastly, we change the **Add** button so it calls the new `addPhoneNumber`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the same changes must be applied to both the view-model and the template
    of the `contact-edition` component for the other item types. However, changing
    the inline edition strategy for the email addresses, the addresses, and the social
    profiles for dialog edition should be straightforward to you now; I'll leave this
    as an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating forms is simple with Aurelia, it is mostly a matter of leveraging two-way
    binding. Validating forms is also easy, thanks to the validation plugin. Additionally,
    the abstraction layer in the validation plugin allows us to use the validation
    library we want, even though the default implementation provided by the plugin
    is already pretty powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The power of Aurelia will really start to become clear in the next chapter.
    By leveraging what we saw up to now, and adding custom attributes, custom elements,
    and content projection to the mix, we will be able to create extremely powerful,
    reusable, and extensible components, composing them into modular and testable
    applications. Of course, while covering those topics, we will heavily refactor
    our contact management application to extract components and reusable behaviors
    from our existing code base, while we add features that would be undoable without
    custom elements and attributes.
  prefs: []
  type: TYPE_NORMAL
