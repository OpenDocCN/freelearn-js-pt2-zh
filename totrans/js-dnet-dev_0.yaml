- en: Chapter 10. Testing and Debugging JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 JavaScript的测试与调试
- en: In every software life cycle, testing and debugging play an important role.
    Thorough testing makes software flawless and good debugging techniques makes it
    easy to not only troubleshoot problems, but also helps to identify and fix any
    problems by reaching out to the exact point.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一个软件生命周期中，测试和调试都扮演着重要的角色。彻底的测试可以使软件无懈可击，而良好的调试技术不仅可以帮助解决问题，还能帮助准确地识别并修复问题。
- en: Testing is the core essence of creating any robust application. However, there
    are different practices and frameworks used by the application to serve particular
    objective, and the architecture varies as per the nature of the application. Therefore,
    sometimes it becomes difficult for a developer to test client-side code, for example,
    if an application contains some JavaScript code on a page itself, such as inline
    event handlers, make it tightly coupled with the page. On the other hand, even
    when modularizing the JavaScript code into different modules bring some test suite
    limitations and become harder to execute the testing process of an application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是创建任何健壮应用程序的核心本质。然而，不同的应用程序采用不同的实践和框架来达到特定的目标，架构也会根据应用程序的性质而有所不同。因此，有时对于开发者来说测试客户端代码会变得困难，例如，如果一个应用程序在其页面中包含一些JavaScript代码，如内联事件处理程序，会使它与页面紧密耦合。另一方面，即使将JavaScript代码模块化，也会带来一些测试套件限制，并使应用程序的测试过程更难以执行。
- en: Debugging is the process of finding and fixing errors in an application. It
    is one of the most important and core skillset in software development. If developers
    have a solid grasp on the debugging tools and know the ins and outs of debugging,
    they can quickly identify the root cause and start fixing the errors. Debugging
    is a basic process in any software development life cycle. Whether application
    is a complex one or a simple one, to trace and rectify errors debugging plays
    an important role. It helps the developer to break the program execution through
    breakpoints and identify the program flow by stepping into the chain of program
    execution. Moreover, there is other useful information almost all debugging tools
    provide, such as watching the current state of the variables or objects being
    used within the program and watching them on every stage of the debugging life
    cycle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是查找并修复应用程序中错误的过程。它是软件开发中最重要的核心技能之一。如果开发者能够熟练掌握调试工具并了解调试的方方面面，他们就可以快速地识别根本原因并开始修复错误。调试是任何软件开发生命周期中的基本过程。无论应用程序是复杂的还是简单的，调试都起着重要的作用，以追踪并修正错误。它帮助开发者通过设置断点来中断程序执行，并逐步进入程序执行链以识别程序流程。此外，几乎所有的调试工具都提供其他有用的信息，例如观察程序中正在使用的变量或对象的状态，并在调试生命周期的每个阶段观察它们。
- en: Testing the JavaScript code
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试JavaScript代码
- en: Normally, web applications go through different types of testing, such as **user
    interface** (**UI**) testing, which checks the functionality of the UI by making
    certain inputs to the form and verifies the behavior of an application. This type
    of testing is mostly done manually or through automated testing tools. The other
    type of testing is **load testing**, which is used mostly to check the performance
    of an application and by putting up some load on the application. In simple terms,
    it can be an example of signing in to an application with many number of users
    or doing some operations through automated routines to test how the application
    behaves. There are a few more testing types, but the most essential type of testing
    that ensures the functionality of the application and certifies whether the application
    complies with the requirements is unit testing. In this section, we will discuss
    about unit testing JavaScript code using Jasmine (a popular JavaScript unit test
    framework) and use it with Karma and Grunt to execute test cases in an ASP.NET
    application using Visual Studio 2015 IDE.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络应用会经历各种类型的测试，比如**用户界面**（**UI**）测试，它通过向表单输入特定数据来检查UI的功能，并验证应用程序的行为。这种类型的测试大多是通过人工操作或自动化测试工具来完成的。另一种测试类型是**压力测试**，主要用于检查应用程序的性能，通过给应用程序施加一些负载来进行。简而言之，这可以作为一个例子，即有大量用户登录应用程序，或者通过自动化脚本来执行一些操作，以测试应用程序的行为。还有其他一些测试类型，但最基本的测试类型是单元测试，它确保应用程序的功能，并验证应用程序是否符合要求。在本节中，我们将讨论如何使用茉莉（一个流行的JavaScript单元测试框架）对JavaScript代码进行单元测试，并将其与Karma和Grunt一起使用，在ASP.NET应用程序中使用Visual
    Studio 2015 IDE执行测试用例。
- en: Unit testing
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is a method to test individual units of modules together with associated
    data and procedures to verify the application's functionality compliance to the
    requirements. Unit testing is done by developers, and it allows developers to
    test each use case of the application to guarantee that it meets the requirement
    and works as expected.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种测试模块中个别单元以及相关数据和程序的方法，以验证应用程序的功能是否符合要求。单元测试由开发者完成，它允许开发者测试应用程序的每个用例，以确保它符合要求并按预期工作。
- en: The basic advantage of unit testing is that it separates each part of the application
    into a smaller unit and helps developers to focus and identify the bug initially
    during the development cycle. Unit testing is the first testing any application
    endures and allow testers and developers to release the application for **user
    acceptance testing** (**UAT**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的基本优点是将应用程序的每个部分分离成更小的单元，帮助开发者在开发周期初期集中精力并识别错误。单元测试是应用程序承受的第一次测试，允许测试人员和开发者将应用程序发布用于**用户验收测试**（**UAT**）。
- en: Writing unit tests
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: To test JavaScript code, there are many testing suites available. The most popular
    ones are Jasmine, Mocha, and QUnit. In this chapter, we will use Jasmine with
    Karma and Grunt.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试JavaScript代码，有许多测试套件可供选择。最受欢迎的是茉莉、摩卡和QUnit。在本章中，我们将使用茉莉与Karma和Grunt一起使用。
- en: Jasmine
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 茉莉
- en: Jasmine is a behavior-driven development framework for testing JavaScript code.
    This provides certain functions such as `it()`, `describe()`, `expect()`, and
    so on to write test scripts for the JavaScript code. The basic advantage of this
    framework is that it is very easy to understand and helps to write the test JavaScript
    code with very simple lines of code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 茉莉是一个用于测试JavaScript代码的行为驱动开发框架。它提供了某些函数，如`it()`、`describe()`、`expect()`等，以便为JavaScript代码编写测试脚本。这个框架的基本优点是它非常容易理解，并帮助用非常简单的代码行编写测试JavaScript代码。
- en: 'For example, consider the following JavaScript code that sums up two numbers
    passed as parameters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下JavaScript代码，它计算作为参数传递的两个数字的和：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The test case for the preceding function will look similar to the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面函数的测试用例将类似于以下内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Karma
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 卡玛
- en: Karma is a test runner for JavaScript that can be integrated with other testing
    frameworks such as Jasmine, Mocha, and so on. It executes test cases defined through
    Jasmine or other test frameworks by providing a mock test environment and load
    browsers that executes the test JavaScript code according to the configuration.
    The Karma configuration file is known as `Karma.config.js`. Once the tests are
    executed, the results are displayed in the console window.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Karma是一个可以与Jasmine、Mocha等其他测试框架集成的JavaScript测试运行器。它通过提供模拟测试环境和加载浏览器来执行通过Jasmine或其他测试框架定义的测试用例，并根据配置执行测试JavaScript代码。Karma配置文件称为`Karma.config.js`。测试执行后，结果将显示在控制台窗口中。
- en: Grunt
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Grunt
- en: Grunt is equivalent to Gulp. It is used to execute tasks such as minification
    of CSS file or JavaScript files, concatenation and merging of multiple JavaScript
    file, and so on. Grunt has hundreds of plugins that can be used to automate specific
    tasks. Unlike the previous chapters, where we used Gulp, we will use Grunt and
    see what it provides with Karma (test runner) and Jasmine (testing suite). Grunt
    and Gulp are both renowned task runners for development. The reason for using
    Grunt here is to get an understanding of another task runner of JavaScript that
    is equally renowned and supported by Visual Studio 2015 and discuss the packages
    that it provides to perform testing using Karma and Jasmine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt相当于Gulp。它用于执行任务，如CSS文件或JavaScript文件的压缩，多个JavaScript文件的合并和拼接等。Grunt有数百个插件可用于自动化特定任务。与前面章节中使用的Gulp不同，我们将使用Grunt并了解它与Karma（测试运行器）和Jasmine（测试套件）一起提供的内容。Grunt和Gulp都是知名的开发任务运行器。在这里使用Grunt的原因是为了了解另一种同样知名且受到Visual
    Studio 2015支持的JavaScript任务运行器，并讨论它提供以使用Karma和Jasmine进行测试的包。
- en: Developing unit test using Jasmine, Karma, and Grunt
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Jasmine、Karma和Grunt开发单元测试
- en: In this section, we will develop a simple unit test to show how unit testing
    can be done in an ASP.NET Core application using Jasmine, Karma, and Grunt frameworks.
    To start with, create an ASP.NET Core application from Visual Studio 2015.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用Jasmine、Karma和Grunt框架来开发一个简单的单元测试，以展示如何在ASP.NET Core应用程序中进行单元测试。首先，从Visual
    Studio 2015创建一个ASP.NET Core应用程序。
- en: Adding packages
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加包
- en: 'Open the `package.json` file in your ASP.NET Core application and add packages
    such as `grunt`, `grunt-karma`, `karma`, `karma-phantomjs-launcher`, `karma-jasmine`,
    `karma-spec-reporter`, and `karma-cli`, as shown in the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的ASP.NET Core应用程序中打开`package.json`文件，并添加如`grunt`、`grunt-karma`、`karma`、`karma-phantomjs-launcher`、`karma-jasmine`、`karma-spec-reporter`和`karma-cli`等包，如下所示：
- en: '![Adding packages](img/00119.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![添加包](img/00119.jpeg)'
- en: 'The following table shows the description of each package:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了每个包的描述：
- en: '| Package Name | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 包名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `grunt` | This configures and runs tasks |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `grunt` | 配置和运行任务 |'
- en: '| `grunt-karma` | This is the Grunt plugin for the Karma test runner |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `grunt-karma` | 这是用于Karma测试运行器的Grunt插件 |'
- en: '| `karma` | This is the test runner for JavaScript |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `karma` | 这是用于JavaScript的测试运行器 |'
- en: '| `karma-phantomjs-launcher` | This is the Karma plugin to launch the PhantomJS
    browser |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `karma-phantomjs-launcher` | 这是用于启动PhantomJS浏览器的Karma插件 |'
- en: '| `karma-jasmine` | This is the Karma plugin for the Jasmine test suite |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `karma-jasmine` | 这是用于Jasmine测试套件的Karma插件 |'
- en: '| `karma-spec-reporter` | This is the Karma plugin to report test results to
    the console |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `karma-spec-reporter` | 这是用于将测试结果报告至控制台的Karma插件 |'
- en: '| `karma-cli` | This is the Karma command-line interface |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `karma-cli` | 这是Karma命令行界面 |'
- en: Adding the Grunt file
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加Grunt文件
- en: Add `Gruntfile.js` in your ASP.NET application to define Grunt tasks. `Gruntfile.js`
    is the main file where all the tasks are configured. Configured tasks can be seen
    in Visual Studio from the **Task Runner Explorer** window.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的ASP.NET应用程序中添加`Gruntfile.js`以定义Grunt任务。`Gruntfile.js`是主文件，其中配置了所有任务。配置的任务可以在Visual
    Studio的**任务运行器浏览器**窗口中看到。
- en: Adding Karma specifications
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加Karma规格
- en: The `Gruntfile.js` file provides the main `initConfig()` method that is called
    when the Grunt is loaded. This is the starting point where we define the Karma
    specifications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gruntfile.js`文件提供了主要的`initConfig()`方法，在加载Grunt时调用。这是定义Karma规格的起点。'
- en: 'The following is the Karma specifications defined within the `initConfig()`
    method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`initConfig()`方法中定义的Karma规格：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding script, we first started by specifying the target platform
    for Karma. Inside `karma`, we will specify the unit that is used to run unit tests.
    Inside `unit`, we can define certain configuration attributes such as `frameworks`,
    `singleRun`, `browsers`, and `files`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，我们首先指定了Karma的目标平台。在`karma`内部，我们将指定用于运行单元测试的单元。在`unit`内部，我们可以定义某些配置属性，如`frameworks`、`singleRun`、`browsers`和`files`：
- en: '`frameworks`: This is an array of test frameworks that we want to use. In this
    exercise, we used Jasmine. However, other frameworks such as Mocha and QUnit can
    also be used.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frameworks`：这是我们想要使用的测试框架数组。在这个练习中，我们使用了Jasmine。然而，也可以使用其他框架，如Mocha和QUnit。'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please note that when using any framework in Karma, an additional plugin/library
    of that framework has to be separately installed using **Node Package Manager**
    (**NPM**).
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，在Karma中使用任何框架时，必须使用**Node包管理器**（**NPM**）单独安装该框架的附加插件/库。
- en: '`singleRun`: If this is set to `true`, Karma start capturing the configured
    browser(s) and executes tests on them. Once the tests are completed, it exits
    smoothly.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleRun`：如果将其设置为`true`，Karma将开始捕获配置的浏览器(s)并在它们上执行测试。一旦测试完成，它将顺利退出。'
- en: '`browsers`: This is an array to define multiple browsers in a comma-separated
    value. We have used PhantomJS in our example, which is a headless browser and
    runs the test in background. Karma supports other browsers such as Chrome, Firefox,
    IE, and Safari, and these can be configured through this property.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browsers`：这是一个数组，用于定义用逗号分隔的多个浏览器。在我们的示例中使用了PhantomJS，它是一个无头浏览器，在后台运行测试。Karma支持其他浏览器，如Chrome、Firefox、IE和Safari，这些可以通过此属性进行配置。'
- en: '`files`: This contains all the test files, source files, and dependencies.
    For example, if we are using jQuery in our test scripts, or original source code,
    we can add the path to this library as well. In the preceding configuration, we
    used wildcard characters to load all the source files defined under the `js` folder,
    and tests files under the `tests` folder with a `test.js` suffix.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：这包含所有测试文件、源文件和依赖项。例如，如果我们正在使用jQuery测试脚本，或原始源代码，我们也可以添加这个库的路径。在前面的配置中，我们使用了通配符来加载`js`文件夹下定义的所有源文件，以及带有`test.js`后缀的`tests`文件夹下的测试文件。'
- en: 'There are many more attributes that can be used in the Karma configuration
    and it can be referred here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karma配置中还可以使用许多其他属性，可以在此处参考：
- en: '[http://karma-runner.github.io/0.13/config/configuration-file.html](http://karma-runner.github.io/0.13/config/configuration-file.html)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://karma-runner.github.io/0.13/config/configuration-file.html](http://karma-runner.github.io/0.13/config/configuration-file.html)'
- en: Load npm task
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加载npm任务
- en: 'To load the Karma test runner tool, we need to specify it in `Gruntfile.js`
    after the Karma configuration, as shown in the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Gruntfile.js中加载Karma测试运行器，需要在Karma配置后面指定它，如下所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Register task
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册任务
- en: 'Finally, we will add the Grunt task to register tasks. The first parameter
    is the task name, which will be available in the **Task Runner Explorer** in Visual
    Studio, and the second parameter takes an array to execute multiple tasks:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将向Grunt任务添加任务注册。第一个参数是任务名称，它将出现在Visual Studio的**任务运行器浏览器**中，第二个参数接受一个数组，以执行多个任务：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Source JavaScript file
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 源JavaScript文件
- en: In this example, we have a `product.js` file that contains a `saveProduct()`
    method, which will be invoked on the **Save** button's click event.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个`product.js`文件，它包含一个`saveProduct()`方法，该方法将在点击**保存**按钮事件时被调用。
- en: 'Add this file to the `wwwroot/js` folder path:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件添加到`wwwroot/js`文件夹路径中：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a recommended approach to keep your JavaScript code separate from your
    HTML markup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript代码与HTML标记分开是一种推荐的方法。
- en: Adding unit test script file
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加单元测试脚本文件
- en: Here, we will add another JavaScript file under the `wwwroot/tests` folder and
    named it `product.test.js`. When writing tests, you can add the `*.test.js` suffix
    to make it uniquely identified, and separates it from the source JavaScript files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在`wwwroot/tests`文件夹下添加另一个JavaScript文件，并将其命名为`product.test.js`。在编写测试时，可以添加`*.test.js`后缀以使其唯一标识，并将其与源JavaScript文件区分开来。
- en: 'Here is the code for `product.test.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`product.test.js`的代码：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Jasmine framework provides certain keywords to define specific blocks that
    run on specific conditions, which are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine框架提供了一些特定的关键字来定义在特定条件下运行的特定块，如下所示：
- en: '`describe()`: This is a global Jasmine function that contains two parameters:
    a string and a function. The string is the name of the functionality that is going
    to be tested. The function contains the code that actually implements the Jasmine
    suite and contains logic of unit tests.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe()`：这是一个全局Jasmine函数，包含两个参数：一个字符串和一个函数。字符串是要测试的功能的名称。该函数包含实际实现Jasmine套件的代码并包含单元测试的逻辑。'
- en: '`it()`: Here, specs are defined by calling the global Jasmine function `it()`.
    This also takes the string and function, where it contains the actual unit test
    name and the function block contains the actual logic of the code to be executed
    followed with the expected results.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it()`：在这里，通过调用全局Jasmine函数`it()`定义规格。这也需要一个字符串和一个函数，其中它包含实际的单元测试名称和函数块包含要执行的实际代码逻辑以及预期结果。'
- en: '`expect()`: The expected results can be specified by using the `expect()` function
    that takes some value defined within the `it()` function. This is also chained
    with a matcher function, such as `toBe()` or `not.toBe()`, to match or unmatch
    the expected value.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect()`：预期的结果可以通过在`it()`函数内定义一些值来使用`expect()`函数来指定。这也与一个匹配器函数（如`toBe()`或`not.toBe()`）相链，以匹配或取消匹配预期值。'
- en: In .NET, it is equivalent to the **Arrange**, **Act**, and **Assert** pattern.
    Here, Arrange is used to initialize objects and set values of the data that is
    passed to the method under test. The Act pattern actually invokes the method under
    test, and Assert verifies that the method under test behaves as expected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，它相当于**准备**、**行动**和**断言**模式。在这里，准备用于初始化对象并设置传递给测试方法的数据的值。实际调用测试方法的实际模式，断言验证测试方法如预期行为。
- en: Running test task
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行测试任务
- en: 'Running these tasks is straightforward, it can simply be run through the **Task
    Runner Explorer** window in Visual Studio 2015\. Here is the screenshot of the
    **Task Runner Explorer** window that shows the tasks defined in `Gruntfile.js`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些任务很简单，它可以通过Visual Studio 2015的**任务运行器浏览器**窗口直接运行。以下是显示`Gruntfile.js`中定义的任务的**任务运行器浏览器**窗口的屏幕截图：
- en: '![Running test task](img/00120.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试任务](img/00120.jpeg)'
- en: 'When we run the test task, it will show something similar to the following
    output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试任务时，它将显示如下类似输出：
- en: '![Running test task](img/00121.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试任务](img/00121.jpeg)'
- en: In our `product.test.js` test script, we have two tasks. One is to check whether
    passing the string values to one of the two elements such as `txtProdUnitPrice`
    and `txtProdQuantity` will return `0`. As our `product.js` file does not handle
    this condition, it will give an error.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`product.test.js`测试脚本中，我们有两个任务。一个是检查传递字符串值到两个元素中的`txtProdUnitPrice`和`txtProdQuantity`中的任何一个是否会返回`0`。由于我们的`product.js`文件没有处理这个条件，它会给出一个错误。
- en: 'To fix this, we will modify our `product.js` and add these two lines to handle
    this logic to check whether the value is a number or not:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将修改我们的`product.js`并在其中添加这两行以处理此逻辑：检查值是否为数字：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, when we run our test again, we will get the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行我们的测试时，我们将得到以下输出：
- en: '![Running test task](img/00122.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试任务](img/00122.jpeg)'
- en: In the preceding example, we defined the HTML markup within the `beforeEach()`
    function in the `product.test.js` file. With simple applications, this may not
    be a cumbersome process to redefine the HTML markup as fixtures and use them to
    execute tests. However, most web applications are using some client-side frameworks
    such as Knockout, AngularJS, and so on, that separates the binding of controls
    specified in an HTML view to a ViewModel, and this ViewModel is responsible to
    read or write control values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在`product.test.js`文件中的`beforeEach()`函数内定义了HTML标记。对于简单的应用程序，重新定义HTML标记作为固定项并使用它们来执行测试可能不是一个繁琐的过程。然而，大多数Web应用程序都在使用一些客户端框架，如Knockout、AngularJS等，这些框架将HTML视图中指定的控件绑定到ViewModel，这个ViewModel负责读取或写入控件值。
- en: In the following example, we will use the Knockout JavaScript library that implements
    an Model-View-ViewModel pattern and see how unit tests can be written in this
    way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用实现模型-视图-视图模型模式的Knockout JavaScript库，并了解如何以这种方式编写单元测试。
- en: Implementing Model-View-ViewModel using Knockout and Run test
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Knockout实现模型-视图-视图模型并运行测试
- en: '**Model-View-ViewModel** (**MVVM**) is a design pattern for building user interfaces.
    It is divided into three parts, as show in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）是构建用户界面的设计模式。它分为三部分，如下面的图表所示：'
- en: '![Implementing Model-View-ViewModel using Knockout and Run test](img/00123.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用Knockout实现Model-View-ViewModel并运行测试](img/00123.jpeg)'
- en: 'These three parts are described as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个部分如下所述：
- en: '**Model**: This contains the backend logic to invoke backend services and save
    or retireve data by communicating with the persistant storage.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这包含调用后端服务并通过与持久存储通信来保存或检索数据的后台逻辑。'
- en: '**ViewModel**: This contains the view-specific operations and data. It represents
    the model of the view to which the view elements binds to. For example, a form
    that contains some HTML elements will have a ViewModel, which is an object containing
    some properties to bind these controls with the data.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：这包含与视图相关的操作和数据。它表示与视图元素绑定的视图模型。例如，包含一些HTML元素的表单将有一个视图模型，这是一个包含一些属性的对象，用于将这些控件与数据绑定。'
- en: '**View**: This is the user interface to which the user interacts. It displays
    information from the ViewModel, raises events at the ViewModel, and updates it
    when the ViewModel changes.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是用户与之交互的用户界面。它显示来自视图模型的信息，在视图模型上引发事件，并在视图模型更改时更新它。'
- en: Let's implement the MVVM pattern using the **Knockout** JavaScript library using
    the following steps.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下步骤使用**Knockout** JavaScript库实现MVVM模式。
- en: Adding the Knockout package
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加Knockout包
- en: To start with, let's add Knockout.js in your ASP.NET Core application through
    `bower.json`. It can be added by making an entry in the dependencies section of
    the `bower.json` file, and Visual Studio automatically downloads the package and
    places it in the `wwwroot/lib/knockout` folder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过`bower.json`在你的ASP.NET Core应用程序中添加Knockout.js。可以通过在`bower.json`文件的依赖项部分添加条目来实现，Visual
    Studio会自动下载包并将其放在`wwwroot/lib/knockout`文件夹中。
- en: 'The following statement can be added in the `bower.json` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句可以添加到`bower.json`文件中：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding ProductViewModel
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加ProductViewModel
- en: '`ProductViewModel` contains properties such as the product code, unit price,
    quantity, expiry, and total amount. Here is the code snippet of `ProductViewModel.js`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductViewModel`包含产品代码、单价、数量、到期日和总金额等属性。以下是`ProductViewModel.js`的代码片段：'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`ko` is basically the Knockout object that provides a complimentary way of
    linking an object model to the View, where `ko.observable()` is a Knockout function
    that makes the Model properties observable and sync with the View data. This means
    that when the ViewModel property''s value changes, View is updated; and when the
    control value is modified, the ViewModel property is updated.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko`实际上是提供将对象模型与视图链接的互补方式的Knockout对象，其中`ko.observable()`是一个Knockout函数，使模型属性变得可观察并同步视图数据。这意味着当视图模型属性的值发生变化时，视图也会更新；当控件值被修改时，视图模型属性也会更新。'
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`ko.applyBindings()` actually activates Knockout to perform the binding of
    the Model properties with the View elements.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.applyBindings()`实际上激活了Knockout，以执行模型属性与视图元素的绑定。'
- en: Add the Product view
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加产品视图
- en: Knockout provides a very decent way of binding ViewModel properties to the control
    elements. Binding consist of two items, name and value, separated by a colon.
    To bind the ViewModel with the input elements, we can use the data-bind attribute
    and specify the value name followed with `:` and ViewModel's property name. Each
    control has a specific set of properties and it can be used to bind elements accordingly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout提供了一种非常合适的方式来将视图模型属性与控件元素绑定。绑定包括两部分，名称和值，由冒号分隔。要绑定视图模型与输入元素，我们可以使用data-bind属性，指定值名称后跟`:`和视图模型的属性名称。每个控件都有一组特定的属性，可以用来相应地绑定元素。
- en: 'For example, the `span` element can bind to the view model property using the
    text name as shown in the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用以下方式将`span`元素绑定到视图模型属性：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the modified version of the Product view:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是产品视图的修改版本：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is all what we need to configure Knockout in the Product view. When the
    `btnSaveProduct` button is clicked, it will calculate the total amount and call
    the product service to save the record.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在产品视图中配置Knockout所需的所有内容。当点击`btnSaveProduct`按钮时，它会计算总金额并调用产品服务以保存记录。
- en: Modifying test configuration
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改测试配置
- en: 'Here is the modified version of `Gruntfile.js` created earlier. We added the
    `ProductViewModel.js` and the Knockout dependency in the `files` array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是之前创建的`Gruntfile.js`的修改版本。我们在`files`数组中添加了`ProductViewModel.js`和Knockout依赖项：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Modifying the product-testing script
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改产品测试脚本
- en: 'As we are not dependent on the HTML view directly, we can test our unit test
    cases through the Product view model. Here is the modified version of `product.test.js`
    that does not have any of the fixtures defined:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不直接依赖HTML视图，因此可以通过产品视图模型来测试我们的单元测试用例。以下是`product.test.js`的修改版本，其中没有定义任何测试数据：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following output will be generated when the test is run:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，将生成以下输出：
- en: '![Modifying the product-testing script](img/00124.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![修改产品测试脚本](img/00124.jpeg)'
- en: Debugging JavaScript
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试JavaScript
- en: JavaScript runs on client browsers, and almost all browsers, such as Internet
    Explorer, Microsoft Edge, Chrome, and Firefox, provide the integrated JavaScript
    debugger and **Developer Tools** window. With Visual Studio, we can also debug
    the JavaScript code by setting Internet Explorer as the default browser. Chrome
    is not supported out of the box, but with certain steps, its can be achieved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在客户端浏览器上运行，几乎所有浏览器，如Internet Explorer、Microsoft Edge、Chrome和Firefox，都提供了集成的JavaScript调试器和**开发者工具**窗口。使用Visual
    Studio，我们还可以通过将Internet Explorer设置为默认浏览器来调试JavaScript代码。Chrome默认不受支持，但通过某些步骤，可以实现。
- en: Debugging options in Visual Studio 2015
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio 2015中的调试选项
- en: Visual Studio provides certain decent features to debug JavaScript and troubleshoot
    errors. JavaScript debugging in Visual Studio only works with Internet Explorer.
    Debugging can be started by starting the application in a debug mode and then
    placing some breakpoints in the JavaScript code. When the breakpoint is hit, we
    can use all sorts of debugging options in Visual Studio that we already know of
    and used in debugging the C# and VB.NET code. Options such as Step into (*F11*),
    Step over (*F10*), Step out (*Shift* + *F11*), conditional breakpoints, and watches,
    all work with the JavaScript code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio提供了一些不错的功能来调试JavaScript和解决错误。在Visual Studio中，只有与Internet Explorer一起使用时才能调试JavaScript。通过以调试模式启动应用程序，然后在JavaScript代码中放置一些断点来开始调试。当断点被击中时，我们可以使用在调试C#和VB.NET代码时已经知道的Visual
    Studio中的所有调试选项，如逐进入(*F11*)，逐过(*F10*)，逐出(*Shift* + *F11*)，条件断点，和观察变量，这些都适用于JavaScript代码。
- en: Debugging from Visual Studio with Internet Explorer
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Visual Studio使用Internet Explorer进行调试
- en: 'The default browser in Visual Studio for a particular web application project
    can be set from the **Web Browser (Internet Explorer)** | **Internet Explorer**
    option, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，可以为特定网络应用项目设置默认浏览器，方法是在**Web浏览器(Internet Explorer)** | **Internet
    Explorer**选项中进行设置，如下面的屏幕截图所示：
- en: '![Debugging from Visual Studio with Internet Explorer](img/00125.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![使用Visual Studio和Internet Explorer进行调试](img/00125.jpeg)'
- en: Debugging from Visual Studio with Google Chrome
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Visual Studio使用Google Chrome进行调试
- en: Visual Studio 2015 does not provide out-of-the-box support to debug JavaScript
    applications, except with Internet Explorer. Alternatively, with Node.js, debugging
    works perfectly fine in Visual Studio, and as technically, both Node.js and Google
    Chrome are based on the V8 engine, there is no drawback.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015不提供内置支持来调试JavaScript应用程序，除了与Internet Explorer一起使用。另外，通过Node.js，Visual
    Studio中的调试工作得非常好，技术上，Node.js和Google Chrome都基于V8引擎，因此没有缺点。
- en: 'To start debugging with Chrome in Visual Studio, we have to run the Google
    `chrome.exe` file with a remote-debugger argument. The following command runs
    Google Chrome with remote debugging, and from Visual Studio, it can be attached
    by pointing to the same Chrome instance:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Chrome在Visual Studio中开始调试，我们必须使用远程调试参数运行Google `chrome.exe`文件。以下命令通过远程调试运行Google
    Chrome，并从Visual Studio中指向相同的Chrome实例：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`9222` is the default port where Visual Studio connects on attaching to its
    process.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`9222`是Visual Studio连接其进程的默认端口。'
- en: From the Visual Studio, you can attach the process by hitting *Ctrl* + *Alt*
    + *P*, or by going to **Debug** | **Attach to Process** in menu bar and selecting
    the Chrome instance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Studio中，您可以通过按*Ctrl* + *Alt* + *P*，或者通过在菜单栏中选择**调试** | **附加到进程**来附加进程，然后选择Chrome实例。
- en: Developer Tools
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者工具
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The **Breakpoints** tab shows the list of all the breakpoints being used in
    the script, and the users can manage these breakpoints by enabling or disabling
    and deleting or adding new events:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**断点**选项卡显示了脚本中正在使用的所有断点列表，用户可以通过启用或禁用、删除或添加新事件来管理这些断点：'
- en: '![Debugging options in Microsoft Edge](img/00127.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Microsoft Edge中的调试选项](img/00127.jpeg)'
- en: Debugging can only start if the **F12 Developers Tools** window is opened and
    this can be opened through the **…** | **F12 Developer Tools** window option from
    menu bar or by hitting the *F12* key. Once the window is opened, you can set breakpoints
    on the JavaScript code and take specific actions on the page.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当打开了**F12开发者工具**窗口时，调试才能开始，可以通过菜单栏的**…** | **F12开发者工具**窗口选项或按下*F12*键来打开该窗口。窗口打开后，你可以在JavaScript代码上设置断点并对页面执行特定操作。
- en: 'The following table shows some important options available in the debugger
    toolbar:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了调试工具栏中一些重要的选项：
- en: '| Icon | Option | Shortcut Key | Description |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: 图标 | 选项 | 快捷键 | 描述 |
- en: '| --- | --- | --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '--- | --- | --- | --- |'
- en: '| ![Debugging options in Microsoft Edge](img/00128.jpeg) | Continue | *F5*
    or *F8* | This releases the break mode and continues till the next breakpoint.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00128.jpeg) | 继续 | *F5* 或 *F8* | 这会释放断点模式并继续到下一个断点。'
- en: '| ![Debugging options in Microsoft Edge](img/00129.jpeg) | Break | *Ctrl* +
    *Shift* + *B* | This breaks on the next statement. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00129.jpeg) | 断点 | *Ctrl* + *Shift* + *B* | 这会在下一条语句处中断。'
- en: '| ![Debugging options in Microsoft Edge](img/00130.jpeg) | Step Into | *F11*
    | This steps into the function being called or the next statement. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00130.jpeg) | 步入 | *F11* | 这会步入被调用函数或下一条语句。'
- en: '| ![Debugging options in Microsoft Edge](img/00131.jpeg) | Step Over | *F10*
    | This steps over the function being called or the next statement. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00131.jpeg) | 步过 | *F10* | 这会步过被调用函数或下一条语句。'
- en: '| ![Debugging options in Microsoft Edge](img/00132.jpeg) | Step Out | *Shift*
    + *F11* | This steps out of the current function and into the calling function.
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00132.jpeg) | 步出 | *Shift* + *F11* | 这会从当前函数步出并进入调用函数。'
- en: '| ![Debugging options in Microsoft Edge](img/00133.jpeg) | Break on new worker
    | *Ctrl* + *Shift* + *W* | This breaks on the creation of a new web worker. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00133.jpeg) | 在新工作者创建时中断 | *Ctrl* + *Shift* + *W*
    | 这会在新web工作者创建时中断。'
- en: '| ![Debugging options in Microsoft Edge](img/00134.jpeg) | Exception Control
    | *Ctrl* + *Shift* + *E* | This can be used to break on all exceptions or unhandled
    exceptions. By default, it is set to ignore exceptions. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00134.jpeg) | 异常控制 | *Ctrl* + *Shift* + *E* | 这可以用来在所有异常或未处理的异常上中断。默认情况下，它会忽略异常。'
- en: '| ![Debugging options in Microsoft Edge](img/00135.jpeg) | Disconnect Debugger
    |   | This disconnects the debugger and no breakpoints run. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00135.jpeg) | 断开调试器 |   | 这会断开调试器，不运行任何断点。'
- en: '| ![Debugging options in Microsoft Edge](img/00136.jpeg) | Debug just my code
    | *Ctrl* + *J* | This ignores the third-party libraries from debugging. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00136.jpeg) | 只调试我的代码 | *Ctrl* + *J* | 这会忽略第三方库的调试。'
- en: '| ![Debugging options in Microsoft Edge](img/00137.jpeg) | Pretty print | *Ctrl*
    + *Shift* + *P* | This searches the minified version of the JavaScript block and
    makes it readible. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00137.jpeg) | 美观打印 | *Ctrl* + *Shift* + *P* | 这会搜索JavaScript块的压缩版本并使其可读。'
- en: '| ![Debugging options in Microsoft Edge](img/00138.jpeg) | Word wrap | *Alt*
    + *W* | This wraps the sentence to adjust it as per the content pane size. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '![Microsoft Edge中的调试选项](img/00138.jpeg) | 单词换行 | *Alt* + *W* | 这会将句子换行以调整内容面板的大小。'
- en: 'Microsoft Edge provides the following five types of breakpoints:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Edge提供了以下五种断点类型：
- en: Standard
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准
- en: Conditional
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件
- en: Tracepoints
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪点
- en: XHR
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHR
- en: Events
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Standard breakpoints
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准断点
- en: 'These breakpoints can be set by simply selecting the statement from the script
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断点可以通过简单地从脚本代码中选择语句来设置：
- en: '![Standard breakpoints](img/00139.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![标准断点](img/00139.jpeg)'
- en: Conditional breakpoints
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件断点
- en: These type of breakpoints are hit when specific conditions are met or when the
    value of the variable reaches a specific state. For example, we can use this with
    a statement inside a loop and break the execution when the counter reaches a value
    of 10.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这类断点在满足特定条件时会被触发，或者当变量的值达到特定状态时。例如，我们可以在循环内的语句使用这个，当计数器达到10时中断执行。
- en: 'It can be set by clicking on the existing breakpoint and selecting **Condition...**
    from the **context** menu:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击现有的断点并从上下文菜单中选择**条件…**来设置：
- en: '![Conditional breakpoints](img/00140.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![条件断点](img/00140.jpeg)'
- en: 'This option opens up the **Conditional breakpoint** window and the condition
    can be set as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项会打开**条件断点**窗口，并且可以设置条件，如下面的屏幕截图所示：
- en: '![Conditional breakpoints](img/00141.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![条件断点](img/00141.jpeg)'
- en: Once the condition is set, the icon changes to ![Conditional breakpoints](img/00142.jpeg)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了条件，图标将更改为 ![条件断点](img/00142.jpeg)
- en: Tracepoints
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪点
- en: 'Tracepoints are used to write the message on the console when it passed through
    the statement where the tracepoint is configured. It can be set by clicking on
    the **Insert tracepoint** option from the **context** menu shown in the gutter
    by right-clicking:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪点用于在穿过配置了跟踪点的语句时在控制台上写入消息。它可以通过点击从由右键点击显示的边缘菜单中的**插入跟踪点**选项来设置：
- en: '![Tracepoints](img/00143.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪点](img/00143.jpeg)'
- en: 'Once the tracepoint is set, the icon changes, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了跟踪点，图标将更改，如下所示：
- en: '![Tracepoints](img/00144.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪点](img/00144.jpeg)'
- en: 'When the statement is executed, it will print the message on a console window
    as shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行语句时，它将在以下屏幕截图所示的控制台窗口中打印消息：
- en: '![Tracepoints](img/00145.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪点](img/00145.jpeg)'
- en: Event
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: Microsoft Edge provides the option of registering event tracepoints and breakpoints
    from the **Breakpoints** pane. An event could be a mouse event, keyboard event,
    or timer event. This feature is heavily used in large or complex web applications
    where the exact location of specifying the breakpoint is not known. It is also
    more useful in cases where the event handlers are specified at multiple places.
    For example, if a page contains five button controls, and we need to break the
    execution whenever any button raises the click event, we can simply specify the
    mouse-click event through the breakpoint event; and whenever any button event
    is raised, the breakpoint will be executed and will focus on the statement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Edge浏览器提供了从**断点**面板注册事件跟踪点和断点的选项。事件可以是鼠标事件、键盘事件或定时器事件。这项功能在大型或复杂的Web应用程序中非常有用，在这些应用程序中，不知道确切的断点指定位置。在事件处理程序在多个地方指定时，它也更有用。例如，如果一个页面包含五个按钮控件，我们需要在任何一个按钮触发点击事件时中断执行，我们只需通过断点事件指定鼠标点击事件；无论任何按钮事件被触发，断点都将执行并关注该语句。
- en: Add event tracepoint
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加事件跟踪点
- en: 'A user can add event tracepoints with the help of the following option:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用以下选项添加事件跟踪点：
- en: '![Add event tracepoint](img/00146.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![添加事件跟踪点](img/00146.jpeg)'
- en: 'The following window shows the registration of an event tracepoint when the
    mouse is clicked:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下窗口显示了当鼠标点击时注册事件跟踪点：
- en: '![Add event tracepoint](img/00147.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![添加事件跟踪点](img/00147.jpeg)'
- en: Add event breakpoints
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加事件断点
- en: 'User can add event breakpoints with the help of the following option:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用以下选项添加事件断点：
- en: '![Add event breakpoints](img/00148.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![添加事件断点](img/00148.jpeg)'
- en: 'The following window shows the registration of an event breakpoint when the
    mouse is clicked:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下窗口显示了当鼠标点击时注册事件断点：
- en: '![Add event breakpoints](img/00149.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![添加事件断点](img/00149.jpeg)'
- en: XHR
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XHR
- en: 'Just like events, XHR events can also be registered from the **Breakpoint**
    pane of browser. These events are invoked when any of the Ajax request is being
    made from the JavaScript code. A user can register the XHR event from the icon
    shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件类似，XHR事件也可以从浏览器的**断点**面板注册。这些事件在JavaScript代码中发起任何Ajax请求时被调用。用户可以从以下屏幕截图所示的图标中注册XHR事件：
- en: '![XHR](img/00150.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![XHR](img/00150.jpeg)'
- en: 'Once we click on this event, it will be added in the **Breakpoints** window,
    as shown in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击这个事件，它就会被添加到**断点**窗口中，如下面的屏幕截图所示：
- en: '![XHR](img/00151.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![XHR](img/00151.jpeg)'
- en: Debugging TypeScript
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试TypeScript
- en: In [Chapter 5](part0028_split_000.html#QMFO2-40dd2de0d2d94f79a49cd7a43c4b76e6
    "Chapter 5. Developing an ASP.NET Application Using Angular 2 and Web API"), *Developing
    an ASP.NET Application Using Angular 2 and Web API*, we already discussed TypeScript
    and how it transpiles into the JavaScript code that eventually runs on the browser.
    The developers write code in TypeScript, but on the browser, a generated JavaScript
    file is run. When the TypeScript file is transpiled to a JavaScript file, a mapping
    file is generated with a `*.map.js` extension. This file contains the information
    about the actual TypeScript file and the generated JavaScript file. Not only this,
    but the generated JavaScript file also contains one entry about the mapping file
    that actually tells the browsers to load the corresponding source TypeScript file
    by reading the mapping file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0028_split_000.html#QMFO2-40dd2de0d2d94f79a49cd7a43c4b76e6 "第5章．使用Angular
    2和Web API开发ASP.NET应用程序")，*使用Angular 2和Web API开发ASP.NET应用程序*，我们已经讨论了TypeScript以及它如何被编译成最终在浏览器上运行的JavaScript代码。开发者用TypeScript编写代码，但在浏览器上运行的是生成的JavaScript文件。当TypeScript文件被编译成一个JavaScript文件时，会生成一个带有`*.map.js`扩展名的映射文件。这个文件包含了有关实际TypeScript文件和生成的JavaScript文件的信息。不仅如此，生成的JavaScript文件还包含了一个关于映射文件的条目，这个条目实际上告诉浏览器通过读取映射文件来加载相应的源TypeScript文件。
- en: 'Here is the entry that every generated JavaScript file contains when it is
    transpiled from TypeScript:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个生成的JavaScript文件包含的条目，该文件是从TypeScript编译而来的：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This can be configured from the `TSConfig.json` file through the `sourceMap`
    property. If the `sourceMap` property is `true`, it generates the mapping file
    and makes an entry in the generated JavaScript file. Also, when working in an
    ASP.NET Core application, all the static files have to be in the `wwwroot` folder.
    So, to debug the typescripts, all the corresponding typescript (`.ts`) files have
    to be moved to any folder under the `wwwroot` folder so that it can be accessible
    from the browser.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`TSConfig.json`文件中的`sourceMap`属性进行配置。如果`sourceMap`属性为`true`，它将生成映射文件并在生成的JavaScript文件中创建一个条目。另外，当在ASP.NET
    Core应用程序中工作时，所有静态文件都必须位于`wwwroot`文件夹中。因此，为了调试typescripts，所有对应的typescript (`.ts`)文件必须移动到`wwwroot`文件夹下的任何文件夹中，以便可以从浏览器中访问。
- en: 'Here is the debugger window, showing the list of TypeScript files on the left-hand
    side and the icon in the upper-right corner to toggle between the source file
    and compiled JavaScript version:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调试窗口，它显示左侧的TypeScript文件列表和在右上角的图标，可以切换源文件和编译后的JavaScript版本：
- en: '![Debugging TypeScript](img/00152.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![调试TypeScript](img/00152.jpeg)'
- en: Debugger keyword supported by all browsers
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有浏览器都支持的调试关键字
- en: 'We can also explicitly force to break the control at some point through the
    `debugger` keyword. If the breakpoint is not set, but the `debugger` keyword is
    specified, the debugging will be enabled and break the execution. It can be set
    from code as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过`debugger`关键字显式地在某个点上中断控制。如果没有设置断点，但指定了`debugger`关键字，调试将启用并中断执行。它可以从代码中设置，如下面的屏幕截图所示：
- en: '![Debugger keyword supported by all browsers](img/00153.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![所有浏览器都支持的调试关键字](img/00153.jpeg)'
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed how JavaScript applications can be tested and
    debugged. For testing JavaScript applications, we discussed the Jasmine testing
    suite that can be easily plugged in with Karma, which is a test runner and can
    be used with Grunt to be executed from Visual Studio **Task Runner Explorer**
    window. We also discussed the basics of the MVVM pattern and how to implement
    it using the Knockout JavaScript library. We then modified the test case to work
    with the View model. For debugging, we discussed some tips and techniques of debugging
    JavaScript with Visual Studio and what Microsoft Edge offers through the **Developer
    Tools** window to make debugging easy. In the end, we also learned about the basic
    topics such as how Microsoft Edge enables debugging for TypeScript files and what
    configurations are required to achieve it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何测试和调试JavaScript应用程序。对于测试JavaScript应用程序，我们讨论了可以与Karma轻松集成的Jasmine测试套件，Karma是一个测试运行器，可以与Grunt一起使用，从Visual
    Studio **任务运行器浏览器**窗口执行。我们还讨论了MVVM模式的基础知识以及如何使用Knockout JavaScript库来实现它。然后我们将测试用例修改为与视图模型一起工作。对于调试，我们讨论了使用Visual
    Studio调试JavaScript的一些技巧和技术，以及Microsoft Edge通过**开发者工具**窗口提供的内容，以使调试变得容易。最后，我们还学习了有关的基本主题，例如Microsoft
    Edge如何启用对TypeScript文件的调试以及实现所需配置。
