- en: Chapter 6. Exploring the WinJS Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章．探索WinJS库
- en: Web development has led to revolutionary experiences. With frameworks like bootstrap,
    material, and others , we are now able to run web applications at their best on
    different screen sizes and adjust their content accordingly. Developers target
    web applications to run on different platforms providing a consistent experience
    to their customers. For example, any web application using bootstrap and other
    frameworks can run on a browser, tablet, and a mobile device providing the best
    user experience ever imagined. With these benefits, new prospects were introduced
    and allow web applications to target different devices bringing the need for accessing
    client-side device-specific features and layouts as well. With these revolutionary
    experiences, companies started bringing JavaScript-based libraries that not only
    changed the look and feel of the applications running on devices but also allowed
    developers to use device-specific features like sending toast notifications, accessing
    the camera to upload pictures, and so on, leveraging user experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网页开发已经导致了革命性的体验。有了像bootstrap、material等框架，我们如今能够使Web应用程序在不同的屏幕尺寸上运行得最好，并相应地调整其内容。开发者将Web应用程序目标定为不同的平台，为他们的客户提供一致的体验。例如，任何使用bootstrap和其他框架的Web应用程序都可以在浏览器、平板电脑和移动设备上运行，提供前所未有的最佳用户体验。有了这些好处，新的前景被引入，允许Web应用程序针对不同的设备，这也带来了访问客户端特定特性和布局的需要。有了这些革命性的体验，公司开始引入基于JavaScript的库，这些库不仅改变了在设备上运行应用程序的外观和感觉，还允许开发者使用特定设备的功能，如发送弹窗通知、访问相机上传图片等等，从而提升用户体验。
- en: Introduction to WinJS
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinJS简介
- en: '**Windows JavaScript** (**WinJS**) library is an open source JavaScript library
    developed by Microsoft. It was released in April 2014 during the Microsoft build
    conference and with Windows 10, Microsoft officially released version 4.0\. Currently
    it''s open source and under an Apache 2.0 license.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows JavaScript**（**WinJS**）库是由微软开发的开源JavaScript库。它在2014年4月的微软构建会议上发布，随着Windows
    10的发布，微软正式发布了4.0版本。目前它是开源的，并受到Apache 2.0许可的约束。'
- en: It was initially targeted for Windows store apps that were based on JavaScript,
    CSS, and HTML but later supported in modern browsers as well. Today developers
    can develop mobile applications for any platform including Windows apps, Android
    apps, and iOS apps using JavaScript, CSS, and HTML and they can use this library
    to transform the **user interface** (**UI**) to a native mobile interface with
    the provision of accessing features of the Windows runtime. The WinJS library
    exposes not only the Windows runtime modules but also provides Windows UI control
    setup for use in web applications. WinJS provides Windows runtime features like
    the classes and runtime components and they can be accessed through JavaScript
    code. Users can build apps that access device features like the camera, storage,
    geolocations, filesystems, and style applications that give the best user experience.
    It also provides a layer of security which keeps the device features safe and
    protects them from malicious attacks. As far as browser compatibility is concerned,
    all the modern browsers including Microsoft Edge, Google Chrome, and others support
    this library. The basic advantage is that now web developers can build Windows
    store applications using WinJS controls suite and library to use Windows runtime
    features. Moreover, Microsoft has also empowered WinJS library to integrate with
    popular client-side frameworks like AngularJS, Knockout, Ember, and Backbone and
    you can use WinJS directives in your HTML with other controls directives and it
    works as expected.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它最初是为基于JavaScript、CSS和HTML的Windows商店应用设计的，后来也支持现代浏览器。今天，开发者可以使用JavaScript、CSS和HTML为任何平台开发移动应用程序，包括Windows应用、Android应用和iOS应用，并可以使用这个库将**用户界面**（**UI**）转换为具有访问Windows运行时功能的本地移动界面。WinJS库不仅暴露了Windows运行时模块，还为Web应用程序提供了Windows
    UI控件设置。WinJS提供了Windows运行时特性，如类和运行时组件，它们可以通过JavaScript代码访问。用户可以构建应用程序以访问设备功能，如相机、存储、地理位置、文件系统，并样式化应用程序以提供最佳用户体验。它还提供了一层安全性，使设备功能保持安全并保护它们免受恶意攻击。至于浏览器兼容性，所有现代浏览器，包括Microsoft
    Edge、Google Chrome等，都支持这个库。基本优势是，现在Web开发者可以使用WinJS控件套件和库来使用Windows运行时特性构建Windows商店应用程序。此外，微软还授权WinJS库与AngularJS、Knockout、Ember和Backbone等流行的客户端框架集成，您可以在HTML中使用WinJS指令与其他控件指令一起使用，并且按预期工作。
- en: WinJS features
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinJS特性
- en: WinJS is not only designed to serve universal windows apps that are based on
    HTML and JavaScript but a generalized JavaScript library that can be used with
    web applications as well. WinJS brings various features that we will discuss in
    the following section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS不仅是为了服务于基于HTML和JavaScript的通用Windows应用而设计的，它也是一个通用的JavaScript库，可以与Web应用程序一起使用。WinJS带来了各种功能，我们将在接下来的章节中讨论。
- en: JavaScript coding and language patterns
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript编程和语言模式
- en: WinJS provides the coding pattern of defining custom namespaces and classes
    performing binding implementations and promises.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS提供了定义自定义命名空间和类的编程模式，以及执行绑定实现和承诺的编程模式。
- en: Stylesheets
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式表
- en: It provides two stylesheets, namely UI-dark and UI-light, which can be used
    with HTML elements to give a particular Windows app a themed appearance. Also,
    it allows you to handle different screen sizes and orientation like landscape
    and portrait.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了两套样式表，分别是UI-dark和UI-light，可以与HTML元素一起使用，给特定的Windows应用带来主题外观。此外，它允许你处理不同的屏幕大小和方向，如景观和肖像。
- en: Windows runtime access
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows运行时访问
- en: We can access the windows runtime features like filesystem, camera, geo-location,
    and others which are applicable through the native application API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问Windows运行时功能，如文件系统、相机、地理定位等，这些功能可以通过本地应用程序API来使用。
- en: Security
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性
- en: With the provision of enabling windows runtime features, WinJS also restricts
    the access to sensitive data on the device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供启用Windows运行时功能的选项，WinJS也限制了对设备上敏感数据的访问。
- en: App model
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用模型
- en: App model offers events initiated by a Windows application and can be registered
    in our JavaScript to do a specific operation. For example, suspend, resume, and
    initialization are some useful events we can use to handle specific tasks through
    registering them in WinJS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用模型提供了由Windows应用程序发起的事件，可以在我们的JavaScript中注册以执行特定操作。例如，挂起、恢复和初始化是一些我们可以在WinJS中注册以处理特定任务的有用事件。
- en: Databinding
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Just like other frameworks like AngularJS, KnockOut, and so on, WinJS also provides
    specific databinding directives and syntax that is used to bind HTML controls
    with the data supplied or that exist in your JavaScript code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他框架如AngularJS、KnockOut等一样，WinJS也提供了特定的数据绑定指令和语法，用于将HTML控件与在JavaScript代码中提供的数据绑定。
- en: Controls
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控件
- en: WinJS provides specific controls apart from the extended attributes on HTML
    elements. These controls are available in the native Windows apps project and
    with WinJS we can use them in our HTML page to bring the same experience.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS提供了除了扩展的HTML元素属性之外的特定控件。这些控件可以在本地Windows应用项目中使用，并且我们可以通过WinJS将它们用于我们的HTML页面，带来相同的体验。
- en: Utilities
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用工具
- en: WinJS provides several utilities to perform localization, animations, and DOM
    selectors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS提供了几个实用工具来执行本地化、动画和DOM选择器。
- en: Usage of WinJS
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinJS的使用
- en: Microsoft has developed various applications using WinJS library. Applications
    like Skype, Store, Weather, News, and others are all developed in HTML, CSS, and
    JavaScript using WinJS library. The modern era of web development made JavaScript
    a core framework of developing responsive and rich applications that run on any
    platform and on any device. This lead Microsoft to invest heavily on WinJS and
    to make this library useful for web developers who want to create Windows apps
    or use Windows platform features from web applications. With the release of **Universal
    Windows Platform** (**UWP**), Microsoft released the new **Universal App Platform**
    (**UAP**), a super set of the WinRT platform used by Windows 8 applications. With
    UWP there is a new Hosted app concept introduced, that allows any web application
    to convert into the Windows app with a very minimum set of configuration properties.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已经使用WinJS库开发了各种应用程序。像Skype、Store、Weather、News等应用程序都是使用HTML、CSS和JavaScript以及WinJS库开发的。Web开发的现代时代使JavaScript成为开发响应迅速且功能丰富的应用程序的核心框架，这些应用程序可以在任何平台和设备上运行。这使得微软对WinJS进行了大量投资，并使这个库对希望创建Windows应用或从Web应用中使用Windows平台功能的Web开发者变得有用。随着**通用Windows平台**（**UWP**）的发布，微软发布了新的**通用应用平台**（**UAP**），它是Windows
    8应用程序所使用的WinRT平台的一个超集。通过UWP引入了新的托管应用概念，它允许任何Web应用程序通过非常少的配置属性转换为Windows应用。
- en: Adding the WinJS library in the ASP.NET application
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ASP.NET应用程序中添加WinJS库
- en: WinJS can be added through **Node** **Package Manager** (**NPM**), NuGet, and
    by referencing a CDN. This depends on whether you want to keep the files local
    on the server or as reference from CDN.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS可以通过Node包管理器（NPM）、NuGet以及引用CDN来添加。这取决于你是否希望将文件保存在服务器上的本地还是作为CDN的引用。
- en: CDN
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CDN
- en: 'Here is the CDN library that contains JavaScript and CSS files that you can
    add in your application: [https://cdnjs.com/libraries/winjs](https://cdnjs.com/libraries/winjs).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在你的应用程序中可以添加的包含JavaScript和CSS文件的CDN库：[https://cdnjs.com/libraries/winjs](https://cdnjs.com/libraries/winjs)。
- en: NPM
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NPM
- en: To install it with NPM you can run `npm install winjs` or just add the `winjs`
    package in the `package.json` file when working in the ASP.NET core application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用NPM安装它，你可以运行`npm install winjs`，或者在ASP.NET核心应用程序中工作时，只需在`package.json`文件中添加`winjs`包。
- en: NuGet
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NuGet
- en: 'To install it via NuGet you can add the WinJS package through the NuGet package
    manager console or just run the following command in the ASP.NET application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过NuGet安装它，你可以在NuGet包管理器控制台中添加WinJS包，或者在ASP.NET应用程序中运行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The WinJS package comes with a set of JavaScript files and the CSS stylesheets
    for darker or lighter UI. The following table defines the files and their usage:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS包包括一组JavaScript文件和CSS样式表，用于更暗或更亮的UI。以下表格定义了文件及其用途：
- en: '| File | Type | Usage |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 类型 | 使用 |'
- en: '| --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Base.js` | JavaScript | This is a core module and it is used by `UI.js`
    to provide Windows runtime features |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '`Base.js` | JavaScript | 这是一个核心模块，它被`UI.js`用来提供Windows运行时特性 |'
- en: '| `UI.js` | JavaScript | Contains UI controls |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '`UI.js` | JavaScript | 包含UI控件 |'
- en: '| `WinJS.intellisense.js` | JavaScript | Provide intellisense when using WinJS
    components in JavaScript |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '`WinJS.intellisense.js` | JavaScript | 在使用WinJS组件时提供intellisense |'
- en: '| `ui-dark.css` | CSS | Stylesheet for darker UI theme |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '`ui-dark.css` | CSS | 用于更暗的UI主题的样式表 |'
- en: '| `ui-light.css` | CSS | Stylesheet for lighter UI theme |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '`ui-light.css` | CSS | 用于更亮的UI主题的样式表 |'
- en: Getting started with WinJS
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用WinJS
- en: Microsoft has provided certain templates in Visual Studio to develop store applications
    using JavaScript and HTML, on the other hand, we can also add it in our ASP.NET
    application to bring certain functionalities of Windows runtime features or changing
    a look and feel accordingly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在Visual Studio中提供了一些模板，以使用JavaScript和HTML开发商店应用程序，另一方面，我们也可以将其添加到我们的ASP.NET应用程序中，以带来Windows运行时特性的一些功能或相应地改变外观和感觉。
- en: Using WinJS in the ASP.NET application
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ASP.NET应用程序中使用WinJS
- en: 'You can start using WinJS by adding the JavaScript to use Windows runtime features
    and CSS to make UI as Windows applications. In the ASP.NET web application you
    can add the package through NPM by making an entry, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加JavaScript来使用Windows运行时特性以及CSS来让UI看起来像Windows应用程序来开始使用WinJS。在ASP.NET网络应用程序中，你可以通过NPM添加包，通过创建一个条目，如下所示：
- en: '![Using WinJS in the ASP.NET application](img/00047.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![在ASP.NET应用程序中使用WinJS](img/00047.jpeg)'
- en: On saving the file, the package will be downloaded automatically in Visual Studio
    2015 under the `node_modules\npm` folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，包将自动在Visual Studio 2015中的`node_modules\npm`文件夹中下载。
- en: 'Here is a screenshot of the folders the WinJS library contains. JS contains
    `winjs` modules, `css`, and `fonts` that can be used to change UI look and feel:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是WinJS库包含的文件夹的屏幕截图。JS包含`winjs`模块、`css`和`fonts`，可以用来改变UI的外观和感觉：
- en: '![Using WinJS in the ASP.NET application](img/00048.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![在ASP.NET应用程序中使用WinJS](img/00048.jpeg)'
- en: 'You can use `Gulp.js` to copy the `css` and `js` files to the `wwwroot` folder
    and reference them on the page, we can add the following sample code that displays
    the `You have clicked!` text on a button click event:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Gulp.js`将`css`和`js`文件复制到`wwwroot`文件夹并在页面上引用它们，我们可以在按钮点击事件中添加以下示例代码来显示`You
    have clicked!`文本：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![Using WinJS in the ASP.NET application](img/00049.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![在ASP.NET应用程序中使用WinJS](img/00049.jpeg)'
- en: On page load, the function will be executed that registers the click event for
    the button when all the WinJS controls are processed. The `WinJS.UI.processAll()`
    method parses whole **document object model** (**DOM**) and searches for the WinJS
    controls to process and return a promise after the binding is done for all the
    controls.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载时，将会执行一个函数，当所有WinJS控件都被处理时，为按钮注册点击事件。`WinJS.UI.processAll()`方法解析整个文档对象模型（DOM），寻找需要处理的WinJS控件，并在所有控件的绑定完成后返回一个承诺。
- en: Under the hood, `WinJS.UI.processAll()` only processes those controls which
    have the `isDeclarativeControlContainer` property set as `true`. This tells WinJS
    which controls need to be bound with the WinJS library. If you are using custom
    controls then you need to specify this `isDeclarativeControlContainer` property
    so it can be processed by WinJS.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`WinJS.UI.processAll()`只处理`isDeclarativeControlContainer`属性设置为`true`的控制器。这告诉WinJS需要与WinJS库绑定的控制器。如果您使用自定义控制器，则需要指定这个`isDeclarativeControlContainer`属性，以便它可以被WinJS处理。
- en: Events can be registered through declarative binding or by registering an event
    from JavaScript. In the preceding code we have registered the button click event
    through JavaScript however; declaratively you can also set the event and call
    some JavaScript functions that can be invoked when the button is clicked.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以通过声明性绑定或通过从JavaScript注册事件来注册。在前面的代码中，我们通过JavaScript注册了按钮点击事件；然而，在声明性方面，您也可以设置事件并调用一些可以在按钮被点击时调用的JavaScript函数。
- en: Existing Windows app template in Visual Studio
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Visual Studio中现有的Windows应用模板
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exploring WinJS core fundamentals
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索WinJS核心基础
- en: Before using WinJS library in any of the projects, it is best to know the core
    concepts that help us to write quality programs and use the best of what the library
    offers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用WinJS库的任何项目之前，最好了解核心概念，帮助我们编写高质量的程序并充分利用库的最佳功能。
- en: Classes and namespaces
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和命名空间
- en: Through WinJS we can create classes and namespace with some special syntax.
    This is provided in the WinJS library to handle complex scenarios. As we know,
    classes and namespaces are the features of ECMAScript 6, but unfortunately none
    of the browsers have proper implementation yet. However, with WinJS we can define
    classes and namespaces and it's a useful option to use them where needed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过WinJS，我们可以使用一些特殊的语法来创建类和命名空间。这是WinJS库提供的，用于处理复杂场景。正如我们所知，类和命名空间是ECMAScript
    6的功能，但不幸的是，目前还没有浏览器有适当的实现。然而，借助WinJS，我们可以定义类和命名空间，并且在需要的地方使用它们是一个有用的选择。
- en: Defining classes in WinJS
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在WinJS中定义类
- en: 'Classes in WinJS can be defined through the `WinJS.Class.define()` method.
    Here is the sample code of a class in WinJS:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在WinJS中，可以通过`WinJS.Class.define()`方法定义类。以下是WinJS中类的示例代码：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code we have created a class named `Logger`, where the first
    function''s parameter is the constructor, second is for any `instanceMembers`
    like properties and methods and third for `staticMembers` to define static members
    and properties. The following is the signature of the `define` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`Logger`的类，其中第一个函数的参数是构造函数，第二个是任何`instanceMembers`如属性和方法，第三个是`staticMembers`以定义静态成员和属性。以下是`define`方法的签名：
- en: '![Defining classes in WinJS](img/00051.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![在WinJS中定义类](img/00051.jpeg)'
- en: 'Now let''s add the property `message` and the `LogMessage()` method in the
    same class `Logger`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在同一个类`Logger`中添加属性`message`和`LogMessage()`方法：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The syntax of defining the methods for the class is a method name followed
    with a colon (`:`) and the function body as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类的方法语法的名称后面跟着一个冒号（`:`）和函数体，如下所示：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The properties can be defined with `get` and `set` function methods as shown
    in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以通过`get`和`set`函数方法定义，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Multiple properties and methods can be defined in a same way separated with
    comma as shown in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在相同的方式下定义多个属性和方法， separated with comma，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Deriving classes in WinJS
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在WinJS中派生类
- en: 'Classes in WinJS can be derived by using the `WinJS.class.derive()` method.
    Considering the previous example, we can also add the `logEnabled` and `logType`
    properties on the base class and then derive the `Logger` class from the `BaseLogger`
    class. Here is the code to derive classes in WinJS:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在WinJS中，可以通过使用`WinJS.class.derive()`方法来派生类。考虑前面的例子，我们也可以在基类上添加`logEnabled`和`logType`属性，然后从`BaseLogger`类派生出`Logger`类。以下是WinJS中派生类的代码：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the above script we have taken both the properties `logType` and `logEnabled`
    to the base class `BaseLogger`. In WinJS, base properties can be accessed through
    the following syntax:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的脚本中，我们将`logType`和`logEnabled`这两个属性都移到了基类`BaseLogger`中。在WinJS中，基属性可以通过以下语法访问：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Settings can be done by calling the `set` method after the `getOwnPropertyDescriptor()`
    method call:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`getOwnPropertyDescriptor()`方法调用后调用`set`方法进行设置：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now if you want to take the `logMessage()` method on the `BaseLogger` class,
    we can do it through prototyping, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想要在`BaseLogger`类上采用`logMessage()`方法，我们可以通过原型化来实现，如下所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Namespaces in WinJS
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinJS 中的命名空间
- en: In object oriented programming, namespaces play an important role in organizing
    classes and categorizing your code. For example, the services can reside under
    the `ApplicationName.Services` namespace; models can reside under the `ApplicationName.Models`
    namespace, and so on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，命名空间在组织类和分类代码方面发挥着重要作用。例如，服务可以位于 `ApplicationName.Services` 命名空间下；模型可以位于
    `ApplicationName.Models` 命名空间下，等等。
- en: We should always use namespaces where possible as it solves many problems that
    could occur in mid-size to larger projects. For example, we have two JavaScript
    files added in our page that have similar names of properties or functions. The
    one referenced later will supersede the member functions or variables of the previous
    ones if they have the same name.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽可能地使用命名空间，因为它可以解决许多在中型到大型项目中可能出现的问题。例如，我们在页面上添加的两个 JavaScript 文件具有相似的属性或函数名称。如果有相同的名称，后来引用的将覆盖先前的成员函数或变量。
- en: WinJS provides an easy way to logically organize classes into namespaces and
    you can define a namespace by calling `WinJS.Namespace.define("namespace name",
    {})))`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS 提供了逻辑上组织类到命名空间的简单方法，你可以通过调用 `WinJS.Namespace.define("命名空间名称", {})` 来定义一个命名空间。
- en: 'Here is the example that encapsulates both the `BaseLogger` and `Logger` class
    into the `Demo.App.Utilities` namespace:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将 `BaseLogger` 和 `Logger` 类封装到 `Demo.App.Utilities` 命名空间中：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the `Log` class can be accessed by specifying its namespace, as shown in
    the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以通过指定其命名空间来访问 `Log` 类，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Mixin
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混入
- en: 'Most of the languages do not support multiple inheritance. However, in WinJS
    we can do it through mixins. Like class, `mixin` is a collection of methods and
    properties but the object of mixins cannot be instantiated. It is used to mix
    with a class to bring the methods and properties that mixins have. For example,
    the following is a Mixin `logMixin` that contains a `logMessage()` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言不支持多重继承。然而，在 WinJS 中，我们可以通过混入（mixins）来实现。与类一样，`mixin` 是一组方法和属性的集合，但混入的对象不能被实例化。它用于与类混合，带来混入所具有的方法和属性。例如，以下是一个包含
    `logMessage()` 方法的混入 `logMixin`：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can add as many mixins when calling the `mix` method. If two or more have
    common methods or properties, later one will override the existing one. Let''s
    look into the examples which have two mixins, namely `logMixin` and `logConsoleMixin`.
    Both the mixins and a `SampleClass` have a same `logMessage()`method. Now based
    on the specification, the methods will be overridden and when the `logMessage()`
    is invoked it will write a message on a console log:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `mix` 方法时，我们可以添加尽可能多的混入。如果有两个或更多的混入具有共同的方法或属性，后来的将覆盖现有的。让我们看看两个混入（分别为 `logMixin`
    和 `logConsoleMixin`）以及一个 `SampleClass` 都有一个相同的 `logMessage()` 方法。根据规范，方法将被覆盖，当调用
    `logMessage()` 时，它将在控制台日志上写入一条消息：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Events in WinJS
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinJS 中的事件
- en: 'WinJS provides an `eventMixin` object that can be used to register, unregister,
    and dispatch events through the following basic steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS 提供了 `eventMixin` 对象，可以通过以下基本步骤注册、注销和分发事件：
- en: 'First of all, the class from which we need to call the dispatch event needs
    to have `WinJS.Utilities.eventMixin` added. We can add this through the `WinJS.Class.mix`
    method, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要调用分发事件的类需要添加 `WinJS.Utilities.eventMixin`。我们可以通过 `WinJS.Class.mix` 方法添加它，如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the `eventMixin` is inherited by the `SampleClass`, we can call the `dispatchEvent()`
    method to dispatch on a particular action. Here is the code of the `Sample` class
    that dispatches the event once the `execute` method is called:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `eventMixin` 被 `SampleClass` 继承，我们就可以调用 `dispatchEvent()` 方法在特定动作上分发事件。以下是
    `Sample` 类在调用 `execute` 方法后分发事件的代码：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we can add the `addEventListener()` method and provide the `eventHandler()`
    that will be invoked once the dispatch message is called:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加 `addEventListener()` 方法，并提供将在分发消息被调用时调用的 `eventHandler()`：
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Databinding
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Databinding
- en: WinJS provides an easy way of binding any JavaScript data source to the HTML
    element. Any JavaScript data source can be bound using `data-win-bind` attribute
    on an HTML element. Databinding facilitates in separating the data with the view
    and allows you to write less code and bind the data with the elements using WinJS,
    which provides three types of databinding as follows.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS 提供了将任何 JavaScript 数据源绑定到 HTML 元素的简单方法。任何 JavaScript 数据源都可以使用 HTML 元素上的
    `data-win-bind` 属性进行绑定。数据绑定有助于将数据与视图分离，并允许您编写更少的代码，并使用 WinJS 将数据与元素绑定，WinJS 提供了以下三种数据绑定类型。
- en: One time databinding
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次性数据绑定
- en: One time databinding is used to bind the element on an HTML page from a JavaScript
    data source. It is unidirectional, that means if the JavaScript data source is
    updated it will not reflect the change on the HTML to which it is bound to.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性数据绑定用于将HTML页面上的元素从JavaScript数据源绑定。它是单向的，这意味着如果JavaScript数据源被更新，它不会反映在绑定到的HTML上。
- en: 'Here is the HTML code that has two controls which binds the properties name
    and description with the view model defined in your JavaScript:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是具有两个控件的HTML代码，它将名称和描述属性与您在JavaScript中定义的视图模型绑定：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: One way databinding
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单向绑定
- en: One way databinding is a unidirectional binding. Once the HTML element is bound
    to the JavaScript data source, any changes in the data source will reflect the
    change on the HTML page but if something is updated on the HTML element, it will
    not update the backend JavaScript data source. One way databinding can be done
    by making the source model observable. So if anything changes on the source object
    it will update the UI element to which it is bound to. It can either be done by
    using the `WinJS.binding.as()` method or adding the `observableMixin` with the
    source class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 单向绑定是一种单向绑定。一旦HTML元素被绑定到JavaScript数据源，数据源的任何更改都会在HTML页面上反映出来，但如果在HTML元素上进行了更新，它不会更新后端JavaScript数据源。单向绑定可以通过使源模型可观察来实现。所以如果源对象上有什么变化，它就会更新与之绑定的UI元素。这可以通过使用`WinJS.binding.as()`方法或在与源类添加`observableMixin`来实现。
- en: 'The following is an example of one way databinding that binds the properties
    `Name` and `Description` and on the button click event, updates the HTML element
    and sets the value set from the backend data source. Adding a button in the previous
    HTML page added in the *One time databinding* section:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单向绑定的示例，它将属性`Name`和`Description`绑定到按钮点击事件上，更新HTML元素并设置从后端数据源设置的值。在之前的HTML页面中添加按钮，如*一次性数据绑定*部分所示：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Two way databinding
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: 'Two way databinding works in both directions. Once the JavaScript object is
    bound to the HTML control, any changes done on the control itself or if the value
    of the JavaScript object gets changed, the control value will be updated and vice
    versa. Implementing two way binding in WinJS is not straight forward. We need
    to have the one way binding in place to reflect any change happening on the backend
    data source to reflect on the frontend, as well as to update the backend data
    source from any changes done on the UI element. This can be done by implementing
    `onPropertyChange()`, `onKeyDown()`, `onChange()`, or `onClick()` and others based
    on the HTML element:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 双向数据绑定在两个方向上起作用。一旦JavaScript对象被绑定到HTML控件上，无论在控件本身上进行任何更改，还是在JavaScript对象的价值发生更改时，控件值都将被更新，反之亦然。在WinJS中实现双向绑定不是一件简单的事。我们需要有一种单向绑定在位，以反映后端数据源上发生的任何变化，并反映在前端，同时也要从任何在UI元素上进行的更改更新后端数据源。这可以通过实现`onPropertyChange()`、`onKeyDown()`、`onChange()`、`onClick()`以及其他基于HTML元素的函数来完成：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another approach is to implement a custom binding initializer which can be
    used as highlighted in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是实现一个自定义绑定初始化器，如以下代码所示：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s create a custom two way binding initializer and extend the same `viewModel`
    to accept the name and description updates through textboxes. Here is the code
    of our custom two way binding initializer:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个自定义的双向绑定初始化器，并扩展相同的`viewModel`以通过文本框接受名称和描述的更新。以下是我们的自定义双向绑定初始化器的代码：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then create a class that contains two properties, namely `name` and `description`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个包含两个属性的类，分别为`name`和`description`：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the above code, we have first defined the binding initializer using `WinJS.Binding.initializer`.
    When defining this initializer we have to pass four properties namely source element
    and its properties object and destination element and its properties. So for example,
    in our case the source element is a textbox and the source property is its value,
    whereas the destination element will be a span and `innerText` as its destination
    property. `WinJS.Binding.defaultBind` creates the one way binding and then we
    can register the `onchange()` event of the source property which updates the destination
    property. Then we defined a class and then initialized the values by initializing
    an instance. And finally, we have transformed the model into the observable model
    to provide two way binding.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们首先使用`WinJS.Binding.initializer`定义了绑定初始化器。定义此初始化器时，我们必须传递四个属性，分别是源元素及其属性对象和目标元素及其属性。例如，在我们的情况下，源元素是一个文本框，源属性是它的值，而目标元素将是一个`span`，`innerText`作为其目标属性。`WinJS.Binding.defaultBind`创建单向绑定，然后我们可以注册源属性的`onchange()`事件，以更新目标属性。然后我们定义了一个类，并通过初始化一个实例来初始化值。最后，我们将模型转换为可观察模型，以提供双向绑定。
- en: 'Now, in the HTML element, we can add the binding as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在HTML元素中，我们可以像下面这样添加绑定：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A databinding working model
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据绑定的工作模型
- en: When the databinding is done in WinJS, the `WinJS.processAll()` method has to
    be called if it's done using WinJS. This method scans all the elements which specify
    the `data-win-bind attributes`. For each element, it checks if the data bound
    with the element is observable or not. This is a crucial step which identifies
    the type of binding and declares whether the binding is a one way binding, one
    time binding, or two way binding.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当在WinJS中完成数据绑定时，如果使用WinJS，则必须调用`WinJS.processAll()`方法。该方法扫描所有指定`data-win-bind`属性的元素。对于每个元素，它检查与元素绑定的数据是否可观察。这是一个关键步骤，它确定了绑定的类型，并声明绑定是单向绑定、一次性绑定还是双向绑定。
- en: '![A databinding working model](img/00052.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![数据绑定的工作模型](img/00052.jpeg)'
- en: Promises
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺
- en: Promises represent an object that contains a value that might be available at
    any time. It's a promise which satisfies the consumer that the resource will be
    available and the consumer can do the rest of the work without waiting for the
    resource in an asynchronous manner.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺代表一个可能随时包含值的对象的承诺。这是一个承诺，满足消费者资源将可用，消费者可以在不等待资源的异步方式中完成其余工作。
- en: It works as an async/await feature of C#. Promises allow consumers to do other
    work rather than waiting for the value to return and provides certain methods
    to acknowledge the consumer once the promise is received. In certain cases, there
    is a chance of not having the response return due to some error and that can also
    be handled by implementing specific callbacks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为C#的异步/等待功能。承诺允许消费者在做其他工作而不是等待值返回的同时，提供某些方法来确认承诺一旦收到。在某些情况下，由于某些错误，有可能响应不会返回，这也可以通过实现特定的回调来处理。
- en: 'In WinJS, promise is an object with functions `then` and `done`. We can initialize
    promise as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在WinJS中，承诺是一个具有`then`和`done`函数的对象。我们可以这样初始化承诺：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code is the way of defining a function that returns a promise.
    We can then call a `progress` method if the method is not completed and we need
    to notify the consumer if something is in progress. Once the promise is defined,
    we can use the `then` and `done` methods to implement callback methods that will
    be triggered by promise. The `then` method returns a promise and denotes the intermediate
    stage of the operation whereas `done` is the final stage of the operation and
    does not return a `promise`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是定义一个返回promise的函数的方式。如果我们还没有完成方法并且需要通知消费者如果正在进行中，我们可以调用一个`progress`方法。一旦定义了promise，我们可以使用`then`和`done`方法来实现由promise触发的回调方法。`then`方法返回一个promise，表示操作的中间阶段，而`done`是操作的最后阶段，不返回`promise`：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following example shows the function that displays the table in a console
    window and returns completed once the promise is processed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了在处理promise后显示表格在控制台窗口中并返回完成的函数：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is the output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Promises](img/00053.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Promises](img/00053.jpeg)'
- en: Now let's modify the same example and invoke `progress` to send intermediate
    results to the consumer on each iteration. The preceding method is synchronous
    and returning promise doesn't mean the method will be executed asynchronously.
    To make this method run asynchronously we can wrap the block of code through the
    `setImmediate()` function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改同一个示例，并调用`progress`在每个迭代中将中间结果发送给消费者。前一个方法是同步的，返回承诺并不意味着该方法将异步执行。为了使这个方法异步运行，我们可以通过`setImmediate()`函数包装代码块。
- en: '`setImmediate()` is the JavaScript function which is used to interrupt the
    execution of the function and returns the callback function immediately, that
    eventually invokes the `onProgress()` function of promise in our case. Here is
    the modified version with the `setImmediate()` and `onProgress()` methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`setImmediate()`是JavaScript函数，用于中断函数的执行，并立即返回回调函数，最终在我们的情况下调用承诺的`onProgress()`函数。以下是带有`setImmediate()`和`onProgress()`方法的修改版本：'
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result of the preceding code snippet will be the same as shown in the previous
    example. However, the use of the `setImmediate()` function allows the `onProgress()`
    method to write messages to the console window asynchronously and is more efficient
    in terms of performance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段代码片段的结果将与前一个示例中的结果相同。然而，使用`setImmediate()`函数允许`onProgress()`方法异步地将消息写入控制台窗口，并且在性能方面更有效率。
- en: Other operations of promises
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 承诺的其他操作
- en: There are several other methods on promises that can be used to cancel any promises,
    chain promises, timeout, wrap, and so on. Let's look over each method and see
    how it can be used.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺上有几个其他方法可以用来取消任何承诺、链式调用承诺、超时、包装等。让我们看看每个方法是如何使用的。
- en: Chaining promises and handling errors
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 承诺链式调用和错误处理
- en: 'Multiple promises can be chained using `then` and based on the order they are
    chained, get executed one by one sequentially. Here is the simple example that
    loads the web page using the `WinJS.xhr()` method. This method is the built in
    method that returns a promise and we can use this method to make HTTP requests:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`then`链式调用多个承诺，并根据它们被链式调用的顺序一个接一个地顺序执行。以下是一个使用`WinJS.xhr()`方法的简单示例来加载网页。此方法是内置方法，返回一个承诺，我们可以使用此方法来发起HTTP请求：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code we are returning the next promise on every promise chain
    execution block. This is required when chaining promises otherwise it would not
    call the next promise in the pipeline. For the last promise in the pipeline, we
    have used `done` instead of `then` which actually tells us that there isn''t a
    promise next in the chain and no chaining can be done now. Another benefit is
    to perform error handling. In the `done` method, we can get all the errors being
    thrown by any of the promises in the chain. If we don''t use `done` then we will
    not be able to access any errors thrown in the promise chain. The following example
    is the modified version of the previous example with error handling:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个代码中，我们在每个承诺链执行块中返回下一个承诺。当链式调用承诺时需要这样做，否则它不会调用管道中的下一个承诺。对于管道中的最后一个承诺，我们使用了`done`而不是`then`，这实际上告诉我们链中没有下一个承诺，现在无法进行链式调用。另一个好处是执行错误处理。在`done`方法中，我们可以获取链中任何承诺抛出的所有错误。如果我们不使用`done`，那么我们将无法访问承诺链中抛出的任何错误。以下示例是带有错误处理的先前示例的修改版本：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding example we have used `done` in the final promise in the chain.
    Now, if you have noticed, the promise 2 URL is not valid and there is a typo mistake.
    Now if we execute the preceding code, `promise1` and `promise2` will be executed
    and will write the messages in the console log window. Whereas, the promise will
    not be executed but the `error` method will be invoked and defined under the `done`
    method and will write the error description in the console log window:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们在链中的最后一个承诺中使用了`done`。现在，如果你注意到了，承诺2的URL是不有效的，并且有一个拼写错误。现在如果我们执行前一个代码，`promise1`和`promise2`将被执行，并将消息写入控制台日志窗口。然而，承诺将不会执行，但`error`方法将在`done`方法下定义并被调用，并将错误描述写入控制台日志窗口：
- en: '![Chaining promises and handling errors](img/00054.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![承诺链式调用和错误处理](img/00054.jpeg)'
- en: Canceling promises
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消承诺
- en: 'Promises can be canceled by calling the `cancel` method on the `promise` object.
    The following is an example to cancel any promise:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`promise`对象的`cancel`方法来取消承诺。以下是一个取消任何承诺的示例：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Promises can only be canceled if it's not completed and went into the error
    state once it was canceled.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在承诺没有完成并且一旦取消就进入错误状态时，才能取消承诺。
- en: Joining promises
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结合承诺
- en: 'Multiple promises can be joined together and return when all of them are finished.
    We can join promises, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 多个承诺可以结合起来，当它们都完成后返回。我们可以像下面的代码那样结合承诺。
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Promise.any()` can be used in cases when we need to know if any of the defined
    promises inside the `any` method have executed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要知道`any`方法中定义的任何一个承诺是否执行时，可以使用`Promise.any()`：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Checking promise
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查承诺
- en: '`WinJS.Promise.is()` is a method that takes a value as a parameter and checks
    if that value is a promise or not. For example, calling `WinJS.xhr` in the `WinJS.Promise.is()`
    method will return `true`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`WinJS.Promise.is()`是一个方法，它接受一个值作为参数，并检查该值是否是一个承诺。例如，在`WinJS.Promise.is()`方法中调用`WinJS.xhr`将返回`true`：'
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Wrapping non-promise into promise
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将非承诺包装成承诺
- en: 'Any function can be wrapped into the promise using the `WinJS.Promise.as()`
    method. The following code wraps the non-promise `displayMessage()` method into
    a promise:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 任何函数都可以通过使用`WinJS.Promise.as()`方法将其包装成承诺。下面的代码将非承诺`displayMessage()`方法包装成一个承诺：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Exploring WinJS controls and styles
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索WinJS控件和样式
- en: Windows library for JavaScript provides a rich set of controls, databinding
    options, and promises and in this section we will explore a few popular controls
    and styling options.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的JavaScript库提供了一系列丰富的控件、数据绑定选项、承诺，在本节中，我们将探索一些流行的控件和样式选项。
- en: None of the WinJS controls have separate markup, instead WinJS library provides
    several attributes that can be used with the existing HTML elements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个WinJS控件有单独的标记，而是WinJS库提供了几个属性，可以用现有的HTML元素。
- en: Adding WinJS controls
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加WinJS控件
- en: As we have seen, there are no any markups for WinJS controls and they can be
    added through attributes on the HTML elements. WinJS controls can be added by
    adding any HTML element and setting its `data-win-control` attribute value to
    the name of the WinJS control.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，没有为WinJS控件添加任何标记，它们可以通过在HTML元素上添加属性来实现。
- en: In the following example, we are changing a simple HTML button element into
    the back button usually seen in store apps. And this can be done by adding the
    `data-win-control` attribute and setting a fully qualified name to `WinJS.UI.BackButton`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将一个简单的HTML按钮元素变成在商店应用中通常看到的后退按钮。这可以通过添加`data-win-control`属性和将完全限定名设置为`WinJS.UI.BackButton`来实现。
- en: 'Here is the HTML markup:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是HTML标记：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you run it, it will render a back button on the page, as shown in the
    following figure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，它将在页面上渲染一个后退按钮，如下面的图所示：
- en: '![Adding WinJS controls](img/00055.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![添加WinJS控件](img/00055.jpeg)'
- en: Also it does not only change the look but also provides the backward navigation
    functionality out of the box.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅改变了外观，还提供了箱式导航功能。
- en: Setting properties of WinJS controls
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置WinJS控件的属性
- en: 'Every HTML element has several properties which can be addressed by specifying
    values through attributes. For example, rating control allows a user to rate any
    item and we can set the properties, like the `max` and `min` range of stars to
    be displayed:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTML元素都有几个属性，可以通过指定值通过属性来寻址。例如，评分控件允许用户对任何项目进行评分，我们可以设置显示星星的`max`和`min`范围属性：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output of the preceding mark-up will generate a rating control like the
    following figure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个标记输出的结果将生成一个评分控件，如下面的图所示：
- en: '![Setting properties of WinJS controls](img/00056.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![设置WinJS控件的属性](img/00056.jpeg)'
- en: 'There are other Windows specific controls like `ListView`, `FlipView`, and
    `Zoom` that you can use in your page and bring high performance on large collections
    or objects. You can learn more about controls at the Windows Dev Center website
    at: [https://msdn.microsoft.com/en-us/library/windows/apps/mt502392.aspx](https://msdn.microsoft.com/en-us/library/windows/apps/mt502392.aspx)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的Windows特定控件，如`ListView`、`FlipView`和`Zoom`，你可以在页面中使用它们，在大量集合或对象上带来高性能。你可以在Windows开发者中心的网站上了解更多关于控件的信息：[https://msdn.microsoft.com/en-us/library/windows/apps/mt502392.aspx](https://msdn.microsoft.com/en-us/library/windows/apps/mt502392.aspx)
- en: Using Windows runtime features
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Windows运行时特性
- en: WinJS provides a complete API to use Windows runtime features and device specific
    features. When accessing the device specific features using WinJS, the web application
    should run as a windows application and accessing it from a browser will result
    in an error. Also, Microsoft has released the concept of Hosted apps which enable
    any web application to host as a windows application with a few configuration
    steps.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: WinJS提供了完整的API来使用Windows运行时功能和设备特定功能。当使用WinJS访问设备特定功能时，Web应用程序应作为Windows应用程序运行，从浏览器访问将导致错误。此外，微软还发布了Hosted
    apps的概念，它使任何Web应用程序能够通过几步配置作为Windows应用程序托管。
- en: Hosted apps and accessing the camera
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hosted apps和访问摄像头
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can add WinJS under the dependencies section and on saving the `package.json`
    file, the package will be downloaded automatically. We have to add gulp as well
    to copy the related libraries and CSS files in the `wwwroot` folder. After this,
    add the `gulpfile.js` and add the following script:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在依赖项部分添加WinJS，并在保存`package.json`文件时，包将自动下载。我们还需要添加gulp，以复制相关库和CSS文件到`wwwroot`文件夹中。之后，添加`gulpfile.js`并添加以下脚本：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you run the `build.lib` and `build.LibCss` tasks through a task runner
    tab in Visual Studio 2015, it will copy the WinJS libraries and `CSS` files inside
    the `wwwroot` folder:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过Visual Studio 2015中的任务运行器标签运行`build.lib`和`build.LibCss`任务时，它将在`wwwroot`文件夹内复制WinJS库和`CSS`文件：
- en: '![Creating the ASP.NET core application](img/00057.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![创建ASP.NET核心应用程序](img/00057.jpeg)'
- en: 'In this application, we will have a simple HTML page that we can directly add
    into the `wwwroot` folder, for this we need to call the `app.UseStaticFiles()`
    method in the `Configure()` method and add the package in `project.json`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将有一个简单的HTML页面，我们可以直接添加到`wwwroot`文件夹中，为此我们需要在`Configure()`方法中调用`app.UseStaticFiles()`方法，并在`project.json`中添加包：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s add the `Index.html` page inside the `wwwroot` folder and add the following
    scripts in the HTML head element:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`wwwroot`文件夹中添加`Index.html`页面，并在HTML头元素中添加以下脚本：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will be using the light Windows theme so add `ui-light.css`, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用浅色Windows主题，因此添加`ui-light.css`，如下所示：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now add the page content which contains a button `Capture` to capture the image
    and an image element to display the captured image:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加包含一个`Capture`按钮以捕获图像的页面内容，以及一个图像元素来显示捕获的图像：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the output of the page:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要输出的页面：
- en: '![Creating the ASP.NET core application](img/00058.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![创建ASP.NET核心应用程序](img/00058.jpeg)'
- en: 'Now add the following script to access the camera and attach the captured image
    with the image element:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加以下脚本以访问摄像头并将捕获的图像附加到图像元素：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Converting an ASP.NET application into Windows application using the Hosted
    app concept
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Hosted app概念将ASP.NET应用程序转换为Windows应用程序
- en: 'Converting any web application into the Windows application is very simple.
    In Visual Studio 2015 you can start creating a simple JavaScript based Windows
    application using the **Blank App (Universal Windows)** template as shown in the
    following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何Web应用程序转换为Windows应用程序非常简单。在Visual Studio 2015中，您可以开始使用**空白应用（通用Windows）**模板创建一个简单的基于JavaScript的Windows应用程序，如下所示：
- en: '![Converting an ASP.NET application into Windows application using the Hosted
    app concept](img/00059.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![将ASP.NET应用程序转换为Windows应用程序使用Hosted app概念](img/00059.jpeg)'
- en: When you add a project it will add the `css`, `images`, `js`, and `winjs` folders.
    We have to delete the `css`, `js`, and `winjs` folders as we will not be using
    any of the files in this project and configure the web application created above
    and transform it to a Windows application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加一个项目时，它会添加`css`、`images`、`js`和`winjs`文件夹。我们必须删除`css`、`js`和`winjs`文件夹，因为我们在这个项目中不会使用任何文件，并配置上面创建的Web应用程序，将其转换为Windows应用程序。
- en: 'Open the `package.appxmanifest` window. Add the URL in the **Start Page** textbox
    as shown in the following screenshot. Our sample ASP.NET application created above
    was hosted on port `41345`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`package.appxmanifest`窗口。在**启动页面**文本框中添加URL，如下所示。我们上面创建的示例ASP.NET应用程序托管在端口`41345`上：
- en: '![Converting an ASP.NET application into Windows application using the Hosted
    app concept](img/00060.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![将ASP.NET应用程序转换为Windows应用程序使用Hosted app概念](img/00060.jpeg)'
- en: 'In the **Content URIs** tab, add the URI of our web application and select
    **All** under **WinRT Access**. You can specify the URL of any web application
    which should be hosted somewhere. In the preceding screenshot we are using localhost
    which actually points to a web application hosted locally:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在**内容URI**标签中，添加我们网络应用程序的URI，并在**WinRT访问**下选择**全部**。您可以指定任何应该被托管在某处的网络应用程序的URL。在前面的截图中，我们使用localhost，它实际上指的是本地托管的网络应用程序：
- en: '![Converting an ASP.NET application into Windows application using the Hosted
    app concept](img/00061.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![使用宿主应用程序概念将ASP.NET应用程序转换为Windows应用程序](img/00061.jpeg)'
- en: This window allows us to specify access rules to WinRT features and we can set
    it to `None`, `All`, or `Allow for web only`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口允许我们指定对WinRT功能的访问规则，我们可以将其设置为`None`、`All`或仅`Web允许`。
- en: 'Building and running the application will show the windows application dialog
    hosting our web application `index.html` page:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序将在我们的网络应用程序`index.html`页面上显示窗口应用程序对话框：
- en: '![Converting an ASP.NET application into Windows application using the Hosted
    app concept](img/00062.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![使用宿主应用程序概念将ASP.NET应用程序转换为Windows应用程序](img/00062.jpeg)'
- en: 'Clicking on the **Capture** button will provide a popup of another dialog to
    take a snapshot, as shown in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**捕获**按钮将弹出另一个对话框以拍摄快照，如下所示：
- en: '![Converting an ASP.NET application into Windows application using the Hosted
    app concept](img/00063.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![使用宿主应用程序概念将ASP.NET应用程序转换为Windows应用程序](img/00063.jpeg)'
- en: 'After taking the desired shot, it will ask you to save or reject through tick
    and cross buttons:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在拍摄所需的照片后，它将通过勾选和交叉按钮询问您是否保存或拒绝：
- en: '![Converting an ASP.NET application into Windows application using the Hosted
    app concept](img/00064.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![使用宿主应用程序概念将ASP.NET应用程序转换为Windows应用程序](img/00064.jpeg)'
- en: 'Selecting tick will render the photo in the `img` HTML element, as shown in
    the following screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 选择勾选框将在`img` HTML元素中渲染照片，如下所示：
- en: '![Converting an ASP.NET application into Windows application using the Hosted
    app concept](img/00065.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![使用宿主应用程序概念将ASP.NET应用程序转换为Windows应用程序](img/00065.jpeg)'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the WinJS Windows library for JavaScript library
    which is open source and under an Apache license. We learned the core concepts
    of defining classes, namespaces, deriving classes, mixins, and promises. We also
    looked into the databinding techniques and how to use the windows controls or
    attributes in HTML elements to change the behavior and look and feel of the control.
    And finally, we used the WinRT API to access the device camera in our web application
    and learned the concept of Hosted app and transforming any web application into
    the Windows apps using the Universal Window template in Visual Studio 2015\. In
    the next chapter, we will learn about a few good design patterns that can be implemented
    in JavaScript to achieve specific requirements.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了WinJS Windows库，这是一个开源且遵循Apache许可的JavaScript库。我们学习了定义类、命名空间、继承类、混合模式和承诺的核心概念。我们还研究了数据绑定技术，以及如何使用HTML元素中的窗口控件或属性来改变控件的行为和外观。最后，我们使用了WinRT
    API在我们的网络应用程序中访问设备摄像头，并学习了宿主应用程序的概念，以及如何使用Visual Studio 2015中的通用窗口模板将任何网络应用程序转换为Windows应用程序。在下一章中，我们将学习一些可以在JavaScript中实现的设计模式，以满足特定需求。
