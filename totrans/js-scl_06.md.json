["```js\n// users.js\nexport default class Users {\n\n    // Accepts a \"collection\" array, and an \"order\"\n    // string.\n    constructor(collection, order) {\n        this.collection = collection;\n        this.order = order;\n\n        // Creates an iterator so we can iterate over\n        // the \"collection\" array without having to\n        // directly access it.\n        this[Symbol.iterator] = function*() {\n            for (let user of this.collection) {\n                yield user;\n            }\n        };\n    }\n\n    set order(order) {\n\n        // When the order break it down into it's parts,\n        // the \"key\" and the \"direction\".\n        var [ key, direction ] = order.split(' ');\n\n        // Sorts the collection. If the property value can be\n        // converted to lower case, they it's converted to avoid\n        // case inconsistencies.\n        this.collection.sort((a, b) => {\n            var aValue = typeof a[key].toLowerCase === 'function' ?\n                a[key].toLowerCase() : a[key];\n\n            var bValue = typeof b[key].toLowerCase === 'function' ?\n                b[key].toLowerCase() : b[key];\n\n            if (aValue < bValue) {\n                return -1;\n            } else if (aValue > bValue) {\n                return 1;\n            } else {\n                return 0;\n            }\n        });\n\n        // If the direction is \"desc\", we need to reverse the sort.\n        if (direction === 'desc') {\n            this.collection.reverse();\n        }\n    }\n\n}\n\n// main.js\nimport Users from 'users.js';\n\nvar users = new Users([\n    { name: 'Albert' },\n    { name: 'Craig' },\n    { name: 'Beth' }\n], 'name');\n\nconsole.log('Ascending order...');\nfor (let user of users) {\n    console.log(user.name);\n}\n//\n// Albert\n// Beth\n// Craig\n\nusers.order = 'name desc';\n\nconsole.log('Descending order...');\nfor (let user of users) {\n    console.log(user.name);\n}\n//\n// Craig\n// Beth\n// Albert\n```", "```js\n// users.js\nexport default class Users {\n\n    // The users collection excepts data, and an\n    // \"order\" property name.\n    constructor(collection, order) {\n        this.collection = collection;\n        this.order = order;\n        this.ordered = !!order;\n    }\n\n    // Whenever the \"order\" property is set, we need\n    // to sort the internal \"collection\" array.\n    set order(key) {\n        this.collection.sort((a, b) => {\n            if (a[key] < b[key]) {\n                return -1;\n            } else if (a[key] > b[key]) {\n                return 1;\n            } else {\n                return 0;\n            }\n        });\n    }\n\n    // Finds the smallest item of the collection. If the\n    // collection is ordered, then we can just return the\n    // first collection item. Otherwise, we need to iterate\n    // over the collection to find the smallest item.\n    min(key) {\n        if (this.ordered) {\n            return this.collection[0];\n        } else {\n            var result = {};\n            result[key] = Number.POSITIVE_INFINITY;\n\n            for (let item of this.collection) {\n                if (item[key] < result[key]) {\n                    result = item;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    // The inverse of the \"min()\" function, returns the\n    // last collection item if ordered. Otherwise, it looks\n    // for the largest item.\n    max(key) {\n        if (this.ordered) {\n            return this.collection[this.collection.length - 1];\n        } else {\n            var result = {};\n            result[key] = Number.NEGATIVE_INFINITY;\n\n            for (let item of this.collection) {\n                if (item[key] > result[key]) {\n                    result = item;\n                }\n            }\n\n            return result;\n        }\n    }\n\n}\n\n// main.js\nimport Users from 'users.js';\n\nvar users;\n\n// Creates an \"ordered\" users collection.\nusers = new Users([\n    { age: 23 },\n    { age: 19 },\n    { age: 51 },\n    { age: 39 }\n], 'age');\n\n// Calling \"min()\" and \"max()\" doesn't result in\n// two iterations over the collection because they're\n// already ordered.\nconsole.log('ordered min', users.min());\nconsole.log('ordered max', users.max());\n//\n// ordered min {age: 19}\n// ordered max {age: 51}\n\n// Creates an \"unordered\" users collection.\nusers = new Users([\n    { age: 23 },\n    { age: 19 },\n    { age: 51 },\n    { age: 39 }\n]);\n\n// Every time \"min()\" or \"max()\" is called, we\n// have to iterate over the collection to find\n// the smallest or largest item.\nconsole.log('unordered min', users.min('age'));\nconsole.log('unordered max', users.max('age'));\n//\n// unordered min {age: 19}\n// unordered max {age: 51}\n```"]