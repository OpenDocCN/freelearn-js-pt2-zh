- en: Chapter 5. JavaScript Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 JavaScript模式
- en: 'So far, we have looked at several fundamental building blocks necessary to
    write code in JavaScript. Once you start building larger systems using these fundamental
    constructs, you soon realize that there can be a standard way of doing a few things.
    While developing a large system, you will encounter repetitive problems; a pattern
    intends to provide a standardized solution to such known and identified problems.
    A pattern can be seen as a best practice, useful abstraction, or template to solve
    common problems. Writing maintainable code is difficult. The key to write modular,
    correct, and maintainable code is the ability to understand the repeating themes
    and use common templates to write optimized solutions to these. The most important
    text on design patterns was a book published in 1995 called *Design Patterns:
    Elements Of Reusable Object-Oriented Software* written by *Erich Gamma, Richard
    Helm, Ralph Johnson, and John Vlissides*—a group that became known as the **Gang**
    **of Four** (**GOF** for short). This seminal work gave a formal definition to
    various patterns and explained implementation details of most of the popular patterns
    that we use today. It is important to understand why patterns are important:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了几个编写JavaScript代码所必需的基本构建块。一旦你开始使用这些基本构建块来构建更大的系统，你很快就会意识到有些事情可能有一种标准的方法。在开发大型系统时，你会遇到重复的问题；模式旨在为这些已知和识别的问题提供标准化的解决方案。模式可以被视为最佳实践、有用的抽象或模板来解决常见问题。编写可维护的代码是困难的。编写模块化、正确和可维护的代码的关键是理解重复的主题并使用通用模板来编写这些优化的解决方案。关于设计模式的最重要文本是一本于1995年出版的书籍，名为《设计模式：可重用面向对象软件的元素》，作者是埃里希·伽玛（Erich
    Gamma）、理查德·赫尔姆（Richard Helm）、拉尔夫·约翰逊（Ralph Johnson）和约翰·维利斯ides（John Vlissides）——一个被称为**四人帮**（简称GOF）的团队。这本开创性的作品给出了各种模式的正式定义，并解释了今天我们使用的大多数流行模式的实现细节。理解模式的重要性是非常重要的：
- en: 'Patterns offer proven solutions to common problems: Patterns provide templates
    that are optimized to solve a particular problem. These patterns are backed by
    solid engineering experience and tested for validity.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式提供了解决常见问题的经过验证的解决方案：模式提供了优化解决特定问题的模板。这些模式得到了坚实的工程经验支持，并经过验证。
- en: 'Patterns are designed to be reused: They are generic enough to fit variations
    of a problem.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式旨在被重用：它们足够通用，可以适应问题的变体。
- en: 'Patterns define vocabulary: Patterns are well-defined structures and hence
    provide a generic vocabulary to the solution. This can be very expressive when
    communicating across a larger group.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式定义了词汇：模式是定义良好的结构，因此为解决方案提供了一个通用的词汇。这在跨大型团队沟通时非常有表现力。
- en: Design patterns
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: 'In this chapter, we will take a look at some of the design patterns that make
    sense for JavaScript. However, coding patterns are very specific for JavaScript
    and are of great interest to us. While we spend a lot of time and effort trying
    to understand and master design patterns, it is important to understand anti-patterns
    and how to avoid pitfalls. In the usual software development cycle, there are
    several places where bad code is introduced, mainly around the time where the
    code is nearing a release or when the code is handed over to a different team
    for maintenance. If such bad design constructs are documented as anti-patterns,
    they can provide guidance to developers in knowing what pitfalls to avoid and
    how not to subscribe to bad design patterns. Most languages have their set of
    anti-patterns. Based on the kind of problems that they solve, design patterns
    were categorized into a few broad categories by the GOF:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些适用于JavaScript的设计模式。然而，编码模式对于JavaScript来说非常具体，对我们来说也非常重要。虽然我们花费了大量时间和精力来理解和掌握设计模式，但理解反模式以及如何避免陷阱也同样重要。在通常的软件开发周期中，有几种地方可能会引入糟糕的代码，主要是在代码接近发布的时候，或者当代码交给另一个团队进行维护时。如果将这些糟糕的设计结构记录为反模式，它们可以指导开发者知道该避免哪些陷阱，以及如何不采用糟糕的设计模式。大多数语言都有它们自己的反模式。根据它们解决的问题类型，设计模式被GOF归类为几个大类：
- en: '**Creational design patterns**: These patterns deal with various mechanisms
    of object creation. While most languages provide basic object creation methods,
    these patterns look at optimized or more controlled mechanisms of object creation.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型设计模式**：这些模式处理各种对象创建机制。尽管大多数语言提供了基本对象创建方法，但这些模式关注对象创建的优化或更受控的机制。'
- en: '**Structural design patterns**: These patterns are all about the composition
    of objects and relationships among them. The idea is to have minimal impact on
    overall object relationships when something in the system changes.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构设计模式**：这些模式都是关于对象及其之间关系的组合。想法是在系统中的某处发生变化时，对整体对象关系的影响最小。'
- en: '**Behavioral design patterns**: These patterns focus on the interdependency
    and communication between objects.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为设计模式**：这些模式专注于对象之间的相互依赖和通信。'
- en: 'The following table is a useful ready reckoner to identify categories of patterns:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的表格是一个有用的工具，用于识别模式的类别：
- en: 'Creational patterns:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型模式：
- en: Factory method
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法
- en: Abstract factory
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Builder
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者
- en: Prototype
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Singleton
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: 'Structural patterns:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构模式：
- en: Adapter
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Bridge
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接
- en: Composite
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Decorator
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Façade
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观
- en: Flyweight
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元
- en: Proxy
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Behavioral patterns
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为模式
- en: Interpreter
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: Template method
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Chain of responsibility
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Command
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Iterator
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Mediator
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者
- en: Memento
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Observer
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: State
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Strategy
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Visitor
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Some patterns that we will discuss in this chapter may not be part of this list
    as they are more specific to JavaScript or a variation of these classical patterns.
    Similarly, we will not discuss patterns that do not fit into JavaScript or are
    not in popular use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将讨论的一些模式可能不包括在此列表中，因为它们更特定于JavaScript或这些经典模式的一种变体。同样，我们也不会讨论不适合JavaScript或不常用的模式。
- en: The namespace pattern
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间模式
- en: 'Excessive use of the global scope is almost a taboo in JavaScript. When you
    build larger programs, it is sometimes difficult to control how much the global
    scope is polluted. Namespace can reduce the number of globals created by the program
    and also helps in avoiding naming collisions or excessive name prefixing. The
    idea of using namespaces is creating a global object for your application or library
    and adding all these objects and functions to that object rather than polluting
    the global scope with objects. JavaScript doesn''t have an explicit syntax for
    namespaces, but namespaces can be easily created. Let''s consider the following
    example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中过度使用全局作用域几乎是一种禁忌。当你构建更大的程序时，有时很难控制全局作用域被污染的程度。命名空间可以减少程序创建的全局变量数量，并帮助避免命名冲突或过度的前缀命名。使用命名空间的想法是创建一个全局对象，为您的应用程序或库添加所有这些对象和函数，而不是用对象污染全局作用域。JavaScript没有显式的语法来定义命名空间，但命名空间可以很容易地创建。考虑以下示例：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are creating all this in the global scope. This is an anti-pattern, and
    this is never a good idea. We can, however, refactor this code and create a single
    global object and make all the functions and objects part of this global object
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在全局作用域中创建所有这些内容。这是一个反模式，这从来不是一个好主意。然而，我们可以重构这个代码，创建一个全局对象，并让所有的函数和对象成为这个全局对象的一部分，如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By convention, the global namespace object name is generally written in all
    caps. This pattern adds namespace to the application and prevents naming collisions
    in your code and between your code and external library that you use. Many projects
    use a distinct name after their company or project to create a unique name for
    their namespace.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，全局命名空间对象名称通常全部用大写书写。这种模式为应用程序添加了命名空间，防止了您的代码以及您的代码与使用的第三方库之间的命名冲突。许多项目在其公司或项目名后使用独特名称来为他们的命名空间创建唯一名称。
- en: Though this seems like an ideal way to restrict your globals and add a namespace
    to your code, it is a bit verbose; you need to prefix every variable and function
    with the namespace. You need to type more and the code becomes unnecessarily verbose.
    Additionally, a single global instance would mean that any part of the code can
    modify the global instance and the rest of the functionality gets the updated
    state—this can cause very nasty side-effects. A curious thing to observe in the
    earlier example is this line—`var CARFACTORY = CARFACTORY || {};`. When you are
    working on a large code base, you can't assume that you are creating this namespace
    (or assigning a property to it) for the first time. It is possible that the namespace
    may pre-exist. To make sure that you create the namespace only if it is not already
    created, it is safe to always rely on the quick defaulting via a short-circuit
    `||` operator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这似乎是一种理想的方式来限制你的全局变量并为你的代码添加一个命名空间，但它有点冗长；你需要为每个变量和函数加上命名空间前缀。你需要输入更多内容，代码变得不必要地冗长。此外，单一的全局实例意味着代码的任何部分都可以修改全局实例，其余的功能得到更新状态—这可能会导致非常糟糕的副作用。在之前的例子中，一个有趣的现象是这一行—`var
    CARFACTORY = CARFACTORY || {};`. 当你在一个大型代码库上工作时，你不能假设你正在为这个命名空间（或者给它分配一个属性）创建第一次。有可能命名空间已经存在。为了确保只有当命名空间尚未创建时才创建命名空间，始终依赖通过短路`||`操作符的快速默认是安全的。
- en: The module pattern
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块模式
- en: As you build large applications, you will soon realize that it becomes increasingly
    difficult to keep the code base organized and modular. The module patterns help
    in keeping the code cleanly separated and organized.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你构建大型应用程序，你很快会意识到保持代码库的组织和模块化变得越来越困难。模块模式有助于保持代码清晰地分离和组织。
- en: Module separates bigger programs into smaller pieces and gives them a namespace.
    This is very important because once you separate code into modules, these modules
    can be reused in several places. Carefully designing interfaces for the modules
    will make your code very easy to reuse and extend.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 模块将更大的程序分成更小的部分，并赋予它们一个命名空间。这非常重要，因为一旦你将代码分成模块，这些模块可以在多个地方重复使用。仔细设计模块的接口将使您的代码非常易于重用和扩展。
- en: JavaScript offers flexible functions and objects that make it easy to create
    robust module systems. Function scopes help create namespaces that are internal
    for the module, and objects can be used to store sets of exported values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了灵活的函数和对象，这使得创建健壮的模块系统变得容易。函数作用域有助于创建模块内部的命名空间，而对象可用于存储一系列导出的值。
- en: Before we start exploring the pattern itself, let's quickly brush up on a few
    concepts that we discussed earlier.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索模式本身之前，让我们快速回顾一下我们之前讨论的一些概念。
- en: 'We discussed object literals in detail. Object literals allow you to create
    name-value pairs as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论了对象字面量。对象字面量允许你按照如下方式创建名称-值对：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we are creating an object literal and defining key-value pairs
    to create properties and functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个对象字面量，并定义了键值对来创建属性和函数。
- en: In JavaScript, the module pattern is used very heavily. Modules help in mimicking
    the concept of classes. Modules allow us to include both public/private methods
    and variables of an object, but most importantly, modules restrict these parts
    from the global scope. As the variables and functions are contained in the module
    scope, we automatically prevent naming conflict with other scripts using the same
    names.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，模块模式被广泛使用。模块有助于模仿类的概念。模块允许我们包含一个对象的公共/私有方法和变量，但最重要的是，模块将这些部分限制在全局作用域之外。由于变量和函数被包含在模块作用域内，我们自动防止了与其他使用相同名称的脚本发生命名冲突。
- en: Another beautiful aspect of the module pattern is that we expose only a public
    API. Everything else related to the internal implementation is held private within
    the module's closure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式的另一个美丽方面是，我们只暴露公共API。与内部实现相关的所有其他内容都在模块的闭包内保持私有。
- en: Unlike other OO languages, JavaScript has no explicit access modifiers and,
    hence, there is no concept of *privacy*. You can't have public or private variables.
    As we discussed earlier, in JavaScript, the function scope can be used to enforce
    this concept. The module pattern uses closures to restrict variable and function
    access only within the module; however, variables and functions are defined in
    the object being returned, which is available to the public.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他面向对象的编程语言不同，JavaScript没有显式的访问修饰符，因此，没有*隐私*的概念。你不能有公共变量或私有变量。如我们之前讨论的，在JavaScript中，函数作用域可以用来强制这个概念。模块模式使用闭包来限制变量和函数的访问仅限于模块内部；然而，变量和函数是在被返回的对象中定义的，这对外部是可用的。
- en: 'Let''s consider the earlier example and turn this into a module. We are essentially
    using an IIFE and returning the interface of the module, namely, the `init` and
    `updateStartup` functions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑之前的例子，将其转换为模块。我们实际上是在使用一个立即执行的函数表达式（IIFE），并返回模块的接口，即`init`和`updateStartup`函数：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, `basicServerConfig` is created as a module in the global context.
    To make sure that we are not polluting the global context with modules, it is
    important to create namespaces for the modules. Moreover, as modules are inherently
    reused, it is important to make sure that we avoid naming conflicts using namespaces.
    For the `basicServerConfig` module, the following snippet shows you the way to
    create a namespace:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`basicServerConfig`作为全局上下文中的一个模块创建。为了确保我们不会污染全局上下文，创建模块时命名空间很重要。此外，由于模块本质上是可以重用的，确保我们使用命名空间避免命名冲突也很重要。对于`basicServerConfig`模块，以下代码片段展示了创建命名空间的方法：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using namespace with modules is generally a good idea; however, it is not required
    that a module must have a namespace associated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间与模块通常是好主意；然而，并不是说模块必须与命名空间相关联。
- en: 'A variation of the module pattern tries to overcome a few problems of the original
    module pattern. This improved variation of the module pattern is also known as
    the **revealing** **module pattern** (**RMP**). RMP was first popularized by *Christian
    Heilmann*. He disliked that it was necessary to use the module name while calling
    a public function from another function or accessing a public variable. Another
    small problem is that you have to use an object literal notation while returning
    the public interface. Consider the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式的一种变体试图克服原始模块模式的一些问题。这种改进的模块模式也被称为**揭示**模块模式（**RMP**）。RMP最初由*Christian Heilmann*普及。他不喜欢在从另一个函数调用公共函数或访问公共变量时必须使用模块名。另一个小问题是，你必须在返回公共接口时使用对象字面量表示法。考虑以下示例：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that we need to call `publicFnTwo()` via `modulePattern` in `publicFn()`.
    Additionally, the public interface is returned in an object literal. The improvement
    on the classic module pattern is what is known as the RMP. The primary idea behind
    this pattern is to define all of the members in the private scope and return an
    anonymous object with pointers to the private functionality that needs to be revealed
    as public.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在`publicFn()`中我们需要通过`modulePattern`调用`publicFnTwo()`。此外，公共接口是以对象字面量返回的。改进经典的模块模式的就是所谓的RMP。这个模式背后的主要思想是在私有作用域中定义所有成员，并返回一个匿名对象，该对象指向需要作为公共接口公开的私有功能。
- en: 'Let''s see how we can convert our previous example to an RMP. This example
    is heavily inspired from Christian''s blog:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将我们之前的示例转换为RMP。这个示例深受Christian博客的启发：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An important distinction here is that you define functions and variables in
    the private scope and return an anonymous object with pointers to the private
    variables and functions that you want to reveal as public. This is a much cleaner
    variation and should be preferred over the classic module pattern.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的一个重要区别是，你在私有作用域中定义函数和变量，并返回一个匿名对象，该对象指向你想作为公共接口公开的私有变量和函数。这是一个更干净的变体，应优先于经典模块模式。
- en: 'In production code, however, you would want to use more a standardized approach
    to create modules. Currently, there are two main approaches to create modules.
    The first is known as **CommonJS modules**. CommonJS modules are usually more
    suited for server-side JavaScript environments such as **Node.js**. A CommonJS
    module contains a `require()` function that receives the name of the module and
    returns the module''s interface. The format was proposed by the volunteer group
    of CommonJS; their aim was to design, prototype, and standardize JavaScript APIs.
    CommonJS modules consist of two parts. Firstly, list of variables and functions
    the module needs to expose; when you assign a variable or function to the `module.exports`
    variable, it is exposed from the module. Secondly, a `require` function that modules
    can use to import the exports of other modules:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在生产代码中，你希望使用一种更标准的模块创建方法。目前，创建模块主要有两种方法。第一种被称为**CommonJS模块**。CommonJS模块通常更适合服务器端JavaScript环境，如**Node.js**。一个CommonJS模块包含一个`require()`函数，该函数接收模块的名称并返回模块的接口。该格式是由CommonJS的志愿者小组提出的；他们的目标是设计、原型化和标准化JavaScript
    API。CommonJS模块由两部分组成。首先，模块需要暴露的变量和函数列表；当你将一个变量或函数赋值给`module.exports`变量时，它就从模块中暴露出来。其次，一个`require`函数，模块可以使用它来导入其他模块的导出：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: CommonJS modules are supported by Node.js on the server and **curl.js** in the
    browser.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS模块在服务器端的Node.js和浏览器端的**curl.js**中得到支持。
- en: 'The other flavor of JavaScript modules is called **Asynchronous Module Definition**
    (**AMD**). They are browser-first modules and opt for asynchronous behavior. AMD
    uses a `define` function to define the modules. This function takes an array of
    module names and a function. Once the modules are loaded, the `define` function
    executes the function with their interface as an argument. The AMD proposal is
    aimed at the asynchronous loading of both the module and dependencies. The `define`
    function is used to define named or unnamed modules based on the following signature:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript模块的另一种形式被称为**异步模块定义**（**AMD**）。它们是以浏览器为首要目标的模块，并选择异步行为。AMD使用一个`define`函数来定义模块。这个函数接受一个模块名称数组和一个函数。一旦模块被加载，`define`函数就带着它们的接口作为参数执行这个函数。AMD提案旨在异步加载模块及其依赖项。`define`函数用于根据以下签名定义命名或未命名模块：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can add a module without dependencies as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以如下添加一个无依赖的模块：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `require` module is used as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`模块的使用如下：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**RequireJS** ([http://requirejs.org/docs/whyamd.html](http://requirejs.org/docs/whyamd.html))
    is one of the module loaders that implements AMD.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**RequireJS**([http://requirejs.org/docs/whyamd.html](http://requirejs.org/docs/whyamd.html))是实现AMD的模块加载器之一。'
- en: ES6 modules
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES6模块
- en: 'Two separate module systems and different module loaders can be a bit intimidating.
    ES6 tries to solve this. ES6 has a proposed module specification that tries to
    keep the good aspects of both the CommonJS and AMD module patterns. The syntax
    of ES6 modules is similar to CommonJS and the ES6 modules support asynchronous
    loading and configurable module loading:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 两种不同的模块系统和不同的模块加载器可能会让人感到有些害怕。ES6试图解决这个问题。ES6有一个拟定的模块规范，试图保留CommonJS和AMD模块模式的优点。ES6模块的语法类似于CommonJS，并且ES6模块支持异步加载和可配置的模块加载：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ES6 export lets you export a function or variable in a way similar to CommonJS.
    In the code where you want to use this imported function, you use the `import`
    keyword to specify from where you want the dependency to be imported. Once the
    dependency is imported, it can be used as a member of the program. We will discuss
    in later chapters how you can use ES6 in environments where ES6 is not supported.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ES6导出允许你以类似于CommonJS的方式导出一个函数或变量。在需要使用这个导入的函数的代码中，你使用`import`关键字来指定你想从哪里导入这个依赖。一旦依赖被导入，它就可以作为程序的一个成员使用。我们将在后面的章节中讨论如何在不支持ES6的环境中使用ES6。
- en: The factory pattern
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: 'The factory pattern is another popular object creation pattern. It does not
    require the usage of constructors. This pattern provides an interface to create
    objects. Based on the type passed to the factory, that particular type of object
    is created by the factory. A common implementation of this pattern is usually
    using a class or static method of a class. The purposes of such a class or method
    are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是另一种流行的对象创建模式。它不需要使用构造函数。这个模式提供了一个接口来创建对象。基于传递给工厂的类型，该特定类型的对象由工厂创建。这个模式的一个常见实现通常是使用类的构造函数或静态方法。这样的类或方法的目的如下：
- en: It abstracts out repetitive operations when creating similar objects
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它抽象了创建类似对象时的重复操作
- en: It allows the consumers of the factory to create objects without knowing the
    internals of the object creation
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许消费者不了解对象创建的内部细节就能创建对象
- en: 'Let''s take a common example to understand the usage of a factory. Let''s say
    that we have the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个常见的例子来了解工厂的使用。假设我们有以下内容：
- en: A constructor, `CarFactory()`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数，`CarFactory()`
- en: A static method in `CarFactory` called `make()` that knows how to create objects
    of the `car` type
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`CarFactory`中有一个名为`make()`的静态方法，它知道如何创建`car`类型的对象
- en: Specific `car` types such as `CarFactory.SUV`, `CarFactory.Sedan`, and so on
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体的`car`类型，如`CarFactory.SUV`、`CarFactory.Sedan`等
- en: 'We want to use `CarFactory` as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望如下使用`CarFactory`：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here is how you would implement such a factory. The following implementation
    is fairly standard. We are programmatically calling the constructor function that
    creates an object of the specified type—`CarFactory[const].prototype = new CarFactory();`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现这样一个工厂的方法。以下实现相当标准。我们通过编程调用构造函数来创建指定类型的对象——`CarFactory[const].prototype
    = new CarFactory();`。
- en: 'We are mapping object types to the constructors. There can be variations in
    how you can go about implementing this pattern:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在映射对象类型到构造函数。实现这个模式可能有以下几种变化：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We suggest that you try this example in JS Bin and understand the concept by
    actually writing its code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在JS Bin中尝试这个例子，并通过实际编写代码来理解这个概念。
- en: The mixin pattern
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混入模式
- en: 'Mixins help in significantly reducing functional repetition in our code and
    help in function reuse. We can move this shared functionality to a mixin and reduce
    duplication of shared behavior. You can then focus on building the actual functionality
    and not keep repeating the shared behavior. Let''s consider the following example.
    We want to create a custom logger that can be used by any object instance. The
    logger will become a functionality shared across objects that want to use/extend
    the mixin:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 混入有助于显著减少我们代码中的功能重复，并有助于功能重用。我们可以将共享功能移动到混入中，减少共享行为的重复。这样，您就可以专注于构建实际功能，而不必重复共享行为。让我们考虑以下示例。我们想要创建一个可以被任何对象实例使用的自定义日志记录器。日志记录器将成为需要在使用/扩展混入的对象之间共享的功能：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we are using `_.extend` from **Underscore.js**—we discussed
    this function in the previous chapter. This function is used to copy all the properties
    from the source (`Logger`) to the destination (`CustomServer.prototype`). As you
    can observe in this example, we are creating a shared `CustomLogger` object that
    is intended to be used by any object instance needing its functionality. One such
    object is `CustomServer`—in its `init()` method, we call this custom logger's
    `log()` method. This method is available to `CustomServer` because we are extending
    `CustomLogger` via Underscore's `extend()`. We are dynamically adding functionality
    of a mixin to the consumer object. It is important to understand the distinction
    between mixins and inheritance. When you have shared functionality across multiple
    objects and class hierarchies, you can use mixins. If you have shared functionality
    along a single class hierarchy, you can use inheritance. In prototypical inheritance,
    when you inherit from a prototype, any change to the prototype affects everything
    that inherits the prototype. If you do not want this to happen, you can use mixins.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了来自**Underscore.js**的`_.extend`——我们在上一章讨论了这个函数。这个函数用于将源（`Logger`）的所有属性复制到目标（`CustomServer.prototype`）。正如您在这个例子中观察到的，我们创建了一个共享的`CustomLogger`对象，旨在被任何需要其功能的对象实例使用。这样一个对象是`CustomServer`——在其`init()`方法中，我们调用这个自定义日志记录器的`log()`方法。这个方法对`CustomServer`是可用的，因为我们通过Underscore的`extend()`将`CustomLogger`扩展到`CustomServer`。我们动态地将混入的功能添加到消费者对象中。理解混入和继承之间的区别很重要。当您在多个对象和类层次结构中有共享功能时，您可以使用混入。如果您在单一的类层次结构中有共享功能，您可以使用继承。在原型继承中，当你从原型继承时，对原型的任何更改都会影响继承原型的一切。如果您不想这样，可以使用混入。
- en: The decorator pattern
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: 'The primary idea behind the decorator pattern is that you start your design
    with a plain object, which has some basic functionality. As the design evolves,
    you can use existing decorators to enhance your plain object. This is a very popular
    pattern in the OO world and especially in Java. Let''s take an example of `BasicServer`—a
    server with very basic functionality. This basic functionality can be decorated
    to serve specific purposes. We can have two different cases where this server
    can serve both PHP and Node.js and serve them on different ports. These different
    functionality are decorated to the basic server:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式背后的主要思想是，你应以一个具有某些基本功能的普通对象开始你的设计。随着设计的演变，你可以使用现有的装饰器来增强你的普通对象。这是一种在面向对象世界中非常流行的模式，尤其是在Java中。让我们以`BasicServer`为例，这是一个具有非常基本功能的服务器。这些基本功能可以通过装饰来服务于特定目的。我们可以有两个不同的情况，这个服务器可以同时服务于PHP和Node.js，并在不同的端口上提供服务。这些不同的功能是通过装饰基本服务器实现的：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Node.js server will have something as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 节点服务器将具有以下内容：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are several ways in which the decorator pattern is implemented in JavaScript.
    We will discuss a method where the pattern is implemented by a list and does not
    rely on inheritance or method call chain:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中实现装饰器模式有几种方法。我们将讨论一种方法，其中模式通过列表实现，不依赖于继承或方法调用链：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`BasicServer.decorate()` and `BasicServer.init()` are the two methods where
    the real stuff happens. We push all decorators being applied to the list of decorators
    for `BasicServer`. In the `init()` method, we execute or apply each decorator''s
    `init()` method from this list of decorators. This is a cleaner approach to decorator
    patterns that does not use inheritance. This method was described by Stoyan Stefanov
    in his book, *JavaScript Patterns, O''Reilly Media*, and has gained prominence
    among JavaScript developers due to its simplicity.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicServer.decorate()`和`BasicServer.init()`是两个真正发生事情的方法。我们将所有要应用到`BasicServer`上的装饰器推送到`BasicServer`的装饰器列表中。在`init()`方法中，我们从这些装饰器列表中执行或应用每个装饰器的`init()`方法。这是一种不使用继承的更清洁的装饰器模式方法。这种方法在Stoyan
    Stefanov的书中《JavaScript模式，O''Reilly媒体》中有描述，因其简单性而在JavaScript开发者中得到了重视。'
- en: The observer pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'Let''s first see the language-agnostic definition of the observer pattern.
    The GOF book, *Design Patterns: Elements of Reusable Object-Oriented Software*,
    defines the observer pattern as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看观察者模式的语言无关定义。在GOF的书中，《设计模式：可重用面向对象软件的元素》，定义观察者模式如下：
- en: '*One or more observers are interested in the state of a subject and register
    their interest with the subject by attaching themselves. When something changes
    in our subject that the observer may be interested in, a notify message is sent
    which calls the update method in each observer. When the observer is no longer
    interested in the subject''s state, they can simply detach themselves.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或多个观察者对主题的状态感兴趣，并通过附着自身向主题注册他们的兴趣。当主题中发生观察者可能感兴趣的变化时，会发送一个通知消息，调用每个观察者的更新方法。当观察者不再对主题的状态感兴趣时，他们可以简单地将自己分离。
- en: 'In the observer design pattern, the subject keeps a list of objects depending
    on it (called observers) and notifies them when the state changes. The subject
    uses a broadcast to the observers to inform them of the change. Observers can
    remove themselves from the list once they no longer wish to be notified. Based
    on this understanding, we can define the participants in this pattern:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者设计模式中，主题保持一个依赖于它的对象列表（称为观察者），并在状态变化时通知它们。主题使用广播向观察者通知变化。观察者可以在不再希望收到通知时从列表中删除自己。基于这种理解，我们可以定义此模式中的参与者：
- en: '**Subject**: This keeps the list of observers and has methods to add, remove,
    and update observers'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：它保持观察者的列表，并具有添加、删除和更新观察者的方法'
- en: '**Observer**: This provides an interface for objects that need to be notified
    when the subject''s state changes'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：为需要在主题状态变化时通知的对象提供接口'
- en: 'Let''s create a subject that can add, remove, and notify observers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以添加、删除和通知观察者的主题：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a fairly straightforward implementation of a `Subject`. The important
    fact about the `notify()` method is the way in which all the observer objects'
    `update()` methods are called to broadcast the update.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接实现的`Subject`。关于`notify()`方法的重要事实是，所有观察者对象`update()`方法的调用方式，以广播方式更新。
- en: 'Now let''s define a simple object that creates random tweets. This object is
    providing an interface to add and remove observers to the `Subject` via `addObserver()`
    and `removeObserver()` methods. It also calls the `notify()` method of `Subject`
    with the newly fetched tweet. When this happens, all the observers will broadcast
    that the new tweet has been updated with the new tweet being passed as the parameter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个创建随机推文的简单对象。这个对象提供了一个接口，通过 `addObserver()` 和 `removeObserver()` 方法向
    `Subject` 添加和删除观察者。它还调用 `Subject` 的 `notify()` 方法，并传递新获取的推文。当这种情况发生时，所有观察者都会传播新推文已更新，新推文作为参数传递：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s now add two observers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加两个观察者：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Both these observers will have one `update()` method that will be called by
    the `Subject.notify()` method. Now we can actually add these observers to the
    `Subject` via Tweeter''s interface:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个观察者都只有一个 `update()` 方法，该方法将由 `Subject.notify()` 方法调用。现在我们实际上可以通过推特的界面将这些观察者添加到
    `Subject` 中：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will result in the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a basic implementation to illustrate the idea of the observer pattern.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的实现，用于说明观察者模式的思想。
- en: JavaScript Model-View-* patterns
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 模型-视图*模式
- en: '**Model-View-Controller** (**MVC**), **Model-View-Presenter** (**MVP**), and
    **Model-View-ViewModel** (**MVVM**) have been popular with server applications,
    but in recent years JavaScript applications are also using these patterns to structure
    and manage large projects. Many JavaScript frameworks have emerged that support
    **MV*** patterns. We will discuss a few examples using **Backbone.js**.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）、**模型-视图-呈现器**（**MVP**）和 **模型-视图-视图模型**（**MVVM**）在服务器应用程序中一直很受欢迎，但在最近几年，JavaScript
    应用程序也开始使用这些模式来结构和管理工作量大的项目。许多 JavaScript 框架已经出现，支持 **MV*** 模式。我们将讨论使用 **Backbone.js**
    的几个示例。'
- en: Model-View-Controller
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型-视图-控制器
- en: MVC is a popular structural pattern where the idea is to divide an application
    into three parts so as to separate the internal representations of information
    from the presentation layer. MVC consists of components. The model is the application
    object, view is the presentation of the underlying model object, and controller
    handles the way in which the user interface behaves, depending on the user interactions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）是一种流行的结构模式，其核心思想是将应用程序分为三个部分，以将信息的内部表示与表示层分离。MVC 包含组件。模型是应用程序对象，视图是底层模型对象的表示，控制器处理用户界面根据用户交互的行为。
- en: Models
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'Models are constructs that represent data in the applications. They are agnostic
    of the user interface or routing logic. Changes to models are typically notified
    to the view layer by following the observer design pattern. Models may also contain
    code to validate, create, or delete data. The ability to automatically notify
    the views to react when the data is changed makes frameworks such as Backbone.js,
    **Amber.js**, and others very useful in building MV* applications. The following
    example shows you a typical Backbone model:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是代表应用程序中数据的构造。它们与用户界面或路由逻辑无关。模型更改通常通过遵循观察者设计模式来通知视图层。模型也可能包含用于验证、创建或删除数据的代码。当数据更改时自动通知视图层做出反应的能力使得像
    Backbone.js、**Amber.js** 等框架在构建 MV* 应用程序时非常有用。以下示例向您展示了一个典型的 Backbone 模型：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This model structure may vary between different frameworks but they usually
    have certain commonalities in them. In most real-world applications, you would
    want your model to be persisted to an in-memory store or database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型结构可能在不同框架之间有所不同，但它们通常有一些共同点。在大多数现实世界中应用程序中，您希望您的模型被持久化到内存存储或数据库中。
- en: Views
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: 'Views are the visual representations of your model. Usually, the state of the
    model is processed, filtered, or massaged before it is presented to the view layer.
    In JavaScript, views are responsible for rendering and manipulating DOM elements.
    Views observe models and get notified when there is a change in the model. When
    the user interacts with the view, certain attributes of the model are changed
    via the view layer (usually via controllers). In JavaScript frameworks such as
    Backbone, the views are created using template engines such as **Handlebar.js**
    ([http://handlebarsjs.com/](http://handlebarsjs.com/)) or **mustache.js** ([https://mustache.github.io/](https://mustache.github.io/)).
    These templates themselves are not views. They observe models and keep the view
    state updated based on these changes. Let''s see an example of a view defined
    in Handlebar:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是您模型的视觉表示。通常，模型的状态在呈现给视图层之前进行处理、筛选或按摩。在JavaScript中，视图负责渲染和操作DOM元素。视图观察模型，并在模型发生变化时收到通知。当用户与视图交互时，通过视图层（通常通过控制器）更改模型的某些属性。在诸如Backbone的JavaScript框架中，视图是使用模板引擎（如**Handlebar.js**([http://handlebarsjs.com/](http://handlebarsjs.com/))或**mustache.js**([https://mustache.github.io/](https://mustache.github.io/)))创建的。这些模板本身并不是视图。它们观察模型，并根据这些变化保持视图状态更新。让我们来看一个用Handlebar定义的视图示例：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Views such as the preceding example contain markup tags containing template
    variables. These variables are delimited via a custom syntax. For example, template
    variables are delimited using `{{ }}` in Handlebar.js. Frameworks typically transmit
    data in JSON format. How the view is populated from the model is handled transparently
    by the framework.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 像前一个示例这样的视图包含包含模板变量的标记。这些变量通过自定义语法进行分隔。例如，在Handlebar.js中，模板变量使用`{{ }}`进行分隔。框架通常以JSON格式传输数据。视图如何从模型中填充由框架透明处理。
- en: Controllers
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Controllers act as a layer between models and views and are responsible for
    updating the model when the user changes the view attributes. Most JavaScript
    frameworks deviate from the classical definition of a controller. For example,
    Backbone does not have a concept called controller; they have something called
    a **router** that is responsible to handle routing logic. You can think of a combination
    of the view and router as a controller because a lot of the logic to synchronize
    models and views is done within the view itself. A typical Backbone router would
    look as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器作为模型和视图之间的层，负责当用户改变视图属性时更新模型。大多数JavaScript框架与经典定义的控制器有所偏离。例如，Backbone没有一个叫做控制器的概念；他们有一个叫做**路由器**的东西，负责处理路由逻辑。你可以把视图和路由器的组合看作是一个控制器，因为很多同步模型和视图的逻辑都在视图本身内完成。一个典型的Backbone路由器如下所示：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Model-View-Presenter pattern
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-呈现器模式
- en: 'Model-View-Presenter is a variation of the original MVC pattern that we discussed
    previously. Both MVC and MVP target the separation of concerns but they are different
    on many fundamental aspects. The presenter in MVP has the necessary logic for
    the view. Any invocation from the view gets delegated to the presenter. The presenter
    also observes the model and updates the views when the model updates. Many authors
    take the view that because the presenter binds the model with views, it also performs
    the role of a traditional controller. There are various implementations of MVP
    and there are no frameworks that offer classical MVP out of the box. In implementations
    of MVP, the following are the primary differences that separate MVP from MVC:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-呈现器是我们之前讨论的原始MVC模式的一种变体。MVC和MVP都旨在分离关注点，但在很多基本方面它们是不同的。MVP中的呈现器具有视图所需的必要逻辑。视图的任何调用都会委派给呈现器。呈现器还观察模型，并在模型更新时更新视图。许多作者认为，因为呈现器将模型与视图绑定在一起，所以它也执行了传统控制器的角色。有各种MVP的实现方式，而且没有框架提供开箱即用的经典MVP。在MVP的实现中，以下是一些将MVP与MVC分开的主要区别：
- en: The view has no reference to the model
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图没有参考模型
- en: The presenter has a reference to the model and is responsible for updating the
    view when the model changes
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现器有一个模型参考，并在模型变化时负责更新视图
- en: 'MVP is generally implemented in two flavors:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: MVP通常有两种实现方式：
- en: 'Passive view: The view is as naïve as possible and all the business logic is
    within the presenter. For example, a plain Handlebars template can be seen as
    a passive view.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被动视图：视图尽可能天真，所有的业务逻辑都在呈现器中。例如，一个简单的Handlebars模板可以被视为一个被动视图。
- en: 'Supervising controller: Views mostly contain declarative logic. A presenter
    takes over when the simple declarative logic in the view is insufficient.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控控制器：视图中大多包含声明性逻辑。当视图中的简单声明性逻辑不足时，由呈现器接管。
- en: 'The following figure depicts MVP architecture:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表描述了MVP架构：
- en: '![The Model-View-Presenter pattern](img/00009.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-呈现器模式](img/00009.jpeg)'
- en: Model-View-ViewModel
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-视图模型
- en: 'MVVM was originally coined by Microsoft for use with **Windows Presentation
    Foundation** (**WPF**) and **Silverlight**. MVVM is a variation of MVC and MVP
    and further tries to separate the user interface (view) from the business model
    and application behavior. MVVM creates a new model layer in addition to the domain
    model that we discussed in MVC and MVP. This model layer adds properties as an
    interface for the view. Let''s say that we have a checkbox on the UI. The state
    of the checkbox is captured in an `IsChecked` property. In MVP, the view will
    have this property and the presenter will set it. However, in MVVM, the presenter
    will have the `IsChecked` property and the view is responsible for syncing with
    it. Now that the presenter is not really doing the job of a classical presenter,
    it''s renamed as ViewModel:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM最初是由微软为与**Windows Presentation Foundation** (**WPF**) 和 **Silverlight**
    使用而提出的。MVVM是MVC和MVP的一个变种，并进一步试图将用户界面（视图）与业务模型和应用程序行为分离。MVVM在MVC和MVP中讨论的领域模型之上创建了一个新的模型层。这个模型层将属性作为视图的接口。假设我们UI上有复选框。复选框的状态被捕捉到一个`IsChecked`属性中。在MVP中，视图会有这个属性，呈现器会设置它。然而，在MVVM中，呈现器会有`IsChecked`属性，视图负责与它同步。既然呈现器实际上并没有做传统呈现器的工作，它被重新命名为视图模型：
- en: '![Model-View-ViewModel](img/00010.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-视图模型](img/00010.jpeg)'
- en: Implementation details of these approaches are dependent on the problem that
    we are trying to solve and the framework that we use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的实现细节取决于我们试图解决的问题和所使用的框架。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While building large applications, we see certain problem patterns repeating
    over and over. These patterns have well-defined solutions that can be reused to
    build a robust solution. In this chapter, we discussed some of the important patterns
    and ideas around these patterns. Most modern JavaScript applications use these
    patterns. It is rare to see a large-scale system built without implementing modules,
    decorators, factories, or MV* patterns. These are foundational ideas that we discussed
    in this chapter. We will discuss various testing and debugging techniques in the
    next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建大型应用程序时，我们会看到某些问题模式一次又一次地重复。这些问题模式有定义良好的解决方案，可以复用以构建健壮的解决方案。在本章中，我们讨论了一些关于这些模式的重要模式和思想。大多数现代JavaScript应用程序使用这些模式。在一个大型系统中不实现模块、装饰器、工厂或MV*模式的情况很少见。这些是我们本章讨论的基础思想。下一章我们将讨论各种测试和调试技术。
