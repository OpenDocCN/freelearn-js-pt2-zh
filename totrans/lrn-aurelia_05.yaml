- en: Chapter 5. Making Reusable Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。制作可重用组件
- en: Aurelia was built with reusability and composability in mind. As such, its templating
    engine supports not only the composition of components, but also custom HTTP elements
    and attributes, called HTML behaviors in Aurelia's terminology. In fact, the resources
    we use in templates, such as `if`, `repeat`, `show`, `focus`, `compose`, and `router-view`,
    are not special constructs baked into the framework, but are actual HTML behaviors
    written using the same API we will use to write our own custom HTML behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia是为了可重用性和组合性而构建的。因此，其模板引擎不仅支持组件的组合，还支持自定义HTTP元素和属性，在Aurelia的术语中称为HTML行为。实际上，我们在模板中使用的资源，如`if`、`repeat`、`show`、`focus`、`compose`和`router-view`，并不是框架中内置的特殊构建，而是使用与我们编写自己的自定义HTML行为相同的API编写的实际HTML行为。
- en: In this chapter, we will see how composition differs from custom elements, what
    the pros and cons are for each technique, and in which scenarios one is better
    suited than the other. We will next look at how to create custom attributes and
    custom elements, and what we can do with them. Lastly, we will see how we can
    customize Aurelia's view location convention.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解组合与自定义元素的区别，以及每种技术的优缺点，并探讨在哪种场景下一方比另一方更适合。接下来，我们将查看如何创建自定义属性和自定义元素，以及我们可以它们做什么。最后，我们将了解如何自定义Aurelia的视图位置约定。
- en: Composition
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: Composition is the simplest way to assemble components in an Aurelia application.
    It is also the most limited way to do so. Its purpose is mainly to reuse existing
    components and templates in other contexts. Composition suits only simple reusing
    scenarios, where the situation does not differ too much from the intended usage.
    The flexibility of composition is very limited when compared to HTML behaviors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是Aurelia应用程序中组装组件的最简单方法，也是最有限的方法。其主要目的是在其他上下文中重用现有的组件和模板。组合只适用于简单的重用场景，其中情况与预期使用相差不大。与HTML行为相比，组合的灵活性非常有限。
- en: In the following sections, we will see the various possibilities and limitations
    of composition by refactoring our contact management application. We will extract
    the contact creation behavior from our `contact-edition` component into a new
    `contact-creation` component. By doing this, we strive for a cleaner design, so
    our new components will have more focused responsibilities. However, since the
    contact form by itself is the same in both contexts, we will see various ways
    to extract this common template and behavior and to reuse them within those two
    components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分中，我们将通过重构我们的联系人管理应用程序来了解组合的各种可能性和局限性。我们将从我们的`contact-edition`组件中提取联系人创建行为，放入一个新的`contact-creation`组件中。这样做是为了实现更清晰的设计，使我们的新组件具有更专注的责任。然而，由于联系人表单本身在两种上下文中都是相同的，我们将看到各种提取这个公共模板和行为并在这两个组件中重用它们的方法。
- en: Splitting the contact edition component
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆分联系人编辑组件
- en: 'Let''s first start by removing all references to contact creation from the
    `contact-edition` component:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`contact-edition`组件中移除所有与联系人创建相关的引用：
- en: '`src/contact-edition.js`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.js`'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we simply remove the `isNew` property, the `if` statements that used it
    in the `activate` and `save` methods, and the related code branches.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地移除了`isNew`属性，以及在`activate`和`save`方法中使用它的`if`语句和相关代码分支。
- en: 'The same thing goes for the template:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的事情也适用于模板：
- en: '`src/contact-edition.html`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we simply remove the static title and the **Cancel** button displayed
    when creating a new component, so basically all template parts that were displayed
    when `isNew` was `true`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地移除了创建新组件时显示的静态标题和**取消**按钮，基本上就是当`isNew`为`true`时显示的所有模板部分。
- en: 'Next, let''s create our new `contact-creation` component:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个新的`contact-creation`组件：
- en: '`src/contact-creation.js`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-creation.js`'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the view-model of this new component, we simply initialize a `contact` property
    with a new `Contact` instance. Additionally, we define a `save` method which,
    if there are no validation errors, delegates to the `create` method of `ContactGateway`
    and, when the returned `Promise` resolves, navigates back to the contact list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新组件的视图模型中，我们简单地将一个`contact`属性初始化为一个新的`Contact`实例。此外，我们定义了一个`save`方法，如果没有验证错误，它将委派给`ContactGateway`的`create`方法，当返回的`Promise`解决时，导航回到联系人列表。
- en: 'For the template, we''ll start with the frame around the form fields themselves:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板，我们将从表单字段本身的框架开始：
- en: '`src/contact-creation.html`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-creation.html`'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Except for the form fields, which we have omitted for now, this template is
    almost identical to the template of `contact-edition`. The main differences are
    highlighted, the title is a static `New contact` string, and the **Cancel** button
    navigates back to the contact list instead of the contact's details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们目前省略的表单字段外，这个模板与`contact-edition`模板几乎完全相同。主要区别是高亮显示的，标题是一个静态的`New contact`字符串，而**取消**按钮导航回到联系人列表而不是联系人的详细信息。
- en: Reusing templates
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复用模板
- en: 'One of the possibilities composition offers is reusing a template in multiple
    contexts. We will illustrate this by extracting the form fields from the `contact-edition.html`
    template into its own template, so we can use it in both `contact-edition.html`
    and `contact-creation.html`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 组合性提供的一个可能性就是在一个多个上下文中复用模板。我们将通过从`contact-edition.html`模板中提取表单字段到其单独的模板，来说明这一点，这样我们就可以在`contact-edition.html`和`contact-creation.html`中都使用它：
- en: '`src/contact-form.html`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-form.html`'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we extracted the set of fields and list editors from `contact-edition.html`
    into its own template. We can now use composition to render this template where
    the fields were before:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们从`contact-edition.html`中提取了字段集和列表编辑器，放入了单独的模板中。现在我们可以使用组合方法在这段模板中渲染之前的位置：
- en: '`src/contact-edition.html`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Additionally, the `contact-form.html` template must be composed in the `contact-creation.html`
    template. I'll let you replace the comment in the template with the same `compose`
    instruction as in the previous snippet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`contact-form.html`模板必须在`contact-creation.html`模板中进行组合。我会让你将模板中的注释替换为与前一个片段相同的`compose`指令。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget to update the `contact-creation` route in `src/app.js`, by changing
    its `moduleId` property to `'contact-creation'`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新`src/app.js`中的`contact-creation`路由，通过将它的`moduleId`属性更改为`'contact-creation'`。
- en: Once this is done, you can run the application and test that everything still
    works unchanged.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，你可以运行应用程序并测试一切是否仍然如常工作。
- en: When using composition to render a template, this template will inherit the
    surrounding binding context. This means that, in order to compose the `contact-form.html`,
    the template rendering it must have a contact object stored as a `contact` property
    on its context. That's because the `contact-form.html` template expects the presence
    of a context property named `contact`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用组合方法渲染模板时，这个模板将继承周围的绑定上下文。这意味着，为了组合`contact-form.html`，渲染它的模板必须在其上下文中存储一个名为`contact`的`contact`对象。这是因为`contact-form.html`模板期望存在一个名为`contact`的上下文属性。
- en: The whole point about composability is that a component should be independent
    from its surrounding context. This example breaks this rule. We need a way to
    inject the `contact` object into the component.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于组合性的整个要点是，一个组件应该与其周围上下文独立。这个例子违反了这条规则。我们需要一种方法将`contact`对象注入到组件中。
- en: 'If our component is just a template and has no view-model, we can inject the
    `contact` object in an untyped view-model:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组件只是一个模板并且没有视图模型，我们可以在一个未命名的视图模型中注入`contact`对象：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the templating engine will create an object and assign its `contact` property
    the `contact` object from the surrounding binding context, then the composition
    engine will data-bind this dynamic view-model with the `contact-form.html` template.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模板引擎将创建一个对象，并将其`contact`属性分配为周围绑定上下文中的`contact`对象，然后组合引擎将这个动态视图模型与`contact-form.html`模板进行数据绑定。
- en: Reusing components
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复用组件
- en: If our component has behaviors, it means that it has a view-model class. As
    such, the previous technique can't work, because it would override the component's
    view-model with an anonymous object and the component would lose its behaviors.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组件有行为，这意味着它有一个视图模型类。因此，前一个技术不能工作，因为它将用一个匿名对象覆盖组件的视图模型，并且组件将失去其行为。
- en: 'Even though it doesn''t have any behavior for now, let''s create an empty view-model
    for our `contact-form` component so we can illustrate this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在它没有任何行为，让我们为我们的`contact-form`组件创建一个空的视图模型，以便我们可以说明这一点：
- en: '`src/contact-form.js`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-form.js`'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will allow us to change the `compose` instruction in both `contact-creation.html`
    and `contact-edition.html` so the `contact-form` component is used instead of
    the template alone. To do this, we will use the `view-model` attribute of the
    `compose` element instead of its `view` attribute:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在`contact-creation.html`和`contact-edition.html`中更改`compose`指令，以便使用`contact-form`组件而不是单独的模板。为此，我们将使用`compose`元素的`view-model`属性而不是它的`view`属性：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how the `compose` element now has a `view-model` attribute instead of
    a `view` attribute, and how the `.html` file extension in the path has been removed,
    so it now refers to the whole component instead of the template alone.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`compose`元素现在有一个`view-model`属性，而不是`view`属性，路径中的`.html`文件扩展名已经被移除，所以现在它指的是整个组件，而不仅仅是模板。
- en: However, composed like this our component is back to relying on the surrounding
    context's `contact` property. We need to inject the `contact` into it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像这样组合后，我们的组件又回到了依赖周围上下文的`contact`属性的状态。我们需要将其注入。
- en: 'The composition engine supports passing a model to a composed component. As
    such, the `compose` element supports a `model` attribute:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 组合引擎支持向组合组件传递模型。因此，`compose`元素支持`model`属性：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order for the view-model to receive this model, it must implement a callback
    method named `activate`, which will be called by the composition engine, and pass
    the value bound to the `model` property:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让视图模型接收这个模型，它必须实现一个名为`activate`的回调方法，该方法将由组合引擎调用，并传递绑定到`model`属性的值：
- en: '`src/contact-form.js`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-form.js`'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, the `contact-form.html` template is data-bound using the `contact`
    property of the `ContactForm` view-model, which overrides the surrounding context's
    `contact`. This allows for much more flexibility. For example, you can inject
    a different object than the one named `contact` on the surrounding context, or
    you can change the name of the property in the `contact-form` component without
    breaking anything. It is the same kind of difference between passing a parameter
    to a function and using a variable from the outer scope in the same function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`contact-form.html`模板使用`ContactForm`视图模型的`contact`属性进行数据绑定，覆盖了周围上下文的`contact`。这使得更加灵活。例如，你可以注入一个与周围上下文中的`contact`名称不同的对象，或者在不破坏任何内容的情况下更改`contact-form`组件中的属性名称。这类似于在同一个函数中传递一个参数与使用来自外层作用域的变量的区别。
- en: Of course, in this case, since the `model` attribute is bound to the `contact`
    property of the surrounding context, the component will be re-composed if this
    `contact` property is assigned a new value. This means that the component's `activate`
    method will be recalled with the new value of `contact`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，由于`model`属性绑定到周围上下文的`contact`属性，如果这个`contact`属性被分配了一个新值，组件将被重新组合。这意味着组件的`activate`方法将被用新的`contact`值重新调用。
- en: Using a template as a custom element
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板作为自定义元素
- en: Since our `contact-form.html` template has a single parameter, which is a contact
    object, composition is absolutely enough. However, if our component needs to have
    multiple arguments which can be bound separately, composition cannot be used,
    unless we aggregate all arguments in a single parameter object, which can quickly
    become ugly. Custom elements, on the other hand, are designed specifically for
    this kind of scenario.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`contact-form.html`模板只有一个参数，即一个联系对象，因此组合是绝对足够的。然而，如果我们的组件需要有多个可以分别绑定的参数，就不能使用组合，除非我们将所有参数聚合在一个单一的参数对象中，这可能会很快变得难看。另一方面，自定义元素正是为这种情况设计的。
- en: For the sake of the example, let's transform our `contact-form` component into
    a custom HTML element. With Aurelia's templating engine supporting template-only
    custom elements, we can delete the `contact-form.js` view-model, since our `contact-form`
    has no behavior other than rendering a template at the moment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例，让我们将我们的`contact-form`组件转换为自定义HTML元素。由于Aurelia的模板引擎支持仅包含模板的自定义元素，因此我们可以删除`contact-form.js`视图模型，因为当前的`contact-form`除了渲染模板外没有其他行为。
- en: 'Next, we simply need to tell our template which parameters should be exposed
    on the element as attributes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要告诉模板哪些参数应该作为属性暴露在元素上：
- en: '`src/contact-form.html`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-form.html`'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we use the `bindable` attribute on the `template` element to tell Aurelia's
    templating engine that this template, when used as a custom element, exposes a
    `contact` attribute, which the template using the custom element can bind to.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`template`元素上使用`bindable`属性，告诉Aurelia的模板引擎，当这个模板作为自定义元素使用时，暴露一个`contact`属性，模板可以使用这个自定义元素进行绑定。
- en: To define multiple bindable attributes, simply separate them with a comma. For
    example, `bindable="title, contact"` will define two bindable attributes named
    `title` and `contact`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义多个绑定属性，只需用逗号将它们分开。例如，`bindable="title, contact"`将定义两个名为`title`和`contact`的绑定属性。
- en: 'Then, in both `contact-creation.html` and `contact-edition.html`, we start
    by loading the template as a resource:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`contact-creation.html`和`contact-edition.html`两个文件中，我们首先以资源的形式加载模板：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `require` statement tells the templating engine that `contact-form` elements
    are rendered using the `contact-form.html` template only, without any view-model.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`语句告诉模板引擎`contact-form`元素仅使用`contact-form.html`模板渲染，不带任何视图模型。'
- en: 'Next, we can replace the `compose` instruction with our new `contact-form`
    element:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以用我们新的`contact-form`元素替换`compose`指令：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we bind the `contact` property of the `contact-creation` or `contact-edition`
    component to the `contact` attribute of our `contact-form` custom element. This
    will inject the `contact` in the template. Additionally, the properties will be
    bound, which means that if the surrounding context's `contact` is assigned as
    a new value, the `contact` property in the context of `contact-form.html` will
    be synchronized, and all bindings depending on it will be updated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`contact-creation`或`contact-edition`组件的`contact`属性绑定到我们`contact-form`自定义元素的`contact`属性上。这将把`contact`注入到模板中。另外，属性也将被绑定，这意味着如果周围上下文的`contact`被分配为新的值，`contact-form.html`上下文中的`contact`属性将被同步，所有依赖它的绑定也将被更新。
- en: This allows us to create custom elements with just templates when the elements
    have no behaviors. It limits to a strict minimum the code we need to write in
    such scenarios.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在元素没有行为时，仅使用模板来创建自定义元素。在这种情况下，我们需要编写的代码量严格限制在最小值。
- en: Understanding HTML behaviors
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTML行为
- en: HTML behaviors allow us to enrich standard HTML with custom elements and attributes.
    When compared to composition, they not only offer many more possibilities and
    far more flexibility, but they also have much more semantical meaning than `compose`
    instructions inside a template.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: HTML行为使我们能够用自定义元素和属性丰富标准HTML。与组合相比，它们不仅提供了更多可能性，而且更加灵活，而且它们还具有比模板内的`compose`指令更具有语义意义的特点。
- en: An HTML behavior is made up of at least a view-model JS class. Additionally,
    a custom element can declare a template as its view. Of course, an attribute cannot
    declare a view, as it is intended to simply enhance or change the behavior of
    an element.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HTML行为至少由一个视图模型JS类组成。另外，自定义元素可以声明一个模板为其视图。当然，属性不能声明一个视图，因为它的意图只是简单地增强或改变元素的
    behavior。
- en: HTML behaviors, whether they are elements or attributes, use the same basic
    concepts and follow the same general rules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是HTML行为中的元素还是属性，它们都使用相同的基本概念并遵循相同的通用规则。
- en: Injecting the DOM element
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入DOM元素
- en: HTML behaviors will often need to use a reference on their DOM element, especially
    custom attributes. The templating engine is aware of this. When evaluating an
    HTML element in a template, it exposes this element in the current DI container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: HTML行为通常需要使用对其DOM元素的引用，特别是自定义属性。模板引擎了解这一点。当在模板中评估HTML元素时，它会在当前DI容器中暴露这个元素。
- en: Thanks to this, if the element is an Aurelia custom element, its view-model
    can declare a dependency on the `Element` class, and see this DOM element being
    injected in its constructor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点，如果元素是一个Aurelia自定义元素，它的视图模型可以在构造函数中声明对`Element`类的依赖，并在其中看到DOM元素被注入。
- en: Similarly, a custom attribute that declares a dependency on the `Element` class
    will see the DOM element it is declared on injected in its constructor when instantiated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，声明对`Element`类依赖的自定义属性在其构造函数中被实例化时，会看到它所声明的DOM元素被注入。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Relying on browser globals should be avoided. As such, the `Element` class should
    be retrieved from the `DOM` interface exposed by the `aurelia-pal` library. This
    way, if your application needs to be made isomorphic, it will be able to run on
    the server by using a different implementation of the PAL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免依赖浏览器全局变量。因此，`Element`类应从`aurelia-pal`库暴露的`DOM`接口中获取。这样，如果您的应用程序需要被使 为同质，它可以通过使用PAL的不同实现来在服务器上运行。
- en: Declaring bindable properties
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明绑定属性
- en: An HTML behavior can declare bindable properties. Such properties are exposed
    to the outside world by the templating engine, so an instance of a custom element
    or attribute can bind to those properties. The `bindable` decorator allows us
    to identify a property as such.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HTML行为可以声明绑定属性。这样的属性通过模板引擎暴露给外部世界，因此自定义元素或属性的实例可以绑定到这些属性。`bindable`装饰器允许我们将属性标识为如此。
- en: 'For example, let''s imagine a custom element called `text-block`, which would
    expose a bindable property named `text` and would be used like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象一个名为`text-block`的自定义元素，它将暴露一个名为`text`的可绑定属性，并像这样使用：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to expose the `text` property as an attribute, the element''s view-model
    would need to decorate it with `bindable`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`text`属性作为属性暴露出来，元素的视图模型需要用`bindable`装饰它：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `bindable` decorator can be passed an options object, which can have the
    following properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`bindable`装饰器可以接受一个选项对象，该对象可以有以下属性：'
- en: '`defaultBindingMode`: The binding mode chosen by the `.bind` command when used
    on the property. The `bindingMode` enumeration should be used to set this value.
    If omitted, one-way is used by default.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultBindingMode`：当用在属性上时`.bind`命令所选择的绑定模式。应使用`bindingMode`枚举来设置此值。如果省略，则默认使用单向绑定。'
- en: '`changeHandler`: The name of the change handler method. If omitted, the name
    of the property, followed by `Changed`, is used by default. For example, the change
    handler method for a property named `title` would be `titleChanged`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changeHandler`：更改处理方法的名称。如果省略，将使用属性名称后跟`Changed`的默认名称。例如，名为`title`的属性的更改处理方法名称为`titleChanged`。'
- en: '`attribute`: The name of the attribute used to expose the property to the outside
    world. If omitted, the name of the property, transformed to dash-case, will be
    used. For example, the `defaultText` property would be exposed as the `default-text`
    attribute.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute`: 用于向外部暴露属性的属性名称。如果省略，将使用属性名称转换为连字符-格式的名称。例如，`defaultText`属性将作为`default-text`属性暴露出来。'
- en: Note
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Dash-case is a case pattern where all words are lower-case and separated by
    a hyphen. Even though there is no clear consensus in the community about this
    name (it is also referred to as *kebab-case*), I will stick to it through the
    book to use a consistent vocabulary.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Dash-case是一种所有单词均为小写且由连字符分隔的命名模式。尽管社区对此名称没有明确的共识（它也被称为*kebab-case*），但为了使用一致的词汇，我将在整本书中坚持使用这种命名方式。
- en: 'For example, let''s imagine that we want the `text` property of the `text-block`
    custom element from the previous example to be bound two-way by default and to
    have a change handler method named `onTextChanged` instead of the default `textChanged`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们想要上一个示例中`text-block`自定义元素的`text`属性默认使用双向绑定，并且更改处理方法的名称为`onTextChanged`而不是默认的`textChanged`：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If, for some reason, you can't or don't want to declare the bindable properties
    inside the class, the `bindable` decorator can be put directly on the class. In
    such a case, the options object passed to `bindable` should have a `name` property,
    which will be used, as you might have guessed, as the name of the bindable property.
    In such a case, you can also specify the default value of the property using the
    additional `defaultValue` property on the options object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你出于某种原因不能或不想在类内部声明绑定属性，可以直接在类上使用`bindable`装饰器。在这种情况下，传递给`bindable`的选项对象应该有一个`name`属性，这个属性将作为可绑定属性的名称，正如你所猜测的那样。在这种情况下，你还可以通过在选项对象上使用额外的`defaultValue`属性来指定属性的默认值。
- en: 'To illustrate this, let''s refactor the previous example to declare the property
    by putting the `bindable` decorator on the class itself:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们将之前的示例重构为通过在类本身上放置`bindable`装饰器来声明属性：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we can clearly see that the `text` property has completely disappeared
    from the `TextBlockCustomElement` class. Its whole declaration is handled by the
    `bindable` decorator on the class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以清楚地看到`TextBlockCustomElement`类中`text`属性已经完全消失。其整个声明都由类上的`bindable`装饰器处理。
- en: Change handler methods
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改处理方法
- en: A HTML behavior can have a change handler method for any of its bindable properties.
    Change handler methods are automatically called by the templating engine when
    the value of the property changes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HTML行为可以为它的任何可绑定属性提供一个更改处理方法。当属性的值发生变化时，更改处理方法会自动被模板引擎调用。
- en: Unless an explicit method name is specified using the `changeHandler` option
    of `bindable`, the name of the change handler method for a given property is the
    name of the property, followed by `Changed`. For example, the default name of
    the change handler method for a property named `firstName` is `firstNameChanged`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除非使用`bindable`的`changeHandler`选项显式指定方法名，否则给定属性的更改处理方法的名称为属性名称后跟`Changed`。例如，名为`firstName`的属性的默认更改处理方法名称为`firstNameChanged`。
- en: 'Change handler methods are called with two parameters, the first being the
    new value of the property, and the second being the previous value. Of course,
    since a handler is called after its property has changed, the property itself
    can be used inside the change handler method instead of the first parameter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更改处理方法带有两个参数，第一个是属性的新值，第二个是之前的值。当然，由于处理程序在其属性发生变化后调用，更改处理程序内部可以直接使用属性而不是第一个参数：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Life cycle
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'All HTML behaviors follow the same life cycle. A behavior''s view-model can
    implement any of the following callback methods, which will be called by the templating
    engine at specific moments during the behavior''s life cycle:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有HTML行为都遵循相同的生命周期。行为的视图模型可以实现以下任意回调方法，这些方法将由模板引擎在行为生命周期的特定时刻调用：
- en: '`created(owningView: View, view?: View)`: This is called right after the creation
    of the behavior. The `owningView`, being the `View` instance inside which the
    behavior was declared, is passed as the first parameter. Additionally, if the
    behavior is a custom element having a view, the `View` instance of the behavior
    is passed as the second parameter.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created(owningView: View, view?: View)`：在行为创建后立即调用。`owningView`，即行为声明其中的`View`实例，作为第一个参数传递。另外，如果行为是一个具有视图的自定义元素，行为的`View`实例作为第二个参数传递。'
- en: '`bind(bindingContext: Object, overrideContext: Object)`: This is called right
    after the view and the view-model have been bound together. The surrounding binding
    context will be passed as the first parameter. An override context, which exposes
    the ancestor contexts and can be used to add contextual properties by the view-model,
    is passed as the second parameter.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind(bindingContext: Object, overrideContext: Object)`：在视图和视图模型绑定在一起后立即调用。周围的绑定上下文将作为第一个参数传递。一个暴露祖先上下文并且可以用来由视图模型添加上下文属性的覆盖上下文，作为第二个参数传递。'
- en: Note
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the behavior does not declare a `bind` callback method, the change handlers
    for the view-model's bindable properties will all be called at this stage, in
    order to allow the view-model to initialize its state according to the instance's
    binding instructions. However, if `bind` is implemented, the change handlers won't
    be called automatically by the templating engine during binding, the `bind` method
    is considered to be responsible for initializing the state of the behavior in
    such a case.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果行为没有声明`bind`回调方法，那么在此阶段将调用视图模型的所有可绑定属性的更改处理程序，以便允许视图模型根据实例的绑定说明初始化其状态。然而，如果实现了`bind`，模板引擎在绑定过程中不会自动调用更改处理程序，在这种情况下，`bind`方法被认为负责初始化行为的状态。
- en: '`attached()`: This is called right after the bounded view has been attached
    onto the DOM.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attached()`：在绑定视图已附加到DOM后立即调用。'
- en: '`detached()`: This is called right after the bounded view has been detached
    from the DOM. This occurs when beginning the process of disposing the behavior.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detached()`：在绑定视图从DOM中解除后立即调用。这发生在开始处理行为释放过程时。'
- en: '`unbind()`: This is called right after the view-model has been unbound from
    its view. This signals the end of the behavior''s life. Normally, if `unbind`
    does its job correctly and does not omit to release any references and resources,
    the view-model instance can be garbage-collected after this method returns.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unbind()`：在视图模型从其视图中解绑后立即调用此方法。这标志着行为生命的结束。通常，如果`unbind`正确地完成其工作，并且没有遗漏任何引用和资源，那么在返回此方法后，视图模型实例可以被垃圾回收。'
- en: In addition to those life cycle callback methods, changed handler methods for
    any bindable property can be implemented. Each time the value of a bindable property
    changes during the life of the behavior instance, the templating engine will call
    the corresponding changed handler method, if implemented.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了那些生命周期回调方法，任何可绑定属性的更改处理方法都可以实现。在行为实例的生命周期内，每当可绑定属性的值发生变化时，模板引擎都会调用相应的更改处理方法，如果已实现的话。
- en: Actually, those life cycle callback methods are not limited to HTML behaviors.
    They can be added to any Aurelia component, such as router components or composed
    components.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，那些生命周期回调方法并不仅限于HTML行为。它们可以添加到任何Aurelia组件中，例如路由组件或组合组件。
- en: Custom attributes
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义属性
- en: Custom attributes are HTML behaviors that can be attached to any HTML element,
    whether a native element or a custom element, by adding the corresponding HTML
    attribute to it. Aurelia's standard templating resources comprise many custom
    attributes we have already covered, such as `focus`, `show`, or `hide`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义属性是可以通过向任何HTML元素（无论是原生元素还是自定义元素）添加相应的HTML属性来附加到HTML行为上的。Aurelia的标准模板资源包括许多我们已经介绍过的自定义属性，如`focus`、`show`或`hide`。
- en: Custom attributes are purely behavioral, meaning that they have no view.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义属性完全是行为性的，意味着它们没有视图。
- en: 'There are typically four types of custom attributes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有四种类型的自定义属性：
- en: Attributes with a single value
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有单值属性的属性
- en: Attributes with multiple properties
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有多个属性的属性
- en: Attributes with dynamic properties
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有动态属性的属性
- en: We will detail these types of attributes in the following sections.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细介绍这些类型的属性。
- en: Declaring a custom attribute
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个自定义属性
- en: There are two ways to identify a class as a custom attribute. The first one
    is to respect the naming convention and make the custom attribute's class name
    end with `CustomAttribute`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 标识一个类为自定义属性有两种方法。第一种是遵守命名约定，使自定义属性的类名以`CustomAttribute`结尾。
- en: In such a case, the rest of the class name will be transformed into dash-case
    and used as the name of the attribute in templates. For example, a class named
    `MySuperAttributeCustomAttribute` will be made available as the `my-super-attribute`
    attribute in the templates.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类名的其余部分将被转换为破折号形式，并在模板中作为属性的名称。例如，一个名为`MySuperAttributeCustomAttribute`的类将在模板中作为`my-super-attribute`属性提供。
- en: 'As an alternative to the naming rule, the `customAttribute` decorator can be
    applied to a class so it is identified as a custom attribute by the templating
    engine. In such a case, the name under which the attribute will be made available
    to the templates must be passed as the first parameter of the decorator. For example,
    the following attribute would be available as the `file-drop-target` attribute
    in templates:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为命名规则的替代方案，`customAttribute`装饰器可以应用于一个类，使其被模板引擎识别为自定义属性。在这种情况下，必须将属性在模板中提供的名称作为装饰器的第一个参数传递。例如，下面的属性将在模板中作为`file-drop-target`属性提供：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When using the `customAttribute` decorator and passing an explicit attribute
    name, a recognized good practice among the community is to stick with the dash-case
    pattern, and to prefix the name of all your HTML behaviors with a two-letter identifier
    common to your application, plugin, framework, or company.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`customAttribute`装饰器并传递一个显式的属性名称时，社区中公认的好做法是坚持使用破折号模式，并将所有HTML行为的名称前缀为一个在应用程序、插件、框架或公司中通用的两位字母标识符。
- en: For example, the `aurelia-dialog` plugin, which was intended to be part of a
    bigger Aurelia interface project, now redefined and rescoped as Aurelia UX, uses
    the `ai-` prefix. We have already seen this in [Chapter 4](ch04.html "Chapter 4. Forms,
    and How to Validate Them"), *Forms, and How to Validate Them*, with elements such
    as `ai-dialog` and `ai-dialog-body`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，原本打算作为更大Aurelia界面项目一部分的`aurelia-dialog`插件，现在重新定义并范围缩减为Aurelia UX，使用`ai-`前缀。我们在[第4章](ch04.html
    "第4章。表单，以及如何验证它们")，*表单，以及如何验证它们*中已经看到过，元素如`ai-dialog`和`ai-dialog-body`。
- en: Attributes with a single value
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有单值属性的属性
- en: By default, a custom attribute has an implicit `value` property, which is where
    the value of the attribute will be assigned. Of course, a change handler method
    named `valueChanged` can be implemented in order to react to changes of the `value`
    property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自定义属性有一个隐式的`value`属性，该属性是分配属性的值的地方。当然，可以实现一个名为`valueChanged`的变更处理方法，以便响应`value`属性的变化。
- en: 'Obviously, an attribute can be used without any value:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一个属性可以没有任何值使用：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In such a case, the `value` property will be assigned an empty string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`value`属性将被分配一个空字符串。
- en: Lastly, when declaring a single-value attribute, the `customAttribute` decorator
    can accept a second parameter, which is the attribute's default binding mode.
    By default, a custom attribute is bound one-way. However, using the decorator,
    this convention can be overridden.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在声明一个单值属性时，`customAttribute`装饰器可以接受第二个参数，即属性的默认绑定模式。默认情况下，自定义属性是单向绑定的。然而，使用装饰器，可以覆盖这个约定。
- en: 'For example, let''s imagine a `file-drop-target` attribute that would be bound
    two-way by default:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设想一个`file-drop-target`属性，它默认会进行双向绑定：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding an image preview
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加图片预览
- en: To illustrate how a single-value custom attribute works, let's create one.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明单值自定义属性是如何工作的，让我们创建一个。
- en: In our contact application, we will add a preview of the selected image in the
    contact photo upload component. To do this, we will leverage the browser's `URL.createObjectURL`
    function, which takes a `Blob` object as a parameter and returns a special URL
    leading to this resource. Our custom attribute, which will be used essentially
    on `img` elements, will be bound to a `Blob` object, will generate an object URL
    from it, and will assign this URL to the `img` element's `src` attribute.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们联系应用程序中，我们将在联系照片上传组件中添加所选图像的预览。为此，我们将利用浏览器提供的`URL.createObjectURL`函数，该函数接受一个`Blob`对象作为参数，并返回一个特殊的URL，该URL指向这个资源。我们的自定义属性将主要用于`img`元素，将其与`Blob`对象绑定，从它生成一个对象URL，并将这个URL分配给`img`元素的`src`属性。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `URL.createObjectURL` function is supported by most major browsers, but
    is still an experimental feature of the File API. The Mozilla Developer Network
    has a good documentation about it, which can be found at [https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL](https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`URL.createObjectURL`函数被大多数主流浏览器支持，但仍然是对File API的实验性特性。Mozilla开发者网络有一个很好的文档关于它，可以在[https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL](https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL)找到。'
- en: You could say that a value converter would be a better fit for this type of
    feature, and I would absolutely agree. A value converter could take as an input
    a `Blob` object and return the object URL. It could then be used on a binding
    between an `img` element's `src` attribute and a property containing a `Blob`
    object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说值转换器会更适合这种特性，我完全同意。值转换器可以接受一个`Blob`对象作为输入，并返回该对象的URL。然后它可以在`img`元素的`src`属性和包含`Blob`对象的属性之间使用。
- en: 'However, in this particular case, each object URL must be released after usage
    in order to prevent memory leaks, and value converters offer no mechanism to be
    notified when a value is no longer used. On the contrary, HTML behaviors offer
    a much richer workflow and a wider set of extension points. That''s why we will
    create a custom attribute instead:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，每个对象URL在使用后都必须释放，以防止内存泄漏，而值转换器没有任何机制在值不再使用时通知。相反，HTML行为提供了更丰富的流程和更广泛的扩展点。这就是我们创建自定义属性的原因：
- en: '`src/resources/attributes/blob-src.js`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/attributes/blob-src.js`'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we rely on the naming convention to identify our class as a custom attribute,
    and we inject in the constructor the HTML element the attribute is on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们依靠命名约定来识别我们的类作为自定义属性，并在构造函数中注入所属性。
- en: We retrieve the `URL` object and the `Blob` class for the `PLATFORM` constant's
    `global` values. When running in the browser and using the `aurelia-pal-browser`
    implementation, this `global` property will reference the `window` object. It
    will allow us to check the availability of those values before calling methods
    on it. This way, if the application is executed server-side to render its HTML
    and the PAL implementation used on the server does not provide those APIs, this
    custom attribute won't raise any error and will simply leave the `src` attribute
    untouched.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`PLATFORM`常量的`global`值检索`URL`对象和`Blob`类。当在浏览器中运行并使用`aurelia-pal-browser`实现时，这个`global`属性将引用`window`对象。它允许我们在调用其方法之前检查这些值是否可用。这样，如果应用程序在服务器端执行以渲染其HTML，并且服务器上使用的PAL实现不提供这些API，则自定义属性不会引发任何错误，并将`src`属性保持不变。
- en: We also use `valueChanged` to release the previous object URL, if any, then
    create a new one and assign it to the `src` attribute of the element our custom
    attribute is on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`valueChanged`来释放任何先前的对象URL，然后创建一个新的并分配给自定义属性所在的元素的`src`属性。
- en: Lastly, the `unbind` method, which will be called by the templating engine when
    our custom attribute is unbound from the view, just releases the current object
    URL, if any.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`unbind`方法将在模板引擎解绑我们的自定义属性时调用，它只是释放当前的对象URL，如果有的话。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget to load this new attribute in the `resources` feature's `configure`
    function, or to add a `require` statement in the next template to load the attribute
    before using it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`resources`特性的`configure`函数中加载这个新属性，或者在下一个模板中添加一个`require`语句，在使用它之前加载属性。
- en: 'Next, let''s use this custom attribute in our contact photo upload component.
    First, we want to display a preview only when a valid image file has been selected.
    This will prevent displaying a broken image. To do so, we will use the `aurelia-validation`
    library''s `validation-errors` attribute to assign the current validation errors
    on a new `errors` property:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的联系照片上传组件中使用这个自定义属性。首先，我们希望在选择有效的图像文件时只显示预览。这将防止显示损坏的图片。为此，我们将使用`aurelia-validation`库的`validation-errors`属性将当前验证错误分配给新的`errors`属性：
- en: '`src/contact-photo.html`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-photo.html`'
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we will add computed properties on the view-model to get the `File` object
    for the preview:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在视图模型上添加计算属性以获取预览的`File`对象：
- en: '`src/contact-photo.js`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-photo.js`'
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We first create an `areFilesValid` property, which uses the new `photoErrors`
    property and ensures that the `photo` property has no validation errors. Next,
    we add a `preview` property, which returns the first file in `photo` only if `photo`
    contains at least one item and is valid. Otherwise, it returns `null`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`areFilesValid`属性，该属性使用了新的`photoErrors`属性，并确保`photo`属性没有验证错误。接下来，我们添加了一个`preview`属性，只有当`photo`包含至少一个项目并且有效时，它才会返回`photo`中的第一个文件。否则，它返回`null`。
- en: 'Now, using the new `preview` property and our `blog-src` attribute, we can
    display a preview of the selected image file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，利用新的`preview`属性和我们的`blog-src`属性，我们可以显示所选图像文件的前缀：
- en: '`src/contact-photo.html`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-photo.html`'
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we simply add a `div` element, which will be displayed only when a `preview`
    is available. Inside this `div`, we add an `img` element with our `blob-src` custom
    attribute on it, bound to the `preview` property.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地添加了一个`div`元素，当有预览时它才会显示。在这个`div`内部，我们添加了一个带有我们的`blob-src`自定义属性的`img`元素，该属性绑定到`preview`属性。
- en: If you test at this point, you should be able to see a preview after selecting
    a valid image file. Additionally, the preview should hide itself when either no
    image is selected or the selection is invalid.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在这个时候进行测试，您应该能够在选择有效的图像文件后看到预览。此外，当没有选择图像或选择无效时，预览应该自动隐藏。
- en: Adding a file drop target
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加文件拖放目标
- en: 'In an upcoming section, we will add a custom element that will act as a file
    picker, supporting both file selection using a dialog and dragging and dropping
    an image file. In order to prepare for this, let''s create a second custom attribute
    that will listen for drag and drop events on its element and will assign any dropped
    file to its value:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将添加一个自定义元素，它将作为一个文件选择器，支持使用对话框选择文件和拖放图像文件。为了为此做准备，让我们创建一个第二个自定义属性，它将监听其元素上的拖放事件，并将任何被拖放的文件分配给它的值：
- en: '`src/resources/attributes/file-drop-target.js`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/attributes/file-drop-target.js`'
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we first declare our custom attribute, making it use two-way binding by
    default. This way, when a user drops files on an element having our attribute,
    the file list assigned to the value will be also assigned to the expression bound
    to it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先声明了我们自定义的属性，使其默认使用双向绑定。这样，当用户将文件拖放到带有我们属性的元素上时，分配给值的字段列表也将分配给与之绑定的表达式。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Saying this attribute uses two-way binding is stretching the truth a little.
    In fact, this attribute never actually reads the value it is bound to; it just
    writes to it. But because Aurelia doesn't support such an outside only binding
    mode, we have to use two-way binding. You may have noticed that the `validation-errors`
    attribute from the `aurelia-validation` plugin works in the same way.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 说这个属性使用双向绑定有点夸张。实际上，这个属性从未真正读取它所绑定的值；它只是写入它。但由于Aurelia不支持这种仅向外绑定的模式，我们必须使用双向绑定。您可能已经注意到`aurelia-validation`插件的`validation-errors`属性也是以同样的方式工作的。
- en: We also declare a dependency on its DOM element and retrieve it through the
    constructor.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要声明一个对其DOM元素的依赖，并通过构造函数来获取它。
- en: When our attribute gets `attached` to the document, we add the proper event
    listeners on its element. When a `drop` event occurs, we assign the dropped `files`
    to our attribute's `value` property.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的属性被附加到文档时，我们在其元素上添加适当的事件监听器。当发生`drop`事件时，我们将被拖动的`files`分配给属性的`value`属性。
- en: Lastly, when our attribute gets `detached` from the document, we remove the
    event listeners on its element.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们的属性从文档中分离时，我们将其元素上的事件监听器移除。
- en: Attributes with multiple properties
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有多个属性的属性
- en: Custom attributes can declare bindable properties. In such a case, the attribute
    no longer has a single `value` property, but has any number of explicitly named
    properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义属性可以声明可绑定的属性。在这种情况下，属性不再有一个单一的`value`属性，而是有任意数量明确命名的属性。
- en: Of course, such an attribute can define change handler methods, which will be
    called by the templating engine when the value of their respective property changes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样的属性可以定义值变化处理方法，当它们各自的属性值发生变化时，模板引擎会调用这些方法。
- en: 'For example, the `route-href` attribute exported by the `aurelia-router` library
    may be defined like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`aurelia-router`库导出的`route-href`属性可能定义如下：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using a custom attribute with multiple properties
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有多个属性的自定义属性
- en: 'When using a custom attribute with multiple properties, the syntax is similar
    to that of the `style` attribute, the name of the property is followed by a colon
    then by its value, and properties are separated from one another by a semicolon:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用带有多个属性的自定义属性时，语法与`style`属性类似，属性名后面跟着冒号和它的值，属性之间用分号分隔：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the `route` property of the attribute instance would be assigned the `'my-route'`
    string, and its `params` property would be bound to an object with an `id` property
    equal to 1.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，属性实例的`route`属性将被赋值为`'my-route'`字符串，其`params`属性将被绑定到一个具有`id`属性等于1的对象上。
- en: Obviously, on such an attribute, binding is not applied to the attribute itself,
    but instead on its properties. We can see this in the previous example, where
    the `params` property is bound to an object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这种属性上，绑定并不应用于属性本身，而是应用于其属性。我们可以在前一个示例中看到这一点，其中`params`属性被绑定到一个对象上。
- en: Attributes with dynamic properties
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有动态属性的属性
- en: In cases where an attribute needs to have dynamic properties whose names are
    not statically known, the attribute class should be decorated with `dynamicOptions`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性需要具有动态属性，其名称在静态情况下不可知时，属性类应该用`dynamicOptions`进行装饰。
- en: 'Value changes of dynamic properties are not notified using the standard change
    handler methods. Instead, the attribute must implement a `propertyChanged` method,
    which will be called each time the value of any of the dynamic properties changes
    and will be passed three parameters: the name of the property, its new value,
    and its previous value:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 动态属性的值变化不使用标准的值变化处理方法进行通知。相反，属性必须实现一个`propertyChanged`方法，每当动态属性之一的值发生变化时，此方法将被调用，并将传递三个参数：属性的名称、其新值和旧值：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using a custom attribute with dynamic properties
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有动态属性的自定义属性
- en: 'Using a custom attribute with dynamic properties is identical to using an attribute
    with multiple static properties:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有动态属性的自定义属性与使用具有多个静态属性的属性相同：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the `Book` attribute instance would have a `title` property, which would
    be assigned the `'Learning Aurelia'` string, and a `lastUpdated` property, which
    would be bound to the `now` property of the outer context.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Book`属性实例将有一个`title`属性，其将被赋值为`'Learning Aurelia'`字符串，以及一个`lastUpdated`属性，其将被绑定到外部上下文的`now`属性。
- en: Custom elements
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义元素
- en: 'Custom elements are a much more complex subject than custom attributes. A custom
    HTML element has the following properties:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素比自定义属性要复杂得多。一个自定义HTML元素具有以下属性：
- en: It can have bindable properties
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以有可绑定的属性
- en: It can have its own template to control how it's rendered
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以有自己的模板来控制它的渲染方式
- en: It can support content projection, so users can inject bound view fragments
    or custom templates into it
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以支持内容投射，因此用户可以将绑定的视图片段或自定义模板注入其中
- en: It can define its own behaviors
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以定义自己的行为
- en: It can interface with the native DOM API
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以与原生DOM API进行接口
- en: Additionally, custom elements can be customized in many different ways, mostly
    using various decorators provided by `aurelia-templating`. We will cover those
    possibilities and extension points in the following sections.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，自定义元素可以通过多种方式进行自定义，主要是使用`aurelia-templating`提供的各种装饰器。我们将在接下来的章节中介绍这些可能性和扩展点。
- en: One important thing to grasp is that custom elements are not handled using a
    templating trick that replaces them with their rendered template. A custom element
    is a real DOM element, which means that it inherits all the properties and behaviors
    of a DOM element, and that it can be used as such with any API targeting DOM elements.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的一个重要点是，自定义元素并不是通过模板技巧来替换它们的渲染模板来处理的。一个自定义元素是一个真实的DOM元素，这意味着它继承了所有DOM元素的属性和行为，并且可以用任何针对DOM元素的API来使用。
- en: Declaring a custom element
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个自定义元素
- en: The declaration of a custom element is very similar to that of a custom attribute.
    By convention, a class whose name ends with `CustomElement` is considered a custom
    element, and the rest of the name will be transformed into dash-case and used
    as the name of the element in the templates.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素的声明与自定义属性非常相似。按照约定，以`CustomElement`结尾的类被认为是自定义元素，其余的名称将被转换为短横线命名法，并用作模板中的元素名称。
- en: For example, a class named `TextBlockCustomElement` will be made available as
    the `text-block` element in the templates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，名为`TextBlockCustomElement`的类将在模板中作为`text-block`元素提供。
- en: Similarly to custom attributes, the `customElement` decorator can be applied
    to a class as an alternative to the naming rule. In such a case, the name under
    which the element will be made available to the templates must be passed as the
    first parameter of the decorator.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义属性类似，`customElement`装饰器可以应用于一个类，作为命名规则的替代。在这种情况下，元素将在模板中以装饰器的第一个参数的形式提供名称。
- en: 'For example, the following element would be available as the `text-block` element
    in the templates:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的元素将在模板中作为`text-block`元素可用：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though Aurelia supports single word names for custom elements, it is recommended
    to stick to the dash-case pattern and to use at least two words in custom element
    names. This is because the web component specification reserves all single-word
    names for native browser elements, so in the future it won't be possible to export
    such an Aurelia custom element as a standard web component. Additionally, a recognized
    good practice among the community is to prefix the name of all your HTML behaviors
    with a two-letter identifier common to your application, plugin, framework, or
    company.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Aurelia支持自定义元素使用单字名称，但建议坚持使用短横线命名法，并在自定义元素名称中使用至少两个单词。这是因为Web组件规范为所有单字名称保留了原生浏览器元素，所以将来不可能将这样的Aurelia自定义元素作为标准Web组件导出。此外，社区公认的良好实践是在你所有的HTML行为名称前加上一个两个字母的标识符，这个标识符在你的应用程序、插件、框架或公司中是共同的。
- en: However, this is all just conventions, because any resource without a decorator
    identifying its type such as `valueConverter`, `bindingBehavior`, or `customAttribute`,
    and not matching any of the resource naming rules, such as the class name ending
    with `ValueConverter`, `BindingBehavior`, or `CustomAttribute`, will be considered
    as custom elements by the templating engine. In such a case, the full name of
    the class will be transformed into dash-case and used as the name of the element
    in the templates.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些都是只是约定，因为任何没有装饰器标识其类型的资源，如`valueConverter`、`bindingBehavior`或`customAttribute`，并且不匹配任何资源命名规则，如类名以`ValueConverter`、`BindingBehavior`或`CustomAttribute`结尾，将被模板引擎视为自定义元素。在这种情况下，类的全名将被转换为短横线命名法，并用作模板中的元素名称。
- en: For example, a class loaded as a resource and named `TextBlock` would be made
    available as the `text-block` element to the templates. It is, however, considered
    best practice to follow the naming rule or to use the decorator.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，作为一个资源的类被命名为`TextBlock`，它将作为`text-block`元素提供给模板。然而，遵循命名规则或使用装饰器被认为是最佳实践。
- en: Creating a file picker
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文件选择器
- en: Let's dive right in by creating our first custom element, named `file-picker`,
    in our contact management application. This element will encapsulate a `file input`
    and will use the `file-drop-target` custom attribute we created in a previous
    section so users can either open a file selection dialog or drag and drop files
    on the element.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在我们的联系人管理应用程序中创建名为`file-picker`的第一个自定义元素来直接进入。这个元素将封装一个`file input`，并将使用我们在上一节中创建的`file-drop-target`自定义属性，以便用户可以打开文件选择对话框或将文件拖放到元素上。
- en: Declaring the custom element
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明自定义元素
- en: 'We will start by adding some CSS for our custom element:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从为我们的自定义元素添加一些CSS开始：
- en: '`src/resources/elements/file-picker.css`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.css`'
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we simply hide `file input` and style the `label` inside our element.
    The `label` will be linked to the hidden `file input` using the `for` attribute,
    so clicking on it will open the input's file selection dialog, even if the `input`
    is not visible. This allows us to display a sexier UI in place of the browser's
    `file input`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地隐藏了`file input`并样式化了我们元素内的`label`。`label`将通过`for`属性链接到隐藏的`file input`，所以点击它将会打开输入的文件选择对话框，即使`input`不可见。这允许我们用更时尚的UI替换浏览器的`file
    input`。
- en: 'Next, let''s create the JS class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建JS类：
- en: '`src/resources/elements/file-picker.js`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.js`'
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This class simply defines some bindable properties that will be used in the
    template. Additionally, as the `files` property is being used to gather user input,
    it will be bound two-way by default. This is the main reason why this class exists.
    Indeed, without the need to make `files` use two-way binding by default, this
    could have been a template-only custom element, without any JS class, similar
    to what we did at the start of the chapter with our `contact-form`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类简单地定义了一些可绑定的属性，这些属性将在模板中使用。另外，由于`files`属性用于收集用户输入，它将默认双向绑定。这就是这个类存在的主要原因。实际上，如果没有需要默认使`files`使用双向绑定的需求，这可以是一个仅包含模板的定制元素，没有JS类，类似于我们在这个章节开始时所做的那样，使用我们的`contact-form`。
- en: 'Lastly, we need to build the template:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要构建模板：
- en: '`src/resources/elements/file-picker.html`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.html`'
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we first `require` the element's CSS file. Next, we add a `file input`,
    which will bind some of its attributes to the view-model's properties. This allows
    the user of our element to specify the `id` of `input` and its `accept` and `multiple`
    attributes. Most of all, as the `files` property is bound to the `files` attribute
    of `input`, the files selected by the user will be synchronized with the expression
    from the outer scope bound to the `files` property.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先`require`元素的CSS文件。接下来，我们添加一个`file input`，它将把一些属性绑定到视图模型的属性。这允许我们元素的使用者指定`input`的`id`以及它的`accept`和`multiple`属性。最重要的是，由于`files`属性绑定到`input`的`files`属性，用户选择的文件将与绑定到`files`属性的外层作用域的表达式同步。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of leaving the `inputId` property empty by default, this element could
    implement some ID generation algorithm. This would make using the element a little
    simpler for other developers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: instead of leaving the `inputId` property empty by default, this element could
    implement some ID generation algorithm. This would make using the element a little
    simpler for other developers.
- en: Next, we add a `label` with a `for` attribute also bound to the `inputId` property.
    This will link the `label` and the `input` together, so a click on the `label`
    will open the file selection dialog of `input`. Additionally, we add our `file-drop-target`
    attribute to this `label` and bind it to the `files` property, so the files dragged
    and dropped on this `label` will be assigned to the `files` property.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`label`中添加一个`for`属性，也绑定到`inputId`属性。这将把`label`和`input`链接在一起，所以点击`label`会打开`input`的文件选择对话框。此外，我们把`file-drop-target`属性添加到这个`label`中，并绑定到`files`属性，所以拖放到这个`label`上的文件将被分配给`files`属性。
- en: Lastly, we add a `slot` inside the `label`. A `slot` is a mechanism that is
    part of the shadow DOM specification and that allows for content projection. We
    will go over content projection more in details in a later section; the point
    to remember for now is that this `slot` element will be replaced with the content
    of the `file-picker` element instance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`label`内部添加一个`slot`。`slot`是影子DOM规范的一部分，它允许内容投射。我们将在后面的章节中详细介绍内容投射；现在需要记住的是，这个`slot`元素将被替换为`file-picker`元素实例的内容。
- en: Using the custom element
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义元素
- en: 'Our new `file-picker` element is now ready to be used. Of course, it needs
    to be either globally loaded in the `resources` feature''s `configure` function,
    or `require`d in the template where we use it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`file-picker`元素现在准备使用。当然，它需要在`resources`特性的`configure`函数中全局加载，或者在模板中使用时`require`：
- en: '`src/contact-photo.html`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-photo.html`'
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we replace the previous `file input` with our new `file-picker`. We specify
    the `input-id` as `photo`, which links the `file input` and the `label` encapsulated
    in our `file-picker` with the other `label`, two lines above.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用新的`file-picker`替换了原来的`file input`。我们指定`input-id`为`photo`，这使得我们的`file-picker`中的`file
    input`和上面的两行中的`label`链接在一起。
- en: We also specify that the selection dialog of `file-picker` should display only
    image files, using the `accept` attribute, and we bind the `files` attribute to
    the `photo` property. Additionally, this binding instruction is decorated with
    the `validate` binding behavior, so the selected or dropped file(s) will be properly
    validated.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we leverage content projection to inject inside our `file-picker` a
    `strong` line of text, which is displayed only when no `preview` is available,
    and an `img` element, which is visible only when a `preview` is available and
    displays the preview using our `blob-src` custom attribute. This content will
    be projected in place of the `slot`, inside the DOM tree of `file-picker`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: If you run the application at this point, you should be able to either click
    on the `file-picker` to select a file using the selection dialog or drag and drop
    an image file on the element, and the selected or dropped file should show up
    in the preview area if it is valid.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Validating custom elements
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the `aurelia-validation` library validates any two-way binding, the `validate`
    binding behavior can be used on custom element bindings without any problem. We
    actually used it in the previous section to validate our `file-picker`, in case
    you didn't notice. However, the reason the validation of `file-picker` works correctly
    is because our `contact-photo` component uses `change` as the `validateTrigger`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a custom element work seamlessly with the `blur``validateTrigger`,
    the custom element must publish `blur` events. Additionally, in order to respect
    the API implemented by all native form-related elements, it is considered good
    practice to implement a `focus` method, which will delegate the focus on any form-related
    element it contains if your element's purpose is user input.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s imagine a `my-widget` custom element encapsulating
    an `input` element such as this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s also imagine a very basic view-model:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order to comply with the `aurelia-validation` requirements, this template
    must be modified:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we first create a new property named `input` on the view-model, which
    will contain a reference of the `input` element. Next, we add a delegate event
    handler for the `blur` event, which will call the `blur` method when triggered.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s modify the view-model to implement the new requirements:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we first declare a dependency on the DOM element itself and have it injected
    in the constructor. Additionally, we define a `focus` method on the `my-widget`
    element, which calls the `input`'s `focus` method when called. Lastly, we create
    a `blur` method, which creates and dispatches a `blur` event on the `my-widget`
    element when called.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Now the `my-widget` element can be used with the default `blur``validateTrigger`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: As for our `file-picker`, in order to have it working with the `blur``validateTrigger`,
    it should be modified so it publishes a `blur` event when the files are either
    selected or dropped. Even though the element has no focusable content because
    the `file input` is invisible, publishing such an event every time its value changes
    will basically force it to be revalidated using the `change validateTrigger` even
    if the validation controller's trigger is `blur`. This can easily be done by implementing
    a `filesChanged` change handler method dispatching a `blur` event.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们的`file-picker`，为了使其与`blur``validateTrigger`一起工作，应该修改它，使其在选择文件或拖放文件时发布一个`blur`事件。尽管该元素没有可聚焦的内容，因为`file
    input`是隐藏的，但每次其值发生变化时发布此类事件将基本上强制它使用`change validateTrigger`进行验证，即使验证控制器的触发器是`blur`。通过实现一个`filesChanged`变更处理方法，分派一个`blur`事件，可以轻松实现这一点。
- en: Implementing a `focus` method is less straightforward. Since it does not contain
    any focusable element, what should it do? One possibility would be to open the
    file selection dialog when the `file-picker` is focused, even though it would
    be a little intrusive from the user's perspective. Doing this is only a matter
    of calling the `click` method of `file input.`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`focus`方法不那么直接。因为它不包含任何可聚焦的元素，它应该做什么呢？一种可能性是在`file-picker`获得焦点时打开文件选择对话框，尽管这从用户的角度来看可能有点侵扰性。这样做只是调用`file
    input`的`click`方法。
- en: Once this is done, the validation controller's assigned `validateTrigger` can
    be removed from the `contact-photo` component, so it is reverted back to the default
    `blur` trigger.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个操作，可以将验证控制器分配的`validateTrigger`从`contact-photo`组件中移除，使其恢复到默认的`blur`触发器。
- en: Since it doesn't add much except consistency and better reusability of the `file-picker`,
    I'll leave it as an exercise to the reader to apply those changes. The chapter's
    completed application sample can be used as a reference.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于除了保持一致性和提高`file-picker`的重用性外，没有增加太多内容，我将留给读者作为练习来应用这些更改。本书完成的应用程序示例可以作为参考。
- en: Surrogate behaviors
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理行为
- en: Surrogate behaviors allow a custom element to declare attributes, event handlers,
    and bindings on itself. This is achieved by adding those surrogate behaviors to
    the custom element's `template` element, which will be projected by the templating
    engine to the element itself. It can be particularly useful to define `aria` attributes
    on an element, in order to add accessibility to it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 代理行为允许自定义元素在其自身上声明属性、事件处理程序和绑定。这是通过将这些代理行为添加到自定义元素的`template`元素来实现的，模板引擎将把这些行为投射到元素本身。它特别有用，可以在元素上定义`aria`属性，以添加可访问性。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following code snippets are excerpts from the `chapter-5/samples/surrogate-behaviors`
    sample.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段摘自`chapter-5/samples/surrogate-behaviors`示例。
- en: 'For example, let''s imagine a custom element named `tree-view`, which renders
    a tree structure. In its template, we could define a surrogate `role` attribute
    such as this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设想一个名为`tree-view`的自定义元素，它渲染一个树形结构。在其模板中，我们可以定义一个代理`role`属性，例如：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When using a `tree-view` element in a template, this `role="tree"` attribute
    will be added to every instance of the element:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当在模板中使用`tree-view`元素时，此`role="tree"`属性将添加到元素的每个实例：
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When used as depicted in the previous example, the element will look like the
    following, once rendered in the DOM:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示使用时，该元素在DOM中渲染后看起来像以下样子：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Surrogate behaviors can also be event handlers. For example, `tree-view` could
    declare a surrogate `click` handler such as this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 代理行为也可以是事件处理程序。例如，`tree-view`可以声明一个这样的代理`click`处理程序：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In such a case, the `click` handler would be called when the `tree-view` element
    itself is clicked.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当点击`tree-view`元素本身时，会调用`click`处理函数。
- en: 'As this example hinted, surrogate attributes can also use data-binding:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所暗示的，代理属性也可以使用数据绑定：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, the `role` attribute projected on the `tree-view` element would be bound
    to the `role` property on the custom element's binding context.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，投影在`tree-view`元素上的`role`属性将绑定到自定义元素绑定上下文上的`role`属性。
- en: Content projection
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容投射
- en: Content projection is the action of injecting content into a custom element.
    By defining projection points, a custom element allows instances to inject external
    DOM sub-trees into its own DOM. This mechanism is described as part of the Shadow
    DOM 1.0 specification, and is part of the growing standard for larger web components.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影是将内容注入自定义元素的动作。通过定义投影点，自定义元素允许实例将外部的DOM子树注入到它自己的DOM中。这一机制是Shadow DOM 1.0规范的一部分，也是大型web组件
    growing standard的一部分。
- en: The default slot
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认插槽
- en: 'A projection point in a custom element is called a slot. Slots are defined
    using the `slot` element. We have already used one, when we built the `file-picker`
    element in our contact management application earlier:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素中的一个投影点被称为插槽。插槽使用`slot`元素定义。我们已经用了一个，当我们之前构建`file-picker`元素在我们的联系人管理应用程序中时：
- en: '`src/resources/elements/file-picker.html`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.html`'
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A custom element can define a single, unnamed slot, which is the default slot.
    When using this element, the content of the element is projected on this default
    slot.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素可以定义一个单一的、未命名的插槽，作为默认插槽。使用这个元素时，元素的内容将被投影到这个默认插槽上。
- en: 'We used the `file-picker` in our `contact-photo` component like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`contact-photo`组件中像这样使用了`file-picker`：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The resulting DOM, after the projection, would look like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 投影后的DOM结果看起来像这样：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we can clearly see that the content, of the `file-picker` instance, the
    `strong` and `img` elements have been injected inside the element's DOM and have
    replaced the `slot` element.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以清楚地看到，`file-picker`实例的内容，`strong`和`img`元素已经注入到元素的DOM中，并替换了`slot`元素。
- en: Named slots
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名插槽
- en: A custom element can declare multiple projection points, by defining multiple
    `slot` elements with different names.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素可以声明多个投影点，通过定义多个不同名称的`slot`元素。
- en: 'For example, let''s imagine that we want to create a `submit-button` custom
    element, whose template would look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象一下，我们想要创建一个`submit-button`自定义元素，其模板看起来像这样：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When using this element, we would now have two slots, named respectively `icon`
    and `label`, into which we could project content:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个元素时，我们现在将有两个插槽，分别命名为`icon`和`label`，我们可以将内容投影到它们中：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To project content into a named slot, you simply need to add a `slot` attribute
    to the element you want to project, with the name of the slot as its value. Here,
    we project an `i` element on the `icon` slot, and a `span` containing the button's
    label on the `label` slot.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要将内容投影到命名插槽中，你只需要给想要投影的元素添加一个`slot`属性，其值为插槽的名称。在这里，我们将一个`i`元素投影到`icon`插槽上，并将一个包含按钮标签的`span`元素投影到`label`插槽上。
- en: 'Additionally, if multiple content elements use the same value for the `slot`
    attribute, they will all be projected into this slot, in the same order they are
    declared in the custom element''s instance:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果多个内容元素使用`slot`属性的相同值，它们都将被投影到这个插槽中，按照它们在自定义元素实例中声明的顺序：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, the two `span` elements would both be projected in the `label` slot, in
    the same order.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这两个`span`元素都将被投影到`label`插槽中，顺序相同。
- en: Data-binding projected content
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据绑定投影内容
- en: The templating engine will first process the content before projecting it, so
    using string interpolation or binding commands on or inside projected elements
    is perfectly legal. The previous example illustrates this, by using string interpolation
    to render the `fullName` of `contact` before the span is projected on the `label`
    slot.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎将首先处理投影前的内容，所以使用字符串插值或绑定命令在或投影元素内部是完全合法的。前一个示例说明了这一点，通过使用字符串插值来渲染`contact`的`fullName`，在`label`插槽上的`span`之前。
- en: The content is data-bound before projection occurs. This means that the content
    is bound using the context surrounding the element instance. It does not have
    access to the custom element's inner context.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在投影发生之前，内容是数据绑定的。这意味着内容是使用元素实例周围的上下文进行绑定的。它无法访问自定义元素的内层上下文。
- en: In the previous example, the view-model of the `submit-button` knows nothing
    about any `contact` property. This property exists only in the outer context,
    where the `submit-button` instance is declared.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，`submit-button`的视图模型不知道任何`contact`属性。这个属性只存在于外层上下文中，在该上下文中声明了`submit-button`实例。
- en: Default content
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认内容
- en: When defining a slot, a custom element can provide a default content for it.
    This way, if no content is projected on the slot, it won't be left empty.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个插槽时，自定义元素可以为其提供默认内容。这样，如果没有内容被投影到插槽上，它就不会留空。
- en: 'To illustrate this, let''s transform the `submit-button` custom element from
    the previous section:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们来改变前一个部分中的`submit-button`自定义元素：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we simply add a check icon in the `icon` slot and the `Submit` text in
    the `label` slot. This way, if a `submit-button` instance does not project content
    on any slot, the button will show a default icon and label.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在`icon`插槽上添加了一个检查图标，在`label`插槽上添加了`Submit`文本。这样，如果`submit-button`实例没有在任何插槽上投影内容，按钮将显示默认图标和标签。
- en: 'The default slot content is displayed only when no content is projected on
    the slot. This means that, in order to override the default content and force
    an empty slot, you simply need to project an empty element on the slot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在没有内容投影到插槽时，默认插槽的内容才会显示。这意味着，为了覆盖默认内容并强制一个空插槽，你只需在插槽上投影一个空元素：
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, an empty span would be projected on the `icon` slot, which would override
    the default icon.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个空`span`将被投影到`icon`插槽上，这将覆盖默认图标。
- en: Slots in slots
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插槽中套插槽
- en: One interesting possibility is to define slots in the default content of another
    slot. In such a case, it is possible to either project content on the first slot
    to override it completely, or to project content on the sub-slot to override only
    this one and keep the rest of the default content of the first slot.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的可能性是在另一个插槽的默认内容中定义插槽。在这种情况下，可以选择完全覆盖第一个插槽的内容，或者仅覆盖第二个插槽的内容并保留第一个插槽的其余默认内容。
- en: 'Let''s illustrate this by modifying the `submit-button` element from the previous
    examples:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改前一个示例中的`submit-button`元素来说明这一点：
- en: '[PRE53]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we surrounded the slots we defined previously with a new slot named `content`.
    All previous usage examples would still work the same; however, it is now possible
    to override the whole content of the `submit-button` using the `content` slot:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将之前定义的插槽包裹在一个名为`content`的新插槽中。所有之前的使用示例仍然有效；然而，现在可以通过`content`插槽完全覆盖`submit-button`的内容：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we simply override the whole content with a `span` containing the text
    `Save`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地将整个内容替换为一个包含文本`Save`的`span`元素。
- en: Mixing named slots with a default slot
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名插槽与默认插槽的混合
- en: It is also possible, inside a given custom element, to define named slots along
    with a default unnamed slot. In such a case, all content projected outside of
    a named slot will be projected in the default slot.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个给定的自定义元素内部，也可以定义命名插槽和默认未命名插槽。在这种情况下，所有在命名插槽之外的内容都将被投影到默认插槽中。
- en: 'Let''s illustrate this by making the `label` slot the default unnamed slot
    in the `submit-button`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过让`label`插槽成为`submit-button`的默认未命名插槽来说明这一点：
- en: '[PRE55]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After this change, we can still override the `content` or `icon` slots, like
    we did previously. However, to override the `label`, we now simply have to project
    content inside the element instance, without any slot name:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这个更改，我们仍然可以像以前一样覆盖`content`或`icon`插槽。然而，要覆盖`label`，现在只需在元素实例中投影内容，而不需要任何插槽名称：
- en: '[PRE56]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This `submit-button` instance overrides the label of the button, which is defined
    by the default, unnamed slot.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`submit-button`实例覆盖了按钮的标签，该标签由默认的未命名插槽定义。
- en: 'It is possible to mix projection on named slots and on the default slot:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在命名插槽和默认插槽上混合投影：
- en: '[PRE57]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we project an `I` element with a different icon on the `icon` slot, and
    project the text `Save` on the default slot.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`icon`插槽上投影了一个带有不同图标的`I`元素，并在默认插槽上投影了文本`Save`。
- en: Slot-ception
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插槽ception
- en: 'What about a custom element that declares slots, which are projected in another
    custom element declaring its own slots? This is totally possible. Let''s imagine
    a `form-button-bar` component, which would encapsulate a `submit-button`, along
    with a **Cancel** button:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个声明插槽的自定义元素，它在另一个声明自己插槽的自定义元素中被投影呢？这是完全可能的。让我们想象一个`form-button-bar`组件，它将封装一个`submit-button`按钮，还有一个**取消**按钮：
- en: '[PRE58]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, the `form-button-bar` element declares two slots, named `submit-label`
    and `cancel-label`, with the `Save` and `Cancel` texts as their respective default
    content. Additionally, the `submit-label` slot is in turn projected on the `label`
    slot of the `submit-button`. When used, if the `form-button-bar` instance does
    not project any content on the `submit-label` slot, its default content will be
    projected on the `label` slot of the `submit-button`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`form-button-bar`元素声明了两个插槽，分别命名为`submit-label`和`cancel-label`，它们的默认内容分别是`Save`和`Cancel`。此外，`submit-label`插槽又被投影到了`submit-button`的`label`插槽上。当使用时，如果`form-button-bar`实例没有在`submit-label`插槽上投影任何内容，它的默认内容将被投影到`submit-button`的`label`插槽上。
- en: This means that the default content of the `label` slot for the `submit-button`
    will always be overridden, either by the default content of the `submit-label`
    slot for the `form-button-bar` or by its projected content.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`submit-button`的`label`插槽的默认内容将总是被覆盖，要么是被`form-button-bar`的`submit-label`插槽的默认内容覆盖，要么是被其投射的内容覆盖。
- en: It also means that, when using the `form-button-bar` element, there is no way
    to project content in the `icon` slot of the `submit-button`, because it is not
    exposed on a slot from the `form-button-bar`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，在使用`form-button-bar`元素时，没有办法在`submit-button`的`icon`插槽中投射内容，因为它没有被`form-button-bar`的插槽暴露出来。
- en: Limitations
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: The implementation of the slots mechanism has a couple of important limitations.
    The `name` attribute on a slot declaration cannot be bound to, neither can the
    `slot` attribute in an element's instance. This includes string interpolation.
    The values of these attributes must be static.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽机制的实现有几个重要的限制。插槽声明上的`name`属性不能绑定，元素实例上的`slot`属性也不能绑定。这包括字符串插值。这些属性的值必须是静态的。
- en: Additionally, `slot` definitions cannot be modified by template controllers,
    such as the `if` and `repeat` attributes. The limitations of the `if` attribute
    can be somehow worked around by putting a `show` attribute on another element
    surrounding the `slot`. However, the `repeat` attribute just does not work because,
    since the slot name is not bindable and must be static, repeating a slot would
    mean having multiple slots with the same name, which is not supported.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`slot`定义不能被模板控制器修改，例如`if`和`repeat`属性。`if`属性的限制可以通过在另一个元素上放置一个`show`属性来某种程度上绕过，这个元素包围着`slot`。然而，`repeat`属性就是不能工作，因为，由于插槽名称不可绑定且必须是静态的，重复插槽意味着有多个具有相同名称的插槽，这是不支持的。
- en: The Aurelia team announced that they intend to lift at least some of those limitations
    in the future, but at the time of writing they still stand.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 奥雷利亚团队宣布，他们打算在未来至少解除一些这些限制，但在撰写本文时，这些限制仍然存在。
- en: Template injection
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板注入
- en: There is yet another way to extend the rendering of a custom element. In addition
    to content projection, it is also possible for a custom element to declare replaceable
    template parts in its own template. Such replaceable parts can then be overridden
    by instances.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以扩展自定义元素的渲染。除了内容投射之外，自定义元素还可以在其模板中声明可替换的模板部分。这些可替换的部分随后可以被实例覆盖。
- en: This technique is completely different from slots mainly because of the way
    binding is performed. While content injected on a slot is bound before projection
    and as such is bound using the outer context, injected templates are bound after
    injection. This means that an injected template is bound using the inner context
    of a custom element. As such, injected templates can be repeated without any problem.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与其他插槽的主要区别在于绑定方式。虽然插槽上注入的内容在投射之前绑定，因此使用外部上下文进行绑定，但注入的模板在注入后绑定。这意味着注入的模板使用自定义元素的内部上下文进行绑定。因此，注入的模板可以无需任何问题地重复。
- en: Creating a group list
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建分组列表
- en: 'Let''s illustrate this by extracting a reusable component from the contact
    list. We will create a `group-list` custom element, which will group and sort
    its bounded items to render groups of items. It will define a replaceable part,
    which will be used to render a single item within a group:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过从联系人列表中提取可重用组件来说明这一点。我们将创建一个`group-list`自定义元素，它将对其绑定的项目进行分组和排序，以渲染项目组。它将定义一个可替换的部分，该部分将用于渲染组内的单个项目：
- en: '`src/resources/elements/group-list.html`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/group-list.html`'
- en: '[PRE59]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we first define bindable properties on the `template` element. This means
    that the `group-list` element will be made of this template only; it won't have
    any view-model.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先在`template`元素上定义可绑定的属性。这意味着`group-list`元素将只由这个模板组成；它将没有任何视图模型。
- en: 'The bindable properties are the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 可绑定的属性如下：
- en: '`items`: The items to render'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items`：要渲染的项目'
- en: '`groupBy`: The name of the property used to group the items'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupBy`：用于分组项目的属性名称'
- en: '`orderBy`: The name of the property used to sort the items of a group'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderBy`：用于对分组项目进行排序的属性名称'
- en: Next, we simply reuse the same template from the `contact-list` component to
    render groups of items. The main difference is that, instead of hardcoding the
    properties passed to the `groupBy` and `orderBy` value converters, we use the
    appropriate bindable properties.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地重用来自`contact-list`组件的相同模板来渲染项目组。主要区别是，我们没有硬编码传递给`groupBy`和`orderBy`值转换器的属性，而是使用适当的可绑定属性。
- en: Lastly, at the place in the template where we rendered a contact, we put a replaceable
    template part named `item`. When using this custom element, we will be able to
    inject a template that will replace this part. This injected template will have
    access to the surrounding context, which means it will be able to use the current
    `item`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在模板中渲染联系人的位置，我们放置一个名为`item`的可替换模板部分。当使用这个自定义元素时，我们将能够注入一个模板，以替换这个部分。这个注入的模板将有权访问周围上下文，这意味着它将能够使用当前的`item`。
- en: Using the group list
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用分组列表
- en: 'Let''s see how we can use a custom element with replaceable parts by refactoring
    the `contact-list` component to use this new `group-list` element:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过重构`contact-list`组件以使用这个新的`group-list`元素来使用具有可替换部分的自定义元素：
- en: '`src/contact-list.html`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.html`'
- en: '[PRE60]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we first use the `group-list` custom element. Do not forget to load it
    as a resource and bind its `items` property with the `contacts` array, filtered
    according to the user search. We also specify the properties to use for grouping
    and sorting using the `group-by` and `order-by` attributes.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用`group-list`自定义元素。不要忘记将其作为资源加载并将其`items`属性与根据用户搜索过滤的`contacts`数组绑定。我们还需要使用`group-by`和`order-by`属性指定用于分组的属性和排序属性。
- en: Next, we define a template to replace the part named `item`. In this template,
    we keep the view used to render a single contact item. As you can see, the template
    part is able to use the `item` property, which comes from the `repeat.for` attribute
    in the custom element's own template.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个模板来替换名为`item`的部分。在这个模板中，我们保留了用于渲染单个联系人项的视图。正如你所看到的，模板部分能够使用来自自定义元素自身模板中的`repeat.for`属性的`item`属性。
- en: Default template part
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认模板部分
- en: At this point, the user of `group-list` needs to replace the `item` part, otherwise
    items don't get rendered at all. When declaring a replaceable template part, it
    is possible to define its default content, which will be used when the part is
    not replaced.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，`group-list`的使用者需要替换`item`部分，否则项目根本不会被渲染。在声明可替换的模板部分时，可以定义其默认内容，当该部分没有被替换时将使用该默认内容。
- en: 'Let''s change our `group-list` template to render each item as a string by
    default:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`group-list`模板更改为默认将每个项目渲染为字符串：
- en: '`src/resources/elements/group-list.html`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/group-list.html`'
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we define the default content of the replaceable `item` part, which will
    simply render the current `item` using its `toString` method. This way, if no
    `item` part is injected, at least the user will see something, even if it's just
    `[object Object]` which is the default result for an object that doesn't override
    a `toString` method.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了可替换的`item`部分的默认内容，它将简单地使用其`toString`方法渲染当前的`item`。这样，如果没有注入`item`部分，用户至少会看到一些东西，即使它只是`[object
    Object]`，这也是一个没有覆盖`toString`方法的对象的默认结果。
- en: You can try it by adding to the `Contact` class a `toString` method returning
    the `fullName` property, and by commenting out the injected `item` template part
    inside the `group-list` element in the `contact-list` component. The group list
    should now simply render the `fullName` of each contact, without any link.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试通过在`Contact`类中添加一个返回`fullName`属性的`toString`方法，并在`contact-list`组件中的`group-list`元素内注释掉注入的`item`模板部分来实现。分组列表现在应该简单地渲染每个联系人的`fullName`，而不带任何链接。
- en: Re-scoping binding context
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新作用域绑定上下文
- en: 'As it is right now, the user of our `group-list` custom element needs to know
    that the current item is named `item` on the binding context. One possibility
    to make things easier is to use the `with` attribute and re-scope the binding
    context within `repeat.for` to the current `item`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如目前所示，我们`group-list`自定义元素的使用者需要知道当前项在绑定上下文中名为`item`。使事情变得更容易的一个可能性是使用`with`属性并在`repeat.for`内重新作用域绑定上下文到当前的`item`：
- en: '`src/resources/elements/group-list.html`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/group-list.html`'
- en: '[PRE62]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We cannot put a `with` attribute on the `li`, as it already hosts a `repeat`
    attribute. Indeed, a single element cannot host more than one template controller.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在`li`上放置`with`属性，因为它已经包含了一个`repeat`属性。确实，单个元素不能包含多个模板控制器。
- en: We need to surround the replaceable template with another `template` element
    hosting the `with` attribute, which we bind to the current `item`. Inside the
    replaceable `item` template, we replace the `item` reference in the string interpolation
    with a reference to `$this`. The `$this` keyword refers to the current context
    itself, which is the current `item` thanks to `with`. This last part is optional,
    because the current context still inherits from the parent context, which means
    that `item` is still available through context inheritance. Actually, `$this`
    and `item` both refer to the current item. That is, unless the current item has
    its own `item` property. In such a case, `$this` would refer to the current item,
    and `item` would refer to the current item's `item` property.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用另一个`template`元素包围可替换的模板，该元素包含`with`属性，我们将其绑定到当前`item`。在可替换的`item`模板内，我们将字符串插值中的`item`引用替换为对`$this`的引用。`$this`关键字指的是当前上下文本身，得益于`with`，这是当前`item`。这部分是可选的，因为当前上下文仍然从父上下文继承，这意味着通过上下文继承`item`仍然可用。实际上，`$this`和`item`都指的是当前项目。除非当前项目有其自己的`item`属性。在这种情况下，`$this`将指的是当前项目，而`item`将指的是当前项目的`item`属性。
- en: 'Since `item` is still available on the binding context and `Contact` objects
    have no `item` property, we don''t need to change anything in the `contact-list`
    template. It still works. However, using `with` on the repeated `li` means that
    we can now remove all references to `item` in the injected template in `contact-list`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`item`仍然在绑定上下文中可用，而`Contact`对象没有`item`属性，所以我们不需要更改`contact-list`模板中的任何内容。它仍然有效。然而，在重复的`li`上使用`with`意味着我们现在可以在`contact-list`中删除所有对`item`的引用：
- en: '`src/contact-list.html`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-list.html`'
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, our `group-list` custom element is easier to use. Developers using it don't
    need to know about an `item` property on the context. They can simply assume that
    the replaceable template part's binding context is the current item.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`group-list`自定义元素更易于使用。使用它的开发者不需要知道上下文有一个`item`属性。他们可以简单地假设可替换模板部分的绑定上下文就是当前项目。
- en: Of course, this is mostly a matter of taste, but it is also a matter of consistency.
    If you start using `with` in such scenarios in an application or a plugin, you
    should make it consistent and keep using it in all other similar cases.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这主要是关于品味的问题，但也涉及到一致性。如果你在一个应用程序或插件中开始在这种场景下使用`with`，你应该保持一致，并在所有其他类似情况下继续使用它。
- en: Creating a list editor
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建列表编辑器
- en: 'Let''s see another example. We will create a reusable list editor, which we
    can use in the `contact-form` component to edit phone numbers, e-mail addresses,
    addresses, and social profiles:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。我们将创建一个可重用的列表编辑器，我们可以在`contact-form`组件中使用它来编辑电话号码、电子邮件地址、地址和社会资料：
- en: '`src/resources/elements/list-editor.js`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.js`'
- en: '[PRE64]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, we start by creating the view-model, on which we define two bindable
    properties:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个视图模型，在该模型上定义两个可绑定的属性：
- en: '`items`: The array of items to edit'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items`：要编辑的项目数组'
- en: '`addItem`: A function used to add a new item to the array'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addItem`：用于将新项目添加到数组中的函数'
- en: Note
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After refactoring `contact-form`, we will be able to delete the `removePhoneNumber`,
    `removeEmailAddress`, `removeAddress`, and `removeSocialProfile` methods from
    the `Contact` class, since they will be replaced by the `removeItem` method from
    the `list-editor`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构`contact-form`之后，我们将能够从`Contact`类中删除`removePhoneNumber`、`removeEmailAddress`、`removeAddress`和`removeSocialProfile`方法，因为它们将被`list-editor`中的`removeItem`方法替换。
- en: 'The template for `list-editor` looks like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`list-editor`的模板如下所示：'
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/list-editor.html`'
- en: '[PRE65]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The global layout of this template reuses the same frame as all the list editors
    we created in [Chapter 4](ch04.html "Chapter 4. Forms, and How to Validate Them"),
    *Forms, and How to Validate them*. We start by repeating a block for each `item`,
    and use `with` to scope the context within this block on the current `item`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板的全球布局与我们在第[4章](ch04.html "第4章 表单及其验证方式")*表单及其验证方式*中创建的所有列表编辑器使用了相同的框架。我们先为每个`item`重复一个块，并使用`with`将上下文范围限制在此块内的当前`item`上。
- en: Inside the repeated item block, we first declare a replaceable `item` part,
    which encapsulates the whole template for a single item. As the default content
    of this part, we use the same columns setup as the rest of the contact form. The
    first column contains an empty replaceable part named `label`. The second column
    contains a replaceable part named `value`, which renders the current item as a
    string if it is not replaced. The third column contains a replaceable part named
    `remove-btn`, which contains by default a **Remove** button splicing the item
    out of the array when clicked.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在重复项目块内，我们首先声明一个可替换的`item`部分，它封装了单个项目的整个模板。作为这个部分的默认内容，我们使用了与联系表单其余部分相同的列设置。第一列包含一个空的replaceable部分，名为`label`。第二列包含一个名为`value`的可替换部分，如果它没有被替换，则将当前项目渲染为字符串。第三列包含一个名为`remove-btn`的可替换部分，其默认内容是一个**移除**按钮，当点击时从数组中删除项目。
- en: What we can see here is that, just like slots can define sub-slots in their
    default content, replaceable parts can define other replaceable parts as their
    default content. In `list-editor`, it allows us to either replace the whole item
    template, or to replace only parts of it. It is a very powerful feature.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到，就像插槽可以定义子插槽一样，可替换部分也可以定义其他可替换部分作为它们的默认内容。在`list-editor`中，它允许我们替换整个项目模板，或者只替换其中的一部分。这是一个非常强大的功能。
- en: We can even use replaceable parts along with slots in the same custom element.
    This is what we do here, the last block, outside the repeated items, contains
    an **Add** button, which calls the `addItem` function when clicked. This button
    contains a first slot named `add-button-content`. Its default content is an icon,
    along with another slot named `add-button-label`, whose default content is the
    text `Add`. This allows us to project content to customize either the whole content
    of the **Add** button, or only its label.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在同一个自定义元素中使用可替换部分和插槽。这就是我们在这里所做的，最后一个块，在重复的项目之外，包含一个**添加**按钮，当点击时调用`addItem`函数。这个按钮包含一个名为`add-button-content`的第一个插槽。其默认内容是一个图标，还有一个名为`add-button-label`的插槽，其默认内容是文本`Add`。这允许我们投影内容以自定义整个**添加**按钮的内容，或仅其标签。
- en: Lastly, we `show` the whole block containing the **Add** button only if the
    `addItem` property is bound to something, which we expect is a function. This
    means that, if an instance of `list-editor` binds no `add-item` attribute, the
    **Add** button won't be visible.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只有当`addItem`属性绑定到某个东西时（我们预期是一个函数），我们才显示包含**添加**按钮的整个块。这意味着，如果`list-editor`实例没有绑定`add-item`属性，**添加**按钮将不可见。
- en: Using the list editor
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表编辑器
- en: 'We can now use this `list-editor` element in our `contact-form` component:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的`contact-form`组件中使用这个`list-editor`元素：
- en: '`src/contact-form.html`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-form.html`'
- en: '[PRE66]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we start by refactoring the phone numbers editor to use our new `list-editor`
    element. We bind its `items` property to the `phoneNumbers` property of `contact`.
    We also bind the `add-item` property to `call` the `addPhoneNumber` method of
    `contact`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将电话号码编辑器重构为使用我们新的`list-editor`元素。我们将它的`items`属性绑定到`contact`的`phoneNumbers`属性。我们还绑定`add-item`属性以调用`contact`的`addPhoneNumber`方法。
- en: Next, we replace the `label` template part with the `select` element bound to
    the item's `type`. Of course, this binding is decorated with `validate`, so the
    item's `type` is properly validated.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`label`模板部分替换为绑定到项目`type`的`select`元素。当然，这个绑定被`validate`装饰器装饰，所以项目的`type`将被正确验证。
- en: We also replace the `value` template part with the `tel input` bound to the
    item's `number`. Again, this binding is decorated with `validate`, so the item's
    `number` is validated.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`value`模板部分替换为绑定到项目`number`的`tel input`。同样，这个绑定被`validate`装饰器装饰，所以项目的`number`将被验证。
- en: Lastly, we project the text `Add a phone number` on the `add-button-label` slot.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`add-button-label`插槽上投影文本`Add a phone number`。
- en: At this point, if you run the application, the phone numbers editor should have
    the same look and the same behavior as before. I'll leave it as an exercise to
    the reader to refactor the editors for the e-mail addresses, addresses, and social
    profiles using the `list-editor`. The completed application sample for this chapter
    can be used as a reference.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您运行应用程序，电话号码编辑器应该和之前一样的外观和行为。我将留给读者一个练习，即使用`list-editor`重构电子邮件地址、地址和社会资料的编辑器。本章的完整应用程序示例可以作为参考。
- en: Using the customization decorators
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义装饰器
- en: The `aurelia-templating` library offers many decorators that can be used to
    customize the behavior of custom elements and how they are processed by the templating
    engine.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-templating`库提供了许多装饰器，可以用来定制自定义元素的行为以及它们被模板引擎处理的方式。'
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the following code snippets are excerpts from the `chapter-5/samples/element-decorators`
    sample.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的大部分代码片段都来自`chapter-5/samples/element-decorators`示例。
- en: viewResources
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: viewResources
- en: The `viewResources` decorator can be used to declare view dependencies. It acts
    just like the `require` element, but from a component's view-model instead of
    its template.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewResources`装饰器可以用来声明视图依赖项。它就像`require`元素一样，但作用于组件的视图模型而不是其模板。'
- en: 'For example, we could refactor the `contact-edition` component from our contact
    management application by removing the `require` statement from its template:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过从其模板中移除`require`语句来重构我们联系管理应用程序中的`contact-edition`组件：
- en: '`src/contact-edition.html`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.html`'
- en: '[PRE67]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we would need to decorate the `ContactEdition` class with `viewResources`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还需要用`viewResources`来装饰`ContactEdition`类：
- en: '`src/contact-edition.js`'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contact-edition.js`'
- en: '[PRE68]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `contact-edition` component would still work the same way as before.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`contact-edition`组件仍然会像以前一样工作。'
- en: 'The `viewResource` decorator expects an array of dependencies. Each dependency
    can be one of the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewResource`装饰器期望一个依赖项数组。每个依赖项可以是以下之一：'
- en: A string, which must be the path of the resource to load
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串，它必须是加载资源的路径
- en: An object with a `src` property, which must contain the path of the resource
    to load, and an optional `as` property, which if present will act as an alias
    for the resource name in the template, just like the `require` element's `as`
    attribute
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象，有一个`src`属性，它必须包含要加载的资源的路径，和一个可选的`as`属性，如果存在，它将在模板中作为资源的别名，就像`require`元素的`as`属性一样
- en: A function, which must be the class of the resource to load
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，它必须是加载资源的类
- en: I can't really think of any good use case for this decorator, other than wanting
    to put all dependencies in the view-model instead of in the view. However, since
    loading dependencies is a template-related matter, it feels much more natural
    to me to do it in the views using `require` statements.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我实在想不出这个装饰器除了想要把所有依赖项放在视图模型中而不是视图里之外还有哪个好的用例。然而，由于加载依赖项是与模板相关的事务，对我来说，在视图中使用`require`语句来做这件事感觉更加自然。
- en: useView
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: useView
- en: The `useView` decorator can be used to explicitly specify the path of the custom
    element's template.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`useView`装饰器可以用来明确指定自定义元素模板的路径。'
- en: 'For example, let''s update the `file-picker` element from our contact management
    application so it uses this decorator:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们更新我们联系管理应用程序中的`file-picker`元素，使其使用这个装饰器：
- en: '`src/resources/elements/file-picker.js`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.js`'
- en: '[PRE69]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This can be pretty useful if multiple elements share the same view. Additionally,
    it is considered good practice to explicitly specify an element's template when
    it is intended to be distributed in a reusable library or plugin. Indeed, as we
    will see toward the end of this chapter, developers using your element can change
    the convention for view location. In such a case, an element that relies on the
    standard convention would be broken.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个元素共享同一个视图，这将会非常有用。另外，当一个元素打算在一个可重用的库或插件中分发时，明确指定元素的模板被认为是一个好的实践。确实，正如我们将在本章末尾看到的，使用你元素的开发者可以改变视图位置的约定。在这种情况下，依赖标准约定的元素将会被破坏。
- en: inlineView
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: inlineView
- en: 'The `inlineView` decorator allows us to completely replace a component''s template
    file with an inline template declared within the JS file:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`inlineView`装饰器允许我们完全用内联模板替换组件的模板文件：'
- en: '[PRE70]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This custom element would have no `.html` file, because its template is declared
    inline, beside the JS class.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义元素将没有`.html`文件，因为它的模板是声明内联的，位于JS类旁边。
- en: This is pretty useful for custom elements that act only as containers and that
    mostly rely on content projection, because it lifts the need to have a separate
    template file containing very few lines.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于只是作为容器存在的自定义元素来说非常有用，它们主要依赖内容投射，因为它消除了需要一个包含很少几行的单独模板文件。
- en: 'For example, this is the code of the `ai-dialog` element, from the `aurelia-dialog`
    library:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是来自`aurelia-dialog`库的`ai-dialog`元素的代码：
- en: '[PRE71]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This element's sole purpose is to act as a container around the `ai-header`,
    `ai-body`, and `ai-footer` elements, so it is much simpler when the template sits
    beside the view-model.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素的唯一目的是作为`ai-header`、`ai-body`和`ai-footer`元素的容器，因此当模板与视图模型相邻时，它会更简单。
- en: noView
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: noView
- en: The `noView` decorator tells the templating engine that a given custom element
    has no template. In such a case, the templating engine will simply bind the element
    itself, and then process its content, if any, that is, unless the `processContent`
    decorator is also used and disables content processing.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`noView`装饰器告诉模板引擎给定的自定义元素没有模板。在这种情况下，模板引擎将简单地绑定元素本身，然后处理其内容（如果有），除非还使用了`processContent`装饰器并禁用了内容处理。'
- en: The cases where a viewless custom element is useful are pretty rare. For most
    use cases I can think of, such as encapsulating the behavior of a JS widget from
    a UI library, custom attributes are better suited. However, there may be scenarios
    where you want some behavior to be encapsulated in a fully-fledged element instead
    of in an attribute on another element.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 没有视图的自定义元素有用的情况相当罕见。对于我所能想到的绝大多数用例，例如封装UI库中JS小部件的行为，自定义属性更为合适。然而，可能存在一些场景，你希望将某些行为封装在一个完整的元素中，而不是在另一个元素的属性中。
- en: 'For the sake of the example, let''s imagine a custom element acting as an adapter
    over a JS widget from a UI library. This widget is created by calling a function
    and passing to it the DOM element to use as the widget visual root:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们想象一个作为UI库中JS小部件适配器的自定义元素。这个小部件是通过调用一个函数并将其DOM元素传递给它作为小部件视觉根来创建的：
- en: '[PRE72]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Such an element doesn't need any template, because the view of the element is
    rendered by an external library.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的元素不需要任何模板，因为元素的视图由外部库渲染。
- en: Similarly to the `viewResource` decorator, the `noView` decorator can be passed,
    as its first parameter, an array of dependencies. Those dependencies will be loaded
    with the component.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 与`viewResource`装饰器类似，`noView`装饰器可以作为其第一个参数传递一个依赖项数组。这些依赖项将与组件一起加载。
- en: Additionally, a second parameter can specify the path the dependencies are relative
    to. In such a case, this path will be used instead of the view-model's path to
    locate the dependencies.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，第二个参数可以指定依赖项相对于的路径。在这种情况下，将使用此路径而不是视图模型的路径来定位依赖项。
- en: useViewStrategy
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: useViewStrategy
- en: The `useViewStrategy` decorator tells the templating engine to use a given `ViewStrategy`
    instance to load the view of a component. It is actually used behind the scenes
    by the `useView`, `inlineView`, and `noView` decorators.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`useViewStrategy`装饰器告诉模板引擎使用给定的`ViewStrategy`实例来加载组件的视图。它实际上是由`useView`、`inlineView`和`noView`装饰器在幕后使用的。'
- en: It simply attaches the provided view strategy as metadata on the class. During
    the view location process, this metadata is then inspected by the view locator
    and used to locate the component's view.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是将提供的视图策略作为元数据附加到类上。在视图定位过程中，这个元数据然后由视图定位器检查并用于定位组件的视图。
- en: It is mostly useful with custom `ViewStrategy` implementations, which is an
    advanced topic outside the scope of this book. It is, however, good to know that
    it exists, in case you ever need to go there.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 它主要与自定义`ViewStrategy`实现一起使用，这是本书范围之外的高级主题。然而，了解一下它的存在是好的，以防你将来需要去那里。
- en: processAttributes
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: processAttributes
- en: 'The `processAttribute` decorator can be used to provide a function that can
    process the element''s attributes before they are processed by the templating
    engine. The processing function must be passed as a parameter to the decorator:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`processAttribute`装饰器可以用来提供一个函数，可以在模板引擎处理元素属性之前处理元素的属性。处理函数必须作为装饰器的参数传递：'
- en: '[PRE73]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The processing function will be passed a bunch of parameters:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数将被传递一堆参数：
- en: '`compiler`: The `ViewCompiler` instance used to compile the current template'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compiler`: 用于编译当前模板的`ViewCompiler`实例。'
- en: '`resources`: The `ViewResources` instance containing the set of resources available
    to the element''s template'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`: 包含元素模板可用的资源集的`ViewResources`实例。'
- en: '`node`: The DOM element of the custom element itself'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`: 自定义元素的DOM元素本身。'
- en: '`attributes`: A `NamedNodeMap` instance, which is the `attributes` property
    of the `node` parameter'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`: 一个`NamedNodeMap`实例，它是`node`参数的`attributes`属性。'
- en: '`instruction`: The `BehaviorInstruction` instance, which contains all the information
    used by the templating engine to process, data-bind, and display the custom element'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instruction`：包含模板引擎用来处理、数据绑定并显示自定义元素的所有信息的`BehaviorInstruction`实例。'
- en: processContent
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: processContent
- en: The `processContent` decorator can be used to control how and if the templating
    engine will process the custom element's content. It all depends on what parameter
    is passed to the decorator.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`processContent`装饰器可以用来控制模板引擎将如何以及是否处理自定义元素的內容。这取决于传递给装饰器的参数是什么。'
- en: 'If the decorator is passed `false`, the templating engine will not process
    the element''s content. In such a case, the element is responsible for processing
    its own content:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装饰器被传递`false`，模板引擎将不会处理元素的內容。在这种情况下，元素负责处理自己的内容：
- en: '[PRE74]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Such an element won''t see its content processed by the templating engine:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的元素不会看到其内容被模板引擎处理：
- en: '[PRE75]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When rendered, the previous template would be displayed exactly as it is. The
    string interpolation instruction would not be interpreted, because `process-no-content-sample`'s
    content is not processed by the templating engine. The `${someProperty}` text
    would be displayed unchanged.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染时，之前的模板将会精确地显示出来。字符串插值指令不会被解释，因为`process-no-content-sample`的内容不是由模板引擎处理的。`${someProperty}`文本将会保持不变。
- en: 'The other possibility is to pass a processing function to the decorator. In
    such a case, the processing function can process the element''s content, and is
    expected to return `true` or `false` to tell the templating engine if it should
    in turn process the content once the processing function returns:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能性是将一个处理函数传递给装饰器。在这种情况下，处理函数可以处理元素的內容，并且被期望返回`true`或`false`，告诉模板引擎在处理函数返回后是否应该处理内容：
- en: '[PRE76]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The processing function will be passed a bunch of parameters:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数将被传递一堆参数：
- en: '`compiler`: The `ViewCompiler` instance used to compile the current template'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compiler`：用于编译当前模板的`ViewCompiler`实例。'
- en: '`resources`: The `ViewResources` instance containing the set of resources available
    to the element''s template'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`：包含元素模板可用的资源集合的`ViewResources`实例。'
- en: '`node`: The DOM element of the custom element itself'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`：自定义元素自身的DOM元素。'
- en: '`instruction`: The `BehaviorInstruction` instance, which contains all the information
    used by the templating engine to process, data-bind and display the custom element'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instruction`：包含模板引擎用来处理、数据绑定并显示自定义元素的所有信息的`BehaviorInstruction`实例。'
- en: This decorator could be used, for example, to create a custom element acting
    as an integration point in an Aurelia application in order to encapsulate sections
    of the application that must use a different templating engine.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器可以被用来，例如，创建一个作为Aurelia应用中集成点的自定义元素，以封装必须使用不同模板引擎的应用程序的部分。
- en: containerless
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containerless
- en: 'The `containerless` decorator indicates to the templating engine that the custom
    element''s view must be injected in place of the element itself, instead of inside
    it:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`containerless`装饰器向模板引擎指示，自定义元素的视图必须被注入到元素本身的位置，而不是在其内部：'
- en: '[PRE77]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s imagine that this `containerless-sample` element has the following template:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设这个`containerless-sample`元素有以下模板：
- en: '[PRE78]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This element would be used like this:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素会被这样使用：
- en: '[PRE79]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Without the `containerless` decorator, it would be rendered in the DOM like
    this:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`containerless`装饰器，它会被渲染到DOM中，如下所示：
- en: '[PRE80]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'However, because it is decorated with `containerless`, the surrounding `containerless-sample`
    element won''t be rendered:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为它被装饰了`containerless`，周围的`containerless-sample`元素不会被渲染：
- en: '[PRE81]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Even though the element itself is not rendered, bindable properties can still
    be declared by the custom element and bound to through attributes. This will work
    even if the element and its attributes are not rendered on the DOM.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 即使元素本身没有被渲染，自定义元素仍然可以声明可绑定的属性，并通过属性进行绑定。即使元素和它的属性没有被渲染到DOM上，这也会起作用。
- en: Of course, this means that surrogate behaviors cannot be used on a `containerless`
    custom element, because the element on which the surrogate behaviors should be
    projected is not rendered.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着代理行为不能用于`containerless`自定义元素，因为代理行为应该被投影到的元素没有渲染。
- en: This decorator is mostly useful when a specific DOM structure must be respected,
    when using SVG elements, for example.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器在必须尊重特定DOM结构时非常有用，例如使用SVG元素时。
- en: useShadowDOM
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: useShadowDOM
- en: The `useShadowDOM` decorator will make a custom element render its view in the
    Shadow DOM. This is useful to isolate the DOM sub-tree of a custom element from
    the rest of the document, to prevent the unwanted interaction of CSS or DOM queries
    between the element's DOM sub-tree and the outside world.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`useShadowDOM` 装饰器将使自定义元素在其影子DOM中渲染其视图。这对于将自定义元素的DOM子树与文档的其余部分隔离很有用，以防止CSS或DOM查询在元素的DOM子树与外部世界之间产生不希望的交互。'
- en: To illustrate this, let's consider the `file-picker` custom element in our contact
    management application. This element has a CSS file, which is loaded by its template.
    Without the Shadow DOM, the CSS file gets appended to the document's `head`, which
    means that the CSS will be globally applied to the whole document. Collisions
    are possible.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们考虑我们联系管理应用程序中的`file-picker`自定义元素。这个元素有一个CSS文件，通过它的模板加载。没有影子DOM，CSS文件将被附加到文档的`head`中，这意味着CSS将全局应用于整个文档。可能发生冲突。
- en: 'To prevent this, let''s make our `file-picker` element render its view on the
    Shadow DOM. This way, its CSS file will be loaded inside its own shadow root,
    and will be applied only inside this limited scope:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这一点，让我们让我们的`file-picker`元素在其影子DOM中渲染其视图。这样，其CSS文件将在其自己的影子根中加载，并且只在此有限的范围内应用：
- en: '`src/resources/elements/file-picker.js`'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.js`'
- en: '[PRE82]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: By adding the `shadowDOM` decorator to our element's class, we tell the templating
    engine that this element's content should be rendered inside its own shadow root.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向我们的元素的类中添加`shadowDOM`装饰器，我们告诉模板引擎这个元素的内容应该在其自己的影子根内渲染。
- en: 'In order for the CSS file to be rendered in the element''s shadow root, we
    need to mark the `require` statement as `scoped`:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让CSS文件在元素的影子根中渲染，我们需要将`require`语句标记为`scoped`：
- en: '`src/resources/elements/file-picker.html`'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.html`'
- en: '[PRE83]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Lastly, since the CSS file will be loaded inside the element''s shadow root,
    which will be inside the `file-picker` element but around its view, we need to
    remove the `file-picker` element from the CSS selectors for them to keep matching:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于CSS文件将在元素的影子根内加载，该影子根将在`file-picker`元素内但围绕其视图，我们需要从CSS选择器中删除`file-picker`元素，以便它们保持匹配：
- en: '`src/resources/elements/file-picker.css`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.css`：'
- en: '[PRE84]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Notice how the `file-picker > label` selector has been replaced with the `label`
    selector. The same goes for the other CSS rule's selector.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`file-picker > label`选择器如何被`label`选择器替换。其他CSS规则的选择器也同理。
- en: Now, if you run the application and inspect the DOM around this element, you
    should see a shadow root, encapsulating the element itself and a `style` element
    containing the CSS. You may notice that the content projected inside `file-picker`,
    here, the `strong` and the `img` elements, are located outside the shadow root.
    This is important. It means that the element's view is only impacted by the CSS
    file. Its projected content is not. If you added a `label` to the projected content,
    it would not be matched by the rule defined in `file-picker.css`, because it would
    not be on the same shadow root.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行应用程序并检查围绕此元素的DOM，您应该看到一个影子根，它封装了元素本身和一个包含CSS的`style`元素。您可能会注意到，在这里，`file-picker`内的`strong`和`img`元素投影到的内容位于影子根的外部。这很重要。这意味着元素的视图只受CSS文件的影响。其投影内容不受影响。如果您向投影内容添加了`label`，它将不会与`file-picker.css`中定义的规则匹配，因为它不会在相同的影子根上。
- en: children
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`children`'
- en: The `children` decorator is intended to be used on a property of a custom element.
    It selects all immediate children matching the provided query selector and assigns
    them to the decorated property as an array.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`装饰器旨在用于自定义元素的属性上。它选择所有匹配提供的查询选择器的直接子元素并将它们作为数组分配给作为数组分配给装饰属性的数组。'
- en: 'To illustrate this, let''s imagine the following custom element:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们想象以下自定义元素：
- en: '[PRE85]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And let''s say the element is used like this:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 假设元素像这样使用：
- en: '[PRE86]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here, the `child-children-sample` instance would see the repeated `item` elements
    assigned as an array to its `items` property.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`child-children-sample`实例将看到重复的`item`元素分配为其`items`属性数组。
- en: Additionally, the value of `items` would be synchronized with the matching set
    of elements. This means that, if a new `item` element is inserted or an existing
    one is removed, because of the `repeat.for` binding, the `items` property will
    be synchronized.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`items`的值将与匹配的元素集同步。这意味着，如果插入一个新的`item`元素或移除一个现有的元素，由于`repeat.for`绑定，`items`属性将被同步。
- en: Similarly to bindable properties, a `children` property can also implement a
    change handler method, using the same naming rule, to react to changes. In this
    example, the `itemsChanged` method, if present, would be called when rendering,
    during the property initialization, and then every time the `items` array would
    change.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: child
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `child` decorator is very similar to `children`, except that it targets
    a single element.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s adapt the previous example:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And let''s say the element is used like this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, the `child-children-sample` instance would see the `header` element assigned
    to its `header` property. Additionally, the `headerChanged` method, if present,
    would be called when rendering, during the property initialization, and then every
    time the element is removed, added, or replaced.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Bonus – preventing multiple submits
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, our contact management application doesn't handle form submits
    very well. Indeed, in the `contact-creation`, `contact-edition`, and `contact-photo`
    components, if the **Save** button is clicked once, then clicked again before
    the underlying Fetch call completes and the router navigates away from the form,
    multiple calls to the backend will be performed in parallel. Sometimes, it doesn't
    matter. However, it can also be a problem in many scenarios.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Creating the submit task attribute
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To fix this, we will create a custom attribute named `submit-task`, which will
    replace the `submit` handler of the `form` elements. It will be bound using the
    `call` command to a method, which is expected to return a `Promise`. When the
    `form` is submitted, the attribute will turn a flag on, and when the returned
    `Promise` completes, it will turn it back off. This flag will indicate if the
    form is currently waiting for a submit task to complete:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/attributes/submit-task.js`'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Here, we first use the naming convention to identify the class as a custom attribute.
    We also declare a dependency on the DOM element the attribute is on, which we
    inject in the constructor.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Here, when our custom attribute is `attached` to the document, we add a listener
    on the element's `submit` event, which will call the `trySubmit` method when triggered.
    Additionally, a new `isSubmitTaskExecuting` property is created on the element
    and initialized to `false`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: When the element publishes a `submit` event, we start by making sure that no
    submit `task` is currently running. If one already is, we simply return. If none
    is, the element's `isSubmitTaskExecuting` property is set to `true`, and the function
    bound to the custom attribute's `value` is called. The result is guaranteed to
    be a `Promise`, and a callback is attached to this `Promise` so `isSubmitTaskExecuting`
    is set back to `false` when the `Promise` completes, no matter whether it succeeds
    or fails.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, when the attribute is `detached` from the document, we simply remove
    the `submit` event listener.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Using the submit task attribute
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can go into the various components with a `form` element and replace
    the `submit` event handler with the new `submit-task` attribute, bound using the
    `call` command to the `save` method:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-creation.html`'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Of course, for this to work, we need to modify the `save` method so it returns
    the `Promise` tracking the Fetch call:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-creation.js`'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: I'll leave it as an exercise to the reader to also apply those changes to the
    `contact-edition` and `contact-photo` components.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you run the application, you shouldn't be able to trigger
    multiple submits when one is already in progress.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Creating the submit button
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another thing that would be great is to display a visual indicator to the user
    that a submit task is in progress. Now that we have a custom attribute that creates
    and manages the appropriate flag, let''s create a `submit-button` custom element
    that will display a spinner animated icon when its form is running a submission:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/submit-button.html`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here, we first declare a `disabled` bindable property on the template element.
    This means that this element will be made of this template only; it won't have
    a view-model.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a `button` element, with a `submit type`. We also use the `ref`
    attribute to assign a reference of this button to the `button` property on the
    binding context, and we bind the button's `disabled` attribute to the `disabled`
    bindable property.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Inside the button, we add a `span` which will be hidden when the `isSubmitTaskExecuting`
    property of the button's `form` element is `true`. Inside this `span`, we define
    an `icon` slot, whose default content is a check icon.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: We also add a spinner icon inside the button, which will be displayed only when
    the `isSubmitTaskExecuting` property of the button's `form` element is `true`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we define a default slot, which contains the `Submit` text as its default
    content.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: This custom element will simply show a check icon when no submit is in progress,
    and will replace this check icon with a spinner during any submit task. It will
    then toggle back to the check icon when the submit task completes.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `icon` slot will allow instances to override the default check
    icon, and the unnamed slot will allow instances to override the `Submit` label.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Using the submit button
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can go into the various components with a `form` element and replace
    the **Save** button with the new `submit-button` element:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-creation.html`'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we simply define a `submit-button` element, and project the `Save` text
    on the default slot, which overrides its default label.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: I'll leave it as an exercise to the reader to also apply those changes to the
    `contact-edition` and `contact-photo` components.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you run the application, you should see the check icon of
    the various **Save** buttons replaced by a spinner when a submit task is in progress.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the view location strategy
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: View location is the process of locating the template or view for a given component.
    By convention, the template should be a file sitting in the same directory as
    the view-model and having the same name, apart from the extension, which should
    be `.html`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 视图位置是定位给定组件的模板或视图的过程。按照约定，模板应该是一个位于视图模型相同的目录中的文件，除了扩展名应该是`.html`。
- en: We already saw a way to customize the view location process for custom elements,
    using decorators such as `useView`, `inlineView`, and `noView`. It is important
    to note that using those decorators is not restricted to custom elements. They
    can be used with any Aurelia component, such as router components, or components
    displayed using the `compose` instruction.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一种自定义自定义元素视图位置过程的方法，使用诸如`useView`、`inlineView`和`noView`的装饰器。需要注意的是，使用这些装饰器并不仅限于自定义元素。它们可以用于任何Aurelia组件，如路由组件，或使用`compose`指令显示的组件。
- en: There are, however, two other ways to customize the view location strategy.
    Let's walk through them.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有两种其他方式可以自定义视图位置策略。让我们逐一了解它们。
- en: Changing the convention itself
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变约定本身
- en: The conventional view location strategy for a whole application can be changed
    by overriding the `convertOriginToViewUrl` method of `ViewLocator`. This means
    that, by default, the view of all components and custom elements in the application
    will be located using this new strategy.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序的常规视图位置策略可以通过重写`ViewLocator`的`convertOriginToViewUrl`方法来改变。这意味着，默认情况下，应用程序中所有组件和自定义元素的观点将使用这个新策略来定位。
- en: 'Let''s imagine we want to change this convention. This should be done in the
    `main` module''s `configure` function:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们想要改变这个约定。这应该在`main`模块的`configure`函数中完成：
- en: '`src/main.js`'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`'
- en: '[PRE94]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here, we re-implement the `convertOriginToViewUrl` method identically as it
    is in `aurelia-templating`. The convention won't be changed here. It gives, however,
    a good idea of how you can implement your own view location logic.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们精确地重新实现了`aurelia-templating`中的`convertOriginToViewUrl`方法。这里的约定不会改变。然而，这给你一个很好的启示，了解你如何可以实现自己的视图位置逻辑。
- en: Note
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `convertOriginToViewUrl` method is passed an `Origin` instance as its parameter.
    The `Origin` class has a `moduleId` property, which contains the path to the JS
    file exporting the component's view-model class, and a `moduleMember` property,
    which contains the name under which the view-model class is exported from its
    JS file.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`convertOriginToViewUrl`方法接收一个`Origin`实例作为其参数。`Origin`类有一个`moduleId`属性，它包含导出组件视图模型类的JS文件的路径，还有一个`moduleMember`属性，它包含视图模型类从其JS文件导出的名称。'
- en: Changing the strategy for a single component
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变单个组件的策略
- en: The alternative to changing the convention is to specify the view location strategy
    at the component or custom element level. This can be done using the view location
    decorators we saw in a previous section, such as `useView`, `inlineView`, and
    `noView`.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 改变约定的替代方法是在组件或自定义元素级别指定视图位置策略。这可以通过我们之前看到的视图位置装饰器来实现，如`useView`、`inlineView`和`noView`。
- en: However, if you don't want to depend on Aurelia imports for a given component
    or custom element, or if you can't use decorators, you can also implement the
    `getViewStrategy` method on the view-model. This method is expected to return
    either the path of the template file as a string, or a `ViewStrategy` instance.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你不想依赖Aurelia导入给定组件或自定义元素，或者如果你不能使用装饰器，你也可以在视图模型上实现`getViewStrategy`方法。这个方法预期返回模板文件路径的字符串，或者一个`ViewStrategy`实例。
- en: 'The `aurelia-templating` library ships with a couple of view strategy implementations
    out of the box, all of which are used under the hood by their corresponding view
    location decorator:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-templating`库自带了几种视图策略实现，所有这些都在其对应的视图位置装饰器的背后使用：'
- en: '`RelativeViewStrategy`: Used by the `useView` decorator. Its constructor expects
    the same parameters as `useView`.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelativeViewStrategy`：由`useView`装饰器使用。其构造函数期望与`useView`相同的参数。'
- en: '`InlineViewStrategy`: Used by the `inlineView` decorator. Its constructor expects
    the same parameters as `inlineView`.'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InlineViewStrategy`：由`inlineView`装饰器使用。其构造函数期望与`inlineView`相同的参数。'
- en: '`NoViewStrategy`: Used by the `noView` decorator. Its constructor expects the
    same parameters as `noView`.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoViewStrategy`：由`noView`装饰器使用。其构造函数期望与`noView`相同的参数。'
- en: 'For example, we could remove the `useView` decorator from the `file-picker`
    custom element of our contact management application and use the `getViewStrategy`
    method instead:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在我们的联系人管理应用程序的`file-picker`自定义元素中移除`useView`装饰器，并使用`getViewStrategy`方法代替：
- en: '`src/resources/elements/file-picker.js`'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/elements/file-picker.js`'
- en: '[PRE95]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here we were able to remove `useView` from the import statement. Additionally,
    we replaced the usage of the decorator with the `getViewStrategy` method, returning
    the path of the template file.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们成功地将`useView`从导入语句中移除。此外，我们用`getViewStrategy`方法替换了装饰器的使用，返回模板文件的路径。
- en: Summary
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: HTML behaviors are extremely powerful and versatile. They open a whole world
    of possibilities to create complex and flexible components, specialized and dedicated
    to a single application, or reusable, fully customizable, and intended to be distributed
    as third-party plugins or frameworks.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: HTML行为非常强大且灵活。它们为创建复杂且灵活的组件、专门针对单一应用程序的专用组件或可重用、完全可自定义的组件开辟了广阔的可能性，旨在作为第三方插件或框架分发。
- en: They also offer a great way to integrate third-party libraries into Aurelia.
    We will see how to do this in [Chapter 11](ch11.html "Chapter 11. Integrating
    with Other Libraries"), *Integrating with Other Libraries*. With Aurelia's templating
    API being open and easy to use, we will be able to customize and plug in the rendering
    process of those integration components to do some amazing things.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还提供了一种很好的方法将第三方库集成到Aurelia中。我们将在[第11章](ch11.html "第11章 与其他库集成")，*与其他库集成*中看到如何做到这一点。由于Aurelia的模板API是开放的且易于使用，我们将能够定制和插入这些集成组件的渲染过程，以完成一些令人惊叹的事情。
- en: But we are not there yet. In the next chapter, we will take a step back to have
    a good look at our contact management application. We will reflect about the design
    choices we made and the ones we didn't make and see how we can make things better.
    We will also talk about different ways to organize an Aurelia application to make
    it more modular, testable, and easy to maintain.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有达到这个阶段。在下一章中，我们将退后一步，好好看看我们的联系人管理应用程序。我们将思考我们所做的设计选择以及我们没有做出的选择，并看看我们如何可以使事情变得更好。我们还将讨论不同的方法来组织Aurelia应用程序，使其更加模块化、可测试和易于维护。
