- en: '*Chapter 9*: Deploying a Deno Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*9*章：部署Deno应用程序
- en: Deployment is a crucial part of any application. We might build a great application,
    follow best practices, and write tests, but at the end of the day, when it gets
    to the user, this is where it will prove its value. As we want this book to be
    a journey through all the different phases of an application, we'll use this chapter
    about application deployment to close the cycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是任何应用程序的关键部分。我们可能会构建一个伟大的应用程序，遵循最佳实践，并编写测试，但最终，当它到达用户手中时，它将在这里证明其价值。既然我们希望这本书能带领读者经历应用程序的所有不同阶段，我们将在本章中关于应用程序部署的章节中结束这个循环。
- en: Note that we didn't—and will not—mention deployment as the final phase of software
    development, but as one phase of a cycle that will run multiple times. We truly
    believe that deployments shouldn't be events that everyone is afraid of. Rather,
    we see them as exciting moments whereby we're shipping features to our users.
    That's how most companies look at deployments in modern software projects, and
    we're true advocates of that. Deployments should be something regular, automated,
    and easy to do. They're the first step in getting features to our users, not the
    final step.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有——也不会——将部署作为软件开发的最后阶段来提及，而是将其视为将多次运行的一个阶段。我们真心相信部署不应该是每个人都害怕的事件。相反，我们认为它是令人兴奋的时刻，我们正在向用户发送功能。大多数公司就是这样看待现代软件项目中的部署的，我们确实是这种观点的忠实倡导者。部署应该是定期、自动化且容易执行的事情。它们是我们将功能发送给用户的第一步，而不是最后一步。
- en: To enable this type of agility of processes and speed of iteration in applications,
    this chapter will focus on learning about containers and how to deploy a Deno
    application using them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使流程的灵活性和应用程序的迭代速度得到这种敏捷，本章将重点学习关于容器以及如何使用它们部署Deno应用程序的知识。
- en: We'll take advantage of the benefits of containerization to create an isolated
    environment to install, run, and distribute our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用容器化的好处，创建一个隔离的环境来安装、运行和分发我们的应用程序。
- en: As the chapter proceeds, we will learn how to use Docker together with `git`
    to create an automated workflow to deploy our Deno application in a cloud environment.
    Then, we'll tweak the way our application loads configurations to support having
    different configurations depending on the environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着章节的进行，我们将学习如何使用Docker和`git`一起创建一个自动化工作流，以便在云环境中部署我们的Deno应用程序。然后，我们将调整应用程序加载配置的方式，以支持根据环境不同而有不同的配置。
- en: By the end of this chapter, we'll have the application running in a cloud environment
    and an automated process in place that enables us to ship iterations of it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们的应用程序将在云环境中运行，并有一个自动化流程，使我们能够发送它的迭代版本。
- en: 'In this chapter, you''ll get comfortable with the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将熟悉以下主题：
- en: Preparing the environment for the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序准备环境
- en: Creating a `Dockerfile` for the Deno application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Deno应用程序创建一个`Dockerfile`
- en: Building and running the application in Heroku
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Heroku中构建和运行应用程序
- en: Configuring the application for deployment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为部署配置应用程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code used in this chapter can be found at the following GitHub link:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在以下GitHub链接中找到：
- en: '[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter09](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter09)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 链接：[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter09](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter09)
- en: Preparing the environment for the application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序准备环境
- en: The environment where an application runs always has a big impact on it. It
    is one of the big causes of the so-common statement, *"it works on my machine"*.
    Over the years, developers have been creating solutions that try to minimize this
    as much as possible. These solutions can go from automatically provisioning new
    clean instances for the application to run, to creating more complete packages
    where everything the application depends on is included.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行的环境对其有很大影响。这是导致人们常说“*它在我的机器上运行正常*”这一常见说法的一个大原因。多年来，开发者一直在创造尽可能减少这种影响的解决方案。这些解决方案可以从为应用程序自动提供新的干净实例运行，到创建更完整的包，其中包含应用程序依赖的一切。
- en: 'We can refer to **virtual machines** (**VMs**) or containers as ways to achieve
    this goal. Both are different solutions to the same problem but have one big thing
    in common: resource isolation. Both try to isolate an application from the environment
    around it. There are many reasons for this, from security, to automation, to reliability.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将**虚拟机**（**VM**）或容器称为实现这一目标的手段。两者都是为同一问题提供的不同解决方案，但有一个很大的共同点：资源隔离。两者都试图将应用程序与周围的环境隔离。有多种原因，从安全、自动化到可靠性。
- en: Containers are a modern way of providing a package for an application. Modern
    software projects use them to provide a single container image that has pretty
    much all it takes for an application to run.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是提供应用程序包的一种现代方式。现代软件项目使用它们来提供一个几乎包含应用程序所需的所有内容的单一容器镜像。
- en: 'If you''re not aware of what a container is, I''ll provide you with a definition
    from Docker''s (a container engine) official website:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道容器是什么，我将为您提供Docker（一个容器引擎）官方网站的定义：
- en: '*"A container is a standard unit of software that packages up code and all
    its dependencies so the application runs quickly and reliably from one computing
    environment to another."*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*“容器是一个标准的软件单元，它打包了代码及其所有依赖项，以便应用程序从一个计算环境快速且可靠地运行到另一个计算环境。”*'
- en: In our path to make our application easily deployable, we will create this layer
    of isolation for our Deno application using Docker.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使应用程序容易部署的路径中，我们将使用Docker为我们的Deno应用程序创建这种隔离层。
- en: The end goal is to create an image that developers can use to deploy and test
    a specific version of the application. To do this with Docker, we need to configure
    the runtime where our application will run. This is defined in a file called a
    `Dockerfile`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是创建一个开发者可以用来部署和测试应用程序特定版本的镜像。要使用Docker做到这一点，我们需要配置应用程序将运行的运行时。这在一个名为`Dockerfile`的文件中定义。
- en: That's what we'll learn about next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们接下来要学习的内容。
- en: Creating a Dockerfile for the Deno application
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Deno应用程序创建Dockerfile
- en: A `Dockerfile` will allow us to specify what is required to create a new Docker
    image. This image will provide an environment containing all dependencies of the
    application, which can be used both for development purposes and for production
    deployments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Dockerfile`将允许我们指定创建新Docker镜像所需的内容。这个镜像将提供一个包含应用程序所有依赖项的环境，该环境可用于开发目的和生产部署。
- en: What we'll do in this section is learn how to create a Docker image for the
    Deno application. Docker provides a base image that is pretty much just the container
    runtime with isolation, called `alpine`. We could use that image, configure it,
    install all the tools and dependencies we need (namely Deno), and so on. However,
    I believe that we shouldn't be reinventing the wheel here, thus we're using a
    community Docker image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为Deno应用程序创建一个Docker镜像。Docker提供了一个基础镜像，它基本上就是带隔离的容器运行时，称为`alpine`。我们可以使用这个镜像，配置它，安装所有需要的工具和依赖（即Deno），等等。然而，我相信我们在这里不应该重新发明轮子，因此我们使用一个社区Docker镜像。
- en: Even though this image solves many of our problems, we still need to tweak it
    to our use case. Dockerfiles can be composed, which means they can extend other
    Docker images' functionality, and that's what we'll use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个镜像解决了许多我们的问题，我们仍然需要调整它以适应我们的用例。Dockerfile可以组合，这意味着它们可以扩展其他Docker镜像的功能，我们将使用这个功能。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As you might imagine, we'll not go deep in the fundamentals of Docker, as that
    would be a book in itself. If you're interested in Docker, you can start with
    the *Getting started* guide on the official documentation ([https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)).
    However, don't worry if you aren't currently very comfortable with Docker as we'll
    explain it enough for you to understand what we're doing here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，我们不会深入讲解Docker的基础知识，因为这将是另一本书。如果您对Docker感兴趣，您可以从官方文档的*入门指南*开始([https://docs.docker.com/get-started/](https://docs.docker.com/get-started/))。但是，如果您目前对Docker不是非常熟悉，也不要担心，因为我们将会解释足够的内容，让您理解我们在这里做什么。
- en: 'Before we start, make sure you install Docker Desktop on your machine by following
    the steps listed in the following link: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    After you have installed and started it, we have everything it takes to create
    our first Docker image! Let''s create it by following these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保通过以下链接中的步骤在您的机器上安装Docker Desktop：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。安装并启动它之后，我们就有了创建我们的第一个Docker镜像所需的一切！按照以下步骤创建它：
- en: Create a `Dockerfile` at the root of our project.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个`Dockerfile`。
- en: As mentioned, we'll use an image from the community that already has Deno installed—`hayd/deno`
    ([https://hub.docker.com/r/hayd/deno](https://hub.docker.com/r/hayd/deno)).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用社区中已经安装了Deno的镜像—`hayd/deno` ([https://hub.docker.com/r/hayd/deno](https://hub.docker.com/r/hayd/deno))。
- en: 'This image is versioned in the same way as Deno, thus we''ll use version `1.7.5.`
    The `FROM` command from Docker allows us to extend an image, specifying its name
    and version tag, as illustrated in the following code snippet:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个图像的版本号与Deno相同，因此我们将使用版本`1.7.5`。Docker的`FROM`命令允许我们扩展一个图像，指定其名称和版本标签，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The next thing we need to do is to define, inside the container, the folder
    we'll be working on.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在容器内定义我们将要工作的文件夹。
- en: 'Docker containers provide a Linux filesystem, and the default `workdir` is
    the root of it (`/`). The `WORKDIR` command from Docker will allow us to work
    from a folder inside this same filesystem, making things a little bit tidier.
    The command can be seen here:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Docker容器提供了一个Linux文件系统，默认的`workdir`是它的根（`/`）。Docker的`WORKDIR`命令将允许我们在这个文件系统内的同一个文件夹中工作，使事情变得更加整洁。该命令可在此处看到：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we''ll need to copy some files into our container image. With the help
    of the `COPY` command, we''ll copy only the files we need for the installation
    step. In our case, these are the `src/deps.ts` and `lock.json` files, as illustrated
    in the following snippet:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将一些文件复制到我们的容器图像中。在`COPY`命令的帮助下，我们将只复制安装步骤所需的文件。在我们这个案例中，这些是`src/deps.ts`和`lock.json`文件，如下面的片段所示：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Having the files inside the container, we now need to install the application
    dependencies. We''ll use `deno cache` to do this, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件在容器内后，我们现在需要安装应用程序依赖。我们将使用`deno cache`来完成此操作，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Dependencies installed, we now need to copy the application''s code into the
    container. One more time, we''ll use Docker''s `COPY` command for that, as shown
    here:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖项安装后，我们现在需要将应用程序的代码复制到容器中。再一次，我们将使用Docker的`COPY`命令完成此操作，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last thing we''ll need to do for our image to work out of the box is introduce
    a command that will run whenever someone "executes" this image. We''ll use Docker''s
    `CMD` command to do this, as illustrated in the following snippet:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的镜像能够即插即用，我们需要做的最后一件事情是在容器内引入一个命令，该命令将在有人“执行”此镜像时运行。我们将使用Docker的`CMD`命令来完成此操作，如下面的片段所示：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command takes an array of commands and parameters that will be executed
    when someone tries to run our image.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令接受一个命令和参数数组，当有人尝试运行我们的图像时将被执行。
- en: And that should be all we need to define our Deno application's Docker image!
    Having these capabilities in place will enable us to run our code locally in the
    same way it runs in production, a great advantage when it comes to debugging and
    investigating production issues.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该就是我们定义Deno应用程序Docker图像所需的所有内容了！有了这些功能，我们就能以与生产中相同的方式在本地下运行我们的代码，这对于调试和调查生产问题来说是一个很大的优势。
- en: The only thing we're missing is the actual step to generate the artifact.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一缺少的是生成工件的实际步骤。
- en: 'We''ll use the `build` command from the Docker `-t` flag to set the tag. Follow
    these steps to generate the artifact:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Docker `-t`标志的`build`命令来设置标签。按照以下步骤生成工件：
- en: 'Inside the project folder, run the following command to generate the tag for
    the image:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹内，运行以下命令来生成图像的标签：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: museums-api:0.0.1. We could now publish it in a private image registry or use
    a public one such as Docker Hub. The continuous integration (CI) pipeline we'll
    set up later will be configured to perform this build step automatically.What
    we can do now is run this image locally to verify that everything is working as
    expected.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`museums-api:0.0.1`。我们现在可以在私有镜像仓库中发布它，或者使用公共镜像仓库，如Docker Hub。我们稍后设置的持续集成（CI）管道将配置为自动执行这个构建步骤。我们现在可以运行这个镜像来验证一切是否按预期工作。'
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To run the image locally, we'll use the Docker CLI `run` command.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在本地运行镜像，我们将使用Docker CLI的`run`命令。
- en: 'As we''re dealing with a web application, we need to expose the port it is
    running on (set in the application''s `configuration` file). We''ll tell Docker
    to bind the container port to our machine''s port by using the `-p` flag, as illustrated
    in the following code snippet:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们处理的是一个web应用程序，我们需要暴露它正在运行的端口（在应用程序的`configuration`文件中设置）。我们将告诉Docker通过使用`-p`标志将容器端口绑定到我们机器的端口，如图以下代码片段所示：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll later use this image definition in a CI system that will create an image
    whenever the code changes and push it to production.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将在CI系统中使用这个镜像定义，每当代码更改时，它都会创建一个镜像并将其推送到生产环境。
- en: 'Having a Docker image containing an application can serve multiple purposes.
    One of them is this chapter''s objective: deploying it; however, this same Docker
    image can also be used to run and debug an application at a specific version.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有包含应用程序的Docker镜像可以服务于多个目的。其中之一就是本章的目标：部署它；然而，这个同样的Docker镜像也可以用来运行和调试特定版本的某个应用程序。
- en: Let's learn how we can run a Terminal in a specific version of an application,
    a very common debug step.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习我们如何在应用程序的特定版本中运行一个终端，这是一个非常常见的调试步骤。
- en: Running a Terminal inside a container
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器内运行一个终端
- en: Another useful thing we can do with a Docker image is execute a Terminal inside
    of it. This might be useful for debugging purposes or to try out something in
    a specific version of an application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Docker镜像在镜像内执行一个终端。这可能对调试目的或尝试在应用程序的特定版本中测试某事很有用。
- en: We can do that by using the same command as previously, together with a couple
    of different flags.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用与以前相同的命令以及几个不同的标志来实现这一点。
- en: 'We''ll use the `-it` flag, which will allow us to have an interactive connection
    to a Terminal inside the image. We''ll also send, as a parameter, the name of
    the command we want to execute first inside the image. In this case it is `sh`,
    the standard Unix shell, as you can check in the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`-it`标志，这将允许我们与镜像内的终端建立交互式连接。我们还将发送一个参数，即我们希望在镜像内首先执行的命令的名称。在这个例子中，是`sh`，标准的Unix壳，正如您在以下示例中可以检查的那样：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will run the `museums-api:0.0.1` image, bind its `8080` port to the `8080`
    port on the host machine, and execute the `sh` command inside of it with an interactive
    Terminal, as illustrated in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行`museums-api:0.0.1`镜像，将其`8080`端口绑定到宿主机的`8080`端口，并在具有交互式终端的其中执行`sh`命令，如图以下代码片段所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the folder where the shell is initially open is the one we've defined
    as our `WORKDIR` and that all our files are there. In the preceding example, we're
    also executing the `ls` command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，初始打开的shell文件夹是我们定义为`WORKDIR`的文件夹，我们所有的文件都在那里。在前面的例子中，我们还执行了`ls`命令。
- en: 'As we have an interactive shell attached to this container, we can use it to
    run a Deno command, for instance, as illustrated in the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个容器上附加了一个交互式shell，我们可以使用它来运行一个Deno命令，例如，如图以下代码片段所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This enables a full set of possibilities in terms of development and debugging,
    as we'll have the ability to check how the application is running in a specific
    version.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这为开发和调试提供了一系列可能性，因为我们将能够查看应用程序在特定版本下是如何运行的。
- en: We've got to the end of this section. Here, we have explored containerization,
    introducing Docker and how it enables us to create an "application package". This
    package will take care of the environment around the application, making sure
    that it will run wherever there's a Docker runtime.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了本节的最后。在这里，我们探讨了容器化，介绍了Docker以及它如何让我们创建一个“应用程序包”。这个包将负责应用程序周围的环境，确保它无论在何处只要有Docker运行时都能运行。
- en: In the next section, we'll be using this same package to deploy an image we
    built locally in a cloud environment. Let's go!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用这个相同的包将在本地构建的镜像部署到云环境。让我们开始吧！
- en: Building and running the application in Heroku
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Heroku上构建和运行应用程序
- en: As we mentioned when the chapter started, our initial objective was to have
    an easy, automated, and replicable way to deploy the application. In the previous
    section, we created our container image that will work as a basis for that. The
    next step is to create the pipeline that builds and deploys our code anytime there's
    an update. We'll use `git` as our source of truth and mechanism to trigger the
    pipeline builds.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在章节开始时提到的，我们的初始目标是实现一个简单、自动化且可复制的应用部署方式。在前一部分，我们创建了我们的容器镜像，它将作为我们部署的基础。下一步是创建一个管道，用于在任何更新发生时构建和部署我们的代码。我们将使用`git`作为我们的真相来源和触发管道构建的机制。
- en: The platform where we'll deploy our code is Heroku. This is a platform that
    aims to simplify tasks for developers and companies in the deployment process
    by providing a set of tools that removes common obstacles, such as provisioning
    machines and setting up big CI infrastructures. By using a platform such as this,
    we can be more focused on the application and on Deno, which is the purpose of
    this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将部署代码的平台是Heroku。这是一个平台，旨在通过提供一套工具来简化开发人员和公司在部署过程中的任务，这些工具消除了常见的障碍，例如配置机器和设置大的CI基础架构。使用这样的平台，我们可以更专注于应用程序以及Deno，这是本书的目的。
- en: Here, we'll use the `Dockerfile` that we previously created and set it up so
    that it is deployed and runs on Heroku. We'll see how easy it is to set up an
    application to run there, and later we'll also explore how we can define configuration
    values via environment variables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用我们之前创建的`Dockerfile`，并将其设置为在Heroku上部署和运行。我们将了解如何轻松地将应用程序设置为在此处运行，稍后我们还将探索如何通过环境变量定义配置值。
- en: 'Before we start, make sure you''ve created an account and installed the Heroku
    CLI before we proceed to the step-by-step guide, by following the two links provided
    here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保您已经根据这里提供的两个链接创建了账户并安装了Heroku CLI，然后我们再按照步骤指南进行操作。
- en: 'Create an account: [https://signup.heroku.com/dc](https://signup.heroku.com/dc).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建账户：[https://signup.heroku.com/dc](https://signup.heroku.com/dc)。
- en: 'Install the CLI: [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装CLI：[https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)。
- en: Now that we have created an account and installed the CLI, we can start to set
    up our project in Heroku.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了账户并安装了CLI，我们可以开始在Heroku中设置我们的项目。
- en: Creating the application in Heroku
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Heroku中创建应用程序
- en: Here, we will go through the steps needed to authenticate and create the application
    in Heroku. We're almost ready to start, but there's another thing we have to make
    clear first.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍在Heroku中进行身份验证并创建应用程序所需的步骤。我们几乎准备好了，但是在我们开始之前，还有另一件事我们必须先弄清楚。
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As Heroku uses `git` as source of truth, you'll *not* be able to do the following
    procedure inside the book's files repository, as it is already a Git repository
    containing multiple stages of the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Heroku使用`git`作为真相来源，您将*无法*按照以下过程在本书的文件仓库内进行操作，因为该仓库已经是一个包含应用程序多个阶段的Git仓库。
- en: What I recommend you do is copy the application files to a different folder,
    *outside the book's repository*, and start the process from there.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您将应用程序文件复制到不同的文件夹中，*位于本书仓库之外*，并从那里开始流程。
- en: You can copy the latest version of the working application from [*Chapter 8*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178),
    *Testing – Unit and Integration* ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)),
    which is the one we'll use here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[第8章](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178)的*测试 - 单元和集成*中复制工作应用的最新版本，即我们将在这里使用的版本。[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter08/sections/7-final-tested-version/museums-api)
- en: 'Now that the files are copied into a new folder (outside the main repository),
    let''s deploy the `Dockerfile` and run it on Heroku by following these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件已经复制到一个新的文件夹（主仓库外），让我们按照以下步骤部署`Dockerfile`并在Heroku上运行它：
- en: 'The first thing we''ll do is log in with the CLI, running `heroku login`. This
    should open a browser window where you can insert your username and password,
    as illustrated in the following code snippet:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先做的就是使用CLI登录，运行`heroku login`。这应该会打开一个浏览器窗口，您可以在其中输入您的用户名和密码，如下面的代码段所示：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As Heroku deployments are based on `git`, and since we''re now in a folder
    that is not a Git repository, we''ll need to initialize it, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Heroku的部署基于`git`，而我们当前所在的文件夹并非Git仓库，因此我们需要初始化它，步骤如下：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we will create our application in Heroku by using `heroku create`, as
    follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过使用`heroku create`命令在Heroku上创建应用，步骤如下：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you go to the Heroku Dashboard after running the preceding commands, you'll
    notice there's a new application living there. When the application is created,
    Heroku prints a URL on the console; however, as we haven't configured anything,
    our application is not available yet.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行上述命令后访问Heroku控制台，你会注意到那里有一个新应用。当应用创建时，Heroku会在控制台打印一个URL；然而，由于我们还没有进行任何配置，所以应用目前不可用。
- en: The next thing we'll need to do it to configure Heroku so that it knows it should
    build and execute our image in every deployment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是配置Heroku，使其知道它应该在每次部署时构建和执行我们的镜像。
- en: Building and running the Docker image
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行Docker镜像
- en: By default, Heroku just tries to make your application available by running
    the code. This is possible to do with many languages and you'll find guides for
    it in the Heroku documentation. As we want to use a container to run our application,
    the process needs a little more configuration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Heroku试图通过运行代码使你的应用可用。这对于许多语言来说都是可能的，你可以在Heroku文档中找到相关指南。由于我们希望使用容器来运行应用，因此需要进行一些额外的配置。
- en: 'Heroku provides a set of features that allow us to define what happens when
    there are changes in the code, via a file named `heroku.yml`. That''s what we''ll
    create now, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku提供了一系列特性，使我们能够定义代码发生变化时的行为，通过一个名为`heroku.yml`的文件。我们现在将创建这样的文件，步骤如下：
- en: 'Create a `heroku.yml` file at the root of your repository and add the following
    lines of code there so that it builds our image using Docker, using the `Dockerfile`
    we created in the previous section:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仓库根目录下创建一个`heroku.yml`文件，并添加以下代码行，以便使用Docker构建我们的镜像，使用我们在上一节中创建的`Dockerfile`：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, in the same file, add the following lines of code to define the command
    that will be executed by Heroku to run the application:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一个文件中，添加以下代码行以定义Heroku将执行以运行应用的命令：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next thing we''ll have to do is to set the application type to `container`,
    informing Heroku that''s how we want this application to run. The code for this
    is shown in the following snippet:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是将应用类型设置为`container`，告知Heroku我们希望以这种方式运行这个应用。这段代码如下所示：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add all the files to make sure that `git` is tracking them:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有文件以确保`git`追踪它们：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Commit all the files with a message, as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交所有文件并附上信息，步骤如下：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, it's a matter of pushing the files to the `heroku` remote.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，需要将文件推送到`heroku`远程仓库。
- en: 'This should trigger the build process of the Docker image, as you can check
    in the logs. This image is then pushed into Heroku''s internal image registry
    in the last phase, as illustrated in the following code snippet:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该触发Docker镜像的构建过程，你可以在日志中进行检查。然后，在最后阶段，这个镜像会被推送到Heroku内部的镜像仓库，如下代码片段所示：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'remote: === Pushing web (Dockerfile)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 远程仓库：=== 推送web（Dockerfile）
- en: 'remote: Tagged image "5c154f3fcb23f3c3c360e16e929c22b62847fcf8" as "registry.heroku.com/boiling-dusk-18477/web"'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 远程仓库：将标签为“5c154f3fcb23f3c3c360e16e929c22b62847fcf8”的镜像标记为“registry.heroku.com/boiling-dusk-18477/web”
- en: 'remote: Using default tag: latest'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 远程仓库：使用默认标签：latest
- en: 'remote: The push refers to repository [registry.heroku.com/boiling-dusk-18477/web]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 远程仓库：推送指的是[registry.heroku.com/boiling-dusk-18477/web]仓库
- en: 'remote: 6f8894494a30: Preparing'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '远程仓库：6f8894494a30: 准备中'
- en: 'remote: f9b9c806573a: Preparing'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '远程仓库：f9b9c806573a: 准备中'
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember that our application depends on the configuration, and that part of
    the configuration is coming from the environment. There's no way Heroku couldn't
    have known which configuration values we needed. There are still some settings
    we need to configure to get our application working, and that's what we'll do
    next.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的应用依赖于配置，而配置的一部分来自环境。Heroku肯定知道我们需要哪些配置值。还有一些设置我们需要配置以使应用运行，接下来我们将完成这个任务。
- en: Configuring the application for deployment
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用以进行部署
- en: We now have an application that, when code is pushed to `git`, starts the process
    of building an image and deploying it. Our application currently gets deployed
    but it's not actually working, and this is happening because it is lacking configuration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个应用程序，当代码推送到 `git` 时，它开始构建镜像并部署它。我们的应用程序目前被部署了，但它实际上并没有运行，这是因为它缺少配置。
- en: The first thing you probably noticed is that our application is always loading
    the configuration file from development, `config.dev.yml`, and it shouldn't.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先注意到的一件事可能是我们的应用程序总是加载开发环境的配置文件，即 `config.dev.yml`，这是不正确的。
- en: When we first implemented this, we thought that different environments would
    have different configurations, and we were right. At the time, we didn't need
    to have configurations for more than one environment, and we used `dev` as a default.
    Let's fix that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次实现这个时，我们认为不同的环境会有不同的配置，我们是对的。当时，我们不需要为多个环境配置多个配置文件，我们使用了 `dev` 作为默认值。让我们来纠正这个。
- en: Remember that when we created the function that loads the configuration, we
    explicitly used an argument for the environment? We didn't use it at the time,
    but we left a default value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记得当我们创建加载配置文件的函数时，我们明确使用了一个环境参数？当时我们没有使用它，但我们留下了一个默认值。
- en: 'Look at the following code snippet from `src/config/index.ts`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下来自 `src/config/index.ts` 的代码片段：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What we''ll need to do is change this so that it supports multiple environments.
    So, let''s do that by following these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是将这个改为支持多个环境。所以，让我们按照以下步骤来做到这一点：
- en: 'Go back into `src/index.ts` and make sure we''re sending the environment variable
    named `DENO_ENV` to the `load` function, as illustrated in the following code
    snippet:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `src/index.ts` 文件中，确保我们向 `load` 函数发送了一个名为 `DENO_ENV` 的环境变量，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create the production configuration file, `config.production.yml`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建生产环境配置文件 `config.production.yml`。
- en: 'For now, it shouldn''t be much different than `config.dev.yml`, with the exception
    of the `port`, for now. Let''s get it running at port `9001` in production, as
    follows:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，它应该与 `config.dev.yml` 没有太大区别，除了 `port` 之外。让我们在生产环境中将其运行在端口 `9001`，如下所示：
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To test this locally, we can run the application with the `DENO_ENV` variable
    set to `production`, like this:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在本地测试这个，我们可以设置 `DENO_ENV` 变量为 `production` 来运行应用程序，像这样：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With what we just implemented, we're now able to control which configuration
    values are loaded based on the environment. This is something we already tested
    locally, but something we haven't done on Heroku.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们刚刚实施的内容，我们现在可以根据环境控制加载哪些配置值。这是我们已经在本地测试过的，但在 Heroku 上还没有做过。
- en: We've solved part of the problem—we're loading a different configuration file
    depending on the environment, but there are other configuration values that our
    application depends on that are coming from the environment. Those are secret
    values such as the **JSON Web Token** (**JWT**) key or the MongoDB credentials.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了问题的一部分——我们根据环境加载不同的配置文件，但我们的应用程序依赖的其他配置值来自环境。那些是诸如 **JSON Web Token**
    (**JWT**) 密钥或 MongoDB 凭据等机密值。
- en: 'There are many ways to do this, and all cloud providers provide a solution
    for that. In Heroku, we can do this by using the `config` command, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以做到这一点，所有云服务提供商都提供了相应的解决方案。在 Heroku 上，我们可以使用 `config` 命令来实现，如下所示：
- en: 'Define the MongoDB credential variables, the JWT key, and the environment using
    the `heroku config:set` command, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 MongoDB 凭据变量、JWT 密钥和环境，使用 `heroku config:set` 命令，如下所示：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: …
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: 'mongoDb:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'mongoDb:'
- en: 'clusterURI: <add your cluster url>'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'clusterURI: <添加你的集群url>'
- en: 'database: <add your database name>'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'database: <添加你的数据库名称>'
- en: '[PRE27]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once again, we''ll add our changes to `git`, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将把我们的更改添加到 `git` 中，如下所示：
- en: '[PRE28]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And then, we''ll push the changes to Heroku to trigger the deployment process,
    as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将把更改推送到 Heroku 以触发部署过程，如下所示：
- en: '[PRE29]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And it should be working. If we now go to the Heroku Dashboard ([https://dashboard.heroku.com/](https://dashboard.heroku.com/)),
    then into our application's dashboard ([https://dashboard.heroku.com/apps/boiling-dusk-18477](https://dashboard.heroku.com/apps/boiling-dusk-18477),
    in my case) and click the **Open Application** button, it should open our application,
    right?
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该能正常工作。如果我们现在访问 Heroku 仪表板 ([https://dashboard.heroku.com/](https://dashboard.heroku.com/)），然后进入我们应用程序的仪表板
    ([https://dashboard.heroku.com/apps/boiling-dusk-18477](https://dashboard.heroku.com/apps/boiling-dusk-18477)，在我的案例中)
    并点击 **打开应用程序** 按钮，它应该打开我们的应用程序，对吗？
- en: Not yet, but we're almost there—we still need to sort out one more thing.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还没有，但我们快到了——我们还需要解决一件事。
- en: Getting the application port from the environment
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从环境中获取应用程序端口
- en: Heroku has some particularities when it comes to running Docker images. It doesn't
    allow us to set the port where the application is running. What it does is assign
    a port where the application should run, and then redirect **HyperText Transfer
    Protocol** (**HTTP**) and **HyperText Transfer Protocol Secure** (**HTTPS**) traffic
    from the application URL there. If this still feels strange, no worries—we'll
    get there.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Heroku上运行Docker镜像时，Heroku有一些特别之处。它不允许我们设置应用程序运行的端口。它所做的是为应用程序分配一个端口，然后将来自应用程序URL的**超文本传输协议**（**HTTP**）和**超文本传输协议安全**（**HTTPS**）流量重定向到那里。如果这听起来仍然很奇怪，不用担心——我们会解释清楚。
- en: As you know, we explicitly defined the port our application was going to run
    on in the `config.production.yml` file. We need to adapt this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，我们在`config.production.yml`文件中明确定义了应用程序将要运行的端口。我们需要适应这一点。
- en: 'The way Heroku defines which port an application should run on is by setting
    the `PORT` environment variable. This is documented at the following link:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku定义应用程序应运行的端口的方式是通过设置`PORT`环境变量。这在以下链接中有文档说明：
- en: '[https://devcenter.heroku.com/articles/container-registry-and-runtime#dockerfile-commands-and-runtime](https://devcenter.heroku.com/articles/container-registry-and-runtime#dockerfile-commands-and-runtime)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://devcenter.heroku.com/articles/container-registry-and-runtime#dockerfile-commands-and-runtime](https://devcenter.heroku.com/articles/container-registry-and-runtime#dockerfile-commands-and-runtime)'
- en: You'll probably know from the title what we're doing next. We're going to change
    our application so that the web server port coming from the environment overrides
    the one defined in the configuration file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从标题中你可能知道我们接下来要做什么。我们要更改我们的应用程序，以便来自环境的Web服务器端口覆盖配置文件中定义的那个。
- en: 'Go back to `src/config/index.ts` in the application and make sure it is reading
    the `PORT` variable from the environment, overriding the configuration coming
    from the file. The code can be seen in the following snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 回到应用程序中的`src/config/index.ts`，确保它从环境中读取`PORT`变量，覆盖来自文件的配置。代码如下所示：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This way, we make sure that we're reading the variable from the `PORT` environment
    variable, using the value in the configuration file as a default.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们确保我们从`PORT`环境变量中读取变量，并在配置文件中使用默认值。
- en: And this should be all it takes to get our application running smoothly in Heroku!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，让我们的应用程序在Heroku上顺利运行就应该没问题了！
- en: Once again, we can test this by going to the Heroku Dashboard ([https://dashboard.heroku.com/apps/boiling-dusk-18477](https://dashboard.heroku.com/apps/boiling-dusk-18477))
    and clicking the **Open App** button, or you can do this by going directly to
    the URL—in my case, it's [https://boiling-dusk-18477.herokuapp.com/](https://boiling-dusk-18477.herokuapp.com/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以通过访问Heroku控制台([https://dashboard.heroku.com/apps/boiling-dusk-18477](https://dashboard.heroku.com/apps/boiling-dusk-18477))并点击**打开应用**按钮来测试这一点，或者你可以直接访问URL——在我的情况下，是[https://boiling-dusk-18477.herokuapp.com/](https://boiling-dusk-18477.herokuapp.com/)。
- en: Important note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using MongoDB Atlas, as we did in [*Chapter 6*](B16380_06_Final_JM_ePub.xhtml#_idTextAnchor141),
    *Adding Authentication and Connecting to the Database*, and want to allow your
    application to access the database, you have to configure it so that it enables
    connections from "anywhere". This isn't recommended practice if you're exposing
    an application to your users, and it only happens because we're using Heroku's
    Free Tier. As it runs in a shared cluster, we have no way of knowing what the
    fixed **Internet Protocol** (**IP**) address is of the machine running the application,
    and we need to do it this way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我们在[第6章](B16380_06_Final_JM_ePub.xhtml#_idTextAnchor141)中使用MongoDB Atlas，*添加身份验证并连接到数据库*，并希望允许你的应用程序访问数据库，你必须配置它以启用来自“任何地方”的连接。如果你将应用程序暴露给用户，这并不是推荐的做法，而且只因为我们使用Heroku的免费层才这样。由于它在一个共享的集群中运行，我们没有办法知道运行应用程序的机器的固定的**互联网协议**（**IP**）地址，我们只能这样做。
- en: 'The following link demonstrates how can you configure network access to the
    database: [https://docs.atlas.mongodb.com/security/ip-access-list](https://docs.atlas.mongodb.com/security/ip-access-list).
    Make sure you click **ALLOW ACCESS FROM ANYWHERE** in the MongoDB Atlas network
    access screen.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接展示了如何配置数据库的网络访问：[https://docs.atlas.mongodb.com/security/ip-access-list](https://docs.atlas.mongodb.com/security/ip-access-list)。确保你在MongoDB
    Atlas网络访问屏幕上点击**允许从任何地方访问**。
- en: 'This is what the network access screen looks like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – MongoDB Atlas network access screen'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16380.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – MongoDB Atlas network access screen
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, our application should work as expected; you can try to perform
    a request to register a user (that connects to the database) and check that everything''s
    fine, as demonstrated in the following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you got a response that's similar to the preceding one, you're all set! We
    managed to configure and deploy our application in a cloud environment and created
    an automated way to ship updates to our users.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'To do a final test to check whether the code is being deployed successfully,
    we can try to change part of the code and trigger the deployment process again.
    Let''s do it! Proceed as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Change our `"Hello World"` message in `src/web/index.ts` to `"Hello Deno World!"`,
    as illustrated in the following code snippet:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add this change to version control, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Push it into Heroku''s `git` remote repository, like this:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we now access the application URL (which is [https://boiling-dusk-18477.herokuapp.com/](https://boiling-dusk-18477.herokuapp.com/),
    in our case), you should get the `Hello Deno World` message.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that our application was successfully deployed. Since we're using
    a cloud platform that provides more than what we learned here, we can explore
    other Heroku features, such as logging.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to the **Open app** button on the Heroku Dashboard ([https://dashboard.heroku.com/](https://dashboard.heroku.com/)),
    you have a **More** button. One of the options is **View logs**, as you can see
    in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – More application options in the Heroku Dashboard'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16380.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – More application options in the Heroku Dashboard
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If you click there, an interface that shows the logs in real time will appear.
    You can try it out by opening your application in a different tab (by clicking
    the **Open app** button).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll see that the logs instantly update, and something like this should
    appear there:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is of great use when you want to have a very light monitoring of how your
    application is running. The Logging feature is provided in the Free Tier, but
    there are many more features you can explore, such as the **Metrics** one, which
    we'll not do here.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to have a detailed look at when and by whom your application was
    deployed, you can also use the **Activity** section from the Heroku Dashboard,
    as illustrated in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Heroku Dashboard application options](img/Figure_9.3_B16380.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Heroku Dashboard application options
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll then see a log of your most recent deployments, another very interesting
    feature of Heroku, as illustrated in the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Activity tab in the Heroku Dashboard application'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_B16380.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Activity tab in the Heroku Dashboard application
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our section on deploying the application in a cloud environment.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们在云环境中部署应用程序部分的结束。
- en: We focused on the application and on topics that can and will be reused independent
    of the platform on which your code is running. We've iterated the application
    logic that loaded the configuration so that it could load different configurations
    depending on the environment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的是应用程序及其可以在不同平台上独立重用的主题。我们迭代了加载配置的应用程序逻辑，使其能够根据环境加载不同的配置。
- en: Then, we learned how we could send environment variables with secret configuration
    values to our application, and we wrapped up by exploring logging on the platform
    of choice for this example, Heroku—and that was it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何将包含机密配置值的环境变量发送到我们的应用程序，最后通过探索本例中选择的平台Heroku上的日志记录来结束。
- en: We managed to get our application to run, and we created a whole infrastructure
    around it that will enable future iterations to be easily shipped to our users.
    Hopefully, we went through some of the phases you'll also go through next time
    you decide to deploy a Deno application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功让应用程序运行起来，并且围绕它创建了一个完整的架构，这将使未来的迭代能够轻松地部署给我们的用户。希望我们经历了一些您下次部署Deno应用程序时也会遇到阶段。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: And we're pretty much done! This chapter completes the cycle of development
    phases in our application by deploying it. We went from building a very simple
    application, to adding features to it, to adding tests, and—finally—to deploying
    it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了大部分工作！本章完成了我们应用程序开发周期的循环，通过部署它。我们从构建一个非常简单的应用程序开始，然后向其中添加功能，再添加测试，最后—部署它。
- en: Here, we learned how we can use some of the benefits of containerization in
    our applications. We started learning about Docker, our container runtime of choice,
    and rapidly moved on to creating an image for our application. Learning about
    some Docker commands as we moved through the process, we also experienced how
    easy it is to prepare a Deno application to be deployed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们学习了如何利用容器化的一些优势来应用我们的应用程序。我们开始学习Docker，我们选择的容器运行时，并迅速转到为我们的应用程序创建镜像。在学习过程中了解一些Docker命令，我们也体验了将Deno应用程序部署出去有多容易。
- en: Creating this Docker image enabled us to have a replicable way of installing,
    running, and distributing our application, creating a package with everything
    the applications needs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个Docker镜像使我们能够以一种可复用的方式安装、运行和分发我们的应用程序，创建一个包含应用程序所需的所有内容的包。
- en: As the chapter proceeded, we started to explore how we can use this application
    package to deploy it in a cloud environment. We started by configuring the cloud
    platform of choice for this step-by-step guide, Heroku, so that it would rebuild
    and run our application's code every time it changed, and we very easily made
    it with the help of `git` and Heroku's documentation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 随着章节的进行，我们开始探索如何使用这个应用程序包将其部署到云环境中。我们首先配置了本步骤指南中选择的云平台Heroku，使其每次发生变化时都会重新构建并运行我们的应用程序代码，在`git`和Heroku文档的帮助下，我们非常容易地实现了这一点。
- en: As the automated pipeline was configured, we understood the need to send configuration
    values to our application. These same configuration values, which we previously
    implemented in earlier chapters, needed to be sent to the application in two different
    ways, via a configuration file and via the environment. We tackled each one of
    those needs, first by iterating the application code so that it loaded different
    configurations depending on the environment, and later by learning how to set
    configuration values in an application living on Heroku.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自动化流水线已经配置完成，我们理解了需要将配置值发送到我们的应用程序。之前在早期章节中实现的这些相同的配置值，需要通过配置文件和环境变量两种不同的方式发送到应用程序中。我们逐一解决了这些需求，首先通过迭代应用程序代码，使其根据环境加载不同的配置，随后学习了如何在Heroku上运行的应用程序中设置配置值。
- en: 'We finally got our application to run flawlessly and completed the objective
    of the chapter: to have a replicable, automated way to deploy code to our users.
    In the meantime, we learned a bit about Docker and the benefits of containerization
    and automation when it comes to releasing code.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们的应用程序运行得完美无缺，并完成了本章的目标：为我们的用户提供一种可复用、自动化的部署代码方式。与此同时，我们还了解了一些关于Docker以及容器化和自动化在发布代码方面的优势。
- en: This pretty much wraps it up on the book's objective. We decided to make this
    a journey of building an application, separately going through all its phases
    and addressing them as needed. This was the last phase—deploying it, which hopefully
    closes the cycle for you in terms of going from the first line of code to deployment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的内容基本上已经讲到这里了。我们决定让这个过程成为一个建立应用程序的旅程，分别经历它的所有阶段并在需要时解决它们。这是最后一个阶段——部署，希望这能为您从编写第一行代码到部署的整个周期画上句号。
- en: The next chapter will focus on what's next when it comes to Deno, both for the
    runtime and for you personally. I hope this has made you a Deno enthusiast and
    that you are as excited as I am about it and the world of possibilities it opens
    up.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点关注Deno接下来的发展，包括运行时和您个人方面。我希望这能让您成为Deno的爱好者，并且您对它以及它所开启的无限可能世界像我一样充满热情。
