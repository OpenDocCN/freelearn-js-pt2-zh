- en: '*Chapter 4*: Building a Web Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：构建网络应用程序
- en: 'Here we are! We have traveled down a long road to get here. This is where all
    the fun starts. We''ve been through three phases: getting to know what Deno is,
    exploring the toolchain provided by it, and understanding the details and functionality
    available via its runtime.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于来了！我们走过了漫长的道路，才到达这里。这里的乐趣才刚刚开始。我们已经经历了三个阶段：了解Deno是什么，探索它提供的工具链，以及通过其运行时了解其详细信息和功能。
- en: Pretty much all the content from the previous chapters will prove to be useful
    in this one. Hopefully, the introductory chapters made you feel confident enough
    to start applying what we have learned together. We'll use those chapters, together
    with your existing TypeScript and JavaScript knowledge, to build a complete web
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎本章之前的所有内容都将证明是有用的。希望，前面的章节让你有足够的信心开始应用我们所学的知识。我们将利用这些章节，结合你现有的TypeScript和JavaScript知识，来构建一个完整的网络应用程序。
- en: We'll be writing an API that contains business logic, handles authentication,
    authorization, and logging, and much more. We will cover enough of the fundamental
    pieces for you to, at the end, feel comfortable choosing Deno to build your next
    great app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个包含业务逻辑、处理身份验证、授权和日志记录等内容的API。我们将涵盖足够的基本内容，让你在最后觉得舒适地选择Deno来构建你下一个伟大的应用程序。
- en: In this chapter, instead of talking just about Deno, we will also go over some
    thoughts regarding the fundamentals of software engineering and application architecture.
    We believe it is crucial to keep some things in mind when it comes to building
    an application from scratch. We will look at of the fundamentals, which will be
    proven useful and help us structure our code, enabling it to evolve in the future
    by making it easy to change.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不仅仅讨论Deno，还会回顾一些关于软件工程和应用程序架构的基本思想。我们认为，在从头开始构建应用程序时，保持一些事情在心中至关重要。我们将查看一些基本原则，这些原则将证明是有用的，并帮助我们结构化代码，使其易于更改，从而使它能够适应未来。
- en: Later, we will start to reference some third-party modules, look at their approaches,
    and decide on what we'll use from here on to help us deal with routing and HTTP
    related challenges. We'll also make sure that we structure our application in
    a way that the third-party code is isolated and works as an enabler for the functionalities
    we want to build, more than the functionalities themselves.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们将开始参考一些第三方模块，查看它们的方法，并决定从这里开始使用哪些来帮助我们处理路由和HTTP相关挑战。我们还将确保我们的应用程序结构以一种第三方代码被隔离并且作为我们想要构建的功能的启用器而不是功能本身来工作的方式进行组织。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Structuring a web application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化网络应用程序
- en: Exploring Deno HTTP frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Deno HTTP框架
- en: Let's get started!
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files used in this chapter are available at the following link: [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码文件可在以下链接找到：[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api)。
- en: Structuring a web application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化网络应用程序
- en: 'When starting an application, it''s important that we spend some time thinking
    about its structure and architecture. That''s where there this section will start:
    by looking at the backbone of application architecture. We''ll have a look at
    what advantages it brings and align ourselves with a set of principles that will
    help us scale it as the application grows.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个应用程序时，花时间思考其结构和架构是很重要的。这一节将从这个角度开始：通过查看应用程序架构的核心。我们将看看它带来了什么优势，并使自己与一套原则保持一致，这些原则将帮助我们在应用程序增长时扩展它。
- en: Then, we'll develop what will become the application's first endpoint. However,
    first, we'll start with the business logic. The persistency layer will follow,
    and we'll finish by looking at an HTTP endpoint that will act as the application's
    entry point.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开发将成为应用程序第一个端点的代码。然而，首先，我们将从业务逻辑开始。持久性层将紧随其后，最后我们将查看一个HTTP端点，它将作为应用程序的入口点。
- en: Deno as an unopinionated tool
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Deno作为一款无偏见的工具
- en: When we're using tools that are low level and delegate many decisions to developers,
    such as Node.js and Deno, structuring an application is one of the big challenges
    that arises.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用将许多决策委托给开发者的低级工具，如Node.js和Deno时，结构化应用程序就成为了一个主要挑战。
- en: This is very different compared to an opinionated web framework, such as PHP
    Symfony, Java SpringBoot, or Ruby on Rails, where many of these decisions are
    made for us.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这与具有明确观点的Web框架，如PHP Symfony、Java SpringBoot或Ruby on Rails，有很大的不同，因为这些框架为我们做了许多决策。
- en: Most of these decisions have something to do with structure; that is, code and
    folder structure. Those frameworks normally provide us with ways to deal with
    dependencies, imports, and even provide some guidance regarding different application
    layers. Since we're using the *raw* language with a few packages, we will take
    care of structure by ourselves in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决策大多数与结构有关；也就是说，代码和文件夹结构。那些框架通常为我们提供处理依赖关系、导入的方法，甚至为不同的应用层提供一些指导。由于我们使用的是*原始*语言和几个包，所以我们将在本书中自己负责结构。
- en: The aforementioned frameworks can't be directly compared with Deno since they
    are frameworks built on top of languages, such as PHP, Java, and Ruby. But when
    we look at the JS world, namely at Node.js we can observe that the most popular
    tools used to create HTTP servers are Express.js and Kao. These tend to be much
    lighter than the aforementioned frameworks, and even though there are also some
    solid complete alternatives such as Nest.js or hapi.js, the Node.js community
    tends to prefer a *library* approach more than a *framework* one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的框架不能直接与Deno比较，因为它们是建立在诸如PHP、Java和Ruby等语言之上的框架。但当我们观察JS世界，也就是Node.js时，我们可以发现最流行的创建HTTP服务器的工具是Express.js和Kao.js。这些通常比前述的框架轻量许多，尽管也有一些像Nest.js或hapi.js这样坚实的完整替代品，但Node.js社区更倾向于采用*库*方法，而不是*框架*方法。
- en: Even though these very popular libraries provide a good amount of functionality,
    many decisions are still delegated to developers. This isn't the libraries' fault,
    but more a community preference.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些非常流行的库提供了大量功能，但许多决策仍然委托给开发者。这不是库的错，更多的是一个社区偏好。
- en: On one hand, having direct access to these primitives lets us build applications
    that are very well-suited to our use cases. On the other hand, flexibility is
    a trade-off. Having a lot of flexibility comes the responsibility of making an
    innumerous number of decisions. And when it comes to making many decisions there
    are many opportunities to make bad decisions. The hard part is that these are
    normally decisions that drastically influence the way a code base scales, and
    that's what gives them such importance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，直接访问这些原生对象让我们能构建非常适合我们用例的应用程序。另一方面，灵活性是有代价的。拥有极大的灵活性随之而来的是做出无数决策的责任。而在做出许多决策时，有很多机会做出糟糕的决策。难点在于，这些通常是对代码库扩展方式产生巨大影响的决策，这就是它们如此重要的原因。
- en: In its current state, Deno and its community are following an approach that's
    very similar to Node.js on this framework-versus-library subject. The community
    is mostly betting on light and small pieces of software that are created by developers
    to fit their specific needs. We'll evaluate some of these later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，Deno及其社区在框架与库这一问题上遵循与Node.js非常相似的方法。社区主要押注于开发者为满足他们特定需求而创建的轻量级、小型软件。我们稍后将在本章中评估一些这些软件。
- en: Starting here, and throughout this book, we'll use an application structure
    that we believe offers great benefits for the use case at hand. However, don't
    expect that structure and architecture to be a silver bullet, as we are pretty
    sure such things do not exist in the software world; every architecture will have
    to keep evolving as it grows.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，贯穿整本书，我们将使用一种我们相信对当前用例有很大好处的应用程序结构。然而，不要期望这种结构和架构是灵丹妙药，因为我们深信软件世界中不存在这样的东西；每种架构都将随着成长而不断进化。
- en: 'Instead of just throwing in a recipe and following it, we want to become familiar
    with a way of thinking – a rationale. This should enable us to make correct decisions
    further down the road with one objective in mind: *writing code that is easy to
    change*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅是要按照食谱机械地操作，而是要熟悉一种思维方式——一种逻辑。这应该能让我们在后续的道路上做出正确的决策，目标明确：*编写易于更改的代码*。
- en: By writing code that is easy to change, we're always ready to change our application
    for the better without much effort.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写易于更改的代码，我们总是准备好在不需要太多努力的情况下改进我们的应用程序。
- en: The most important part of an application
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序最重要的部分
- en: Applications are created to fit a purpose. It doesn't matter if that purpose
    is to support a business or a simple pet project. At the end of the day, we want
    it to do something. That *something* is what makes the application useful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是为了适应一个目的而创建的。无论这个目的是支持一个企业还是一个简单的宠物项目都不重要。到最后，我们希望它能做些什么。那个*做些什么*就是让应用程序变得有用的原因。
- en: This might seem obvious, but it is sometimes very easy for us, as developers,
    to get so enthusiastic about a technology that we forget that it is just a means
    to an end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很显然，但对于我们这些开发者来说，有时候很容易因为对某项技术充满热情而忘记，它只是一个达成目标的手段。
- en: As Uncle Bob says in his *Architecture – the lost years* talk ([https://www.youtube.com/watch?v=hALFGQNeEnU](https://www.youtube.com/watch?v=hALFGQNeEnU)),
    it is very common for people to forget the application's purpose and focus more
    on the technology itself. It is very important that we remember this in all the
    phases of application development, but it is even more critical when we're setting
    up its initial structure. Next, we'll discover the requirements for the application
    we'll be building throughout the remainder of this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如罗伯特叔叔在他的*架构——失去的岁月*演讲中说的([https://www.youtube.com/watch?v=hALFGQNeEnU](https://www.youtube.com/watch?v=hALFGQNeEnU)),人们很容易忘记应用程序的目的，而更多地关注技术本身。我们在应用程序开发的各个阶段都记住这一点非常重要，但在设置其初始结构时尤为关键。接下来，我们将发现本书剩余部分我们将要构建的应用程序的需求。
- en: What is our application about?
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的应用程序是关于什么的？
- en: 'Even though we truly believe that business logic is the most important thing
    in any application, in this book, the case is a little different. We''ll be creating
    an example application, but it will just be a means to reach the main goal: learning
    Deno. However, as we want the process to be as real as possible, we want to have
    a clear objective in mind.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们真心相信业务逻辑是任何应用程序最重要的事情，但在本书中，情况有点不同。我们将创建一个示例应用程序，但它只是一个达到主要目标的手段：学习Deno。然而，为了使过程尽可能真实，我们希望在心中有一个清晰的目标。
- en: 'We will build an application that will let people create and interact with
    a list of museums. We can make this clearer by listing its features as user stories,
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，让人们可以创建和与博物馆列表进行互动。我们可以通过将其功能作为用户故事来使其更清晰，如下所示：
- en: The user is able to register and log in.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以注册和登录。
- en: The user is able to create a museum with a title, description, and location.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以创建一个带有标题、描述和位置的博物馆。
- en: The user can view a list of museums.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以查看博物馆列表。
- en: Throughout this journey, we'll develop APIs and the logic to support those features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个旅程中，我们将开发API和支持这些功能的逻辑。
- en: Now that we're familiar with the end goals, we can start thinking about how
    to structure the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了最终目标，我们可以开始思考如何组织应用程序。
- en: Understanding folder structure and application architecture
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解文件夹结构和应用程序架构
- en: The first thing we need to be aware of regarding the folder structure, especially
    when we're starting a project from scratch without a framework, is that it will
    keep evolving with the project. A folder structure that is good for a project
    with a couple of endpoints will not be as good for a project with hundreds of
    them. This depends on many things, from team size, to the standards defined, and
    ultimately to preferences.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文件夹结构，我们需要注意的第一个问题是，尤其是当我们从零开始一个没有框架的项目时，它会随着项目的进行而不断演变。一个对于只有几个端点的项目来说不错的文件夹结构，对于有数百个端点的项目来说可能就不那么好了。这取决于很多因素，从团队规模，到制定的标准，最终到个人偏好。
- en: When defining the folder structure, it is important that we get to a place where
    we can facilitate future decisions about where to locate a piece of code. The
    folder structure should provide clear hints on how to make good architectural
    decisions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义文件夹结构时，重要的是我们要达到一个可以促进未来关于如何定位一段代码的决策的地方。文件夹结构应该为如何做出良好的架构决策提供清晰的提示。
- en: At the same time, we certainly don't want to create an overengineered application.
    We'll create enough abstractions so that modules are very contained and do not
    have knowledge outside their domain, but not more than that. Keeping this in mind
    also forces us to build flexible code and clear interfaces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们当然不希望创建一个过度工程化的应用程序。我们将创建足够的抽象，以便模块非常紧凑，并且不知道它们域外的知识，但不会超过这个程度。牢记这一点也迫使我们构建灵活的代码和清晰的接口。
- en: 'Ultimately, what''s most important is that the architecture enables the code
    base to be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，最重要的是架构能够使代码库如下所示：
- en: Testable
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试
- en: Easy to extend
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展
- en: Decoupled from a specific technology or library
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与特定技术或库松耦合
- en: Easy to navigate and reason about
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于导航和推理
- en: We'll have to keep in mind that, while creating folders, files, and modules,
    we don't want any of the previously listed topics to be compromised.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建文件夹、文件和模块时，我们必须记住，我们不想牺牲前面列出的任何主题。
- en: These principles are very much in line with the SOLID principles of software
    design, made famous by Uncle Bob, Robert C. Martin ([https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID))
    in another talk worth watching ([https://youtu.be/zHiWqnTWsn4](https://youtu.be/zHiWqnTWsn4)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则与软件设计中的SOLID原则非常一致，这些原则由Uncle Bob，Robert C. Martin（[https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)）在另一个值得一看的演讲中提出（[https://youtu.be/zHiWqnTWsn4](https://youtu.be/zHiWqnTWsn4)）。
- en: The folder structure we are going to use in this book might sound familiar to
    you if you come from a Node.js background.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书我们将要使用的文件夹结构，如果你有Node.js背景，可能会觉得熟悉。
- en: As it also happens with Node.js there's nothing preventing us from creating
    a full API in a single file. However, we will not do this as we believe that some
    initial separation of concerns will vastly improve our flexibility later, without
    sacrificing the developer's productivity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如发生在Node.js上一样，我们创建一个完整的API的单个文件没有任何障碍。然而，我们不会这样做，因为我们相信一些初步的关注点分离将大大提高我们的灵活性，而不会牺牲开发者的生产力。
- en: In the following section, we'll look at the responsibilities of the different
    layers and how they fit together while developing a feature for our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨不同层的责任以及它们如何在开发应用程序功能时相互配合。
- en: By following this line of thought, we strive to guarantee a degree of decoupling
    between modules. For instance, we want to ensure that making a change in the web
    framework doesn't means we have to touch business logic objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这种思路，我们努力保证模块之间的解耦程度。例如，我们希望能够确保在更改Web框架时，不必触摸业务逻辑对象。
- en: All these recommendations, as well as the ones we will be making throughout
    this book, will help ensure that the central part of our application is our business
    logic, with everything else being just plugins. A JSON API is just a way of sending
    our data to our users, while a database is just a way to persist data; neither
    of these should be central parts of the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些建议，以及我们在这本书中将会提出的建议，将有助于确保我们应用程序的核心部分是业务逻辑，其他所有内容只是插件。JSON API只是向用户发送我们数据的方式，而数据库只是持久化数据的方式；这两者都不应成为应用程序的核心部分。
- en: 'One way to make sure we''re doing this is to do the following mental exercise
    when we are writing the code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们这样做的一种方法是在编写代码时进行以下心理练习：
- en: '*"When you''re writing business logic, imagine that these objects will be used
    in a different context. Take, for instance, using the business logic with a different
    delivery mechanism (a CLI, for instance) or a different persistence engine (an
    in-memory database instead of a NOSQL database)."*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '"当你编写业务逻辑时，想象这些对象将在不同的上下文中使用。例如，使用不同的交付机制（例如CLI）或不同的持久化引擎（内存数据库而非NoSQL数据库）。"'
- en: In the next few pages, we'll walk you through how to create different layers,
    and we'll also explain all the design decisions and what they enable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将引导您创建不同的层，并解释所有设计决策以及它们所启用的功能。
- en: Let's get practical and start creating our project's backbone.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实践并开始构建我们项目的基础。
- en: Defining the folder structure
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义文件夹结构
- en: The first thing we'll do in our project's folder is create an `src` folder.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目的文件夹中做的第一件事是创建一个`src`文件夹。
- en: This is, predictably, where our code will live. We don't want any code to be
    at the root level of the project because configuration files, READMEs, documentation
    folders, and so on might be added there. This would make it hard to distinguish
    the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们代码将存放的地方。我们不希望有任何代码位于项目的根级别，因为可能会添加配置文件、READMEs、文档文件夹等。这将使得代码难以区分。
- en: We'll be spending most of our time inside the `src` folder in the following
    chapters. Since our application is about museums, we'll create a folder inside
    the `src` folder named `museums`. This is where most of the logic that will be
    written in this chapter will live. Later, we'll create files for types, controllers,
    and repositories. Then, we'll create the `src/web` folder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们大部分时间将在`src`文件夹内度过。由于我们的应用程序是关于博物馆的，我们将在`src`文件夹内创建一个名为`museums`的文件夹。这个文件夹将是本章将编写大部分逻辑的地方。后来，我们将创建类型、控制器和服务器的文件。然后，我们将创建`src/web`文件夹。
- en: The controller's file is where our business logic will live. The repository
    will take care of the logic related to data access, while the web layer will handle
    everything that is *web-related*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的文件是承载我们业务逻辑的地方。仓库将处理与数据访问相关的逻辑，而网络层将处理所有*与网络相关*的事情。
- en: 'You can see what the final structure will look like by taking a look at the
    GitHub repository of this book: [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看本书的GitHub仓库来了解最终结构会是什么样子：[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter04/museums-api)。
- en: The initial requirement for this chapter is that there is a route where we can
    perform a GET request and receive a list of museums in JSON format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的初始要求是有一个路由，我们可以在此执行GET请求并收到以JSON格式表示的博物馆列表。
- en: We will start in the controller's file (`src/museums/controller.ts`) and write
    the required business logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在控制器文件（`src/museums/controller.ts`）中编写所需的业务逻辑。
- en: 'This is how the folder''s structure should look like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构应该如下所示：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is our starting point. Everything that is related to museums will be located
    inside the `museums` folder, and we'll call it a module. The `controller` file
    will host the business logic, the `repository` file will host data fetching capabilities,
    and the `types` file will be where our types will be located.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们出发的起点。所有与博物馆相关的内容都将位于`museums`文件夹内，我们将之称作一个模块。`controller`文件将承载业务逻辑，`repository`文件将承载数据获取功能，而`types`文件将是我们放置类型的位置。
- en: Now, let's start coding!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编码！
- en: Developing the business logic
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发业务逻辑
- en: We previously stated that our business logic is the most important part of our
    application. Even though ours will be super simple for now, that's what we'll
    develop first.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，我们的业务逻辑是应用程序最重要的部分。尽管现在我们的会非常简单，但这是我们首先开发的。
- en: 'Since we''ll be using TypeScript for our application, let''s create the interface
    that will define our `Museum` object. Follow these steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用TypeScript来编写我们的应用程序，让我们来创建一个定义我们的`Museum`对象的接口。按照以下步骤操作：
- en: 'Go into `src/museums/types.ts` and create a type that defines a `Museum`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`src/museums/types.ts`并创建一个定义`Museum`的类型：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure it is exported as we'll be using this across other files.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保它被导出，因为我们将跨其他文件使用这个。
- en: Now that we know the type, we must create some business logic to get a list
    of museums.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 既然我们知道了类型，我们必须创建一些业务逻辑来获取博物馆列表。
- en: 'Inside `src/museums/types.ts`, create an interface that will define `MuseumController`.
    It should contain a method that lists all the museums:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums/types.ts`内，创建一个定义`MuseumController`的接口。它应该包含一个列出所有博物馆的方法：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside `src/museums/controller.ts`, create a class that will act as the controller.
    It should contain a function named `getAll`. In the future, this is where the
    business logic will live, but for now, we can just return an empty array:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums/controller.ts`内，创建一个类作为控制器。它应该包含一个名为`getAll`的函数。将来，这里将是业务逻辑的所在，但目前，我们只需返回一个空数组：
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We could use this to directly access the database and get certain records. However,
    since we want to be able to have our business logic isolated and not coupled with
    other parts of the application, we won't do this.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们本可以直接访问数据库并获取某些记录。然而，由于我们希望能够使我们的业务逻辑得到隔离，并不与应用程序的其他部分耦合，所以我们不会这样做。
- en: On top of that, we also want our business logic to be testable in isolation,
    without depending on a connection to a database or a server. To achieve this,
    we can't access our data source directly from our controller. Later, we will create
    an abstraction that will be responsible for getting those records from the database.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还希望业务逻辑能够独立于数据库或服务器的连接进行测试。为了实现这一点，我们不能直接从我们的控制器访问数据源。稍后，我们将创建一个抽象，它将负责从数据库获取这些记录。
- en: For now, we know that we will need to call an external module that will get
    all the museums for us it give them to our controller – it doesn't matter from
    where.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们知道我们将需要调用一个外部模块，它将为我们获取所有的博物馆，并将它们交给我们的控制器——它从哪里来无关紧要。
- en: 'Keep in mind the following software design best practice: *"Code to an interface,
    not an implementation."*'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住以下软件设计最佳实践：*"面向接口编程，而不是面向实现。"*
- en: Simply put, this quote means that we should define the module's signature and
    only then start thinking about its implementation. This vastly helps when it comes
    to designing clear interfaces.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单来说，这个引言的意思是我们应该定义模块的签名，然后才开始思考它的实现。这对设计清晰的接口非常有帮助。
- en: Going back to our controller, we know that the controller's `getAll` method
    will, at some point, have to call a module to get the data from a data source.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回到我们的控制器，我们知道控制器的`getAll`方法最终必须调用一个模块以从数据源获取数据。
- en: 'Inside `src/museums/types.ts`, define `MuseumRepository`, the module that will
    be responsible for getting the museums from a data source:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums/types.ts`中，定义`MuseumRepository`，这个模块将负责从数据源获取博物馆：
- en: '[PRE4]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside `src/museums/controller.ts`, add an injected class called `museumRepository`
    to the constructor:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/museums/controller.ts`中，向构造函数添加一个注入的类`museumRepository`：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a file called `src/index.ts`, import the `MuseumController`, instantiate
    it, and call the `getAll` method, logging its output. For now, you can inject
    a dummy repository that just returns an empty array:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/index.ts`的文件，导入`MuseumController`，实例化它，并调用`getAll`方法，记录其输出。现在，你可以注入一个伪仓库，它只是返回一个空数组：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run it to check whether it''s working:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它以检查是否正常工作：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's it! We just received the empty array that's coming from the dummy repository
    function!
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！我们刚刚从伪仓库函数中得到了一个空数组！
- en: With the abstraction we have created, our controller is now decoupled from the
    data source. Its dependencies are injected via a constructor, allowing us to change
    repositories without changing the controller later.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们创建的抽象，我们的控制器现在与数据源解耦。它的依赖关系通过构造函数注入，允许我们稍后不改变控制器而更改仓库。
- en: What we just did is called **dependency inversion** – the **D** in the SOLID
    principles – and it consists of lifting up part of the dependencies to the function
    caller. This makes it very easy to test the inside functions independently, as
    we will see in [*Chapter 8*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178),
    *Testing – Unit and Integration*, where we'll cover testing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚所做的称为**依赖倒置**——SOLID原则中的**D**——它包括将部分依赖性提升到函数调用者。这使得独立测试内部函数变得非常容易，正如我们将在[*第8章*](B16380_08_Final_JM_ePub.xhtml#_idTextAnchor178)，*测试——单元和集成*中看到的，我们将涵盖测试。
- en: To transform what we just wrote into a fully functioning app, we need to have
    a database or something that looks like one. We need something that can store
    and retrieve a list of museums. Let's create that now.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们刚刚编写的代码转换为完全功能的应用程序，我们需要有一个数据库或类似的东西。我们需要一个可以存储和检索博物馆列表的东西。现在让我们创建这个东西。
- en: Developing the data accessing logic
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发数据访问逻辑
- en: While developing the controller, we noticed that we needed something that would
    be able to get the data; that is, the repository. This is the module that will
    abstract all the calls to a data source, and in this case, the data source that
    stores the museums. It will have a very well-defined set of methods, and whoever
    wants to access the data should do so through this module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发控制器时，我们注意到我们需要一个能够获取数据的东西，即仓库。这个模块将抽象所有对数据源的调用，在这个案例中，数据源存储博物馆。它将有一组非常明确的方法，任何想要访问数据的人都应该通过这个模块进行访问。
- en: We already have part of its interface defined inside `src/museums/types.ts`,
    so let's write a class that implements it. For now, we will not connect it to
    a real database. We will use an ES6 Map as an in-memory database instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`src/museums/types.ts`中定义了其接口的一部分，所以让我们写一个实现它的类。现在，我们不会将它连接到真实的数据库。我们将使用ES6
    Map作为内存中的数据库。
- en: 'Let''s get into our repository file and start writing our data accessing logic
    by following these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的仓库文件，并按照以下步骤开始编写我们的数据访问逻辑：
- en: Open the `src/museums/repository.ts` file and create a `Repository` class.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/museums/repository.ts`文件，创建一个`Repository`类。
- en: 'It should have a property named `storage` that will be a JavaScript `Map`.
    The `Map` keys should be strings and the values should be objects of the `Museum`
    type:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该有一个名为`storage`的属性，这将是一个JavaScript `Map`。`Map`的键应该是字符串，值应该是`Museum`类型的对象：
- en: '[PRE8]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are using TypeScript generics to set the types of our `Map`. Note that we've
    imported the `Museum` interface from the museum controller, as well as `MuseumRepository`,
    which is implemented by our class.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用TypeScript泛型来设置我们的`Map`的类型。请注意，我们已经从博物馆控制器中导入了`Museum`接口，以及由我们的类实现的`MuseumRepository`。
- en: Now that the *database* is "ready", we have to expose certain methods so that
    people can interact with it. The requirement from the previous section is that
    we can get all the records from the database. Let's implement that next.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 既然“数据库”已经“准备就绪”，我们必须暴露某些方法，以便人们可以与之交互。上一部分的要求是我们可以从数据库中获取所有记录。让我们接下来实现这一点。
- en: 'Inside the repository class, create a method named `getAll`. It should be responsible
    for returning all the records in our `storage` `Map`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仓库类内部，创建一个名为`getAll`的方法。它应该负责返回我们`storage` `Map`中的所有记录：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `src/museums/index.ts` file that exports the museum''s controller
    and repository:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/museums/index.ts`的文件，导出博物馆的控制器和仓库：
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To remain consistent, we'll need go to all the previous imports that were importing
    from a file that isn't `src/museums/index.ts` and change them so that they're
    only importing things from this file.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了保持一致性，我们需要去所有之前从不是`src/museums/index.ts`的文件中导入的导入，并更改它们，使它们只从这个文件中导入东西。
- en: 'Update the `controller.ts` and `repository.ts` imports to import from the `index`
    file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`controller.ts`和`repository.ts`的导入，使它们从`index`文件中导入：
- en: '[PRE11]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You've probably guessed what we must do next… Do you remember the end of the
    previous section, where we injected a dummy function into the museum's controller,
    which was returning an empty array? Let's go back to this and use the logic we
    just wrote.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经猜到我们接下来必须做什么了……你还记得上一部分末尾吗，我们在博物馆控制器中注入了一个虚拟函数，它返回一个空数组？让我们回到这一点并使用我们刚刚编写的逻辑。
- en: 'Go back to `src/index.ts`, import the `Repository` class we''ve just developed
    and inject it into the `MuseumController` constructor:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/index.ts`，导入我们刚刚开发的`Repository`类，并将其注入到`MuseumController`构造函数中：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's add a fixture to our "database" so that we can check it if it's actually
    printing something.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们向我们的“数据库”添加一个测试数据，这样我们就可以检查它是否实际上正在打印一些内容。
- en: Access the storage property in `museumRepository` and add a fixture to it.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`museumRepository`中的`storage`属性，并向其添加一个测试数据。
- en: 'This is currently an anti-pattern as we''re directly accessing the module''s
    database, but we''ll create a method so that we can add fixtures properly later:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这目前是一个反模式，因为我们直接访问了模块的数据库，但我们将创建一个方法，以便我们以后可以正确地添加测试数据：
- en: '[PRE13]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s run our code again:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行我们的代码：
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With that, the connection to our database is working, as we can see by the printed
    fixture.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这个，我们数据库的连接就可以工作了，正如我们通过打印测试数据所看到的那样。
- en: The abstractions we created in the previous section enabled us to change the
    data source without changing the controller. This is one of the advantages of
    the architecture we are using.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一部分创建的抽象使我们能够在不更改控制器的情况下更改数据源。这是我们正在使用的架构的一个优点。
- en: Now, if we recall our initial requirement, we can confirm that we are halfway
    there. Our business logic to satisfy the use case has been created – we're just
    missing the HTTP part.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们回顾我们的初始需求，我们可以确认我们已经完成了一半。我们已经创建了满足用例的业务逻辑——我们只是缺少HTTP部分。
- en: Creating the web server
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Web服务器
- en: 'Now that we have our functionality in place, we need to expose it via a web
    server. Let''s use what we''ve learned from the standard library to create it
    by following these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的功能，我们需要通过Web服务器暴露它。让我们使用我们从标准库学到的知识来创建它，并按照以下步骤进行：
- en: 'Create a file named `index.ts` inside the `src/web` folder and add the logic
    there to create a server. We can copy and paste it from the previous chapter''s
    exercise:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/web`文件夹中创建一个名为`index.ts`的文件，并在那里添加创建服务器的逻辑。我们可以从上一章的练习中复制并粘贴它：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since we want our application to be easily configurable, we don't want `port`
    to be hardcoded here but to be configurable from the outside. We need to export
    this server creation logic as a function.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们希望应用程序易于配置，我们不希望`port`在这里是硬编码的，而是可以从外部配置的。我们需要将这个服务器创建逻辑作为一个函数导出。
- en: 'Wrap the server logic creation inside a function that receives the configuration
    and `port` as an argument:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务器逻辑创建封装在一个接收配置和`port`作为参数的函数中：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make this function''s parameters an `interface`. This will help us in terms
    of documentation and will also add type safety and static checks:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个函数的参数设置为`接口`。这将有助于我们的文档工作，并且还会增加类型安全和静态检查：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have configured the web server, we can think of using it for our
    use case.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经配置了网络服务器，我们可以考虑为其使用场景使用它。
- en: 'Go back to `src/index.ts`, import `createServer`, and use it to create a server
    running on port `8080`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/index.ts`，导入`createServer`，并使用它创建一个在端口`8080`上运行的服务器：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run it and see if it works:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它并看看它是否起作用：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we can see that we have a log stating that the server is running and a
    log of the result from the previous section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到有一个日志记录服务器正在运行，以及来自上一节的日志结果。
- en: 'Now, we can test the web server with `curl` to guarantee it is working:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`curl`测试网络服务器以确保它正在工作：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, it works – we have some pretty basic logic that still doesn't
    satisfy our requirements but that spins up a web server. What we'll do next is
    connect this web server with the logic we wrote previously.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它起作用了——我们有一些相当基础的逻辑，但这仍然不能满足我们的要求，却能启动一个网络服务器。我们接下来要做的就是将这个网络服务器与之前编写的逻辑连接起来。
- en: Wiring the web server to the business logic
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将网络服务器与业务逻辑连接起来
- en: We're pretty close to finishing what we planned to do at the beginning of this
    chapter. We currently have a web server and some business logic; it is the connection
    that is missing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离完成本章开始时计划做的事情已经相当接近了。我们目前有一个网络服务器和一些业务逻辑；缺少的是连接。
- en: One quick way to connect both things would be to import the controller directly
    on `src/web/index.ts` and use it there. Here, the application would have the desired
    behavior and currently, that doesn't bring any problems.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将两者连接起来的一个快速方法是将控制器直接导入`src/web/index.ts`并在那里使用它。在这里，应用程序将具有所需的行为，目前，这并没有带来任何问题。
- en: However, since we are thinking of an app architecture that can grow without
    many issues, we won't do this. This is because it would make it very hard to test
    our web logic in isolation, thus compromising one of our principles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们考虑的是一个可以无需太多问题就能扩展的应用程序架构，我们不会这样做。这是因为这将使测试我们的网络逻辑变得非常困难，从而违背了我们的一条原则。
- en: If we import the controller directly from the web server, every time we call
    the `createServer` function in a testing environment, it will automatically import
    and call the methods from the `MuseumController` and that's not what we want.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接从网络服务器导入控制器，那么每次在测试环境中调用`createServer`函数时，它都会自动导入并调用`MuseumController`中的方法，这不是我们想要的结果。
- en: We will use dependency inversion once more to send the controller's methods
    to the web server. If this still seems too abstract, don't worry – we'll get to
    the code in a minute.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用依赖倒置将控制器的函数发送到网络服务器。如果这仍然看起来过于抽象，不要担心——我们马上就会看到代码。
- en: To make sure we aren't forgetting our initial goal, what we want is for, when
    a user does a `GET` request to `/api/museums`, our web server to return a list
    of museums.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们没有忘记我们的初始目标，我们想要的是，当用户对`/api/museums`进行`GET`请求时，我们的网络服务器返回一个博物馆列表。
- en: Since we're doing this as an exercise, we will not use a routing library just
    yet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行这个练习，我们暂时不会使用路由库。
- en: We just want to add a basic check to ensure that the URL and method of the request
    are the ones we want to answer to. If they are, we want to return the list of
    museums.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想添加一个基本检查，以确保请求的URL和方式是我们希望回答的。如果是，我们想返回博物馆列表。
- en: 'Let''s go back to the `createServer` function and add our route handler:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`createServer`函数并添加我们的路由处理程序：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ve added a basic check for the request URL and method and a different response
    when they match the initial requirement. Let''s run the code to see how it behaves:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了对请求URL和方法的基本检查，以及它们符合初始要求时的不同响应。让我们运行代码看看它的行为如何：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, test it with `curl`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，用`curl`测试它：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It works – cool!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它起作用了——酷！
- en: Now comes the part where we define what we need in order to satisfy this request
    as an interface.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们定义需要什么来满足这个请求作为接口的部分。
- en: 'We ultimately require a function that returns a list of museums to be injected
    into our server. Let''s add that inside the `CreateServerDependencies` interface
    by following these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终需要一个返回博物馆列表的函数，以注入到我们的服务器中。让我们按照以下步骤在`CreateServerDependencies`接口中添加该功能：
- en: 'Back inside `src/web/index.ts`, add `MuseumController` as a dependency to the
    `createServer` function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/web/index.ts`中，将`MuseumController`作为`createServer`函数的一个依赖项添加：
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the `getAll` function from the museum''s controller to get a list of all
    the museums and respond to the request:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从博物馆控制器中调用`getAll`函数以获取所有博物馆的列表并响应请求：
- en: '[PRE25]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Go back to `src/index.ts`, which is where we are calling the `createServer`
    function, and send the `getAll` function from `MuseumController`. You can also
    remove the code that directly calls the controller method from the previous section
    as it is of no use at the moment:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`src/index.ts`，这是我们调用`createServer`函数的地方，并发送来自`MuseumController`的`getAll`函数。你也可以删除上一节直接调用控制器方法的代码，因为此刻它没有任何用处：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the application again:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用程序：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Send a request to http://localhost:8080/api/museums; you will get a list of
    museums:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向http://localhost:8080/api/museums发送请求；你会得到一个博物馆列表：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And there it is – we're getting the list of museums!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们得到了博物馆的列表！
- en: We've just accomplished the goal of this section; that is, to connect our business
    logic to the web server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了本节的 goals；也就是说，将我们的业务逻辑连接到web服务器。
- en: Note how we've enabled the controller methods to be injected instead of the
    web server being the one that directly imports it. This was made possible because
    we used dependency inversion. This is something we'll keep doing throughout this
    book, whenever we want to decouple and increase the testability of modules and
    functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使控制器方法可以被注入，而不是web服务器直接导入它。这之所以可能，是因为我们使用了依赖倒置。这是我们在这本书中会持续做的事情，无论何时我们想要解耦并增加模块和函数的可测试性。
- en: While doing our mental exercise to test the coupling of our code, when we wanted
    to use the current business logic with a different delivery mechanism, such as
    a CLI, nothing impeded us. We could still reuse the same controllers and repositories.
    This means that we're doing a nice job of using abstractions to decouple our business
    logic from the application logic.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行代码耦合的思维锻炼时，当我们想要将当前的业务逻辑与不同的交付机制（如CLI）结合使用时，没有任何阻碍。我们仍然可以重用相同的控制器和存储库。这意味着我们很好地使用了抽象来将业务逻辑与应用程序逻辑解耦。
- en: Now that we have the baseline of our application architecture and folder structure,
    and we also understand the *whys* behind it, we can start looking at the utilities
    that might help us build it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了应用程序架构和文件结构的基线，并且也理解了背后的*原因*，我们可以开始查看可能帮助我们构建它的工具。
- en: In the next section, we will have a look at the current HTTP frameworks that
    exist in the Deno community. We won't spend much time doing this, but we want
    to understand the pros and cons of each one and ultimately choose one to help
    us with the rest of our journey.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看Deno社区中现有的HTTP框架。我们不会花太多时间在这方面，但我们需要了解每个框架的优缺点，并最终选择一个来帮助我们完成余下的旅程。
- en: Exploring Deno HTTP frameworks
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Deno HTTP框架
- en: When you're building an application that's more complex than a simple tutorial,
    and if you don't want to take a purist approach, you are most likely going to
    use third-party software.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个比简单教程更复杂的应用程序时，如果你不想采取纯粹主义方法，你很可能会使用第三方软件。
- en: Obviously, this is not something particular to Deno. Even though there are communities
    that are keener on using third-party modules than others, all the communities
    use third-party software.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不仅仅是Deno特有的。尽管有些社区比其他社区更愿意使用第三方模块，但所有社区都在使用第三方软件。
- en: We could go over the reasons why people do or don't do this, but the more popular
    reasons are always to do with reliability and time management. This might be because
    you want to use software that is battle tested instead of building it yourself.
    Sometimes, it is a mere time management question of not wanting to rewrite something
    that has already been created.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以讨论人们为什么这样做或不做，但更常见的原因总是与可靠性和时间管理有关。这可能是因为你想使用经过实战测试的软件，而不是自己构建。有时，这只是时间管理问题，即不想重写已经创建的东西。
- en: One important thing we have to say is that we must be extremely cautious in
    terms of how many of the applications we're building are coupled with third-party
    software. We don't mean that you should try to reach for the utopia of having
    everything completely decoupled, especially because that introduces other problems
    and lots of indirection. What we're saying is that we should be very aware of
    the cost of bringing a dependency into our code and the trade-offs it introduces.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点我们必须说的是，我们必须极其谨慎地考虑我们构建的应用程序中有多少与第三方软件耦合。我们并不是说你应该试图达到完全解耦的乌托邦，尤其是因为这会引入其他问题和大量的间接性。我们要说的是，我们应该非常清楚地将一个依赖项引入我们的代码以及它引入的权衡。
- en: In the first section of this chapter, we built the foundations for a web application
    that we'll be adding features to throughout the rest of this book. In its current
    state, it is still very small, so it doesn't have any dependencies other than
    the standard library.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们构建了一个web应用程序的基础，我们将在本书的其余部分向其添加功能。在其当前状态，它仍然非常小，因此除了标准库之外，没有其他依赖。
- en: In that application, we did a couple of things that we don't believe will scale
    well, such as defining routes by matching URLs and HTTP methods using plain `if`
    statements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在那篇应用中，我们做了一些我们认为不会很好扩展的事情，比如使用普通的`if`语句根据URL和HTTP方法定义路由。
- en: As the application grows, it is likely that we will have more advanced needs.
    These needs can go from dealing with an HTTP request body in different formats
    to having more complex routing systems, handling headers and cookies, or connecting
    to a database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，我们可能会需要更高级的功能。这些需求可能从处理不同格式的HTTP请求体，到拥有更复杂的路由系统，处理头部和cookies，或连接数据库。
- en: Because we don't believe in reinventing the wheel when it comes to developing
    applications, we will analyze a few libraries and frameworks that currently exist
    in the Deno community and are focused on creating web applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不相信在开发应用程序时重新发明轮子，所以我们将分析Deno社区目前存在的几个库和框架，它们专注于创建web应用程序。
- en: We will take a general look at the existing solutions and explore their features
    and approaches.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对现有的解决方案进行一般性的观察，并探索它们的功能和方法。
- en: In the end, we'll choose the one we believe offers the best trade-off for our
    use case.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将选择我们认为最适合我们用例的一个。
- en: What alternatives exist?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在哪些替代方案？
- en: At the time of writing, there are a few third-party packages that offer a great
    amount of functionality to create web applications and APIs. Some of them are
    heavily inspired by very popular Node.js packages, such as Express.JS, Koa, or
    hapi.js, while others are inspired by other frameworks outside of JavaScript,
    such as Laravel, Flask, and so on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，有几个第三方包提供了大量功能来创建web应用程序和API。其中一些深受非常流行的Node.js包（如Express.JS、Koa或hapi.js）的启发，而其他则受到JavaScript之外的框架（如Laravel、Flask等）的启发。
- en: We'll be exploring four of them that are quite popular and well-maintained at
    the time of writing. Keep in mind since as Deno and the mentioned packages are
    evolving quickly, this might change over time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索其中的四个，这些在撰写本文时非常流行且维护得很好。请注意，由于Deno和提到的包正在快速发展，这可能会随时间而变化。
- en: Important note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There is a great article by Craig Morten that does a very thorough analysis
    and exploration of the available libraries. I heavily recommend this article if
    you want to find out more ([https://dev.to/craigmorten/what-is-the-best-deno-web-framework-2k69](https://dev.to/craigmorten/what-is-the-best-deno-web-framework-2k69)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Craig Morten撰写了一篇非常彻底的分析文章，探讨了可用的库。如果你想要了解更多，我强烈推荐这篇文章（[https://dev.to/craigmorten/what-is-the-best-deno-web-framework-2k69](https://dev.to/craigmorten/what-is-the-best-deno-web-framework-2k69)）。
- en: We will try to be diverse when it comes to the packages we're going to explore.
    There are some that provide more abstractions and structure than others, and some
    that provide not much more than mere utility functions and composable functionality.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试在我们将要探索的包中保持多样性。有些包提供了比其他包更多的抽象和结构，而有些包提供的功能并不多于纯粹的实用函数和可组合的功能。
- en: 'The packages we''ll explore are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索的包如下：
- en: Drash
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drash
- en: Servest
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servest
- en: Oak
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oak
- en: Alosaur
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alosaur
- en: Let's look at each one separately.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看。
- en: Drash
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Drash
- en: Drash ([https://github.com/drashland/deno-drash](https://github.com/drashland/deno-drash))
    aims to be different from the existing Deno and Node.js frameworks. This motivation
    is explicitly mentioned by its maintainer, Edward Bebbington, on a blog post where
    he compares Drash to other alternatives and explains the motivations behind its
    creation ([https://dev.to/drash_land/what-makes-drash-different-idd](https://dev.to/drash_land/what-makes-drash-different-idd)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Drash ([https://github.com/drashland/deno-drash](https://github.com/drashland/deno-drash))旨在与现有的Deno和Node.js框架不同。这一动机在其维护者Edward
    Bebbington的一篇博客文章中明确提到，他比较了Drash与其他替代方案，并解释了其创建的动机 ([https://dev.to/drash_land/what-makes-drash-different-idd](https://dev.to/drash_land/what-makes-drash-different-idd)).
- en: These motivations are great, and the inspiration of very popular software tools
    such as Laravel, Flask, and Tonic justifies most of these decisions. Some of the
    similarities are also noticeable the moment you look at Drash's code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动机很好，而且像Laravel、Flask和Tonic这样非常流行的软件工具的启发证明了许多这些决定是合理的。你一查看Drash的代码，就能发现一些相似之处。
- en: 'It really offers a different approach compared to libraries such as Express.js
    or Koa, as the documentation states:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与Express.js或Koa等库相比，它确实提供了一种不同的方法，正如文档所述：
- en: '"Where Deno is different than Node.js, Drash aims to be different than Express
    or Koa, utilizing resources and a full class-based system."'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “Deno与Node.js的不同之处在于，Drash旨在与Express或Koa不同，利用资源和一个完整的基于类的系统。”
- en: 'The main differences are that Drash doesn''t want to provide an application
    object where developers can then register their endpoints, like some popular Node.js
    frameworks do. It sees endpoints as resources that are defined within a class,
    similar to the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于，Drash不想提供应用程序对象，让开发者可以在其中注册他们的端点，就像一些流行的Node.js框架一样。它将端点视为在类内部定义的资源，类似于以下内容：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These resources are then plugged into Drash''s application later:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源随后被插入到Drash的应用程序中：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we can directly state it is, in fact, different from the other frameworks
    we've mentioned. These differences are deliberate and plan to please developers
    that are fans of this approach and the problems it solves for other frameworks.
    Those use cases are very well-explained in Drash's documentation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以直接声明，它实际上与我们在前面提到的其他框架不同。这些差异是有意的，旨在满足喜欢这种方法及其为其他框架解决问题的开发者。这些用例在Drash的文档中有很好的解释。
- en: Drash's resource-based approach is definitely something to keep an eye on. Its
    inspiration from very mature pieces of software such as Flask and Tonic definitely
    brings something to the table and proposes a solution that helps solve some of
    the common problems unopinionated tools have. The documentation is complete and
    easy to understand, which makes it a great asset to have when it comes to choosing
    a tool for building your application with.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Drash基于资源的的方法确实值得关注。它从非常成熟的软件（如Flask和Tonic）中汲取灵感，确实为桌面上带来了一些东西，并提出了一种解决方案，有助于解决一些无观点工具的常见问题。文档完整且易于理解，这使得在选择构建应用程序的工具时，它成为了一个宝贵的资产。
- en: Servest
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Servest
- en: Servest ([https://servestjs.org/](https://servestjs.org/)) calls itself a *"progressive
    HTTP server for Deno."*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Servest ([https://servestjs.org/](https://servestjs.org/))自称是一个*"适用于Deno的渐进式HTTP服务器。"*
- en: One of the reasons it was created was because its author wanted to make some
    APIs from the standard library's HTTP module easier to use and experiment with
    new features. The latter is something that is really hard to do on a standard
    library that needs stability.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它被创建的一个原因是因为其作者想要使标准库的HTTP模块中的一些API更容易使用，并实验新功能。后者是在需要稳定性的标准库上真正难以实现的。
- en: Servest directly focuses on this comparison with the standard library's HTTP
    module. One of its main objectives, which is directly stated on the project's
    home page, is making it easy to migrate from the standard library's HTTP module
    to Servest. This summarizes Servest's vision well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Servest直接关注与标准库的HTTP模块的比较。其主要目标之一是在项目的主页上直接声明，即使其易于从标准库的HTTP模块迁移到Servest。这很好地总结了Servest的愿景。
- en: 'API-wise, Servest is very similar to what we''re used to from Express.js and
    Koa. It provides an application object where routes can be registered. You can
    also recognize obvious influences from what is provided by the standard library
    module, as we can see in the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从API的角度来看，Servest与我们从Express.js和Koa熟悉的东西非常相似。它提供了一个应用程序对象，可以在其中注册路由。你也可以看到以下代码片段中明显受到了标准库模块提供的内容的启发：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can recognize the application object from well-known Node.js libraries and
    the request object from the standard library, among other things.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别出来自知名Node.js库的应用程序对象和来自标准库的请求对象等功能。
- en: On top of this functionality, Servest also provides common features, such as
    support for directly rendering JSX pages, serving static files, and authentication.
    The documentation is also clear and full of examples.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些功能之上，Servest还提供了诸如直接渲染JSX页面、提供静态文件和身份验证等常见功能。文档也非常清晰，充满了示例。
- en: Servest tries to leverage knowledge and familiarity from Node.js users while
    using the benefits provided by Deno in a promising mix. Its progressive nature
    brings very nice features to the table, with the promise to make developers more
    productive than when they're using the standard library HTTP package.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Servest试图利用Node.js用户的知识和熟悉度，同时利用Deno提供的优势，这是一个很有前途的混合。它逐渐发展的特性为开发人员提供了非常好的功能，承诺会使开发人员比使用标准库HTTP包时更加高效。
- en: Oak
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oak
- en: Oak ([https://oakserver.github.io/oak/](https://oakserver.github.io/oak/)) is
    currently the most popular Deno library when it comes to creating web applications.
    Its name derives from a play on words of Koa, a very popular Node.js middleware
    framework and Oak's main inspiration.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Oak ([https://oakserver.github.io/oak/](https://oakserver.github.io/oak/)) 目前是创建网络应用程序最受欢迎的Deno库。它的名字来源于Koa的词语游戏，Koa是一个非常流行的Node.js中间件框架，也是Oak的主要灵感来源。
- en: Due to its heavy inspirations, it is of no surprise that its APIs resemble Koa
    by using asynchronous functions and a context object. Oak also includes a router,
    also inspired by `@koa/router`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其深受启发，其API与Koa相似，使用异步函数和上下文对象也就不足为奇了。Oak还包括一个路由器，也是受 `@koa/router` 启发的。
- en: 'If you know Koa, the following code might look very familiar to you:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道Koa，下面的代码对你来说可能非常熟悉：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For those of you who are not familiar with Koa, we'll explain it in brief, since
    understanding it will help you understand Oak.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉Koa的你们，我们将简要解释一下，因为理解它将帮助你理解Oak。
- en: Koa provides a minimal and unopinionated approach by using modern JavaScript
    features. One of the initial reasons Koa was created (by the same team who created
    Express.js) was that its creator wanted to create a framework that would leverage
    modern JavaScript features, as opposed to Express, which was created at the beginning
    of Node.js' lifetime.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Koa通过使用现代JavaScript特性提供了一个最小化和不带偏见的的方法。Koa最初被创建（由创建Express.js的同一团队）的原因之一是，其创建者想要创建一个利用现代JavaScript特性的框架，而不是像Express那样，在Node.js的早期就被创建。
- en: The team wanted to use new features such as promises and async/await, and then
    solve challenges that developers faced with Express.JS. Most of these challenges
    were related to error handling, dealing with callbacks, and the lack of clarity
    of some APIs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 团队希望使用诸如promises和async/await等新特性，然后解决开发者在使用Express.JS时面临的挑战。这些挑战大多数与错误处理、处理回调和某些API的缺乏清晰性有关。
- en: Oak's popularity doesn't come out of nowhere, and its current distance from
    the alternatives in terms of GitHub stars reflects that. By themselves, GitHub
    stars don't mean much, but together with opened and closed issues, the number
    of releases, and so on, we can see why people are trusting it. Of course, this
    familiarity plays a big role in terms of this package's popularity.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Oak的流行并非空穴来风，它在GitHub上的星级与其他替代方案的距离反映了这一点。单凭GitHub的星级并不能说明什么，但是结合打开和关闭的问题、发布的版本等等，我们可以看出人们为什么信任它。当然，这种熟悉在很大程度上影响了这个包的流行度。
- en: In its current state, Oak is a solid (in terms of Deno's community standards)
    way to build web applications as it provides a very clear and direct set of features.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，Oak是一个坚实的（就Deno社区标准而言）构建网络应用程序的方式，因为它提供了一组非常清晰和直接的功能。
- en: Alosaur
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Alosaur
- en: Alosaur ([https://github.com/alosaur/alosaur](https://github.com/alosaur/alosaur))
    is a Deno web application framework based on decorators and classes. It is similar
    to Drash in a way, even though the final approaches are quite different.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Alosaur（[https://github.com/alosaur/alosaur](https://github.com/alosaur/alosaur)）是一个基于装饰器和类的Deno网络应用程序框架。它在某种程度上与Drash相似，尽管最终的方法有很大不同。
- en: Among its main features, Alosaur provides things such as template rendering,
    dependency injection, and OpenAPI support. These features have been added on top
    of what is a standard for all the alternatives we presented here, such as middleware
    support and routing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其主要特性之一，Aloaur提供诸如模板渲染、依赖注入和OpenAPI支持等功能。这些功能是在所有我们在这里介绍的替代方案的标准之上添加的，例如中间件支持和路由。
- en: 'This framework''s approach is to define controllers by using classes and define
    their behavior using decorators, as shown in the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架的方法是使用类定义控制器，并使用装饰器定义其行为，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we can see that the application's instantiation has similarities with
    Drash. It also uses TypeScript decorators to declare a framework's behavior.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到应用程序的实例化与Drash有相似之处。它还使用TypeScript装饰器来声明框架的行为。
- en: Alosaur takes a different approach compared to most of the aforementioned libraries,
    mainly because it doesn't try to be minimal. Instead, it provides a set of features
    that prove to be useful when it comes to building certain types of applications.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Alosaur与前面提到的大多数库相比采取了不同的方法，主要是因为它不试图简约。相反，它提供了一组在构建某些类型的应用程序时证明有用的特性。
- en: We decided to have a look at it not only because it does what it is supposed
    to do, but also because it has some features that are not so common in the Node.js
    and Deno world. This includes things such as dependency injection and OpenAPI
    support, which are not offered by any other of the presented solutions. At the
    same time, it keeps features such as template rendering, which is something that
    might be familiar to you from Express.JS but not so familiar in more modern frameworks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定看看它，不仅是因为它能做到它应该做的事情，而且还因为它在Node.js和Deno世界中有一些不常见的特性。这包括像依赖注入和OpenAPI支持这样的东西，这是其他展示的解决方案所没有提供的。同时，它保持了如模板渲染之类的特性，这可能是您从Express.JS熟悉的东西，但在更现代的框架中可能不那么熟悉。
- en: The final solution is very promising and complete in the sense of the functionalities
    it provides. It is definitely something to keep an eye on so that you can see
    how it evolves.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的解决方案在提供的功能方面非常有前途且完整。这绝对是值得关注的东西，这样你可以看到它是如何发展的。
- en: The verdict
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终判决
- en: After looking at all the presented solutions and recognizing that all of them
    have their merits, we've decided to go with Oak for the rest of this book.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了所有展示的解决方案并认识到它们都有自己的优点之后，我们决定在本书的剩余部分使用Oak。
- en: This doesn't mean that this book will focus on Oak. It will not, as it will
    only handle HTTP and routing. Oak's minimal approach will fit very nicely with
    what we will be doing next, helping us to incrementally create features without
    it getting in the way. The fact that it is also one of the most stable, maintained,
    and popular options in the Deno community has an obvious influence on our decision.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着本书将重点介绍Oak。不会的，因为它只会处理HTTP和路由。Oak的简约方法将与我们接下来要做的很多事情非常契合，帮助我们逐步创建功能而不会妨碍我们。它也是Deno社区中最稳定、维护得最好、最受欢迎的选项之一，这对我们的决定有明显的影响。
- en: Be aware that this decision doesn't mean that what we will learn in the next
    few chapters can't be done in any of the alternatives. In fact, because of the
    way we will organize our code and architecture, we believe that it would be easy
    to keep up with most of the things we are going to do using a different framework.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个决定并不意味着我们将在接下来的几章中学到的内容不能在任何替代方案中完成。事实上，由于我们将如何组织和架构我们的代码，我们相信很容易使用不同的框架来完成我们将要做的绝大多数事情。
- en: Throughout the rest of this book, we will use other third-party modules that
    can help us build the functionalities we've proposed. The reason we've decided
    to have a deeper look at the libraries that deal with HTTP is because this is
    the fundamental delivery mechanism for the application we'll be developing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将使用其他第三方模块来帮助我们构建我们提出的功能。我们决定深入研究处理HTTP的库的原因是因为这是我们即将开发的应用程序的基本交付机制。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we finally started building an application that leverages our
    knowledge of Deno. We started by considering the main goals we will have when
    we build an application and define its architecture. These goals will set the
    tone for most of our conversations regarding architecture and structure throughout
    this book as we'll keep going back to them, ensuring that we're in line with them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于开始构建一个利用我们对Deno知识的应用程序。我们首先考虑了构建应用程序时我们将拥有的主要目标以及定义其架构。这些目标将为我们本书中关于架构和结构的绝大多数对话定下基调，因为我们将会不断回顾它们，确保我们的工作与它们保持一致。
- en: 'We started by creating our folder structure and trying to achieve our very
    first application goal: have an HTTP endpoint that lists museums. We did this
    by building the simple business logic first and progressed while needs such as
    separation of concerns and isolation and responsibilities arose. These needs derived
    our architecture, proving why the layers and abstractions we created are useful
    and demonstrating what they add.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了我们的文件夹结构，并试图实现我们第一个应用程序目标：拥有一个列出博物馆的HTTP端点。我们首先构建了简单的业务逻辑，并在需要关注分离和隔离以及职责时逐步推进。这些需求引导了我们的架构，证明了我们所创建的层次和抽象的有用性，并展示了它们所提供的价值。
- en: 'By having the responsibilities and the module''s interfaces well-defined, we
    understood that we could temporarily build our application by using an in-memory
    database, which we did. It was possible to build the application to fit this chapter''s
    requirement with that, and layer separation allows us to come back later and change
    it to a proper persistency layer without any issues. After defining the business
    and data accessing logic, we created a web server with the standard library that
    worked as a delivery mechanism. After creating a very rudimentary routing system,
    we plugged in the business logic we built previously and satisfied the main requirement
    for this chapter: having an application that returns a list of museums.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明确职责和模块接口，我们了解到我们可以暂时使用内存数据库来构建我们的应用程序，我们也确实这样做了。借助这种分离层次结构的方法，我们可以稍后回来将其更改为合适的持久性层而不会遇到任何问题。在定义业务和数据访问逻辑之后，我们使用标准库创建了一个web服务器作为交付机制。在创建了一个非常简单的路由系统之后，我们插入了之前构建的业务逻辑，满足了本章的主要要求：拥有一个返回博物馆列表的应用程序。
- en: We did all of this without creating a direct coupling between the business logic,
    the data fetching, and the delivery layers. This is something we believe will
    be very useful as we start adding complexity, extending our application, and adding
    tests to it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工作都没有在业务逻辑、数据获取和交付层之间创建直接耦合。我们认为这在开始增加复杂性、扩展我们的应用程序并为其添加测试时会非常有用。
- en: This chapter wraps up by having a look at the HTTP frameworks and libraries
    that currently exist in the Deno community and understanding their differences
    and approaches. Some of them use approaches that are familiar to Node.js users,
    while others deeply use TypeScript and its features to create a more structured
    web application. By looking at the four currently available solutions, we learned
    what is being developed in the community and the directions they might go in.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过查看Deno社区目前存在的HTTP框架和库以及它们之间的差异和做法来结束。其中一些使用对Node.js用户熟悉的做法，而其他则深入使用TypeScript及其特性来创建更具结构的web应用程序。通过查看目前可用的四个解决方案，我们了解了社区正在开发的内容以及他们可能采取的方向。
- en: We ended up choosing Oak, a very minimal and reasonably mature solution, to
    help us solve the routing and HTTP challenges we'll come across in the rest of
    this book.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终选择了Oak，这是一个非常简洁且相对成熟解决方案，以帮助解决本书后续内容中我们将遇到的路由和HTTP挑战。
- en: In the next chapter, we'll start adding Oak to our code base, together with
    useful features such as authentication and authorization, using concepts such
    as middleware, and growing our application so that it achieves the goals we set
    ourselves up to complete.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始将Oak添加到我们的代码库中，并使用诸如身份验证和授权等有用功能，使用诸如中间件等概念，并使我们的应用程序增长，以实现我们为自己设定的目标。
- en: Let's go!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
