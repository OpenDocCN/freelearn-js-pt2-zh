- en: Chapter 1. Diving into the JavaScript Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 深入JavaScript核心
- en: 'You may have owned an iPhone for years and regard yourself as an experienced
    user. At the same time, you keep removing unwanted characters one at a time while
    typing by pressing delete. However, one day you find out that a quick shake allows
    you to delete the whole message in one tap. Then you wonder why on earth you didn''t
    know this earlier. The same thing happens with programming. We can be quite satisfied
    with our coding until, all of sudden, we run into a trick or a lesser-known language
    feature that makes us reconsider the entire work done over the years. It turns
    out that we could do this in a cleaner, more readable, more testable, and more
    maintainable way. So it''s presumed that you already have experience with JavaScript;
    however, this chapter equips you with the best practices to improve your code.
    We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能用了几年的iPhone，自认为是个有经验的用户。同时，你在打字时按删除键逐个删除不需要的字符。然而，有一天你发现只需快速摇晃就能一次性删除整条信息。然后你可能会想为什么之前不知道这个技巧。编程也是一样。我们可能会对自己的代码相当满意，直到突然间遇到一个技巧或不太知名的语法特性，让我们重新考虑过去几年所做的全部工作。结果是我们本可以用更简洁、更可读、更可测试、更易维护的方式完成这些工作。所以假设你已经有一定的JavaScript经验；然而，这一章将为你提供改进代码的最佳实践。我们将涵盖以下主题：
- en: Making your code readable and expressive
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的代码可读且具有表现力
- en: Mastering multiline strings in JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握JavaScript中的多行字符串
- en: Manipulating arrays in the ES5 way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以ES5的方式操作数组
- en: Traversing an object in an elegant, reliable, safe, and fast way
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一种优雅、可靠、安全和快速的方式遍历对象
- en: The most effective way of declaring objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明对象的最有效方式
- en: How to magic methods in JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解JavaScript中的魔法方法
- en: Make your code readable and expressive
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让你的代码可读且具有表现力
- en: There are numerous practices and heuristics to make a code more readable, expressive,
    and clean. We will cover this topic later on, but here we will talk about syntactic
    sugar. The term means an alternative syntax that makes the code more expressive
    and readable. In fact, we already had some of this in JavaScript from the very
    beginning. For instance, the increment/decrement and addition/subtraction assignment
    operators inherited from C. *foo++* is syntactic sugar for *foo = foo + 1*, and
    *foo += bar* is a shorter form for *foo = foo + bar*. Besides, we have a few tricks
    that serve the same purpose.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多实践和启发式方法可以使代码更具可读性、表现力和整洁性。我们稍后讨论这个话题，但在这里我们谈谈语法糖。这个术语意味着一种替代语法，使代码更具表现力和可读性。实际上，我们从一开始就有一些这样的东西在JavaScript中。例如，自增/自减和加法/减法赋值运算符继承自C语言。`*foo++*`是`*foo
    = foo + 1*`的语法糖，`*foo += bar*`是`*foo = foo + bar*`的简写形式。此外，还有一些同样的目的的小技巧。
- en: JavaScript applies logical expressions to so-called **short-circuit** evaluation.
    This means that an expression is read left to right, but as soon as the condition
    result is determined at an early stage, the expression tail is not evaluated.
    If we have *true || false || false*, the interpreter will know from the first
    test that the result is true regardless of other tests. So the *false || false*
    part is not evaluated, and this opens a way for creativity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对所谓的**短路**表达式应用逻辑运算。这意味着表达式是从左到右阅读的，但一旦在早期阶段确定了条件结果，表达式的尾部就不会被评估。如果我们有`true
    || false || false`，解释器会从第一个测试中知道结果无论如何都是`true`。所以`false || false`部分不会被评估，这就为创意开启了道路。
- en: Function argument default value
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数默认值
- en: 'When we need to specify default values for parameters we can do like that:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要为参数指定默认值时，可以这样操作：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is going on here? When `foo` is `true` (`not undefined`, `NaN`, `null`,
    `false`, `0`, or `""`), the result of the logical expression is `foo` otherwise
    the expression is evaluated until `Default value` and this is the final result.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？当`foo`是`true`（`not undefined`、`NaN`、`null`、`false`、`0`或`""`）时，逻辑表达式的结果就是`foo`，否则会评估到`Default
    value`，这就是最终结果。
- en: 'Starting with 6th edition of EcmaScript (specification of JavaScript language)
    we can use nicer syntax:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从ECMAScript的第六版（JavaScript语言的规格）开始，我们可以使用更优美的语法：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Conditional invocation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件调用
- en: While composing our code we shorten it on conditions:"
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，根据条件缩短它：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we used the AND (`&&`) operator to invoke `console.log`
    if the left-hand condition is Truthy. The OR (`||`) operator does the opposite,
    it calls `console.log` if the condition is `Falsy`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们使用AND（`&&`）操作符在左条件为真时调用`console.log`。OR（`||`）操作符相反，如果条件为`假`，则调用`console.log`。
- en: 'I think the most common case in practice is the shorthand condition where the
    function is called only when it is provided:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为实践中最常见的情况是简写条件，只有在提供时函数才被调用：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is one more example on this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在此的一个更多示例：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Syntactic sugar was introduced to its full extent to the JavaScript world only
    with the advance in CoffeeScript, a subset of the language that trans-compiles
    (compiles source-to-source) into JavaScript. Actually CoffeeScript, inspired by
    Ruby, Python, and Haskell, has unlocked arrow-functions, spreads, and other syntax
    to JavaScript developers. In 2011, Brendan Eich (the author of JavaScript) admitted
    that CoffeeScript influenced him in his work on EcmaScript Harmony, which was
    finalized this summer in ECMA-262 6th edition specification. From a marketing
    perspective, the specification writers agreed on using a new name convention that
    calls the 6th edition as EcmaScript 2015 and the 7th edition as EcmaScript 2016\.
    Yet the community is used to abbreviations such as ES6 and ES7\. To avoid confusion
    further in the book, we will refer to the specifications by these names. Now we
    can look at how this affects the new JavaScript.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 语法糖直到CoffeeScript的进步才完全进入JavaScript世界，CoffeeScript是这种语言的一个子集，它源码编译（源码到源码编译）为JavaScript。实际上，受Ruby，Python和Haskell启发的CoffeeScript为JavaScript开发者解锁了箭头函数，展开和其他语法。2011年，Brendan
    Eich（JavaScript的作者）承认CoffeeScript影响了他的EcmaScript Harmony的工作，该工作在今年夏天的ECMA-262
    6th edition specification中最终完成。从市场营销的角度来看，规格编写者同意使用新的命名约定，将第6版称为EcmaScript 2015，第7版称为EcmaScript
    2016。然而，社区已经习惯了缩写如ES6和ES7。为了进一步避免混淆，在本书中，我们将用这些名称来指代规格。现在我们可以看看这对新的JavaScript有什么影响。
- en: Arrow functions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Traditional function expression may look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的函数表达式可能如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When declaring an expression using the arrow function (aka fat arrow function)
    syntax, we will have this in a less verbose form, as shown in the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用箭头函数（也称为胖箭头函数）语法声明表达式时，我们将以更简洁的形式拥有这个this，如下所示：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In my opinion, we don''t gain much with this. But if we need, let''s say, an
    array method callback, the traditional form would be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这样做我们并没有得到太多。但是如果我们需要，比如说，一个数组方法的回调，传统形式如下：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now the equivalent arrow function becomes shorter, as shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在等效的箭头函数变得更短了，如下所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We may do filtering in an array this way:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能这样在数组中进行过滤：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using an array function, we can do filtering in a cleaner form:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组函数，我们可以以更简洁的形式进行过滤：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Besides shorter function declaration syntax, the arrow functions bring the
    so called lexical `this`. Instead of creating its own context, it uses the context
    of the surrounding object as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更短的方法声明语法外，箭头函数还带来了所谓的词法`this`。而不是创建自己的上下文，它使用周围对象的上下文，如下所示：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, we subscribed a handler function to a DOM event (`click`).
    Within the scope of the handler, we still have access to the view context (`this`),
    so we don''t need to bind the handler to the outer scope or pass it as a variable
    through the closure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们为DOM事件（`click`）订阅了一个处理函数。在处理器的范围内，我们仍然可以访问视图上下文（`this`），因此我们不需要将处理函数绑定到外部作用域或通过闭包作为变量传递：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Method definitions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法定义
- en: 'As mentioned in the preceding section, arrow functions can be quite handy when
    declaring small inline callbacks, but always applying it for a shorter syntax
    is controversial. However, ES6 provides new alternative method definition syntax
    besides the arrow functions. The old-school method declaration may look as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一部分所述，当声明小型的内联回调函数时，箭头函数非常方便，但总是为了更短的语法而使用它是有争议的。然而，ES6除了箭头函数之外，还提供了新的替代方法定义语法。老式的方法声明可能如下所示：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In ES6 we can get rid of the function keyword and the colon. So the preceding
    code can be put this way:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，我们可以摆脱函数关键字和冒号。所以前一条代码可以这样做：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The rest operator
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剩余操作符
- en: Another syntax structure that was borrowed from CoffeeScript came to JavaScript
    as the rest operator (albeit, the approach is called *splats* in CoffeeScript).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种从CoffeeScript借用的语法结构作为剩余操作符（尽管在CoffeeScript中，这种方法被称为*splats*）来到了JavaScript。
- en: 'When we had a few mandatory function parameters and an unknown number of rest
    parameters, we used to do something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有几个必需的函数参数和一个未知数量的剩余参数时，我们通常会这样做：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now check out how expressive this code becomes in ES6:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这段代码在ES6中变得多么有表现力：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Function parameters aren''t the only application of the rest operator. For
    example, we can use it in destructions as well, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数不是剩余操作符的唯一应用。例如，我们也可以在解构中使用它，如下所示：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The spread operator
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展开操作符
- en: 'Similarly, we can spread array elements into arguments:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以将数组元素展开为参数：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ES6 also provides expressive syntactic sugar for object creation and inheritance,
    but we will examine this later in *The most effective way of declaring objects*
    section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ES6还提供了创建对象和继承的有表现力的语法糖，但我们将稍后在*声明对象的最有效方式*部分中 examine this。
- en: Mastering multiline strings in JavaScript
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握JavaScript中的多行字符串
- en: 'Multi-line strings aren''t a good part of JavaScript. While they are easy to
    declare in other languages (for instance, NOWDOC), you cannot just keep single-quoted
    or double-quoted strings in multiple lines. This will lead to syntax error as
    every line in JavaScript is considered as a possible command. You can set backslashes
    to show your intention:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 多行字符串不是JavaScript的一个好部分。虽然它们在其他语言中很容易声明（例如，NOWDOC），但你不能只是将单引号或双引号的字符串保持在多行中。这会导致语法错误，因为JavaScript中的每一行都被认为是可能的命令。你可以用反斜杠来表示你的意图：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This kind of works. However, as soon as you miss a trailing space, you get a
    syntax error, which is not easy to spot. While most script agents support this
    syntax, it's, however, not a part of the EcmaScript specification.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法基本有效。然而，一旦你漏掉了一个尾随空格，你就会得到一个语法错误，这不容易被发现。虽然大多数脚本代理支持这种语法，但它并不是EcmaScript规范的一部分。
- en: 'In the times of **EcmaScript for XML** (**E4X**), we could assign a pure XML
    to a string, which opened a way for declarations such as these:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EcmaScript for XML**（**E4X**）的时代，我们可以将纯XML赋值给一个字符串，这为这些声明打开了一条道路：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Nowadays E4X is deprecated, it's not supported anymore.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在E4X已经被弃用，不再被支持。
- en: Concatenation versus array join
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接与数组连接
- en: 'We can also use string concatenation. It may feel clumsy, but it''s safe:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字符串连接。它可能感觉笨拙，但它是安全的：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You may be surprised, but concatenation is slower than array joining. So the
    following technique will work faster:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会感到惊讶，但字符串连接比数组连接慢。所以以下技术会更快地工作：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Template literal
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板字面量
- en: 'What about ES6? The latest EcmaScript specification introduces a new sort of
    string literal, template literal:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么ES6呢？最新的EcmaScript规范引入了一种新的字符串字面量，模板字面量：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now the syntax looks elegant. But there is more. Template literals really remind
    us of NOWDOC. You can refer any variable declared in the scope within the string:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个语法看起来很优雅。但还有更多。模板字面量真的让我们想起了NOWDOC。你可以在字符串中引用作用域内声明的任何变量：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you wonder when can you safely use this syntax, I have a good news for you—this
    feature is already supported by (almost) all the major script agents ([http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道何时可以安全地使用这种语法，我有一个好消息告诉你——这个特性已经得到了（几乎）所有主要脚本代理的支持（[http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)）。
- en: Multi-line strings via transpilers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过转译器实现多行字符串
- en: 'With the advance of ReactJS, Facebook''s EcmaScript language extension named
    JSX ([https://facebook.github.io/jsx/](https://facebook.github.io/jsx/)) is now
    really gaining momentum. Apparently influenced by previously mentioned E4X, they
    proposed a kind of string literal for XML-like content without any screening at
    all. This type supports template interpolation similar to ES6 templates:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着ReactJS的发展，Facebook的EcmaScript语言扩展JSX（[https://facebook.github.io/jsx/](https://facebook.github.io/jsx/)）现在已经真正获得了动力。显然受到之前提到的E4X的影响，他们提出了一种没有任何筛选的XML样内容的字符串字面量。这种类型支持类似于ES6模板的模板插值：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another way to declare multiline strings is by using CommonJS Compiler ([http://dsheiko.github.io/cjsc/](http://dsheiko.github.io/cjsc/)).
    While resolving the ''require'' dependencies, the compiler transforms any content
    that is not `.js`/`.json` content into a single-line string:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种声明多行字符串的方法是使用CommonJS编译器（[http://dsheiko.github.io/cjsc/](http://dsheiko.github.io/cjsc/)）。在解析'require'依赖关系时，编译器将任何非`.js`/`.json`内容转换为单行字符串：
- en: '**foo.txt**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo.txt**'
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**consumer.js**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**consumer.js**'
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can find an example of JSX use in [Chapter 6](part0042_split_000.html#181NK2-f4ff6b81796e4f78aa983a623fb95daf
    "Chapter 6. A Large-Scale JavaScript Application Architecture"), *A Large-Scale
    JavaScript Application Architecture*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第6章](part0042_split_000.html#181NK2-f4ff6b81796e4f78aa983a623fb95daf "Chapter 6. A
    Large-Scale JavaScript Application Architecture")中找到JSX使用的示例，*大规模JavaScript应用程序架构*。
- en: Manipulating arrays in the ES5 way
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以ES5方式操作数组
- en: Some years ago when the support of ES5 features was poor (EcmaScript 5th edition
    was finalized in 2009), libraries such as Underscore and Lo-Dash got highly popular
    as they provided a comprehensive set of utilities to deal with arrays/collections.
    Today, many developers still use third-party libraries (including jQuery/Zepro)
    for methods such as `map`, `filter`, `every`, `some`, `reduce`, and `indexOf`,
    while these are available in the native form of JavaScript. It still depends on
    how you use such libraries, but it may likely happen that you don't need them
    anymore. Let's see what we have now in JavaScript.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，当ES5特性的支持较差（ECMAScript第五版于2009年最终确定）时，像Underscore和Lo-Dash这样的库变得非常流行，因为它们提供了一套全面的工具来处理数组/集合。今天，许多开发者仍然使用第三方库（包括jQuery/Zepro）来处理诸如`map`、`filter`、`every`、`some`、`reduce`和`indexOf`等方法，而这些方法在JavaScript的本地形式中是可用的。是否需要这些库还取决于您的使用方式，但很可能您不再需要它们。让我们看看现在JavaScript中有什么。
- en: Array methods in ES5
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES5中的数组方法
- en: '`Array.prototype.forEach` is probably the most used method of the arrays. That
    is, it is the native implementation of `_.each`, or for example, of the `$.each`
    utilities. As parameters, `forEach` expects an `iteratee` callback function and
    optionally a context in which you want to execute the callback. It passes to the
    callback function an element value, an index, and the entire array. The same parameter
    syntax is used for most array manipulation methods. Note that jQuery''s `$.each`
    has the inverted callback parameters order:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.forEach`可能是数组中最常用的方法。也就是说，它是`_.each`的本地实现，或者是例如`$.each`实用程序的实现。作为参数，`forEach`期望一个`iteratee`回调函数，可选的是您希望执行回调的上下文。它将元素值、索引和整个数组传递给回调函数。大多数数组操作方法都使用相同的参数语法。注意jQuery的`$.each`将回调参数顺序颠倒：'
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`Array.prototype.map` produces a new array by transforming the elements of
    a given array:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.map`通过转换给定数组的元素来生成一个新的数组：'
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Array.prototype.filter` returns an array, which consists of given array values
    that meet the callback''s condition:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.filter`返回一个数组，该数组由满足回调条件的给定数组值组成：'
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`Array.prototype.reduce`/`Array.prototype.reduceRight` retrieves the product
    of values in an array. The method expects a callback function and optionally the
    initial value as arguments. The callback function receive four parameters: the
    accumulative value, current one, index and original array. So we can, for an instance,
    increment the accumulative value by the current one (return acc += cur;) and,
    thus, we will get the sum of array values.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.reduce`/`Array.prototype.reduceRight`检索数组中值的产品。该方法期望一个回调函数和可选的初始值作为参数。回调函数接收四个参数：累积值、当前值、索引和原始数组。因此，我们可以通过当前值增加累积值（返回acc
    += cur;）来实例化，从而得到数组值的和。'
- en: 'Besides calculating with these methods, we can concatenate string values or
    arrays:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用这些方法进行计算外，我们还可以连接字符串值或数组：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Array.prototype.some` tests whether any (or some) values of a given array
    meet the callback condition:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.some`测试给定数组中的任何一个（或一些）值是否满足回调条件：'
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we checked whether any of the bar array values are available
    in the `foo` array. For testability, we need to pass a reference of the `foo`
    array into the callback. Here we inject it as context. If we need to pass more
    references, we would push them in a key-value object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们检查`foo`数组中是否有任何一个柱状数组值是可用的。为了可测试性，我们需要将`foo`数组的引用传递给回调函数。这里我们将其作为上下文注入。如果我们需要传递更多的引用，我们会将它们推入一个键值对象中。
- en: As you probably noticed, we used in this example `Array.prototype.indexOf`.
    The method works the same as `String.prototype.indexOf`. This returns an index
    of the match found or `-1`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能注意到的，在这个例子中我们使用了`Array.prototype.indexOf`。这个方法的工作方式与`String.prototype.indexOf`相同。如果找到匹配项，则返回匹配项的索引，否则返回-1。
- en: '`Array.prototype.every` tests whether every value of a given array meets the
    callback condition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.every`测试给定数组的每一个值是否满足回调条件：'
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you are still concerned about support for these methods in a legacy browser
    as old as IE6-7, you can simply shim them with [https://github.com/es-shims/es5-shim](https://github.com/es-shims/es5-shim).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然关心这些方法在像 IE6-7 这样老旧的浏览器中的支持情况，你可以简单地使用 [https://github.com/es-shims/es5-shim](https://github.com/es-shims/es5-shim)
    来补丁它们。
- en: Array methods in ES6
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: es6 中的数组方法
- en: In ES6, we get just a few new methods that look rather like shortcuts over the
    existing functionality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，我们只获得了一些看起来像是现有功能快捷方式的新方法。
- en: '`Array.prototype.fill` populates an array with a given value, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.fill` 用给定值填充数组，如下所示：'
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`Array.prototype.includes` explicitly checks whether a given value exists in
    the array. Well, it is the same as `arr.indexOf( val ) !== -1`, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.includes` 明确检查给定值是否存在于数组中。嗯，它和 `arr.indexOf( val ) !== -1`
    是一样的，如下所示：'
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Array.prototype.find` filters out a single value matching the callback condition.
    Again, it''s what we can get with `Array.prototype.filter`. The only difference
    is that the filter method returns either an array or a null value. In this case,
    this returns a single element array, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.find` 过滤出符合回调条件的单个值。再次说明，这和 `Array.prototype.filter` 能获得的是一样的。唯一的区别是
    filter 方法返回一个数组或者一个 null 值。在这种情况下，它返回一个包含单个元素的数组，如下所示：'
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Traversing an object in an elegant, reliable, safe, and fast way
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优雅、可靠、安全、快速地遍历对象
- en: 'It is a common case when we have a key-value object (let''s say options) and
    need to iterate it. There is an academic way to do this, as shown in the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个键值对象（比如说选项）并且需要遍历它时，这是一个常见的情况。下面代码中展示了一种学术上的做法：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code outputs the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出如下：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now let''s imagine that any of the third-party libraries that you load in the
    document augments the built-in `Object`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下，你文档中加载的任何第三方库都增强了内置的 `Object`：
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now when we run our example code, we will get an extra undesired entry:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行我们的示例代码时，我们将得到一个额外的不需要的条目：
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The solution to this problem is well known, we have to test the keys with the
    `Object.prototype.hasOwnProperty` method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题解决方案是众所周知的，我们必须使用 `Object.prototype.hasOwnProperty` 方法测试键：
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Iterating the key-value object safely and fast
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全快速地遍历键值对象
- en: 'Let''s face the truth—the structure is clumsy and requires optimization (we
    have to perform the `hasOwnProperty` test on every given key). Luckily, JavaScript
    has the `Object.keys` method that retrieves all string-valued keys of all enumerable
    own (non-inherited) properties. This gives us the desired keys as an array that
    we can iterate, for instance, with `Array.prototype.forEach`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实吧——这个结构是笨拙的，需要优化（我们必须对每个给定的键执行 `hasOwnProperty` 测试）。幸运的是，JavaScript 有
    `Object.keys` 方法，它可以获取所有枚举的自身（非继承）属性的字符串值。这让我们得到了一个数组，里面是我们期望的键，我们可以用 `Array.prototype.forEach`
    等方式进行迭代：
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Besides the elegance, we get a better performance this way. In order to see
    how much we gain, you can run this online test in distinct browsers such as: [http://codepen.io/dsheiko/pen/JdrqXa](http://codepen.io/dsheiko/pen/JdrqXa).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优雅，我们这种方式还能得到更好的性能。为了看看我们获得了多少性能提升，你可以在不同的浏览器上运行这个在线测试，比如：[http://codepen.io/dsheiko/pen/JdrqXa](http://codepen.io/dsheiko/pen/JdrqXa)。
- en: Enumerating an array-like object
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举数组对象
- en: 'Objects such as `arguments` and `nodeList` (`node.querySelectorAll`, `document.forms`)
    look like arrays, in fact they are not. Similar to arrays, they have the `length`
    property and can be iterated in the `for` loop. In the form of objects, they can
    be traversed in the same way that we previously examined. But they do not have
    any of the array manipulation methods (`forEach`, `map`, `filter`, `some` and
    so on). The thing is we can easily convert them into arrays as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `arguments` 和 `nodeList`（`node.querySelectorAll`、`document.forms`）这样的对象看起来像数组，实际上它们并不是。和数组一样，它们有
    `length` 属性，可以在 `for` 循环中进行迭代。以对象的形式，它们可以以前面提到的相同方式进行遍历。但它们没有任何数组操作方法（`forEach`、`map`、`filter`、`some`
    等等）。事实是，我们可以很容易地将它们转换为数组，如下所示：
- en: '[PRE44]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code can be even shorter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码甚至可以更短：
- en: '[PRE45]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It''s a pretty convenient solution, but looks like a trick. In ES6, we can
    do the same conversion with a dedicated method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常方便的解决方案，但看起来像是一个技巧。在 ES6 中，我们可以用一个专用方法进行相同的转换：
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The collections of ES6
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: es6 集合
- en: 'ES6 introduces a new type of objects—iterable objects. These are the objects
    whose elements can be retrieved one at a time. They are quite the same as iterators
    in other languages. Beside arrays, JavaScript received two new iterable data structures,
    `Set` and `Map`. `Set` which are a collection of unique values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了一种新类型的对象——可迭代对象。这些对象可以一次获取一个元素。它们与其他语言中的迭代器非常相似。除了数组，JavaScript还接收了两个新的可迭代数据结构，`Set`和`Map`。`Set`是一个包含唯一值的集合：
- en: '[PRE47]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The map is similar to a key-value object, but may have arbitrary values for
    the keys. And this makes a difference. Imagine that we need to write an element
    wrapper that provides jQuery-like events API. By using the `on` method, we can
    pass not only a handler callback function but also a context (`this`). We bind
    the given callback to the `cb.bind( context )` context. This means `addEventListener`
    receives a function reference different from the callback. How do we unsubscribe
    the handler then? We can store the new reference in `Map` by a key composed from
    an event name and a `callback` function reference:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类似于键值对象，但键可以是任意值。这造成了区别。想象一下，我们需要编写一个元素包装器，提供类似jQuery的事件API。通过使用`on`方法，我们不仅可以传递一个处理回调函数，还可以传递一个上下文（`this`）。我们通过`cb.bind(context)`将给定的回调绑定到上下文。这意味着`addEventListener`接收一个与回调不同的函数引用。那么我们如何取消订阅处理程序呢？我们可以通过一个由事件名称和`callback`函数引用组成的键将新引用存储在`Map`中：
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Any iterable object has methods, `keys`, `values`, and `entries`, where the
    keys work the same as `Object.keys` and the others return array values and an
    array of key-value pairs respectively. Now let''s see how we can traverse the
    iterable objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可迭代的对象都有方法，`keys`，`values`和`entries`，其中键与`Object.keys`相同，其他方法分别返回数组值和键值对数组。现在让我们看看我们如何遍历可迭代的对象：
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Iterable objects have manipulation methods such as arrays. So we can use `forEach`.
    Besides, they can be iterated by `for...in` and `for...of` loops. The first one
    retrieves indexes and the second, the values.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代的对象有数组类似的操作方法。因此我们可以使用`forEach`。此外，它们可以通过`for...in`和`for...of`循环进行迭代。第一个获取索引，第二个获取值。
- en: The most effective way of declaring objects
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明对象最有效的方法
- en: How do we declare an object in JavaScript? If we need a namespace, we can simply
    use an object literal. But when we need an object type, we need to think twice
    about what approach to take, as it affects the maintainability of our object-oriented
    code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JavaScript中如何声明一个对象？如果我们需要一个命名空间，我们可以简单地使用一个对象字面量。但当我们需要一个对象类型时，我们需要三思采取什么方法，因为这会影响我们面向对象代码的可维护性。
- en: Classical approach
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 古典方法
- en: 'We can create a constructor function and chain the members to its context:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个构造函数并将成员链接到其上下文：
- en: '[PRE50]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can also assign the members to the constructor prototype. The result will
    be the same as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将成员分配给构造函数原型。结果将与以下相同：
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the first case, we have the object structure within the constructor function
    body mixed with the construction logic. In the second case by repeating `Constructor.prototype`,
    we violate the **Do Not Repeat Yourself** (**DRY**) principle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们在构造函数体中混合了对象结构和构造逻辑。在第二种情况下，通过重复`Constructor.prototype`，我们违反了**不要重复自己**（**DRY**）原则。
- en: Approach with the private state
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有状态的方法
- en: 'So how can we do it otherwise? We can return an object literal by the constructor
    function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们还可以用其他方式做什么呢？我们可以通过构造函数函数返回一个对象字面量：
- en: '[PRE52]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The advantage of this approach is that any variables declared in the scope of
    the constructor are in the same closure as the returned object, and therefore,
    available through the object. We can consider such variables as private members.
    The bad news is that we will lose the constructor prototype. When a constructor
    returns an object during instantiation, this object becomes the result of a whole
    new expression.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于，构造函数作用域内声明的任何变量都与返回的对象在同一个闭包中，因此，可以通过对象访问。我们可以将这些变量视为私有成员。坏消息是我们将失去构造函数原型。当构造函数在实例化过程中返回一个对象时，这个对象成为整个新表达式的结果。
- en: Inheritance with the prototype chain
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型链的继承
- en: 'What about inheritance? The classical approach would be to make the subtype
    prototype an instance of supertype:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么继承呢？古典方法会让子类型原型成为超类型实例：
- en: '[PRE53]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You may run into some code, where for instantiation `Object.create` is used
    instead of the new operator. Here you have to know the difference between the
    two. `Object.create` takes an object as an argument and creates a new one with
    the passed object as a prototype. In some ways, this reminds us of cloning. Examine
    this, you declare an object literal (proto) and create a new object (instance)
    with `Object.create` based on the first one. Whatever changes you do now on the
    newly created object, they won''t be reflected on the original (proto). But if
    you change a property of the original, you will find the property changed in its
    derivative (instance):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一些代码，其中实例化时使用`Object.create`而不是新操作符。在这里，你需要知道两者的区别。`Object.create`接受一个对象作为参数，并创建一个以传递的对象为原型的新对象。在某种意义上，这使我们想起了克隆。检查这个，你声明一个对象字面量（proto）并基于第一个对象使用`Object.create`创建一个新的对象（实例）。无论你现在对新生成对象做何更改，它们都不会反映在原始（proto）上。但是，如果你更改原始对象的属性，你会在派生对象（实例）中发现该属性已更改：
- en: '[PRE54]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Inheriting from prototype with Object.create
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过`Object.create`继承原型
- en: 'In contrast to the new operator, `Object.create` does not invoke the constructor.
    So when we use it to populate a subtype prototype, we are losing all the logic
    located in a `supertype` constructor. This way, the `supertype` constructor is
    never called:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与新操作符相比，`Object.create`不调用构造函数。因此，当我们使用它来填充子类型的原型时，我们失去了位于`supertype`构造函数中的所有逻辑。这样，`supertype`构造函数永远不会被调用：
- en: '[PRE55]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Inheriting from prototype with Object.assign
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过`Object.assign`继承原型
- en: 'When looking for an optimal structure, I would like to declare members via
    an object literal, but still have the link to the prototype. Many third-party
    projects leverage a custom function (*extend*) that merge the structure object
    literal into the constructor prototype. Actually, ES6 provides an `Object.assign`
    native method. We can use it as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当寻找最优结构时，我希望通过对象字面量声明成员，但仍保留到原型的链接。许多第三方项目利用自定义函数(*extend*)将结构对象字面量合并到构造函数原型中。实际上，ES6提供了`Object.assign`本地方法。我们可以像这样使用它：
- en: '[PRE56]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This looks almost as required, except there is one inconvenience. `Object.assign`
    simply assigns the values of source objects to the target ones regardless of their
    type. So if you have a source property with an object (for instance, an `Object`
    or `Array` instance), the target object receives a reference instead of a value.
    So you have to reset manually any object properties during initialization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来几乎就是所需的，除了有一点不便。`Object.assign`简单地将源对象的价值分配给目标对象，而不管它们的类型如何。所以如果你有一个源属性是一个对象（例如，一个`Object`或`Array`实例），目标对象接收一个引用而不是一个值。所以你必须在初始化时手动重置任何对象属性。
- en: Approach with ExtendClass
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ExtendClass的方法
- en: 'ExtendClass, proposed by Simon Boudrias, is a solution that seems flawless
    ([https://github.com/SBoudrias/class-extend](https://github.com/SBoudrias/class-extend)).
    His little library exposes the `Base` constructor with the **extend** static method.
    We use this method to extend this pseudo-class and any of its derivatives:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由Simon Boudrias提出的`ExtendClass`似乎是一个无懈可击的解决方案([https://github.com/SBoudrias/class-extend](https://github.com/SBoudrias/class-extend))。他的小型库暴露了带有**extend**静态方法的`Base`构造函数。我们使用这个方法来扩展这个伪类及其任何派生类：
- en: '[PRE57]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Classes in ES6
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: es6中的类
- en: 'TC39 (the EcmaScript working group) is pretty aware of the problem, so the
    new language specification provides extra syntax to structure object types:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: tc39（ECMAScript工作组）对这个问题非常清楚，所以新的语言规范提供了额外的语法来结构对象类型：
- en: '[PRE58]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The syntax looks class-based, but in fact this a syntactic sugar over existing
    prototypes. You can check with the type of `ConcreteClass`, and it will give you
    *function* because `ConcreteClass` is a canonical constructor. So we don''t need
    any trick to extend `supertypes`, no trick to refer the `supertype` constructor
    from subtype, and we have a clean readable structure. However, we cannot assign
    properties the same C-like way as we do now with methods. This is still in discussion
    for ES7 ([https://esdiscuss.org/topic/es7-property-initializers](https://esdiscuss.org/topic/es7-property-initializers)).
    Besides this, we can declare a class''s static methods straight in its body:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法看起来是基于类的，但实际上这只是现有原型的语法糖。你可以检查`ConcreteClass`的类型，它会给你*function*，因为`ConcreteClass`是一个典型的构造器。所以我们在扩展`supertypes`时不需要任何技巧，不需要从子类型中引用`supertype`构造函数，并且我们有一个清晰可读的结构。然而，我们无法以现在的方法相同的C语言方式分配属性。这仍在ES7的讨论中([https://esdiscuss.org/topic/es7-property-initializers](https://esdiscuss.org/topic/es7-property-initializers))。此外，我们可以在类的正文中直接声明类的静态方法：
- en: '[PRE59]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Actually, there are many in the JavaScript community who consider the new syntax
    as a deviation from the prototypical OOP approach. On the other hand, the ES6
    classes are backwards compatible with most of the existing code. Subclasses are
    now supported by the language and no extra libraries are required for inheritance.
    And what I personally like the most is that this syntax allows us to make the
    code cleaner and more maintainable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有很多在JavaScript社区的人认为新的语法是从原型面向对象方法的一种偏离。另一方面，ES6类与大多数现有代码向后兼容。子类现在由语言支持，不需要额外的库来实现继承。我个人最喜欢的是，这种语法允许我们使代码更简洁、更易于维护。
- en: How to – magic methods in JavaScript
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何——JavaScript中的魔术方法
- en: 'In the PHP world, there are things such as *overloading methods*, which are
    also known as magic methods ([http://www.php.net/manual/en/language.oop5.overloading.php](http://www.php.net/manual/en/language.oop5.overloading.php)).
    These methods allow us to set a logic that triggers when a nonexisting property
    of a method is being accessed or modified. In JavaScript, we control access to
    properties (value members). Imagine we have a custom collection object. In order
    to be consistent in the API, we want to have the `length` property that contains
    the size of the collection. So we declare a `getter` (get length), which does
    the required computation whenever the property is accessed. On attempting to modify
    the property value, the setter will throw an exception:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP世界中，有诸如*重载方法*这样的概念，它们也被称为魔术方法（[http://www.php.net/manual/en/language.oop5.overloading.php](http://www.php.net/manual/en/language.oop5.overloading.php)）。这些方法允许我们在访问或修改一个方法的不存在属性时触发一个逻辑。在JavaScript中，我们控制对属性（值成员）的访问。想象我们有一个自定义的集合对象。为了保持API的一致性，我们想要有一个`length`属性，它包含集合的大小。所以我们就声明一个`getter`（获取长度），每当属性被访问时就会执行所需的计算。在尝试修改属性值时，设置器将抛出一个异常：
- en: '[PRE60]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we want to declare getters/setters on an existing object, we can use the
    following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在现有对象上声明getters/setters，我们可以使用以下方式：
- en: '[PRE61]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`Object.defineProperty` as well as the second parameter of `Object.create`
    specifies a property configuration (whether it is enumerable, configurable, immutable,
    and how it can be accessed or modified). So, we can achieve a similar effect by
    configuring the property as read-only:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.defineProperty`以及`Object.create`的第二个参数指定了属性配置（是否可枚举、可配置、不可变，以及如何访问或修改）。因此，我们可以通过将属性设置为只读来达到类似的效果：'
- en: '[PRE62]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'By the way, if you want to get rid of the property accessor in the object,
    you can simply remove the property:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你想要摆脱对象中的属性访问器，你可以简单地移除该属性：
- en: '[PRE63]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Accessors in ES6 classes
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES6类中的访问器
- en: 'Another way by which we can declare accessors is using the ES6 classes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 声明访问器的另一种方式是使用ES6类：
- en: '[PRE64]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Besides public properties, we can control access to static ones as well:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了公共属性，我们还可以控制对静态属性的访问：
- en: '[PRE65]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Controlling access to arbitrary properties
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制对任意属性的访问
- en: 'All these examples show access control to known properties. However, there
    might be a case when I want a custom storage with a variadic interface similar
    to `localStorage`. This must be a storage that has the `getItem` method to retrieve
    stored values and the `setItem` method to set them. Besides, this must work the
    same way as when you directly access or set a pseudo-property (`val = storage.aKey`
    and `storage.aKey = "value"`). These can be achieved by using the ES6 Proxy:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都展示了对已知属性的访问控制。然而，可能有一个情况，我想要一个具有类似于`localStorage`的变长接口的自定义存储。这必须是一个具有`getItem`方法以检索存储的值和`setItem`方法以设置它们的存储。此外，这必须与直接访问或设置伪属性（`val
    = storage.aKey`和`storage.aKey = "value"`）的方式相同。这可以通过使用ES6代理实现：
- en: '[PRE66]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter gives practices and tricks on how to use the JavaScript core features
    for the maximum effect. In the next chapter, we will talk about module concepts
    and we will do a walkthrough on scopes and closures. The next chapter will explain
    the scope context and the ways to manipulate it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用JavaScript核心特性达到最大效果的最佳实践和技巧。在下一章中，我们将讨论模块概念，并详细介绍作用域和闭包。下一章将解释作用域上下文及其操作方法。
