- en: Chapter 5. Twitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Twitter is a service that really grew up on having an open and available API.
    Initially, there were no Twitter clients. Communication with Twitter was limited
    to SMS and later the website. During the development of Twitter, the developers
    apparently racked up hundreds of dollars in SMS charges, testing, and building
    the system. Twitter grew in popularity on the back of hundreds of developers who
    built tools like **TweetDeck** and **Tweetree** using open Twitter APIs or the
    Twitter RSS feeds. As such, Twitter offers a rich API that can be used to build
    up applications, and in our case, visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into building visualizations, let's take a look at the Twitter
    API, and how we can make use of it. There is a great deal of documentation on
    the API available at [https://dev.twitter.com](https://dev.twitter.com). If you
    want more information, this should be your first stop for additional research.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, Twitter offers two different models for retrieving data.
    The first is a typical RESTful model, where the client makes requests to Twitter
    for specific resources that are returned over HTTP in JSON format. This API is
    likely to be similar to others you have seen before. It is stateless, meaning
    that no information is retained server side between requests, and follows the
    best practices of HTTP. If you''re attempting to consume data from Twitter in
    a web browser, then this is the option for you. The second option is the streaming
    API. This method makes use of a persistent HTTP connection to which Twitter will
    send messages as they occur. It is a generally poor idea to make use of the streaming
    API from a browser, so you''ll need to have some sort of an intermediary server
    between the browser and the API, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Twitter](img/6542OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Having a server is, unfortunately, a requirement of all visualizations that
    make use of Twitter, even the RESTful API, as Twitter does not support authentication
    using a pure browser-based solution. We'll get into all that later, but first
    we'll need to set up a developer account with Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting access to the APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you remember in [Chapter 3](ch03.html "Chapter 3. OAuth"), *OAuth*, one of
    the requirements was getting an application key for each site with which we want
    to talk. This applies to Twitter, so let's go and do that.
  prefs: []
  type: TYPE_NORMAL
- en: Open up a browser, head over to [https://dev.twitter.com](https://dev.twitter.com),
    and click on the **Sign in** link. If you already have a Twitter account, then
    you can use that here to sign in. If not then you can sign up for a new Twitter
    account. Don't worry, it is all free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re signed in, then in the top right-hand corner there should be a
    link to **My applications,** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting access to the APIs](img/6542OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on that will take you to a page where you can go about setting up
    your first application. You''ll need to enter some information about the application.
    You can enter whatever you choose for most fields, but the callback URL should
    be [http://127.0.0.1:8080/twitter1.html](http:// http://127.0.0.1:8080/twitter1.html).
    This is the URL to which Twitter will direct you once the OAuth phase is complete.
    We''re using a localhost value here, but in production you would want to use the
    publicly-facing URL for your visualization. The following screenshot shows the
    **Application Details** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting access to the APIs](img/6542OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot use a localhost domain here, but if you would rather not see an IP
    address, then you can use a URL shortening service to create an alias for your
    localhost URL. Make sure your URL shortener preserves query parameters, or you
    won't be able to login correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your application has been created, you''ll be able to see the various
    settings from the same **My applications** option that we used previously. The
    key information for our purpose is `OAuth settings,` as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting access to the APIs](img/6542OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These keys will be used for user authorization with our application. Should
    the secret key be leaked—for instance, you might have pasted it into a book you're
    writing—it can be reset using the **Reset keys** link. Doing so will prevent readers
    of your book from pretending to be you and committing unspeakable evils in your
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned, Twitter does not allow direct access to their authentication
    structure from a browser, we'll need to make use of a server. Fortunately, we
    can develop against a server on our own computer—no need for an external server.
    We're using a lot of JavaScript in this book, so let's keep that theme going and
    host our site locally using node.js. Any other HTTP server will also work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing node.js is pretty simple. If you''re on Windows, then there is an
    installer available from [http://nodejs.org](http://nodejs.org). On OS X, there
    is a `.pkg`-based installer available on the same site, or it can be installed
    using Homebrew. If you''re using Linux, it is preferable to compile from source.
    However, if you''re using a distribution with a built-in packaging system, such
    as **apt** or **yum**, then there is a node.js package that can be installed with
    either of the two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'node.js is a piece of server-side software that is designed to perform all
    of its I/O tasks asynchronously. This means that an operation such as writing
    to disk is handled without blocking the main thread. When the I/O is complete,
    the main thread is notified. One of the most common applications is its usage
    as an HTTP server. This functionally comes in the box in the form of the HTTP
    module, but the interface provided by that module is pretty lightweight. Instead,
    we''ll make use of the Express framework. Express is a lightweight framework which
    provides some infrastructure around routing, sessions and serving content, and
    templating. It can be installed using the node package manager `npm` as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We'll make use of Express going forward.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OAuth can, of course, be manually configured and controlled, but we stand on
    the shoulders of giants for good reason. It is much easier for us to make use
    of an already built OAuth library. Fortunately, node has such a library, creatively
    called **OAuth**. Even with this library, you''ll see that interacting with an
    OAuth 1.0a endpoint is complicated. To install it, drop to the command line again
    and use the node package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This library can perform both OAuth 1.0a and OAuth 2.0 operations. As Twitter
    is an OAuth 1.0a endpoint, we'll be making use of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is set up our Express application. Express provides application
    templates, but they are an overkill for the simple application in this chapter.
    If you''re planning on creating a more complicated application in future, you''ll
    want to look more into app generation and directory structure for you, application.
    We start by requiring `express` and creating a new app using the loaded module,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Require is a library which permits the dynamic loading of JavaScript libraries.
    It is the most common way to bring in external modules in a node application.
    Next, we configure a number of settings in `express`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`bodyParser` allows `express` for simple parsing of the body of requests sent
    to the server. On the next line, the `cookieParser` is set up. Like the `bodyParser`,
    this allows for parsing of cookies and populates the request object with values
    retrieved from cookies, in our case, information for the session. Next, we set
    up the session capabilities. This allows us to share information from request
    to request. In its default configuration, it uses in-memory storage to hold session
    information. This means that restarting your application will erase session information.
    If you''re hosting your visualization on a farm of machines, you''ll need to make
    use of an external data storage mechanism such as **MongoDB** or **Redis**. We
    pass in a secret key that is used in generating the `session` hash. It should
    be a random string. Using the `app.router` will instruct express to listen to
    route requests, which we''ll define in a second. Finally our `.html` and `.js`
    files are going to be in a directory called `public`, so we''ll instruct `express`
    to serve out the contents of that directory as static resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to make use of the OAuth library. This can be done with a function
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an OAuth object associated with Twitter. We give the two end-points,
    and then the consumer key and consumer secret which we received from Twitter earlier.
    The requirement to embed the consumer secret for OAuth 1.0a is why client-side
    code cannot be used to retrieve information from Twitter. The consumer secret
    cannot be leaked to outsiders by sending it to the client. `1.0A` is passed in
    as the version of OAuth; no authorization callback is required so `null` is given
    as the sixth parameter. The final parameter is the signature method: Twitter uses
    `HMAC-SHA1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll set up a route in the Express application to request the OAuth
    tokens from Twitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we hook up the `/requestOAuth` route to first request an OAuth token,
    and then use that to redirect the users to the sign in page on Twitter. We build
    an anonymous function and pass that into OAuth, because node is highly asynchronous.
    The callback model allows the main node thread to serve another request, while
    waiting for Twitter to get back to it with OAuth tokens. Once we have the OAuth
    tokens, we save them in a session state for use in the next step, and redirect
    to the Twitter authorization page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Twitter will redirect the user once they have authenticated to the URL we defined
    when setting up the application. In our case, this will be served by the route
    `/receiveOAuth`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code takes the OAuth tokens passed back by Twitter's `redirect`, and performs
    the final step which is looking up the access tokens. Once we have these access
    tokens, they can be used to call the API—here done in the `GetRetweets` function.
    We'll save all the tokens generated in the session so that user's don't have to
    continually grant access to the Twitter API.
  prefs: []
  type: TYPE_NORMAL
- en: Tired of tokens yet? You should be! This exchange to set up OAuth 1.0a uses
    an awful lot of tokens. Fortunately, we're done with tokens and OAuth. Now we
    can get onto building a visualization with Twitter data!
  prefs: []
  type: TYPE_NORMAL
- en: Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a whole bunch of APIs made available to us by Twitter. We should start
    perhaps by inventing something we would like to visualize and then decide if the
    data is available and how we would show it. I'm curious about which of the people
    I follow tweet the most. Some accounts such as `@kellabyte` seem to always be
    tweeting and others like @ericevans hardly at all.
  prefs: []
  type: TYPE_NORMAL
- en: Server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by getting the data on the server side. In node.js, I set up a
    new route using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we check to make sure that we have the appropriate tokens available in
    the session. If not then we redirect back to the `requestOAuth` page which will
    start up the whole OAuth workflow. Next, we set an initial cursor value. Twitter
    limits the number of results which come back from its services. This avoids dumping
    a million records out to the consumer, which is not something either party is
    likely to want. For the API call, we'll be using the limit set to 20\. However,
    Twitter also provides a continuation token which they call a cursor. By calling
    the service again with this token, the next page of results is returned. An initial
    value of `-1` gives the first page. The cursor along with all the required tokens
    is passed into `receiveUserListPage`, which will perform the actual lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Rate Limits**'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter limits the number of request you can send to their service. When developing
    a visualization, you may bump into these limits. Wait for 15 minutes and try again.
    In production, try caching your data so you don't have to query Twitter so frequently.
  prefs: []
  type: TYPE_NORMAL
- en: '`receiveUserListPage` looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We start off by getting a reference to the OAuth library, then we use the current
    cursor and the current `user_id` to query Twitter. The API call we're using returns
    a set of 20 users from the list of people who I follow. The results are returned
    as a string so we parse them into an object using `JSON.parse`. If the resulting
    object contains a field called `errors`, then we've likely hit the rate limit,
    so we return everything we've pull down so far. Because the rate limit is only
    `15` for this API call, if you follow more than 300 people, you'll hit the limit.
  prefs: []
  type: TYPE_NORMAL
- en: If we have results, we append them to our current set of data. We use the underscore's
    `map` function to select only two of the fields from. This saves on bandwidth
    and makes debugging easier, as the objects returned from Twitter are very heavyweight
    with dozens of useless fields. If `next_cursor` is equal to `0`, then it means
    that we've reached the end of the list and can return the current set of names
    and counts. Otherwise we recourse into the function, giving it the new cursor,
    set of names, and items. Once we hit a case where we can return, we call `projectResults`
    which sends the 10 users with the most tweets to the client formatted as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Underscore.js**'
  prefs: []
  type: TYPE_NORMAL
- en: The underscore JavaScript library is a small library that makes working with
    arrays far easier. It adds set functions such as `union` and `intersect,` as well
    as functional programming concepts such as map and reduce. It can be downloaded
    from [http://underscorejs.org/](http:// http://underscorejs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Client side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client side visualization code can be placed in the public directory that
    we previously directed Express to serve out as static content.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d like to show the most active tweeters visually. A nice way of doing this
    is to use a bubble chart, and make the bubbles bigger the more tweets they have.
    Let''s build up the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Much of this code will look familiar now that you know a bit about d3\. The
    data array which is passed in is what is retrieved from our node service. First,
    we create an SVG element on the page of an arbitrary size. Then, we set up a color
    scale so that our visualization will be nicely colored. The `calculateBubbles`
    function is a helper function which will calculate the locations of the bubbles.
    It augments our data array with the x and y coordinates for the circle as well
    as its radius. We won't get into that here, but the code is available on GitHub.
    For each of the top tweeters we create a bubble. We color it using the color scale,
    and set the location using the pre-calculated values from the data array. Initially,
    we set the radius to `0`, but then we use a transition to grow the circles for
    a nice loading effect.
  prefs: []
  type: TYPE_NORMAL
- en: For each one of the circles, we want to label what the circle represents. This
    is done by adding a text element at the center of the circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting graph, based on the 10 most active people I follow, looks like
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client side](img/6542OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every one of these people has tweeted over 35,000 times.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now be able to set up a new application to query Twitter, create
    the proper OAuth tokens using the OAuth library on node.js, and build a bubble
    chart. The Twitter API is rich and has many more potential visualizations lurking
    in it. I'm sure that we could come up with a couple of dozen potential visualizations.
    There is no better way to learn than through experimenting with the API, so don't
    be afraid to get messy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll take a look at visualizations of data on the popular
    question and answer site, Stack Overflow. Their API is largely an open one which
    doesn't require authentication for most queries, so we should have a brief reprieve
    from having to use OAuth and even node.js.
  prefs: []
  type: TYPE_NORMAL
