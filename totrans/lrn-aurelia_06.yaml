- en: Chapter 6. Design Concerns - Organizing and Decoupling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。设计关注 - 组织和解耦
- en: Organizing a large application can be complicated. Depending on how the application
    is structured and on how its parts must depend on each other, deciding how to
    organize the code is not always obvious. It's even truer when working with a framework
    you are not familiar with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 组织大型应用程序可能会变得复杂。取决于应用程序的结构以及其部分之间必须如何相互依赖，决定如何组织代码并不总是显而易见的。当你不熟悉框架时，这一点更是如此。
- en: There are many ways to organize an Aurelia application. Like anything related
    to design and architecture, choosing an organizational model is a matter of juggling
    with a lot of criteria. Obviously, selecting one model over another means benefiting
    from its advantages, but dealing with its downsides and limitations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 组织Aurelia应用程序有很多方法。像设计和架构相关的任何事物一样，选择一个组织模型是一个权衡许多标准的问题。显然，选择一个模型而不是另一个意味着从中受益，但也需要处理其缺点和限制。
- en: In this chapter, we will first see the different ways to organize an application,
    along with the various features of the framework that can help us do that. Of
    course, we will refactor our contact management application toward a more scalable
    structure. We will play with different ideas until we settle on a stable structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将了解组织应用程序的不同方法，以及框架可以帮助我们做到这一点的各种特性。当然，我们将对我们的联系管理应用程序进行重构，使其具有更可扩展的结构。我们会尝试不同的想法，直到找到一个稳定的结构。
- en: Secondly, having a framework based on components is pointless if the components
    forming our application are tightly coupled. In the second half of this chapter,
    we will see different ways to decouple components, using either data binding,
    shared services, or Aurelia's event aggregator.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果构成我们应用程序的组件紧密耦合，基于组件的框架就是徒劳的。在本章的第二部分，我们将看到不同的方法来解耦组件，使用数据绑定、共享服务或Aurelia的事件聚合器。
- en: Re-organizing our application
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新组织我们的应用程序
- en: Before starting to explore an application's structural possibilities, we first
    need to decide what we are aiming for. We won't be able to make an enlightened
    decision if we don't know what properties we are striving for in an organizational
    model.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索应用程序结构的可能性之前，我们首先需要决定我们的目标是什么。如果我们不知道我们正在努力争取的组织模型的属性，我们就无法做出明智的决定。
- en: Of course, those properties will be absolutely arbitrary here. In a real project,
    with a real client, real stakeholders, and real users, we would have at least
    some clues as to what those properties could be. In the case of our contact management
    application, we will stick with the properties that are most commonly needed in
    typical, medium to large-scaled projects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里的属性将是绝对任意的。在真实项目中，有真实的客户、真实的利益相关者和真实的用户，我们至少会有一些线索来了解这些属性可能是什么。在我们联系管理应用程序的案例中，我们将坚持最常见的中型到大型项目中需要的属性。
- en: Firstly, we will assume that our application is destined to grow. For now, it
    only manages contacts, but we can imagine that our product owner has big plans
    for the application, and that we will eventually add some completely unrelated
    features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将假设我们的应用程序注定要增长。现在，它只管理联系人，但我们可以想象我们的产品所有者对应用程序有宏伟的计划，最终我们会添加一些完全不相关的功能。
- en: The current structure, or the absence of it, fits a small application. For a
    larger application, with more distinct features, the project must be structured
    in such a way that the developers do not get lost in the code. In the context
    of our application, we need to choose a structure that will minimize the odds
    of it needing to be re-organized after a while because its structure doesn't scale.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的结构，或者它的缺失，适合一个小应用程序。对于一个具有更多独特功能的大型应用程序，项目必须以这样的方式组织，以使开发人员不会在代码中迷失。在我们应用程序的背景下，我们需要选择一个结构，以最小化将来需要重新组织的机会，因为它的结构无法扩展。
- en: Secondly, we will strive for an architecture that allows features to be as decoupled
    and independent as possible. The goal is to make including and excluding features
    of the application as easy as possible. This requirement is not typical for most
    applications, but in this case it will allow us to see how Aurelia can help to
    do that when needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将努力实现一种允许功能尽可能解耦和独立的架构。目标是使包括和排除应用程序的功能尽可能容易。这个要求对大多数应用程序来说并不典型，但在这个情况下，它将允许我们了解当需要时Aurelia如何帮助我们做到这一点。
- en: Refactoring the structure
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构结构
- en: At the moment, our application has mostly no structure at all, except for the
    global resources and validation setup, which are grouped as features in their
    own directory. All files related to the contact management feature sit at the
    root of the `src` directory, and the components are mixed with the API gateway
    and the models. Let's put some order in there.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序基本上没有结构，除了全局资源和验证设置，它们作为特性在自己的目录中分组。所有与联系人管理特性相关的文件都位于`src`目录的根目录中，组件与API网关和模型混合在一起。让我们在那里面整理一下。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sample found at `chapter-6/samples/app-reorganized` illustrates the application
    after being restructured as depicted in the following section. It can be used
    as a reference.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter-6/samples/app-reorganized`中找到的示例展示了经过以下章节描述的结构调整后的应用程序。它可以作为参考。
- en: Let's first group all code related to contact management in a `contacts` directory.
    This moves toward isolating each feature in its own directory. Additionally, to
    reduce redundancy, let's rename the files starting with `contact-` and remove
    the prefix.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将所有与联系人管理相关的代码放在一个`contacts`目录中。这使得每个功能都向隔离在自己的目录中迈出了一步。此外，为了减少冗余，让我们将以`contact-`开头的文件重命名为不带前缀的名称。
- en: 'The project structure should look like this afterwards:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构应该像这样之后：
- en: '![Refactoring the structure](img/image_06_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![重构结构](img/image_06_001.jpg)'
- en: 'This is already better. However, we could enhance cohesion by creating subdirectories
    to group files according to their types of responsibilities. Here, we first have
    the components `creation`, `details`, `edition`, `list`, and `photo`. We also
    have a service: the `gateway`. Lastly, we have some `models`, which are all grouped
    inside the same file.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经更好了。然而，我们可以通过创建子目录来增强聚合性，按其责任类型对文件进行分组。在这里，我们首先有组件`creation`、`details`、`edition`、`list`和`photo`。我们还有一个服务：网关。最后，我们有一些`models`，它们都被放在同一个文件里。
- en: Breaking the models down
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解模型
- en: 'Let''s start by breaking down the models into a new `models` directory and
    by exploding the `models.js` file, moving each model class to its own file inside
    this new directory. It should look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先将模型分解成一个新的`models`目录，并通过爆炸`models.js`文件，将每个模型类移动到这个新目录内部的各自文件中。它应该看起来像这样：
- en: '![Breaking the models down](img/image_06_007.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![分解模型](img/image_06_007.jpg)'
- en: Now, with a simple glimpse at the `models` directory, a developer can see that
    we have multiple models and what their names are.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过简单的查看`models`目录，开发者可以看到我们有多个模型以及它们的名称。
- en: 'Of course, this means that we must perform some changes to those classes. First,
    we must add an `import` statement for validation at the top of `address.js`, `email-address.js`,
    `phone-number.js`, and `social-profile.js`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着我们必须对这些类进行一些更改。首先，我们必须在`address.js`、`email-address.js`、`phone-number.js`和`social-profile.js`文件的顶部添加一个用于验证的`import`语句：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, `import` statements for the other model classes must be added at the
    top of `contact.js`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`contact.js`文件的顶部必须添加其他模型类的`import`语句：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Isolating the gateway
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离网关
- en: The `gateway` is a different beast from the rest of the files, it is a service.
    Generally, services are singletons that provide some functionalities to other
    parts of the application. Here, we only have this one service, but it is still
    worth putting it in its own directory, so it is easier to find.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`gateway`与文件中的其他内容不同，它是一个服务。通常，服务是单例，为应用程序的其他部分提供一些功能。在这里，我们只有这个一个服务，但仍然值得为其创建一个自己的目录，以便更容易找到。'
- en: 'Let''s create a `services` directory and move the `gateway` there:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`services`目录，并将`gateway`移动到那里：
- en: '![Isolating the gateway](img/image_06_003.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![隔离网关](img/image_06_003.jpg)'
- en: 'The first thing that needs to be changed for the `gateway` to work as before
    is to make the path of the `environment import` statement absolute, by removing
    the `./` prefix:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`gateway`像以前一样工作，需要做的第一个改变是使`environment import`语句的路径绝对，通过移除`./`前缀：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also need to change the path from which we import the `Contact` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改导入`Contact`类的路径：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Grouping the components
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件分组
- en: 'Lastly, we could group the visual components inside their own directory. Let''s
    create a `components` directory and move the rest of the files inside it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将视觉组件分组到它们自己的目录中。让我们创建一个`components`目录，并将剩下的文件移动到里面：
- en: '![Grouping the components](img/image_06_004.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![组件分组](img/image_06_004.jpg)'
- en: 'At this point, the application is broken. We need to do two things: fix the
    `import` and `require` statements for the model classes and the gateway in the
    components, and fix the route declarations in the `app` component.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，应用程序已损坏。我们需要做两件事：修复组件中的模型类和网关的`import`和`require`语句，以及修复`app`组件的路由声明。
- en: 'First, inside `creation.js`, `details.js`, `edition.js`, `list.js`, and `photo.js`,
    the `import` statement for the gateway must be fixed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`creation.js`、`details.js`、`edition.js`、`list.js`和`photo.js`中，必须修复网关的`import`语句：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Additionally, the `import` statement for the `Contact` model must also be fixed
    in `creation.js`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Contact`模型在`creation.js`中的`import`语句也必须修复：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, we need to change the `require` statement in `creation.html` and `edition.html`
    by fixing the path and adding an alias, so the `form.html` template is still loaded
    as the `contact-form` custom element:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要通过修复路径并添加别名来更改`creation.html`和`edition.html`中的`require`语句，以便`form.html`模板仍作为`contact-form`自定义元素加载：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, our `contacts/components` are ready to work. We simply need
    to fix the component path of all route declarations inside the `app` component:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们的`contacts/components`已准备就绪。我们只需要修复`app`组件内所有路由声明的组件路径：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The file structure is now much cleaner. If you run the application now, everything
    should work as before.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构现在要干净得多。如果你现在运行应用程序，一切应该还是和之前一样工作。
- en: There is no silver bullet
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有一劳永逸的解决方案。
- en: The structure we just refactored toward is not a universal truth. Taste and
    opinions always play a part in such decisions, and there are no right or wrong
    answers to this kind of question.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚重构的结构并不是绝对的真理。在这种决策中，品味和观点总是起到一定的作用，对于这类问题没有正确或错误的答案。
- en: 'However, the rationale behind this structure is simple and can be boiled down
    to a few principles:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种结构的背后的理由是简单且可以归结为几个原则：
- en: General-purpose or application-wide resources are in the `resources` feature.
    Things such as the `order-by` value converter or the `file-picker` custom element
    belong there.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用或应用程序范围内的资源位于`resources`特性中。像`order-by`值转换器或`file-picker`自定义元素这样的东西应该放在那里。
- en: Similarly, services and models that don't belong to a specific feature, but
    are used application-wide, should sit in their own directories, located at the
    root of the `src` directory; for example, in `src/services` and `src/models`.
    We don't have any of those in our application.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，不属于特定特性的服务和服务模型，应该位于`src`目录的根目录下的各自目录中；例如，在`src/services`和`src/models`中。在我们的应用程序中没有这些。
- en: Each domain feature sits in its own directory, such as the `contacts` directory.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个领域特性都位于自己的目录中，例如`contacts`目录。
- en: Technical features can also exist, such as the `validation` feature. The purpose
    of those features is to provide some general behaviors or extend other features.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以存在技术特性，例如`validation`特性。这些特性的目的是提供一些通用行为或扩展其他特性。
- en: Inside a feature's directory, files are grouped by type of responsibility. Components,
    whether they are route components such as `creation`, `details`, `edition`, `list`,
    and `photo`, or specialized widgets or custom elements such as the `form.html`
    template, are grouped inside the `components` subdirectory. Services and models
    are also in their own directory. If specialized value converters or binding behaviors
    exist for a given feature, they should also sit in their own directory inside
    the feature directory.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特性目录内，文件按责任类型分组。组件，无论是像`creation`、`details`、`edition`、`list`和`photo`这样的路由组件，还是像`form.html`模板这样的专用小部件或自定义元素，都位于`components`子目录内。服务和模型也有各自的目录。如果给定特性存在特殊的值转换器或绑定行为，它们也应该位于特性目录内的各自目录中。
- en: Those are the guidelines I use when structuring an Aurelia application. Of course,
    there are often cases that need reflection, either because they don't fall right
    into an existing slot or because blindly applying those rules would make a mess.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我在构建Aurelia应用程序时遵循的指导原则。当然，通常还有需要深思熟虑的情况，要么是因为它们不适合现有的槽位，要么是因为盲目应用这些规则会搞得一团糟。
- en: For example, it might be a good idea to split the `components` directory in
    two, named something like `screens` and `widgets`, if we have a lot of route components
    and specialized widgets. This way, it will be easier to identify which components
    are route components and which are feature-specific custom elements or composable
    widgets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的路由组件和专用小部件很多，将`components`目录分成两个，比如命名为`screens`和`widgets`可能是个好主意。这样，更容易识别哪些是路由组件，哪些是特定功能的定制元素或组合小部件。
- en: Additionally, it is sometimes better to add another level of classification
    to the structure, whether it is to group features by sub-domain or category, or
    to group services, models, or components by more specific purposes. The real guideline
    here is to try to make the structure communicate intent and implicit knowledge,
    as well as to make understanding where each part sits as easy as possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时在结构中添加另一层分类会更好，无论是按子域或类别分组功能，还是按更具体的目的分组服务、模型或组件。这里的真正指南是尽量使结构传达意图和隐性知识，以及尽可能容易地理解每个部分的位置。
- en: Another guideline I try to follow is to make the domain features directories
    mirror the navigation menu structure. Of course, this is not doable when the menu
    structure is too complicated, although this might be a sign that it needs to be
    rethought. When possible, it obviously makes navigating the code and the application
    much easier and intuitive for developers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试遵循的另一条指南是使域功能目录反映出导航菜单结构。当然，当菜单结构过于复杂时，这是不可能的，尽管这可能是一个需要重新思考的信号。当可能时，这显然可以使开发人员更容易、更直观地导航代码和应用程序。
- en: Leveraging child routers
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用子路由
- en: At this point, all code related to contact management is located in the `contacts`
    directory. But is it really? Actually, no. Route definitions still sit in the
    `app` component. How can we move those inside the `contact` directory?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，所有与联系人管理相关的代码都位于`contacts`目录中。但这真的正确吗？实际上，并不正确。路由定义仍然位于`app`组件中。我们如何将这些移动到`contact`目录内？
- en: The first possibility would be to leverage a child router. This way, we could
    declare a `main` component inside `contacts`, which would be responsible for declaring
    the routes to the various contact management components, such as `list`, `creation`,
    and `edition`. Then, the `app` component would need a single route leading to
    the contact's `main` component, and would not need to know about the more specialized
    `contacts` routes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可能性是利用子路由。这样，我们可以在`contacts`内部声明一个`main`组件，负责声明到各种联系人管理组件的路由，如`list`、`creation`和`edition`。然后，`app`组件需要一个通往联系人`main`组件的单一路由，并且不需要知道更专业的`contacts`路由。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the following sections, we will try different things. To make it easier to
    restore the code to be as it was before each try, I recommend that you somehow
    backup your application at this point, either by simply copying and pasting the
    project directory, or by creating a branch on your source control if you cloned
    the code from GitHub. Additionally, the sample found at `chapter-6/samples/app-using-child-router`
    illustrates the application modified as depicted in the following section. It
    can be used as a reference.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将尝试不同的事情。为了更容易地将代码恢复到每次尝试之前的样子，我建议您在此时以某种方式备份您的应用程序，无论是简单地复制和粘贴项目目录，还是如果您从GitHub克隆了代码，则在您的源控制中创建一个分支。此外，在`chapter-6/samples/app-using-child-router`中找到的示例展示了如下一节中描述的应用程序修改。它可以作为参考。
- en: Changing the root routes
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改根路由
- en: 'Let''s start by changing the root router configuration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改根路由配置：
- en: '`src/app.js`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we remove all the routes leading to the various contact management components,
    and replace them with a single route mapped to the `contacts` URL prefix. This
    route leads to the `main` component of `contacts`. Of course, we keep the default
    route redirecting to this `contacts` route.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们移除了所有指向各种联系人管理组件的路由，并用一个映射到`contacts` URL前缀的单一路由替换它们。此路由通往`contacts`的`main`组件。当然，我们保留了默认路由，它重定向到这个`contacts`路由。
- en: Configuring the contacts child router
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置联系人子路由
- en: 'Next, we need to create the `main` component of `contacts`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`contacts`的`main`组件：
- en: '`src/contacts/main.js`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/main.js`'
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we first use the `inlineView` decorator to declare a template that simply
    uses the `router-view` element to render the child router's active component.
    This child router is configured using the `configureRouter` method, which declares
    the `contacts` routes that were in the `app` component before.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用`inlineView`装饰器声明一个模板，该模板简单地使用`router-view`元素来渲染子路由器的活动组件。这个子路由器是通过`configureRouter`方法配置的，该方法声明了之前在`app`组件中的`contacts`路由。
- en: Of course, the route declarations need to change a little. First, the `contacts/`
    prefix must be removed from the `route` property of each route, since it is handled
    by the parent router now. As such, the route leading to the `list` component is
    now the child router's default route, as its pattern matches an empty string.
    Additionally, the `moduleId` property can be made relative instead of absolute,
    like it was before. This will reduce the amount of changes to be made if we ever
    rename or move the `contacts` directory. Lastly, since this child router's navigation
    model is not used to render any menu, we can remove the `nav` property from the
    route leading to the list.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，路由声明需要做一点小修改。首先，必须从每个路由的`route`属性中删除`contacts/`前缀，因为它现在由父路由器处理。因此，指向`list`组件的路由现在是子路由器的默认路由，因为它的模式与空字符串匹配。此外，`moduleId`属性可以改为相对路径，而不是像以前那样的绝对路径。这将减少如果我们改名或移动`contacts`目录时需要做的更改。最后，由于这个子路由器的导航模型不用于渲染任何菜单，我们可以从指向列表的路由中删除`nav`属性。
- en: Implications
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 含义
- en: If you run the application and play around with it, you may notice that the
    **contacts** top menu item stays highlighted when we navigate through the `creation`,
    `details`, `edition`, and `photo` components now, whereas it was previously only
    highlighted when the `list` component was active.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序并对其进行测试，你可能会注意到，现在在通过`creation`、`details`、`edition`和`photo`组件导航时，**联系人**顶菜单项保持高亮状态，而之前只有在`list`组件活动时才高亮。
- en: This is because this menu item is rendered using the route leading to the `main`
    component of `contacts`, which stays activated when we are on any child route.
    This is an interesting side effect that increases feedback to the user and makes
    the behavior of the top menu more consistent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这个菜单项是使用指向`contacts`组件的`main`路由生成的，当我们在任何子路由上时，它保持激活状态。这是一个有趣的副作用，增加了用户的反馈，使顶级菜单的行为更加一致。
- en: Additionally, using a child router moves the responsibility of declaring the
    module's routes inside the module itself. If the need arises to change the module's
    routes, the changes would be made within the boundaries of the module, and would
    have no impact on the rest of the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用子路由器将声明模块路由的责任移到了模块本身内部。如果需要更改模块的路由，更改将在模块的范围内进行，对应用程序的其余部分没有影响。
- en: There are, however, some limitations to child routers. Typically, at the time
    of writing, a router only has access to its own routes when generating a URL.
    This means that you cannot use the `route-href` attribute, nor the `Router` class'
    `generate` or `navigateToRoute` methods for routes defined in other routers, whether
    they are parents, children, or siblings. This can be problematic when modules
    need to have direct links between each other. The route must be generated manually,
    meaning that the route pattern could be defined in more than one place, which
    increases the risk of introducing a bug if a route pattern ever changes and the
    developer updates only some of the pattern instances.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，子路由器有一些限制。通常，在编写本文时，路由器在生成URL时只访问自己的路由。这意味着你不能使用`route-href`属性，也不能使用`Router`类的`generate`或`navigateToRoute`方法为其他路由器中定义的路由生成URL，无论这些路由器是父路由器、子路由器还是兄弟路由器。当模块需要彼此之间有直接链接时，这可能是个问题。必须手动生成路由，这意味着路由模式可能在不止一个地方定义，这增加了如果路由模式更改并且开发者只更新了一些模式实例时引入错误的风险。
- en: Declaring root routes in a feature
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在功能中声明根路由
- en: Another tool that could be helpful here is Aurelia's `feature` system. We could
    leverage a `configure` function to register the contact management routes directly
    on the root router.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个可能会有帮助的工具是Aurelia的`feature`系统。我们可以利用一个`configure`函数直接在根路由器上注册联系人管理路由。
- en: Let's roll things back to how they were before plugging in the child router
    and seeing how this can turn out.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们恢复到在插入子路由器之前的状态，看看这可能会导致什么结果。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sample found at `chapter-6/samples/app-using-feature` illustrates the application
    modified as depicted in the following section. It can be used as a reference.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter-6/samples/app-using-feature`找到的示例展示了根据以下部分修改后的应用程序。它可以作为参考。
- en: Creating the feature
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建特性
- en: 'We first need to create the `index.js` file to `configure` our new feature:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个`index.js`文件来配置我们新的特性：
- en: '`src/contacts/index.js`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/index.js`'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the `configure` function simply retrieves the root router from the DI
    container, then registers the routes using the `Router` class' `addRoute` method.
    Since there is no child router here, the routes are mapped using their full URLs,
    including the `contacts/` prefix, and they use absolute paths to refer to their
    components because they are relative to the component declaring the root `configureRouter`
    method, which is the `app` here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`configure`函数简单地从DI容器中获取根路由器，然后使用`Router`类的`addRoute`方法注册路由。由于这里没有子路由，所以路由使用它们的完整URL，包括`contacts/`前缀，并且它们使用绝对路径来引用它们的组件，因为它们相对于声明根`configureRouter`方法的组件，这里是`app`。
- en: 'Of course, this means we need to load this feature into the application''s
    main `configure` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着我们需要将这个功能加载到应用程序的主要`configure`函数中：
- en: '`src/main.js`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`'
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Changing the root routes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改根路径
- en: 'Lastly, we need to remove the contact management routes from the `app` component:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要从`app`组件中移除联系人管理路径：
- en: '`src/app.js`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we simply remove all the routes leading to the various contact management
    components, except for the default route redirecting to the `contacts` route,
    which displays the `list` component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地移除了所有通往各种联系人管理组件的路径，除了默认路径重定向到显示`list`组件的`contacts`路径。
- en: Reducing coupling on the feature
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少特性之间的耦合
- en: 'The application still depends on the `contacts` feature in two ways: it loads
    it into the main `configure` function, and the default route redirects to one
    of its routes in the `app` component. If we want to remove this feature, we now
    have two places to update. How can we remove the dependency from the `app` component?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序仍然以两种方式依赖于`contacts`特性：它将其加载到主要的`configure`函数中，默认路径重定向到`app`组件中的其一个路径。如果我们想要移除这个特性，现在有两个地方需要更新。我们如何从`app`组件中移除依赖？
- en: One first possibility is to simply add a `home` component, or some kind of Welcome
    dashboard, and to use it as the default route. This way, the user accessing the
    root of the application will always be welcomed at the same place, even if the
    application features the change. We also won't have any reference to the `contacts`
    feature except in the main `configure` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一种首先的可能性是简单地添加一个`home`组件，或者某种欢迎仪表板，并将其作为默认路径。这样，访问应用程序根目录的用户总是在同一个地方受到欢迎，即使应用程序功能发生了变化。除了在主要的`configure`函数中，我们也不会有任何关于`contacts`功能的引用。
- en: 'Alternatively, we could dynamically select the route to which the default route
    redirects. Since the `app` component''s `configureRouter` method is called during
    the component''s activation lifecycle, the feature has already been configured
    at that time and its routes have already been added to the root router. We could
    simply take the router''s first navigation model entry and have the default route
    redirect to it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'Alternatively, we could dynamically select the route to which the default route
    redirects. Since the `app` component''s `configureRouter` method is called during
    the component''s activation lifecycle, the feature has already been configured
    at that time and its routes have already been added to the root router. We could
    simply take the router''s first navigation model entry and have the default route
    redirect to it:'
- en: '`src/app.js`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/app.js`'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The advantage of this solution is that the default route will always redirect
    to the first route displayed in the top menu, which is a reasonable behavior in
    most applications without a distinct home screen.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的优势在于，默认路径总是会重定向到顶部菜单中显示的第一个路径，这对于没有明显主页屏幕的绝大多数应用程序来说是一种合理的行为。
- en: However, if all features are removed from the application, the navigation model
    will be empty and this code will break. In such a case, having a distinct home
    page could save the day, although an application without any features but a simple
    home page would be pointless in most cases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果应用程序中移除了所有特性，导航模型将会为空，这段代码将会断裂。在这种情况下，拥有一个明确的主页可能能够挽救局面，尽管在大多数情况下，一个没有特性但有一个简单主页的应用程序是没有意义的。
- en: Implications
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 含义
- en: One of the main advantages of defining all application routes on the root router,
    via features or the `app` component, is that all routes are known to the root
    router, which means it can generate URLs for any route in the application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序中所有路由在根路由器上，通过特性或`app`组件的主要优点之一是，所有路由都被根路由器所知晓，这意味着它可以为应用程序中的任何路由生成URL。
- en: This distinction is not negligible when there are a lot of links across components
    and features. In such a case, using child routers and not being able to rely on
    the routers to generate most of the URLs is painful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件和特性之间存在大量链接时，这种区别不容忽视。在这种情况下，使用子路由器并且不能依赖路由器生成大部分URL是痛苦的。
- en: Why not both?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么不两者都使用呢？
- en: The two solutions we just explored both have their pros and cons. Using a child
    router feels like the right thing to do, mostly because it fixes an inconsistent
    behavior in the top menu, which bothers me maybe more than it deserves, but makes
    linking across features complicated. Additionally, it requires the declaration
    of a route leading to the contact's `main` component in the `app` component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚探索的这两种解决方案都有各自的优缺点。使用子路由器感觉是正确的事情，主要是因为它修复了顶部菜单的不一致行为，这让我感到烦恼，也许比它应得的还要多，但它使跨特性的链接变得复杂。此外，它需要在`app`组件中声明一个指向联系人`main`组件的路由。
- en: On the other hand, using a feature also feels right. Features have been designed
    specifically for such use cases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用特性也感觉是正确的。特性正是为这类用例设计的。
- en: 'Let''s try to merge both strategies: declaring a child router to handle the
    contact''s routes in a `main` component, and using a feature to add the route
    leading to this `main` component on the root router.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试合并这两种策略：在`main`组件中声明一个子路由器来处理联系人的路由，并使用一个特性在根路由器上添加到这个`main`组件的路由。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following code snippets are excerpts from this chapter's completed sample
    application, which can be found at `chapter-6/app`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是本章完成示例应用程序的摘录，可以在`chapter-6/app`中找到。
- en: 'If we keep the modifications we did when introducing a `contacts` feature in
    the previous section, this means we need to add a `main` component just like we
    did when we played with the child router:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保留上一节中引入`contacts`特性时所做的修改，这意味着我们需要像使用子路由器一样添加一个`main`组件：
- en: '`src/contacts/main.js`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/main.js`'
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, the feature''s `configure` function must be changed so it adds the route
    leading to the `main` component of `contacts`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须更改特性的`configure`函数，使其添加到`contacts`的`main`组件的路由：
- en: '`src/contacts/index.js`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/index.js`'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using this pattern, a new feature can easily be added without having to change
    anything other than loading it into the main `configure` function. The only case
    when you also need to change the `app` component is when changing the feature
    to which the default route redirects if you don't use the dynamic approach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，可以轻松添加新特性，而无需更改除了将其加载到主`configure`函数之外的其他内容。唯一需要更改`app`组件的情况是，当你不使用动态方法时，需要更改默认路由重定向到的特性。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I'm not advocating the use of this pattern in every Aurelia application. It
    adds complexity and, as such, should be used only when really needed. The main
    goal here was to show the possibilities the framework offers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是提倡在每一个Aurelia应用程序中都使用这种模式。它增加了复杂性，因此，只有真正需要时才应该使用。这里的主要目标是展示框架提供的可能性。
- en: Decoupling components
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦组件
- en: Deciding how components of a program depend on each other and communicate with
    one another is what design is all about. Designing an Aurelia application is no
    different. However, in order to make enlightened design choices, you need to know
    what techniques the framework offers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 决定一个程序的组件如何相互依赖和通信就是设计的核心。设计一个Aurelia应用程序也不例外。然而，为了做出明智的设计选择，你需要知道框架提供了哪些技术。
- en: 'There are typically four ways to make components communicate in an Aurelia
    application: using data binding, using remote services, using shared services,
    and using events.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Aurelia应用程序中，通常有四种方法可以使组件相互通信：使用数据绑定，使用远程服务，使用共享服务，和使用事件。
- en: Up to now, our application has mostly relied on data binding and on a remote
    service, our backend. The route components don't directly communicate with each
    other, but do so via the backend. Each route component retrieves the data it needs
    from the backend each time it is activated, then delegates any action performed
    by the user back to the backend. Additionally, route components are composed of
    other reusable components, and communicate with them using data binding.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序主要依赖于数据绑定和远程服务，即我们的后端。路由组件之间没有直接通信，而是通过后端进行通信。每个路由组件在激活时从后端检索所需的数据，然后将用户执行的任何操作委派给后端。此外，路由组件由其他可重用组件组成，并通过数据绑定与它们通信。
- en: 'In the following sections, we will start by quickly summarizing the techniques
    we have already used, then we will discuss the other techniques: events and shared
    services. In doing so, we will also heavily refactor our contact management application,
    so we can try a whole different architecture based on those techniques.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们首先快速总结我们已经使用的技术，然后我们将讨论其他技术：事件和共享服务。这样做的同时，我们也将对联系人管理应用程序进行大量重构，这样我们就可以尝试一种完全不同的基于这些技术的架构。
- en: As an experiment, we will first refactor our application so we can listen for
    and locally dispatch events sent by the backend when things happen. This way,
    any component that needs to react to such events can simply subscribe to the local
    event.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实验，我们首先重构应用程序，使其能够监听后端发送的事件并在本地分派这些事件。这样，任何需要对这类事件做出反应的组件都可以简单地订阅本地事件。
- en: Once this is done, we will use those local events to refactor our application
    further, this time toward real-time, multi-user synchronization. We will create
    a service that will load the list of contacts and then listen for change events
    to keep its contacts synchronized. We will refactor all route components so they
    retrieve their data from this local list of contacts instead of fetching it from
    the backend at each activation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，我们将利用这些本地事件进一步重构我们的应用程序，这次是朝着实时、多用户同步的方向。我们将创建一个服务，用来加载联系人列表，然后监听变更事件以保持联系人同步。我们将重构所有路由组件，使它们从本地联系人列表而不是每次激活时都从后端获取数据。
- en: 'The flow will be similar to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 流程将与以下类似：
- en: '![Decoupling components](img/image_06_005.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![解耦组件](img/image_06_005.jpg)'
- en: When a user performs an action, such as creating a new contact or updating an
    existing one, a command will be sent to the backend. This doesn't change. However,
    instead of reloading the whole dataset from the backend each time the contact
    list component is displayed, the application will simply display its local copy
    of the data because it will keep it up-to-date by listening for change events,
    which are emitted by the backend every time a command is sent.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户执行某个操作，比如创建一个新的联系人或更新一个现有的联系人时，一个命令将被发送到后端。这一点是不变的。然而，下次联系人列表组件显示时，应用程序将仅仅显示其本地的数据副本，因为它将通过监听由后端每次发送命令时发出的变更事件来保持其最新。
- en: This new design borrows some concepts from the **CQRS/ES** patterns. One advantage
    of this pattern is that the application will be notified instantly each time any
    user makes a change to the data, so the application is constantly synchronized
    with the state of the server.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新设计借鉴了**CQRS/ES**模式的一些概念。这种模式的一个优点是，每当任何用户对数据进行更改时，应用程序都会立即收到通知，因此应用程序不断地与服务器的状态保持同步。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'CQRS stands for Command and Query Responsibility Segregation, and ES stands
    for Event Sourcing. Defining those patterns being way outside the scope of this
    book, you can check what Martin Fowler has to say about them if you are curious:
    [http://martinfowler.com/bliki/CQRS.html](http://martinfowler.com/bliki/CQRS.html) and [http://martinfowler.com/eaaDev/EventSourcing.html](http://martinfowler.com/eaaDev/EventSourcing.html).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS代表命令和查询责任分离，ES代表事件源。由于定义这些模式超出了本书的范围，如果你对此感到好奇，可以去查看马丁·福勒（Martin Fowler）关于它们的说法：[http://martinfowler.com/bliki/CQRS.html](http://martinfowler.com/bliki/CQRS.html)
    和 [http://martinfowler.com/eaaDev/EventSourcing.html](http://martinfowler.com/eaaDev/EventSourcing.html)。
- en: Of course, this whole synchronization mechanism would require some form of conflict
    management in a production-ready application. Indeed, when a user is editing a
    contact, if another user makes a change to the same contact, the first user will
    see the form being updated on the fly and the new values overwrite his own changes.
    That would be bad. However, we will not go this far. Let's consider this as a
    proof of concept and an experiment on ways to make components communicate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在生产就绪的应用程序中，整个同步机制将需要某种形式的冲突管理。实际上，当一个用户正在编辑一个联系人时，如果另一个用户对同一个联系人进行更改，第一个用户将看到表单实时更新，新值覆盖他自己的更改。那是糟糕的。然而，我们不会深入探讨这个问题。让我们将这视为一个概念验证和一个关于使组件通信的实验。
- en: Using data binding
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据绑定
- en: The most common and simple way to make components communicate is through data
    binding. We have already seen plenty of examples of this; when we bound the `edit`
    component's `contact` property with the `form` component's `contact` bindable
    property, we made them communicate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使组件通信最常见且简单的方式是通过数据绑定。我们已经看到了很多这样的例子；当我们将`edit`组件的`contact`属性与`form`组件的`contact`可绑定属性绑定在一起时，我们就使它们进行了通信。
- en: 'Data binding allows the loose coupling of components within a template. Of
    course, it has some intrinsic limitations: binding is declared by the parent component
    and communication is limited to a single layer of components in the application
    tree. Making the communication go more than one level requires each component
    in the tree to be data-bound to its children. We can see this in the `photo` component,
    whose `files` property is bound to the `files` property of `file-picker`, which
    is in turn bound to the `file-drop-target` attribute, enabling communication across
    multiple layers of components.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定允许在模板内松散地耦合组件。当然，它有一些内在的限制：绑定是由父组件声明的，通信限于应用程序树中的一层组件。要使通信超过一个层次，需要树中的每个组件都与其子组件数据绑定。我们可以看到这在`photo`组件中，其`files`属性与`file-picker`的`files`属性绑定，后者又与`file-drop-target`属性绑定，从而使跨多层组件进行通信成为可能。
- en: It is also the more flexible way to make components communicate because it is
    extremely easy to change and because the dependency lies within the template,
    where the components themselves are declared and composed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是使组件通信更加灵活的方式，因为它非常容易更改，并且依赖关系存在于模板中，组件本身就是在那里声明和组合的。
- en: Using remote services
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用远程服务
- en: Another way to make components communicate is via a remote service. We have
    also used this technique a lot in our application. The application stores very
    little state; the backend is the actual repository of state.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使组件通信的另一种方式是通过远程服务。在我们的应用程序中，我们也大量使用了这种技术。应用程序存储非常少的状态；后端才是实际的状态库。
- en: 'In order to display a contact for modification, the `edition` component queries
    the backend for the contact''s data. When the user saves the contact''s modifications,
    an update command is sent to the backend, which applies the changes to its internal
    state. Then, when the application brings the user back to the contact''s details,
    the component queries a fresh copy of the contact''s data. The same happens when
    navigating to the contacts list: the backend is queried each time and the whole
    list of contacts is fetched every time.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示一个联系人的修改版本，`edition`组件向后端查询该联系人的数据。当用户保存联系人的修改时，向后端发送一个更新命令，后端将其应用于内部状态。然后，当应用程序将用户带回到联系人的详细信息时，组件查询联系人的最新数据副本。当导航到联系人列表时，也是同样的情况：每次都查询后端，并且每次都获取联系人列表的整个副本。
- en: This technique is very common. In such cases, an application considers its backend
    to be the sole source of the truth, and relies on it for everything. Such applications
    can be much simpler because things like business rules and the complex side effects
    of commands can be completely handled by the backend. The application is simply
    a rich user interface sitting on top of the backend.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术非常普遍。在这种情况下，应用程序认为其后端是唯一真实的数据来源，并依赖其后端处理一切。这样的应用程序可以更简单，因为业务规则和命令的复杂副作用可以完全由后端处理。应用程序只是一个富用户界面，位于后端之上。
- en: However, the downside of this technique is that the application is useless if
    the communication line goes down. In situations of network failure, or when the
    backend is irresponsive for some reason, the application doesn't work anymore.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技术的缺点是，如果通信线路中断，应用程序就变得无用。在网络故障或后端由于某种原因无法响应的情况下，应用程序就无法再工作。
- en: Using events
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件
- en: One design technique widely used to reduce coupling is the **publish**/**subscribe**
    pattern. When applying this pattern, components can subscribe to a message bus
    so they are notified when specific types of messages are sent. Other components
    can then use this same message bus to send messages, without knowing which components
    will handle them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛用于减少耦合的一种设计技术是**发布**/**订阅**模式。当应用这个模式时，组件可以订阅消息总线，以便在发送特定类型的消息时收到通知。其他组件可以使用这个相同的消息总线发送消息，而无需知道哪些组件将处理它们。
- en: Using this pattern, the various components don't have any dependency on each
    other. Instead, they all depend on the message bus, which acts like a kind of
    abstraction layer between them. Additionally, this pattern greatly increases the
    flexibility and extensibility of the design, as new components can very easily
    subscribe to existing message types without any need to change other components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，各个组件之间没有任何依赖关系。相反，它们都依赖于消息总线，它充当了它们之间的某种抽象层。此外，这种模式极大地提高了设计的灵活性和可扩展性，因为新组件可以非常容易地订阅现有消息类型，而无需更改其他组件。
- en: Aurelia offers, through its `aurelia-event-aggregator` library, an `EventAggregator`
    class, which can act as such a message bus. We will see how we can benefit from
    this class in the following section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia通过其`aurelia-event-aggregator`库提供了一个`EventAggregator`类，该类可以充当这样的消息总线。我们将在下一节中看到如何利用这个类。
- en: The event aggregator
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件聚合器
- en: The `aurelia-event-aggregator` library is part of the default configuration,
    so, by default, we don't need to install or load anything to use it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia-event-aggregator`库是默认配置的一部分，因此，默认情况下，我们不需要安装或加载任何内容就可以使用它。'
- en: 'This library exports the `EventAggregator` class, which exposes three methods:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库导出了`EventAggregator`类，该类暴露了三个方法：
- en: '`publish(name: string, payload?: any): void`: Publishes a named event along
    with an optional payload.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish(name: string, payload?: any): void`: 发布一个带有可选负载的命名事件。'
- en: '`subscribe(name: string, callback: function): Subscription`: Subscribes to
    a named event. The `callback` function will be called each time an event is published
    with the subscribed `name`. The `payload` passed to the `publish` method will
    be passed to the `callback` function as its first argument.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe(name: string, callback: function): Subscription`: 订阅一个命名的事件。当发布一个带有订阅的`name`的事件时，将调用`callback`函数。`publish`方法传递的`payload`将作为第一个参数传递给`callback`函数。'
- en: '`subscribeOnce(name: string, callback: function): Subscription`: Subscribes
    to a named event, but only once. The subscription will be automatically disposed
    the first time the event is published. The subscription is returned, so it can
    even be disposed manually before the event is ever published.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribeOnce(name: string, callback: function): Subscription`: 订阅一个命名的事件，但只有一次。当事件第一次发布时，订阅会自动被销毁。返回的订阅可以手动在事件发布之前就销毁。'
- en: The `Subscription` object returned by the `subscribe` and `subscribeOnce` methods
    has a single method, named `dispose`. This method simply removes the `callback`
    function from the registered handlers so it won't be called anymore when the event
    is published.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`和`subscribeOnce`方法返回的`Subscription`对象有一个单一的方法，名为`dispose`。这个方法简单地将`callback`函数从注册的处理程序中移除，这样当事件发布时它就不会再被调用。'
- en: 'For example, some component could publish an event named `something-happened`
    using the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，某个组件可以使用以下代码发布一个名为`something-happened`的事件：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the component's constructor will be injected with an `EventAggregator`
    instance, which is then stored on the component. Then, when the `doSomething`
    method is called, an event named `something-happened` is published on the event
    aggregator. The event's payload is an object with an `args` property, which contains
    the `args` parameter that was passed to the `doSomething` method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，组件的构造函数将被注入一个`EventAggregator`实例，然后将其存储在组件中。然后，当`doSomething`方法被调用时，会在事件聚合器上发布一个名为`something-happened`的事件。事件的负载是一个具有`args`属性的对象，该属性包含传递给`doSomething`方法的`args`参数。
- en: 'In order to react to this event, another component could subscribe to it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应这个事件，另一个组件可以对其进行订阅：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the other component's constructor is also injected with the event aggregator,
    which is stored on the component. When activated, the component starts listening
    for `something-happened` events, so it can write a log to the browser's console
    each time one is published. It also keeps a reference to the subscription, so
    it can `dispose` it and stop listening for the event when deactivated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，另一个组件的构造函数也被注入了事件聚合器，该事件聚合器存储在组件中。当激活时，组件开始监听`something-happened`事件，所以它可以在每次发布一个时向浏览器的控制台写入日志。它还保留了对订阅的引用，以便在停用时可以`dispose`它并停止监听该事件。
- en: Such a pattern is very common when working with the event aggregator in a component.
    Using it makes sure that components listen for events only when they are active.
    It also prevents memory leaks; indeed, a component cannot be garbage-collected
    if the event aggregator still holds a reference to it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在与事件聚合器在组件中工作时非常常见。使用它确保组件只在它们处于活动状态时监听事件。它还可以防止内存泄漏；实际上，如果事件聚合器仍然引用它，组件不能被垃圾回收。
- en: Extending an object with events
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展具有事件的对象
- en: In addition to the `EventAggregator` class, the `aurelia-event-aggregator` library
    also exports a function named `includeEventsIn`. It expects an object as its single
    argument.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`EventAggregator`类之外，`aurelia-event-aggregator`库还导出一个名为`includeEventsIn`的函数。它期望一个对象作为其单个参数。
- en: This function can be used to extend an object with the event aggregator's functionality.
    It will create an `EventAggregator` instance internally and add to the object
    a `publish`, a `subscribe`, and a `subscribeOnce` method, all delegating to this
    new `EventAggregator` instance's corresponding method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以用来扩展具有事件聚合器功能的对象。它将在内部创建一个`EventAggregator`实例，并向对象添加一个`publish`、一个`subscribe`和一个`subscribeOnce`方法，所有这些方法都委托给这个新的`EventAggregator`实例的对应方法。
- en: 'For example, by calling this function in a class constructor, you can make
    all instances of the class have their own local events. Let''s imagine the following
    class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过在类构造函数中调用这个函数，可以使所有类实例具有自己的本地事件。让我们想象以下类：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `something-happened` event can be subscribed directly on a `SomeModel`
    instance:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`something-happened`事件可以直接在`SomeModel`实例上订阅：'
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since each instance has its own private `EventAggregator` instance, the events
    won't be shared across the whole application or even across multiple instances.
    Instead, the events will be scoped to each instance individually.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个实例都有自己的私有`EventAggregator`实例，事件不会在整个应用程序之间或多个实例之间共享。相反，事件将单独每个实例范围内。
- en: Using event classes
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件类
- en: 'The `publish`, `subscribe`, and `subscribeOnce` methods can be used with named
    events, but they also support typed events. As such, the following signatures
    are also valid:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish`、`subscribe`和`subscribeOnce`方法可以使用命名事件，但它们也支持类型化事件。因此，以下签名也是有效的：'
- en: '`publish(event: object): void`: Publishes an event object. Uses the prototype
    of the object as the key to select the callback functions to call.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish(event: object): void`：发布一个事件对象。使用对象的prototype作为键来选择要调用的回调函数。'
- en: '`subscribe(type: function, callback: function): Subscription`: Subscribes to
    a type of event. The `callback` function will be called each time an event that
    is an instance of the subscribed `type` is published. The published event object
    itself will be passed to the `callback` function as its single argument.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe(type: function, callback: function): Subscription`：订阅一个事件类型。每次发布一个属于订阅`type`的事件实例时，`callback`函数将被调用。发布的事件对象本身将作为单个参数传递给`callback`函数。'
- en: '`subscribeOnce(type: function, callback: function): Subscription`: Subscribes
    to a type of event, but only once.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribeOnce(type: function, callback: function): Subscription`：订阅一个事件类型，但只有一次。'
- en: 'As an example, let''s imagine the following event class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，让我们想象以下事件类：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Publishing such an event would be done this way:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 发布此类事件将这样做：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we can imagine that the `eventAggregator` variable contains an instance
    of an `EventAggregator` class, and that the `newContact` variable contains some
    object representing a newly created contact.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以想象`eventAggregator`变量包含`EventAggregator`类的实例，`newContact`变量包含表示新创建联系人的一些对象。
- en: 'Subscribing to this event would be done like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅此事件将像这样进行：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the callback will be called each time a `ContactCreated` event is published,
    and its `e` argument will be the `ContactCreated` instance that was published.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每次发布一个`ContactCreated`事件时，回调将被调用，其`e`参数将是发布的`ContactCreated`实例。
- en: Moreover, the `EventAggregator` supports inheritance when working with event
    classes. This means that you can subscribe to an event base class and the callback
    function will be called each time any event class inheriting from this base class
    is published.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`EventAggregator`在处理事件类时支持继承。这意味着你可以订阅一个事件基类，每次有任何继承自这个基类的事件类发布时，回调函数都会被调用。
- en: 'Let''s go back to our previous example and add some event classes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前的例子，并添加一些事件类：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we define a class named `ContactEvent`, from which the `ContactCreated`
    class inherits.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`ContactEvent`的类，`ContactCreated`类从中继承。
- en: 'Now let''s imagine the two following subscriptions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下以下两个订阅：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After this code is executed, if an instance of `ContactEvent` is published,
    the text `Something happened to a contact` will be logged to the console.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，如果发布了一个`ContactEvent`实例，将在控制台记录文本`Something happened to a contact`。
- en: However, if an instance of `ContactCreated` is published, both texts `A contact
    was created` and `Something happened to a contact` will be logged to the console
    because the event aggregator will go up the prototype chain and try to find subscriptions
    for all ancestors. This feature can be pretty powerful when dealing with complex
    hierarchies of events.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果发布了一个`ContactCreated`实例，将在控制台记录文本`A contact was created`和`Something happened
    to a contact`，因为事件聚合器将遍历原型链并尝试找到所有祖先的订阅。当处理复杂的事件层次结构时，这个功能可能非常强大。
- en: Class-based events add some structure to messaging, as they force an event payload
    to respect a predefined contract. Depending on your style of programming, you
    may prefer using strongly-typed events instead of named events with untyped payloads.
    It fits particularly well for typed JS supersets such as TypeScript.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的事件为消息添加了一些结构，因为它们强制事件有效负载遵守一个预定义的合同。根据你的编程风格，你可能会更喜欢使用强类型事件而不是带有未类型载荷的命名事件。它特别适合于像TypeScript这样的强类型JS超集。
- en: Creating an interactive connection
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个互动连接
- en: The following being some kind of experiment, or proof of concept, I suggest
    that you somehow backup your application at this point, either by simply copying
    and pasting the project directory, or by creating a branch on your source control
    if you cloned the code from GitHub. This way, you'll be able to start back at
    the current point when you go on to the next chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容某种程度上是一种实验，或者是一个概念证明，我建议你在这一点上以某种方式备份你的应用程序，无论是简单地复制和粘贴项目目录，还是如果你从GitHub克隆了代码，就在你的源代码控制中创建一个分支。这样，当你继续下一章节时，你就能从当前点开始。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Additionally, the sample found at `chapter-6/samples/app- using-server-events`
    illustrates the application modified as depicted in the following sections. It
    can be used as a reference.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在`chapter-6/samples/app-using-server-events`找到的示例展示了应用程序按照以下章节修改后的样子。它可以作为参考。
- en: The backend we use accepts interactive connections in order to dispatch events
    to client applications. Using such an interactive connection, it can notify connected
    clients every time a contact is either created, updated, or deleted. To dispatch
    those events, the backend relies on the **WebSocket** protocol.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的后端接受互动连接，以便将事件分发给客户端应用程序。使用这种互动连接，它可以在每次创建、更新或删除联系时通知连接的客户端。为了分发这些事件，后端依赖于**WebSocket**协议。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The WebSocket protocol allows for long-lived, two-way connections between a
    client and a server. As such, it allows the server to send event-based messages
    to the connected clients.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议允许客户端与服务器之间建立长生命周期的、双向的连接。因此，它允许服务器向连接的客户端发送基于事件的消息。
- en: In this section, we will create a service named `ContactEventDispatcher`. This
    service will create a WebSocket connection with the backend and will listen for
    change events from the server to locally dispatch them through the application's
    event aggregator.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个名为`ContactEventDispatcher`的服务。这个服务将与后端创建一个WebSocket连接，并监听服务器发送的更改事件，以便通过应用程序的事件聚合器在本地分派它们。
- en: In order to create an interactive connection to the server, we will use the
    **socket.io** library.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与服务器创建一个互动连接，我们将使用**socket.io**库。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The socket.io library offers a client implementation and a node.js server for
    interactive connections, both supporting WebSocket and offering fallback implementations
    when WebSocket is not supported. The backend already uses this library to handle
    interactive connections from the application. It can be found at [http://socket.io/](http://socket.io/).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`库为交互式连接提供了客户端实现和node.js服务器，两者都支持WebSocket，并在WebSocket不受支持时提供回退实现。后端已经使用这个库来处理应用程序的交互式连接。它可以在[http://socket.io/](http://socket.io/)找到。'
- en: 'Let''s first install the `socket.io` client. Open a console in the project''s
    directory and run the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装`socket.io`客户端。在项目的目录中打开一个控制台，并运行以下命令：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, the new dependency must be added to the application''s bundle. In
    `aurelia_project/aurelia.json`, under `build`, then `bundles`, in the `dependencies`
    section of the bundle named `vendor-bundle.js`, add the following entry:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，新的依赖项必须添加到应用程序的捆绑包中。在`aurelia_project/aurelia.json`中，在`build`下的`bundles`中，在名为`vendor-bundle.js`的捆绑包的`dependencies`部分，添加以下条目：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now create the `ContactEventDispatcher` class. This class being a service,
    we will create it in the `contacts` feature''s `services` directory:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`ContactEventDispatcher`类。由于这个类是一个服务，我们将在`contacts`特性的`services`目录中创建它：
- en: '`src/contacts/services/event-dispatcher.js`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/services/event-dispatcher.js`。'
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This class requires an `EventAggregator` instance to be passed to its constructor
    and declares an `activate` method, which uses the `io` function imported from
    the `socket.io` client library to create a `connection` with the server using
    the `contactUrl` of `environment`. It then creates a new `Promise`, which is assigned
    to the `connecting` property and returned by the `activate` method. This `Promise`
    allows the monitoring of the state of the connection process to the backend, so
    callers can hook into it to react when the connection is established. In addition,
    the method also makes sure that only one `connection` to the backend is opened
    at any given time. If `activate` is called multiple times, the `connecting``Promise`
    is returned.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类需要一个`EventAggregator`实例作为其构造函数的参数，并声明了一个`activate`方法，该方法使用从`socket.io`客户端库中导入的`io`函数，使用`environment`的`contactUrl`与服务器创建一个`connection`。然后创建一个新的`Promise`，将其分配给`connecting`属性，并通过`activate`方法返回。这个`Promise`允许监控连接到后端的过程状态，因此调用者可以连接到它以在连接建立时做出反应。此外，该方法还确保在任何给定时间只打开一个到后端的`connection`。如果多次调用`activate`，则返回`connecting`
    `Promise`。
- en: When the backend receives a new connection, it sends the current list of contacts
    as an event named `contacts.loaded`. As such, once the `activate` method initializes
    the connection, it listens for this event to republish it on the event aggregator.
    In doing so, it also transforms the initial list of objects received from the
    server in an array of `Contact` objects. It finally resolves the `connecting``Promise`
    to notify the caller that the `activate` operation is completed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当后端接收到一个新的连接时，它会发送当前联系人列表作为一个名为`contacts.loaded`的事件。因此，一旦`activate`方法初始化连接，它就会监听这个事件，并在事件聚合器上重新发布它。这样做时，它还将从服务器接收的初始对象列表转换为`Contact`对象的数组。最后，它解决`connecting`
    `Promise`以通知调用者`activate`操作已完成。
- en: The class also exposes a `deactivate` method, which closes and clears the connection.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还暴露了一个`deactivate`方法，该方法关闭并清除连接。
- en: 'At this point, the dispatcher publishes a `contacts.loaded` event containing
    the current list of contacts when it starts. However, the backend can additionally
    send up to three types of events:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，当它开始时，分发器发布一个包含当前联系人列表的`contacts.loaded`事件。然而，后端还可以发送多达三种类型的事件：
- en: '`contact.created`, when a new contact is created'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact.created`，当创建新的联系人时。'
- en: '`contact.updated`, when a contact is updated'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact.updated`，当更新联系人时。'
- en: '`contact.deleted`, when a contact is deleted'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact.deleted`，当一个联系人被删除时。'
- en: The payload of each of those events has a `contact` property containing the
    contact on which the command was executed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件的每个负载都有一个`contact`属性，其中包含执行命令的联系人。
- en: 'Based on this information, we can modify the dispatcher so it listens for those
    events and republishes them locally:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，我们可以修改分发器，使其监听这些事件并在本地重新发布它们：
- en: '`src/contacts/services/event-dispatcher.js`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/services/event-dispatcher.js`。'
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we add event handlers, so that, when the backend sends either a `contact.created`
    event, a `contact.updated` event, or a `contact.deleted` event, the impacted contact
    is transformed into a `Contact` object, and the event is republished on the application's
    event aggregator.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加事件处理程序，以便当后端发送`contact.created`事件、`contact.updated`事件或`contact.deleted`事件时，受影响的信息条目被转换为`Contact`对象，并将事件重新发布到应用程序的事件聚合器上。
- en: Once this is ready, we need to `activate` the event listener. We will do this
    in the `contacts` feature's `configure` function. However, the dispatcher uses
    the `Contact` class to transform the list of objects received from the backend
    into `Contact` instances when initiating the connection. Since the `Contact` class
    relies on the `aurelia-validation` plugin to be loaded, and since we can't be
    sure that the plugin is indeed loaded when our `configure` function is called,
    we can't use `Contact` here, otherwise an error could be thrown when initializing
    the validation rules of `Contact`. How can we do it, then?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好，我们需要在`contacts`特性的`configure`函数中`activate`事件监听器。然而，分发器在初始化连接时使用`Contact`类将来自后端的对象列表转换为`Contact`实例。由于`Contact`类依赖于`aurelia-validation`插件的加载，并且我们不能确定当我们的`configure`函数被调用时插件确实已加载，因此我们在这里不能使用`Contact`，否则在初始化`Contact`的验证规则时可能会抛出错误。我们该怎么办呢？
- en: 'The Aurelia framework configuration process supports post-configuration tasks.
    Such tasks are simply functions that will be called after all plugins and features
    are loaded, and can be added using the `postTask` method of the framework''s configuration
    object, which is passed to the `configure` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia框架配置过程支持后配置任务。这样的任务只是将在所有插件和功能都加载完成后调用的函数，可以通过将配置对象的`postTask`方法传递给`configure`函数来添加：
- en: '`src/contacts/index.js`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/index.js`'
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we add a post-configuration task, which activates the dispatcher once
    all plugins and features have been loaded. Additionally, since post-configuration
    tasks support `Promise`s, we can return the `Promise` returned by `activate`,
    so we are sure that the interactive connection with the backend is completed and
    that the initial contacts are loaded when the framework's bootstrapping process
    completes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个后配置任务，当所有插件和功能都加载完成后激活分发器。此外，由于后配置任务支持`Promise`s，我们可以返回由`activate`返回的`Promise`，因此我们确信当框架的引导过程完成后，与后端的交互式连接已完成，并且初始联系人已加载。
- en: Adding notifications
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加通知
- en: At this point, our `main` component of `contacts` listens for server events,
    and dispatches them locally. However, we still don't do anything with those events.
    Let's add some notifications that tell the user when something happens on the
    server.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们的`main`组件的`contacts`列表监听服务器事件，并在本地分发它们。然而，我们仍然对那些事件不做任何事情。让我们添加一些通知，当服务器上发生某些事情时告诉用户。
- en: 'We will add a notification system that will let the user know every time the
    backend sends a change event. As such, we will use a library called `humane.js`,
    which can be found at [http://wavded.github.io/humane-js/](http://wavded.github.io/humane-js/).
    You can install it by opening a console window in the project directory and by
    running the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个通知系统，每当后端发送一个变更事件时，都会让用户知道。因此，我们将使用一个名为`humane.js`的库，该库可以在[http://wavded.github.io/humane-js/](http://wavded.github.io/humane-js/)找到。您可以通过在项目目录中打开控制台窗口并运行以下命令来安装它：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once it''s completed, you must also let the bundler know about this library.
    In `aurelia_project/aurelia.json`, under `build`, then `bundles`, in the `dependencies`
    section of the bundle named `vendor-bundle.js`, add the following snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，您还必须让打包工具知道这个库。在`aurelia_project/aurelia.json`中，在`build`下的`bundles`中，在名为`vendor-bundle.js`的包的`dependencies`部分，添加以下代码片段：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to isolate usage of this library, we will create a custom element
    around it:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隔离这个库的使用，我们将围绕它创建一个自定义元素：
- en: '`src/contacts/components/notifications.js`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/notifications.js`'
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This custom element first requires an `EventAggregator` instance and a `Humane`
    object to be injected into its constructor. When it is `attached` to the DOM,
    it subscribes to the `contact.created`, `contact.updated`, and `contact.deleted`
    events to display proper notifications when they are published. It also stores
    the subscriptions returned by the `subscribe` method of `EventAggregator` calls
    in an array, so it is able to `dispose` those subscriptions when it is `detached`
    from the DOM.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义元素首先需要一个`EventAggregator`实例和一个`Humane`对象被注入到其构造函数中。当它被`attached`到DOM时，它会订阅`contact.created`、`contact.updated`和`contact.deleted`事件，在发布时显示适当的通知。它还存储由`EventAggregator`的`subscribe`方法返回的订阅在一个数组中，这样它就可以在从DOM中`detached`时释放这些订阅。
- en: In order to use this custom element, we need to modify the template of the feature's
    `main` component by adding a `require` statement and an instance of this element.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个自定义元素，我们需要通过添加一个`require`语句和一个这个元素的实例来修改功能`main`组件的模板。
- en: 'However, the `main` template is growing larger, so let''s remove the `inlineView`
    decorator from the view-model class and move the template to its own file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`main`模板正在变得更大，所以让我们从视图模型类中移除`inlineView`装饰器，并将模板移动到其自己的文件中：
- en: '`src/contacts/main.html`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/main.html`'
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, we need to add the stylesheet for one of themes of `humane.js`, so
    the notifications are correctly styled:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加`humane.js`的一个主题样式的样式表，以便通知被正确样式化：
- en: '`index.html`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you run the application at this point and modify a contact, you'll see that
    the notification doesn't show. What did we miss?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在这个时候运行应用程序并修改一个联系人，您会看到通知没有显示。我们错过了什么？
- en: Getting out of the pitfall
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摆脱陷阱
- en: This is one tricky gotcha that I've experienced a couple of times now when integrating
    libraries with Aurelia. It is caused by the `aurelia-app` attribute being on the
    `body` element.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在将库与Aurelia集成时遇到的一个棘手的问题。这是由于`aurelia-app`属性在`body`元素上引起的。
- en: Indeed, some libraries add elements to the `body` when they are loaded. This
    is what `humane.js` does. When it is loaded, it creates a DOM subtree, which it
    will use as a container to display notifications, and appends it to the `body`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，有些库在加载时会向`body`添加元素。`humane.js`就是这样做的。当它加载时，它会创建一个DOM子树，将其作为显示通知的容器，并将其附加到`body`上。
- en: However, when Aurelia's bootstrapping process ends and the application gets
    rendered, the content of the element hosting the `aurelia-app` attribute gets
    replaced by the rendered view of the `app` component. This means that the DOM
    element's `humane.js` will try to use to display notifications that won't be on
    the DOM anymore. Oops.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当Aurelia的引导过程结束，应用程序被渲染时，包含`aurelia-app`属性的元素的內容会被替换为`app`组件的渲染视图。这意味着DOM元素的`humane.js`将尝试使用它来显示通知，但这些通知将不再在DOM上。哎呀。
- en: 'Fixing this is pretty simple. We need to move the `aurelia-app` attribute to
    another element, so the content of the `body` element won''t be wiped out when
    our application is rendered:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题相当简单。我们需要将`aurelia-app`属性移动到另一个元素，以便在应用程序被渲染时，`body`元素的內容不会被清除：
- en: '`index.html`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, if you refresh your browser and then perform some action, such as updating
    a contact, you should see a notification being displayed for a couple of seconds
    at the top of the viewport.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您刷新浏览器然后执行某些操作，例如更新一个联系人，您应该会在视图区域的顶部看到一个通知显示几秒钟。
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a rule of thumb, I never put the `aurelia-app` attribute directly in the
    `body`. I learnt this lesson by spending too much time, on multiple occasions,
    trying to figure out why an external library I had integrated into my project
    didn't work.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，我从不直接在`body`中放置`aurelia-app`属性。我通过多次花费太多时间试图弄清楚为什么我项目中集成的外部库不起作用而学到了这个教训。
- en: Simulating a multi-user scenario
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟多用户场景
- en: At this point, our application is able to notify the user when a change occurs
    on the server, even when this is done by another user. Let's test a multi-user
    scenario. To do this, the application must be run using something other than Aurelia's
    CLI because, at the time of writing, the browser sync feature interferes with
    our synchronization mechanism.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们的应用程序能够在服务器上发生更改时通知用户，即使这是由另一个用户完成的。让我们测试一个多用户场景。为此，应用程序必须使用除了Aurelia的CLI之外的东西运行，因为截至撰写本文时，浏览器同步功能会与我们的一致性机制发生冲突。
- en: 'The simplest solution is to install the `http-server` node module, if you don''t
    already have it installed, by running the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是安装`http-server`节点模块，如果你还没有安装，可以通过运行以下命令来安装：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then you can build our application:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以构建我们的应用程序：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once this command has completed, you can launch a plain HTTP server:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个命令完成，你可以启动一个简单的HTTP服务器：
- en: '[PRE38]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can then open the application in two browser windows and put them side by
    side. In one, perform actions such as creating a new contact or updating an existing
    one. You should see the notification pop up in both windows.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在两个浏览器窗口中打开应用程序，并将它们并排放置。在一个窗口中执行创建新联系人或更新现有联系人的操作。你应该会在两个窗口中都看到通知弹出。
- en: Using shared services
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用共享服务
- en: At the moment, our application is mostly stateless, since every route component
    loads its data from the server. There is no route component that depends on a
    global state, outside of its own scope.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序大部分是无状态的，因为每个路由组件都从服务器加载其数据。没有路由组件依赖于其范围之外的全局状态。
- en: However, sometimes an application needs to store a global state. This state
    is typically managed by some kind of service, which can either be propagated through
    components using data binding or injected into them using the dependency injection
    system, in which case the dependency is declared and controlled in the JS code,
    not in a template.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时应用程序需要存储一个全局状态。这个状态通常由某种服务管理，可以通过数据绑定将状态传播给组件，或者通过依赖注入系统将它们注入，在这种情况下，依赖关系在JS代码中声明和控制，而不是在模板中。
- en: There are plenty of scenarios where locally storing the state is beneficial,
    or even required. It can allow the saving of bandwidth and reducing the number
    of calls to the backend. If you want to make your app available offline, you'll
    probably need to locally store a state at some point.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多场景在本地存储状态是有利的，甚至是必需的。它可以让节省带宽，减少对后端的调用。如果你想让你的应用离线可用，你可能需要在某个时候本地存储一个状态。
- en: In this section, we will refactor our application by creating a service that
    will be shared among all route components and that will allow them to access the
    same local data. This service will act as a local data store, and will rely on
    the events published by the dispatcher we created in the previous section to both
    initialize its state and stay synchronized with the server's state.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个服务来重构我们的应用程序，这个服务将被所有路由组件共享，并允许它们访问相同的本地数据。这个服务将作为本地数据存储，并依赖于我们在上一节中创建的分发器发布的事件来初始化其状态并与服务器的状态保持同步。
- en: Creating an in-memory store
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建内存中的存储
- en: 'We will start our refactoring by creating a new service that we''ll call `ContactStore`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个名为`ContactStore`的新服务来开始我们的重构：
- en: '`src/contacts/services/store.js`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/services/store.js`'
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This store first declares a `contacts` property, which is assigned an empty
    array. This array will contain the local list of contacts. Next, the class expects
    an `EventAggregator` instance to be injected into its constructor, which is then
    stored on the `eventAggregator` property.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储首先声明了一个`contacts`属性，它被赋值为一个空数组。这个数组将包含联系人列表的本地副本。接下来，该类期望一个`EventAggregator`实例在其构造函数中被注入，然后存储在`eventAggregator`属性上。
- en: The class then defines an `activate` method, which will subscribe to some events
    on the aggregator, and a `deactivate` method, which disposes of the subscriptions.
    This is the same pattern we implemented when we wrote the notifications component
    earlier.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该类定义了一个`activate`方法，它将在聚合器上订阅一些事件，以及一个`deactivate`方法，它将解除这些订阅。这是我们编写通知组件时实现的模式。
- en: The `ContactStore` also exposes a `getById` method, which expects a contact
    `id` as its argument, and which either returns a rejected `Promise` if the contact
    is not found or a `Promise` resolved using a copy of the contact if it is. This
    method will be used by some route components in place of the gateway's `getById`
    method, so it mimics its signature to minimize the amount of changes we have to
    do.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactStore`还暴露了一个`getById`方法，该方法期望一个联系人的`id`作为其参数，如果找不到联系人，则返回一个拒绝的`Promise`，如果找到了，则返回一个使用联系人的副本解决的`Promise`。这个方法将被一些路由组件用来代替网关的`getById`方法，所以它模仿了其签名，以最小化我们必须做的更改。'
- en: 'Now the `activate` method needs to have some event subscriptions added so it
    can react to them:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`activate`方法需要添加一些事件订阅，以便它可以响应它们：
- en: '`src/contacts/services/store.js`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/services/store.js`'
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, the `activate` method subscribes to the various events published by the
    dispatcher so it can keep its list of contacts up-to-date:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`activate`方法订阅了分发器发布的各种事件，以便它可以保持其联系人列表的最新：
- en: When it receives a `contacts.loaded` event, it resets the `contacts` array using
    the new list of contacts contained in the event's payload
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当他接收到`contacts.loaded`事件时，它使用事件负载中包含的新联系人列表重置`contacts`数组
- en: When it receives a `contact.created` event, it first makes sure that the contact
    doesn't already exist in the array using its `id` and, if not, adds it
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当他接收到`contact.created`事件时，它首先确保联系人不已经在数组中使用其`id`，如果不在，则添加它
- en: When it receives a `contact.updated` event, it retrieves the local copy of the
    updated contact still using its `id` and updates all of its properties
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当他接收到`contact.updated`事件时，它使用其`id`检索更新后的联系人的本地副本并更新其所有属性
- en: When it receives a `contact.deleted` event, it finds the contact's index in
    the array, always using its `id`, and splices it out
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当他接收到`contact.deleted`事件时，他在数组中找到联系人的索引，总是使用它的`id`，并把它拿出来
- en: This store is now able retrieve a local copy of the list of contacts from the
    server, and then keep itself up-to-date.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储现在能够从服务器检索联系人的本地列表，并保持自己最新。
- en: Using the store
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用存储
- en: We can now modify all the route components that perform read operations so they
    use this store instead of the gateway. Let's walk through them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改所有执行读操作的路由组件，使它们使用这个存储而不是网关。让我们逐一进行。
- en: First, the `creation` component doesn't need to change.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`creation`组件不需要更改。
- en: 'Next, the `details`, the `edition`, and the `photo` components must be modified.
    For each of them, we need to:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须修改`details`、`edition`和`photo`组件。对于它们中的每一个，我们需要做的是：
- en: Import the `ContactStore` class
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ContactStore`类
- en: Add the `ContactStore` class to the `inject` decorator so it is injected in
    the constructor
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`inject`装饰器中添加`ContactStore`类，以便在构造函数中注入
- en: Add a `store` argument to the constructor
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加一个`store`参数
- en: In the constructor, assign the `store` argument to a `store` property
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将`store`参数分配给`store`属性
- en: In the `activate` method, replace the call to the `getById` method of `gateway`
    with a call to the `store`
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activate`方法中，用对`store`的调用替换对`gateway`的`getById`方法的调用
- en: 'Here''s what the `details` component looks like after those changes:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更改后的`details`组件的样子：
- en: '`src/contacts/components/details.js`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/details.js`'
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice how the `delete` operation is still called on the `gateway`. Indeed,
    all write operations are still performed using the `ContactGateway` class. However,
    all read operations will now be performed using the `ContactStore` service, as
    it keeps a synchronized, local copy of the server's state.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`gateway`上`delete`操作仍然被调用。实际上，所有的写操作仍然使用`ContactGateway`类执行。然而，所有的读操作现在将使用`ContactStore`服务执行，因为它保持了与服务器状态同步的本地副本。
- en: 'As such, and lastly, the `list` component must also be modified. We need to:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后，`list`组件也必须进行修改。我们需要做的是：
- en: Replace the `ContactGateway` import for a `ContactStore` import
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ContactGateway`导入更改为`ContactStore`导入
- en: Replace the dependency on the `ContactGateway` class with a dependency on the
    `ContactStore` class on the `inject` decorator
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`inject`装饰器中将`ContactGateway`类的依赖更改为`ContactStore`类
- en: Remove the `contacts` property declaration and initialization
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`contacts`属性声明和初始化
- en: Replace the constructor's `gateway` argument with a `store` argument
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造函数的`gateway`参数替换为`store`参数
- en: In the constructor, remove the assignation of the `gateway` property by assigning
    the `store` argument's `contacts` property to `this.contacts`
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，通过将`store`参数的`contacts`属性分配给`this.contacts`来删除`gateway`属性的分配
- en: Remove the `activate` callback method
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`activate`回调方法
- en: 'The new `list` component is now stripped down to its minimum:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`list`组件现在已经简化为最小：
- en: '`src/contacts/components/list.js`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/components/list.js`'
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can see here the state sharing at its core. The `contacts` property of `store`
    contains an array that is the actual state holder. It is this array that, being
    shared among components through the `ContactStore` instance, allows the same data
    to be accessed from the different screens. As such, this array should never be
    overwritten, only mutated, so Aurelia's binding system can work with it seamlessly.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到状态共享的核心。`store`的`contacts`属性包含一个数组，它是实际的状态持有者。正是这个数组，通过`ContactStore`实例在组件之间共享，使得相同的数据可以从不同的屏幕访问。因此，这个数组绝不应该被覆盖，只能被变异，以便Aurelia的绑定系统能够与之无缝工作。
- en: 'However, we still need to `activate` the `ContactStore` instance somewhere,
    so it can start listening for change events. Let''s do this in the feature''s
    `configure` function, just before we activate the event dispatcher:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要在某个地方`activate``ContactStore`实例，以便它开始监听变更事件。让我们在特性的`configure`函数中，在我们激活事件分发器之前这样做：
- en: '`src/contacts/index.js`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/index.js`'
- en: '[PRE43]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we force the DI container to initialize the single `ContactStore` instance
    by retrieving it, then we simply `activate` it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过检索来强制DI容器初始化唯一的`ContactStore`实例，然后简单地`activate`它。
- en: Lastly, we could go and delete the `getAll` and `getById` methods from the `ContactGateway`
    class, since they are not used anymore.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以去删除`ContactGateway`类中的`getAll`和`getById`方法，因为它们已经不再使用了。
- en: At this point, if you run the application, everything should still work as before.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，如果你运行应用程序，一切应该仍然和以前一样工作。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Designing a valuable application is almost never simple. It is always a matter
    of juggling many factors, deciding what pros are beneficial and what cons are
    acceptable:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 设计有价值的应用程序几乎从来不是简单的。它总是关于权衡许多因素，决定哪些利弊是有益的，哪些是可以接受的：
- en: A child router makes the top menu's active item behave better, while root routes
    do not.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子路由使得顶部菜单的活动项目表现更好，而根路由则不然。
- en: A child router makes it difficult to have links across features, while root
    routes make it easy.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子路由使得跨特性拥有链接变得困难，而根路由则使之变得容易。
- en: Features help to isolate and integrate a domain or technical feature in an Aurelia
    application.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性有助于在Aurelia应用程序中隔离和集成领域或技术特性。
- en: Data binding is the simplest way to connect components together. However, it
    has limitations.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定是连接组件的最简单方法。然而，它有局限性。
- en: Using a remove service to communicate data is another very simple way to make
    components communicate. It can, however, be bandwidth intensive, can put some
    load on the remote service, and makes the remote server a single point of failure,
    rendering the application unusable if the user has no network connection or if
    the remote service goes down.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个删除服务来通信数据是让组件通信的另一种非常简单的方法。然而，它可能会占用带宽，可能会对远程服务造成一些负载，并且使远程服务器成为单点故障，如果用户没有网络连接或远程服务宕机，应用程序将无法使用。
- en: Sharing services between components to make them communicate is versatile, but
    adds complexity.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务共享给组件以实现通信是多功能的，但增加了复杂性。
- en: Using events to make components communicate increases extensibility and decoupling,
    but also increases complexity. Discipline is required in order to make events
    easily discoverable in a large application.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件来让组件进行通信增加了可扩展性和解耦，但也增加了复杂性。在大型应用程序中，需要有纪律性，以便事件容易被发现。
- en: Some of those pros and cons may seem trivial, and I would tend to agree that
    a menu item not highlighted all the time is no big deal in most cases, but on
    some projects it may be unacceptable. The best I can do is to give you the tools
    to make your own informed decisions.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有些利弊可能看起来很微小，我倾向于同意，在大多数情况下，一个菜单项不是一直高亮显示并不是什么大问题，但在一些项目中这可能无法接受。我所能做的就是给你提供工具，让你自己做出明智的决策。
