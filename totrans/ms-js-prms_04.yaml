- en: Chapter 4. Implementing Promises
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. 实现承诺
- en: In the last chapter, [Chapter 3](ch03.html "Chapter 3. The Promise Paradigm"),
    *The Promise Paradigm*, we have seen how promise and its theories were fabricated
    together to form a whole new amazing picture of the software engineering paradigm,
    and especially in today's modern asynchronous application development life cycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，[第 3 章](ch03.html "第 3 章. 承诺范式")，*承诺范式*，我们看到了承诺及其理论是如何结合在一起，形成软件工程范式的一个全新的惊人的图片，尤其是在当今现代异步应用开发生命周期中。
- en: In this chapter, we will start experimenting on how this concept can take shape
    by implementing promises in real time. Why do we need to see its implementation?
    The answer to this question is quite simple; we need to see how the concept we
    have developed so far is true and how much of this concept is really applicable.
    Also, with these little implementations of promises, we will plot the base of
    our foundation to use promise in other technologies in later chapters. So, let's
    see how we will go about with this implementation phase.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始实验如何通过实现承诺来形成这个概念。为什么我们需要了解它的实现？这个问题的答案很简单；我们需要了解我们迄今为止开发的这个概念是否真实，以及这个概念有多少是真正适用的。另外，通过这些承诺的小实现，我们将绘制我们基础的基石，以便在后面的章节中在其他技术中使用承诺。那么，让我们来看看我们将如何进行这个实现阶段。
- en: How to implement promises
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现承诺
- en: So far, we have learned the concept of promise, its basic ingredients, and some
    of the basic functions it has to offer in nearly all of its implementations, but
    how are these implementations using it? Well, it's quite simple. Every implementation,
    either in the language or in the form of a library, maps the basic concept of
    promises. It then maps it to a compiler/interpreter or in code. This allows the
    written code or functions to behave in the paradigm of promise, which ultimately
    presents its implementations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了承诺的概念、它的基本组成部分以及它在几乎所有实现中提供的一些基本功能，但是这些实现是如何使用它的呢？嗯，其实很简单。每种实现，无论是作为一种语言还是一种库，都会映射承诺的基本概念。然后，它将其映射到一个编译器/解释器或代码中。这使得编写的代码或函数以承诺的范式行为，最终呈现出它的实现。
- en: Promises are now part of the standard package for many languages. The obvious
    thing is that they have implemented it in their own way as per the need. We will
    be examining more on how these languages are implementing the concept of promise
    in detail in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺现在已经成为了许多语言的标准包的一部分。显而易见的是，它们根据自己的需求以自己的方式实现了它。我们将在本章中详细探讨这些语言是如何实现承诺的概念。
- en: Implementations in Java
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Java 中的实现
- en: Java is among the world's favorite and most admired programming languages and
    is used in millions of devices across the globe. There is no need to say anything
    further about Java, except that it's the first choice of engineers when it comes
    to creating application software that uses multithreaded and controlled asynchronous
    patterns and behaviors. Java is one of the few languages that has implemented
    asynchronous behavior by default in its compiler, which helps programmers to write
    robust, scalable, and maintainable pieces of software.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是世界上最受欢迎和最受尊敬的编程语言之一，并在全球各地的数百万设备上使用。除了 Java 之外，无需再说什么，它是工程师在创建使用多线程和受控异步模式和行为的应用程序软件时的首选。Java
    是少数几种默认在编译器中实现异步行为的语言之一，这有助于程序员编写健壮、可扩展和可维护的软件。
- en: The util package of Java
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 的 util 包
- en: Naturally, Java has more acceptability for the concept of promise and its implementation.
    There are many implementations in the package of `java.util.concurrent`, regarding
    promise and its implementations. We have handpicked some of the interfaces and
    classes that are helping out in implementing promises or nearly matching the concept.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，Java 对承诺的概念及其实现有更广泛的接受。在 `java.util.concurrent` 包中，关于承诺及其实现有很多实现。我们挑选了一些有助于实现承诺或与该概念相匹配的接口和类。
- en: The mechanics of Java to implement a promise
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java 实现承诺的机制
- en: Within the `java.util.concurrent` package, there are a number of interfaces
    and classes that will help us to write concurrent and asynchronous code, but there
    are a few particular interfaces and libraries that are specific to this promise/future
    implementation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.util.concurrent` 包中，有许多接口和类可以帮助我们编写并发和异步代码，但有一些特定的接口和库是专门用于这个承诺/未来的实现。
- en: The `java.util.concurrent` package is home to concurrent programming (as the
    name says) and is the home of few small standardized extensible frameworks. This
    also helps in implementing some of the core classes, which in normal conditions,
    are hard to work with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 包是并发编程（正如其名）的家园，也是几个小型标准化扩展框架的家园。它还帮助实现一些在正常情况下难以工作的核心类。'
- en: The core components of java.util.concurrent
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 核心组件'
- en: 'The `java.util.concurrent` package has many classes and components, but some
    of the core components that make this particular package more adaptable to work
    are:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 包中包含许多类和组件，但使其特别适合于并发工作的核心组件包括：'
- en: '![The core components of java.util.concurrent](img/5500OS_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![The core components of java.util.concurrent](img/5500OS_04_01.jpg)'
- en: Core components of the Java util.concurrent package
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 包的核心组件'
- en: Executor
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Executor
- en: '`Executor` is a simple standardized interface, which is commonly used to define
    custom threaded subsystems. These subsystems include the thread pools, asynchronous
    I/O, and task-based lighter frameworks.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor` 是一个简单的标准化接口，通常用于定义自定义线程子系统。这些子系统包括线程池、异步 I/O 和基于任务的轻量级框架。'
- en: Tasks created in the thread can either be executed in "the same task-execution
    thread" or in a new thread; this may also be executed in the thread calling execute
    sequentially or concurrently. Whichever thread the execute pattern task adopts
    is purely based on the concrete `Executor` class used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程中创建的任务可以在线程中执行“相同的任务执行线程”或在新线程中执行；这也可以在调用执行的线程中顺序或并发执行。无论执行模式任务采用哪个线程，都完全取决于使用的具体
    `Executor` 类。
- en: The `ExecutiveService` interface provides a fully stacked asynchronous tasks
    framework. This interface is for a number of tasks of the pool, which includes
    the controlled shutdown of `Executor`, managing of different in-pool cues, and
    scheduling of tasks. There are a few more associates that work with `ExecutiveService`
    to add support to delay the periodic and periodic task executing. One such associate
    is `ScheduledExecutorService`, a subinterface that works with the `ExecutiveService`
    interface in managing the delayed and periodic tasks executing whenever called
    upon.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutiveService` 接口提供了一个完全堆叠的异步任务框架。这个接口是为了处理池中的多个任务，包括控制 `Executor` 的关闭、管理不同池中的队列以及任务的调度。还有一些与
    `ExecutiveService` 一起工作以添加对延迟和周期性任务执行支持的关联。其中之一是 `ScheduledExecutorService`，它是一个子接口，与
    `ExecutiveService` 接口一起管理延迟和周期性任务的执行。'
- en: There is another interface called the `ExecutorService` interface, which provides
    methods to arrange the execution of any function that is expressed as callable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个接口称为 `ExecutorService` 接口，它提供方法来安排任何表示为可调用函数的执行。
- en: Queues
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 队列
- en: When it comes to the queue, the only thought that first emerges is the pattern
    of **First In First Out** (**FIFO**). Just as other languages apply this data
    structure in their own ways, Java treats it as an efficient and scalable thread-safe,
    nonblocking FIFO queue by employing the `ConcurrentLinkedQueue` class from its
    `java.util.concurrent` package. In the same package, five implementations support
    the `BlockingQueue` interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到队列时，首先浮现的想法是**先进先出**（**FIFO**）模式。就像其他语言以自己的方式应用这种数据结构一样，Java 通过使用来自其 `java.util.concurrent`
    包的 `ConcurrentLinkedQueue` 类，将其视为一个高效、可扩展的线程安全、非阻塞的 FIFO 队列。在同一包中，五种实现支持 `BlockingQueue`
    接口。
- en: The `BlockingQueue` interface is a queue, which has an advanced wait mechanism.
    This holds the queue to further get into processing until all the previous processing
    is done. This also waits for the space to make the queue available when storing
    an element.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingQueue` 接口是一个队列，具有高级的等待机制。在所有之前的处理完成之前，它保持队列不进入进一步处理。在存储元素时，它也等待空间使队列可用。'
- en: 'The five implementations of the `BlockingQueue` interface are listed as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `BlockingQueue` 接口的五种实现：
- en: '`LinkedBlockingQueue`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedBlockingQueue`'
- en: '`ArrayBlockingQueue`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayBlockingQueue`'
- en: '`SynchronousQueue`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SynchronousQueue`'
- en: '`PriorityBlockingQueue`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`'
- en: '`DelayQueue`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DelayQueue`'
- en: We will discuss some of these relevant implementations in the following section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论一些这些相关实现。
- en: Timing
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Timing
- en: Since `util` is the utilities package, it has controls in the form of classes
    and interfaces that help engineers to make use of their daily routine stuff. One
    such package is the timing of a method or interface. This is to perform certain
    instructed operations, and eventually, they time out themselves once the operation
    is done.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`util`是工具包，它有以类和接口形式存在的控制，帮助工程师使用他们日常例行的事情。这样一个包就是方法或接口的时间。这是为了执行某些指令操作，最终，当操作完成时，它们会自己超时。
- en: Most of us are already aware of the importance of session creation and session
    timeout, especially those of us who are programmers for the Web. Session tracking
    is a subject in its own and doesn't really link that much from the structure of
    this chapter, so we will return our focus to the topic of timing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的大多数人已经意识到会话创建和会话超时的重要性，特别是那些从事Web编程的程序员。会话跟踪是一个独立的主题，与本章的结构并没有太大关系，因此我们将把重点回到时间话题上。
- en: This packing is like a timing belt of Java programs. In any engine, the role
    of a timing belt is to make sure that certain mechanical operations are done within
    a specified amount of time; it is the same as with this package. This controls
    the in-time and out-time of functions and also the definite/indefinite waits.
    The point to remember is that all these methods use the time out in every case.
    This helps threads define the amount of time a method spends within a thread pool
    and saves the actual program to perform with scalability.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个打包就像是Java程序的定时带。在任何引擎中，定时带的作用是确保某些机械操作在指定时间内完成；这个包也是如此。它控制函数的时效性和非确定性等待。需要记住的是，所有这些方法在每种情况下都使用超时。这有助于线程定义方法在线程池中花费的时间，并节省实际程序以实现可伸缩性。
- en: Synchronizers
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步器
- en: Java provides a low-level thread creation and execution so that programmers
    can easily handle and modify the thread-level control. In earlier versions, the
    controlling of threads was considered the hardest topic to deal with, as there
    was much of the manual control than automation of threads and their synchronization.
    At this time, Java was much more advanced in controlling multiple threads than
    its competing languages, but still playing with threads was a fairly hard task
    for Java engineers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一个低级别的线程创建和执行，以便程序员可以轻松地处理和修改线程级控制。在早期版本中，线程的控制被认为是处理最困难的话题，因为与线程的自动控制相比，有很多线程和它们同步的手动控制。在这个时候，Java在控制多个线程方面比它的竞争语言先进得多，但线程的操作对于Java工程师来说仍然是一项相当艰巨的任务。
- en: In the later versions of Java, this problem was considered as the most important
    one to find a regulation, and finally, with the emergence of version 7, the compiler
    has fixed most of the problems faced by engineers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的后续版本中，这个问题被认为是寻找规律的最重要问题，最终，在版本7的出现时，编译器已经解决了工程师面临的大部分问题。
- en: 'In the current version, which is version 8, five classes aid the purpose of
    synchronization:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本，即版本8中，有五个类帮助实现同步：
- en: The `Semaphore` class is a classic concurrency tool and has been around for
    a very long time ([http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html))
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore`类是一个经典的并发工具，已经存在很长时间了（[http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html)）'
- en: The `CountDownLatch` class is a very simple yet common utility for blocking
    until a given number of signals, events, or operations being performed in other
    thread are being taken care off ([http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html))
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`类是一个非常简单但又常见的工具，用于阻塞直到给定的信号、事件或其他线程中执行的操作被处理（[http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html)）'
- en: The `CyclicBarrier` class is a resettable multiway synchronization point, which
    is useful in some styles of parallel programming ([http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html))
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类是一个可重置的多路同步点，这在某些并行编程风格中非常有用（[http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html)）'
- en: The `Phaser` class provides a more flexible form of barrier that may be used
    to control phased computation among multiple threads ([http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Phaser.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Phaser.html))
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser`类提供了一种更灵活的屏障形式，可用于控制多个线程之间的分阶段计算([http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Phaser.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Phaser.html))'
- en: The `Exchanger` class allows two threads to exchange objects at a rendezvous
    point and is useful in several pipeline designs ([http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html))
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchanger`类允许两个线程在汇合点交换对象，在许多流水线设计中很有用([http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html))'
- en: Concurrent collections
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发集合
- en: The `Concurrent` packages provide the implementations for a multithreaded context
    and has the following implementations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concurrent`包为多线程环境提供了实现，并具有以下实现。'
- en: 'Since it has more specific sync facilities, some of its classes use the prefix
    `Concurrent` to highlight the additional facilitates it is providing. A few more
    prominent ones are:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它具有更具体的同步设施，其中一些类使用前缀`Concurrent`来强调它提供的额外设施。还有一些更为突出的例子：
- en: '`ConcurrentHashMap`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`'
- en: '`ConcurrentSkipListMap`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListMap`'
- en: '`ConcurrentSkipListSet`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListSet`'
- en: '`CopyOnWriteArrayList`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArrayList`'
- en: '`CopyOnWriteArraySet`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入后复制数组集（CopyOnWriteArraySet）
- en: The virtue of concurrent collection is its safe thread, but not overlooked by
    a single locking mechanism, in particular. Only in the case of `ConcurrentHashMap`,
    it allows any sum of concurrent reads as well as concurrent writes. Why, then,
    do we use synchronized classes? The answer is that they are very useful in preventing
    all the access to a collection using a single lock, but it has a cost, and poorer
    scalability.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并发集合的优点是其安全的线程，而不是被单一的锁定机制忽视。只有在`ConcurrentHashMap`的情况下，它才允许任何数量的并发读取以及并发写入。那么，我们为什么还要使用同步类呢？答案是它们在防止使用单个锁对集合的所有访问方面非常有用，但这有代价，并且可扩展性较差。
- en: In other cases where multiple threads are in line to access a common collection,
    the current version of classes is more advisable, whereas unsynchronized locks
    are used when either collections are unshared or they can be accessed when holding
    other locks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，如果有多个线程排队访问一个公共集合，建议使用当前版本的类，而当集合是不共享的或者在持有其他锁时可以访问时，则使用未同步的锁。
- en: The implementation of promise by Java
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java实现承诺的方式
- en: 'Java implements the paradigm of promise using its promising class and interfaces.
    Although its asynchronous behavior is one of the core and flagship features of
    Java, here are the ingredients of how promise is implemented in Java:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java 通过其承诺类和接口实现承诺范式。尽管它的异步行为是Java的核心和旗舰特性之一，但以下是Java中承诺实现的成分：
- en: 'Interfaces:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口：
- en: '`CompletionService`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成服务（CompletionService）
- en: '`ExecutorService`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`'
- en: '`Future`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`'
- en: 'Classes:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类：
- en: '`Delayed`'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delayed`'
- en: '`DelayQueue`'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟队列（DelayQueue）
- en: '`FutureTask`'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FutureTask`'
- en: CompletionService
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成服务（CompletionService）
- en: The `CompletionService` interface acts as a service to make a distinction between
    new asynchronous tasks from the result of completed tasks. This follows a simple
    process in which the producer adds the tasks for execution. For the consumers,
    this interface takes completed tasks and processes their results in the order
    that they were marked as completed. This service can be used for many concurrent
    operations, such as managing an asynchronous I/O. The mechanism of an asynchronous
    I/O is the tasks that are submitted in one part of the program or set of programs
    or in a system, and then acted upon the different parts of the program. The submission
    order may be different than the order they were requested initially.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionService`接口作为一项服务，用于区分新异步任务与已完成任务的结果。这个过程很简单：生产者添加执行的任务。对于消费者来说，这个接口接收完成的任务并按它们被标记为完成时的顺序处理它们的结果。这个服务可用于许多并发操作，如管理异步I/O。异步I/O的机制是任务提交在程序的一部分或程序集或系统中，然后在不同程序的部分执行。提交顺序可能与最初请求的顺序不同。'
- en: The mechanism of an asynchronous I/O is that it reads tasks and stores it in
    one part of the program, such as buffer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 异步I/O的机制是，它在程序的一部分，如缓冲区中读取任务并存储起来。
- en: This can be a single program (such as browser) or a set of programs (such as
    an operating system thread pool). The thread handler decides which thread needs
    to be executed first.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一个单一的程序（如浏览器），或者是一组程序（如操作系统线程池）。线程处理者决定哪个线程需要首先执行。
- en: This interface relies on a separate executor or actually executes the tasks
    due to which the `CompletionService` interface only manages an internal completion
    queue. As interfaces implement, they need a class to do so, and the `ExecutorCompletionService`
    class provides such a facility.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口依赖于一个单独的执行器，或者实际上执行任务，因此`CompletionService`接口只管理一个内部的完成队列。接口实现时，需要一个类来完成这个功能，`ExecutorCompletionService`类提供了这样的功能。
- en: ExecutorService
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ExecutorService`'
- en: The `ExecutorService` interface has two main roles to perform—one is to provide
    methods to manage the termination of asynchronous tasks, and the other is to provide
    the methods that can produce a future value for tracing. This tracking can be
    done for either one or more asynchronous tasks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`接口有两个主要角色要执行——一个是提供管理异步任务终止的方法，另一个是提供可以产生跟踪未来值的方法。这种跟踪可以针对一个或多个异步任务进行。'
- en: 'The use of an `Executor` for `ExecutorService`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Executor`管理`ExecutorService`：
- en: '`ExecutorService` inherits `Executor`, which provides the methods to manage
    termination and production of a future value to track the progress.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`继承了`Executor`，提供了管理终止和生成未来值的方法，以跟踪进度。'
- en: '`ExecutorService` when shutdown rejects all the new tasks. They have been loaded
    with two different methods:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`ExecutorService`关闭时，它会拒绝所有新任务。它们已经通过两种不同的方法加载：
- en: '`shutdown()`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()`'
- en: '`shutdownNow()`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdownNow()`'
- en: The `shutdown()` method allows the tasks in memory to conclude their states
    and then terminate them. Also, it prevents the memory from entering and processing
    it for any upcoming tasks. On the other hand, `shutdownnow()` doesn't give any
    such liberty; it just terminates whatever is in the memory, then and there. This
    also totally rejects the entry of new tasks in the memory by nullifying the existing
    thread.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutdown()`方法允许内存中的任务完成它们的状态，然后终止它们。同时，它防止内存进入并处理任何即将到来的任务。另一方面，`shutdownnow()`并不提供这样的自由；它只是立即终止内存中的所有内容。这也完全拒绝了新任务在内存中的进入，通过使现有线程无效来实现。'
- en: Both the methods have their own significance, but since both are related to
    termination of existing tasks, they must be used with much care and with proper
    understanding of the potential consequences.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法各有其重要性，但由于它们都与现有任务的终止有关，因此在使用时必须非常小心，并充分理解潜在的后果。
- en: 'The following code snippet is taken from the original Java docs, which is available
    at [http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自原始的Java文档，具体内容可在[http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html)找到：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following method shuts down an `ExecutorService` interface in two phases:
    first, by calling shutdown to reject incoming tasks, and then by calling `shutdownNow()`,
    if necessary, to cancel any lingering tasks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法通过两个阶段关闭`ExecutorService`接口：首先，通过调用shutdown来拒绝新任务，然后如有必要，调用`shutdownNow()`来取消任何挂起的任务：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Future
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Future`'
- en: In Java, `future` represents the value of the result of an asynchronous computation.
    Methods are provided to track the status of result. These methods indicate whether
    the current state is waiting or not.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`future`代表了异步计算结果的值。提供了跟踪结果状态的方法。这些方法表明当前状态是等待还是其他状态。
- en: The catch is, you can only yield the result using `get` or when the computation
    is done.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，你只能通过`get`或者计算完成时才能获取结果。
- en: Cancellation can be done via the cancel method; this sounds very easy to remember.
    Cancellation of a `Future` value can be done using the cancellation method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 取消可以通过cancel方法完成；这非常容易记住。使用取消方法可以取消`Future`值。
- en: You can also check whether the task was completed normally or cancelled by virtue
    of this method invocation. Once the computation is done, it cannot be cancelled;
    this sounds so promising to us, just like the concept of promise.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过调用该方法检查任务是否正常完成或被取消。一旦计算完成，就不能取消了；这让我们觉得很有希望，就像承诺的概念一样。
- en: You can also use `Future` to cancel tasks. Although it's not a very good approach,
    if you want to do it, then you can declare many types of `Future` objects and
    ask the method to return null; that's it! You got your task cancelled once again.
    This must be done before the final computation of the tasks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`Future`来取消任务。尽管这并不是一个很好的方法，如果你想要这么做，那么你可以声明许多类型的`Future`对象，并要求方法返回null；就这样！你的任务再次被取消了。这必须在任务最终计算之前完成。
- en: 'Here is the code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码片段：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `FutureTask` class is an implementation of `Future` that implements `Runnable`,
    and so may be executed by an `Executor`. For example, the previous construction
    with submit can be replaced by the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`FutureTask`类是实现`Future`并实现`Runnable`的`Future`的实现，因此可以由`Executor`执行。例如，使用submit的先前构造可以替换为以下内容：'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Delay and DelayedQueue
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟和DelayedQueue
- en: '`Delay` is an interface that uses a marker to mark those objects that were
    acted upon, after they were given a delay.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delay`是一个使用标记来标记在延迟之后进行操作的对象的接口。'
- en: '`DelayedQueue` is an unbounded queue that is used to collect all the objects
    that were delayed/expired. Since it''s a queue, it must have a header element
    whose delay has expired long ago.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelayedQueue`是一个用于收集所有延迟/过期的对象的无限队列。由于它是一个队列，必须有一个延迟已经很久很久的头元素。'
- en: Since it's a queue and is similar to a `queue` data structure, it has a starting
    point called header and an ending point called footer. When it comes to future,
    the queue we are referring to here has a value, which has already expired due
    to the failed promise or unfulfilled promise.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个队列，并且与`queue`数据结构相似，它有一个称为头部的起始点和一个称为脚部的结束点。当说到未来时，我们在这里提到的队列有一个值，它已经由于失败的承诺或未实现的承诺而过期。
- en: If such an element was not found, will the poll return null when the expiration
    occurs? Well, it occurs when the method `getDelay(TimeUnit.NANOSECONDS)` returns
    the value as less than or equal to zero. The expired elements in this way cannot
    be removed, so they are treated as normal ones.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到这样的元素，在过期发生时，轮询会返回null吗？嗯，当方法`getDelay(TimeUnit.NANOSECONDS)`返回的值小于或等于零时，它就会发生。以这种方式过期的元素不能被移除，所以它们被视为正常元素。
- en: FutureTask
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`FutureTask`'
- en: '`FutureTask` is the cancellable asynchronous computation. This is the basic
    provider of `Future` that is loaded with methods from start of a method to cancel
    it. This also helps in the retrieving of the result of the computation, and since
    it''s an implementation, the result can be extracted when the computation has
    been completed. Needless to mention that once the result is computed, it cannot
    be pulled back or changed as it''s a promise.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`FutureTask`是可取消的异步计算。这是`Future`的基本提供者，它从开始一个方法到取消它都加载了方法。这也有助于检索计算的结果，因为它是实现，当计算完成时可以提取结果。不用说，一旦计算出结果，它就不能被拉回或更改，因为这是一个承诺。'
- en: Summing up Java and Promises.js
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结Java和Promises.js
- en: If we conclude the preceding discussion, it's clear that Java has a clearer
    approach and implementation when it comes to Promises.js. It's a mature way of
    handling asynchronous behavior, and especially, the way it handles multithreading
    is far better than what other languages have to offer. However, as every implementation
    has its own drawbacks, Java too has it, and it's quite acceptable since you cannot
    just copy and paste the theory as it is with any compiler/interpreter. There are
    few more supportive frameworks/libraries contributed by an open source community
    to add the remainder of its implementation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们总结一下前面的讨论，很清楚Java在处理Promises.js方面有更清晰的方法和实现。它是一种处理异步行为成熟的方式，特别是，它在处理多线程方面的表现远胜于其他语言。然而，每种实现都有它的缺点，Java也是如此，这是可以接受的，因为你不能简单地复制和粘贴理论，就像任何编译器/解释器一样。开源社区贡献了少数更多支持的框架/库来补充它的实现。
- en: Say hello to JDeferred
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向JDeferred打个招呼
- en: Inspired by the implementation of promise in jQuery, few Java Engineers have
    started to develop a library called `JDeferred`. This implements the concept of
    promise as robustly as it should be by leaving the gaping holes of the `java.util.concurrent`
    package. This was a brief of how `JDeferred` works. Let's dive deep into what
    it is and its unique advantages, as compared to other implantations available
    in the market.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 受到jQuery中承诺实现的启发，一些Java工程师开始开发一个名为`JDeferred`的库。它通过留下`java.util.concurrent`包中的巨大漏洞，实现了承诺的概念。这是`JDeferred`工作的简要介绍。让我们深入了解它是什么以及与其他市场上可用的实现相比的独特优势。
- en: Just like jQuery has a deferred object, `JDeferred` is designed in a similar
    way to behave and contact with Java's compiler. `JDeferred` is not only similar
    with jQuery's implementation of promise, but it also extends its support to the
    Android Deferred Object. [Chapter 8](ch08.html "Chapter 8. Promises in jQuery"),
    *Promises in jQuery* is the dedicated chapter on jQuery and its mechanism and
    working on promise, so we can skip that part for now and see what the Android
    Deferred Object is, and how it fits into the implementation of promise.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像jQuery有一个延迟对象一样，`JDeferred`也是设计成与Java编译器的行为和联系相似。`JDeferred`不仅与jQuery的承诺实现相似，而且还将其支持扩展到了Android
    Deferred Object。第[8章](ch08.html "第8章。jQuery中的承诺")，*jQuery中的承诺*是专门讨论jQuery及其机制和承诺工作的章节，所以我们现在可以跳过这部分，看看Android
    Deferred Object是什么，以及它如何融入承诺的实现。
- en: A few words about Android Deferred Object
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Android Deferred Object说几句
- en: It would be unfair not to showcase the existence of Android Deferred Object
    and its properties when we are discussing `JDeferred`. The Android Deferred Object
    is a utility or more simply, it is a chainable utility object that can actually
    do all the same stuff for the Android domain. It can register multiple callbacks
    in a single callback queue; it can invoke callback queues and after processing.
    It also can relay the state of success or failure to whichever function is waiting
    for; it doesn't matter whether it's a synchronous function or an asynchronous
    function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论`JDeferred`时，如果不展示Android Deferred Object及其属性的存在，那是不公平的。Android Deferred
    Object是一个工具，或者更简单地说，它是一个可链式的工具对象，实际上可以为Android领域做所有相同的事情。它可以在单个回调队列中注册多个回调；它可以调用回调队列并在处理后执行。它还可以将成功或失败的状态传达给等待的任何函数；无论它是一个同步函数还是一个异步函数都不重要。
- en: Its working is quite straightforward. You obtain a promise out of a function
    that was executed asynchronously. As we can work around with promise, you can
    attach callbacks to get notified about the success or failure. Whenever this piece
    of program that was working asynchronously finishes off as expected, the promise
    is called to be resolved in case of any error; it calls the `rejected` parameter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作相当直接。你从一个异步执行的函数中得到一个承诺。由于我们可以围绕承诺进行操作，因此你可以附加回调以获取关于成功或失败的通知。无论这部分程序是同步执行还是异步执行，当它如预期般完成时，承诺会被调用以解决任何错误，它调用`rejected`参数。
- en: Use case 1 – object success and failure callbacks for a task
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例1——任务的对象成功和失败回调
- en: 'Say that you need an asynchronous HTTP request. A simple way of using Android
    Deferred Object is to wrap the request in to `DeferredAsyncTask` and attach callbacks
    to your action. Here is the code for such a scenario:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说你需要一个异步的HTTP请求。使用Android Deferred Object的一个简单方法是将请求包装到`DeferredAsyncTask`中，并将回调附加到你的操作上。以下是这种场景的代码：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reference to preceding code is available at [https://github.com/CodeAndMagic/android-deferred-object](https://github.com/CodeAndMagic/android-deferred-object).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的参考可以在[https://github.com/CodeAndMagic/android-deferred-object](https://github.com/CodeAndMagic/android-deferred-object)找到。
- en: Use case 2 – merging several promises
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例2——合并多个承诺
- en: 'This use case is best for when you need to add several executed promises into
    a single one by merging them as a single promise. A convenient way is to call
    the `DeferredObject.when` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此用例最适合当你需要将多个已执行的承诺合并成一个单一的承诺，通过将它们作为一个单一的承诺来合并。一个方便的方法是调用`DeferredObject.when`方法：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Mechanics of JDeferred
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDeferred的机制
- en: Coming back to our core discussion of JDeferred, there is almost everything
    that this implementation has adopted from promises and considered to be more promised
    than any other library. We will look at what the features it's providing are,
    and how they are implemented within.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们JDeferred的核心讨论，这个实现几乎采纳了来自承诺的所有特性，并被认为比其他任何库都更符合承诺。我们将看看它提供哪些特性，以及它们是如何在内部实现的。
- en: Features of JDeferred
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDeferred的特性
- en: The implementation of `JDeferred` provides all the methods needed to present
    the promise paradigm in Java. This has features such as deferred objects and promise,
    promise callbacks, multiple promises, callable and runnable methods, and Java's
    generic support.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`JDeferred`的实现提供了展示Java中承诺范式的所有必要方法。它具有诸如延迟对象和承诺、承诺回调、多个承诺、可调用和可运行方法以及Java的泛型支持等特性。'
- en: 'The following table summarizes the features, along with their available implementation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了特性及其可用的实现：
- en: '| Feature | Available implementation |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 可用的实现 |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Deferred object and promise | N/A |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 延迟对象和承诺 | N/A |'
- en: '| Promise callbacks | `.then(…)``.done(…)``.fail(…)``.progress(…)``.always(…)`
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 承诺回调 | `.then(…)``.done(…)``.fail(…)``.progress(…)``.always(…)` |'
- en: '| Multiple promises | `.when(p1, p2, p3, …).then(…)` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 多个承诺 | `.when(p1, p2, p3, …).then(…)` |'
- en: '| Callable and runnable wrappers | `.when(new Runnable() {…})` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 可调用和可运行包装器 | `.when(new Runnable() {…})` |'
- en: '| Java generic support | `Deferred<Integer, Exception, Double> deferred;``deferred.resolve(10);``deferred.reject(new
    Exception());``deferred.progress(0.80);` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Java泛型支持 | `Deferred<Integer, Exception, Double> deferred;``deferred.resolve(10);``deferred.reject(new
    Exception());``deferred.progress(0.80);` |'
- en: Playing with the code using JDeferred
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JDeferred玩转代码
- en: 'We will now explore some of the common examples of this implementation, which
    are used most often. We will be looking at the following topics:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨一些这个实现的常见示例，这些示例最常被使用。我们将讨论以下主题：
- en: Deferred object and promise
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟对象和承诺
- en: Deferred Manager
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟管理器
- en: Runnable and callable
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可运行和可调用
- en: '`wait()` and `waitSafely()`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait()`和`waitSafely()`'
- en: Filters
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器
- en: Pipes
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Deferred object and promise
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟对象和承诺
- en: 'The following code will help you understand how `JDeferred` implements deferred
    objects and promise. This code has comments for a better understanding:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将帮助你理解`JDeferred`如何实现延迟对象和承诺。这段代码附有注释，以便更好地理解：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Deferred Manager
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟管理器
- en: 'Deferred Manager is a simple way to manage your deferred objects. Call the
    default method of Deferred Manager, and then add the number of promises you want:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟管理器是一种简单的方式来管理你的延迟对象。调用延迟管理器的默认方法，然后添加你想要的承诺数量：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Runnable and callable
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可运行和可调用
- en: 'Runnable and callable, which is as good as promise, can be used as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可运行和可调用，与承诺一样好，可以用如下方式使用：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use `DeferredCallable` and `DeferredRunnable` if you want to do the
    following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要做以下事情，你可以使用`DeferredCallable`和`DeferredRunnable`：
- en: Be notified about the progress made by the callable or runnable
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知关于可调用或可运行的进度
- en: You want to make your `Deferred` object
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想让你的`Deferred`对象
- en: 'Here is an example code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Extending `DeferredRunnable`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`DeferredRunnable`：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: wait() and waitSafely()
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`wait()`和`waitSafely()`'
- en: 'The `wait()` and `waitSafely()` functions are the part of `JDeferred` that
    wants to assume the control of all asynchronous tasks. This is not recommended,
    but can be very useful in some cases:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()`和`waitSafely()`函数是`JDeferred`想要控制所有异步任务的部分。这并不推荐，但在某些情况下非常有用：'
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The shortcut to the preceding code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的快捷方式如下：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Filters
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'Here is the code that we will use for the filtration of promise and deferred
    objects:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将用于过滤承诺和延迟对象的代码：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Pipes
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道
- en: 'Pipes in `JDeferred` also act for the asynchronous computation of tasks within
    the ordered manner:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`JDeferred`中的管道也是按顺序进行异步任务计算的：'
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ultimate JDeferred
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ultimate JDeferred
- en: As you have seen, it's a much more powerful implementation of Java using promise.
    Java is very powerful when it comes to implementing the promise paradigm.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是使用承诺的Java的一个更强大的实现。当谈到实现承诺范式时，Java非常强大。
- en: Actually, Java itself has many powerful features, but when it comes to proper
    implementation, such frameworks help us out. Since they are community maintained,
    they have a problem in terms of quality, as you may find nontested and unverified
    code that can waste your time. However, `JDeferred` has almost identical implementation,
    compared to jQuery.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Java本身就有很多强大的功能，但当谈到适当的实现时，这样的框架可以帮助我们。因为它们是社区维护的，所以在质量方面存在问题，你可能会找到未测试和未经验证的代码，这可能会浪费你的时间。然而，与jQuery相比，`JDeferred`的实现几乎相同。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Within this chapter of the book, we have actually started our journey towards
    mastering the promise. This chapter covered why we are implementing promise and
    why we chose Java as the core of this chapter. Java has richer features than any
    other programming language and it's also tried very well to keep it more or less
    similar to the automation of asynchronous behavior. We explored the core components
    of Java's `util.concurrent` class in greater detail and by virtue of which we
    have seen many live examples from Java docs online. Since Java cannot implement
    the promise paradigm in whole due to the limitations that we have seen, an open
    source library that acts exactly the same as the promise's paradigm has prescribed
    it. `JDeferred` has cleared the rest of the doubts out of our minds by taking
    full advantage of implementing the core values of promise, such as `future`, `deferred`,
    and so on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一章节中，我们实际上已经开始掌握Promise的旅程了。这一章节涵盖了为什么我们要实现Promise以及为什么我们选择Java作为本章节的核心。Java的功能比任何其他编程语言都要丰富，并且它也非常努力地使其与异步行为的自动化保持更多或
    less 相似。我们详细探讨了Java的`util.concurrent`类的核心组件，并通过这些组件我们看到了来自Java在线文档的许多实际例子。由于Java由于我们所看到的限制而不能完全实现承诺范式，因此有一个开源库，其行为与承诺范式完全一样。`JDeferred`通过充分利用实现承诺的核心价值观（如`future`、`deferred`等）消除了我们心中的其他疑虑。
- en: In the next chapter, we will carry out a more practical work to develop our
    understanding of promise with WinRT.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过一个更实用的例子来加深对WinRT中Promise的理解。
