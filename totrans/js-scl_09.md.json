["```js\n// model.js\n// A model with a fake \"fetch()\" method that doesn't\n// actually set any data.\nexport default class Model {\n\n    fetch() {\n\n        // Returns a promise so the caller can work\n        // with this asynchronous method. It resolves\n        // after 1 second, meant to simulate a real\n        // network request.\n        var promise = new Promise((resolve, reject) => {\n            setTimeout(() => resolve(), 1000);\n        });\n\n        return promise;\n    }\n\n};\n\n// main.js\nimport Model from 'model.js';\n\nfunction onRequestsInput(e) {\n    var size = +e.target.value,\n        cnt = 0,\n        models = [];\n\n    // Create some models, based on the \"requests\"\n    // number.\n    while (cnt++ < size) {\n        models.push(new Model());\n    }\n\n    // Setup a timer, so we can see how long it\n    // takes to fetch all these models.\n    console.clear();\n    console.time(`fetched ${models.length} models`);\n\n    // Use \"Promise.all()\" to synchronize the fetches\n    // of each model. When they're all done, we can stop\n    // the timer.\n    Promise.all(models.map(item => item.fetch())).then(() => {\n        console.timeEnd(`fetched ${models.length} models`);\n    });\n}\n\n// Setup our DOM listener, so we know how many\n// models to create and fetch based on the \"requests\"\n// input.\nvar requests = document.getElementById('requests');\n\nrequests.addEventListener('input', onRequestsInput);\nrequests.dispatchEvent(new Event('input'));\n```", "```js\n// model.js\nvar counter = 0;\n\n// A model that consumes more and more memory,\n// with each successive instance.\nexport default class Model {\n\n    constructor() {\n        this.data = new Array(++counter).fill(true);\n    }\n\n};\n\n// app.js\n// A simple application component that\n// pushes items onto an array.\nexport default class App {\n\n    constructor() {\n        this.listening = [];\n    }\n\n    listen(object) {\n        this.listening.push(object);\n    }\n\n};\n\n// main.js\nimport Model from 'model.js';\n\nfunction onRequestsInput(e) {\n    var size = +e.target.value,\n        cnt = 0,\n        models = [];\n\n    // Create some models, based on the \"requests\"\n    // number.\n    while (cnt++ < size) {\n        models.push(new Model());\n    }\n\n    // Setup a timer, so we can see how long it\n    // takes to fetch all these models.\n    console.clear();\n    console.time(`fetched ${models.length} models`);\n\n    // Use \"Promise.all()\" to synchronize the fetches\n    // of each model. When they're all done, we can stop\n    // the timer.\n    Promise.all(models.map(item => item.fetch())).then(() => {\n        console.timeEnd(`fetched ${models.length} models`);\n    });\n}\n\n// Setup our DOM listener, so we know how many\n// models to create and fetch based on the \"requests\"\n// input.\nvar requests = document.getElementById('requests');\n\nrequests.addEventListener('input', onRequestsInput);\nrequests.dispatchEvent(new Event('input'));\n```", "```js\n// component.js\n// A generic component used in an application...\nexport default class Component {\n\n    // The constructor accepts a collection, and performs\n    // a \"reduce()\" on it, for no other reason than to eat\n    // some CPU cycles.\n    constructor(collection) {\n        collection.reduce((x, y) => x + y, 0);\n    }\n\n}\n// main.js\nimport Component from 'component.js';\n\nfunction onInput() {\n    // Creates a new collection, the size\n    // is based on the \"data\" input.\n    var collection = new Array(+data.value).fill(1000),\n        size = +components.value,\n        cnt = 0;\n\n    console.clear();\n\n    // Sets up a timer so we can see how long it\n    // takes for x components to process y collection items.\n    console.time(`${size} components, ${collection.length} items`);\n\n    // Create the number of components in the \"components\"\n    // input.\n    while (cnt++ < size) {\n        new Component(collection);\n    }\n\n    // We're done processing the components, so stop the timer.\n    console.timeEnd(`${size} components, ${collection.length} items`);\n}\n\n// Setup out DOM event listeners...\nvar components = document.getElementById('components'),\n    data = document.getElementById('data');\n\ncomponents.addEventListener('input', onInput);\ndata.addEventListener('input', onInput);\n\ncomponents.dispatchEvent(new Event('input'));\n```", "```js\n// view.js\n// An ultra-simplistic view that updates\n// the text of an element that's already in\n// the DOM.\nexport default class View {\n\n    constructor(element, text) {\n        element.textContent = text;\n    }\n\n};\n\n// controller.js\nimport events from 'events.js';\nimport View from 'view.js';\n\n// A controller component that accepts and configures\n// a router instance.\nexport default class Controller {\n\n    constructor(router) {\n        // Adds the route, and creates a new \"View\" instance\n        // when the route is activated, to update content.\n        router.add('controller', 'controller');\n        events.listen('route:controller', () => {\n            new View(document.getElementById('content'), 'Controller');\n        });\n    }\n\n};\n\n// component-controller.js\nimport Controller from 'controller.js';\n\n// An application that doesn't actually do\n// anything accept create a controller. Is the\n// controller really needed here?\nexport default class ComponentController {\n\n    constructor(router) {\n        this.controller = new Controller(router);\n    }\n\n};\n\n// component-nocontroller.js\nimport events from 'events.js';\nimport View from 'view.js';\n\n// An application component that doesn't\n// require a component. It performs the work\n// a controller would have done.\nexport default class ComponentNoController {\n\n    constructor(router) {\n        // Configures the router, and creates a new\n        // view instance to update the DOM content.\n        router.add('nocontroller', 'nocontroller');\n        events.listen('route:nocontroller', () => {\n            new View(document.getElementById('content'), 'No Controller');\n        });\n    }\n\n};\n\n// main.js\nimport Router from 'router.js';\nimport ComponentController from 'component-controller.js';\nimport ComponentNoController from 'component-nocontroller.js';\n\n// The global router instance is shared by components...\nvar router = new Router();\n\n// Create our two component type instances,\n// and start the router.\nnew ComponentController(router);\nnew ComponentNoController(router);\n\nrouter.start();\n```", "```js\n// model.js\n// A dummy model with a dummy \"fetch()\" method.\nexport default class Model {\n\n    fetch() {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n\n                // We want to log from within the model\n                // so that we know a fetch has actually\n                // been performed.\n                console.log('processing model');\n\n                // Sets some dummy data and resolves the\n                // promise with the model instance.\n                this.first = 'First';\n                this.last = 'Last';\n\n                resolve(this);\n            }, 1000);\n        });\n    }\n\n};\n\n// component-duplicates.js\nimport Model from 'model.js';\n\n// Your standard application component\n// with a model.\nexport default class ComponentDuplicates {\n\n    constructor() {\n        this.model = new Model();\n    }\n\n    // A naive proxy to \"model.fetch()\". It's\n    // naive because it shouldn't fetch the model\n    // while there's outstanding fetch requests.\n    fetch() {\n        return this.model.fetch();\n    }\n\n};\n\n// component-noduplicates.js\nimport Model from 'model.js';\n\n// Your standard application component with a\n// model instance.\nexport default class ComponentNoDuplicates {\n\n    constructor() {\n        this.promise = null;\n        this.model = new Model();\n    }\n\n    // \"Smartly\" proxies to \"model.fetch()\". It avoids\n    // duplicate API fetches by storing promises until\n    // they resolve.\n    fetch() {\n\n        // There's a promise, so there's nothing to do -\n        // we can exit early by returning the promise.\n        if (this.promise) {\n            return this.promise;\n        }\n\n        // Stores the promise by calling \"model.fetch()\".\n        this.promise = this.model.fetch();\n\n        // Remove the promise once it's resolved.\n        this.promise.then(() => {\n            this.promise = null;\n        });\n\n        return this.promise;\n    }\n\n};\n\n// main.js\nimport ComponentDuplicates from 'component-duplicates.js';\nimport ComponentNoDuplicates from 'component-noduplicates.js';\n\n// Create instances of the two component types.\nvar duplicates = new ComponentDuplicates(),\n    noDuplicates = new ComponentNoDuplicates();\n\n// Perform two \"fetch()\" calls. You can see that\n// the fetches are both carried out by the model,\n// even though there's no need to.\nduplicates.fetch();\nduplicates.fetch().then((model) => {\n    console.log('duplicates', model);\n});\n\n// Here we do the exact same double \"fetch() call,\n// only this component knows not to carry out\n// the second call.\nnoDuplicates.fetch();\nnoDuplicates.fetch().then((model) => {\n    console.log('no duplicates', model);\n});\n```"]