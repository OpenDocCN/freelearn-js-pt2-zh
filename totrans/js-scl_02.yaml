- en: Chapter 2. Influencers of Scale
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。规模影响者
- en: Influencers of scale start with the users of our software. They're the number
    one influencer because they're the reason we've set out to build an application.
    As we saw in the preceding chapter, users influence features that ultimately influence
    the code we write and the development personnel who implement it. When we pause
    and think about these scaling influencers, we recognize that a sound JavaScript
    architecture that can handle them is a prudent cause. We can then take our findings
    and look at our code from different architectural perspectives. We'll dig into
    each of these perspectives throughout this book, starting with the next chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 规模影响的发起者从我们软件的用户开始。他们是影响力度最大的发起者，因为他们是我们构建应用的原因。正如我们在前一章所看到的，用户影响最终影响我们编写的代码和实施它的开发人员。当我们停下来思考这些规模影响者时，我们认识到能够应对它们的健壮的JavaScript架构是一个审慎的原因。然后我们可以把我们找到的信息从不同的架构角度审视我们的代码。我们将在本书中深入探讨这些观点，从下一章开始。
- en: But before we do that, let's go into more detail on these influencers of scale.
    We want to pay close attention to these because with every decision we make about
    our design, how it actually scales depends largely on the influences we've anticipated.
    Perhaps more importantly, we need to design our architecture in such a way that
    it enables us to handle scaling scenarios we haven't anticipated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，让我们更深入地了解这些规模影响者。我们希望密切关注这些，因为关于我们的设计，我们做出的每一个决定实际上如何扩展在很大程度上取决于我们预见的影響。也许更重要的是，我们需要以这样的方式设计我们的架构，以便它能够让我们处理我们没有预见的扩展场景。
- en: We'll start with a closer look at the users of our software. Why are they using
    it? How does our software make them happy? What's in it for us? These questions,
    believe it or not, are pertinent to the way we write our JavaScript. From users,
    we then move down to features, the outward-facing personality of our application.
    Some features aren't a good fit for our application, but sometimes that doesn't
    matter—we don't have a say. If we're going to scale up, to please our users, sometimes
    we have to make the best of these features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从更仔细地观察我们软件的用户开始。他们为什么使用它？我们的软件是如何让他们快乐的？对我们有什么好处？这些问题，信不信由你，与我们编写JavaScript的方式密切相关。从用户出发，我们然后再深入到功能，我们应用的外向个性。有些功能不适合我们的应用，但有时候那并不重要——我们说了不算。如果我们想要扩大规模，取悦我们的用户，有时我们必须充分利用这些功能。
- en: The development resources, ultimately responsible for implementing these features,
    are a scaling influencer that can make or break a product. We'll look at the challenges
    faced by the development team, and how they're constrained by the feature influences.
    We'll close the chapter with a generic checklist for each of these influencers;
    to help ensure we've thought of the most pressing issues concerning our ability
    to scale.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 负责实施这些功能的发展资源是一个可以成就或破坏产品的规模影响者。我们将查看开发团队面临的挑战，以及他们如何受到功能影响。我们将在本章结束时为每个这些影响者提供一个通用的检查表；以帮助确保我们已经考虑了我们能够扩展的最紧迫的问题。
- en: Scaling users
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩大用户规模
- en: The most important user is us—the development organization. While our mission
    is to keep our users happy by delivering software that scales, we need to keep
    ourselves happy too. And that requires a viable business model. The reason we
    care about this is because different models mean different approaches to acquire
    new users, and manage existing users. From there, the complexities of scaling
    our user base get deeper. We need to consider how our users are organized, how
    they use our software to communicate with one another, how to provide support,
    collect feedback, and collect user metrics.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的用户是我们——开发组织。虽然我们的任务是通过提供可扩展的软件来保持我们的用户快乐，但我们也需要让自己快乐。而这需要一个可行的商业模式。我们关心这个原因是因为不同的模型意味着获取新用户和管理现有用户的不同方法。从那里开始，扩大我们的用户基础的复杂性会更深。我们需要考虑我们的用户是如何组织的，他们如何使用我们的软件相互沟通，如何提供支持，收集反馈和收集用户指标。
- en: Viable business models for JavaScript applications range from deploying a free
    service that's ad-supported, to a private, on-premise deployment of our software,
    where we collect license fees. Deciding which approach is right for the organization
    is likely out of our hands. However, it's our responsibility to understand the
    chosen business model and relate it to the current and future users of our software.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript应用程序可行的业务模式包括提供广告支持的免费服务，到我们收取许可费的私有、本地软件部署。决定哪种方法适合组织可能不在我们手中。然而，我们的责任是理解选定的业务模式，并将其与当前和未来使用我们软件的用户联系起来。
- en: The business model can grow quite complex. For instance, organizations will
    often start off with one approach that's clear cut and keeps users happy, while
    meeting business expectations. However, as the organization grows and matures,
    the once coherent business model is obscured into something that's less approachable,
    and has unpredictable results for our architecture. Let's take a look at some
    of these business models and how each impacts the scalability of our user base.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 业务模式可能会变得相当复杂。例如，组织通常会从一种清晰明了、能让用户满意，同时满足商业期望的方法开始。然而，随着组织的成长和成熟，曾经连贯的业务模式变得模糊不清，对于我们的架构产生了不可预测的结果。让我们来看看这些业务模式以及它们如何影响我们用户基础的可扩展性。
- en: License fees
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可费用
- en: Software licensing is a complex topic, one that we're not going to explore in
    depth here. What's important is simply whether or not we're relying on licensed
    software as our business model. If we are, then we likely have other organizations
    deploying our JavaScript applications on-premise. It's unlikely that we'll have
    individuals purchasing licenses. Not impossible though—it depends on the nature
    of the software. The likely case with selling licenses is that our software will
    be privately deployed by multiple organizations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件许可是一个复杂的话题，在这里我们不会深入探讨。重要的是我们是否依赖许可软件作为我们的业务模式。如果是，那么我们很可能有其他组织在本地部署我们的JavaScript应用程序。个人购买许可证的可能性不大——这取决于软件的性质。销售许可证的情况下，我们的软件更有可能被多个组织私有化部署。
- en: There are two interesting scaling properties to consider with this business
    model. Firstly, there's a fundamental limit on the number of users within a given
    organization. While organizations can be large, and we can sell to multiple large
    organizations, the common case is to have fewer users overall with a licensed
    model. Secondly, each organization has different needs in terms of customizations.
    This involves configurability, user organization, and so on. We're more likely
    to experience requests for these types of changes or enhancements using a licensed
    model.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种业务模式有两个有趣的扩展属性需要考虑。首先，对于给定组织内的用户数量存在一个基本限制。虽然组织可以很大，我们可以向多个大型组织销售产品，但常见的案例是拥有较少用户，并采用授权模型。其次，每个组织在定制方面都有不同的需求。这包括配置性、用户组织等。采用授权模型时，我们更有可能遇到这些类型的更改或增强请求。
- en: So, while there're not as many users to support, the nature of supporting them
    is more complex due to the structure of the organization using our software, and
    hence difficult to scale. Dependency management in these environments can be challenging
    as well, due to restrictions that determine how our software is able to scale.
    In other environments, these restrictions are more lax.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，虽然支持的用户不多，但由于使用我们软件的组织的结构性质，支持他们的性质更加复杂，因此难以扩展。在这些环境中，依赖管理也可能具有挑战性，因为限制决定了我们的软件如何能够扩展。在其他环境中，这些限制较为宽松。
- en: Subscription fees
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅费用
- en: Subscriptions are recurring fees we collect for the use of our software. This
    approach costs our users less, most of the time. It's also a more flexible business
    model in that it can easily apply to software that's deployed on-premise, and
    software that's deployed publicly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅服务是我们为使用我们的软件而收取的定期费用。这种方法通常对我们的用户来说成本更低。此外，这种业务模式也更加灵活，因为它可以轻松地应用于本地部署的软件，以及公开部署的软件。
- en: Since it's cheaper for organizations to deploy subscription-based software rather
    than license-based ones, we're more likely to reach more organizations. Mind you,
    these are organizations divided into departments, each with their own budgetary
    constraints.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组织部署基于订阅的软件比基于许可的软件成本更低，我们更有可能接触到更多的组织。请注意，这些组织是按部门划分的，每个部门都有自己的预算限制。
- en: In terms of scale, however, the challenge with subscriptions is similar to the
    challenge faced with licenses, that is, complex customization requests. If subscriptions
    are likely to get us more on-premise deployments and likely more arcane feature
    requests. Another scaling problem facing the subscription approach is customer
    retention. Users aren't going to continue paying subscription fees if value isn't
    continuously delivered.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在扩展方面，订阅模式的挑战与许可模式的挑战相似，即复杂的定制化请求。如果订阅可能会让我们获得更多的企业内部部署，可能会带来更复杂的功能请求。采用订阅方式所面临的另一个扩展问题就是客户保留。如果不能持续提供价值，用户是不会继续支付订阅费用的。
- en: So if we go the subscription route, we need to scale up our efforts in delivering
    new features that justify the recurring subscription costs for our users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们选择订阅模式，我们需要加大力度提供新功能，这些功能可以证明用户的持续订阅费用是合理的。
- en: Consumption fees
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费费用
- en: Another business model for software is consumption, or, pay-as-you-go. This
    is an appealing model for users since they're not paying for resources they don't
    use. Of course, this doesn't suit every application. What if there are no meaningful
    resources for users to consume? What if we're running our application in a way
    that resource consumption is of no concern to us?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的另一种商业模式是消费模式，或者说，按需付费。这对用户来说是一个有吸引力的模式，因为他们为他们不使用的资源付费。当然，这并不适合每一个应用程序。如果用户没有有意义的东西可以消耗呢？如果我们在运行应用程序的方式上，资源消耗对我们来说不是问题呢？
- en: In other cases, the resource usage is glaringly obvious. Maybe the user performs
    some computationally-expensive task, or stores a lot of data for a period of time.
    In these cases, the consumption model makes perfect sense, for both us and the
    user. Users that consume less, pay less. User behavior can be erratic, with spikes
    of consumption. However, these events are brief, relative to the rest of the time
    they're using our application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，资源使用情况是显而易见的。也许用户执行了一些计算密集型的任务，或者在一段时间内存储了大量数据。在这些情况下，消耗模型对我们和用户来说都是完全合理的。消耗较少的用户，支付较少费用。用户行为可能会有波动，但与他们在使用我们应用程序的其他时间相比，这些事件是短暂的。
- en: The scaling challenge we face with this business model is that we need good
    tools in addition to the core aspects of our application. First, we need a tool
    that measures and records consumption. Second, we need tools to accurately portray
    these consumption metrics, often visually. Depending on what users are consuming,
    and what level of integration we're expecting, there might be a third-party component
    to consider.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个业务模型所面临的扩展挑战是我们除了应用的核心方面外，还需要好的工具。首先，我们需要一个测量和记录消耗的工具。其次，我们需要准确描绘这些消耗指标的工具，通常是以视觉化的方式。根据用户在消耗什么，以及我们期望达到什么程度的集成，可能还需要考虑第三方组件。
- en: Ad-supported
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广告支持
- en: Another option is to deploy our application to the public internet and use display
    advertisements for revenue. These are free applications, and hence more likely
    to be used. On the other hand, advertisements are a big turn-off to many people,
    which counteracts the appeal of "free".
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是将我们的应用部署到公共互联网上，并使用显示广告来赚钱。这些是免费的应用程序，因此更有可能被使用。另一方面，广告会让很多人感到厌烦，这抵消了“免费”的吸引力。
- en: Perhaps the goal when using this approach, rather than ad revenue, is generating
    mass usage. The two go hand-in-hand actually, more users means more ad revenue.
    However, mass adoption of an online JavaScript application can catch the attention
    of investors. So lots of user accounts, by itself, has merit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的目标，或许不是广告收入，而是产生大规模使用。实际上，用户越多，广告收入也会越多。然而，一个在线JavaScript应用程序的大规模采用可能会吸引投资者。所以，用户账户的数量本身就有价值。
- en: These types of applications are different from those that follow other business
    models, in how they scale. Applications that gain mass appeal on the internet
    solve different problems for different user personas. Following this model means
    we need to have reach, and to scale our reach means lowering the barrier to entry.
    Our focus, while using this business model, is on ease-of-use and social validity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这类应用程序与其他业务模型不同的地方在于它们的扩展方式。在互联网上获得广泛流行的应用程序为不同的用户角色解决不同的问题。遵循这一模式意味着我们需要有覆盖面，而扩大覆盖面意味着降低入门门槛。在使用这种业务模型时，我们的重点是易用性和社会有效性。
- en: Open source
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源
- en: The final business model for us to consider is open source. Don't laugh; open
    source software is vital to the functioning of the web. It's highly unlikely that
    our JavaScript application doesn't use any open source components. It's more likely
    that we're only using open source components. But why do people spend their valuable
    time developing tools for everyone else to use, even their competition?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的最后一种商业模式是开源。别笑；开源软件对网络的功能至关重要。我们的JavaScript应用程序很可能使用了一些开源组件，更有可能的是，我们只使用了开源组件。但为什么人们会花宝贵的时间开发供所有人使用，甚至包括他们的竞争对手的工具呢？
- en: The first misconception here is that folks are just sitting around, unemployed,
    building open source software for the rest of us to use. The fact is, most of
    the tools we'll use are built by people in strong positions at companies that
    use the same technologies we do. They may have even started the open source project
    to solve a problem for the company—to provide a missing tool in their development
    process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个误解是，人们只是闲坐着，失业，为其他人构建开源软件。事实是，我们大多数将使用的工具都是由使用与我们相同技术的大型公司的有强大地位的人构建的。他们甚至可能启动开源项目来为公司解决问题——为他们的开发过程提供一个缺失的工具。
- en: The second misconception is that we're helping out our competitors by starting
    up, or contributing to, open source projects. It's not possible for us to single-handedly
    put ourselves in a worse position than our competition via open source software.
    By other measures, yes, it's absolutely possible to help out our competition by
    hurting ourselves.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个误解是我们通过启动或贡献开源项目在帮助我们的竞争对手。我们不可能仅通过开源软件就让自己处于比竞争对手更糟的位置。通过其他标准，是的，通过伤害自己来帮助我们的竞争对手是完全可能的。
- en: On the other hand, open source projects can be good for an organization. They
    have to be effective projects; something that's usable and generic. If it grows
    legs, we're creating new stakeholders in technology that we rely on, and that's
    a good thing. The community that surrounds an open source project is invaluable.
    While open source by itself can't support an organization, there's no escaping
    the fact that it's an integral part of any JavaScript application business model.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，开源项目可能对一个组织是有益的。这些项目必须是有效的；即有用且通用的。如果它发展壮大，我们就在创造我们依赖的新技术利益相关者，这是件好事。围绕开源项目的社区是无价的。虽然开源本身不能支持一个组织，但不可否认的是，它是任何JavaScript应用程序商业模式的一个重要组成部分。
- en: Groups and rolesGroups allow us to classify our users. Think of the role as
    a user type. This is a powerful abstraction, because it allows us to generalize
    aspects of features by role type. For example, instead of checking conditions
    based on user properties, we check them based on role properties. It's a lot easier
    to move a user from one role to another, than to modify our logic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 分组与角色分组使我们能够对我们的用户进行分类。想想角色是一种用户类型。这是一个强大的抽象概念，因为它允许我们通过角色类型泛化特征的方面。例如，我们不是基于用户属性检查条件，而是基于角色属性检查条件。将用户从一个角色移动到另一个角色比修改我们的逻辑容易得多。
- en: Figuring out user roles and how they translate into group implementations is
    a tricky subject. The only thing we can count on is having to shuffle around the
    organizational structure of our users. So, making the grouping mechanism as generic
    as possible is our first goal. This has trade-offs too—anything that's completely
    generic has negative performance implications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 确定用户角色以及它们如何转化为小组实施是一个棘手的问题。我们可以确定的是，我们必须调整我们用户的组织结构。因此，使分组机制尽可能通用是我们的第一个目标。这也有一定的权衡——任何完全通用的东西都会有负面的性能影响。
- en: Some grouping decisions will be obvious up front. Like whether users are aware
    of other users in the system or not. If they are, we can start drilling into the
    specific questions around how users communicate with one another using our application.
    Again, this may be obvious based on the types of features our application has.
    The business model we're following influences our user management design as well.
    If we're selling software licenses and likely to be deployed on-premise, then
    we can expect lots of varying needs for user roles, and the subsequent grouping
    implementation. If we're deployed publicly on the internet, grouping is less of
    a concern—we can probably choose a simple approach in favor of performance, for
    example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有些分组决策一开始是显而易见的。比如用户是否意识到系统中还有其他用户。如果他们意识到了，我们可以开始深入探讨用户如何使用我们的应用程序相互沟通的具体问题。再次，这可能基于我们应用程序的功能类型是显而易见的。我们正在遵循的业务模式也影响我们的用户管理设计。如果我们出售软件许可证，并且很可能被部署在本地，那么我们可以预期会有很多不同的用户角色需求，以及随后的分组实现。如果我们公开部署在互联网上，分组就不是那么重要了——我们可以选择一种简单的性能方法，例如。
- en: As our software grows more complex, as we add more features and bring on more
    customers, we'll start to see the need to segregate parts of our application.
    That is, we'll need to tie-down certain features based on access control permissions.
    Rather than having different user roles, install separate software systems; it's
    easier for them to have a single system with users, groups, and access control.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们软件的复杂性增加，随着我们增加更多功能和吸引更多客户，我们将开始看到需要将应用程序的某些部分隔离开来的需求。也就是说，我们需要根据访问控制权限将某些功能绑定下来。与其设立不同的用户角色，安装不同的软件系统；不如让他们拥有一个带有用户、组和访问控制的单一系统更容易。
- en: This has implications for us as JavaScript architects because once we start
    down the access control path, there's no turning back. From that point forward,
    we have to be consistent—every feature needs to check for the appropriate permissions.
    Further complicating matters, is that if we're grouping users this way, we're
    probably going to have to group other entities of our system in a similar fashion
    at some point. Which only makes sense, especially to the end user – this group
    of things is accessed and used by that group of users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们作为JavaScript架构师有深远影响，因为一旦我们走上了访问控制的道路，就无法回头。从那时起，我们必须保持一致性——每个功能都需要检查适当的权限。进一步
    complicating 事情的是，如果我们这样分组用户，我们可能在某个时候以类似的方式对我们的系统中的其他实体进行分组。这是很合理的，特别是对最终用户来说——这一组事物是由那一组用户访问和使用的。
- en: Communicating users
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Communicating users
- en: Another aspect to consider with regard to users, and their relationships with
    one another, is the communication channels available to these users. Do they explicitly
    pick and choose other users to communicate with? Or is the communication more
    implicit? An example of the latter might be a user from the same group as us,
    looking at a chart. This chart is generated based on data that's put into the
    system by other members of the group. Is it worthwhile to think about these sorts
    of implicit communication channels in addition to the explicit ones?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户以及他们之间的关系的另一个方面是，这些用户可用的沟通渠道。他们是否明确地选择其他用户进行沟通？还是沟通更隐性？后者的一个例子可能是我们同一个组的用户，正在查看一个图表。这个图表是基于系统中由小组其他成员输入的数据生成的。除了明确的沟通渠道外，思考这些隐性的沟通渠道是否值得？
- en: The nature of our application determines which communication channels are open
    to our users. It might also depend on the users themselves. Some applications
    have users that need to get in there, and expertly perform a task—communicating
    with other users is unnecessary. On the other hand, we might find ourselves developing
    something that's a little more social-minded. In fact, we might even depend on
    the services of an external social network.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的性质决定了用户可以打开哪些沟通渠道。它可能还取决于用户本身。有些应用程序的用户需要深入其中，熟练地完成一项任务——与 other users
    沟通是不必要的。另一方面，我们可能会发现自己正在开发一些更加注重社交的应用程序。事实上，我们甚至可能依赖外部社交网络的服务。
- en: If we're going to rely on third-party user management, social networks or otherwise,
    we have to be careful how tightly coupled we become with these services. In terms
    of scale, using third-party authentication mechanisms may have social bonus features
    we want—especially considering that most users will love the fact that they don't
    need yet another account to use our application. Scaling this approach to user
    management becomes a problem from other perspectives once we start implementing
    new features, where third-party integration is complex. For example, a photo editing
    application might scale better using a Facebook login, since that's where most
    users' photos originate.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算依赖第三方用户管理，无论是社交网络还是其他方式，我们必须注意我们与这些服务耦合的紧密程度。在规模上，使用第三方认证机制可能具有我们想要的社会性增值功能——特别是考虑到大多数用户会喜欢他们不需要再创建另一个账户就能使用我们的应用程序。一旦我们开始实现新功能，第三方集成变得复杂，此时将这种用户管理方法扩展到其他方面将成为一个问题。例如，一个照片编辑应用程序可能会通过使用Facebook登录来扩展得更好，因为大多数用户的照片都来源于此。
- en: Users are going to find a way to communicate with one another if our application
    is useful or fun to use. We can fight it, or we can leverage user communication
    as a tool to help us scale. That is, scale the transparency with which our users
    can point their peers to something useful, that they would otherwise have to go
    and dig-around for.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序有用或有趣，用户会找到彼此沟通的方式。我们可以抵制它，或者我们可以利用用户沟通作为帮助我们扩展的工具。也就是说，扩展用户可以透明地指向对他们有用的东西的能力，否则他们需要去到处寻找。
- en: Support mechanisms
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持机制
- en: It's great to have our JavaScript application just work. Even when everything's
    going according to plan, we've deployed and there are no bugs, we have to support
    the cases where the users have no idea how to use something. Or they've performed
    some action they probably shouldn't have. Or where one of the other ten million
    usability issues are relevant, and swift rescue is in order.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使我们的JavaScript应用程序顺利运行是非常好的。即使一切都在按计划进行，我们已经部署完毕且没有bug，我们仍需要支持那些用户不知道如何使用某功能的情况。或者他们执行了一些他们可能不应该执行的操作。或者有其他十万里挑一的用户体验问题需要迅速解决。
- en: Our support mechanism not scaling can grind our business to a halt. So, in addition
    to our software scaling well, we need to think about how the user support systems
    are going to scale alongside it. Support can be tightly integrated, or farmed
    out to third-party software and personnel.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的支持机制不扩展会让我们的事业陷入停滞。因此，除了我们的软件需要扩展得很好外，我们还需要考虑用户支持系统如何与之一同扩展。支持可以紧密集成，或者外包给第三方软件和人员。
- en: It's better if users don't need support to use our software. That's why we design
    with usability in mind. We walk through the various user experiences, often with
    experts and/or actual users, and integrate design for them in our software. This
    is the most obvious thing we can tackle when it comes to supporting our users.
    Because if we can do this, through usability design, then we can eliminate a large
    portion of the likely support issues we'll face as we scale.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 用户最好不需要支持就能使用我们的软件。这就是为什么我们在设计时考虑易用性。我们走过各种用户体验，通常是与专家和/或实际用户一起，并将为他们整合设计到我们的软件中。这是我们支持用户时可以解决的最明显的问题。因为如果我们能通过易用性设计做到这一点，那么我们就可以消除我们扩展过程中可能遇到的大部分潜在支持问题。
- en: Regardless, we still have to assume that we're not thinking of the support cases
    that will inevitably pop up after deployment. Users are inquisitive. Even if everything
    is going fine, they still might have questions. So we can't really say, "we've
    designed a great user experience for you and everything's working, so go away".
    We need to be responsive with our users' questions and concerns. Because the second
    we're being dismissive about inquiries, we're failing to scale our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们仍然必须假设我们没有考虑到部署后必然会出现的支持案例。用户是好奇的。即使一切都在顺利进行，他们可能仍然会有问题。因此，我们实在不能说：“我们为您设计了一个优秀的用户体验，一切都在运行，所以您走吧。”我们需要对用户的疑问和担忧做出回应。因为一旦我们对询问表现出轻视，我们就未能扩大我们的应用程序。
- en: Can our JavaScript components help with supporting our users? If that's what
    we want, absolutely! In fact, contextual help is probably the most effective.
    If a user has a question about a particular component, and they see a help button,
    right there within the problematic component, then they can use that to submit
    their question. On the receiving end of the support question, there's less confusion.
    We know exactly what the user is trying to do, and spending time creating the
    context around the issue is no longer necessary.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript组件可以帮助支持用户吗？如果我们希望这样，绝对可以！实际上，上下文帮助可能是最有效的。如果用户对某个组件有疑问，并且他们看到在该问题组件中的帮助按钮，那么他们可以利用它来提交他们的问题。在支持问题的接收端，混淆更少。我们确切地知道用户想要做什么，而花时间创建问题周围的上下文不再必要。
- en: This is definitely easier said than done and has other scaling implications
    for us. These contextual help systems aren't effort-free. And should we decide
    to go that route, we' would have to consider contextual help with every feature
    we implement. Can this scale alongside everything else we're doing?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实说起来容易做起来难，对我们还有其他的扩展影响。这些上下文帮助系统并非不劳而获。如果我们决定走那条路，我们必须考虑在实施每个功能时都提供上下文帮助。这个方法能与我们在做的其他事情一起扩展吗？
- en: Another approach we might want to consider is a knowledge base with information
    from the organization creating the software, and also from those that use it.
    Those using it for a particular purpose are apt to have better answers than us,
    and these answers are super-valuable. Not only to users looking for answers, but
    also to us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要考虑的另一种方法是一个知识库，其中包含来自创建软件的组织以及使用它的那些人的信息。为特定目的使用它的人很可能比我们更有答案，这些答案极具价值。不仅对寻找答案的用户有价值，对我们也是如此。
- en: Feedback mechanisms
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反馈机制
- en: Is feedback really worth differentiating from support? Support is definitely
    feedback. If we pay attention to the various support issues we encounter over
    time, we can transform it into feedback and use this information as feedback.
    However, it's still worth differentiating the two forms, because the user is in
    a different frame of mind. While experiencing a support issue, there's frustration,
    ranging from mild to intense. This user doesn't care about improving the product
    now—they need to get their job done.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 是否真的需要将反馈与支持区分开来？支持无疑是反馈。如果我们关注随着时间的推移遇到的各种支持问题，我们可以将其转化为反馈，并利用这些信息作为反馈。然而，区分这两种形式仍然是有价值的，因为用户的心态是不同的。在体验支持问题时，从轻微到强烈的挫折感都有。现在的用户并不关心改进产品——他们需要完成自己的工作。
- en: On the other hand, users who've used our software for a while grow acutely aware
    of the inefficiencies of their workflow. Collecting this type of feedback is crucial.
    How do we get it? One option is supplying a feedback button in the application,
    as we would with a contextual support button. Another option is to let a third-party
    handle feedback collection. As with support, automating the context is always
    better for us when it comes to understanding what the user is talking about without
    spending too much time on it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用我们软件一段时间的用户会高度意识到他们工作流程的低效。收集这类反馈至关重要。我们如何获得它？一种方法是在应用程序中提供一个反馈按钮，就像我们为上下文支持按钮所做的。另一种方法是让第三方处理反馈收集。对于理解用户在谈论什么，自动化上下文总是对我们更有利，这样我们就不用花太多时间在上面。
- en: The key with feedback is keeping customers engaged. Not everyone who uses our
    software is going to share their thoughts with us. But some no doubt will—even
    if they're just venting frustration. We have to respond to these in order to establish
    a dialog. Users who supply feedback like this want us to respond to them. And
    it's in the ongoing conversation with these users where the product improvements
    emerge, not in the brilliant ideas initially submitted by users.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与反馈相关的一个重要方面是保持客户的参与度。并非所有使用我们软件的人都会与我们分享他们的想法。但无疑有些人会的——即使他们只是在发泄不满。我们必须回应这些反馈，以建立对话。提供这类反馈的用户希望我们回应他们。而这些用户的持续对话是产品改进的来源，而不是用户最初提交的那些辉煌想法。
- en: As our user base grows, can we keep up and stay responsive to user feedback?
    Obviously this is a challenge, given everything else that's on our plate, dealing
    with our application's growth. It's one thing to create dialog around a given
    piece of user data, but it's another to act on that feedback. Suppose we've enabled
    great feedback mechanisms, embedded in our software. We will have to turn this
    into actionable work at some point. So, we need to think about how our process
    of generating requirements based on user feedback scales. If it doesn't, and user
    feedback is never acted upon, they'll bail and we will have failed to scale.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的用户基础增长，我们能否保持响应并积极地响应用户反馈？显然，这是一个挑战，鉴于我们桌上还有其他一切事情，处理应用程序的增长。创建围绕给定用户数据的对话是一回事，但采取行动又是另一回事。假设我们已经为我们的软件集成了伟大的反馈机制。我们最终必须将其转化为可执行的工作。因此，我们需要考虑我们的基于用户反馈生成需求的过程如何扩展。如果它不能，并且用户反馈从未被执行，他们将会放弃，我们就未能实现扩展。
- en: Notifying users
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知用户
- en: JavaScript applications need to display notifications to its users. These can
    be fairly straightforward to implement, especially if we're mainly concerned with
    responding to user actions. For example, when users do something, it results in
    an API request to the back-end. We will want to display a notification to the
    user, indicating that the action has succeeded or failed. These notifications
    look the same across the application—we can use the same tool for most, if not
    all, notifications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用程序需要向其用户显示通知。这些实现起来可能相当直接，尤其是如果我们主要关心响应用户行为的话。例如，当用户做某事时，它会导致向后端发送API请求。我们想要向用户显示一个通知，指示该操作是否成功或失败。这些通知在应用程序中看起来都一样——我们可以为大多数甚至所有通知使用相同的工具。
- en: Notifications are easy to forget about in terms of designing a scalable JavaScript
    architecture. It's a big topic—there are contextual notifications, general notifications,
    and notifications that take place when the user is offline. The latter generally
    means that something has been emailed to the user, prompting them to log in and
    take action if need be.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计可扩展的JavaScript架构时，通知很容易被忘记。这是一个大话题——有上下文通知、一般通知以及用户离线时发生的通知。后者通常意味着已经向用户发送了电子邮件，提示他们登录并采取必要的行动。
- en: The contextual notifications are probably the most important, as they supply
    feedback to the user on something they're currently doing. This is challenging
    to scale because we have to ensure that these types of notifications remain consistent
    across the user interface, for all types of entities. The more general notifications
    take place as a result of something happening in the background.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文通知可能是最重要的，因为它们向用户提供了关于他们当前正在做的事情的反馈。确保这些通知在用户界面上保持一致，对于所有类型的实体来说是一个挑战。更一般的通知是作为后台发生某事的结果而发生的。
- en: Some resource that belongs to a user may have changed state, either expectedly
    or unexpectedly. Regardless, the user probably wants to know about these events.
    Ideally, if they're logged in and using the system, then a generic notification
    will reveal itself. However, we may want these types of notifications emailed
    to users as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 属于用户的某些资源可能已经改变了状态，要么是预期之中，要么是出乎意料。无论如何，用户可能希望知道这些事件。理想情况下，如果他们登录并使用系统，那么一个通用的通知会自动显示。然而，我们可能还希望将这些通知通过电子邮件发送给用户。
- en: The challenge with any notification system is volume. If there are a lot of
    users, and they're fairly active, a lot of notifications will need to be generated
    and delivered. This will no doubt interfere with the performance of other components
    in our code. We're also faced with the configurability that comes with notifications.
    We'll never get the notifications right for all of our users, so we'll need some
    degree of notification tuning. The right level that scales our application is
    up to us JavaScript architects and developers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任何通知系统的挑战都是数量问题。如果有很多用户，而且他们相对活跃，将需要生成和传递大量的通知。这无疑会干扰我们代码中其他组件的性能。我们还面临着通知带来的可配置性问题。我们永远不可能为所有用户正确设置通知，因此我们需要一定的通知调整程度。找到使应用程序可扩展的正确通知级别取决于我们JavaScript架构师和开发者。
- en: User metrics
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户指标
- en: The best way to approach the question of how users interact with our software
    is through data. Certain data points cannot be guessed at or manually collected.
    This is where we need to rely on tools that automatically collect user metrics
    as they interact with our software. With the raw data in place, we're well-equipped
    to analyze what we see, and make decisions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 了解用户如何与我们的软件互动的最佳方式是通过数据。有些数据点是无法猜测或手动收集的。这就是我们需要依赖能够自动收集用户指标的工具的地方，这些工具在用户与我们的软件互动时发挥作用。有了原始数据，我们就能够很好地进行分析，并做出决策。
- en: While it makes sense to automate this task, the task may not be necessary in
    the first place. It may only be worthwhile to collect user metrics when we're
    really unsure about the future direction of a given feature, or when we want further
    insight on what work to prioritize. A lot of the time, we can get these answers
    without much effort, and 'there'll certainly be no need for analytical tools.
    We may not even be permitted to collect such data if we've deployed on-premise
    somewhere.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动化这个任务是有意义的，但这个任务可能根本就不必要。如果我们真的不确定一个特定功能的未来方向，或者当我们想要更深入地了解应该优先处理什么工作时，收集用户指标可能是有价值的。大多数时候，我们可以不费吹灰之力地得到这些答案，当然也不需要分析工具。如果我们部署在本地，我们可能甚至不被允许收集这样的数据。
- en: There's a ton of good third-party metric collection tools available. These are
    especially helpful because they ship with a lot of the reporting we need. And
    a lot that we don't. There's also the question of how tightly integrated we want
    our third-party components. There's always a chance that we would need to turn
    such a feature off. Or, at least change where such data is stored.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有很多好的第三方指标收集工具。这些工具特别有帮助，因为它们附带了我们需要的很多报告。还有我们不需要的很多报告。还有一个问题是我们希望第三方组件多么紧密地集成。总是有可能我们需要关闭这样的功能。或者，至少改变数据存储的位置。
- en: There are a number of uses for this data other than just input for product direction
    decisions. Our code can take user metric data and reflectively improve the experience.
    This could be something as innocent as making suggestions on what to do next,
    based on past events. Or we could get really fancy and make efficiency optimizations
    based on this data. It all comes down to the common case of what our users want.
    Figuring out what our users want is a scaling problem in and of itself, because
    as we grow, we acquire more users who all want different things. User metrics
    could turn out to be a helpful tool with which to combat this issue.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据除了作为产品方向决策的输入之外，还有许多其他用途。我们的代码可以利用用户指标数据反思性地改善体验。这可能仅仅是基于过去事件提出下一步建议。或者，我们可以根据这些数据进行效率优化。这一切都取决于我们的用户想要什么。确定用户想要什么是一个本身具有扩展性的问题，因为随着我们的成长，我们会吸引更多想要不同东西的用户。用户指标可能最终成为解决这个问题的有力工具。
- en: Scaling users example
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: scaling users example（规模用户示例）
- en: Our software firm is developing an online lending application. It's fairly straightforward;
    there's not a lot of moving parts in the front end. The applicant first creates
    an account, and then can apply for a new loan and manage existing loans. The business
    model of this application is consumption-based. We earn revenue through interest
    on the loans, so the more the loans consumed, the more we earn.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的软件公司正在开发一个在线贷款应用。这个应用相当直接；前端没有太多的移动部件。申请人首先创建一个账户，然后可以申请新贷款并管理现有贷款。这个应用的商业模型是基于消费的。我们通过贷款的利息来赚取收入，所以贷款消费得越多，我们赚的钱就越多。
- en: The obvious scaling influencers are user volume and ease of use. Part of our
    value proposition is low interest on small loans. There should be very little
    overhead for the users when applying for a new loan; minimal input required, and
    minimal wait time for the loan application to succeed or fail. This is our highly
    focused vision for delivering value, and some of more apparent scaling influencers
    we'll be up against.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，影响规模扩展的因素包括用户数量和易用性。我们价值主张的一部分是小型贷款的低利率。当用户申请新贷款时，应该几乎没有 overhead；所需输入最少，贷款申请成功或失败的等待时间也最少。这是我们提供价值的高度聚焦的愿景，也是我们将面临的一些更明显的规模扩展影响因素。
- en: Let's think about some of the more subtle implications of our application with
    regard to scale. Given the type of application this is, we're unlikely to see
    requests for social functions. For the most part, the user can be treated as a
    black box; they're in their own little universe when using our application. Since
    ease of use is very important to us, and our application has few moving parts,
    support and feedback are unlikely factors when it comes to scale. We can't eliminate
    support and feedback, but our focus on those areas can be minimal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下我们应用在规模方面的更微妙的含义。鉴于这类应用的性质，我们不太可能看到对社交功能的请求。在大多数情况下，用户可以被视为一个黑箱；当使用我们的应用时，他们处于自己的小宇宙中。由于易用性对我们来说非常重要，而且我们的应用没有太多复杂的部分，因此在规模方面，支持和反馈不太可能是关键因素。我们无法消除支持和反馈，但在这些方面的关注可以最小化。
- en: On the other hand, we need to market our service and we really have no idea
    what our customers are getting loans for, what are the most popular repayment
    schedules, and so on. For this, we can probably deliver a more effective market
    message, as well as improve our overall user experience. The implication here
    being that collecting meta data about our application is a big deal. Since we're
    after large user numbers, the implication is that we'll need to store lots of
    meta data. We'll also have to design each feature in such a way that we can collect
    metrics and store them for later use, which complicates the design.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们需要推广我们的服务，我们真的不知道我们的客户为什么要贷款，最受欢迎的还款计划是什么，等等。为此，我们可能能够提供更有效的市场信息，以及改善我们的整体用户体验。这里的含义是，收集我们应用的元数据是一件大事。由于我们追求大量用户，这意味着我们将需要存储大量的元数据。我们还需要以这样的方式设计每个功能，以便我们可以收集指标并稍后使用，这使得设计变得复杂。
- en: Scaling features
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展功能
- en: Now we'll turn our attention to scaling the features we implement in our software.
    The users are the ultimate influence, and now that we have a rough idea of what's
    required in terms of scaling them, we can put this knowledge to work with feature
    development. When we think about scaling users, we're thinking about the why.
    Why do we choose this business model over that business model? Why do we need
    to enable things for one user role, and disable them for others? Once we get into
    actually designing and implementing the feature in JavaScript, we start thinking
    of the how. Not only are we concerned about correctness, but also scalability.
    As with users, influencers are the determinant when it comes to scalable features.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注如何扩展我们软件中实施的功能。用户是最终的决策者，现在我们已经有了关于在规模方面需要什么的大致想法，我们可以将这些知识应用于功能开发。当我们考虑扩展用户时，我们是在思考为什么。我们为什么选择这个商业模式而不是那个商业模式？为什么我们需要为其中一个用户角色启用事物，而为其他角色禁用它们？一旦我们开始用JavaScript设计和实现功能，我们开始思考如何。我们不仅关心正确性，也关心扩展性。与用户一样，影响者是决定可扩展功能的关键。
- en: Application value
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用价值
- en: We'd like to think that we're doing a good job with the features we implement,
    and that with each new feature we introduce, we're providing value to the user.
    It's worthwhile for us to think about this, because in essence, that's what we're
    trying to do—scale the value of our software to a broader audience. An example
    of not scaling, in this regard, is when existing users who rely on existing features
    are neglected, and feel disappointed with our software because we've focused on
    scaling new areas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为我们在实施的功能方面做得很好，并且每次我们引入新功能时，我们都在为用户提供价值。值得我们思考这一点，因为本质上，这就是我们试图做的事情——将我们软件的价值扩展到更广泛的受众。在这方面没有扩展的一个例子是，当现有用户依赖现有功能而被忽视，并对我们软件因为我们关注了新的领域而感到失望。
- en: This happens when we forget about the problems we had originally set out to
    solve with our software. It might sound like a ridiculous notion, but it's easy
    to move in a completely different direction based on a number of factors. In some
    rare cases, this change in direction has led to some of the most successful software
    the world has seen. In the more common case, it leads to failed software, and
    it is indeed a scaling problem. There's a core set of value propositions our software
    should always deliver—this is the essence of our software and should never falter.
    We're often faced with other scaling influencers, like the addition of new customers
    who want different things from the core values offered by our software. The inability
    to handle this means we're not able to scale the main value proposition of our
    application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们忘记了我们最初为软件解决的问题时，这种情况就会出现。这听起来可能是个荒谬的观念，但根据许多因素，我们很容易走向完全不同的方向。在某些罕见的情况下，这种改变方向导致了世界上一些最成功的软件。在更常见的情况下，它导致软件失败，确实是一个扩展问题。我们的软件应始终提供一组核心价值主张——这是我们软件的精髓，绝不能动摇。我们经常面临其他扩展影响因素，如新客户希望从我们的软件提供的核心价值中得到不同的事物。无法处理这意味着我们无法扩展应用程序的主要价值主张。
- en: An indicator that we're headed down the wrong path when it comes to scaling
    value is confusion with current value and ideal value. That is, what our software
    currently does versus what we might like it to do someday. We have to be forward
    thinking, there's no doubt about that. But future plans need to be continuously
    sanity-checked against what's possible. And this often means backtracking to why
    we set out to create the software in the first place.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩大价值时走向错误方向的一个指标是与当前价值和理想价值混淆。也就是说，我们的软件目前所做与将来我们可能希望它做的事情之间的区别。我们必须向前看，这是毫无疑问的。但是，未来计划需要不断与可能实现的事情进行理智的检查。这通常意味着回溯我们最初创建软件的原因。
- en: If our application is really compelling, and we hope that it is, then we have
    to fight against other scaling influencers to keep it that way. Maybe this means
    that part of our process for evaluating new features involves ensuring the feature
    in some way contributes to the core value proposition features of our software.
    Not all features under consideration will be able to, and these deserve the most
    scrutiny. Is it really worth the change in direction, and jeopardy to our ability
    to scale?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序真的很吸引人，我们希望它是这样，那么我们必须对抗其他有影响力的扩张因素，以保持这种方式。也许这意味着我们评估新功能的过程的一部分涉及确保该功能以某种方式贡献于我们软件的核心价值主张功能。并非所有考虑中的功能都能做到这一点，这些功能应受到最严格的审查。改变方向真的值得吗，会危及我们扩展能力吗？
- en: Killer features versus features that kill
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杀手级功能与功能致死
- en: We want our application to stand out from the crowd. It'd be nice if there were
    a niche-enough market where we had little to no competition. Then it would be
    easy to implement stable software that just works, without anything fancy, and
    everyone would be happy. Given that this isn't reality, we have to differentiate—one
    such way to do this is by implementing a killer feature—which is an aspect of
    our software that nobody else has, and something users care deeply for.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的应用程序能够脱颖而出。如果有一个足够细分的市场，我们几乎没有任何竞争，那会很不错。那样我们就可以轻松实现稳定且无需花哨功能的软件，大家都会很满意。鉴于这并非现实，我们必须进行区分——实现杀手级功能就是其中之一，这是我们的软件独有的方面，也是用户非常关心的。
- en: The challenge is that killer features are rarely planned. Instead, they're a
    side-effect of something else going well in the delivery of our application. As
    we continuously mature our application, refining and tweaking features, we'll
    stumble upon that one "minor" change that evolves into a killer feature. It's
    no surprise that this is often the way killer features come into being. By listening
    to our customers and meeting scaling requirements, we're able to evolve our features.
    We add new features, take some away, and modify existing features. If we do that
    successfully for long enough, the killer features will reveal themselves.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于，杀手级功能很少是计划好的。相反，它是我们在交付应用程序时其他事情做得好的副作用。随着我们不断成熟应用程序，精炼和调整功能，我们会偶然发现那个演变成杀手级功能的“小”变化。杀手级功能往往就是这样产生的，这并不令人惊讶。通过倾听客户的需求和满足扩展要求，我们能够发展我们的功能。我们增加新功能，减少一些功能，修改现有功能。如果我们成功地这样做足够长的时间，杀手级功能就会显现出来。
- en: Sometimes it's clear during the planning of a given feature that it's trying
    to be a killer feature, for the sake of being a killer feature. That's not optimal.
    Nor is it valuable to the user. They didn't choose our software because we had
    "lots of killer features" on our product roadmap. They chose us because we do
    something they need done. Possibly more efficiently than the alternatives. As
    we start thinking about killer features for their own sake, we start gravitating
    away from the core values of our application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在规划某个功能时很清楚地意识到它试图成为一个杀手级功能，仅仅是为了成为一个杀手级功能。这不是最优的。这对用户也没有价值。他们选择我们的软件不是因为我们产品路线图中“有很多杀手级功能”。他们选择我们是因为我们能为他们做到他们需要的事情。可能比其他替代方案更有效率。当我们开始思考为了杀手级功能而思考时，我们开始偏离应用程序的核心价值观。
- en: The best solution to this problem is an open environment, one that welcomes
    input from all team members at feature inception time. The earlier we're able
    to kill a bad idea, the more time we will save by not working on it. It's not
    always as clear-cut as this, unfortunately, and we have to do some development
    on the feature in order to discover that one or more aspects don't scale well.
    This could be for any number of reasons, but it's not a total loss. If we're still
    willing to pull the plug on a feature after development has commenced, then we
    can learn a valuable lesson.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题最好的解决方案是一个开放的环境，它欢迎在功能构思阶段所有团队成员的输入。我们越早能够杀死一个糟糕的想法，我们就越能节省时间，不用在它上面工作。不幸的是，情况并不总是这么清晰，我们必须在功能上做一些开发，才能发现其中一个或多个方面扩展得不好。这可能是由于任何number
    of reasons，但这不是完全的损失。如果我们仍然愿意在开发已经开始后取消一个功能，那么我们可以学到一个宝贵的教训。
- en: When things don't scale and we decide to terminate the feature, we'll be doing
    our software a favor. We're not compromising our architecture by forcing something
    on it that doesn't work. We'll reach a point during the development of any feature
    where we'll need to ask ourselves; "do we value this feature more than the architecture
    we have in place, and if so, are we willing to change the architecture to accommodate
    it?" Most of the time, our architecture is more valuable than the feature. So
    putting a stop to developing something that doesn't fit can serve as a valuable
    lesson. In the future, we'll have a better idea of what will scale and what won't,
    based on this cancelled feature.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情无法扩展并且我们决定终止功能时，这对我们的软件来说是一种帮助。我们没有通过向其强制推行不适用的事物来妥协我们的架构。在开发任何功能的过程中，我们将达到一个需要问自己的点；“我们是否重视这个功能胜过我们现有的架构，如果是这样，我们愿意改变架构来适应它吗？”大多数时候，我们的架构比功能更有价值。因此，停止开发不适应的功能可以作为一个宝贵的教训。在未来，我们将根据这个被取消的功能更好地了解哪些功能可以扩展，哪些不能。
- en: Data-driven features
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据驱动的功能
- en: It's one thing to have an application with a large and varied user base. It's
    another to be able to make use of the ways they interact with our software by
    collecting data. User metrics are a powerful tool for collecting information pertinent
    to making decisions about our software, and the future direction it takes. We'll
    call these data-driven features.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有具有大量不同用户基础的应用程序是一回事。另一回事是我们能够通过收集数据来利用他们与我们的软件互动的方式。用户指标是收集与软件决策和未来发展方向相关的信息的强大工具。我们将这些称为数据驱动的功能。
- en: In the beginning, when we have few or no users, we obviously can't collect user
    metrics. We'll have to rely on other information, such as the collective wisdom
    of our team. We've all likely worked on JavaScript projects in the past, so we
    have enough of a rough idea to get the product off the ground. Once there, we
    need tools in place to better support our decisions on features. In particular,
    which features we need versus those that we do not? As our software matures, and
    we collect more user metrics, we can further refine our features to match the
    reality of what our users need.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初阶段，当我们没有用户或者很少有用户时，我们显然无法收集用户指标。我们将不得不依赖其他信息，比如我们团队的集体智慧。我们都可能在过去参与过JavaScript项目，因此我们有足够的信息来让产品起飞。一旦产品上线，我们需要工具来更好地支持我们的功能决策。特别是，我们需要了解哪些功能是我们需要的，哪些是不需要的？随着我们软件的成熟，我们收集到更多的用户指标，我们可以进一步完善我们的功能，以满足用户的实际需求。
- en: Having the necessary data to make a feature data-driven is a challenging feat
    to scale, because we need the mechanism to collect and refine the data in the
    first place. This requires development effort that we simply may not have. Additionally,
    we have to actually make the decisions about features based on this data—the data
    alone isn't going to turn itself into requirements for us.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有使特性数据驱动所需的必要数据是一个难以扩展的挑战，因为我们首先需要收集和精炼数据的机制。这需要我们可能根本不存在的开发努力。此外，我们实际上必须根据这些数据做出关于特性的决定——数据本身不会自己变成我们的需求。
- en: We'll also want to predict the viability of features we've been asked to implement.
    This task is difficult without data to support our hypotheses. For example, do
    we have any data on the environments in which our application will run? Simple
    data points can be enough to determine that a feature isn't worth implementing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想知道我们被要求实现的特性的可行性。如果没有数据支持我们的假设，这项任务是非常困难的。例如，我们对我们的应用程序将要运行的环境有数据吗？简单的数据点可能足以确定某个特性不值得实现。
- en: Data-driven features work from two angles, that is, the data we collect automatically,
    and the data we supply. Both are difficult to scale, and yet both are necessary
    to scale. The only real solution is to make sure that the number of features we
    implement are small enough in number, so that we can handle the amount of data
    generated by a given feature.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据驱动特性需要从两个角度进行工作，那就是我们自动收集的数据和我们提供数据。这两者都难以扩展，但两者对于扩展都是必要的。唯一的真正解决方案是确保我们实现的特性数量足够少，这样我们就可以处理某个特性生成的数据量。
- en: Competing with other products
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他产品竞争
- en: Unless we're operating in a completely niche market, there's a good probability
    of competing products. Even if we are in a somewhat niche market, there's still
    going to be some overlap with other applications. There're a lot of software development
    firms out there— so we're likely to face direct competition. We compete with similar
    offerings by creating superior features. This means that not only do we have to
    keep delivering top-notch software, but we need to be aware of what the competition
    is up to, and what users of their software think. This is a limiting factor in
    our ability to scale, because we have to spend time understanding how these competing
    technologies work.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们在一个非常利基的市场中运营，否则很可能存在竞争产品。即使我们在某种程度上处于利基市场，与其他应用程序仍然会有一些重叠。有很多软件开发公司——所以我们很可能面临直接竞争。我们通过创建更优越的特性与类似的产品竞争。这意味着我们不仅要不断提供顶级软件，还要注意竞争对手在做什么，以及他们的软件用户怎么想。这是限制我们扩展能力的一个因素，因为我们必须花时间了解这些竞争技术是如何工作的。
- en: If we have a sales force out-selling our product, they're often a good source
    of information on what the other guys are doing. They'll often be asked by prospective
    customers if our software does such and such because this other application does
    it. Perhaps the most compelling selling point is that we can deliver that feature,
    and we can do it better.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个销售团队在销售我们的产品，他们往往是关于竞争对手在做什么的好信息来源。他们经常会被告知潜在客户我们的软件是否能做到这样那样，因为其他应用程序能做到。或许最有说服力的销售点是我们能够提供那个特性，而且我们能做得更好。
- en: This is where we must be careful, as this is yet another scaling factor that
    limits our ability to win customers. We have to scale to promises we make to existing
    and prospective customers. Promise too much, and we won't be able to implement
    the features, leading to disappointed users. Promise too little, or nothing at
    all, and we won't win customers in the first place. The best way to combat this
    scaling limitation is to ensure that those selling our product are kept well in
    touch with the reality of our software. What it can and cannot do, what's a future
    possibility versus impractical options.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须小心这里，因为这又是限制我们赢得客户能力的另一个扩展因素。我们必须扩展我们对现有和潜在客户的承诺。承诺过多，我们将无法实现特性，导致用户失望。承诺过少，或者根本不承诺，我们一开始就无法赢得客户。克服这种扩展限制的最佳方式是确保那些销售我们产品的人与我们的软件现实保持良好联系。它能做到什么，不能做到什么，哪些是未来的可能性，哪些是不切实际的选项。
- en: To sell our product, there has to be some wiggle room for promising some things
    without understanding the full implications of implementing such promises. Otherwise,
    we won't get the customers we're after, because we're not generating any excitement
    around our product. If we're going to scale this approach to selling to new customers,
    we need a proven means to distill the promises into something that's achievable.
    On the one hand, we can't compromise the architecture. On the other hand, we have
    to meet somewhere in the middle to give the user what they need.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了销售我们的产品，必须在承诺一些事情而不了解实现这些承诺的全部影响上留有回旋余地。否则，我们将无法获得我们想要的目标客户，因为我们没有围绕我们的产品产生任何兴奋感。如果我们要将这种销售方法扩展到新的客户，我们需要一种经过验证的方法，将承诺提炼成可实现的东西。一方面，我们不能妥协架构。另一方面，我们需要在中间找到某种平衡，以满足用户的需求。
- en: Modifying existing features
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改现有功能
- en: Long after we've successfully deployed our JavaScript application, we're still
    constantly refining the design of our code and the overall architecture. The only
    constant is change, or something to that effect. It takes a sizeable amount of
    discipline to go back and modify existing features of our software in an effort
    to improve the experience for users. The reason is that we feel more pressure
    from stakeholders to add new features. This presents a long-term scaling problem
    for our application because we can't add new features forever, without ever improving
    what's already in place.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们成功部署了我们的JavaScript应用程序之后，我们仍然在不断优化我们的代码和整体架构的设计。唯一不变的是变化，或者类似的东西。需要大量的纪律性回到软件的现有功能上进行修改，以改善用户的体验。原因是我们有更多的压力来自利益相关者要求添加新功能。这对我们的应用程序来说是一个长期的可扩展性问题，因为我们不能永远添加新功能，而从不改进已经存在的内容。
- en: The unlikely scenario is that there's no need to change anything; all our existing
    users are happy and they don't want us to touch anything. Some users are afraid
    of change, which means they like aspects of our software because we did a good
    job implementing them. We obviously want more features that are this good, by
    which, users are generally happy and don't see a need to improve.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不太可能的情况是，我们不需要更改任何东西；我们所有的现有用户都很满意，他们不想让我们碰任何东西。一些用户害怕变化，这意味着他们喜欢我们软件的某些方面，因为我们在实施方面做得很好。显然，我们想要更多这样好的功能，通过这种方式，用户通常很满意，并且看不到改进的需要。
- en: So how do we reach this point? We have to listen to user feedback, and base
    our roadmap for modifying features on this feedback. To keep scaling along with
    our users and their demands, we have to strike a balance between implementing
    new features and modifying existing features. One way to check if we're moving
    in the right direction with feature enhancements is to broadcast the proposed
    changes to our user base. We can then gauge the feedback we get, if any. In fact,
    this might entice our otherwise quiet users to give us some specific suggestions.
    It's a way of putting the ball in the user's court—"here's what we're thinking,
    what do you think?"
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何达到这个阶段呢？我们必须倾听用户的反馈，并根据这些反馈制定修改功能的路线图。为了与我们的用户及其需求一起扩展，我们必须在实施新功能和修改现有功能之间找到平衡。检查我们是否在正确的方向上改进功能的一种方法是将拟议的更改广播给我们的用户基础。然后我们可以衡量我们收到的任何反馈。实际上，这可能会促使我们那些通常安静的用户给出一些具体的建议。这是一种将球抛给用户的方法——“这是我们正在考虑的，你们觉得呢？”
- en: Beyond figuring out what features to improve and when to improve them relative
    to implementing new features, there's the architectural risk. How tightly coupled
    is our code? Can we isolate a feature to the extent that there's no chance of
    us breaking other features? We're never going to completely eliminate this risk—we
    can only reduce coupling. The scaling issue at play here is how much time do we
    spend modifying a given feature due to re-factoring, fixing regressions, and so
    on? We spend less time on these activities when our components are loosely-coupled,
    consequently, we can scale our feature enhancements. From a management point of
    view, we always run the risk of blocking other people in the organization, through
    conflicts brought about by our changes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定要改进哪些功能以及何时相对于实施新功能来改进它们之后，还存在架构风险。我们的代码耦合度有多紧密？我们能将一个功能隔离到什么程度，以至于我们不会破坏其他功能？我们永远不可能完全消除这种风险——我们只能减少耦合。在这里起作用的规模问题是我们花在修改给定功能上的时间，由于重构、修复回归等等原因？当我们的组件松耦合时，我们会花更少的时间在这些活动上，因此，我们可以扩展我们的功能改进。从管理的角度来看，我们总是有因为我们的更改而阻碍组织中其他人的风险。
- en: Supporting user groups and roles
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持用户组和角色
- en: Depending on the type of business model we're following and the size of our
    user base, user management becomes a scaling issue for us because it touches every
    feature we implement. This is further complicated by the fact that the user management
    is likely to change just as frequently as the feature requirements are. As our
    application grows, we'll likely be dealing with roles, groups, and access control.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们遵循的商业模式和我们的用户基础大小，用户管理对我们来说成为一个扩展问题，因为它触及我们实施的每一个功能。这种问题进一步复杂化，因为用户管理很可能与功能需求一样频繁地更改。随着我们的应用程序的增长，我们可能会处理角色、组和访问控制。
- en: There are a lot of side-effects with complicated user management. The new feature
    we've just implemented may work perfectly fine initially, but fail in a number
    of other scenarios our production customers are likely to face. This means that
    we need more time dedicated to testing features, and the quality assurance team
    is probably already overwhelmed. Not to mention the additional security and privacy
    implications that arise from complicated user management in each of our features.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理复杂时会有很多副作用。我们刚刚实施的新功能可能最初运行得非常好，但在我们的生产客户可能面临的大量其他场景中失败。这意味着我们需要花更多的时间来测试功能，并且质量保证团队可能已经不堪重负。更不用说由于每个功能中用户管理的复杂性而产生的额外的安全和隐私问题。
- en: We can't really do much about complex user management schemas, as they're often
    symptomatic of the organization using the application, and its structure. We're
    more likely to face these types of complexities with on-premise deployments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并不能做太多关于复杂的用户管理架构的事情，因为它们往往是使用应用程序的组织及其结构的症状。我们在本地部署时更有可能面临这类复杂性。
- en: Introducing new services
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入新服务
- en: There comes a point where the current back-end services no longer suffice for
    new features. We can scale our front-end development efforts better when there's
    very little dependency on the back-end. If that sounds counter-intuitive, don't
    worry. It's true that we need back-end services to carry out the requests of our
    users. So the dependency will always be there. What we want to avoid is changing
    the API unnecessarily.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，现有的后端服务不再足以支持新功能。当前端开发工作的依赖性非常小的时候，我们可以更好地扩展我们的前端开发工作。如果这听起来违反直觉，不用担心。确实，我们需要后端服务来执行用户的请求。因此，依赖关系总是存在的。我们想要避免的是不必要的更改
    API。
- en: If there's a way to implement the feature using existing APIs, we do it. This
    lets the back-end team focus on stability and performance by fixing bugs. They
    can't do that if the API constantly has to change in order to support our features.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够使用现有 API 实现功能，我们就这样做。这样后端团队可以专注于通过修复漏洞来提高稳定性和性能。如果 API 必须不断更改以支持我们的功能，他们就无法做到这一点。
- en: Sometimes there's no getting around adding new back-end services. In order to
    scale our development process, we need to know when new services are necessary,
    and how to go about implementing them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时不可避免地需要添加新的后端服务。为了扩展我们的开发过程，我们需要知道何时需要新的服务，以及如何实施它们。
- en: The first question is the necessity of the new service. Sometimes this is easy—it's
    not possible to implement the requested API. We'll have to make do with what's
    there. The second question is the feasibility of the new service. We'll likely
    form the shape of the new API since we're the ones who need it. Then we'll have
    to hear what the back-end team thinks. If we're a team with full-stack developers,
    there's less overhead because we're likely all on the same team and in closer
    communication with one another.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是要评估新服务的必要性。有时候这很简单——无法实现所需的 API。我们将不得不将就使用现有的东西。第二个问题是新服务的可行性。由于我们需要新的 API，我们很可能形成新
    API 的形状。然后我们需要听听后端团队的意见。如果我们是一个拥有全栈开发人员的团队，开销会比较小，因为我们很可能都在同一个团队中，并且彼此之间的沟通更为密切。
- en: Now that we've decided to go ahead with the new API, we have to synchronize
    the implementation of our feature in the front-end, with the implementation of
    the feature in the back-end. There's no cut-and-dry solution here for us to follow,
    because the service could be easy or difficult to implement. Our feature could
    require several new services. The trick is reaching an agreement on the API and
    having a mocking mechanism in place. Once the real service is available, it's
    a time matter of disabling the mock.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经决定推进新的API，我们必须同步前端和后端特性的实现。这里没有我们可以遵循的一刀切的解决方案，因为服务可能容易或难以实现。我们的特性可能需要几个新的服务。关键是在API上达成一致，并建立一个模拟机制。一旦真正的服务可用，禁用模拟就是时间问题。
- en: However, in terms of scaling our application as a whole, this is just one integration
    point between the front-end features and back-end services. The implications of
    introducing the new feature, for the system, aren't known. We can only guess so
    much through testing and prior knowledge. It's not until production that we will
    see the full implication of how well our new feature scales. Different features
    that use the exact same service have different implications for request load,
    error rate, and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在扩展我们整个应用程序方面，这只是前端功能与后端服务之间的一个集成点。引入新特性对系统的影响是未知的。我们只能通过测试和先验知识猜测这么多。直到生产环境，我们才会看到我们新特性扩展效果的全面影响。使用完全相同服务的不同特性对请求负载、错误率等有不同的影响。
- en: Consuming real-time data
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费实时数据
- en: It's commonplace in JavaScript applications to have socketed connections to
    back-end data, in order to keep any user sessions synchronized with the reality.
    This simplifies some areas of our code while complicating others. The implications
    for scaling are substantial. Sending real-time data over web socket connections
    is what's called "pushing data". The prevailing technique prior to web socket
    connectivity was long-polling HTTP requests. This basically meant that instead
    of the data being delivered to clients when it changed, the client was responsible
    for checking if the data had changed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript应用程序中，为了保持用户会话与现实同步，通常会有面向后端数据的有状态连接。这简化了我们代码的某些方面，同时使其他方面变得复杂。扩展的影响是巨大的。通过WebSocket连接发送实时数据，这被称为“推送数据”。在WebSocket连接之前，主流的技术是长轮询HTTP请求。这意味着，数据不是在改变时交付给客户端，而是客户端负责检查数据是否已更改。
- en: The same scaling issues surrounding real-time data still exist today. With web
    socket technology, some of the burden has been shifted from our front-end code
    to the back-end. It's up to the application services to push web socket messages
    when relevant messages take place. There are a number of angles we need to look
    at here though. For example, does our architecture as a whole rely on the delivery
    of real-time data, or are we only considering real-time data for a single feature?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕实时数据的扩展问题今天仍然存在。有了WebSocket技术，一些负担已经从我们的前端代码转移到了后端。应用程序服务需要在相关消息发生时推送WebSocket消息。然而，我们需要从多个角度来考虑这个问题。例如，我们的整体架构是否依赖于实时数据的交付，还是我们只考虑将实时数据用于单一功能？
- en: If we're considering introducing web-socket connectivity for the first time,
    to better support a new feature, we have to ask ourselves if it's something we
    want to fit into our architecture moving forward. The challenge with real-time
    data only affecting one or two features is a lack of clarity. Developers looking
    at one feature that has real-time data fed into it, versus another that does not,
    will have a hard time addressing things like consistency issues that arise over
    the course of developing our software.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑首次引入WebSocket连接，以更好地支持一个新功能，我们必须问自己是否这是我们要融入我们未来架构中的东西。实时数据只影响一个或两个功能时的挑战在于缺乏清晰性。开发者看到一个实时数据输入的功能与另一个没有实时数据输入的功能相比，在开发我们软件的过程中解决一致性问题会更加困难。
- en: It often makes more sense, and scales better from a number of perspectives,
    to properly integrate real-time data into the code of our front-end architecture.
    Which essentially means that any given component should have access to real-time
    data in the same way as any other component. As always though, the scaling issues
    we face when flowing top-down, from the user and their organization, ultimately
    determines the type of features we implement. This in turn influences the rate
    at which real-time data is published. Depending on the structure of our application,
    and how user data is connected, the frequency with which real-time data is delivered
    to each browser session can fluctuate dramatically. These types of considerations
    have to be made for every feature we implement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，将实时数据适当地集成到前端架构的代码中，在多个方面都有更好的扩展性。这基本上意味着任何给定组件都应该能够像其他任何组件一样访问实时数据。然而，当我们自上而下地流动，从用户及其组织那里面临的可扩展性问题，最终决定了我们实施的功能类型。这反过来又影响了实时数据发布的速度。根据我们应用程序的结构以及用户数据是如何连接的，实时数据每次浏览器会话交付的频率可能会大幅波动。对于我们所实施的每一个功能，都必须考虑这些问题。
- en: Scaling features example
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放功能示例
- en: Our video conference software is popular with large organizations. Mainly due
    to it's stability, performance, and the fact that it's browser-based, without
    the need for plugins. One of our customers has requested that we implement chat
    utilities as well. They like our software so much that they'd rather use it for
    all real-time communication, and not just video conferencing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视频会议软件在大组织中很受欢迎。这主要归功于它的稳定性、性能，以及它基于浏览器，无需插件。我们的一个客户请求我们实现聊天工具。他们非常喜欢我们的软件，以至于他们希望用它来进行所有的实时通信，而不仅仅是视频会议。
- en: The actual implementation of chat utilities at the JavaScript level wouldn't
    be too difficult. We would end up reusing several components that enable our web
    video conferencing functionality. A little re-factoring and we've got the new
    chat components that we need. But there're some subtle differences between text
    chat and video chat with regard to scale.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript层面实现聊天工具并不会太难。我们最终会重用一些使我们的网页视频会议功能成为可能的组件。稍微重构一下，我们就能得到所需的聊天组件。但文本聊天和视频聊天之间在缩放上有一些微妙的区别。
- en: The key difference is the longevity of the text chats versus video chats, where
    the latter is generally a transient occurrence. This means that we need to figure
    out policies for persisting chats. Our video chats don't require user accounts
    to join, in case people want to invite people outside of the organization. This
    is different with text chats because we can't exactly invite anonymous actors,
    and then blow the chat away after they leave. We'll likely have other changes
    to make in our user management components as well. For example, do chat groups
    now correspond to video groups?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的区别在于文本聊天与视频聊天的持续时间，后者通常是一时的。这意味着我们需要找出持久化聊天的方法。我们的视频聊天不需要用户账户加入，以防人们想邀请组织外的人。这与文本聊天不同，因为我们不能确切地邀请匿名参与者，然后在他们离开后取消聊天。我们很可能还需要在我们的用户管理组件中进行其他更改。例如，聊天组现在是否对应于视频组？
- en: Since this is just one customer who's asked for this capability, we'll probably
    want a way to turn it off. Not only does this new feature have the potential to
    detract from our core value—video conferencing—but it can cause problems in deployments
    for other customers. With the new back-end services, the added interface complexity,
    and the additional training and support that's required, it's understandable that
    not all organizations would want this feature enabled. So if this isn't something
    we already have in our architecture, that is, the ability to turn components on
    and off, then that's something else that influences our ability to scale.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是其中一个客户提出了这个要求，我们可能希望有一种方法来关闭它。这个新功能不仅有可能削弱我们的核心价值——视频会议，还可能在对其他客户部署时造成问题。有了新的后端服务、增加的界面复杂性以及所需的其他培训和支持，可以理解并非所有组织都希望启用这个功能。所以，如果我们还没有在我们的架构中实现这一点，即组件的开关功能，那么这也是影响我们扩展能力的一个因素。
- en: Scaling development
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放开发
- en: The last hurdle for us to overcome in terms of scaling influencers is that of
    actually developing the software. Any sufficiently complex JavaScript application
    isn't going to be written in isolation by just one developer. There's a team involved,
    even if it is only ad-hoc and self-organized in an open source context. In other
    institutions, teams and the roles within them are defined more concretely. Regardless
    of how the team is put together, scaling that team is a direct consequence of
    how we react to the other scaling influencers discussed so far in this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展影响因素方面，我们需要克服的最后障碍实际上是软件开发本身。任何足够复杂的JavaScript应用程序都不可能由一个开发者独立编写。即使是在开源环境中，也涉及到一个团队，即使它只是非正式的和自我组织的。在其他机构中，团队及其角色定义更为具体。不管团队是如何组建的，扩大团队的规模是我们如何应对本章中讨论的其他扩展影响因素的直接结果。
- en: The first issue we'll address is the one we're most likely to run into first
    with a nascent software project—finding development resources. A team isn't a
    static thing; we'll have to add new resources as the software grows in code size
    and solution scope. Like it or not, the best resources are the most likely to
    leave as they're the most sought after. Ideally, we can hang on to a talented
    crew, but we will nonetheless have to scale the process of acquiring new resources.
    How and when we hire JavaScript programmers is influenced by the features we're
    implementing, and the architecture we're putting together to to serve the functioning
    of those features.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的首要问题是我们在新兴软件项目中最早遇到的问题——寻找开发资源。团队不是一个静态的事物；随着软件在代码大小和解决方案范围上的增长，我们将不得不添加新资源。不管我们喜欢与否，最好的资源最有可能是那些离开的资源，因为它们最受欢迎。理想情况下，我们可以留住一支有才华的团队，但无论如何，我们将不得不扩大获取新资源的过程。我们如何以及何时招聘JavaScript程序员受到我们要实现的功能和我们要构建的架构的影响，以服务于这些功能的运行。
- en: From a day-to-day perspective, each team member should be responsible for implementing
    a specific chunk of our application. This is a complicated matter, and scaling
    influencers are to blame. We have to be careful about defining our roles for the
    team; to not make them overly restrictive. When things change in response to influencers,
    we need to pivot and deliver. Rigid role definitions don't help us much here.
    Conversely, we need to at least make an attempt to put boundaries in place, if
    there's going to be any level of autonomy in the way our components are developed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从日常角度来看，每个团队成员应该负责实现我们应用程序的特定部分。这是一个复杂的问题，扩展影响因素应该受到责备。我们必须小心地为团队定义角色；不要使它们过于
    restrictive。当事情因影响因素而变化时，我们需要调整并交付。僵化的角色定义在这里对我们帮助不大。另一方面，我们需要至少尝试建立界限，如果我们的组件开发中有任何自主性的话。
- en: Finally, we'll try to figure out if there's a sound approach to determine when
    we potentially have too many development resources. To say it out loud almost
    sounds like a bad thing. We've got all this talent, and all this work to do—it
    seems like those two items go hand-in-hand, do they not? No, not always.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将尝试找出是否有健全的方法来确定我们可能拥有过多的开发资源。大声说出来几乎听起来像是一件坏事。我们拥有所有这些才华，还有这么多工作要做——这两件事似乎是相辅相成的，不是吗？不，并不总是这样。
- en: Finding development resources
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找开发资源
- en: It's tempting, especially for product managers, to hire development resources
    not for what we're currently working on, but for what we've planned to work on
    in the future. But this doesn't scale well for a number of reasons. The first
    issue that new hires are likely to face in this scenario is not being able to
    learn the code by working on real features. Remember, they were hired to work
    on something on the roadmap that we haven't started yet. So they end up trying
    to be useful, but there's no real obligation for them yet. After a couple of weeks,
    they're fighting to stay out of the way of folks who are trying to wrap up work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 诱惑确实很大，尤其是对于产品经理来说，倾向于招聘开发资源不是为了我们现在正在做的工作，而是为了我们计划在将来进行的工作。但是，出于许多原因，这种方法扩展性不佳。新员工在这种情境下首先可能面临的问题是在实际功能上无法通过工作来学习代码。要记住，他们是被招聘来完成我们尚未开始的路标上的某项工作。所以，他们最终试图有所帮助，但现在还没有真正的义务。几周后，他们要努力避免挡住那些试图完成工作的人的路。
- en: It's often better to consider what we're working on now. Is there a clear gap
    in our ability to deliver something that's expected in the next release of our
    software? If there is no well-defined gap, there's nothing for a new programmer
    to fill, and that just creates unnecessary communication overhead. The downside
    is that once we have clearly-defined gaps in our ability to develop the features
    we need, we won't be able to find the resources we need. This pressure can lead
    to hiring the wrong people, who don't gel with the team, for one reason or another.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常更好的做法是考虑我们现在正在做的工作。下一次软件发布中预期会有哪些功能是我们目前能力中缺失的清晰缺口吗？如果没有明确定义的缺口，新程序员就无事可做，这将导致不必要的沟通开销。这种做法的缺点是，一旦我们明确了在开发所需功能方面的能力缺口，我们可能就找不到所需的资源。这种压力可能导致招聘错误的人，这些人可能因为各种原因与团队格格不入。
- en: A better approach to scaling the growth of our development resources is to wait
    till there's a gap. A gap doesn't necessary mean the world is on fire and you're
    going to fail as a company. It just means we could do things better, development-wise.
    We shouldn't try hiring more than one developer at a time if we can avoid it.
    If we take the time needed to find the right resource, then they're likely to
    fill any gaps we've identified with our process and some.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的扩展我们开发资源增长的方法是等待缺口出现。缺口并不意味着世界末日，你的公司要倒闭。它只是意味着我们开发方面可以做得更好。如果我们能避免的话，我们不应该一次尝试招聘超过一个开发者。如果我们花时间找到合适的资源，那么他们很可能会用我们的流程和其他方法填补我们识别出的任何缺口。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The quintessential resource on communication overhead during the software development
    lifecycle is "The Mythical Man-Month", by Fred Brooks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发生命周期中关于沟通开销的经典资源是弗雷德·布鲁克斯的《人月神话》。
- en: Development responsibilities
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发职责
- en: The web browser platform is a complex space, with lots of technologies, and
    lots of moving parts. Some components of the web platform are more greenfield
    than others, but important nonetheless for us to understand. These emerging technologies
    are the future of the web. So who on our team is going to take ownership of learning
    these new technologies and socializing them throughout the organization? The challenge
    with the web platform is that there's more to master than one person can reasonably
    manage while simultaneously delivering product features. This is why we need at
    least some level of development roles.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器平台是一个复杂的领域，有许多技术和许多活动部分。网络平台的某些组件比其他组件更具前瞻性，但对于我们理解来说仍然很重要。这些新兴技术是网络的未来。那么在我们团队中谁来负责学习这些新技术并在整个组织中推广呢？网络平台的挑战在于，要掌握比一个人在同时交付产品功能时合理管理的内容还要多。这就是为什么我们需要至少有一定级别的开发角色。
- en: How strict the boundaries are for these roles is dependent on the organization
    and the culture therein. The nature of the application under development will
    likely influence the types of development roles to setup too. There's no recipe,
    and strictness should be avoided where possible. The reason being that we need
    to adapt to changes brought on by scaling influencers. Strict roles essentially
    impede an otherwise capable developer from putting out fires. We generally don't
    have time for role boundary disputes as deadlines loom.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些角色的边界严格程度取决于组织和其中的文化。正在开发的应用程序的性质可能会影响要设置的开发角色类型。没有固定的食谱，严格性应该在可能的情况下避免。原因是我们需要适应扩展性影响者带来的变化。严格的角色实际上阻碍了其他有能力的开发者扑灭火灾。当截止日期临近时，我们通常没有时间角色的边界争议。
- en: It's the architect of the front-end that's most likely to see the roles that
    make sense for implementing a given application architecture. And these are likely
    transient roles, guided by the architect but formed organically by the members
    themselves. This is especially observable in open source projects where people
    do what they're good at, and hence what they enjoy doing. While we can't always
    adopt this model exactly, we can certainly take cues from it—shape roles around
    what people are good at doing in the context of our feature requirements. Doing
    so will help developers get mentorship where they need it. Being interested in
    some aspect of JavaScript development doesn't mean they're proficient at the level
    they need to be. That's where having a senior person show them the ropes, doing
    something they like doing, has enormous payoffs for the product in the long term.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前端架构师最有可能看到实施给定应用程序架构的合理角色。这些角色很可能是短暂的，由建筑师指导，但由成员本身有机形成。这在开源项目中尤为明显，人们做他们擅长的事情，因此也做他们喜欢做的事情。虽然我们不能总是完全采用这种模式，但我们确实可以从中获得启示——根据我们的功能需求，塑造人们擅长做的事情的角色。这样做将帮助开发者在需要指导的地方获得指导。对JavaScript开发的某些方面感兴趣，并不意味着他们在需要的水平上精通。资深人员指导他们，做他们喜欢做的事情，对产品长期的收益巨大。
- en: Too many resources
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源过多
- en: We've partially addressed the notion that it's easy to hire too many development
    resources— tempting even. When there's a clear roadmap ahead of us defined by
    product management, we want to take comfort in knowing we do in fact have the
    development resources to fulfill our roadmap. Hiring people too fast inevitably
    leads to too many development resources. We may already be there now, and the
    question then becomes what to do about it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们部分解决了这样一个观念：轻易招聘过多开发资源——甚至颇具诱惑。当产品管理为我们定义了一个清晰的路线图时，我们想要安心地知道我们确实拥有足够的开发资源来完成我们的路线图。过快招聘人员不可避免地导致开发资源过多。我们现在可能已经面临这种情况，那么接下来要考虑的就是如何应对。
- en: If we're unhappy with members of our team, and it's clear that we have more
    resources than are needed, the answer is straightforward. However, there's another
    way to look at things, if we have too many good resources we don't want to lose.
    We have to adjust the product roadmap to accommodate the development talent we've
    recruited. This often means finding a channel in which we're able to flow product
    ideas up from development to product management. This is more of an art than a
    science.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对我们的团队成员不满意，并且很清楚我们有比所需更多的资源，答案是显而易见的。然而，如果我们有太多优秀的资源不想失去，还有另一种看待事物的方法。我们需要调整产品路线图，以适应我们招聘的开发人才。这通常意味着找到一个渠道，使我们能够将产品想法从开发传递给产品管理。这更是一门艺术，而不是一门科学。
- en: It's a challenging job, being a front-end architect and figuring out who's going
    to build what. The best way to scale our development resources is to provide an
    accurate map of our architecture to those that are currently implementing it.
    If there's discrepancies, figure out the right path forward. For example, there
    could be gaps and we need more JavaScript programmers, or there could be too many
    resources and something needs to change in the product.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 担任前端架构师是一项具有挑战性的工作，需要确定谁将构建什么。扩展我们的开发资源的最佳方式是向当前正在实施它的人提供一个我们架构的准确地图。如果有差异，找出正确的前进路径。例如，可能存在缺口，我们需要更多的JavaScript程序员，或者可能资源过多，产品中需要有所调整。
- en: Scaling development example
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[扩展开发示例](#扩展开发示例)'
- en: Our application has been around for a while, has seen some success, and is deployed
    in a variety of contexts. One of our core developers, Ryan, touches many areas
    of the code. He helps many other developers improve their code, providing suggestions
    and so on. Our application has reached the point where it's large enough 'for
    us to start noticing performance degradation across all features.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经存在一段时间，取得了一些成功，并在各种环境中得到部署。我们的一个核心开发人员Ryan，触及了代码的许多领域。他帮助许多其他开发者改进他们的代码，提供建议等。我们的应用程序已经达到了一个足够大的规模，以至于我们开始注意到所有功能上的性能下降。
- en: We need Ryan to implement some performance enhancements, which will involve
    re-factoring certain sections of code, and basically occupy all his time. We still
    have features to deliver, if we plan on scaling to meet customer demand. On the
    other hand, we're seeing red flags with our ability to scale performance-wise.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Ryan来实现一些性能优化，这将涉及重构代码的某些部分，基本上会占用他所有的时间。如果我们打算扩大规模以满足客户需求，我们仍然还有功能要交付。另一方面，我们看到了在性能方面扩展能力的红旗。
- en: We realize that we need to hire a new developer to help with new feature development.
    This developer doesn't need Ryan-like chops. They need to have the basics down
    for the technologies we're using. If we're lucky, we'll find someone that grows
    into filling more responsibilities. But for now, the gap left by Ryan that we
    need to fill is fairly narrow. And to scale, we don't need to find another Ryan
    right away.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到我们需要招聘一名新开发者来帮助开发新功能。这名开发者不需要像Ryan那样的技能。他们需要掌握我们所使用技术的基础知识。如果我们运气好，我们会找到一个可以承担更多责任的人。但目前，我们需要填补的由Ryan留下的空缺相当狭窄。而且，为了扩大规模，我们不需要立即找到另一个Ryan。
- en: Influencer checklist
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影响者清单
- en: We'll close out the chapter with a few checklists. These are simple questions
    for which there's no one correct answer. Some answers will remain the same throughout
    the lifetime of our software. For example, our business model will, hopefully,
    'not change often. Others depend on the current state of things, and that's what
    these lists are for. We can come back to them again and again, anytime something
    changes. These could be requirements, users, new deployments, or changes to the
    development environment. These questions are nothing more than subtle reminders
    of the factors that influence scalable JavaScript applications. If reading them
    results in more questions than answers, then they've served their purpose.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用几个清单来结束这一章。这些问题很简单，没有唯一正确的答案。有些答案将贯穿我们软件的整个生命周期。例如，我们的商业模式希望“不会经常改变”。其他答案取决于当前的情况，这就是这些清单的目的。我们可以随时回来再次查看，无论何时发生变化。这可能是需求、用户、新的部署或开发环境的变化。这些问题不过是影响可扩展JavaScript应用程序的因素的微妙提醒。如果阅读它们导致的问题比答案多，那么它们就发挥了作用。
- en: User checklist
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户清单
- en: The user is why we build software in the first place. This checklist covers
    the most fundamental aspects of why we need to scale our application. These questions
    will be relevant throughout the lifetime of the software. And not just when something
    with the user management perspective is in question. Changes to feature development
    should trigger a look at this list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是我们最初构建软件的原因。这个清单涵盖了我们需要扩展应用程序的最基本方面。这些问题将在软件的整个生命周期中相关。不仅仅是在用户管理方面有问题的时候。特征开发的变化应该触发对这份清单的查看。
- en: What's the business model of our software?
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们软件的商业模式是什么？
- en: Is it *license-based*?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是*基于许可*的吗？
- en: Is it *subscription-based*?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是*基于订阅*的吗？
- en: Is it *consumption-based*?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是*基于消费*的吗？
- en: Is it *advertisement-based*?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是*基于广告*的吗？
- en: Is it *open source*?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是*开源*的吗？
- en: Does our application have different user roles?
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的应用程序有不同的用户角色吗？
- en: Are features hidden from one role while visible to others?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个角色是否有特征对另一个角色隐藏，而对其他角色可见？
- en: Does every feature in our application have to be *role-aware*?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用程序中的每个功能都必须是*角色意识*的吗？
- en: How are roles defined and administered?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色是如何定义和管理的？
- en: How does our business model influence the use of roles in our application?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的商业模式如何影响应用程序中角色的使用？
- en: Do our users communicate with each other using our software?
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的用户是否使用我们的软件相互沟通？
- en: Do users collaborate with each other to use our application effectively?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否相互合作以有效使用我们的应用程序？
- en: Does user communication happen as a side-effect of our data model?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户沟通是否是我们数据模型的副作用？
- en: How do the user roles in our application influence user communication?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用程序中的用户角色如何影响用户沟通？
- en: How do we support our application?
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何支持我们的应用程序？
- en: Is support built into the application, or handled externally?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持是内置在应用程序中，还是外部处理的？
- en: Can users support each other using a central knowledge repository?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能否通过一个中央知识库互相支持？
- en: How do our business model and application user roles influence the type of support
    we need to provide?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们商业模式和应用程序用户角色如何影响我们需要提供的支持类型？
- en: How do we collect feedback from users?
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何从用户那里收集反馈？
- en: Is feedback collection built into the application, or handled externally?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反馈收集是内置在应用程序中，还是外部处理的？
- en: How do we incentivize users to provide feedback?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何激励用户提供反馈？
- en: How does the type of support we provide influence the type of feedback we want
    to collect?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提供的支持类型如何影响我们想要收集的反馈类型？
- en: How do we notify users with relevant information?
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何向用户通知相关信息？
- en: Does our application have a generic, context-independent notification mechanism?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序是否有通用的、与上下文无关的通知机制？
- en: How do we ensure that only relevant notifications take place at any given time?
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何确保在任意给定时间只发生相关的通知？
- en: Can users audit their notifications?
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以审计他们的通知吗？
- en: What type of user metrics should we collect?
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们应该收集哪种类型的用户指标？
- en: Do we use metrics to improve future versions of the product?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否使用指标来改善产品的未来版本？
- en: Can our features use metrics at runtime to improve the user experience?
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的特性是否可以在运行时使用指标来改善用户体验？
- en: How does the business model influence our need to collect metrics?
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业模式如何影响我们收集指标的需求？
- en: Feature checklist
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性清单
- en: Following the scaling influencers that originate from users of our software,
    are the features of our software. This list covers some of the questions we should
    be asking ourselves about any new feature, or implementing changes in an existing
    feature. They'll help us address the common issues related to scalability on a
    per-feature basis.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循来自我们软件用户的规模影响者，我们的软件特性是什么。这个列表涵盖了我们应该问自己关于任何新特性或实现现有特性的变化的问题。它们将帮助我们在每个特性基础上解决与可扩展性相关的常见问题。
- en: What's the core value proposition of our software?
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们软件的核心价值主张是什么？
- en: Does the feature we're implementing or enhancing contribute to the overall value
    proposition of our product?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在实施或增强的特性是否有助于我们产品整体的价值主张？
- en: Is our current value proposition too broadly focused?
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们当前的价值主张是否过于宽泛？
- en: How do the number of users and their roles influence our ability to focus on
    features relevant to our application's value?
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数量和他们的角色如何影响我们专注于与应用程序价值相关的特性的能力？
- en: How do we determine the feasibility of a feature?
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何确定一个特性的可行性？
- en: Are we trying to implement killer features instead of letting them come about
    naturally?
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否试图实现杀手级特性，而不是让它们自然地出现？
- en: Do we take the time to determine whether a proposed feature is feasible to implement,
    rather than implementing it poorly?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否花时间确定一个提议的特性是否可行，而不是做得差劲？
- en: How does the value proposition of our software, and the feature requests from
    our users, influence the feasibility of the features we ultimately implement?
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们软件的价值主张以及用户的特性请求如何影响我们最终实现的特性可行性？
- en: Can we make informed decisions about our features?
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们能否对特性做出明智的决策？
- en: Do we have any user metric data on which we can base our decisions?
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否有任何用户指标数据，我们可以基于此做出决策？
- en: Is there any historical data on similar features we've implemented in the past?
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去我们实施过的类似特性有任何历史数据吗？
- en: How does our business model influence the data we can collect and use for decisions
    about the features of our application?
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的商业模式如何影响我们可以收集和用于应用程序特性决策的数据？
- en: Who's our competition?
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的竞争对手是谁？
- en: Are we offering something similar to a competing product, done better?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否提供了与竞品类似，但做得更好的东西？
- en: Are we in a niché market?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否处于利基市场？
- en: What can we learn from competing products?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从竞品中学习到什么？
- en: How does our business model influence the amount of competition we face and
    the types of features we need to implement?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的商业模式如何影响我们面临的竞争程度以及我们需要实现的特性类型？
- en: How do we make what we have better?
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何让现有的东西变得更好？
- en: Given the rate at which we're adding features, do we have enough time to maintain
    our existing features?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到我们添加特性的速度，我们是否有足够的时间来维护现有的特性？
- en: Is it safe, architecturally, to modify a feature without breaking other features?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从架构上讲，修改一个特性而不破坏其他特性是否安全？
- en: How do our users influence the enhancements we make to existing features?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户如何影响我们对现有特性的改进？
- en: How does our business model influence our ability to deploy product enhancements?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的商业模式如何影响我们部署产品增强的能力？
- en: How do we integrate user management into our features?
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何将用户管理整合到特性中？
- en: Are access control mechanisms generalized to the point that they're not a day-to-day
    concern for feature development?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制机制是否已经通用到不再特性发展为日常担忧的程度？
- en: Can we organize our features into groups?
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否将特性组织成小组？
- en: Can users turn features on or off?
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能否开启或关闭特性？
- en: How does the type of application we're building, in conjunction with our users
    and their roles, influence the complexity of our features?
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在构建的应用程序类型，以及我们的用户和他们的角色，如何影响我们特性的复杂性？
- en: Are our features tightly coupled to backend services?
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的特性是否与后端服务紧密耦合？
- en: Are the existing services generic enough to handle the new feature we're implementing?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的服务是否足够通用，能够处理我们正在实施的新特性？
- en: Are we able to mock back-end services, running entirely in the browser?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能够在浏览器中完全模拟后端服务吗？
- en: How do our features influence the design and capabilities of back-end services?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的特性如何影响后端服务的设计和功能？
- en: How does the frontend stay synchronized with backend data?
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端如何与后端数据保持同步？
- en: Can we utilize web socket connectivity for push notifications?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否利用WebSocket连接来实现推送通知？
- en: Does high user activity cause more messages to be delivered to other users?
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高用户活动是否会导致更多消息被发送给其他用户？
- en: How does consuming real-time data influence the complexity of our features?
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时数据消费如何影响我们特性的复杂性？
- en: Developer checklist
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者清单
- en: The final checklist we'll want to review throughout the course of our software
    is concerned with development resources. This checklist won't be used as frequently
    as the users or the features lists. Nonetheless, it's important to make sure we're
    addressing the concerns that arise in terms of development resources.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们软件开发过程中，我们需要回顾的最终清单是关于开发资源的。这个清单不会像用户或者特性清单那样经常使用。尽管如此，确保我们在开发资源方面解决出现的问题是很重要的。
- en: How do we find the right development resources?
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何找到合适的发展资源？
- en: Can we get by with the development resources we currently have?
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否用目前现有的开发资源应付过去？
- en: Do we need to revisit the features under development to accommodate the resources
    we have?
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要重新审视正在开发的特性，以适应我们所拥有的资源吗？
- en: Do we have the *right* development resources for the product we're building?
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否有为正在构建的产品配备*正确的*开发资源？
- en: How do we allocate development responsibilities?
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何分配开发责任？
- en: How much overlap should there be between areas of responsibility?
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任区域之间应该有多少重叠？
- en: Do our current areas of responsibility reflect what we're building?
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们当前的责任区域是否反映了我们在构建什么？
- en: How do the various skill-sets of our team members influence the responsibilities?
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队成员的各种技能如何影响他们的职责？
- en: Can we avoid hiring too many resources?
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们能否避免雇佣过多的资源？
- en: Are we hiring people too far in advance of actually needing them?
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否过早地雇佣了人员？
- en: Are we experiencing communication overhead due to too many resources?
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于资源过多，我们是否经历了沟通上的开销？
- en: How does the number of features under development in parallel, influence the
    perception that more developers means more will be accomplished?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时开发多个特性是否会影响这样一种观念：更多的开发者意味着能完成更多的工作？
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There are three main areas of concern when it comes to scaling influencers in
    JavaScript applications. Each area influences the area directly beneath it, until
    we ultimately hit the ground floor, where development takes place.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在JavaScript应用程序中扩展影响者时，有三个主要关注领域。每个领域都直接影响其下方的领域，直到我们最终到达底层，即开发发生的地方。
- en: First and foremost are the users of our software. There are a number of user-related
    factors that influence the need for our software to scale. For instance, the business
    model our organization chooses subtly affects later decisions about our architecture.
    License-based deployments are likely to be deployed on-premise somewhere, and
    therefore more likely to require customizations. The combinations of complexities
    are endless, and they all stem from the users of our software.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，也是最重要的是，我们软件的用户。有许多与用户相关的因素会影响我们软件的扩展需求。例如，我们组织选择的企业模型会在不知不觉中影响我们后来关于架构的决策。基于许可证的部署可能会在某处进行本地部署，因此更有可能需要进行定制。复杂性的组合无穷无尽，它们都源于我们软件的用户。
- en: The next major area we looked at were the features themselves. We have to take
    much of the insight gained from thinking about our users and their influence on
    scale, and provide this as input to our feature design. For example, a lot may
    happen in a short period of time, once people start using our software. How will
    this distract us from the core value of our application? Believe it or not, focus
    is something that needs to scale too.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来主要关注的是功能本身。我们必须把我们从思考我们的用户以及他们对扩展性的影响中获得的大部分洞察力，作为输入提供给我们的功能设计。例如，一旦人们开始使用我们的软件，很短的时间内可能会发生很多事情。这会如何分散我们应用程序的核心价值呢？信不信由你，专注也是需要扩展的。
- en: Finally, there are the development activities. There's the team to build, and
    finding the right people isn't easy. Even if we have a team of solid developers
    in place, the responsibilities, and how they are influenced by the features and
    the people using them, needs to be taken into consideration. Likewise, as the
    development of our application progresses, we have to ensure that the right resources
    are in place.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有开发活动。需要建设团队，而且找到合适的人并不容易。即使我们有了一个由优秀开发者组成的团队，也需要考虑到责任以及它们是如何受到功能和使用它们的人的影响。同样地，随着我们应用程序的开发进展，我们还需要确保正确的资源得到配置。
- en: Now that we've laid the foundation of what scaling is all about in the front-end,
    we're ready to dive into the specifics. The remainder of this book will put the
    concepts of the first two chapters into a JavaScript context. We know what scaling
    influencers are, and now we get to make architectural trade-offs. This is the
    fun part, because we get to write code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在前端奠定了扩展性的基础，现在就准备深入具体内容吧。本书的剩余部分将把前两章的概念放入JavaScript的语境中。我们知道什么是影响扩展性的因素，现在我们开始做出架构上的取舍。这是有趣的部分，因为我们可以开始写代码了。
