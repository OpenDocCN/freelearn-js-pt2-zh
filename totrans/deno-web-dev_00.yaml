- en: '*Chapter 3*: The Runtime and Standard Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：运行时和标准库'
- en: Now that we know enough about Deno, we're in a good place to write a few real
    applications with it. In this chapter, we'll be using no libraries as its primary
    purpose is to present the runtime APIs and the standard library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经足够了解Deno，我们可以用它来写一些真正的应用程序。在本章中，我们将不使用任何库，因为其主要目的是介绍运行时API和标准库。
- en: We will be writing small CLI utilities, web servers, and more, always leveraging
    the power of what the official Deno team created, with no external dependencies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写小的CLI工具、Web服务器等，始终利用官方Deno团队创建的力量，没有外部依赖。
- en: The Deno namespace will be our starting point as we believe it makes sense to
    explore what the runtime includes first. Following this idea, we'll also look
    at the Web APIs that Deno shares with the browser. We'll use `setTimeout` to `addEventListener`,
    `fetch`, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点将是Deno命名空间，因为我们认为首先探索运行时包含的内容是有意义的。遵循这个想法，我们还将查看Deno与浏览器共享的Web API。我们将使用`setTimeout`到`addEventListener`、`fetch`等。
- en: Still in the Deno namespace, we will get to know the program lifecycle, interact
    with the filesystem, and build small command-line programs. Later, we will get
    to know buffers and understand how they can be used to asynchronously read and
    write.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在Deno命名空间中，我们将了解程序的生命周期，与文件系统交互，并构建小的命令行程序。后来，我们将了解缓冲区，并了解如何使用它们异步地读写。
- en: We will then take a quick turn into the standard library and we'll go through
    some useful modules. This chapter doesn't aim to replace the standard library's
    documentation; it will instead present you with some of its capabilities and use
    cases. We'll get to know it while we write small programs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将快速转向标准库，并浏览一些有用的模块。本章旨在取代标准库的文档；它将为您提供一些其功能和使用案例的介绍，而我们在编写小程序的过程中将了解它。
- en: On this journey through the standard library, we will use modules that deal
    with the filesystem, ID generation, text formatting, and HTTP communication. Part
    of it will be an introduction to what we'll explore in more depth in later chapters.
    You'll finish this chapter by writing your first JSON API, and connecting to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库的旅程中，我们将使用与文件系统、ID生成、文本格式化和HTTP通信相关的模块。其中一部分将是介绍我们将在后续章节中深入探讨的内容。您将通过编写第一个JSON
    API并连接到它来完成本章。
- en: 'The following are the topics that we will be covering in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中涵盖的主题：
- en: The Deno runtime
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deno运行时
- en: Exploring the Deno namespace
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Deno命名空间
- en: Using the standard library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库
- en: Building a web server using the HTTP module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP模块构建Web服务器
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code files of this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在以下GitHub链接中找到：[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03)。
- en: The Deno runtime
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deno运行时
- en: Deno provides a set of functions that are included in the runtime as globals
    in the `Deno` namespace. The runtime APIs are documented at [https://doc.deno.land/](https://doc.deno.land/)
    and can be used to do the most elementary, low-level things.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Deno提供了一组函数，这些函数作为全局变量包含在`Deno`命名空间中。运行时API在[https://doc.deno.land/](https://doc.deno.land/)上进行文档化，可以用来做最基本、最底层的事情。
- en: 'Two types of functions are available on Deno without any imports: Web APIs
    and the `Deno` namespace. Whenever there''s a behavior in Deno that also exists
    on the browser, Deno mimics the browser APIs – those are Web APIs. Since you come
    from the JavaScript world, you''re probably familiar with most of them. We''re
    speaking about functions such as `fetch`, `addEventListener`, `setTimeout`, and
    objects such as `window`, `Event`, `console`, among others.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Deno上有两种函数无需任何导入即可使用：Web API和`Deno`命名空间。每当Deno中存在与浏览器中相同的行为时，Deno会模仿浏览器API——这些是Web
    API。由于您来自JavaScript世界，您可能熟悉其中的大部分内容。我们谈论的是诸如`fetch`、`addEventListener`、`setTimeout`等函数，以及`window`、`Event`、`console`等对象等。
- en: Code written using Web APIs can be bundled and run in the browser with no transformations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web API编写的代码可以无需转换即可捆绑并在浏览器中运行。
- en: The other big part of the APIs exposed by the runtime lives inside a global
    namespace named `Deno`. You can use the REPL and the documentation, two of the
    things we explored in [*Chapter 2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *The Toolchain*, to explore it and get a quick grasp of what functions it includes.
    Later in this chapter, we'll also experiment with some of the most common ones.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时暴露的API的另一个大部分位于一个名为`Deno`的全局命名空间中。你可以使用REPL和文档，这两样我们在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)《工具链》中探索过，来探索它并快速了解它包括哪些函数。在本章后面，我们还将尝试一些最常用的函数。
- en: If you want to access the documentation of all the symbols that are included
    in Deno, you can run the `doc` command with the `--builtin` flag.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问Deno中包含的所有符号的文档，你可以运行带有`--builtin`标志的`doc`命令。
- en: Stability
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定性
- en: The functions inside the `Deno` namespace are considered stable from version
    1.0.0 onwards. This means the Deno team will make an effort to support them across
    newer versions, and will do its best to keep them compatible with future changes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.0.0开始，Deno命名空间内的函数被认为是稳定的。这意味着Deno团队将努力在更新的版本中支持它们，并尽最大努力使它们与未来的变化保持兼容。
- en: Features that are still not considered stable for production live under the
    `--unstable` flag, as you probably imagined, since we've used them in previous
    examples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然没有被认为是在生产中稳定的特性，正如你想象的那样，因为我们已经在之前的例子中使用过它们，都位于`--unstable`标志下。
- en: The documentation of unstable modules can be accessed by using the `--unstable`
    flag with the `doc` command or by accessing [https://doc.deno.land/builtin/unstable](https://doc.deno.land/builtin/unstable).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定模块的文档可以通过使用`doc`命令的`--unstable`标志访问，或者通过访问[https://doc.deno.land/builtin/unstable](https://doc.deno.land/builtin/unstable)来访问。
- en: The standard library is not yet considered stable by the Deno team and thus
    they have a different version from the CLI (at the time of writing, it is on version
    0.83.0).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库尚未被Deno团队认为是稳定的，因此它们的版本与CLI（在撰写本文时，版本为0.83.0）不同。
- en: In contrast with the `Deno` namespace functions, the standard library doesn't
    normally need the `--unstable` flag to run, except if any module from the standard
    library is using unstable functions from the `Deno` namespace.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Deno`命名空间函数相比，标准库通常不需要`--unstable`标志来运行，除非标准库中的任何模块正在使用来自`Deno`命名空间的不可稳定函数。
- en: Program lifecycle
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序生命周期
- en: Deno supports the browser compatible `load` and `unload` events that can be
    used to run setup and cleanup code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Deno支持与浏览器兼容的`load`和`unload`事件，可以用来运行设置和清理代码。
- en: 'Handlers can be written in two different ways: with `addEventListener` and
    by overriding the `window.onload` and `window.onunload` functions. The `load`
    events can be asynchronous but the same is not true for `unload` events as they
    can''t be canceled.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序可以以两种不同的方式编写：使用`addEventListener`和通过重写`window.onload`和`window.onunload`函数。`load`事件可以是异步的，但`unload`事件不是真的，因为它们不能被取消。
- en: 'Using `addEventListener` enables you to register unlimited handles; for instance:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addEventListener`可以让你注册无限数量的处理程序；例如：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we run the preceding code, we get the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们会得到以下输出：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another way to schedule code to run on setup and teardown phases is by overriding
    the `onload` and `onunload` functions from the `window` object. These functions
    have the particularity that only the last to be assigned runs. This happens because
    they override one another; see the following code, for instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在设置和清理阶段安排代码运行的方法是重写`window`对象上的`onload`和`onunload`函数。这些函数的特点是只有最后分配的一个会运行。这是因为它们会相互覆盖；例如以下代码：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By running the preceding program, we got the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序后，我们得到了以下输出：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we then look at the initial code we wrote, we can understand that the first
    two declarations were overridden by the two declarations following them. That's
    what happens when we override `onunload` and `onload`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后如果我们看看我们最初编写的代码，我们可以理解前两个声明被跟在它们后面的两个声明覆盖了。当我们覆盖`onunload`和`onload`时，就是这样发生的。
- en: Web APIs
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络API
- en: 'To demonstrate that we can use the Web APIs the exact same way we can use on
    the browser, we''ll write a rudimentary program that fetches the Deno website
    logo, converts it to base64, and prints to the console an HTML page with the base64
    of the image there. Let''s do this by following these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们可以像在浏览器上一样使用Web API，我们将编写一个简单的程序，获取Deno网站的标志，将其转换为base64，并在控制台打印一个包含图像base64的HTML页面。让我们按照以下步骤进行：
- en: 'Start with the request to [https://deno.land/logo.svg](https://deno.land/logo.svg):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Convert it into `blob`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Get the text out of the `blob` object and convert it into `base64`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Print to the console an HTML page with an image tag using the base64 image:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run this, we get the expected output:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, with the help of *nix output redirection features, we can create an HTML
    file with the output of our script:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can now inspect the file, or open it directly in the browser to test that
    it works.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use your knowledge from the previous chapter and directly
    run a script from the Deno standard library to serve the current folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And then, by navigating to `http://localhost:4507/deno-logo.html`, we can check
    that the image is there and working:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Accessing a web page with the Deno.land logo as a base64 image'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B16380.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Accessing a web page with the Deno.land logo as a base64 image
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Those are just examples of Web APIs that are supported in Deno. In this specific
    example, we've used `fetch` and `btoa` but more will be used throughout the chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to experiment with these already familiar APIs, either by writing
    simple scripts or by using the REPL. In the rest of the book, we'll be using known
    functions from the Web APIs. In the next section, we'll get to know the Deno namespace,
    the functions that only work inside Deno, and generally provide a more low-level
    behavior.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Deno namespace
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the functionality that is not covered by a Web API lives under the Deno
    namespace. This is functionality that is exclusive to Deno and that can't, for
    instance, be bundled to run in Node or the browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore some of this functionality. We'll be building
    small utilities, mimicking some of the programs you use daily.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: If you want to explore the available functions before we get our hands dirty,
    they are available at [https://doc.deno.land/builtin/stable](https://doc.deno.land/builtin/stable).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple ls command
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you've ever used a *nix system's Terminal or Windows PowerShell, you are
    probably familiar with the `ls` command. Briefly, it lists the files and folders
    inside a directory. What we will do is create a Deno utility that mimics some
    functionality of `ls`, that is, lists the files in a directory, and shows some
    details about them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The original command has a countless number of flags, which we will not implement
    here for brevity reasons.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The information we decided to show is the name, size, and last modified date
    of a file. Let''s get our hands dirty:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `list-file-names.js` and use `Deno.readDir` to get a list
    of all files and folders in the current directory:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will print the files in the current directory on different lines:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use `Deno.args` (https://doc.deno.land/builtin/stable#Deno.args) to get the
    command-line arguments. If no argument is sent, use the current directory as a
    default:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We're leveraging array destructuring to get the first value of `Deno.args` and
    at the same time using default properties to set the default value of the `path`
    variable.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to the `demo-files` folder ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls/demo-files](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls/demo-files))
    and run the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It looks like it is working. It is getting the files from the folder it is currently
    in and listing them.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now need to get the file information so that we can display it.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `Deno.stat` (https://doc.deno.land/builtin/stable#Deno.stat) to get information
    about the files:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: $ deno run --allow-read index.ts ./demo-files
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 12   7/4  .hidden
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 96   7/4  folder
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 96   7/4  second-folder
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5    7/4  my-best-file
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 20   7/4  .file1
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0    7/4  .hidden-file
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And we get our list of files and folders in the `deno-files` directory we sent
    as a parameter, together with the size in bytes and the creation month and day.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Here, we're using the already known and required `--allow-read` flag to give
    Deno permissions to access the filesystem. However, in the previous chapter, we
    mentioned that there was a different way for Deno programs to ask for permissions,
    using what we called "dynamic permissions." That's what we'll learn about next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic permissions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing Deno programs ourselves, it's very common that we know the required
    permissions beforehand. However, when writing or executing code that might or
    might not need some permissions or writing an interactive CLI utility, it might
    not make sense to ask for all permissions at once. That's what dynamic permissions
    are for.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic permissions allow programs to ask for permissions as they are needed,
    allowing whoever is executing the code to give or deny specific permissions interactively.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: This is a feature that is still unstable and thus its APIs can change, but I
    think it's still worth mentioning, because of the amount of potential it enables.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: You can have a look at Deno's permissions API at [https://doc.deno.land/builtin/unstable#Deno.permissions](https://doc.deno.land/builtin/unstable#Deno.permissions).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''ll do next is make sure that our `ls` program asks for filesystem
    read permissions. Let''s do it by following these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `Deno.permissions.request` to ask for read permissions before executing
    the program:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This asks for permissions for the directory where the program is going to run.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the program and grant permissions on the current directory:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the program and deny read permissions on the current directory:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And that's how dynamic permissions work!
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we've used them to control the filesystem read permissions, but they can
    be used to ask for access to all the available permissions (mentioned in [*Chapter
    2*](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056), *The Toolchain*) in the runtime.
    They're very useful when writing CLI applications, allowing you to interactively
    tune which permissions the running program has access to.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用它们来控制文件系统的读取权限，但它们也可以用来请求运行时所有可用的权限（在[第2章](B16380_02_Final_JM_ePub.xhtml#_idTextAnchor056)中提到，*工具链*）。在编写CLI应用程序时，它们非常有用，允许您交互式地调整正在运行的程序可以访问的权限。
- en: Using the filesystem APIs
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件系统API
- en: Accessing the filesystem is one of the basic needs we have when writing programs.
    As you have probably already seen in the documentation, Deno provides APIs to
    do these common tasks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序时，访问文件系统是我们最基本的需求之一。正如您在文档中可能已经看到的那样，Deno提供了执行这些常见任务的API。
- en: With a decision to standardize communication with the Rust core, all of these
    APIs return `Uint8Array` and the decoding and encoding should be made by their
    consumers. This is a substantial difference from Node.js, where some functions
    return converted formats, where others return blobs, buffers, and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 决定与Rust核心标准化通信后，所有这些API都返回`Uint8Array`，其解码和编码应由其消费者完成。这与Node.js有所不同，在Node.js中，一些函数返回转换格式，而其他函数返回blob、缓冲区等。
- en: Let's explore these filesystem APIs and read the contents of a file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些文件系统API并阅读一个文件的内容。
- en: 'We''re going to read the example file available at [https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/file-system/sentence.txt](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/file-system/sentence.txt),
    using the `TextDecoder` and `Deno.readFile` APIs, as the following script demonstrates:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要读取位于[https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/file-system/sentence.txt](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/file-system/sentence.txt)的示例文件，使用`TextDecoder`和`Deno.readFile`
    API，如下脚本所示：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can note that we've used the `TextDecoder` class, another API that is present
    in the browser.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们使用了`TextDecoder`类，这是另一个在浏览器中存在的API。
- en: Do not forget to use the `--allow-read` permission when running the script so
    it can read from the filesystem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本时，请不要忘记使用`--allow-read`权限，以便它可以从文件系统中读取。
- en: 'If we want to write the content of this file to another file, we can use `writeFile`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将这个文件的内容写入另一个文件，我们可以使用`writeFile`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we don't need the `TextEncoder` anymore since we're using `Uint8Array`
    we got from `readFile` to send directly to the `writeFile` method. Remember to
    use the `--allow-write` flag when running it, since it's now writing to the filesystem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们正在使用从`readFile`得到的`Uint8Array`直接发送到`writeFile`方法，所以我们不再需要`TextEncoder`。记得在运行时使用`--allow-write`标志，因为它现在正在向文件系统写入。
- en: 'As you probably guessed or read in the documentation, Deno provides an API
    exactly for that, `copyFile`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能猜到的或阅读文档的那样，Deno正好提供了这样的API，`copyFile`：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, you probably noticed we're always using `await` before the method calls
    on Deno namespace functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能注意到我们总是在Deno命名空间函数的调用前使用`await`。
- en: All asynchronous operations on Deno return a promise, and that's the main reason
    we're doing this. We could use the equivalent `then` syntax and deal with the
    result there, but we find this to be more readable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Deno上的异步操作都返回一个承诺，这是我们这样做的主要原因。我们本可以在那里使用等效的`then`语法处理结果，但我们认为这样更易读。
- en: Other APIs for removing, renaming, changing permissions, and so on are also
    included in the Deno namespace, as you can find in the documentation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文档中找到Deno命名空间中还包括的其他API，用于删除、重命名、更改权限等。
- en: Important note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Many of the asynchronous APIs in Deno have an equivalent *synchronous* API that
    can be used for specific use cases where you want to block the process and get
    a result (for example, `readFileSync`, `writeFileSync`, and so on).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Deno中的许多异步API都有相应的*同步*API，可以用于特定用例，在这些用例中，您希望阻塞进程并获取结果（例如，`readFileSync`、`writeFileSync`等）。
- en: Using buffers
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓冲区
- en: Buffers represent regions in memory that are used to store temporary binary
    data. They are commonly used to deal with I/O and network operations. As asynchronous
    operations are something where Deno excels, we'll be exploring buffers in this
    section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区代表用于存储临时二进制数据的内存区域。它们通常用于处理I/O和网络操作。由于异步操作是Deno的优势之一，所以我们将在本节中探索缓冲区。
- en: Deno buffers differ from Node buffers. This happens because when Node was created,
    and up until version 4, there was no support in JavaScript for `ArrayBuffers`.
    As Node optimized for asynchronous operations (where buffers really shine), the
    team behind it had to create a Node buffer to emulate the behavior of a native
    buffer. Later, `ArrayBuffers` were added into the language and the Node team migrated
    the existing buffer to leverage it. It currently isn't more than a subclass of
    `ArrayBuffers`. This same buffer was then deprecated in v10 of Node. As Deno was
    recently created, its buffer deeply leverages `ArrayBuffer`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Deno缓冲区与Node缓冲区不同。这是因为当Node被创建时，直到版本4，JavaScript中都没有对`ArrayBuffers`的支持。由于Node针对异步操作进行了优化（缓冲区真正闪耀的地方），其背后的团队不得不创建一个Node缓冲区来模拟本地缓冲区的行为。后来，`ArrayBuffers`被添加到语言中，Node团队将现有的缓冲区迁移到利用它。目前它只是一个`ArrayBuffers`的子类。这个相同的缓冲区在Node
    v10中被弃用。由于Deno是最近创建的，它的缓冲区深度利用了`ArrayBuffer`。
- en: Reading and writing from Deno.Buffer
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Deno.Buffer读写
- en: Deno provides a dynamic length buffer that is implemented on top of `ArrayBuffer`,
    a fixed memory allocation. Buffers provide functionality similar to a queue where
    data can be written and read by different consumers. As we initially mentioned,
    they are heavily used for jobs such as networking and I/O as they allow asynchronous
    reading and writing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Deno提供了一个动态长度的缓冲区，它是基于`ArrayBuffer`的固定内存分配实现的。缓冲区提供了类似于队列的功能，其中数据可以被不同的消费者写入和读取。正如我们最初提到的，它们在网络和I/O等任务中得到了广泛应用，因为它们允许异步读写。
- en: To give an example, imagine you have an application that is writing some logs
    that you want to process. You can do it synchronously as they come, or you can
    have that application writing to a buffer and have a consumer processing them
    asynchronously.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你有一个正在写一些日志的应用程序，你想处理这些日志。你可以同步地处理它们，也可以让这个应用程序将日志写入缓冲区，然后有一个消费者异步地处理它们。
- en: Let's write a small program for that situation. We will write two short programs.
    The first one will emulate an application producing logs; the second will consume
    those logs by using a buffer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为那种情况写一个小的程序。我们将写两个简短程序。第一个程序将模拟一个产生日志的应用程序；第二个程序将通过使用缓冲区来消费这些日志。
- en: 'We''ll start by writing code that emulates an application producing logs. At
    [https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/buffers/logs/example-log.txt](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/buffers/logs/example-log.txt),
    there''s a file that has some example logs we''ll use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写模拟一个产生日志的应用程序的代码。在[https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/buffers/logs/example-log.txt](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/buffers/logs/example-log.txt)，有一个文件，里面有一些示例日志我们将使用：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code reads the content from the example file and splits it into lines.
    Then, it gets a random line number and every 100 ms writes that line into a buffer.
    This file then exports a function that we can call to start "generating random
    logs." We'll use this in the next script to mimic an application producing logs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从示例文件中读取内容并将其分割成行。然后，它获取一个随机的行号，每100毫秒将那一行写入缓冲区。这个文件然后导出一个函数，我们可以调用它来“生成随机日志”。我们将在下一个脚本中使用这个来模仿一个产生日志的应用程序。
- en: 'Now comes the interesting part: we''ll write our basic *log processor* by following
    these steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来到了有趣的部分：我们将按照这些步骤编写基本的*日志处理器*：
- en: 'Create a buffer and send it to the `start` function of the log producer we
    just wrote:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个缓冲区并将其发送给我们刚刚编写的日志生产者的`start`函数：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the `processLogs` function to start processing the log entries present
    in the buffers:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`processLogs`函数来开始处理缓冲区中存在的日志条目：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the `processLogs` function would be called and nothing would
    happen, as we haven't implemented a program to do it yet.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所看到的，`processLogs`函数会被调用，但是什么也不会发生，因为我们还没有实现一个程序来执行它。
- en: 'Create an object type of `Uint8Array` inside the `processLogs` function and
    read the content of the buffer there:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`processLogs`函数内部创建一个`Uint8Array`对象类型，并读取那里的缓冲区内容：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The documentation ([https://doc.deno.land/builtin/stable#Deno.Buffer](https://doc.deno.land/builtin/stable#Deno.Buffer))
    states that when there is something to read, the `read` function from `Deno.Buffer`
    returns the number of bytes read. When there is nothing to read, the buffer is
    empty and it returns null.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文档（[https://doc.deno.land/builtin/stable#Deno.Buffer](https://doc.deno.land/builtin/stable#Deno.Buffer)）指出，当有东西要读取时，`Deno.Buffer`的`read`函数返回读取的字节数。当没有东西可读时，缓冲区为空，它返回null。
- en: 'Now, inside `if`, we can just decode the content that was read, as we know
    it comes in `Uint8Array` format:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`if`内部，我们可以简单地解码已经读取的内容，因为我们知道它以`Uint8Array`格式存在：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To print the decoded value on the console, we can use the already known `console.log`.
    We can also do it differently, by using `Deno.stdout` ([https://doc.deno.land/builtin/stable#Deno.stdout](https://doc.deno.land/builtin/stable#Deno.stdout))
    to write to the standard output.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将在控制台中解码的值打印出来，我们可以使用已知的`console.log`。我们也可以用不同的方式来做，通过使用`Deno.stdout`([https://doc.deno.land/builtin/stable#Deno.stdout](https://doc.deno.land/builtin/stable#Deno.stdout))来写入标准输出。
- en: '`Deno.stdout` is a `writer` object in Deno ([https://doc.deno.land/builtin/stable#Deno.Writer](https://doc.deno.land/builtin/stable#Deno.Writer)).
    We can use its `write` method to send text there:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Deno.stdout` 是 Deno 中的一个`writer`对象([https://doc.deno.land/builtin/stable#Deno.Writer](https://doc.deno.land/builtin/stable#Deno.Writer))。我们可以使用它的`write`方法将文本发送到那里：'
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And with this, we're writing to `Deno.stdout`, the value we just read. We're
    also adding a line break at the end (`\n`) so that it becomes a little more readable
    on the console.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们就在`Deno.stdout`中写入刚刚读取的值。我们还添加了一个换行符（`\n`）在末尾，使其在控制台上的可读性稍好。
- en: If we leave it this way, this `processLogs` function will run only once. As
    we want this to run again and check if there are more logs in `buffer`, we'll
    need to schedule it to run again later.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们保持这种方式，这个`processLogs`函数将只运行一次。因为我们希望这个函数再次运行并检查`buffer`中是否还有更多日志，我们需要将其安排在稍后再次运行。
- en: 'Use `setTimeout` to call the same `processLogs` function 100 ms from now:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setTimeout`在100毫秒后调用相同的`processLogs`函数：
- en: '[PRE29]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As an example, if we open the `example-log.txt` file, we can see that there
    are lines that contain dates in the following format: `Thu Aug 20 22:14:31 WEST
    2020`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们打开`example-log.txt`文件，我们可以看到包含以下格式的日期行：`Thu Aug 20 22:14:31 WEST 2020`。
- en: 'Let''s imagine we just want to print logs that have `Tue` on them. Let''s write
    the logic to do that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想打印出包含`Tue`的日志。让我们编写实现该功能的逻辑：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we execute the program while inside the folder containing the `example-logs.txt`
    file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在包含`example-logs.txt`文件的文件夹内执行程序：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The log lines with the dates appear as they are read from the buffer and match
    our criteria.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 带有日期的日志行如实地从缓冲区读取并符合我们的条件出现。
- en: This was a short demonstration of what can be done with buffers. We were able
    to asynchronously write and read from a buffer. This approach allows, for instance,
    a consumer to be working on a portion of a file while the application is reading
    other parts of it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用缓冲区可以做到的简要演示。我们能够异步地从缓冲区写入和读取。这种方法允许，例如，消费者在应用程序读取其他部分的同时处理文件的一部分。
- en: The Deno namespace provides a lot more functionality than what we've tried here.
    In this section, we decided to pick a few parts and give you a glimpse of how
    much it enables.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deno`命名空间提供了比我们在这里尝试的更多功能。在本节中，我们决定选择几个部分并给您展示它启用多少功能。'
- en: We'll be using these functions, together with third-party modules and the standard
    library, when we write our web server, from [*Chapter 4*](B16380_04_Final_JM_ePub.xhtml#_idTextAnchor108),
    *Building a Web Application,* onwards.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些函数，以及第三方模块和标准库，当我们从[第*4*章](B16380_04_Final_JM_ePub.xhtml#_idTextAnchor108)，*构建网络应用程序*开始编写我们的网络服务器。
- en: Using the standard library
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准库
- en: In this section, we'll explore the behavior provided by Deno's standard library.
    It is currently not considered stable by the runtime and thus modules are separately
    versioned. At the time we're writing, the standard library is at *version 0.83.0*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨由 Deno 的标准库提供的行为。目前， runtime 认为它还不稳定，因此模块是单独版本化的。在我们撰写本文时，标准库处于 *version
    0.83.0* 版本。
- en: As we previously mentioned, Deno is very meticulous in what it adds to the standard
    library. The core team wants it to provide enough behavior, so people don't need
    to rely on millions of external packages to do certain things, but at the same
    time doesn't want to add too much of an API surface. This is a fine balance that
    is hard to strike.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Deno 在添加到标准库的内容上非常细致。核心团队希望它提供足够的行为，这样人们就不需要依赖数百万个外部包来完成某些事情，但同时也不想增加太多的
    API 表面。这是一个难以达到的微妙平衡。
- en: With the assumed inspiration of golang, most of the Deno standard library functions
    mimic the language created by Google. This happens because the Deno team truly
    believes in the way *golang* evolved its standard library, one that is commonly
    known for being well polished. As a funny note, Ryan Dahl (Deno and Node creator)
    mentions in one of his talks that, when pull requests add new APIs to the standard
    library, the equivalent *golang* implementation is asked for.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 受到golang的启发，Deno标准库的大部分函数模仿了谷歌创建的语言。这是因为Deno团队真正相信*golang*如何发展其标准库，这个标准库以其精心打磨而广为人知。作为一个有趣的注记，Ryan
    Dahl（Deno和Node的创建者）在他的某次演讲中提到，当拉取请求向标准库添加新的API时，会要求提供相应的*golang*实现。
- en: We'll not go over the whole library for the same reasons we didn't go over the
    whole Deno namespace. What we'll do is build a couple of useful programs with
    it while we learn what it enables. We'll go from stuff such as generating IDs,
    to logging, to HTTP communication, among other known use cases.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会逐一介绍整个库，原因与我们没有逐一介绍Deno命名空间相同。我们将做的是在学习它所提供的内容的同时，用它来构建几个有用的程序。我们将从生成ID等操作，到日志记录，到HTTP通信等已知用例进行介绍。
- en: Adding colors to our simple ls
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的简单`ls`添加颜色
- en: A few pages ago, we built a very rough and simple "clone" of the `ls` command
    in *nix systems. At the time we listed the files, together with their size and
    modification date.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 几页之前，我们在*nix系统中建立了一个非常粗糙和简单的`ls`命令的“克隆”。当时我们列出了文件，以及它们的大小和修改日期。
- en: To start exploring the standard library, we're going to add some coloring to
    the terminal output of that program. Let's make folder names be printed in red
    so we can easily differentiate them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始探索标准库，我们将向该程序的终端输出添加一些颜色。让我们把文件夹名称打印成红色，以便我们可以轻松地区分它们。
- en: We'll create a file called `list-file-names-color.ts`. This time we will be
    using TypeScript as we'll get much better completion because the standard library
    and the Deno namespace functions were written with that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`list-file-names-color.ts`的文件。这次我们将使用TypeScript，因为我们将得到更好的补全功能，因为标准库和Deno命名空间函数都是为此编写的。
- en: Let's explore the standard library functions that allow us to colorize our text
    (https://deno.land/std@0.83.0/fmt/colors.ts).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索允许我们为文本着色的标准库函数（https://deno.land/std@0.83.0/fmt/colors.ts）。
- en: If we want to look at a module's documentation, we can go directly to code,
    but we can also use the `doc` command or the documentation website. We'll use
    the latter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要查看一个模块的文档，我们可以直接查看代码，但我们也可以使用`doc`命令或文档网站。我们将使用后者。
- en: 'Navigate to https://doc.deno.land/https/deno.land/std@0.83.0/fmt/colors.ts.
    All the listed available methods are presented on the screen:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到https://doc.deno.land/https/deno.land/std@0.83.0/fmt/colors.ts。屏幕上列出了所有可用的方法：
- en: 'Import the method from the standard library''s formatting library that prints
    the text in red:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从标准库的格式化库中导入打印红色文本的方法：
- en: '[PRE32]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use it inside our `async` iterator that is going through our files in the current
    directory:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`async`迭代器遍历当前目录中的文件时使用它：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'By running it inside the `demo-files` folder ([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls)),
    we get the folders printed in red (it is not possible to see this in the printed
    book, but you can run it locally):'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`demo-files`文件夹内运行它([https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls](https://github.com/PacktPublishing/Deno-Web-Development/tree/master/Chapter03/ls)),我们得到用红色打印的文件夹（这在打印书中无法显示，但您可以本地运行它）：
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We now have a better `ls` command that enables us to distinguish folders from
    files, using the coloring functions from the standard library. There are many
    other modules provided by the standard library that we'll have a look at during
    the course of the book. Some of them will be used when we start writing our own
    application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个更好的`ls`命令，它让我们能够区分文件夹和文件，这是通过使用标准库中的颜色函数实现的。标准库还提供了许多其他模块，我们将在书的进程中逐一了解它们。其中一些将在我们开始编写自己的应用程序时使用。
- en: One module that we'll pay special attention to is the HTTP module, which we'll
    heavily use from the next section onwards.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别关注的一个模块是HTTP模块，从下一节开始我们将大量使用它。
- en: Building a web server using the HTTP module
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP模块构建Web服务器
- en: The main focus of this book, together with presenting Deno and how it can be
    used, is to learn how to use it to build web applications. Here, we'll create
    a simple JSON API to introduce you to the HTTP module.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We'll build an API that will save and list notes. We will call these notes post-its.
    Imagine that this is the API that will feed your post-its board.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a very simple routing system with the help of Web APIs and the
    functions from the Deno standard library's HTTP module. Keep in mind we're doing
    this to explore the APIs themselves and thus this is not production-ready code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a folder named `post-it-api` and a file named `index.ts`
    inside. One more time, we will use TypeScript as we believe the autocomplete and
    type checking capabilities greatly improve our experience and reduce the number
    of possible errors.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code for this section is available at [https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/steps/7.ts](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/steps/7.ts):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the standard library HTTP module into our file:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Write the logic to handle requests by using `AsyncIterator`, as we did in previous
    examples:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we now run it, this is what we get. Keep in mind we need to use the `--allow-net`
    flag, mentioned in the Permissions section, for it to have network access:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For clarity, we can extract the port and the server instance to a separate
    variable:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And we have our server working, as it was before, with the small difference
    that now the code looks (arguably) more readable with the configuration variables
    at the top of the file. We'll later learn how can we extract those from the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Returning a list of post-its
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first requisite is that we have an API that returns a list of post-its.
    Those will be composed of the name, title, and the date created. Before we get
    there, and to enable us to have multiple routes, we need a routing system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this exercise, we'll build ours. This is our way of getting
    to know some of the APIs built into Deno. We'll later agree that when writing
    production applications, it is sometimes better to reuse tested and heavily used
    pieces of software than to keep reinventing the wheel. However, it is completely
    fine to *reinvent the wheel* for learning purposes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: To create our basic routing system, we will use some APIs that you probably
    know from the browser. Objects such as `URL`, `UrlSearchParams`, and so on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to be able to define a route by its URL and path. Something like
    `GET /api/post-its` would be nice. Let's do it!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `URL` object ([https://developer.mozilla.org/en-US/docs/Web/API/URL](https://developer.mozilla.org/en-US/docs/Web/API/URL))
    to help us parse the URL and its parameters. We''ll extract `HOST` and `PROTOCOL`
    to a different variable, so we don''t have to repeat ourselves:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the created `URL` object to do some routing. We''ll use a `switch case`
    for that. When no route matches, a `404` should be sent to the client:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的`URL`对象进行一些路由。我们将使用`switch case`来实现。当没有匹配的路由时，应向客户端发送`404`：
- en: '[PRE40]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can use the `--unstable` and `--watch` flags together when running your
    script to restart it on file changes as follows: `deno run` `--allow-net` `--watch`
    `--unstable` `index.ts`.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以运行脚本时同时使用`--unstable`和`--watch`标志来重新启动文件更改后的脚本，如下所示：`deno run --allow-net
    --watch --unstable index.ts`。
- en: Access `http://localhost:8080/api/post-its` and confirm we have the correct
    response. Any other routes will get a 404 response.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/api/post-its`并确认我们得到了正确的响应。其他任何路由都会得到404响应。
- en: Note that we're using the `continue` keyword to make Deno jump out of the current
    iteration after responding to the request (remember we're inside a `for` loop).
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们使用`continue`关键字让Deno在响应请求后跳出当前迭代（记住我们正在一个`for`循环内）。
- en: You might have noticed that, at the moment, we're just routing by path and not
    by method. This means any request made to `/api/post-its`, either `POST` or `GET`,
    will get the same response. Let's fix that by moving ahead.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到，目前我们只是按路径路由，而不是按方法。这意味着对`/api/post-its`的任何请求，无论是`POST`还是`GET`，都会得到相同的响应。让我们通过继续前进来解决这个问题。
- en: 'Create a variable that contains the request method and the pathname:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含请求方法和路径名的变量：
- en: '[PRE41]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now define our routes the way we desire, `GET /api/post-its`. Now that
    we have the basics of our routing system, we'll write the logic to return our
    post-its.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以按照自己的意愿定义路由，比如`GET /api/post-its`。现在我们已经有了路由系统的基本知识，我们将编写返回便签的逻辑。
- en: 'Create the TypeScript interface that will help us maintain the structure of
    the post-its:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建TypeScript接口，以帮助我们保持便签的结构：
- en: '[PRE42]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Create a variable that will work as our *in-memory database* for this exercise.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将作为我们这次练习的*内存数据库*的变量。
- en: 'We''ll use a JavaScript object where the keys are the IDs and values are the
    objects of the `PostIt` type we just defined:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用一个JavaScript对象，其中键是ID，值是刚刚定义的`PostIt`类型的对象：
- en: '[PRE43]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add a couple of fixtures to our database:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的数据库添加几个测试数据：
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we're *generating* the *IDs* by hand for now. Later, we'll use another
    module from the standard library to do it. Let's get back to our API and change
    the `case` that handles our route.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们目前是*手动生成* *IDs*。稍后，我们将使用标准库中的另一个模块来完成。让我们回到我们的API，并更改处理路由的`case`。
- en: Change the `case` that will return all the post-its instead of the hardcoded
    message.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`case`，以便返回所有便签而不是硬编码的消息。
- en: 'As our database is a key/value store, we need to use `reduce` to build an array
    with all our post-its (delete the line highlighted in the code block):'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的数据库是一个键/值存储，我们需要使用`reduce`来构建包含所有便签的数组（删除下面代码块中突出显示的行）：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the code and go to `/api/post-its`. We should have our post-its listed there!
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并访问`/api/post-its`。我们应该会在那里看到我们的便签列表！
- en: You might have noticed that it is still not 100 percent correct, since our API
    is returning JSON, and its headers do not match the payload.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这仍然不是100%正确的，因为我们的API返回的是JSON，而且其头部与载荷不匹配。
- en: 'We''ll add the `content-type` by using an API we know from the browser, the
    `Headers` object ([https://developer.mozilla.org/en-US/docs/Web/API/Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers)).
    Delete the line highlighted in the following code block:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过使用来自浏览器的我们知道的API，即`Headers`对象，来添加`content-type`（[https://developer.mozilla.org/en-US/docs/Web/API/Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers)）。删除下面代码块中突出显示的行：
- en: '[PRE46]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've created an instance of the `Headers` object up there, and then we used
    it on the response, on `req.respond`. This way, our API is now more coherent,
    digestible, and following standards.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面创建了`Headers`对象的实例，然后我们在响应中使用它，在`req.respond`上。这样，我们的API现在更加一致、易消化，并遵循标准。
- en: Adding a post-it to the database
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向数据库添加便签
- en: Now that we have a way to read our post-its, we will need a way to add new ones
    as it doesn't make much sense to have an API with completely static content. That's
    what we'll do.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了读取便签的方法，我们还需要一种添加新便签的方法，因为如果API完全是静态内容，那就没有意义了。那就是我们接下来要做的。
- en: 'We''ll use the *routing infrastructure* we created to add a route that allows
    us to *insert* records into our database. Since we''re following REST guidelines,
    that route will live on the same path as the one that lists `post-its`, but with
    a different method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a route that always returns the `201` status code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Testing it, with the help of `curl`, we can see it''s returning the correct
    status code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Following the recommendation, read the value and print it to get a better understanding
    of it:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Make a request with `body`, with the help of `curl`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Uint8Array(25) [
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 123,  34, 116, 105, 116, 108, 101,
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 34,58,32,34,84,   101, 115,
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 116,  32, 112, 111, 115, 116,  45,
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 105, 116,  34, 125
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use `TextDecoder` to get the request body as a readable value. After doing
    this, we''ll log the output again and we''ll make a new request:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is what the server printed to the console this time:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We're getting there!
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since the body is a string, we need to parse it into a JavaScript object. We''ll
    use an old friend of ours, `JSON.parse`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We now have the request body in a format we can act on, and that''s pretty
    much all it takes for us to create a new database record. Let''s create one by
    following these steps:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `uuid` module ([https://deno.land/std@0.83.0/uuid](mailto:https://deno.land/std@0.67.0/uuid))
    from the standard library to generate a random UUID for our records:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In our route''s switch case, we''ll create an `id` with the help of the `generate`
    method and insert it in the *database*, adding the `createdAt` date on top of
    what the user sent in the request payload. For the sake of this example, we''re
    skipping validation:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that we''re using the same `headers` object we previously defined (in
    the `GET` route) so that our API responds with `Content-Type: application/json`.'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then again, as we follow the *REST* guidelines, we return the `201` `Created`
    code and the created record.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save the code, restart the server, and run it again:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: $ curl http://localhost:8080/api/post-its
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{"postIts":[{"title":"Read more","body":"PacktPub books","id":"3209ebc7-b3b4-4555-88b1-b64b33d507ab","createdAt":"2021-01-10T16:28:52.210Z"},{"title":"Finish
    book","body":"Deno Web Development","id":"a1afee4a-b078-4eff-8ca6-06b3722eee2c","createdAt":"2021-01-10T16:28:52.210Z"},{"title":"Buy
    groceries","body":"1 x Milk","id":"b35b0a62-4519-4491-9ba9-b5809b4810d5","createdAt":"2021-01-10T16:29:05.519Z"}]}'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: And it works! We now have an API that returns and adds post-its to a list.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: This pretty much wraps up what we'll do in terms of APIs with the HTTP module
    for this chapter. As most of the APIs, like the one we wrote, are made to be consumed
    by a frontend application, we'll do that to wrap up this chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Serving a frontend
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since it is out of the scope of this book, we will not write the frontend code
    that interacts with this API. However, if you want to use it with a single-page
    application that fetches the post-its and displays them, I've included one in
    the book's files ([https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/index.html](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/index.html)).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这超出了本书的范围，我们不会编写与这个API交互的前端代码。然而，如果你想用它来获取post-its并显示在一个单页应用程序上，我在书中的文件中包含了一个（[https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/index.html](https://github.com/PacktPublishing/Deno-Web-Development/blob/master/Chapter03/post-it-api/index.html)）。
- en: 'What we''ll learn here is how can we use the web server we just built to serve
    an HTML file:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用我们刚刚建立的网络服务器来提供一份HTML文件：
- en: First, we need to create a route at the root of our server. Then, we need to
    set the correct `Content-Type` and return the file's content by using the already
    known filesystem APIs.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在服务器的根目录下创建一个路由。然后，我们需要设置正确的`Content-Type`，并使用已知的文件系统API返回文件内容。
- en: 'In order to get the path to the HTML file in reference to the current file,
    we''ll use the URL object together with the `import.meta` declaration from JavaScript
    ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta)),
    which contains the path to the current file:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了获取当前文件中HTML文件的路径，我们将使用URL对象与JavaScript中的`import.meta`声明一起使用（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta)），其中包含当前文件的路径：
- en: '[PRE59]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order for us to be a little more secure, we will specify the exact folder
    the program can read, by sending it to the `--allow-read` flag:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们更安全，我们将指定程序可以读取的确切文件夹，通过将其发送到`--allow-read`标志：
- en: '[PRE60]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This will prevent us from any bugs that might allow malicious people to read
    from our filesystem.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将防止任何可能允许恶意人士读取我们文件系统的错误。
- en: 'Access the URL with the browser, and you should get to a page where we can
    see the fixture `post-its` we''ve added. To add a new one, you can also click
    the **Add a new post-it** text and fill in the form:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，输入网址，你应该会来到一个页面，我们可以看到添加的`post-its`日程安排。要添加一个新的，你也可以点击**添加新日程**文本并填写表单：
- en: '![Figure 3.2 – The frontend consuming the post-it API'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 前端消费post-it API](img/Figure_3.2_B16380.jpg)'
- en: '](img/Figure_3.2_B16380.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B16380.jpg)'
- en: Figure 3.2 – The frontend consuming the post-it API
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 前端消费post-it API
- en: Important note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Please keep in mind that, in many production environments, it is not a recommended
    practice to have your API serving your frontend code. Here, we did it for learning
    purposes, so we could understand some of the possibilities of the standard library
    HTTP module.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在许多生产环境中，不建议API提供前端代码。在这里，我们这样做是为了学习目的，以便我们能够理解标准库HTTP模块的一些可能性。
- en: In this section, we learned how can we use the modules provided by the standard
    library to our benefit. We made a simple version of a very common command, `ls`,
    and used the output formatting functions from the standard library to add some
    color to it. To finish the section, we made an HTTP API with a couple of endpoints
    that listed and persisted records. We went through different requirements and
    learned how Deno can be used to accomplish them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用标准库提供的模块造福。我们创建了`ls`命令的简单版本，并使用标准库的输出格式化功能为其添加了一些颜色。为了结束这一节，我们创建了一个具有几个端点的HTTP
    API，用于列出和持久化记录。我们经历了不同的需求，并学习了Deno如何完成它们。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we go through the book, our knowledge of Deno gets more practical and we
    start to use it for use cases that are closer to the real world. That was what
    this chapter was about.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对这本书的阅读，我们对Deno的了解变得更加实用，我们开始用它来处理更接近现实世界的用例。这一章就是关于这个。
- en: We started the chapter by learning about some fundamental characteristics of
    the runtime, namely the program lifecycle, and how Deno sees module stability
    and versioning. We rapidly moved on to the Web APIs provided by Deno by writing
    a simple program that fetches the Deno logo from the website, converts it to base64,
    and puts it into an HTML page.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了运行时的基本特性，即程序生命周期，以及Deno如何看待模块稳定性和版本控制。我们迅速转向了Deno提供的Web API，通过编写一个简单的程序，从网站上获取Deno标志，将其转换为base64，并将其放入HTML页面。
- en: Then, we got into the `Deno` namespace and explored some of its low-level functionality.
    We built a couple of examples with the filesystem API and ended up building a
    rudimentary copy of the `ls` command with it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入了`Deno`命名空间，探索了一些其底层功能。我们使用文件系统API构建了一些示例，并最终用它构建了一个`ls`命令的简化版。
- en: Buffers are things that are heavily used in the Node world, with their capabilities
    to perform asynchronous read and write behavior. As we know, Deno shares many
    use cases with Node.js, and that made it impossible to not talk about buffers
    in this chapter. We started by explaining how Deno buffers differ from Node.js'
    and ended the section by building a small application that handles reading and
    writing asynchronously from them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是在Node.js世界中广泛使用的东西，它们有能力执行异步读写行为。正如我们所知，Deno与Node.js有很多相似的使用场景，这使得在这一章中不可避免地要讨论缓冲区。我们首先解释了Deno缓冲区与Node.js的区别，然后通过构建一个小型应用程序来结束这一节，该程序可以异步地从它们中读写。
- en: To wrap up the chapter, we got closer to one of the main goals of this book,
    using Deno for web development. We created our first JSON API with Deno. In the
    process, we learned about multiple Deno APIs and we even built our basic routing
    system. We then proceeded by creating a couple of routes that listed and created
    records in our *data storage*. Getting closer to the end of this chapter, we learned
    how we can handle headers in our APIs and added those to our endpoints.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我们更接近了这本书的主要目标之一，即使用Deno进行Web开发。我们使用Deno创建了第一个JSON API。在这个过程中，我们了解到了多个Deno
    API，甚至建立了我们基本的路由系统。然后，我们继续创建几个路由，列出并在我们的*数据存储*中创建记录。在章节的最后，我们学习了如何处理API中的头部，并将它们添加到我们的端点。
- en: We finished the chapter by serving a single-page application directly from our
    web server; that same single-page application that consumed and interacted with
    our API.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过直接从我们的Web服务器提供单页应用程序来结束这一章；那个相同的单页应用程序消费并与我们的API进行了交互。
- en: This was a chapter where lots of ground was covered. We started building APIs
    that are now much closer to reality than what we previously did. We also got more
    of a grasp on what it is to develop with Deno, using permissions, and the documentation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章我们覆盖了很多内容。我们开始构建API，这些API现在离现实更近了，比我们之前做的要接近多了。我们还更清楚地了解了如何使用Deno进行开发，包括使用权限和文档。
- en: The current chapter wraps up our introductory journey and has hopefully left
    you curious about what is coming next.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当前章节结束了我们的入门之旅，希望它让你对接下来的内容感到好奇。
- en: In the next four chapters, we'll be building a web application and will explore
    all the decisions made in the process. Most of the knowledge you have learned
    so far will be used later, but there is also a ton of new, exciting stuff coming
    up. In the next chapter, we'll start creating an API that we'll be adding features
    to as the chapters progress.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的四章中，我们将构建一个Web应用程序，并探索在过程中所做的所有决策。你到目前为止学到的大部分知识将会在后面用到，但还有大量新的、令人兴奋的内容即将出现。在下一章，我们将开始创建一个API，随着章节的进行，我们将继续添加功能。
- en: I hope to have you on board!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能加入我们！
