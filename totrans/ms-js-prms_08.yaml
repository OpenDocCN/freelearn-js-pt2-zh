- en: Chapter 8. Promises in jQuery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。jQuery 中的承诺（Promises）
- en: In the last chapter, we learned how promises were implemented in Angular.js
    and how they provided benefit in the fast growing real-time web app industry.
    In this chapter, we will explore another very famous and useful JavaScript library
    for frontend web/mobile apps development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了承诺（promises）是如何在 Angular.js 中实现的，以及它们如何在快速发展的实时 Web 应用行业中提供好处的。在本章中，我们将探讨另一个非常著名且实用的
    JavaScript 库，用于前端 Web/移动应用开发。
- en: jQuery is one the most used JavaScript libraries and it is recognized as one
    of the most maintainable, progressive, and easy to adopt libraries around. jQuery
    has also a credit to shrink the mile-long lines of code into plainer and simpler
    short code. This utility helped jQuery gain popularity beyond imagination. In
    this chapter, we will be looking at the history of jQuery, how it evolved, what
    is the basic way to use it, and how promises are playing a part in the maturity
    of jQuery. Let's start with the history of jQuery in brief.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 是众多常用的 JavaScript 库之一，它被认为是维护性最强、最先进且易于采用的库之一。jQuery 也有助于缩短冗长的代码行，使其变得更简洁、更易理解。这一工具帮助
    jQuery 获得了超出想象的普及度。在本章中，我们将回顾 jQuery 的发展历程，它是如何演进的，如何使用它以及承诺（promises）是如何在 jQuery
    的成熟过程中发挥作用的。让我们从简要回顾 jQuery 的发展历程开始。
- en: From where it started?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它从哪里开始？
- en: The classical way of writing code in JavaScript was quite a tedious task. Since
    the language did not have many set rules, the code written in JavaScript was becoming
    unattainable and rewriteable. The way developers chose the names of their functions
    and variables was making simple functions nonreadable and thus not worthy to use
    in another project of a similar nature. Also, the fact was that JavaScript was
    considered as a second rated language in the computing world due to which not
    many people were using it seriously.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中编写代码的古典方式相当繁琐。由于该语言没有很多固定的规则，编写出的 JavaScript 代码变得难以实现和修改。开发人员选择函数和变量名称的方式使得简单函数变得不易阅读，因此在类似性质的另一个项目中不值得使用。此外，JavaScript
    被认为是计算机世界中第二流的编程语言，因此没有多少人认真使用它。
- en: In August 2006 the birth of jQuery, enlightened the JavaScript world. John Resig,
    the brain behind jQuery, announced in his blog post that jQuery 1.0 was released.
    This was the first time when people really started taking JavaScript seriously
    and were convinced of its trustworthiness. Though JavaScript has been around since
    the early 90s (as described in the first chapter), it has seen many ups and downs.
    Finally, with the release of Firefox browser and jQuery, JavaScript managed to
    gain some credibility.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 2006 年 8 月，jQuery 的诞生照亮了 JavaScript 世界。jQuery 的创造者约翰·雷西格（John Resig）在他的博客文章中宣布
    jQuery 1.0 正式发布。这是人们开始真正认真对待 JavaScript 并确信其可信度的第一次。虽然 JavaScript 从 90 年代初就已经存在（如第一章所述），但它经历了很多起伏。最终，随着
    Firefox 浏览器和 jQuery 的发布，JavaScript 终于获得了一些可信度。
- en: Behind the scenes – how does jQuery work?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幕后 – jQuery 是如何工作的？
- en: jQuery is based on a simple line of write less, do more; within a few lines
    of jQuery code, you will be able to achieve more tasks than conventional ways
    of writing code. jQuery has made many tasks easy to conclude in a short time span.
    It also brings neatness and readability in code, which earlier, was rare in JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 基于一个简单的原则：写得更少，做得更多。在几行 jQuery 代码中，你将能够完成比传统编写代码方式更多的任务。jQuery 在短时间内使许多任务变得容易完成。它还使代码更整洁、更易读，这在
    JavaScript 中是前所未有的。
- en: After the arrival of jQuery, things started to change dramatically for JavaScript.
    Many new implementations started to come on the screen with much more mature approaches,
    but the place jQuery has gained was unmatched then and still is.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 出现后，JavaScript 开始发生了戏剧性的变化。许多新的实现开始出现在屏幕上，采用更加成熟的方法，但 jQuery 获得的地位是无法比拟的，至今仍然如此。
- en: 'Having said this, let''s come back to our topic: how does jQuery work behind
    the scenes?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们回到我们的主题：jQuery 幕后是如何工作的？
- en: 'It all rotates around the $ sign. The jQuery library provides the jQuery ();
    function, which allows you select elements just like CSS selectors. For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一切围绕着美元符号（$）。jQuery 库提供了 jQuery() 函数，该函数允许你像 CSS 选择器一样选择元素。例如：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding line, the `$` sign is the representation of jQuery. In JavaScript,
    the variable name can be anything, but must not start with a numeric value and
    must not include a hyphen. In this way, using `$` is more convenient for the rules
    and easy to remember. You may also find functions like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行中，`$`符号是jQuery的表示。在JavaScript中，变量名可以是任何东西，但必须不以数字开头，且不能包含连字符。这样使用`$`对于规则来说更方便，也更容易记住。你也可以找到像这样的函数：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here the `$` sign comes at the very end of the function, and this is the same
    sight you will notice in the jQuery source code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$`符号出现在函数的最后。你会在jQuery源代码中注意到同样的情况。
- en: The mechanism is when you call `$()` and supply a selector to it, you are actually
    creating a new jQuery object. In JavaScript, functions are objects too, which
    means `$()` has not only embedded a single object, but it may contain methods,
    variables, and multiple objects. So, you might use `$.support` for information
    on the current environment or you may also use `$.ajax` for an AJAX call to make
    an AJAX request.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制是当你调用`$()`并给它提供一个选择器时，你实际上正在创建一个新的jQuery对象。在JavaScript中，函数也是对象，这意味着`$()`不仅嵌入了一个单一的对象，而且它可能包含方法、变量和多个对象。所以，你可以使用`$.support`来获取当前环境的信息，或者你也可以使用`$.ajax`来进行AJAX调用以发起AJAX请求。
- en: Is your document ready to submit?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的文档准备好提交了吗？
- en: Sometimes, it can happen that you submit your document when its half finished
    without knowing that it still needs to be processed further. Such an event triggers
    a chain of events that will eventually make your page or app go into the service-fail
    mode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在文档还未完成时提交它，而你不知道它还需要进一步处理，这种情况可能会发生。这样的事件将触发一系列事件，最终使你的页面或应用程序进入服务失败模式。
- en: 'Using jQuery, this is something that happens rarely as it provides the `$(document).ready()`
    method, which will help to complete of the processing the document. A simple example
    can be seen here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery，这种情况很少发生，因为它提供了`$(document).ready()`方法，该方法将帮助完成文档的处理。一个简单的例子可以在这里看到：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function will execute and will be passed to `.ready()` once the document
    is ready. We are using `$(document)` to create a jQuery object from the page's
    document. We will then call the `.ready()` function on that object, passing it
    the function we want to execute.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将执行，并在文档准备好时传递给`.ready()`。我们使用`$(document)`从页面的文档创建一个jQuery对象。然后我们在这个对象上调用`.ready()`函数，把它传递给我们想要执行的函数。
- en: How to use jQuery
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用jQuery
- en: As we saw in [Chapter 7](ch07.html "Chapter 7. Promises in Angular.js"), *Promises
    in Angular.js*, the documents related to Angular.js was the JavaScript file that
    was linked in HTML pages to call the functions; the same structure is used in
    jQuery.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第7章](ch07.html "Chapter 7. Promises in Angular.js")中看到的，*Angular.js中的Promises*，与Angular.js相关的文档是链接在HTML页面中调用函数的JavaScript文件；jQuery中使用了相同的结构。
- en: 'jQuery is a JavaScript file that was linked in at the very beginning of our
    HTML file. This can be done in two ways: either call the file from its location
    on the Web or download the JavaScript file on your local hard drive and then embed
    the code. Either way it will work, but we prefer to use it from our hard drive.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个链接在HTML文件开头的JavaScript文件。这可以通过两种方式实现：从Web上的位置调用文件，或者将JavaScript文件下载到你的本地硬盘上然后嵌入代码。无论哪种方式都可以工作，但我们更倾向于从硬盘上使用它。
- en: 'The following lines of code show when we want to link a file from its remote
    location:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行显示了当我们想要从远程位置链接文件时：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or, we can download the file on our local hard drive and change the syntax
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将文件下载到我们的本地硬盘上，并像这样更改语法：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `src="js` is indicating the local folder where JavaScript file exists.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`src="js"`表示JavaScript文件存在的本地文件夹。
- en: In a nutshell, you can either use the already written jQuery by embedding it
    at the head of the HTML file using the URL or you can download it and make your
    own modifications. In both ways, your output will be generated on the screen of
    the browser.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，你可以选择使用已经写好的jQuery，通过在HTML文件头部嵌入URL来使用它，或者你可以下载它并进行自己的修改。无论哪种方式，你的输出都会在浏览器的屏幕上生成。
- en: The syntax
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法：
- en: 'The real power of jQuery lies in its custom made syntax, which will help in
    selecting HTML elements and perform some action. Its syntax is quite straightforward
    and easy to remember, plus it''s very neatly written. Here is a sample of jQuery
    syntax:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的真正力量在于其自定义的语法，这将帮助选择HTML元素并执行一些操作。它的语法相当直接且容易记住，而且非常整洁。以下是jQuery语法的示例：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The dollar sign (`$`) defines whether you will use jQuery, whereas the `selector`
    query is to find the HTML element and `action` defines what kind of action will
    be performed on selected elements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 美元符号（`$`）定义了你是否将使用jQuery，而`selector`查询是用来查找HTML元素的，`action`定义将在选定的元素上执行什么类型的操作。
- en: 'Here are some examples that will explain how jQuery works using its syntax:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用jQuery语法的示例，解释了jQuery是如何工作的：
- en: '`$(this).hide()`: This hides the current element'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(this).hide()`：隐藏当前元素'
- en: '`$("p").hide()`: The hides all `<p>` elements'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$("p").hide()`：隐藏所有`<p>`元素'
- en: '`$(".test").hide()`: This hides all elements with `class="test"`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(".test").hide()`：隐藏所有具有`class="test"`的元素'
- en: '`$("#test").hide()`: This hides the element with `id="test"`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$("#test").hide()`：隐藏具有`id="test"`的元素'
- en: 'These are a few examples of hundreds of other methods provided by jQuery. For
    the complete reference on methods and APIs, here''s the link for all your jQuery
    needs: [https://api.jquery.com/](https://api.jquery.com/).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是jQuery提供的成百上千种方法中的几个示例。对于方法和API的完整参考，以下是所有jQuery需求的链接：[https://api.jquery.com/](https://api.jquery.com/)。
- en: Caching in jQuery
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery中的缓存
- en: Let's discuss caching in brief specifically relating to jQuery and as a concept
    in general.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下与jQuery相关的缓存，以及作为一个概念的缓存。
- en: The concept of caching is as old as the Internet itself, at least with the modern
    day Internet. Developers are using it to store repetitive data and to reduce cost
    to server calls or to remember the connection between the user and server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的概念与互联网本身一样古老，至少与现代互联网一样古老。开发者使用它来存储重复的数据，以减少服务器调用成本或记住用户与服务器之间的连接。
- en: Caching helps in many ways to boost the performance of web apps by writing images
    and sending the session's information to the user's hard drive at a special location
    called the temporary storage. Mostly, this location is specifically created on
    the local hard drive and is there to deal with such type of data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存通过将图像写入并把会话信息发送到用户硬盘上的特殊位置——临时存储，以多种方式提高web应用的性能。通常，这个位置是专门在本地硬盘上创建的，专门处理这类数据。
- en: Say you are surfing an online shopping cart over your browser. At the very first
    instance, the site is being loaded to your temporary memory. This includes adding
    images of products and other meta information that marks the initial caching of
    that particular website. Now, say you have decided to purchase a product and signed
    in to the user's area of the shopping cart. This will cache your information in
    a little text file called a cookie, which holds the information about who you
    are and remembers the web server you are talking to. This is a flow of caching
    your information over the temporary location to reduce server calls, optimize
    navigation, and let the server remember your identity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说你正在通过浏览器浏览一个在线购物车。在最初的时刻，网站被加载到你的临时记忆中。这包括添加产品的图片和其他元信息，这标志着该特定网站的初始缓存。现在，假设你决定购买一个产品并登录到购物车的用户区域。这将会在一个名为cookie的小文本文件中缓存你的信息，该文件持有关于你是谁以及记住你正在与哪个web服务器对话的信息。这是一个将你的信息缓存到临时位置的流程，以减少服务器调用，优化导航，并让服务器记住你的身份。
- en: What does jQuery have to offer when it comes to caching and handing elements
    that need to cache? Let's take a look.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery在缓存需要缓存的元素方面有什么提供呢？让我们来看看。
- en: Caching in jQuery is offered by data function, and it's the same as any other
    function calls you make within jQuery. This function itself allows you to bind
    random data to random selectors. Most of the developers use it for manipulation
    with DOM elements, but this is not limited to it. You can add multiple selectors
    to bind to multiple references at a given time slot as the function takes care
    of it automatically; it's as simple and easy as this. However, how do the elements
    and their handlers stay in the memory?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中的缓存是通过data函数提供的，它与你在jQuery中调用的任何其他函数相同。这个函数本身允许你将随机数据绑定到随机选择器。大多数开发者使用它来操作DOM元素，但它的应用并不仅限于于此。你可以在给定的时间槽内添加多个选择器，以绑定多个引用，因为函数会自动处理；就是这么简单和容易。然而，元素和它们的处理程序是如何保持在内存中的呢？
- en: jQuery follows the "name corresponds value" method to write and handle the elements
    in the memory. The unique part of it is the name of element can be same for many
    entries, but they must have to point to different DOM elements. In this way, reference
    by value comes into play and referring to a particular element will be faster
    and easy to traverse by the program using it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery遵循“名称对应值”的方法来编写和处理内存中的元素。其独特之处在于，元素的名称对于许多条目来说可以相同，但它们必须指向不同的DOM元素。这样，通过值引用就变得重要了，并且引用特定元素对于使用它的程序来说会更快、更容易遍历。
- en: 'Now, to add elements to the data function, we will follow a syntax similar
    to the one shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要向数据函数添加元素，我们将遵循与此类似的语法：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From here, you can see that we bind the selector with the `data()` function,
    and within the function, we supplied two parameters as the name and its corresponding
    value. In this way, we can bind as many selectors as we want to cache them up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以看到我们将选择器与`data()`函数绑定，并在函数内部提供了两个参数作为名称及其相应的值。这样，我们可以绑定尽可能多的选择器来缓存它们。
- en: 'However, the story has a twist. You can write in cache using `data()`, but
    it won''t remove data on its own. You have to remove it manually from the temporary
    memory. You can do it by calling out the `removeData()` method like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，故事有一个转折。你可以使用`data()`在缓存中写入，但它不会自动删除数据。你必须从临时内存中手动删除它。你可以像这样调用`removeData()`方法：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, you can automate the function call of `removeData()` by writing some
    kind of cron/timer job function. However, this requires smart engineering and
    loads of dry run to that particular job as this can wipe out any important data
    from the temporary storage permanently, so it's advised to use such timer jobs
    in a very careful manner.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过编写某种cron/定时任务函数来自动化`removeData()`的函数调用。然而，这需要巧妙的工程设计和大量的干燥运行，因为此操作可能会从临时存储中永久删除任何重要数据，所以建议非常谨慎地使用此类定时任务。
- en: Overall, caching in jQuery is an essential component, and without this, you
    cannot optimize your application's flow and data traversing. Using jQuery cache
    will also optimize the number of server calls and will boost the performance of
    your piece of code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，jQuery中的缓存是一个基本组成部分，没有它，你无法优化应用程序的流程和数据遍历。使用jQuery缓存还可以优化服务器调用的数量，并提高你代码的性能。
- en: A sample example
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: Before we start the prime topic of this chapter, we need to understand how we
    draft files that can use jQuery query. This will give us a better understanding
    of the code level working and will make us skilled to use promises in jQuery.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始本章的主要内容之前，我们需要了解如何编写可以使用jQuery查询的文件。这将使我们更好地理解代码级别的运作，并将使我们能够熟练地在jQuery中使用承诺。
- en: Let's start with selectors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从选择器开始。
- en: Selectors
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择器
- en: 'Selectors enable us to select and manipulate HTML. We can use them to find
    HTML elements that are based on their IDs: classes, types, attributes, values,
    and much more stuff. These selectors are just like selectors in CSS, but with
    the jQuery touch. Here touch is all the selectors start with the dollar sign,
    `$`, followed by round brackets and dot, as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器使我们能够选择和操作HTML。我们可以使用它们来查找基于它们ID的HTML元素：类、类型、属性、值等等。这些选择器与CSS中的选择器类似，但带有jQuery的特色。这里的特色是所有选择器都以美元符号`$`开头，后面跟着圆括号和点，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Have a look at the preceding code. The script tag right after the `</script>`
    tag is the place where the selector defines itself and then processes the requests.
    Once the page is loaded, it will say "I am a paragraph" with a button, and when
    you click on it, the name of the button will change to "I am a button" from "I
    am a paragraph." This all happened without any page change since jQuery was able
    to play with HTML elements on the go and display results on the same page. This
    is one helpful feature of jQuery out of the many that developers are using on
    a daily basis. Such binding, instantaneous computing is the reason why jQuery
    is the choice of many groups of developers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的代码。`</script>`标签后面的脚本标签是选择器定义自己并进行请求处理的地方。一旦页面加载完成，它将带有一个按钮说“我是一个段落”，当你点击它时，按钮的名称将从“我是一个段落”更改为“我是一个按钮”。这一切都是在没有页面更改的情况下发生的，因为jQuery能够实时地与HTML元素交互并在同一页面上显示结果。这是jQuery众多开发者每天都在使用的有益特性之一。这种绑定、即时计算是jQuery成为许多开发者选择的原因。
- en: Event methods
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件方法
- en: 'jQuery has many event-driven interfaces. These interfaces are invoked when
    you trigger some event. There are many events such as mouse click, double-click
    by mouse, keystroke, mouse hover, and touch. They are made simple by jQuery; all
    you need to do is write a few lines of code and the rest of the processing will
    be taken over by the jQuery library. Have a look at the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery有许多事件驱动的接口。当您触发某个事件时，这些接口将被调用。有许多事件，如鼠标点击、鼠标双击、键盘按键、鼠标悬停和触摸。jQuery使它们变得简单；你只需要写几行代码，其余的处理将由jQuery库完成。请看以下示例：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Okay, what will happen to the page when I click on the text that appears on
    the screen? Any guesses? Yes, it will disappear as I passed the value of the `h1`
    tag into the jQuery function, which will then hide it when it senses the mouse
    has been clicked on it. This is how we normally used to play around with placeholders
    in the forms or text areas, but nowadays, forms have this ability built in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我点击屏幕上出现的文本时，页面会发生什么？有人猜测吗？是的，当我把`h1`标签的值传递给jQuery函数时，它会消失，当它感觉到鼠标被点击时，它会隐藏它。这是我们通常在表单或文本区域中玩占位符的方式，但现在，表单已经内置了这种能力。
- en: Having said this, it's time to move on to the core of our chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，是时候转向我们章节的重点了。
- en: JavaScript before and after jQuery
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery之前的JavaScript和之后的JavaScript
- en: There was a time when a simple mouse click can be caught by a simple function,
    `element.onClick = functionName`. This was good till the time another function
    came about that wanted to listen to the same click. This was solved by adding
    the `addListenerEvent` function from the DOM function. This had added as many
    possible listener functions, and we used to adopt this approach.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，一个简单的鼠标点击可以通过一个简单的函数`element.onClick = functionName`来捕获。这对当时来说很好，直到另一个想要监听同一个点击事件的函数出现。这个问题通过从DOM函数中添加`addListenerEvent`函数来解决。这个函数尽可能多地添加了监听器函数，我们通常采用这种方法。
- en: However, such happenings are meant to reoccur as we are now facing the same
    problem with AJAX calls. AJAX uses a single callback function and not only the
    jQuery `$ajax()`, but also the `XMLHttpRequest` object which has similar problems.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样的情况是注定要再次发生的，因为我们现在面临着与AJAX调用相同的问题。AJAX使用一个单一的回调函数，不仅是jQuery的`$ajax()`，还有具有类似问题的`XMLHttpRequest`对象。
- en: The solution – introducing promises in jQuery
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案——在jQuery中引入承诺
- en: 'The solution to the preceding problem was finally delivered in jQuery 1.5 as
    the deferred object. Before the deferred concept was introduced in jQuery, the
    typical AJAX call was something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面问题的解决方案最终在jQuery 1.5中以延迟对象的形式提供。在jQuery中引入延迟概念之前，典型的AJAX调用是这样的：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Can you guess what could be the output of this function? Yes, a single `XMLHttpRequest`
    object, which is quite expected for those who are still maintaining the apps built
    before jQuery 1.5.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出这个函数的输出是什么吗？是的，一个单独的`XMLHttpRequest`对象，这对于那些仍然维护着在jQuery 1.5之前构建的应用的人来说是相当预期的。
- en: Now, what dramatical change was introduced in jQuery 1.5\. First of all, it's
    based on a specification of common JavaScript that defines common interfaces and
    can be extended as per the needs, and secondly, they are quite global and you
    can use these in similar services, such as Node.js.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，jQuery 1.5中引入了什么重大变化呢？首先，它是基于一个 common JavaScript规范，定义了常见的接口，可以根据需要进行扩展，其次，它们非常全局化，你可以将这些功能用在类似的服务中，比如Node.js。
- en: 'After the addition of deferred objects in jQuery 1.5, the preceding code was
    rewritten like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在jQuery 1.5中添加了延迟对象之后，之前的代码被重写成了这样：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you want to write a more concise version of the preceding code, it can be
    achieved as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要编写前述代码的更简洁版本，可以按照以下方式实现：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Likewise, there are a number of other advancements that were brought in by introducing
    promise in jQuery. In the following sections, we will take a closer look into
    how jQuery is getting its promises fulfilled.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过在jQuery中引入承诺，带来了许多其他进步。在以下部分中，我们将详细了解jQuery是如何实现其承诺的。
- en: Deferred in jQuery
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery中的延迟
- en: 'Like in any other implementation of promises, `Deferred` also has its importance
    and value in jQuery. The power lies in the implementation of the concept, which
    is straightforward, yet very powerful. In jQuery, `deferred` has two important
    methods that are used to attach with three important events so that they can be
    linked to a callback. The methods are `resolve` and `reject`, and the events that
    can be attached with a callback are `done()`, `fail()`, and `always()`. Let''s
    see it with an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 像在承诺的任何其他实现中一样，`Deferred`在jQuery中也有其重要性和价值。力量在于概念的实现，这是简单而强大的。在jQuery中，`deferred`有两个重要的方法，用于与三个重要事件链接以附加回调。这些方法是`resolve`和`reject`，可以附加回调的事件是`done()`、`fail()`和`always()`。让我们通过一个例子来看一下：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The thing to remember here is that callback will always be executed no matter
    whether `deferred` is resolved or not, but when you call the `reject` method,
    the failed callback will be executed. Having said that, our preceding example
    can look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要记住的是，无论`deferred`是否解决，回调总是会被执行，但是当你调用`reject`方法时，失败的回调将被执行。说到这一点，我们前面的例子可以像这样：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we are to summarize what the `$.Deferred` object is; we can say it's just
    a promise that has methods, which will allow its owner to either resolve or reject
    it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要总结`$.Deferred`对象是什么；我们可以说是只是一个有方法的承诺，这将允许其所有者要么解决要么拒绝它。
- en: $.Deferred().promise() in jQuery
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $.Deferred().promise() in jQuery
- en: One of the shiny stars of `Deferred` is its promises. What this method can do?
    Well, it returns an object, and with nearly the same interface as `Deferred`.
    However, there is a catch. It's there just to attach the callbacks and not to
    resolve or reject.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deferred`的闪亮之星之一就是它的承诺。这个方法能做什么？嗯，它返回一个对象，并且几乎与`Deferred`相同的接口。但是，有一个陷阱。它只是为了附加回调，而不是解决或拒绝。'
- en: This is quite useful in some other conditions, say you want to call out an API.
    This will not have the ability to resolve or reject the deferred. Such code will
    eventually fail as the promise here does not have a method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在某些其他情况下非常有用的功能，比如说你想调用一个API。这将没有能力解决或拒绝延迟。这样的代码最终会失败，因为这里的承诺没有方法。
- en: 'Try executing this code, save it as `test.html` and run the file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试执行这段代码，将其保存为`test.html`然后运行文件：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will get an error like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个错误，像这样：
- en: '![$.Deferred().promise() in jQuery](img/5500OS_08_01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![$.Deferred().promise() in jQuery](img/5500OS_08_01.jpg)'
- en: 'So, as mentioned earlier, it returns an object and with nearly the same interface
    as that of `Deferred`. However, it''s there just to attach the callbacks not to
    resolve or reject; this is the catch that we talked about earlier. Now, how can
    we resolve it? Simple. You can use promise as a return value for another function;
    let''s try the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，像前面提到的那样，它返回一个对象，并且几乎与`Deferred`相同的接口。然而，它只是为了附加回调，而不是解决或拒绝；这是我们之前谈论的陷阱。现在，我们如何解决它？很简单。你可以将承诺作为另一个函数的返回值；让我们尝试以下代码：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you run the preceding code, it will give you an error in the alert dialog
    box on the page, which it shouldn''t when the URL passed in the URL variable is
    real. For the sake of understanding, let''s assume the URL was proper and that
    it saved the value, the result will be like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的代码时，它会在页面的警告对话框中给出一个错误，如果URL变量中传递的URL是真实的，它不应该这样做。为了理解，让我们假设URL是正确的，它保存了值，结果会像这样：
- en: '![$.Deferred().promise() in jQuery](img/5500OS_08_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![$.Deferred().promise() in jQuery](img/5500OS_08_02.jpg)'
- en: The preceding code and the one before that has only one difference—you can add
    as many callbacks as you want, the grammar of the code is clean as it shows that
    we don't want an extra parameter in the method. Thus, you can ask promise in jQuery
    to perform some operations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码和那一段代码只有一个区别——你可以添加尽可能多的回调，代码的语法干净，因为它显示我们不想在方法中有一个额外的参数。因此，你可以要求jQuery中的承诺执行一些操作。
- en: Projecting a promise in jQuery
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery中的承诺投射
- en: In some cases, we have to just display the name of a promise. This will be much
    needed when you only want to see what the element can be or what operations you
    want to perform on an object. Using jQuery, we can easily achieve it by using
    the `pipe()` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们只需要显示一个承诺的名字。当您只想查看元素可以是什么或者您想对对象执行哪些操作时，这将非常有用。使用jQuery，我们可以通过使用`pipe()`函数轻松实现。
- en: 'Consider this code where we are projecting the result, which is an actor:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个我们正在投射结果的代码，结果是一个演员：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The result of the code will be the full name, Arnold Schwarzenegger, displayed
    on an alert dialog box at the browser:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结果将是一个全名，阿诺德·施瓦辛格，在浏览器的警告对话框中显示：
- en: '![Projecting a promise in jQuery](img/5500OS_08_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![jQuery中的承诺投影](img/5500OS_08_03.jpg)'
- en: As you can see, the projection of the result is an actor name used as an object.
    So, instead of deferred of a person, we have a deferred of `Name Saved >> Arnold
    Schwarzenegger`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果的投影是一个用作对象的演员名字。所以，我们不是一个人 deferred，我们有一个`Name Saved >> Arnold Schwarzenegger`的deferred。
- en: 'The `pipe` function can also be used to return the object from deep inside
    a method call. We can dig out an actor name and his IMDB rating, as explained
    in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe`函数也可以用来从方法调用深处返回对象。我们可以挖掘出一个演员的名字和他的IMDB评分，如下面的代码所示：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you run this code, it will give you an alert output on the browser, which
    will look like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，它将在浏览器上给你一个警告输出，看起来像这样：
- en: '![Projecting a promise in jQuery](img/5500OS_08_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![jQuery中的承诺投影](img/5500OS_08_04.jpg)'
- en: By the virtue of `pipe()`, we will dig into callback and on passing the correct
    parameters to the function `getActorById()`; we able to get our desired results
    displayed. In a similar manner, you can use `pipe()` to reject `deferred` inside
    the callback.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 借助`pipe()`方法，我们将深入探讨回调和在传递给函数`getActorById()`时正确参数的传递；我们能够得到我们期望的结果显示。类似地，你也可以在回调内部使用`pipe()`来拒绝`deferred`。
- en: One more thing that you can do with `pipe` is recursive deferred. Say, you have
    an asynchronous operation at the backend of API calls, and you need to poll all
    the response sets before you can put them to use. You can ask `pipe()` to help
    you out.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pipe`的另一种方法是递归deferred。比如说，你在API调用的后端有一个异步操作，你需要轮询所有的响应集合才能使用它们。你可以请`pipe()`帮助你。
- en: 'Consider the following code that will help collect API responses and let you
    know whether all the responses are collected or not:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，这将帮助收集API响应并让你知道是否已经收集了所有的响应：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Please note that we didn't give any hardcoded value for computing the results,
    rather we used `math.random()` to calculate the results every time we hit refresh.
    This is just a mechanism using which you can pool data, validate it, and then
    use it as required.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有为计算结果提供任何硬编码值，而是每次刷新时使用`math.random()`来计算结果。这只是一个机制，你可以用它来轮询数据，验证它，然后按需使用。
- en: So, we saw how the `pipe()` method can be beneficial in writing neat and maintainable
    code. This also gave us a view of how we can use `deferred` in the longer run
    while remaining under the umbrella of jQuery.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们看到了`pipe()`方法在编写整洁和可维护的代码方面的好处。这也让我们看到了我们如何在较长的时间内使用`deferred`，同时仍然在jQuery的庇护下。
- en: Joining promises with $.when
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用$.when联合承诺
- en: '`$.when` is another method that can accept multiple promises and return a master
    deferred object. This master object can be resolved if all the promises are resolved,
    or it would be rejected if any of the promises were rejected. You may have sequence
    like `when().then().done()` or you can add multiple `when()` methods followed
    by `then()` and `done()`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.when`是另一个可以接受多个承诺并返回一个主deferred对象的方法。这个主对象可以在所有承诺都被解决时解决，或者如果任何承诺被拒绝，它将被拒绝。你可能有一个序列，如`when().then().done()`，或者你可以添加多个`when()`方法，后面跟着`then()`和`done()`。'
- en: 'Let''s take a look at an example of how the code will look like with `$when()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个用`$when()`的代码示例：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you execute the preceding code, it will generate an output like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行前面的代码时，它将生成如下输出：
- en: '![Joining promises with $.when](img/5500OS_08_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用$.when联合承诺](img/5500OS_08_05.jpg)'
- en: Notice that at the end of the code, the `$.when` function returns a new master
    deferred object, and we used two results in one `done()` callback.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在代码的最后，`$.when`函数返回一个新的主deferred对象，我们在一个`done()`回调中使用了两个结果。
- en: We also changed the `getActorByRating()` method due to the fact that the promise
    of an AJAX call, which has the content payload, has the first element in the result
    along with status code included.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还改变了`getActorByRating()`方法，因为AJAX调用的承诺，包含内容负载，在结果中的第一个元素以及状态代码。
- en: 'However, this is not the end; you can also use `$.when` with pipes. Let''s
    see how:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是结束；你也可以用`$.when`和管道使用。让我们看看：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: From the preceding code, you can easily see how `when()` and `pipe()` can work
    in combination and produce results. By summarizing the preceding code, we can
    say the sequence of our code was like `when()`, `pipe()`, and `done()`. The `done()`
    method is the last milestone that has compiled and presented the result on our
    screen.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的代码中，你可以很容易地看出`when()`和`pipe()`是如何组合在一起产生结果的。通过总结之前的代码，我们可以认为我们代码的顺序就像`when()`、`pipe()`和`done()`。`done()`方法是最后一个里程碑，它已经编译并在我们的屏幕上展示了结果。
- en: 'We can also use `when()` as an operator. Remember in JavaScript, every method
    can be a variable. Let''s see how to do it using this code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`when()`用作操作符。记住在JavaScript中，每个方法都可以是一个变量。让我们看看如何使用这段代码：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So from the preceding code, you can clearly see how we can use `when()` in many
    different ways. We can add more variety to it as it has many implementations and
    best case scenarios for solving complex problems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从之前的代码中，你可以清楚地看到我们如何以多种不同的方式使用`when()`。我们可以通过添加更多实现和解决复杂问题的最佳案例来增加它的多样性。
- en: Your own $.Deferred process
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你自己的$.Deferred过程
- en: You can customize the deferred object as per your need. This is simple and can
    be achieved by calling out the `jQuery.Deferred()` method. We can also define
    our own process and the sequence of the flow and arrange the output as required.
    We can use `setInterval()` to set up the delays and `setTimeout()` to decide when
    to end the sequence. The scope of variable declaration decides whether the deferred
    object has to be locally or globally processed. If the deferred object is assigned
    to a local variable, we can call deferred object's `resolve()`, `promise()`, and
    `notify()` events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要自定义deferred对象。这很简单，可以通过调用`jQuery.Deferred()`方法来实现。我们还可以定义自己的流程和流动顺序，并按需安排输出。我们可以使用`setInterval()`来设置延迟，并使用`setTimeout()`来决定何时结束序列。变量声明的范围决定了deferred对象是本地处理还是全局处理。如果deferred对象被分配给一个局部变量，我们可以调用deferred对象的`resolve()`、`promise()`和`notify()`事件。
- en: 'Let''s have a look at this example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个例子：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, from the preceding code, we are able to achieve a skeleton of the processes.
    This can be simplified by making it more concise or by adding some combining methods
    such as `then()`, `when()`, and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从之前的代码中，我们能够实现一个流程的骨架。这可以通过使其更简洁，或者通过添加一些组合方法，如`then()`、`when()`等来简化。
- en: 'Let''s have a look at this compact code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段紧凑的代码：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is more concise and easy to scale. The learning element from this section
    is one thing; you can also go for the custom-made deferred in jQuery. It's easy,
    maintainable, and you can scale it as per your need.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更加简洁，易于扩展。这一节的学习要点是，你也可以选择jQuery中的自定义deferred。它简单、可维护，并且可以根据你的需要进行扩展。
- en: The advent of promises in jQuery
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery中的promise的出现
- en: So far we learned how promise can be used in jQuery, what deferred object is,
    and how we can achieve certain tasks using this concept. Why should we use it?
    The answer is simple, it has many capabilities to maximize our output and build
    applications in a lesser time. However, what can it actually do for us? Let's
    have a look.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何在jQuery中使用promise，什么是deferred对象，以及如何使用这个概念来实现某些任务。为什么要使用它？答案很简单，它有很多能力来最大化我们的输出，并在更短的时间内构建应用程序。然而，它实际上能为我们做什么呢？让我们来看看。
- en: 'We can call the `done()` and `fail()` functions as many times as we want, with
    different callbacks. Maybe we have a callback function that can halt our animation,
    or one that does a new AJAX call, and so on:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用`done()`和`fail()`函数无数次，每次都可以有不同的回调。也许我们有一个回调函数可以停止我们的动画，或者一个执行新AJAX调用的函数，等等：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: No matter whether the AJAX call has finished, we can still call the `done()`
    and `fail()` functions and the callbacks are executed immediately. So, variables
    stated are not a big deal. When the call has finished, it will end up in either
    the success state or the failed state, and this state will not change.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 无论AJAX调用是否完成，我们仍然可以调用`done()`和`fail()`函数，回调立即执行。所以，声明的变量并不是什么大问题。当调用完成后，它将最终进入成功状态或失败状态，并且这个状态不会改变。
- en: 'We can combine promises. Say we have to do two simultaneous AJAX calls and
    we need to execute a function when both are successfully finished, as shown in
    the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以组合promise。比如说，我们需要同时执行两个AJAX调用，并且需要在两者都成功完成后执行一个函数，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From jQuery 1.8, we can chain the `then()` function consecutively:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从jQuery 1.8开始，我们可以连续地链式调用`then()`函数：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So, with this chapter coming to an end, let's revise the topics we have covered
    so far.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，随着这一章的结束，让我们回顾一下我们迄今为止所涵盖的主题。
- en: We have seen the how jQuery has started taking shape and how it became a fundamental
    element of the modern-day web development. We have learned how to build basic
    jQuery documents and how to call the functions embedded into HTML files. We have
    learned why we started using deferred and promise in jQuery and how it helped
    us in achieving cutting-edge applications on both web -based platform and portable
    devices. We have seen saw many working examples to understand better and clear
    any doubts. The topic of promises in jQuery is huge, but we tried to summarize
    as much as we can to lay out solid foundations for those who hadn't used this
    property before and to help those who are already using it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了jQuery是如何开始成形的，以及它是如何成为现代网页开发的一个基本元素。我们已经学会了如何构建基本的jQuery文档以及如何调用嵌入HTML文件中的函数。我们已经了解了为什么我们开始在jQuery中使用延迟和承诺，以及它是如何帮助我们实现基于网络平台和便携设备的尖端应用程序的。我们已经看到了许多工作示例，以更好地理解并澄清任何疑问。jQuery中的承诺主题非常庞大，但我们试图尽可能地总结，为那些之前没有使用过这个属性的人打下坚实的基础，并帮助那些已经开始使用它的人。
- en: In the next chapter, we will see how all the combined JavaScript and their properties
    are shaping up to bring the world closer and making our life easier in the days
    to come.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何将所有结合的JavaScript及其属性整合在一起，以使世界变得更紧密，并在未来使我们的生活变得更容易。
