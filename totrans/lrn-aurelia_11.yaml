- en: Chapter 11. Integrating with Other Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章．与其他库集成
- en: A UI framework never lives on its own, especially a web framework. The web being
    such a rich platform and being driven by such a dynamic community, there are thousands
    of libraries, widgets, and components out there that can be leveraged in countless
    scenarios, and which save developers tremendous amounts of time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UI框架永远不会独自存在，尤其是Web框架。由于Web是一个丰富的平台，并且由一个充满活力的社区推动，因此有数千个库、小部件和组件可以在这个平台上无数的场景中
    leverage，这大大节省了开发人员的时间。
- en: In this chapter, we will see how we can integrate various libraries into our
    contact-management application. We'll add UI widgets from both Bootstrap and jQuery
    UI, some drag and drop support using `sortable.js`, and graphs using D3\. We'll
    also see how we can leverage SASS instead of CSS. Finally, we'll even see how
    we can integrate Polymer components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何将各种库集成到我们的联系人管理应用程序中。我们将添加来自Bootstrap和jQuery UI的UI小部件，使用`sortable.js`提供一些拖放支持，以及使用D3的图表。我们还将了解如何利用SASS而不是CSS。最后，我们甚至将了解如何集成Polymer组件。
- en: Using Bootstrap widgets
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bootstrap小部件
- en: Since the beginning of this book, we have relied on Bootstrap to style and lay
    out our application. However, we haven't used the library's JS widgets. Let's
    see how we can integrate such widgets into our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从这本书的开头到现在，我们一直依赖于Bootstrap来为我们的应用程序样式和布局。然而，我们还没有使用库的JS小部件。让我们看看我们如何可以将此类小部件集成到我们的应用程序中。
- en: Loading the library
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载库
- en: 'Since jQuery is used by Bootstrap''s JS widgets, we''ll first need to install
    it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Bootstrap的JS小部件使用jQuery，所以我们首先需要安装它：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to add jQuery and Bootstrap JS resources to the vendor bundle:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将jQuery和Bootstrap JS资源添加到供应商包中：
- en: '`aurelia_project/aurelia.json`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_project/aurelia.json`'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we add jQuery to the bundle's dependencies, then we update the entry for
    Bootstrap so the JS widgets are loaded after jQuery is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在包的依赖项中添加了jQuery，然后更新了Bootstrap的条目，以便在jQuery之后加载JS小部件。
- en: The `bootstrap` module in the application is also configured to export the global
    `jQuery` object. This means that we'll be able to import the `jQuery` object from
    `bootstrap` in our JS code, and we'll be sure that the Bootstrap widgets have
    been registered on jQuery.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的`bootstrap`模块也配置为导出全局`jQuery`对象。这意味着我们可以在JS代码中从`bootstrap`导入`jQuery`对象，并确保Bootstrap小部件已经注册到jQuery上。
- en: Creating a bs-tooltip attribute
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个bs-tooltip属性
- en: 'Let''s go over a simple example of using a Bootstrap JS widget with Aurelia.
    We''ll create a custom attribute that will encapsulate the Bootstrap `tooltip`
    widget:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看如何使用Bootstrap JS小部件与Aurelia配合。我们将创建一个自定义属性，它将封装Bootstrap的`tooltip`小部件：
- en: '`src/resources/attributes/bs-tooltip.js`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/resources/attributes/bs-tooltip.js`'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we start by importing the jQuery global object from Bootstrap. This will
    ensure that the Bootstrap JS library was properly loaded and registered to the
    jQuery namespace. We also declare the list of properties supported by the `tooltip`
    widget, so the attribute can use dynamic options and just ignore unsupported options.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从Bootstrap中导入jQuery全局对象。这将确保Bootstrap JS库已正确加载并注册到jQuery命名空间中。我们还声明了`tooltip`小部件支持的属性列表，因此属性可以使用动态选项，并忽略不支持的选项。
- en: 'We''ll use dynamic options instead of explicit options, just to write less
    code. We''ll write some change-handler methods next, and if we use an explicit
    list of properties, all declared as bindable on the `BsTooltipCustomAttribute`
    class, we will have to write a distinct change handler for each property. All
    those change handlers will do pretty much the same thing: update the corresponding
    option on the Bootstrap widget. Instead, since we use dynamic options, we can
    write a single change handler that will be called for all options.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用动态选项而不是显式选项，只是为了少写一些代码。我们接下来会写一些更改处理方法，如果我们使用一个显式的属性列表，在`BsTooltipCustomAttribute`类中全部声明为可绑定的，我们将为每个属性编写一个不同的更改处理器。所有这些更改处理器都会做几乎相同的事情：更新Bootstrap小部件的相应选项。相反，由于我们使用动态选项，我们可以为所有选项编写一个单一的更改处理器。
- en: We can now create a custom attribute, named `bs-tooltip`. It receives as a constructor
    argument the DOM element on which it is placed. When attached to the DOM, it assigns
    the value bound to the attribute for each supported property to an `init` object.
    This object is then passed to the `tooltip` initialization method, which is called
    on the element hosting the attribute. This last line will create the `tooltip`
    widget.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when detached from the DOM, it just calls the `destroy` method on the
    `tooltip` widget.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'This first version of the `bs-tooltip` attribute doesn''t support updating
    properties. This can be added by using the `propertyChanged` callback method to
    update the `tooltip` widget:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/attributes/bs-tooltip.js`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, when the value of a property changes and the attribute is currently attached
    to the DOM, we first make sure that the property is supported by the widget, then
    we simply update the widget's property.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Using the attribute
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now add a Bootstrap `tooltip` to any element. Let''s replace the **Remove**
    button''s `title` attribute with a Bootstrap `tooltip` in the `list-editor` component:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we simply remove the `t="[title]..."` attribute from the **Remove** button
    and replace it with a `bs-tooltip` attribute. In this attribute, we define a `title`
    option, to which we bind the result of the same translation as before. The fact
    that we use the `.bind` command and the `t` binding behavior will cause the tooltip's
    `title` to be updated when the current locale changes. We also specify that the
    `tooltip` should be placed to the `right` of the hosting element using the `placement`
    option.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to load the `bs-tooltip` attribute, either as a global resource
    in the `resources` feature's `configure` function, or in the template of `list-editor`
    using a `require` statement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: If you run the application at this point and hover over a **Remove** button
    in one of the `list-editor` instances with your mouse, a Bootstrap `tooltip` widget
    should show up.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bs-datepicker element
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One widget our contact-management application could greatly benefit from is
    a date picker. This would make entering a birthday much more comfortable for most
    users.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap doesn't include a date picker per se, but some are available as plugins.
    In this section, we'll install the `bootstrap-datepicker` plugin, load it, and
    create a new custom element that will encapsulate an `input` element hosting a
    date picker.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Installing the bootstrap-datepicker plugin
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll first install the Bootstrap plugin:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to add it to the vendor bundle:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we add the `bootstrap-datepicker` library to the vendor bundle. Just like
    the standard Bootstrap widgets, this plugin adds new functions on the jQuery object,
    so it needs to have a dependency on jQuery so it can register itself. It also
    loads its own stylesheet as an additional resource.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Creating the custom element
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the plugin is ready to be used, we can start building the custom element.
    Our `bs-datepicker` element will expose a two-way bindable `date` property, which
    will be assigned the selected date as a `Date` object. It will also expose a bindable
    `options` property, which will be used to provide the options passed to the underlying
    `bootstrap-datepicker` widget instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s write its template:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/bs-datepicker.html`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This template simply requires the stylesheet `bootstrap-datepicker`, then declares
    an `input` element. A reference to this `input` will be assigned to the binding
    context's `input` property, so the view-model can use it to host the date picker.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s write the view-model class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/bs-datepicker.js`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We start by importing the global jQuery object from Bootstrap; remember, we
    configured the Bootstrap library so it exports the jQuery object when we added
    it to the vendor bundle to write the `bs-tooltip` attribute.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Next, we load the `bootstrap-datepicker` plugin so it is properly registered
    to jQuery, then create the custom element's class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: It first declares a static `defaultOptions` property, which is used to set the
    default values for the options passed to the widget when creating it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: When the element is attached to the DOM, it creates a `datepicker` widget instance
    on the `input`. It also subscribes to the widget's `clearDate` and `changeDate`
    events, so it can update its own `date` property when the widget's selected date
    changes; then it initializes the widget's selected date.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we add those event listeners and why we don't just bind to
    the value of `input`. That's because the widget already handles validation of
    the value of `input` and its parsing as a `Date` object, so it is much simpler
    for our custom element to rely on the selected date of `datepicker`. Basically,
    our custom element just bridges its `date` bindable property with the selected
    date of `datepicker`. When the widget's selected date changes, one of the event
    listeners is triggered and the widget's new value is assigned to the element's
    `date` property. Similarly, since the element's `date` property uses two-way binding
    by default, when the `date` property changes, mostly when initializing the element
    when used in a template, the `dateChanged` method is called by the binding system
    and the widget's selected date is updated. We additionally use an `isUpdating`
    property to prevent infinite update loops between the element and the widget.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: When the element is detached from the DOM, it first unsubscribes from the widget's
    `clearDate` and `changeDate` events, then calls its `destroy` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the element's `options` property changes, the widget is destroyed
    then recreated. This is because, at the time of writing, the `bootstrap-datepicker`
    plugin doesn't offer any API to update a widget's options after its creation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, this element manually handles data binding between Aurelia and
    the Bootstrap widget. The patterns you see here, registering event handlers on
    the widget, and synchronizing data back and forth, are pretty common when integrating
    an external UI library in Aurelia.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'A group in the Aurelia community is doing some pretty interesting work in this
    area. They develop what they call bridges, allowing us to use various UI frameworks
    in Aurelia applications. They have already released such a bridge for Kendo UI,
    and are working on bridges for Bootstrap and Materialize, among others. I suggest
    you take a look at their work if you''re interested in the subject: [https://github.com/aurelia-ui-toolkits](https://github.com/aurelia-ui-toolkits).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Using the element
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now easily replace the `input` bound to the contact''s birthday in the
    `form` component with our new `bs-datepicker` element:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/form.html`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we simply replace the previous `input` element with a `bs-datepicker`
    element. We bind the element's `date` property to the `birthday` property of `contact`,
    decorating the binding with the `validate` binding behavior so the property is
    still validated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our new element''s `date` property expects a `Date` object and not a
    string value, we need to change the `Contact` model class, so it parses its `birthday`
    property into a `Date` instance when created from a JS object. Additionally, we
    need to change the default value of `birthday` from an empty string to `null`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/models/contact.js`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the `birthday` property of `Contact` instances will be either `null` values
    or a `Date` object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you run the application, navigate to the creation or edition
    component, and give the focus to the birthday `input`, the date picker should
    show up. You should be able to navigate through the calendar and select a date.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to load the `bs-datepicker` element, either as a global resource
    in the `resources` feature's `configure` function, or in the `form` template using
    a `require` statement.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Internationalizing the bs-datepicker element
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, our `bs-datepicker` element doesn't support internationalization.
    In a typical real-world application, the format of the date displayed in the input,
    and the calendar's texts and properties, such as the first day of the week, should
    be localized.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the `bootstrap-datepicker` contains localization data as additional
    JS modules. We simply need to include the modules for the locales we need in the
    bundles.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Reconfiguring bundling of jQuery and Bootstrap
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'However, at the time of writing, the localized modules don''t support module-loading
    mechanisms, but rely exclusively on the jQuery object being on the global scope.
    As such, we need to change the way we use jQuery and the Bootstrap widgets by
    loading them not as AMD modules but as global libraries, using the vendor bundle''s
    `prepend` property:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we add jQuery, the Bootstrap widgets, the `bootstrap-datepicker` plugin,
    and its French localization module to the prepended libraries of the bundle (the
    English localization data being built into the plugin itself, so we don't need
    to include it). This means that those libraries will simply be merged at the beginning
    of the bundle, without being loaded as AMD modules, but using the global `window`
    scope. Of course, this means the entries for jQuery, Bootstrap, and the date-picker
    plugin must be removed from the `dependencies` array.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the prepended libraries can only be JS files, this also means we must
    change the way we load the Bootstrap stylesheet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, the `require` statements for `bootstrap.css` and `bootstrap-datepicker3.standalone.css`
    must be respectively removed from the `src/app.html` and the `src/resources/elements/bs-datepicker.html`
    templates.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `import` statements for `bootstrap` and `bootstrap-datepicker`
    must be removed from the `bs-tooltip.js` and the `bs-datepicker.js` files, since
    jQuery, Bootstrap, and the date-picker plugin will be accessed from the global
    scope.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Updating the element
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To localize the date-picker widget, we simply need to set the `language` option:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/form.html`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This means we need to add this `locale` property to the view-model of `form`.
    We also need to subscribe to the proper event, so we can update the property when
    the current locale changes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/form.js`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we start by importing the `I18N` class from the `aurelia-i18n` library
    and the `EventAggregator` class from `aurelia-event-aggregator`. We then hint
    to the DIC that they should both be injected into the view-model's constructor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: When the component is data-bound, we initialize the `locale` property using
    the `I18N` instance's `getLocale` method, and we subscribe to the `i18n:locale:changed`
    event, so we can keep the `locale` property up-to-date.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the component is unbound, we dispose of the event subscription.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you run the application and play around with the birthday
    date picker while toggling the current locale back and forth between French and
    English, the date format displayed in the `input`, and the calendar's texts and
    setup should update accordingly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery UI widgets
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jQuery UI widget library is still pretty popular. Integrating those widgets
    in an Aurelia application is pretty similar to what we just did with Bootstrap
    widgets, although not as painless, as we'll see in the following section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a `tooltip` attribute using jQuery UI, so we can compare it with
    Bootstrap's.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippets are excerpts from the `chapter-11/samples/using-jqueryui`
    sample in the book's assets.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Installing the libraries
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first need to install both jQuery and jQuery UI by opening a console in
    the project directory and running the following commands:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we need to add those libraries to the vendor bundle. The simplest way
    to do this is to put them in the `prepend` section:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since CSS files cannot be globally loaded into the `prepend` section, let''s
    load them into the `index.html` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, we can now create our attribute.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Creating a jq-tooltip attribute
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At first, our new attribute will be pretty similar to the one using Bootstrap:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/attributes/jq-tooltip.js`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We start by defining the `options` that the jQuery UI `tooltip` widget supports,
    so the attribute can use dynamic options and ignore those that are not supported
    in this; the `jq-tooltip` attribute behaves exactly like the `bs-tooltip` attribute
    we created in the previous section. Next, we hint to the DI container that the
    DOM element hosting the attribute should be injected into the constructor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: When the attribute is attached to the DOM, it retrieves the value bound to the
    attribute instance for each supported property to build an `options` object. This
    object is then passed to the `tooltip` initialization method, which is applied
    to the element hosting the attribute.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: When the attribute is detached from the DOM, the widget's `destroy` method is
    called on the element hosting the attribute.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the attribute doesn''t support property changes. Since jQuery''s
    `tooltip` widget offers an API to update options, this implementation won''t have
    to destroy and recreate the widget to update a property like the `bs-tooltip`
    attribute did:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/attributes/jq-tooltip.js`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we simply add the `propertyChanged` callback method, which updates the
    widget instance if the attribute is attached to the DOM and the updated property
    is supported by the widget.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our attribute is ready, let''s replace the **Remove** button''s `title`
    attribute for a `jq-tooltip` custom attribute in the `list-editor` component:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we simply put a `jq-tooltip` attribute on the proper `button` element.
    We bind its `content` property to the proper translation, which is decorated with
    the `t` binding behavior.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to load the `jq-tooltip` attribute, either as a global resource
    in the `resources` feature's `configure` function, or in the `list-editor` template
    using a `require` statement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: However, if you run the application and hover over the **Remove** button of
    a `list-editor` element with your mouse, you'll see that the `tooltip` doesn't
    show up.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This is caused by a long-known limitation; some in the community would say it's
    a bug (and I would agree) in the `tooltip` widget, which forces the hosting element
    to have a `title` attribute, even if it is not used.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, let''s update the attribute and add a method to create an empty `title`
    attribute if none exists on the hosting element:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/attributes/jq-tooltip.js`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now you can run the application and the `tooltip` should show up properly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Using SASS instead of CSS
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SASS**, which stands for Syntactically Awesome Stylesheets, is the most mature,
    stable, and powerful professional-grade CSS extension language in the world according
    to their website. Whether this claim is true or not, it is one of the most popular,
    and I can at least say that I use it a lot.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Using SASS instead of CSS in an Aurelia application is pretty simple, at least
    for CLI-based projects. The CLI already offers support for many CSS processors,
    such as SASS, LESS, and Stylus.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recreate our contact-management application using the CLI and, in the
    creation process, enable the SASS processor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SASS instead of CSS](img/image_00_001.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: You can select the default values for all the other questions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project has been created and the dependencies have been fetched, we
    can move the following directories and files from our working copy of the application
    to the newly created project:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/environments`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locales`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.html`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to copy the `dependencies` from the `package.json` file, and run
    another `npm install` in order to fetch all application dependencies. Finally,
    we need to copy the vendor-bundle configuration from the `aurelia_project/aurelia.json`
    file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: You can take a look at the `chapter-11/samples/using-sass` sample from the book's
    assets as a reference.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Replacing CSS with SASS
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s transform the CSS files in the application into SASS files, by replacing
    the `.css` extension with the `.scss` extension:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.scss`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the build tasks created by the CLI now include a SASS processor, every
    `.scss` file in the `src` directory will be transformed into a `.css` file with
    the same path, and will be included in the `app-bundle` under that path.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `resources/elements/list-editor.scss` file will be transformed
    into CSS, and the result will be bundled as `resources/elements/list-editor.css`
    in the `app-bundle`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the `require` statements must keep referring to stylesheets
    using the `.css` extension:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the application at this point, everything should be styled as before.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Dragging and dropping with sortable
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sortable ([https://github.com/RubaXa/Sortable](https://github.com/RubaXa/Sortable))
    is a well-known library for drag and drop. Its simple yet powerful API makes its
    integration very easy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Let's use it in our contact-management application to allow users to reorder
    the items for `list-editor` elements using drag and drop.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Installing the library
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to install the library by opening a console in the project directory
    and running the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to add it to the vendor bundle:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At this point, we can start using the library in our application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Adding drag and drop to list-editor
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first add a handle to list items. This handle will be the area where
    the users will be able to drag items up and down the list. Additionally, we need
    to add a `div` element, which will act as the container for the sortable items:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.html`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we start by assigning a reference on the `div` element containing the
    list items to the view-model's `container` property. This `container` will be
    required by the `sortable` API to enable drag and drop on its children. Next,
    we remove the `col-sm-offset-1` CSS class from the label column, and we add a
    sized-1 column, using Bootstrap's `col-sm-1` CSS class containing a `bars` Font
    Awesome icon and acting as a `sort-handle`, using the CSS class of the same name.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a CSS rule to change the drag handle''s mouse cursor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.css`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now use `sortable` to add drag and drop support:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`src/resources/elements/list-editor.js`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we start by importing the `sortable` API. Then, when the element is attached
    to the DOM, we create a `sortable` instance on the `container` items that have
    the `le-item` CSS class. We specify to `sortable` that the item's child element
    that has the `sort-handle` CSS class should be used as the drag handle. Finally,
    when an item is dropped at a different position in the list, the `onUpdate` callback
    is triggered, in which we remove the dropped item from its previous position in
    the `items` array and then insert it back at its new position.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: We need to use `splice` to remove then add the moved items, because Aurelia
    is unable to observe the array's index setter. It can only react to an array's
    changes by overriding the methods of `Array.prototype`, such as `splice`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we need to remove the `animated` CSS class from the items before
    moving them, so the CSS rules triggering the animations won't be matched. We then
    add it back using `setTimeout`, so it is only added once the templating engine
    is done removing the old view and adding the new one. This way, the animations
    that play when removing or adding items won't play when dragging and dropping
    items, which would look weird.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the `list-editor` is detached from the DOM, we call the `destroy`
    method on the `sortable` instance, in order to prevent memory leaks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can run the application, reorder the items for one of a contact's
    list properties, and save the form. In the details view, the items should appear
    in the new order in which you put them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Drawing graphs with D3
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Presenting data as a graph is yet another common need in modern applications.
    When it comes to the Web, **D3.js** is a well-known library that offers a very
    powerful API to display data in the DOM.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll add a tree view to our contact-management application,
    which will display the contacts grouped by address parts. Taking all the addresses
    for all contacts, the first level of nodes will be the countries, then each country
    will have its states as children, then each its cities, and so on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tree view we will build in this section is only a simple, poor example of
    what can be achieved with D3\. Go to [https://d3js.org/](https://d3js.org/) and
    browse through the hundreds of samples to see for yourself the power of this library.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Installing the library
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first install the library by opening a console in the project directory
    and running the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As usual, we need to add it to the vendor bundle:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At this point, D3 is ready to be used.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Prepping the application
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before creating the tree itself, let's start by prepping the application around
    it. We'll add a `route` component that will load the contacts using the gateway,
    inside which we'll display the tree. We'll also add a `route` for this component
    in the contacts `main`, then add links allowing navigation back and forth between
    the list and the tree.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `route`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/main.js`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we simply add a `route` named `contacts-by-address` matching the `by-address`
    path and leading to the `by-address` component, which we'll create in a minute.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add to the list component a link leading to the yet-nonexistent
    tree component:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/list.html`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You probably noticed that the `title` property of the new `route` and the text
    of the new link both use new translations, the addition of which I leave as an
    exercise for the reader. As always, this chapter's sample application can be used
    as a reference.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll create the `by-address` component. In order to keep things as
    decoupled as possible, we'll isolate the D3-related code in a custom element named
    `contact-address-tree`. The `by-address` component's sole responsibility will
    be to connect this custom element with the rest of the application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the view-model:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/by-address.js`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This view-model is pretty straightforward. When activated, it uses the injected
    gateway to retrieve the full list of contacts. It also exposes a method that triggers
    navigation to a given contact's details component. This method will be called
    when clicking on a contact node in the tree.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The template is pretty simple, as you can imagine:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/by-address.html`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This template simply declares a `contact-address-tree` element, binding the
    loaded `contacts`, and calling `navigateToDetails` when a contact node is clicked.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSS file simply sets the size of the `contact-address-tree` element:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/by-address.css`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating the contact-address-tree custom element
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that everything is ready to use our new element, let's create it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we're adding more contact-specialized custom elements, I suggest we create
    a new `elements` directory in the `contacts` feature, move the contact `form`
    to it, and create those new elements in it. This chapter's completed application
    sample can be used as a reference.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by laying out some CSS rules, which will style various tree parts,
    such as branch nodes, leaf nodes, and links:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/elements/address-tree.css`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since the rendering of the tree view will be handled by the D3 API, the custom
    element doesn''t need a template. As such, it will be declared with the `noView`
    decorator, to which the path to the CSS file will be passed, so it is loaded as
    a resource:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/elements/address-tree.js`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Additionally, the view-model's constructor will be injected into the DOM element
    itself, so the D3 API can use it as a viewport to render the tree. It also exposes
    a `contacts` and a `click` bindable property.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'This is for the Aurelia part. Now, let''s add an `attached` method, which will
    render the tree inside the element. The code inside this method will be completely
    ignorant of Aurelia, and will simply work with the `d3` API and the DOM `element`
    itself:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/elements/address-tree.js`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code is a simplified adaptation of Mike Bostock's sample, found at [https://bl.ocks.org/mbostock/4339083](https://bl.ocks.org/mbostock/4339083).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: It is way beyond the scope of this book to explain in detail how the `d3` API
    works. However, the inline comments in the previous code snippet can give you
    a good idea of how it works.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Chances are that you noticed some missing pieces: the `createAddressTree` and
    the `onNodeClicked` methods don''t exist yet.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The latter is pretty simple:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/elements/address-tree.js`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method simply makes sure that the clicked node is a contact node, and that
    the `click` property was properly bound before calling it with the clicked `contact`
    object. This will execute the expression bound using the `.call` command to the
    `click` property, passing to it the node's contact as a `contact` argument.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The former is a little more complicated. Its job is to transform a list of
    contacts into a tree data structure that will act as the data source for the `d3`
    API:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/elements/address-tree.js`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the `createAddressTree` method starts by creating a root node with an
    empty list of `children`. It then loops over every contact's `addresses` and,
    for each of them, creates a path of nodes for the address, starting from the country
    and drilling down to the street number. Nodes for the whole path or for a part
    of it that already exists are not created again but simply retrieved. Finally,
    a leaf node for the contact itself is appended to the last node in the path, which
    is the one for the street number.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you run the application and go to the address tree view, you
    should see the contacts show up, laid out in a tree.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Using Polymer components
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Polymer** is a popular library, which is heavily biased towards web components.
    Its community offers a wide range of components, among them a `google-map` element that
    encapsulates the Google Maps API in order to display a map declaratively in HTML.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia offers an integration library named `aurelia-polymer`, which allows
    the use of Polymer components inside an Aurelia application. In the following
    section, we'll integrate it into our contact-management application. In the details
    component, we'll display a small map showing the contact's address.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Installing the libraries
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymer and its libraries are typically installed using **Bower**. Bower and
    NPM can be used side by side without any problem, so let''s first install it,
    if you don''t already have it on your development environment, by opening a console
    and running the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Bower is yet another package manager for web libraries, which can be found at
    [https://bower.io/](https://bower.io/).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, let''s create Bower''s project file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`bower.json`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This file is pretty similar to `package.json`. It describes the project's dependencies
    managed by Bower. Here, we include Polymer and the Google Maps components.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: We also include `webcomponentjs`, which is a polyfill for various web components'
    APIs, such as the Custom Elements API and the HTML Imports API. Since those two
    APIs are required by Polymer, this polyfill is required if the browsers you target
    don't support those natively.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can check if your favorite browser supports the required APIs here: [http://caniuse.com/#feat=custom-elementsv1](http://caniuse.com/#feat=custom-elementsv1)
    and [http://caniuse.com/#feat=imports](http://caniuse.com/#feat=imports).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like NPM, the packages listed in the project file must be installed. As
    such, open a console in the project directory and run the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once this is done, the last thing we need to install is the bridge between
    Polymer and Aurelia, which is done by opening a console in the project directory
    and running the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Configuring the application
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that everything is installed, we need to configure our application so it
    can load Polymer components.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the `aurelia-polymer` library to the vendor bundle:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Of course, with this library being an Aurelia plugin, we need to load it into
    our application''s main `configure` function:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main.js`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As mentioned earlier, Polymer relies on HTML Imports. At the time of writing,
    CLI-based Aurelia applications don''t support using HTML Imports to load views.
    As such, we won''t be able to load components in the templates that need them.
    We have no choice but to load them in the `index.html` file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we first load the Web Components API polyfill. This line can be removed
    if you don't need the polyfill. Next, we import Polymer and the `google-map` components.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'In a production-ready application, importing Polymer and each component separately
    is sub-optimal. It is strongly suggested to vulcanize the components into a single
    bundle, which can be loaded in the `index.html` file: [https://github.com/Polymer/vulcanize](https://github.com/Polymer/vulcanize).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: At this point, integration with Polymer is up and running. The `google-map`
    element is ready to be used.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a Google map
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by making sure everything works by creating a custom element that
    we''ll use to display a map with a single address pinned on it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/elements/address-map.html`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `google-map` Polymer component loads the Google Maps API behind the scenes.
    In order for it to load correctly, you'll need a Google Maps API key. You can
    create one by following the instructions found at [https://developers.google.com/maps/documentation/javascript/get-api-key#key](https://developers.google.com/maps/documentation/javascript/get-api-key#key).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Here, we first add a button that toggles the value of the `isMapVisible` property.
    Next, we add a `google-map` Polymer element. Its `api-key` attribute should be
    set to your own Google Maps API key.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the view-model, it will be almost empty for now:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/elements/address-map.js`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we need to add this `address-map` element to the contact''s `details`
    component:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/components/details.html`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, if you run the application and navigate to a contact's details,
    you should see a button beneath every address. If you click on it, a map should
    show up.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Geocoding addresses
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to display the address as a marker on the map, we need to get the
    geographical coordinates of the address. As such, we''ll create a new service
    named `Geocoder`, which will use **Nominatim**, a search service based on `OpenStreetMap`
    data ([http://www.openstreetmap.org/](http://www.openstreetmap.org/)), to find
    the latitude and longitude of a given address:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/services/geocoder.js`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This class starts by creating an `HttpClient` instance, using Nominatim's URL
    and the standard configuration. It then exposes a `search` method, which expects
    an `Address` object as a parameter to send a request to the Nominatim endpoint
    and return the resulting `Promise`. This `Promise` is either resolved with `null`
    if the address is not found, or with an object containing the matching position's
    `latitude` and `longitude`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a marker
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can geocode the address, let''s update our `address-map` element
    to display a marker for it:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contacts/elements/address-map.js`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we start by injecting a `Geocoder` instance into the view-model. We also
    add a bindable `address` property. When the element is attached to the DOM, we
    geocode the address, and if its coordinates are found, we set the value of the
    `latitude` and `longitude` properties. We also set `isGeocoded` to `true`. This
    flag is initially set to `false`, and will be used to disable the toggle button
    if the address can't be localized. If the address can't be found, we hide the
    map, disable the toggle button, and reset `latitude` and `longitude` to `null`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将一个`Geocoder`实例注入到视图模型中。我们还添加了一个可绑定的`address`属性。当元素附加到DOM时，我们进行地理编码，如果找到其坐标，我们设置`latitude`和`longitude`属性的值。我们还设置`isGeocoded`为`true`。这个标志最初设置为`false`，如果地址无法定位，我们将用来禁用切换按钮。如果找不到地址，我们隐藏地图，禁用切换按钮，并将`latitude`和`longitude`重置为`null`。
- en: We also geocode each time the `address` changes after the element has been attached
    to the DOM, to keep the `latitude` and `longitude` properties up-to-date.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在元素附加到DOM之后，每次`address`发生变化时，我们还进行地理编码，以保持`latitude`和`longitude`属性的最新。
- en: 'As for the template, we don''t need to change much:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 至于模板，我们不需要做太多更改：
- en: '`src/contacts/elements/address-map.html`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/contacts/elements/address-map.html`'
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we start by disabling the toggle button when `isGeocoded` is `false`.
    Next, we bind the `google-map` element's `latitude` and `longitude`, and set its
    `zoom` to `15` so it is centered on the address's location.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先在`isGeocoded`为`false`时禁用切换按钮。接下来，我们将`google-map`元素的`latitude`和`longitude`进行绑定，并将它的`zoom`设置为`15`，以便它显示在地址位置的中心。
- en: Finally, we add a `google-map-marker` element inside the `google-map` element.
    We also bind this marker's `latitude` and `longitude`, and set its `open` property
    to `true` so its info window is opened upon rendering. Inside the marker, we display
    the full address as text, which will be rendered inside the info window.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`google-map`元素内部添加一个`google-map-marker`元素。我们还绑定这个标记的`latitude`和`longitude`，并将其`open`属性设置为`true`，以便在渲染时打开其信息窗口。在标记内部，我们显示完整的地址作为文本，它将在信息窗口内渲染。
- en: You may wonder where this `google-map-marker` element comes from. In fact, the
    HTML Imports mechanism allows the loading of multiple components from a single
    file. When we imported the `bower_components/google-map/google-map.html` file
    in `index.html`, many components were registered to Polymer, among which were
    the map and the marker.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇这个`google-map-marker`元素是从哪里来的。实际上，HTML Imports机制允许从单个文件中加载多个组件。当我们 在`index.html`中导入`bower_components/google-map/google-map.html`文件时，许多组件被注册到Polymer中，其中就包括地图和标记。
- en: If you run the application at this point, navigate to a contact's details, and
    click on an address's **View map** button, a map should show up with a marker
    at the proper location and an info window displaying the full address.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候运行应用程序，导航到联系人的详细信息，然后点击地址的**查看地图**按钮，应该会出现一个带有标记在正确位置的地图，并且一个信息窗口会显示完整的地址。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'The integration of a UI library into an Aurelia application almost always follows
    the same process: you create a custom element or attribute around it. By leveraging
    Aurelia''s two-way data binding, it is not too complicated most of the time.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个UI库集成到Aurelia应用程序中几乎总是遵循相同的流程：你围绕它创建一个自定义元素或属性。利用Aurelia的双向数据绑定，大多数时候并不太复杂。
- en: This is particularly true for libraries that follow good practices and community
    standards such as supporting common module loaders, exposing data-change events,
    and having a destructor in its public API. Libraries that are older, or that do
    not follow those standards, can be more painful to integrate. Aurelia, for its
    part, makes it as easy as it can.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于遵循良好实践和社区标准库来说尤其如此，比如支持常见模块加载器、暴露数据变更事件，并在其公共API中有一个析构器。那些较老，或者不遵循这些标准的库，集成就更痛苦。Aurelia在这方面尽其所能简化。
