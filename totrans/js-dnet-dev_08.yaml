- en: Chapter 8. Node.js for ASP.NET Developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 Node.js对ASP.NET开发者的意义
- en: JavaScript has become one of the most prevalent languages that not only runs
    on the client side, but also runs on the server side as well. Node.js empowers
    JavaScript to run on the server side and provide non-blocking I/O, an event driven
    model that makes it more lightweight, scalable and efficient. Today, it is more
    widely used in performing real-time operations, developing business applications,
    database operations, and more. JavaScript on Node.js can relate to ASP.NET that
    runs on IIS or any other web server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经成为一种不仅运行在客户端，也运行在服务器端的流行语言之一。**Node.js** 使JavaScript能够运行在服务器端，并提供非阻塞I/O、一个事件驱动的模型，这使得它更加轻量级、可伸缩和高效。如今，它在执行实时操作、开发业务应用程序、数据库操作等方面得到了更广泛的应用。**Node.js**
    上的JavaScript可以与运行在IIS上的ASP.NET或其他网络服务器相关联。
- en: Introduction to Node.js
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**Node.js** 简介'
- en: Node.js is a powerful platform to build server-side applications using JavaScript.
    Node.js itself is not written in JavaScript but provides a runtime environment
    to run JavaScript code. It allows JavaScript code that runs on the server side,
    providing the runtime built on the Google V8 JavaScript engine, which is an open
    source JavaScript engine written in C++, and used by Google Chrome, to compile
    JavaScript code into machine code, at the time of executing through the V8 JIT
    compiler.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js** 是一个使用JavaScript构建服务器端应用程序的强大平台。**Node.js** 本身不是用JavaScript编写的，但它提供了一个运行JavaScript代码的运行时环境。它允许在服务器端运行JavaScript代码，提供基于Google
    V8 JavaScript引擎的运行时，这是一个用C++编写的开源JavaScript引擎，由Google Chrome使用，用于在V8即时编译器执行时将JavaScript代码编译成机器代码。'
- en: Node.js works on a single thread; unlike other server-side technologies that
    create a separate thread for each request, Node.js uses the event callback system
    that processes the request using a single thread. If multiple requests arrive
    they have to wait until the thread becomes available and then acquire it. In the
    case of errors, Node.js does not throw an error and this is an essential technique
    to avoid error bubbling and the abortion of the single thread. If any error arises
    while serving a request, Node.js sends the error log, in the callback parameters,
    in the response itself. This allows the main thread to propagate the error and
    delay the response. Node.js is good for writing network applications. It consists
    of HTTP requests, other network communications tasks, and real-time client/server
    communications using web sockets.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js** 工作在单线程上；与其他创建每个请求单独线程的服务器端技术不同，**Node.js** 使用事件回调系统，通过单线程处理请求。如果多个请求同时到达，它们必须等待线程可用，然后才能获取它。在错误情况下，**Node.js**
    不会抛出错误，这是避免错误冒泡和单线程中断的一个基本技术。如果在处理请求时出现任何错误，**Node.js** 会在响应本身中发送错误日志，通过回调参数。这使得主线程能够传播错误并延迟响应。**Node.js**
    适合编写网络应用程序。它包括HTTP请求、其他网络通信任务，以及使用Web Sockets进行实时客户端/服务器通信。'
- en: Request processing by the Node.js web server
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Node.js** 网络服务器请求处理'
- en: The Node.js web server maintains a limited thread pool to handle client requests.
    When the request gets to the server, the Node.js web server places that request
    into an event queue. The request is then picked up by the event loop component
    that works in an infinite loop and processes the request when it is free. This
    event loop component is single-threaded, and if the request involves I/O blocking
    operations such as filesystem access, database access, or others, it checks the
    availability of the thread in the internal thread pool and assigns the request
    to the available thread. Otherwise, it processes the request and sends the response
    back to the client in a single go. When the I/O blocking request is completed
    by the internal thread, it sends the response back to the event loop first, which
    sends the response back to the client.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js** 网络服务器维护一个有限的线程池来处理客户端请求。当请求到达服务器时，**Node.js** 网络服务器把这个请求放入一个事件队列中。然后事件循环组件——它在一个无限循环中工作——在空闲时处理这个请求。这个事件循环组件是单线程的，如果请求涉及到如文件系统访问、数据库访问等的I/O阻塞操作，它会检查内部线程池中的线程可用性，并将请求分配给可用线程。否则，它会一次性处理请求并将响应发送回客户端。当内部线程完成了I/O阻塞请求，它会首先将响应发送回事件循环，然后事件循环再将响应发送回客户端。'
- en: Comparison of Node.js with .NET
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Node.js** 与.NET的比较'
- en: 'Both ASP.NET and Node.js are server-side technologies. The following diagram
    shows the comparison of Node.js with .NET:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASP.NET** 和**Node.js** 都是服务器端技术。下面的图表展示了**Node.js** 与.NET的比较：'
- en: '![Comparison of Node.js with .NET](img/00082.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js 与 .NET 比较](img/00082.jpeg)'
- en: NPM
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NPM
- en: '**Node Package Manager** (**NPM**) is the Node.js package manager used to install
    Node modules. Node.js provides a way to write modules in JavaScript, and with
    NPM we can add and reuse those modules in other applications. With ASP.NET Core,
    we already use some modules, such as Gulp and Grunt for minifying the CSS and
    JavaScript files, and doing copying and merging operations. The `package.json`
    file is the configuration file that holds the metadata information about the application
    and Node modules used in our project. Here is the sample screenshot of the `package.json`
    file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node 包管理器**（**NPM**）是用于安装 Node 模块的 Node.js 包管理器。Node.js 提供了一种编写 JavaScript
    模块的方法，借助 NPM，我们可以在其他应用程序中添加和使用这些模块。在使用 ASP.NET Core 时，我们已经在使用一些模块，例如使用 Gulp 和
    Grunt 压缩 CSS 和 JavaScript 文件，以及执行复制和合并操作。`package.json` 文件是包含有关应用程序和项目中使用的 Node
    模块的元数据信息的配置文件。以下是 `package.json` 文件的示例截图：'
- en: '![NPM](img/00083.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![NPM](img/00083.jpeg)'
- en: 'Dependencies can be installed by executing the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行以下命令来安装依赖项：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`--save` is used to update the `package.json` dependencies section and add
    the packages downloaded.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save` 用于更新 `package.json` 的依赖项部分并添加下载的包。'
- en: Installing Node.js
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Node.js
- en: 'Visual Studio provides great support for developing programs using Node.js.
    To configure the Node.js development environment on the Windows platform, download
    and install Node.js from [http://nodejs.org](http://nodejs.org). There are various
    installers available as per the platform, as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 为使用 Node.js 开发程序提供了强大的支持。要在 Windows 平台上配置 Node.js 开发环境，请从 [http://nodejs.org](http://nodejs.org)
    下载并安装 Node.js。根据平台不同，可用的安装程序各不相同，如下面的截图所示：
- en: '![Installing Node.js](img/00084.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Node.js](img/00084.jpeg)'
- en: 'For Windows, we will download the 64-bit Windows installer that downloads the
    `.msi` package and take you through some simple wizard screens. You will notice
    that the Node.js installer contains a runtime to run node programs and NPM to
    reference other Node modules in your program. This can be seen in the following
    screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，我们将下载 64位的 Windows 安装程序，该程序下载`.msi`包并通过一些简单的向导屏幕引导您。您会注意到 Node.js
    安装程序包含一个运行 Node 程序的运行时和 NPM，以便在您的程序中引用其他 Node 模块。以下截图展示了这一点：
- en: '![Installing Node.js](img/00085.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Node.js](img/00085.jpeg)'
- en: 'Commands such as `npm` and `node` are already added in the environment path
    and we can execute these commands directly from the command prompt. Therefore,
    if we open the command prompt and write `node`, it will give you the Node prompt,
    which allows you to write JavaScript code on the fly and execute, as shown in
    the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 和 `node` 这样的命令已经添加到了环境路径中，我们可以直接从命令提示符执行这些命令。因此，如果我们打开命令提示符并输入 `node`，它将给出
    Node 提示符，允许你即兴编写 JavaScript 代码并执行，如下面的截图所示：'
- en: '![Installing Node.js](img/00086.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Node.js](img/00086.jpeg)'
- en: Alternatively, we can also run the `.js` file by calling `node javascriptfile.js`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们还可以通过调用`node javascriptfile.js`来运行`.js`文件。
- en: 'The following is the sample `example1.js` file that sums the numbers defined
    in an array:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为`example1.js`的示例文件，该文件用于计算数组中定义的数字之和：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![Installing Node.js](img/00087.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Node.js](img/00087.jpeg)'
- en: Using Node.js with Visual Studio 2015
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 与 Visual Studio 2015
- en: There are many **Integrated Development Environments** (**IDEs**) available
    in the market that have Node.js tooling support. IDEs such as Visual Studio Code,
    Sublime, Komodo and Node Eclipse are popular IDEs to work with Node.js, but in
    practice, most .NET developers are more comfortable and familiar working with
    the Visual Studio IDE. Therefore, we will be using the Visual Studio 2015 Community
    edition in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有很多支持 Node.js 工具的集成开发环境（IDE）。像 Visual Studio Code、Sublime、Komodo 和 Node Eclipse
    这样的 IDE 都是流行的 Node.js 工作环境，但实际上，大多数 .NET 开发人员更习惯并熟悉使用 Visual Studio IDE。因此，在本章中，我们将使用
    Visual Studio 2015 社区版。
- en: 'Node.js templates can be installed in Visual Studio 2015 by installing its
    extensions. Extensions can be installed from the Visual Studio menu option **Tools**
    | **Extensions and Updates**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 Visual Studio 2015 中通过安装其扩展来安装 Node.js 模板。可以从 Visual Studio 菜单选项 **工具**
    | **扩展和更新** 中安装扩展：
- en: '![Using Node.js with Visual Studio 2015](img/00088.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Node.js 与 Visual Studio 2015](img/00088.jpeg)'
- en: 'This extension of Node.js is installed with various templates to start developing
    applications using Node.js. There is a template to develop console applications
    using the blank Node.js console application template, a web application using
    Node.js express templates, and so on:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Node.js扩展安装了各种模板，用于开始使用Node.js开发应用程序。有一个模板是使用空白Node.js控制台应用程序模板开发控制台应用程序，有一个使用Node.js
    express模板开发web应用程序等等：
- en: '![Using Node.js with Visual Studio 2015](img/00089.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用Node.js和Visual Studio 2015](img/00089.jpeg)'
- en: The basic advantage of using these templates is to save time in configuring
    things manually, and these templates facilitate developers by providing the basic
    project structure to kick-start the Node.js application right away.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模板的基本优势是节省手动配置事物的时间，这些模板通过提供基本的项目结构来帮助开发者立即启动Node.js应用程序。
- en: 'Let''s start by creating a basic console application template. The basic console
    application has an `npm` folder, containing node packages, `package.json` that
    contains the metadata information and other configuration attributes, and `app.js`,
    which contains actual JavaScript code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个基本的控制台应用程序模板。基本的控制台应用程序有一个`npm`文件夹，包含node包，`package.json`包含元数据信息和其他配置属性，还有`app.js`，其中包含实际的JavaScript代码：
- en: '![Using Node.js with Visual Studio 2015](img/00090.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![使用Node.js和Visual Studio 2015](img/00090.jpeg)'
- en: 'This extension for Node.js provides a handy feature for adding Node modules
    by simply right-clicking on the `npm` folder and selecting the **Install New npm
    Packages** option, as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Node.js扩展提供了一个方便的功能，通过在`npm`文件夹上右键点击并选择**安装新的npm包**选项，即可添加Node模块，如下面的屏幕截图所示：
- en: '![Using Node.js with Visual Studio 2015](img/00091.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![使用Node.js和Visual Studio 2015](img/00091.jpeg)'
- en: 'On selecting this option, Visual Studio opens up the window that helps to search
    any node package and add it to your application with a few clicks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个选项后，Visual Studio会打开一个窗口，帮助搜索任何node包，并几点击添加到你的应用程序中：
- en: '![Using Node.js with Visual Studio 2015](img/00092.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用Node.js和Visual Studio 2015](img/00092.jpeg)'
- en: The preceding diagram shows the versions of `Gulp` packages that can be added
    through this option.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表展示了可以通过这个选项添加的`Gulp`包的版本。
- en: '**Interactive Window** is another nice feature in Visual Studio, which opens
    up the command prompt integrated in the Visual Studio tab, and you can write JavaScript
    code and execute commands instantly, as shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**交互式窗口**是Visual Studio中的另一个好功能，它打开了一个集成在Visual Studio标签中的命令提示符，你可以立即编写JavaScript代码并执行命令，如下面的屏幕截图所示：'
- en: '![Using Node.js with Visual Studio 2015](img/00093.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![使用Node.js和Visual Studio 2015](img/00093.jpeg)'
- en: 'There are several other benefits of using Visual Studio: you can use the Git
    or TFS version repositories, debug your code and enable breakpoints on your JavaScript
    files, and so on. The Visual Studio-specific project file for Node.js is known
    as `.njsproj` and resides in the root folder of your project.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio还有其他几个好处：你可以使用Git或TFS版本库，在JavaScript文件上调试你的代码并设置断点等等。针对Node.js的Visual
    Studio特定项目文件称为`.njsproj`，位于你项目的主文件夹中。
- en: Simple console application using Node.js
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Node.js的简单控制台应用程序
- en: 'A Node.js application consists of one or more JavaScript files that provide
    specific functionality to the application. Writing thousands of lines of code
    in one JavaScript file is not practically possible, and also increases maintainability
    issues. In Node.js, we can create multiple JavaScript files and use them through
    `require` and `export` objects, which are parts of the Common JS module system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Node.js应用程序由一个或多个提供特定功能的JavaScript文件组成。在一个JavaScript文件中写入成千上万行代码在实际中是不可能的，而且也会增加可维护性问题。在Node.js中，我们可以创建多个JavaScript文件，并通过`require`和`export`对象使用它们，这些对象是Common
    JS模块系统的组成部分：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively we can also call `require` without specifying the `.js` file
    extension, and it automatically loads the file that exists on a particular path.
    If the path corresponds to a folder, all the JavaScript files will be loaded:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们也可以调用`require`而不指定`.js`文件扩展名，它会自动加载特定路径上存在的文件。如果该路径对应于一个文件夹，所有JavaScript文件都将被加载：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The main entry point when the application is bootstrapped is defined under
    `package.json`. In the following screenshot, `app.js` is the main entry point
    file that is loaded first and executed by Node.js:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，定义在`package.json`中的是主要入口点。在下面的屏幕截图中，`app.js`是主入口文件，首先被Node.js加载并执行：
- en: '![Simple console application using Node.js](img/00094.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![使用Node.js的简单控制台应用程序](img/00094.jpeg)'
- en: Let's implement a basic example that has two files, namely `app.js` (main entry)
    and `cars.js`, and returns a few properties of the `car` object, such as `name`,
    `model`, and `engine`. To start, create a console application project and add
    one `cars.js` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个基本示例，有两个文件，分别是`app.js`（主入口）和`cars.js`，并返回`car`对象的几个属性，例如`name`、`model`和`engine`。首先，创建一个控制台应用程序项目并添加一个`cars.js`文件。
- en: 'Here is the code for `cars.js`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`cars.js`的代码：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Through `module.exports`, we can export any object. Whether it''s a variable,
    a function, or a JSON object, it can be exported through this. Furthermore, the
    objects exported can be used through the `require` object in `app.js`, as shown
    in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`module.exports`，我们可以导出任何对象。无论是变量、函数还是JSON对象，都可以通过这个方法导出。此外，导出的对象可以通过`app.js`中的`require`对象使用，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Simple console application using Node.js](img/00095.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用Node.js的简单控制台应用程序](img/00095.jpeg)'
- en: The preceding code displays the JSON output as defined in the `cars.js` file.
    In order to initialize the `cars` object, and loop through the car items defined
    in the list, we need to export it as a function and define it through the `this`
    keyword. Specifying it through `this` will make the list accessible from the cars
    object we create in the `app.js` file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了`cars.js`文件中定义的JSON输出。为了初始化`cars`对象，并遍历列表中定义的汽车项目，我们需要将其作为函数导出，并通过`this`关键字定义它。通过`this`指定它将使列表从我们在`app.js`文件中创建的`cars`对象中访问。
- en: 'Here is the modified version of `cars.js`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`cars.js`的修改版本：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And here is the modified version of the `app.js` file that initialized the
    `cars` object and loops through the list:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是初始化`cars`对象并遍历列表的`app.js`文件的修改版本：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Web applications with Node.js
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Node.js的Web应用程序
- en: There are various Node.js web frameworks available. Frameworks such as Express
    and Hapi.js are powerful frameworks and have different architectures and designs.
    In this section, we will use the Express framework, which is one of the most widely
    used web frameworks for Node.js, for both web and mobile applications, and also
    provides the application framework model to develop web **Application Programming
    Interfaces** (**APIs**).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种Node.js Web框架可供选择。像Express和Hapi.js这样的框架是强大的框架，具有不同的架构和设计。在本节中，我们将使用Express框架，这是Node.js中最广泛使用的Web框架之一，用于Web和移动应用程序，并提供应用程序框架模型以开发Web
    **Application Programming Interfaces**（**APIs**）。
- en: Creating blank Node.js applications
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建空白Node.js应用程序
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the Express framework for web applications in Node.js
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Node.js中使用Express框架的Web应用程序
- en: In any programming language, a framework has an important benefit that minimizes
    the effort required to develop web applications. The framework plays the important
    role of processing requests, such as loading a specific view, injecting models
    into a view, and more. As with ASP.NET, where w have two web-application frameworks,
    ASP.NET Web Forms and ASP.NET MVC, Node.js provides Express EJS, Jade, and many
    other web application frameworks to build robust web applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，框架的一个重要好处是减少开发Web应用程序所需的努力。框架扮演着处理请求的重要角色，例如加载特定的视图、将模型注入视图等。与ASP.NET一样，我们有两种Web应用程序框架，ASP.NET
    Web Forms和ASP.NET MVC，Node.js提供Express EJS、Jade以及许多其他Web应用程序框架来构建健壮的Web应用程序。
- en: Extend simple Node.js to use Express
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将简单的Node.js扩展以使用Express
- en: With the Node.js extension for Visual Studio, you can get all the templates
    to start working with the Express 3.0 and Express 4.0 application frameworks.
    Express 4.0 is the most recent version and has some new features and improvements.
    We can use the template that bootstraps most of the configuration-level stuff
    for you but, in order to get more clarity, we will extend the simple Node.js example
    created previously, and use the Express framework to develop a simple web application
    on top of it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js的Visual Studio扩展，你可以获得所有模板来开始使用Express 3.0和Express 4.0应用程序框架。Express
    4.0是最新的版本，有一些新功能和改进。我们可以使用引导大多数配置级别工作的模板，但为了获得更多清晰度，我们将扩展前面创建的简单Node.js示例，并使用Express框架在其上开发一个简单的Web应用程序。
- en: 'To use `Express`, we have to add its package dependency using NPM, as shown
    in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Express`，我们必须使用NPM添加其包依赖，如下面的截图所示：
- en: '![Extend simple Node.js to use Express](img/00098.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![将简单的Node.js扩展以使用Express](img/00098.jpeg)'
- en: 'Once you add the Express package, you can add the following code snippet to
    kick start the Express app:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了Express包，您可以添加以下代码片段来启动Express应用程序：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a simple `Hello World` example that returns the HTML content. Now, in
    scenarios where we want to return a specific view instead of the static HTML content,
    we achieve this by using Express view engines, which will be discussed next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`Hello World`示例，返回HTML内容。现在，在我们要返回特定视图而不是静态HTML内容的情况下，我们可以通过使用Express视图引擎来实现，接下来将讨论这一点。
- en: Express view engines
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express视图引擎
- en: Express has various view engines, although Jade and EJS are the most widely
    used. We will go through these one by one and see what the differences are.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Express拥有多种视图引擎，尽管Jade和EJS是最广泛使用的。我们将逐一了解这些差异是什么。
- en: EJS view engine
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EJS视图引擎
- en: 'In the EJS view engine, views are HTML pages and the model properties can be
    bound using scriptlets: `<% %>`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在EJS视图引擎中，视图是HTML页面，模型属性可以使用脚本片段`<% %>`绑定。
- en: 'To start using EJS, we need to add the EJS package through the NPM package
    manager option in Visual Studio, or by executing the `npm install ejs –save` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用EJS，我们需要通过Visual Studio中的NPM包管理器选项添加EJS包，或者通过执行`npm install ejs –save`命令来添加：
- en: '![EJS view engine](img/00099.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![EJS视图引擎](img/00099.jpeg)'
- en: 'Once this is added, we can set the view engine to `ejs`, as shown in the following
    code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此代码后，我们可以将视图引擎设置为`ejs`，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Set the path of the `ejs` view by calling the response object `render()` method,
    as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用响应对象的`render()`方法设置`ejs`视图的路径，如下所示：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the `index.ejs` file inside the `home` folder. All the views should reside
    under the root `Views` folder, otherwise they won''t be loaded when the application
    is run. Therefore, the `ejsviews` folder should be defined under the `Views` folder
    and `home` inside the `ejsviews` folder, as shown in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home`文件夹中添加`index.ejs`文件。所有视图都应该存放在根`Views`文件夹下，否则当应用程序运行时它们不会被加载。因此，应该在`Views`文件夹下定义`ejsviews`文件夹，在`ejsviews`文件夹下定义`home`，如下面的屏幕截图所示：
- en: '![EJS view engine](img/00100.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![EJS视图引擎](img/00100.jpeg)'
- en: 'The following is the content of the EJS view that will be rendered when the
    application starts:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在应用程序启动时将被渲染的EJS视图的内容：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the code at the bottom of the `ejsserver.js` file that creates the server
    which listens for requests on port number `1337`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ejsserver.js`文件的底部添加创建服务器并监听端口号`1337`的代码：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the application runs, `index.ejs` will be loaded and will render the HTML
    content as shown in the following figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，`index.ejs`将被加载并渲染以下所示的HTML内容：
- en: '![EJS view engine](img/00101.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![EJS视图引擎](img/00101.jpeg)'
- en: 'We can also pass the model in the representation of the JSON object. Suppose
    we need to pass the application name and description; we can pass these values
    when calling a `render()` method of the response object, as shown in the following
    code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过JSON对象的形式传递模型。假设我们需要传递应用程序名称和描述；我们可以在调用响应对象的`render()`方法时传递这些值，如下所示：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `index.ejs`, we can use and bind these values with HTML controls using scriptlets:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.ejs`中，我们可以使用脚本片段将这些值与HTML控件绑定：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: EJS also supports layout pages that contain the static content, such as the
    header and footer of the web application. So, a developer doesn't need to define
    the main layout content again and again on every page, and we can keep it centralized,
    just like we do in ASP.NET MVC using `_layout.cshtml` and `Site.master` in ASP.NET
    web forms.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: EJS还支持包含静态内容的布局页面，比如网页应用的头部和底部。因此，开发者不需要在每一页上都重新定义主要的布局内容，我们可以将其集中管理，就像我们在ASP.NET
    MVC中使用`_layout.cshtml`和ASP.NET web forms中的`Site.master`一样。
- en: 'To work with master pages, we need to add one more package, known as `ejs-local`.
    This package can be added using the NPM package manager window in Visual Studio,
    or by running the `npm` command as `npm install ejs-local --save`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用主页面，我们需要再添加一个包，称为`ejs-local`。此包可以通过Visual Studio中的NPM包管理器窗口添加，或者通过运行`npm
    install ejs-local --save`命令来添加：
- en: '![EJS view engine](img/00102.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![EJS视图引擎](img/00102.jpeg)'
- en: 'After adding this package, we can add `ejs-locals`, as shown in the following
    code. It has to be set before setting the view engine:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加此包后，我们可以添加`ejs-locals`，如下所示。必须在设置视图引擎之前设置它：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the `layout.ejs` page in the same `ejsviews` folder and specify the HTML
    content:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个`ejsviews`文件夹中添加`layout.ejs`页面，并指定HTML内容：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following output is generated:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出生成：
- en: '![EJS view engine](img/00103.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![EJS 视图引擎](img/00103.jpeg)'
- en: Jade view engine
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Jade 视图引擎
- en: 'The Jade view engine is another Node.js view engine and the syntax is quite
    different, when defining views, than we have seen in EJS. To start with the Jade
    view engine, we need to install the Jade view engine node package using NPM. We
    can install this from the Visual Studio NPM package manager or by running the
    `npm install jade –save` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 视图引擎是另一个 Node.js 视图引擎，其语法与我们之前在 EJS 中看到的有很大不同。当我们定义视图时，需要先通过 NPM 安装 Jade
    视图引擎。我们可以在 Visual Studio 的 NPM 包管理器中安装，或者通过运行 `npm install jade –save` 命令：
- en: '![Jade view engine](img/00104.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Jade 视图引擎](img/00104.jpeg)'
- en: When you install it, it will add the Jade package in the `package.json` dependencies
    section. We will start by setting the Jade view engine in the `app.js` file (the
    main entry point to kick start the Node.js project).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，它将在 `package.json` 的依赖项部分添加 Jade 包。我们将从在 `app.js` 文件（Node.js 项目的入口点）中设置
    Jade 视图引擎开始。
- en: 'Here is the code to set up the Jade view engine in `app.js`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `app.js` 中设置 Jade 视图引擎的代码：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will notice that we have not specified the Jade reference through the `require`
    object. This is because when the Express framework is loaded, it will automatically
    register the dependencies of Jade. The following code snippet loads the Jade view:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们没有通过 `require` 对象指定 Jade 引用。这是因为当 Express 框架被加载时，它将自动注册 Jade 的依赖项。以下代码片段加载了
    Jade 视图：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Jade view syntax is typically different from HTML and all the view extensions
    should be `.jade`. In the preceding code, we are pointing to `index.jade`, where
    Jade is not required to be specified explicitly. `Index.jade` should reside under
    the `views/home` folder. Let''s create a folder called `views` and then the `home`
    folder inside it. Add a new Jade file and named it `index.jade`. Here is the code
    that displays the `appName` and `message` in HTML elements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 视图语法通常与 HTML 不同，所有视图扩展名都应该是 `.jade`。在前面的代码中，我们指向了 `index.jade`，其中不需要显式指定
    Jade。`Index.jade` 应该位于 `views/home` 文件夹下。让我们创建一个名为 `views` 的文件夹，然后在里面创建一个名为 `home`
    的文件夹。添加一个新的 Jade 文件并将其命名为 `index.jade`。以下代码显示了 `appName` 和 `message` 在 HTML 元素中：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With Jade syntax, you don't have to define the complete HTML tags, you simply
    specify it through their names, followed by the value assigned to them. For example,
    in the preceding example, we are setting the `appName` and `message` values passed
    as a JSON object to this view through the response `render()` method. However,
    there are many more attributes that HTML elements support, such as setting control
    width, font color, font style, and so on. In a later section, we will see how
    we can achieve this in Jade.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jade 语法，你不需要定义完整的 HTML 标签，你只需通过它们的名称指定，后面跟着分配给它们的值。例如，在前面的示例中，我们通过响应 `render()`
    方法传递的 JSON 对象设置了 `appName` 和 `message` 的值。然而，HTML 元素支持许多更多的属性，如设置控件宽度、字体颜色、字体样式等。在后面的章节中，我们将了解如何在
    Jade 中实现这一点。
- en: 'The equal to (`=`) operator is only required if you are binding to any value
    injecting in to the view. If you want to specify a hardcoded static value, then
    it can easily be set without using the equal to operator, as shown in the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 等于（`=`）操作符只有在您绑定到注入到视图中的任何值时才需要。如果您想要指定一个硬编码的静态值，那么可以很容易地不使用等于操作符来设置，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here are a few examples of using Jade syntax for HTML-specific scenarios:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用 Jade 语法处理 HTML 特定场景的示例：
- en: '| Attributes | Jade | HTML |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | Jade | HTML |'
- en: '| --- | --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Textbox |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 文本框 |'
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Anchor tag |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 锚点标签 |'
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Checkbox |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 复选框 |'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Anchor with style attributes |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 带样式属性的锚点 |'
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Link button |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 链接按钮 |'
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'You can learn more about the Jade language here: [http://jade-lang.com/](http://jade-lang.com/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://jade-lang.com/](http://jade-lang.com/) 了解更多关于 Jade 语言的信息。
- en: Jade's framework also supports layout pages. Layout pages hold the static information
    of the website, which is mostly placed in the header, footer, or side bars, and
    the content actually changes as per the page requested. In ASP.Net web forms,
    we define master pages with `<asp:ContentPlaceHolder>` tags, which render the
    content of the page reference to that master page. In ASP.NET MVC, this can be
    done using the Razor `@RenderBody` element. In Jade, we can define the content
    block using a `block` keyword followed by the name of the block. For example,
    the following is the `layout.jade` that contains the `block contentBlock` statement,
    where `block` represents where the content of the child page renders, and `contentBlock`
    is the name of the block that has to be defined in the child page. Multiple blocks
    can also be defined in a single view.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Jade的框架也支持布局页面。布局页面包含网站的静态信息，这些信息大部分位于页眉、页脚或侧边栏中，而实际内容根据请求的页面而变化。在ASP.Net Web表单中，我们使用`<asp:ContentPlaceHolder>`标签定义主页面，该页面将渲染页面的内容引用到该主页面。在ASP.NET
    MVC中，这可以通过使用Razor `@RenderBody`元素来实现。在Jade中，我们可以使用`block`关键字后跟块的名称来定义内容块。例如，以下是的`layout.jade`，其中包含`block
    contentBlock`声明，其中`block`表示子页面的内容渲染位置，`contentBlock`是要在子页面中定义的块的名称。在单个视图中也可以定义多个块。
- en: 'The following is the content of the layout page:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是布局页面的内容：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The layout page can be used with the `extends` keyword followed by the layout
    page name. The Jade view engine automatically searches the page with that name
    and if it''s found, searches for the block name and places the content there.
    Here is the child page `index.jade` that uses the layout page `layout.jade`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 布局页面可以使用`extends`关键字后跟布局页面名称与`layout`页面一起使用。Jade视图引擎会自动搜索具有该名称的页面，如果找到，则搜索块名称并在该位置放置内容。以下是使用布局页面`layout.jade`的子页面`index.jade`：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output will be as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将会如下所示：
- en: '![Jade view engine](img/00105.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![玉视引擎](img/00105.jpeg)'
- en: Routing in the Express application
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Express应用程序中的路由
- en: We have now learned the basics of the EJS and Jade view engines. Both offer
    similar features, but the syntax is different. In the previous examples, we sent
    a response that points to a specific page which renders the content on the client
    side.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了EJS和Jade视图引擎的基本知识。两者都提供类似的功能，但语法不同。在前面的示例中，我们发送了一个响应，指向一个特定的页面，在客户端渲染内容。
- en: The Express framework provides several methods that correspond to HTTP methods,
    such as `get`, `post`, `put`, `delete`, and so on. We can use the `get` method
    to retrieve something, `post` to create a record, `put` to update, and so on.
    Pages can reside anywhere within the `Views` folder, but the routing actually
    defines which page has to be loaded when the request is made on a specific URL
    path.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Express框架提供了与HTTP方法相对应的多个方法，如`get`、`post`、`put`、`delete`等。我们可以使用`get`方法来获取一些内容，`post`来创建一个记录，`put`来更新，等等。页面可以位于`Views`文件夹内的任何地方，但是路由实际上定义了当在特定的URL路径上请求时必须加载哪个页面。
- en: Let's create an EJS page inside the `Views/ejsviews/home` folder and name it
    `about.ejs`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Views/ejsviews/home`文件夹内创建一个名为`about.ejs`的EJS页面。
- en: 'Routing can be defined using the Express application object, as shown in the
    following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 路由可以通过Express应用程序对象来定义，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When the user browses to `http://localhost/About`, it shows the **About** page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户浏览到`http://localhost/About`时，会显示**关于**页面。
- en: Middleware
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: 'Node.js Express also provides a special routing method, `all()`, which is not
    mapped to any HTTP method. But it is used to load Middleware at a path, irrespective
    of the HTTP method being requested. For example, making HTTP `GET` and `POST`
    requests at `http://localhost/middlewareexample` will execute the same `all()`
    method shown in the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js Express还提供了一个特殊的路由方法`all()`，它没有映射到任何HTTP方法。但是，它用于在路径上加载中间件，而不管请求的HTTP方法是什么。例如，对`http://localhost/middlewareexample`进行HTTP
    `GET`和`POST`请求将会执行下面代码中显示的相同的`all()`方法：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Just like in .NET, we have OWIN middleware that can be chained in the request
    pipeline. In the same way, Node.js Express middleware can also be chained and
    can be invoked by calling the next middleware with a little change in the function
    signature. Here is the modified version that takes the `next` parameter after
    the response object which provides a handler to the next middleware in the pipeline,
    defined in a sequence for a particular request path:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 .NET 中一样，我们有 OWIN 中间件可以链接到请求管道。同样，Node.js Express 中间件也可以链接，并且可以通过稍微修改函数签名来调用下一个中间件。以下是修改后的版本，在响应对象之后添加了
    `next` 参数，为特定请求路径定义管道中的下一个中间件的处理器：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For example, suppose we have two middlewares and the first middleware just
    logs the information to the console window, whereas the second returns the HTML
    content back to the client. Here is the `server.js` file that contains the two
    middlewares in the EJS view engine:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有两个中间件，第一个中间件只是将信息输出到控制台窗口，而第二个中间件则将 HTML 内容返回给客户端。以下是包含这两个中间件的 EJS 视图引擎的
    `server.js` 文件：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now when we access the URL path `http://localhost/middlewareexample`, the message
    will be printed on the console and renders the HTML content in the browser:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们访问 URL 路径 `http://localhost/middlewareexample` 时，消息将在控制台打印，并在浏览器中呈现 HTML
    内容：
- en: '![Middleware](img/00106.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![中间件](img/00106.jpeg)'
- en: 'Here is the HTML content that will render in the browser:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将在浏览器中呈现的 HTML 内容：
- en: '![Middleware](img/00107.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![中间件](img/00107.jpeg)'
- en: MVC with the Express framework
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 与 Express 框架
- en: Almost every application consists of numerous pages, and defining all the logic
    and routing on the main `server.js` is not practical or maintainable. In this
    section, we will see how the **Model View Controller** (**MVC**) pattern can be
    implemented with the Express framework. We will develop a simple application to
    see how controllers and data services can be developed, and how the controller
    loads the view and injects the model using the Express framework.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都由无数页面组成，而在主 `server.js` 中定义所有逻辑和路由既不实际也不易维护。在本节中，我们将了解如何使用 Express
    框架实现 **模型-视图-控制器**（**MVC**）模式。我们将开发一个简单的应用程序，以了解如何创建控制器和数据服务，以及如何使用 Express 框架加载视图并注入模型。
- en: MVC pattern
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型-视图-控制器模式
- en: MVC is a software architectural pattern used to separate an application's concerns.
    The model represents the entity that contains properties to hold information,
    whereas the controller is used to inject the model into the view and load the
    view. The controller is also used to store the model in the database, whereas
    the view is the page that renders the model injected by the controller and uses
    it wherever needed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）是一种用于分离应用程序关注点的软件架构模式。模型表示包含属性以持有信息的实体，而控制器则用于将模型注入视图并加载视图。控制器还用于将模型存储在数据库中，而视图是呈现由控制器注入的模型的页面，并在需要时使用它。
- en: Creating a controller
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'We will start by creating a simple `homeController` to render a home page.
    Let''s extend the EJS view engine example developed above, and create a `Controllers`
    folder at the root of your project. Inside the `Controllers` folder, create a
    `HomeController.js` file and place the following code snippet there:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个简单的 `homeController` 开始，以渲染主页。让我们扩展上述开发的 EJS 视图引擎示例，并在项目的根目录下创建一个 `Controllers`
    文件夹。在 `Controllers` 文件夹内，创建一个 `HomeController.js` 文件，并将以下代码片段放在那里：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, there is an anonymous JavaScript function that takes
    the `module.export` object and binds it to the `homeController` when it is executed.
    The basic advantage of implementing it in this way is that every method or property
    defined with the `homeController` object will be exportable and accessible by
    the calling object. In the preceding example, we have defined a `load()` method
    that defines the routing at the root path (`/`) and returns the **Index** page
    to the client.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一个匿名 JavaScript 函数，它接受 `module.export` 对象，并在执行时将其绑定到 `homeController`。以这种方式实现的基本优点是，定义在
    `homeController` 对象中的每个方法或属性都将可导出并可供调用对象访问。在前面的示例中，我们定义了一个 `load()` 方法，它定义了根路径（`/`）的路由并返回
    **Index** 页面给客户端。
- en: 'In the main `ejsserver.js` file, we can use the controller by using the `require`
    object as shown in the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 `ejsserver.js` 文件中，我们可以使用控制器，如以下代码所示，通过使用 `require` 对象：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, we have added the `HomeController` object using the `require`
    object and called the `load()` method to define the routing that navigates to
    the index page when the website runs.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `require` 对象添加了 `HomeController` 对象，并调用 `load()` 方法来定义路由，使得当网站运行时能够导航到索引页面。
- en: Creating data services
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据服务
- en: 'Every business application involves lots of CRUD (create, read, update, and
    delete) operations. For a better design, these operations can be separately implemented
    in data service objects, so if multiple controllers wanted to use the same service,
    they can use them without writing the same code repeatedly. In this section, we
    will create a data service JavaScript file that reads the data and passes it in
    the routing function. To start with, let''s create a folder name `DataServices`
    at the root of the application and create `ProductService.js` inside it. Here
    is the code for `ProductService.js`, which returns the products array:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个商业应用程序都涉及大量的 CRUD（创建、读取、更新、删除）操作。为了更好的设计，这些操作可以分别实现在数据服务对象中，所以如果多个控制器想要使用同一个服务，它们可以重复使用而不需要重复编写相同的代码。在本节中，我们将创建一个名为
    `DataServices` 的文件夹，位于应用程序的根目录下，并在其中创建 `ProductService.js`。以下是 `ProductService.js`
    的代码，它返回产品数组：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can use this `ProductService` inside `HomeController` through the `require`
    object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `require` 对象在 `HomeController` 中使用这个 `ProductService`：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And here is the `index.ejs` file, which loops through the products and displays
    the product name and price:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `index.ejs` 文件，它遍历产品并显示产品名称和价格：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, the output looks like the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输出结果如下：
- en: '![Creating data services](img/00108.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据服务](img/00108.jpeg)'
- en: Accessing the Microsoft SQL server in Node.js
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Node.js 中访问 Microsoft SQL 服务器
- en: 'Node.js provides different database drivers that can be added as node packages.
    There are packages for the MongoDB driver, the Microsoft SQL Server driver, and
    more. We will use the MS SQL driver for Node.js to connect with Microsoft SQL
    server databases. To install `mssql` you can run the `npm install mssql –save`
    command, or add it from the NPM package manager window, as shown in the following
    screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 提供了不同的数据库驱动，可以作为 node 包添加。有 MongoDB 驱动、Microsoft SQL Server 驱动等等。我们将使用
    Node.js 的 MS SQL 驱动来连接 Microsoft SQL 服务器数据库。要安装 `mssql`，您可以运行 `npm install mssql
    –save` 命令，或者从 NPM 包管理器窗口中添加，如下面的截图所示：
- en: '![Accessing the Microsoft SQL server in Node.js](img/00109.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![在 Node.js 中访问 Microsoft SQL 服务器](img/00109.jpeg)'
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: With the MSSQL driver, TCP/IP should be enabled for a corresponding SQL server
    instance.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MSSQL 驱动时，对于相应的 SQL 服务器实例应启用 TCP/IP。
- en: Reading a record from the Microsoft SQL server database
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Microsoft SQL 服务器数据库中读取记录
- en: In the `DataService.js` file, we will add the `getProducts()` method, which
    loads the list of products from the SQL Server database.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DataService.js` 文件中，我们将添加 `getProducts()` 方法，它从 SQL Server 数据库加载产品列表。
- en: 'The following is the `getProducts()` method, which accepts the callback function,
    so as soon the products list is fetched from the database, it will be passed in
    the callback function on the caller side:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `getProducts()` 方法，它接受回调函数，所以一旦从数据库中获取了产品列表，它就会在调用者的回调函数中传递：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code, we initialized the `sql` object using the `require` object.
    The `Config` variable contains the connection attributes, such as `username`,
    `password`, `server`, and `database`. This is passed while calling the `sql connect()`
    method. The `Connect()` method returns a `then()`promise, through which we can
    initiate the SQL query request using the `sql.Request()` method. If the request
    is successful, we will get the result set in the `recordset` object that will
    be returned to the caller through its callback function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `require` 对象初始化了 `sql` 对象。`Config` 变量包含连接属性，如 `username`、`password`、`server`
    和 `database`。在调用 `sql connect()` 方法时传递这个属性。`Connect()` 方法返回一个 `then()` 承诺，通过它我们可以使用
    `sql.Request()` 方法发起 SQL 查询请求。如果请求成功，我们将在 `recordset` 对象中获取结果集，并通过其回调函数返回给调用者。
- en: 'Here is the modified version of `HomeController.js` that calls the `DataService`
    `getRecords()` method and passes the products list retrieved as a model to the
    index view:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改后的 `HomeController.js` 文件，它调用 `DataService` 的 `getRecords()` 方法，并将检索到的产品列表作为模型传递给索引视图：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the `index.js` file, which loops through the list of products
    and displays the product name and price:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `index.js` 文件，它遍历产品列表并显示产品名称和价格：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Creating a record in the Microsoft SQL server database
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Microsoft SQL服务器数据库中创建记录
- en: To create a record in the database, we can define the HTML input elements wrapped
    within the HTML form tag, and on submission of the form, we can make a post request
    by defining a `post` method in our `HomeController.js` file. When the form is
    submitted, the values can be retrieved using the `request.body` object. This is
    the parser that parses the DOM and makes a list of elements wrapped under the
    form tag. We can access it like `req.body.txtName`, where `txtName` is the HTML
    input element and `req` is the request object.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据库中创建记录，我们可以定义HTML表单标签内的HTML输入元素，并在表单提交时通过在`HomeController.js`文件中定义`post`方法来发送POST请求：当表单提交时，可以使用`request.body`对象检索值。这是一个解析器，它解析DOM并创建一个包含表单标签下的元素的列表。我们可以像`req.body.txtName`这样访问它，其中`txtName`是HTML输入元素，`req`是请求对象。
- en: 'Express 4.0 unbundled the `body-parser` object into a separate package and
    can be downloaded separately using the `npm install body-parser –save` command
    or through the NPM package manager window, as shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Express 4.0将`body-parser`对象解耦为一个单独的包，可以使用`npm install body-parser –save`命令单独下载，或者通过NPM包管理器窗口，如下面的屏幕截图所示：
- en: '![Creating a record in the Microsoft SQL server database](img/00110.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![在Microsoft SQL服务器数据库中创建记录](img/00110.jpeg)'
- en: 'In your main `ejsserver.js` file, add the `body-parser` using the `require`
    object and pass it in the `expressApp` object by calling the `expressApp,use()`
    method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的主`ejsserver.js`文件中，使用`require`对象添加`body-parser`，并通过调用`expressApp,use()`方法将其传递给`expressApp`对象：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once this is added, we can modify `HomeController.js` and define a `POST` method
    that will be called once the form is submitted:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了这些内容，我们就可以修改`HomeController.js`，并定义一个`POST`方法，一旦表单提交，该方法将被调用：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And finally, here is the `Index.ejs` view that contains a form with the `Name`,
    `Description`, and `Price` fields:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是包含`Name`、`Description`和`Price`字段的表单的`Index.ejs`视图：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To learn more about the `mssql` node package, please use this link: [https://www.npmjs.com/package/mssql](https://www.npmjs.com/package/mssql).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解关于`mssql`节点包的更多信息，请使用这个链接：[https://www.npmjs.com/package/mssql](https://www.npmjs.com/package/mssql)。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter focused on the basics of Node.js and how to use them in developing
    server-side applications using JavaScript. We have learned about two view engines,
    EJS and Jade, and how to use them. We have also learned the usage of controllers
    and services to implement an MVC pattern. And finally, we finished by looking
    at examples of accessing the Microsoft SQL server database to perform, create,
    and retrieve operations on a database. In the next chapter, we will focus on best
    practices for using JavaScript in large-scale applications.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Node.js的基础知识以及如何使用它们来开发使用JavaScript的服务器端应用程序。我们了解到了两种视图引擎，EJS和Jade，以及如何使用它们。我们还学习了如何使用控制器和服务来实现MVC模式。最后，我们通过查看访问Microsoft
    SQL服务器数据库的示例，来了解如何执行数据库上的增删改查操作。在下一章中，我们将关注在大型应用程序中使用JavaScript的最佳实践。
