- en: Chapter 7. Promises in Angular.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章  Angular.js中的承诺
- en: In the last chapter, we learned about Node.js and its implementations. We also
    saw how Node.js can be used to amplify the real-time web and how promises can
    be used to deliver more efficient apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，我们学习了Node.js及其实现。我们还看到了Node.js如何用来放大实时网络，以及如何使用承诺来提供更高效的app。
- en: In this chapter, we examine another side of promises implementation, promises
    in Angular.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了承诺实现的另一面，即在Angular.js中的承诺。
- en: As we go along, we will learn what is Angular.js, why it was created, what benefits
    it will give us, and lastly, how promises get implemented in Angular.js.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的学习深入，我们将了解什么是Angular.js，它为什么被创建，它能给我们带来哪些好处，最后，我们将学习如何在Angular.js中实现承诺（promises）。
- en: Let's get started with the introduction of Angular.js and how to set it up.
    Some sample code and working examples will be provided. We will then move to promises
    in Angular.js.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Angular.js的介绍和设置开始。将提供一些示例代码和运行示例。然后我们将转到Angular.js中的承诺。
- en: The evolution of Angular.js
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular.js的演变
- en: Since the birth of single-page web applications, there have been a number of
    ways one can write code for such apps. The usage of single-page web apps has been
    increasing rapidly due to the fact that they are faster, platform independent,
    and lightweight for all types of devices and auto-adjust to all screen sizes.
    This is the main reason why engineers want to develop single-page web apps and
    are more interested in using libraries and frameworks that ease their routine
    work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 自从单页网络应用程序诞生以来，人们已经找到了编写此类应用程序代码的许多方法。单页网络应用程序的使用之所以迅速增加，是因为它们更快、平台无关、轻便，适用于所有类型的设备，并能自动调整到所有屏幕尺寸。这是工程师希望开发单页网络应用程序，并且更愿意使用简化日常工作的库和框架的主要原因。
- en: The inception of Angular.js was on the same concept. The core of Angular.js
    is that it employs the declarative programming concept that states user interfaces
    should be used to connect software services, while we can use imperative programming
    to define business logic.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Angular.js的创建是基于相同的概念。Angular.js的核心是采用声明式编程概念，指出用户界面应用来连接软件服务，而我们可以使用命令式编程来定义业务逻辑。
- en: Angular.js's framework extends classical HTML (HTML5) to couple the content
    together. It uses a two-way data binding technique that is helpful in the automatic
    synchronization of both model and views. With all these features, Angular.js is
    independent of DOM, which helps in increased performance and security standards
    of coupled modules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Angular.js的框架扩展了经典的HTML（HTML5），以将内容紧密结合。它使用了一种双向数据绑定技术，有助于自动同步模型和视图。有了这些特性，Angular.js与DOM无关，这有助于提高性能和耦合模块的安全标准。
- en: The most notable nonfunctional property of Angular.js is the brain that maintains
    it—Google.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Angular.js最显著的非功能性属性是其维护者——谷歌的大脑。
- en: Google is the force behind the development, maintaining, and releasing of different
    versions of Angular.js.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌是Angular.js开发、维护和发布不同版本背后的力量。
- en: Angular.js was first released in the year 2009 with the aim of providing client-side
    **MVC** (**model view controller**) implementation that can ease both development
    and testing of applications. Also, it provides a toolset embedded for creating
    rich Internet applications and tools for modern real-time web applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Angular.js最初于2009年发布，旨在提供客户端**MVC**（模型-视图-控制器）实现，以简化应用程序的开发和测试。此外，它还提供了一个工具集，用于创建富互联网应用程序和现代实时网络应用程序的工具。
- en: '![The evolution of Angular.js](img/5500OS_07_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Angular.js的演变](img/5500OS_07_01.jpg)'
- en: The structure of the Angular.js document
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular.js文档的结构
- en: Angular.js uses the HTML file at the base document for its implementation. Its
    syntax is very simple and easy to remember. The structure of the page is a simple
    HTML file with `ng` at its start. This is called the Angular.js directive and
    it can be used with HTML or can be linked as a individual document.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular.js使用基础文档的HTML文件进行实现。其语法非常简单且容易记忆。页面的结构是一个带有`ng`的简单HTML文件。这被称为Angular.js指令，它可以与HTML一起使用，也可以作为独立的文档链接。
- en: 'To start using Angular.js, you need to add a few lines and it will be up and
    running. For using Angular.js, perform the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Angular.js，你需要添加几行代码，它就可以运行起来。要使用Angular.js，请执行以下步骤：
- en: 'Add the `ng` directive; you only need to add this simple code to start using
    the Angular.js:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ng`指令；你只需要添加这段简单的代码就可以开始使用Angular.js：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the library to the file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中添加库：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, define the variable within the HTML tag like this:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在HTML标签内定义变量，如下所示：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, you can use it by calling out the variable:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以通过调用变量来使用它：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Getting started with Angular.js
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习Angular.js
- en: 'To download Angular.js, go to [https://angularjs.org/](https://angularjs.org/)
    and hit the **Download** button. The following dialog box will appear:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想要下载Angular.js，请前往[https://angularjs.org/](https://angularjs.org/)并点击**下载**按钮。以下对话框将出现：
- en: '![Getting started with Angular.js](img/5500OS_07_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![开始学习Angular.js](img/5500OS_07_02.jpg)'
- en: Select the stable and minified build and click on **Download**. This file is
    a compact one with all the whitespaces removed so that it loads faster. You need
    to save this file to your working directory as you will need it in the following
    sections of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 选择稳定和压缩构建，然后点击**下载**。这个文件是紧凑的，去除了所有的空白，以便更快地加载。你需要将这个文件保存到你的工作目录中，因为你将在本章的后续部分需要它。
- en: Creating your first Angular.js file
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个Angular.js文件
- en: We will use the downloaded file to include it in our HTML. From there, it will
    show its magic on how Angular.js is a two-way banded framework and show the results
    in real time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用下载的文件将其包含在我们的HTML中。从那里，它将展示Angular.js是一个双向绑定的框架，并实时显示结果。
- en: Step 1 – create the HTML 5 doc
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步 - 创建HTML 5文档
- en: 'Create a file like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个这样的文件：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Step 2 – add the JavaScript file to it
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二步 - 向其中添加JavaScript文件
- en: 'Create a JavaScript file with the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的JavaScript文件：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the Angular.js directive in the preceding code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中添加Angular.js指令：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it; you now have a working Angular.js file for further use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；你现在有一个可以进一步使用的工作Angular.js文件了。
- en: How to use Angular.js on your local machine
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在你本地机器上使用Angular.js
- en: There are several ways you can sample Angular.js on your local machine. One
    way is to use your locally installed server. The XAMPP or Node.js server can be
    the best option to use for executing the Angular.js code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种方法可以在你的本地机器上体验Angular.js。一种方法是使用你本地下载的服务器。XAMPP或Node.js服务器可以是你执行Angular.js代码的最佳选择。
- en: You can download the XAMPP server from [https://www.apachefriends.org/download.html](https://www.apachefriends.org/download.html)
    and install it over your PC. Once you are done with installation, you can just
    drop your Angular.js files/folders in the `htdocs` folder and access these files
    by simply visiting `http://localhost/source/`, where `source` should be the folder
    name inside `htdocs`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://www.apachefriends.org/download.html](https://www.apachefriends.org/download.html)下载XAMPP服务器并在你的PC上安装它。安装完成后，你只需将你的Angular.js文件/文件夹拖放到`htdocs`文件夹中，并通过简单地访问`http://localhost/source/`来访问这些文件，其中`source`应该是`htdocs`内的文件夹名称。
- en: 'Using Node.js, simply paste the following code to a text file and save it as
    `app.js`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js，只需将以下代码粘贴到文本文件中并将其保存为`app.js`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save this file to any folder on your drive. Now, open Command Prompt by typing
    `cmd` in the **Run** utility of your Windows machine and go to the folder where
    `app.js` is located.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存到您驱动器上的任何文件夹中。现在，通过在Windows机器的**运行**实用程序中键入`cmd`来打开命令提示符，并转到包含`app.js`文件的文件夹。
- en: 'Once you reach there, please type in the following lines and hit **Enter**:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你到达那里，请输入以下行并按**Enter**：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see the response on screen like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到屏幕上的响应如下：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once you get this response, your server is ready to use. Drop your Angular.js
    files in the same folder where the `app.js` file is located and access it using
    a browser like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到这个响应，你的服务器就可以使用了。将你的Angular.js文件放在`app.js`文件所在的同一文件夹中，并使用浏览器访问它，如下所示：
- en: '`http://127.0.0.1:1337/source/`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:1337/source/`'
- en: Here, `source` is the folder where `app.js` is located.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`source`是包含`app.js`文件的文件夹。
- en: What would be your preference for the server?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你对服务器有什么偏好？
- en: You can use any of these servers as they both are open source and both have
    great adoptability for the Angular.js. It's completely up to you which one you
    can use. To make things more understandable for you, I chose Node.js as it's very
    handy and easy to maintain with more performance output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用其中任何一个服务器，因为它们都是开源的，并且都具有对Angular.js很好的适应性。选择哪一个完全取决于你。为了让你更容易理解，我选择了Node.js，因为它非常方便且易于维护，并且性能输出更高。
- en: Key elements of Angular.js
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular.js的关键元素
- en: Before we get into how promises are implemented in Angular.js, we will first
    look at the key elements of Angular.js and how they work for us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解Angular.js中如何实现承诺之前，我们将首先查看Angular.js的关键元素以及它们是如何为我们工作的。
- en: Within this section, you will learn the key elements of Angular.js. The skills
    acquired will be used in the forthcoming sections of this chapter. You will then
    be able to apply the concepts of promises in Angular.js and write your own custom-made
    promises in Angular.js as per your need.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习Angular.js的关键元素。所获得的技能将在本章后续部分中使用。您将能够根据需要将Angular.js中的承诺概念应用于Angular.js并编写自己的自定义承诺。
- en: 'The most common elements we will discuss are:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最常见元素是：
- en: Supplying scope data
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供作用域数据
- en: Filtering output
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤输出
- en: Controlling scopes
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制作用域
- en: Routing views
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由视图
- en: Supplying scope data
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供作用域数据
- en: 'We will play around with the frontend HTML, CSS, and JavaScript to display
    the results in the browser. We will also get bootstrap from [http://getbootstrap.com/getting-started/#download](http://getbootstrap.com/getting-started/#download)
    to give cosmetic touches in the code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对前端HTML、CSS和JavaScript进行操作，以在浏览器中显示结果。我们还将从[http://getbootstrap.com/getting-started/#download](http://getbootstrap.com/getting-started/#download)获取bootstrap，以在代码中进行美容修饰：
- en: The folder structure must be as defined in the following image. To demonstrate
    how code works, we will be using the Node.js server. The folder name public needs
    to deploy at the folder where `app.js` is located. Once the server has started,
    navigate to `http://127.0.0.1:3000` and you will see the app running there.![Supplying
    scope data](img/5500OS_07_03.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件结构必须如以下图片中所定义。为了展示代码如何工作，我们将使用Node.js服务器。名为public的文件夹需要部署在`app.js`所在的文件夹中。一旦服务器启动，导航到`http://127.0.0.1:3000`，您将在那里看到运行的应用程序。![提供作用域数据](img/5500OS_07_03.jpg)
- en: We will create an app for available services at a subway station. Let's call
    this station Stratford from where we will be looking at which subway service is
    available.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为地铁站的可用服务创建一个应用程序。让我们称这个站为Stratford，从这里我们将查看哪个地铁服务可用。
- en: 'Create a file in the `js/controller` folder and name it `app.js`. Here is how
    this file will look like:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/controller`文件夹中创建一个名为`app.js`的文件。这个文件将看起来像这样：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, at the root of the public folder create an HTML file, name it as `index.html`,
    and add the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在public文件夹的根目录下创建一个HTML文件，命名为`index.html`，并添加以下代码：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, when you hit refresh at the browser, it will show you which services are
    away from Stratford station. However, how can this be made possible?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在浏览器中刷新时，它会显示离开Stratford车站的服务。然而，这是如何实现的呢？
- en: At the top of the HTML doc, there is an `ng` directive that will create the
    Angular.js app, and then we can include the JavaScript files; one from Angular.js's
    minified file and the other is our created JavaScript file that supplies scope
    to let HTML display it. This all happened due to one variable declaration, `$scope`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文档的顶部，有一个`ng`指令将创建Angular.js应用程序，然后我们可以包含JavaScript文件；一个是Angular.js的压缩文件，另一个是我们创建的JavaScript文件，它提供作用域以便HTML显示它。这一切都是由于一个变量声明`$scope`。
- en: '`$scope` is responsible for binding data and providing output within the supplied
    scope. This helps Angular.js to maintain its uniqueness to perform the computation
    in an isolated or defined area of influence, that''s all!'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`$scope`负责在提供的范围内绑定数据并提供输出。这有助于Angular.js在其独特的范围内执行计算，这就是全部！'
- en: Filtering data
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据过滤
- en: Sometimes, we need to have a specific format of data to display data from our
    app. Within Angular.js, it's as easy as simply supplying some operators to the
    element where we want to filter it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要以特定格式显示应用程序中的数据。在Angular.js中，这就像简单地为我们要过滤的元素提供一些操作符一样简单。
- en: 'The operator used for this purpose is the pipe, `|`. As soon as we add a pipe
    sign, Angular.js knows that we want to filter out something. Let''s take a look
    at two of the most important filters of all:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的的操作符是管道符号，`|`。一旦我们添加了一个管道符号，Angular.js就知道我们想要过滤掉一些东西。让我们看看两个最重要的过滤器：
- en: 'To convert text in to uppercase at the page output, consider the following
    code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在页面输出中将文本转换为大写，请考虑以下代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The most helpful feature of filtering out data is to get an entire object as
    JSON. This will not only help in the debugging mode, but it's also used to validate
    the supplied data to see if the format is correct.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤数据的最有帮助的功能是获取整个对象作为JSON。这不仅有助于调试模式，而且还用于验证提供的数据以查看格式是否正确。
- en: 'Consider the following code which will not only filter out data as a JSON object,
    but also validate it before displaying the output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它不仅会过滤出作为JSON对象的数据，而且在显示输出之前还会验证它：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will return the entire JavaScript object as JSON. You can now validate
    data or get into the debugging mode by getting your hands dirty, digging the JavaScript
    code and adding `alert()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回整个JavaScript对象作为JSON。现在，您可以通过获取您的手脏，挖掘JavaScript代码并添加`alert()`，来验证数据或进入调试模式。
- en: Controlling scopes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制作用域
- en: 'We can also supply an entire function to a particular stream instead of a single
    variable; this will help us interlink the different parts of any app without much
    hassle. Consider the following JavaScript code which is displaying how we are
    supplying an entire function to a particular stream:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向特定流提供一个完整的函数，而不是一个单一的变量；这将帮助我们无需太多麻烦地在任何应用程序的不同部分之间进行互联。考虑以下JavaScript代码，它显示了我们如何向特定流提供一个完整的函数：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the last three lines, we added a function that will be fully passed on to
    the calling `ng` directive at the HTML output. The code of HTML will look like
    this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后三行中，我们添加了一个函数，它将被完全传递给HTML输出中的调用`ng`指令。HTML代码看起来像这样：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that we are writing very neat code with very few updates. We can achieve
    many changes as desired in the last lines before the `body` tag is completed;
    you will notice how we have passed an entire function using Angular.js.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们写的代码非常整洁，更新非常少。我们可以在`body`标签完成之前的最后几行实现许多所需的更改；您将注意到我们是如何通过Angular.js传递一个完整的函数的。
- en: Routing views
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由视图
- en: Conventional websites were made up of many pages linked together via an `href`
    tag. Their content was hard to read and required more maintenance than ever. With
    the emergence of single page web apps, the information appeared on the browser
    instantly as the views can be routed from one link to another without hitting
    the server repeatedly, or without having to wait for the page to load.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的网站由许多通过`href`标签链接在一起的页面组成。他们的内容很难阅读，并且比以往任何时候都需要更多的维护。随着单页Web应用程序的出现，信息立即出现在浏览器中，因为视图可以通过从一个链接路由到另一个链接，而不需要重复访问服务器，或不需要等待页面加载。
- en: '![Routing views](img/5500OS_07_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![路由视图](img/5500OS_07_04.jpg)'
- en: 'From our examples, we will add another file as a module and place it under
    the root of the JS folder. The code will look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的示例中，我们将添加另一个文件作为一个模块，并将其放在JS文件夹的根目录下。代码看起来像这样：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will generate views dynamically on the fly at the browser without hitting
    the server. We need a couple of more files to add more dynamicity. We will add
    the partials folder in which we placed two more files named `services` and `destination`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在不经过服务器的情况下，在浏览器中动态生成视图。我们需要添加更多的文件以增加动态性。我们将添加一个名为`partials`的文件夹，在该文件夹中我们放置了两个名为`services`和`destination`的文件。
- en: 'The `destination.html` file will look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`destination.html`文件将看起来像这样：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `services.html` file will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`services.html`文件将看起来像这样：'
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After editing the `index.html` file at the root of the public folder, the view
    will look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在根目录下的public文件夹中编辑`index.html`文件后，视图将看起来像这样：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implementing promises in Angular.js
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular.js中实现承诺。
- en: Promise is all about how async behavior can be applied on a certain part of
    an application or on the whole. There is a list of many other JavaScript libraries
    where the concept of promises exists but in Angular.js, it's present in a much
    more efficient way than any other client-side applications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的全部内容在于如何将异步行为应用于应用程序的某一部分或整个应用程序。有许多其他的JavaScript库也存在承诺的概念，但在Angular.js中，它比其他任何客户端应用程序都要高效。
- en: Promises comes in two flavors in Angular.js, one is `$q` and the other is Q.
    What is the difference between them? We will explore it in detail in the following
    sections. For now, we will look at what promise means to Angular.js.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular.js中，承诺有两种口味，一个是`$q`，另一个是Q。它们之间有什么区别？我们将在接下来的部分详细探讨。现在，我们将看看对Angular.js来说承诺意味着什么。
- en: There are many possible ways to implement promises in Angular.js. The most common
    one is to use the `$q` parameter, which is inspired by Chris Kowal's Q library.
    Mainly, Angular.js uses this to provide asynchronous methods' implementations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular.js中实现承诺有多种可能的方式。最常见的是使用`$q`参数，这是受Chris Kowal的Q库启发的。主要的是，Angular.js使用这个来提供异步方法的实现。
- en: With Angular.js, the sequence of services is top to bottom starting with `$q`,
    which is considered as the top class; within it, many other subclasses are embedded,
    for example, `$q.reject()` or `$q.resolve()`. Everything that is related to promises
    in Angular.js must follow the `$q` parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular.js中，服务的顺序是从上到下，从`$q`开始，它被认为是最高层；在其中，还嵌入了许多其他子类，例如`$q.reject()`或`$q.resolve()`。与Angular.js中的一切承诺相关的都必须遵循`$q`参数。
- en: Starting with the `$q.when()` method, it seems like it creates a method immediately
    rather it only normalizes the value that may or may not create the promise object.
    The usage of `$q.when()` is based on the value supplied to it. If the value provided
    is a promise, `$q.when()` will do its job and if it's not, a promise value, `$q.when()`
    will create it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从`$q.when()`方法开始，它看起来像是立即创建一个方法，但实际上它只是规范化了一个可能或不创建承诺对象的值。`$q.when()`的用法基于传递给它的值。如果传递的值是一个承诺，`$q.when()`会执行它的任务；如果它不是一个承诺值，`$q.when()`会创建它。
- en: The schematics of using promises in Angular.js
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular.js中使用承诺的架构
- en: 'Since Chris Kowal''s Q library is the global provider and inspiration of promises
    callback returns, Angular.js also uses it for its promise implementations. Many
    of Angular.js services are by nature promise oriented in return type by default.
    This includes `$interval`, `$http`, and `$timeout`. However, there is a proper
    mechanism of using promises in Angular.js. Look at the following code and see
    how promises maps itself within Angular.js:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Chris Kowal的Q库是全局承诺回调返回的提供者和灵感来源，Angular.js也使用它来实现承诺。Angular.js中的许多服务默认返回类型都是面向承诺的。这包括`$interval`、`$http`和`$timeout`。然而，Angular.js中有个适当的承诺使用机制。看看下面的代码，了解承诺如何在Angular.js中自我映射：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All of the mentioned services in Angular.js return a single object of promise.
    They might be different in taking parameters in, but in return all of them respond
    back in a single promise object with multiple keys. For example, `$http.get` returns
    a single object when you supply four parameters named `data`, `status`, `header`,
    and `config`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular.js中提到的所有服务都返回一个承诺对象。它们在接收参数方面可能有所不同，但它们都以带有多个键的单个承诺对象作为回应。例如，当你提供四个名为`data`、`status`、`header`和`config`的参数时，`$http.get`返回一个单一对象。
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we employ the promises concept here, the same code will be rewritten as:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里使用承诺的概念，相同的代码将被重写为：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code is more concise and easier to maintain than the one before
    this, which makes the usage of Angular.js more adaptable to the engineers using
    it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码比这之前的代码更简洁，也更容易维护，这使得使用Angular.js的工程师更容易适应。
- en: Promise as a handle for callback
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将回调作为承诺的处理方式
- en: 'The implementation of promise in Angular.js defines your use of promise as
    a callback handle. The implementations not only define how to use promise for
    Angular.js, but also what steps one should take to make the services as "promise-return".
    This states that you do something asynchronously, and once your said job is completed,
    you have to trigger the `then()` service to either conclude your task or to pass
    it to another `then()` method: `/asynchronous _task.then().then().done()`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular.js中实现承诺定义了您对承诺作为回调处理的使用。实现不仅定义了如何在Angular.js中使用承诺，还定义了应采取哪些步骤使服务成为“承诺返回”。这表明您异步地执行某事，一旦您的任务完成，您必须触发`then()`服务，要么结束您的任务，要么将其传递给另一个`then()`方法：`/异步_任务.then().then().done()`。
- en: 'In simpler form, you can do this to achieve the concept of promise as a handle
    for call backs:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单地说，您可以这样做来实现承诺作为回调的处理方式：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Blindly passing arguments and nested promises
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盲目传递参数和嵌套承诺
- en: Whatever service of promise you use, you must be very sure of what you are passing
    and how this can affect the overall working of your promise function. Blindly
    passing arguments can cause confusion for the controller as it has to deal with
    its own results too while handling other requests. Say we are dealing with the
    `$http.get` service and you blindly pass too much of load to it. Since it has
    to deal with its own results too in parallel, it might get confused, which may
    result in callback hell. However, if you want to post-process the result instead,
    you have to deal with an additional parameter called `$http.error`. In this way,
    the controller doesn't have to deal with its own result, and calls such as 404
    and redirects will be saved.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪个承诺服务，你都必须非常确定你传递了什么，以及这如何影响你的承诺函数的整体工作。盲目传递参数可能会导致控制器混淆，因为它必须处理自己的结果同时处理其他请求。比如说我们正在处理`$http.get`服务，你盲目地给它传递了太多的负载。由于它必须在并行中处理自己的结果，可能会导致混淆，从而可能引发回调地狱。然而，如果你想要后处理结果，你必须处理一个额外的参数，称为`$http.error`。这样，控制器就不用处理自己的结果，像404和重定向这样的调用将被保存。
- en: 'You can also redo the preceding scenario by building your own promise and bringing
    back the result of your choice with the payload that you want with the following
    code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过构建自己的承诺并使用以下代码返回你选择的结果和你想要的有效负载来重现前面的场景：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By building a custom promise, you have many advents. You can control inputs
    and output calls, log the error messages, transform the inputs into desired outputs,
    and share the status by using the `deferred.notify(mesg)` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建自定义承诺，你有许多优点。你可以控制输入和输出调用，记录错误消息，将输入转换为所需的输出，并通过使用`deferred.notify(mesg)`方法共享状态。
- en: Deferred objects or composed promises
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟对象或组合的承诺
- en: 'Since custom promise in Angular.js can be hard to handle sometimes and can
    fall into malfunction in the worse case, the promise provides another way to implement
    itself. It asks you to transform your response within a `then` method and returns
    a transformed result to the calling method in an autonomous way. Considering the
    same code we used in the previous section:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Angular.js中自定义承诺有时可能难以处理，最坏的情况下可能会出现故障，承诺提供了另一种实现方式。它要求你在`then`方法中转换你的响应，并以一种自主的方式返回转换后的结果给调用方法。考虑我们在上一节中使用的相同代码：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The output we yield from the preceding method will be a chained, promised, and
    transformed. You can again reuse the output for another output, chain it to another
    promise, or simply display the result.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前面方法中产生的输出将是一个链式、承诺式且转换过的。你再次可以使用输出用于另一个输出，将其链式到另一个承诺，或简单地显示结果。
- en: 'The controller can then be transformed into the following lines of code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器可以转换为以下代码行：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This has significantly reduced the lines of code. Also, this helps us in maintaining
    the service level since the automechanism of failsafe in `then()` will help it
    to be transformed into failed promise and will keep the rest of the code intact.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这显著减少了代码行数。同时，这也帮助我们维持了服务级别，因为`then()`中的自动安全机制可以帮助它转换为失败的承诺，并保持其余代码不变。
- en: Dealing with the nested calls
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理嵌套调用
- en: 'While using internal return values in the `success` function, promise code
    can sense that you are missing one most obvious thing: the error controller. The
    missing error can cause your code to stand still or get into a catastrophe from
    which it might not recover. If you want to overcome this, simply throw the errors.
    How? See the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`success`函数中使用内部返回值时，承诺代码可以感觉到你忽略了一件最明显的事情：错误控制器。缺失的错误可能导致你的代码停止运行或陷入无法恢复的灾难。如果你想克服这个问题，只需抛出错误。怎么做？请看下面的代码：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, whenever the code enters into an error-like situation, it will return a
    single string, not a bunch of `$http` statutes or config details. This can also
    save your entire code from going into a standstill mode and help you in debugging.
    Also, if you attached log services, you can pinpoint the location that causes
    the error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论代码进入何种错误情况，它都会返回一个字符串，而不是一串`$http`状态或配置详情。这也可以拯救你的整个代码进入停滞模式，并帮助你在调试。另外，如果你附上了日志服务，你可以精确地定位出错的地点。
- en: Concurrency in Angular.js
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular.js中的并发
- en: We all want to achieve maximum output at a single slot of time by asking multiple
    services to invoke and get results from them. Angular.js provides this functionality
    via its `$q.all` service; you can invoke many services at a time and if you want
    to join all/any of them, you just need `then()` to get them together in the sequence
    you want.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都希望在单一时间槽中获得最大输出，通过请求多个服务调用并从它们获取结果。Angular.js通过其`$q.all`服务提供此功能；您可以同时调用许多服务，如果您想要将它们全部或任意组合在一起，您只需要`then()`将它们按照您想要的顺序组合在一起。
- en: 'Let''s get the payload of the array first:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先获取数组的有效载荷：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And now this array will be used by the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个数组将被以下代码使用：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A promise is created by executing `$http.get` for each URL and is added to an
    array. The `$q.all` function takes the input of an array of promises, which will
    then process all results into a single promise containing an object with each
    answer. This will get converted in JSON and passed on to the caller function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每个URL执行`$http.get`来创建一个promise，并将其添加到数组中。`$q.all`函数接受一个promise数组的输入，然后将所有结果处理成一个包含每个答案的对象的单个promise。这将被转换为JSON并传递给调用者函数。
- en: 'The result might be like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能像这样：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The combination of success and error
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功和错误的组合
- en: The `$http` returns a promise; you can define its success or error depending
    on this promise. Many think that these functions are a standard part of promise—but
    in reality, they are not as they seem to be.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`$http`返回一个promise；您可以根据这个promise定义它的成功或错误。许多人认为这些函数是promise的标准部分——但实际上，它们并不是看起来那样。'
- en: Using promise means you are calling `then()`. It takes two parameters—a callback
    function for success and a callback function for failure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用promise意味着你在调用`then()`。它有两个参数——成功回调函数和失败回调函数。
- en: 'Imagine this code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这个代码：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This can be rewritten as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以重写为：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: One can use either the `success` or `error` function depending on the choice
    of a situation, but there is a benefit in using `$http`—it's convenient. The `error`
    function provides response and status, and the `success` function provides the
    response data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`success`或`error`函数，具体取决于情境的选择，但使用`$http`有一个好处——它很方便。`error`函数提供了响应和状态，而`success`函数提供了响应数据。
- en: 'This is not considered as a standard part of a promise. Anyone can add their
    own versions of these functions to promises, as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是promise的标准部分。任何人都可以向promise添加自己的这些函数版本，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The safe approach
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全方法
- en: So the real matter of discussion is what to use with `$http`? Success or error?
    Keep in mind that there is no standard way of writing promise; we have to look
    at many possibilities.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，讨论的真正问题是与`$http`一起使用什么？成功还是错误？记住，编写promise没有标准方式；我们必须考虑许多可能性。
- en: If you change your code so that your promise is not returned from `$http`, when
    we load data from a cache, your code will break if you expect success or error
    to be there.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改代码，使promise不是从`$http`返回的，那么当我们从缓存加载数据时，如果您期望成功或错误，您的代码将会断裂。
- en: So, the best way is to use `then` whenever possible. This will not only generalize
    the overall approach of writing promise, but also reduce the prediction element
    from your code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最佳做法是尽可能使用`then`。这不仅会概括编写promise的整体方法，还会减少代码中的预测元素。
- en: Route your promise
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由您的promise
- en: 'Angular.js has the best feature to route your promise. This feature is helpful
    when you are dealing with more than one promise at a time. Here is how you can
    achieve routing through the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Angular.js具有路由promise的最佳特性。当您同时处理多个promise时，这个特性很有帮助。以下是如何通过以下代码实现路由的：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can observe, we have two routes: the `api` route takes us to the index
    page, with `IndexController`, and the video route takes us to the movie''s page.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所观察到的，我们有两个路由：`api`路由带我们到索引页，使用`IndexController`，视频路由带我们到电影页。
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There is a problem, until the `MovieService` class gets the name from the backend,
    the name is `null`. This means if our view binds to the name, first it's empty,
    then its set.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个问题，直到`MovieService`类从后端获取名称，该名称是`null`。这意味着如果我们的视图绑定到名称，首先它是空的，然后才设置。
- en: 'This is where router comes in. Router resolves the problem of setting the name
    as `null`. Here''s how we can do it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是路由器出现的地方。路由器解决了将名称设置为`null`的问题。我们可以这样做到：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After adding the resolve, we can revisit our code for a controller:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加解析后，我们可以重新访问控制器的代码：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also define multiple resolves for the route of your promises to get
    the best possible output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为您的承诺定义多个解决方法，以获得最佳可能的输出：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how promise is implemented in Angular.js, how it
    evolved, and how promises help in creating applications composed for real-time
    web apps. We also saw the functionality of the Q library and Angular.js implementation
    of promises using code and learned how to use them in our next application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Angular.js中实现承诺，它是如何发展的，以及承诺如何帮助创建为实时网络应用而设计的应用程序。我们还看到了Q库的功能以及Angular.js中使用承诺的实现代码，并学习了如何在我们下一个应用程序中使用它们。
- en: The specification of promise in Angular.js is very close to the proposed specification
    by ECMAScript 6, but there might be a change when Angular.js fully adopts promises
    as its own specification. It will define its own set of rules to use promise,
    which might not be the same as the specification itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Angular.js中承诺的规范非常接近ECMAScript 6提出的规范，但是当Angular.js完全采用承诺作为自己的规范时，可能会有所变化。它将定义自己的一套规则来使用承诺，这可能与规范本身不同。
- en: In the next chapter, we will look at how promises are implemented in jQuery,
    what will be the mechanism, and what benefits it will bring.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在jQuery中实现承诺，以及将会是怎样的机制以及它将带来哪些好处。
