- en: Chapter 10. Bundling for Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When deploying a JS application to production, bundling is an important practice
    performance-wise. By merging resources, mostly JS code, HTML templates, and CSS
    sheets, into a single file, we can drastically reduce the number of HTTP calls
    the browser has to make to serve the application.
  prefs: []
  type: TYPE_NORMAL
- en: The CLI always bundles the application it runs, even in a development environment.
    This makes deploying an application to a server pretty simple; it's only a matter
    of building it and then copying a bunch of files over.
  prefs: []
  type: TYPE_NORMAL
- en: But then comes the versioning problem. When deploying a new version of our application,
    if the bundles keep the same names, cached bundles may not get refreshed, causing
    users to run an outdated version of our application. How do we deal with this?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll see how to customize the bundling of our contact-management
    application. We'll also see how to leverage the CLI's revision feature to version
    our bundles, so we can benefit from HTTP caching as much as possible. Finally,
    we'll add a new build task to our project in order to facilitate deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring bundles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, a project created using the CLI contains two bundles: a first one
    named `vendor-bundle.js`, which contains all external libraries used by the application,
    and a second named `app-bundle.js`, which contains the application itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bundles are configured in the `aurelia_project/aurelia.json` file, under
    the build section. Here''s how it looks in a typical application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each bundle has a unique name, and must define its content, which can be sourced
    from the application and external dependencies. Typically, the `app-bundle` includes
    all JS, HTML, and CSS from the application's sources, while the `vendor-bundle`
    includes external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This is generally the best configuration for small to medium applications. The
    external dependencies, which commonly don't change very often, are grouped in
    their own bundle, so the users won't have to download those dependencies every
    time a new version of the application is released. In most cases, they'll only
    have to download the new `app-bundle`.
  prefs: []
  type: TYPE_NORMAL
- en: Merging the application in a single bundle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, if for some reason you want your application to fit in a single bundle,
    including both the application itself and its dependencies, it is fairly easy
    to do so. You simply need to define a single bundle, which contains both the application
    sources and the external dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The snippets in the following section are excerpts from the `chapter-10/samples/app-single-bundle`
    sample from the book's assets.
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the entry point of an Aurelia application being the `aurelia-bootstrapper`
    library, the entry-point bundle must be the one containing the `bootstrapper`.
    By default, this is the `vendor-bundle`. If you change the entry-point bundle
    here it becomes the `app-bundle`; you need to change a couple of things.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, still in `aurelia_project/aurelia.json` and under `build`, the loader''s
    `configTarget` property must be changed for the new entry-point bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the main `script` tag of `index.html` must also reference the
    new entry-point bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you run the application at this point, you will see that a single bundle
    is generated, and that the browser loads only this bundle when launching the application.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the application into multiple bundles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some scenarios, having the whole application source in a single `app-bundle`
    is suboptimal. We could easily imagine an application built on heavily segregated
    user stories. Users, depending on their role, only use specific parts of this
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Such an application could be split into multiple smaller bundles, one for each
    role-related section. This way, users would not download bundles for sections
    of the application they never use.
  prefs: []
  type: TYPE_NORMAL
- en: The snippets in the following section are excerpts from the `chapter-10/samples/
    app-with-home` `sample` from the book's assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out by moving the `contacts` feature of our application into
    its own bundle. To do so, we first need to exclude everything within the `contacts`
    directory from the `app-bundle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `source` property supports either an array of glob patterns, or an object
    with an `include` and optional `exclude` properties, both expected to contain
    an array of glob patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we simply move the previous value of `source` down to the `include` property,
    and add an `exclude` property matching everything in the `contacts` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define the new bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This new bundle, named `contacts-bundle.js`, will include all JS, HTML, and
    CSS files within the `contacts` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application at this point, you should first see that the `scripts`
    directory now contains three bundles: `app-bundle.js`, `contacts-bundle.js`, and
    `vendor-bundle.js`. If you open the application in a browser and check the debug
    console, you should see that when loading the application, the browser first loads
    the `vendor-bundle`, then the `app-bundle`, and finally, the `contacts-bundle`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contact-bundle` is loaded when the main `configure` function loads the
    `contacts` feature during the application startup process. This is one of the
    limitations of Aurelia''s features: it can be difficult to isolate a feature in
    a distinct bundle. Indeed, a feature''s `index` file, along with all its dependencies,
    should be bundled in the `app-bundle`. Bundling it separately is useless, since
    this other bundle will be loaded upon startup anyway. However, everything else
    in the feature can be bundled separately.'
  prefs: []
  type: TYPE_NORMAL
- en: In our application, even if you make this change, the `contacts-bundle` would
    still get loaded when the application starts, because the `app` component automatically
    redirects the user to the contacts default route, which is the contacts list.
  prefs: []
  type: TYPE_NORMAL
- en: If you add a home component as the default route in the application and you
    make sure this home component is included in the `app-bundle`, you should see
    that the `contacts-bundle` is loaded only when you navigate to it.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning bundles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the bundles are generated using static names. This means that a
    browser that already has a cached copy of the bundles has no way of knowing if
    its copy is fresh. What if a new version of the application was released?
  prefs: []
  type: TYPE_NORMAL
- en: One (bad) solution to solve this problem is to either set the cache duration
    to a very short time span, which forces all users to download all bundles very
    frequently, or to live with the fact that some users may run an outdated version
    of our application, which means managing compatibility with backend, web services,
    and so on accordingly. This seems like a great recipe for a nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: A much better solution would be to add some kind of revision number to the name
    of each bundle, and to set the cache time to leave of the `index.html` to a very
    short time span, or even to disable its cache completely. Since the `index.html`
    is very small compared to bundles, it is an interesting trade-off, because each
    time a given user would access the application, he would download a fresh copy
    of the `index.html`, which would in turn reference the latest version of the bundles.
    This means that bundles can be cached forever, because the content of a given
    bundle name never changes. Users would never download a given version of a bundle
    more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Aurelia CLI supports bundle versioning by appending a suffix to the filename.
    This suffix is a hash computed from the file''s content. By default, versioning
    is disabled. To enable it, open the `aurelia_project/aurelia.json` file, and set
    the `rev` property of `options` under the `build` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The revision mechanism is enabled on a per-environment basis. Typically, it
    would be enabled in staging and production. It should, however, not be used in
    a development environment, as it doesn't play nice with browser reload and the
    bundle rebuild mechanism when the `watch` switch is used with `au` run. Additionally,
    since most developers systematically test in a browser with caching disabled,
    it would have little value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must also always ensure that in `aurelia_project/aurelia.json` and under
    `build`, the first entry in `targets` has an `index` property set to `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This lets the bundler know the name of the HTML file that loads the application,
    so it can update the `script` tag that loads the entry-point bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now test this by opening a console in the project directory and running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once the command completes, you should see in the `scripts` directory that the
    bundles now contain a hash in their name. You should see something like `app-bundle-ea03d27d90.js`
    and `vendor-bundle-efd8bd9cd8.js`, probably with different hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in `index.html`, the `src` attribute of the `script` tag inside
    the body should now refer to the `vendor-bundle` file with the hash in the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, deploying our application is fairly easy. We need to copy the
    following files over to the server hosting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`favicon.ico`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locales/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styles/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules/bootstrap/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules/font-awesome/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nowadays, most projects use some kind of software factory to build and deploy
    applications. Of course, we could easily put that list of files in the build task
    on our factory. However, this means that every time we add a file or directory
    to that list, we need to change the build task.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing I like to do when working on an Aurelia project is create a new `deploy`
    section in the `aurelia_project/aurelia.json` file, which I set to a list of glob
    patterns matching the files to include in a deployment package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/aurelia.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In addition to this, I also typically create a `deploy` task in the project.
    This task simply builds the application and then copies the files to deploy to
    a target directory, which is passed as an argument to the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create the task definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/tasks/deploy.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a `copy` task, which will be used by the `deploy` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/tasks/copy.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This task first retrieves the target directory passed as the `out` argument
    and fails if it was omitted, then uses the list of glob patterns from the new
    `deploy` section in `aurelia_project/aurelia.json` and copies every matching file
    to the provided target directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can create the deploy task itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia_project/tasks/deploy.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This task simply executes `build` and `copy` sequentially. We could even run
    the unit test task between `build` and `copy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `gulp` task greatly simplifies the build task in the software factory.
    A typical software factory build process would first check the code out from the
    version control, then run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, it would copy everything under $(build-artifacts) over to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, `$(env)` and `$(build-artifacts)` are some kind of environment
    or system variables. The first contains the environment for which the build is
    done, such as `stage` or `prod`, while the second contains some temporary folder
    from which the artifacts to deploy to the web server will be copied. It could
    simply be a `dist` folder inside the working directory, for example.
  prefs: []
  type: TYPE_NORMAL
- en: One of the upsides of this solution is that most details related to building
    and deploying our application are now within the project itself. The software
    factory doesn't depend on the file structure and filenames from the application's
    source, but relies only on `gulp` tasks instead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the CLI running applications in bundled mode all the time, it seems at
    first pretty simple to deploy an Aurelia application. Then you start thinking
    about HTTP cache expiration, and things get a little more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the CLI already provides tools to solve these problems. This, along
    with some good practices, makes prepping an application for the real world a simple
    enough task.
  prefs: []
  type: TYPE_NORMAL
