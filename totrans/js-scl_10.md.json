["```js\n// The DOM elements...\nvar error = document.getElementById('error'),\n    fail1 = document.getElementById('fail1'),\n    fail2 = document.getElementById('fail2');\n\n// The first event merely disables the button.\nfunction onFail1(e) {\n    e.target.disabled = true;\n}\n\n// The second event disables the button, but\n// also explicitly informs the user about what\n// went wrong.\nfunction onFail2(e) {\n    e.target.disabled = true;\n    error.style.display = 'block';\n}\n\n// Setup event handlers...\nfail1.addEventListener('click', onFail1);\nfail2.addEventListener('click', onFail2);\n```", "```js\n// events.js\n// The event broker...\nclass Events {\n\n    // Trigger an event...\n    trigger(name, data) {\n        if (name in this.listeners) {\n            // We need to know the outcome of the previous handler,\n            // so each result is stored here.\n            var previous = null;\n\n            return this.listeners[name].map(function(callback) {\n                var result;\n\n                // Get the result of running the callback. Notice\n                // that it's wrapped in an exception handler. Also\n                // notice that callbacks are passed the result\n                // of the \"previous\" callback.\n                try {\n                    result = previous = callback(Object.assign({\n                        name: name\n                    }, data), previous);\n                } catch(e) {\n                    // If the callback raises an exception, the\n                    // exception is returned, and also passed to\n                    // the next callback. This is how the callbacks\n                    // know if their predecessor failed or not.\n                    result = previous = e;\n                }\n\n                return result;\n            });\n        }\n    }\n\n}\n\nvar events = new Events();\n\nexport default events;\n\n// main.js\nimport events from 'events.js';\n\n// Utility for getting the error message from\n// the object. If it's an exception, we can return\n// the \"message\" property. If it has an \"error\"\n// property, we can return that value. Otherwise,\n// it's not an error and we return \"undefined\".\nfunction getError(obj) {\n    if (obj instanceof Error) {\n        return obj.message;\n    } else if (obj && obj.hasOwnProperty('error')) {\n        return obj.error;\n    }\n}\n\n// This callback will be executed first, since it's\n// the first to subscribe to the event. It'll randomly\n// throw errors.\nevents.listen('action', (data, previous) => {\n    if (Math.round(Math.random())) {\n        throw new Error('First callback failed randomly');\n    } else {\n        console.log('First callback succeeded');\n    }\n});\n\n// This callback is second in line. It checks if the\n// \"previous\" result is an error. If so, it will exit\n// early by returning the error. Otherwise, it'll randomly\n// throw its own error or succeed.\nevents.listen('action', (data, previous) => {\n    var error = getError(previous);\n    if (error) {\n        console.error(`Second callback failed: ${error}`);\n        return previous;\n    } else if (Math.round(Math.random())) {\n        throw new Error('Second callback failed randomly');\n    } else {\n        console.log('Second callback succeeded');\n    }\n});\n\n// The final callback function will check for errors in\n// the \"previous\" result. What's key here is that only\n// one of the preceding callbacks will have failed. Because\n// the second callback doesn't do anything if the first\n// callback fails.\nevents.listen('action', (data, previous) => {\n    var error = getError(previous);\n    if (error) {\n        console.error(`Third callback failed: ${error}`);\n        return previous;\n    } else {\n        console.log('Third callback succeeded');\n    }\n});\n\nevents.trigger('action');\n```", "```js\n// api.js\n// Simulate an API call by returning a promise.\nfunction fetch() {\n    return new Promise((resolve, reject) => {\n\n        // After one second, randomly resolve or\n        // reject the promise.\n        setTimeout(() => {\n            if (Math.round(Math.random())) {\n                resolve();\n            } else {\n                reject();\n            }\n        }, 1000);\n\n    });\n}\n\nexport default fetch;\n\n// model.js\nimport fetch from 'api.js';\n\n// An entity model that's fetched from the API.\nexport default class Model {\n\n    // Initialized with a \"retries\" count and an\n    // \"attempts\" counter, used when the requests fail.\n    constructor(retries=3) {\n        this.attempts = 0;\n        this.retries = retries;\n    }\n\n    // Returns a new promise where \"fetchExecutor()\"\n    // attempts, and possibly re-attempts to call the API.\n    fetch() {\n        return new Promise(this.fetchExecutor.bind(this));\n    }\n\n    fetchExecutor(resolve, reject) {\n        // Call the API and resolve the promise. Also reset the\n        // \"attempts\" counter.\n        fetch().then(() => {\n            this.attempts = 0;\n            resolve();\n        }).catch(() => {\n            // Make another API request attempt, unless\n            // we've already made too many, in which case\n            // we can reject the promise.\n            if (this.attempts++ < this.retries) {\n                console.log('retrying', this.attempts);\n                this.fetchExecutor(resolve, reject);\n            } else {\n                this.attempts = 0;\n                reject(`Max fetch attempts \n                    ${this.retries} exceeded`);\n            }\n        });\n    }\n\n};\n\n// main.js\nimport Model from 'model.js';\n\nvar model = new Model();\n\n// Fetch the model, and look at the logging\n// output to see how many attempts were made.\nmodel.fetch()\n    .then(() => {\n        console.log('succeeded');\n    })\n    .catch((e) => {\n        console.error(e);\n    });\n```"]