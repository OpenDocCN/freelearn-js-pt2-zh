- en: Chapter 8. DOM Manipulation and Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章。DOM操作与事件
- en: The most important reason for JavaScript's existence is the web. JavaScript
    is the language for the web and the browser is the raison d'être for JavaScript.
    JavaScript gives dynamism to otherwise static web pages. In this chapter, we will
    dive deep into this relationship between the browser and language. We will understand
    the way in which JavaScript interacts with the components of the web page. We
    will look at the **Document Object Model** (**DOM**) and JavaScript event model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: javascript存在最重要的原因就是网络。JavaScript是网络的语言，浏览器就是JavaScript存在的理由。JavaScript为原本静态的网页赋予了动态性。在本章中，我们将深入探讨浏览器与语言之间的关系。我们将了解JavaScript与网页组件进行交互的方式。我们将查看**文档对象模型**（**DOM**）和JavaScript事件模型。
- en: DOM
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM
- en: In this chapter, we will look at various aspects of JavaScript with regard to
    the browser and HTML. HTML, as I am sure you are aware, is the markup language
    used to define web pages. Various forms of markups exist for different uses. The
    popular marks are **Extensible Markup Language** (**XML**) and **Standard Generalized
    Markup Language** (**SGML**). Apart from these generic markup languages, there
    are very specific markup languages for specific purposes such as text processing
    and image meta information. **HyperText Markup Language** (**HTML**) is the standard
    markup language that defines the presentation semantics of a web page. A web page
    is essentially a document. The DOM provides you with a representation of this
    document. The DOM also provides you with a means of storing and manipulating this
    document. The DOM is the programming interface of HTML and allows structural manipulation
    using scripting languages such as JavaScript. The DOM provides a structural representation
    of the document. The structure consists of nodes and objects. Nodes have properties
    and methods on which you can operate in order to manipulate the nodes themselves.
    The DOM is just a representation and not a programming construct. DOM acts as
    a model for DOM processing languages such as JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨JavaScript与浏览器和HTML的各种方面。HTML，我相信您已经知道，是用于定义网页的标记语言。存在各种形式的标记用于不同的用途。流行的标记有**可扩展标记语言**（**XML**）和**标准通用标记语言**（**SGML**）。除了这些通用的标记语言之外，还有针对特定目的非常具体的标记语言，例如文本处理和图像元信息。**超文本标记语言**（**HTML**）是定义网页表示语义的标准标记语言。网页本质上是一个文档。DOM为您提供了这个文档的表示。DOM还为您提供了存储和操纵这个文档的手段。DOM是HTML的编程接口，并允许使用脚本语言（如JavaScript）进行结构操作。DOM为文档提供了结构表示。该结构由节点和对象组成。节点有属性和方法，您可以对这些属性和方法进行操作以操纵节点本身。DOM只是一个表示，并不是一个编程结构。DOM作为DOM处理语言（如JavaScript）的模型。
- en: Accessing DOM elements
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问DOM元素
- en: 'Most of the time, you will be interested in accessing DOM elements to inspect
    their values or processing these values for some business logic. We will take
    a detailed look at this particular use case. Let''s create a sample HTML file
    with the following content:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你将会想要访问DOM元素以检查它们的值，或者处理这些值以进行某些业务逻辑。我们将详细查看这个特定的用例。让我们创建一个带有以下内容的示例HTML文件：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can save this file as `sample_dom.html`; when you open this in the Google
    Chrome browser, you will see the web page displayed with the **Hello World** text
    displayed. Now, open Google Chrome Developer Tools by navigating to options |
    **More Tools** | **Developer Tools** (this route may differ on your operating
    system and browser version). In the **Developer Tools** window, you will see the
    DOM structure:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此文件保存为`sample_dom.html`；当您在Google Chrome浏览器中打开此文件时，您将看到显示**Hello World**文本的网页。现在，打开Google
    Chrome开发者工具，通过转到选项 | **更多工具** | **开发者工具**（此路径可能因您的操作系统和浏览器版本而异）。在**开发者工具**窗口中，您将看到DOM结构：
- en: '![Accessing DOM elements](img/00025.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![访问DOM元素](img/00025.jpeg)'
- en: 'Next, we will insert some JavaScript into this HTML page. We will invoke the
    JavaScript function when the web page is loaded. To do this, we will call a function
    on `window.onload`. You can place your script in the `<script>` tag located under
    the `<head>` tag. Your page should look as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向这个HTML页面中插入一些JavaScript。当网页加载时，我们将调用JavaScript函数。为此，我们将调用`window.onload`上的一个函数。您可以将您的脚本放在`<script>`标签下，该标签位于`<head>`标签下。您的页面应如下所示：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The anonymous function is executed when the browser loads the page. In the function,
    we are getting the nodes of the DOM programmatically. The entire HTML document
    can be accessed using the `document.documentElement` function. We store the document
    in a variable. Once the document is accessed, we can traverse the nodes using
    several helper properties of the document. We are accessing the `<body>` element
    using `doc.body`. You can traverse through the children of an element using the
    `childNodes` array. The first and last children of a node can be accessed using
    additional properties—`firstChild` and `lastChild`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数在浏览器加载页面时执行。在函数中，我们获取DOM节点的程序化方式。整个HTML文档可以通过`document.documentElement`函数访问。我们将文档存储在一个变量中。一旦访问了文档，我们就可以使用文档的几个辅助属性来遍历节点。我们使用`doc.body`访问`<body>`元素。可以通过`childNodes`数组遍历元素的子节点。节点的第一个和最后一个子节点可以通过额外的属性——`firstChild`和`lastChild`来访问。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is not recommended to use render-blocking JavaScript in the `<head>` tag.
    This slows down the page render dramatically. Modern browsers support the `async`
    and `defer` attributes to indicate to the browsers that the rendering can go on
    while the script is being downloaded. You can use these tags in the `<head>` tag
    without worrying about performance degradation. You can get more information at
    [http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup](http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在`<head>`标签中使用阻塞渲染的JavaScript。这会显著减慢页面渲染速度。现代浏览器支持`async`和`defer`属性，以指示浏览器在下载脚本的同时可以继续渲染。你可以在`<head>`标签中使用这些标签，而不用担心性能下降。你可以在[http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup](http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup)获取更多信息。
- en: Accessing specific nodes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问特定节点
- en: 'The core DOM defines the `getElementsByTagName()` method to return `NodeList`
    of all the element objects whose `tagName` property is equal to a specific value.
    The following line of code returns a list of all the `<p/>` elements in a document:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 核心DOM定义了`getElementsByTagName()`方法，返回所有`tagName`属性等于特定值的元素对象`NodeList`。以下代码行返回一个文档中所有`<p>`元素的列表：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The HTML DOM defines `getElementsByName()` to retrieve all the elements that
    have their name attribute set to a specific value. Consider the following snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTML DOM定义了`getElementsByName()`方法来获取所有名称属性设置为特定值的元素。考虑以下片段：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are creating a group of radio buttons with the `name` attribute
    defined as `feeling`. In the `showFeelings` function, we get all the elements
    with the `name` attribute set to `feeling` and we iterate through all these elements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一组单选按钮，其`name`属性定义为`feeling`。在`showFeelings`函数中，我们获取所有`name`属性设置为`feeling`的元素，并对这些元素进行遍历。
- en: 'The other method defined by the HTML DOM is `getElementById()`. This is a very
    useful method in accessing a specific element. This method does the lookup based
    on the `id` associated with an element. The `id` attribute is unique for every
    element and, hence, this kind of lookup is very fast and should be preferred over
    `getElementsByName()`. -However, you should be aware that the browser does not
    guarantee the uniqueness of the `id` attribute. In the following example, we are
    accessing a specific element using the ID. Element IDs are unique as opposed to
    tags or name attributes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTML DOM还定义了`getElementById()`方法。这是一个非常实用的方法，用于访问特定元素。该方法基于与元素相关联的`id`属性进行查找。`id`属性对每个元素都是唯一的，因此这种查找非常快速，应优先于`getElementsByName()`方法。然而，你应该注意到浏览器不保证`id`属性的唯一性。在以下示例中，我们使用ID访问一个特定元素。元素ID相对于标签或名称属性来说是唯一的：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What we discussed so far was the basics of DOM traversal in JavaScript. When
    the DOM gets complex and you want sophisticated operations on the DOM, these traversal
    and access functions seem limiting. With this basic knowledge with us, it's time
    to get introduced to a fantastic library for DOM traversal (among other things)
    called jQuery.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们讨论的是DOM遍历的基本知识。当DOM变得复杂且需要在DOM上进行复杂操作时，这些遍历和访问函数似乎有限。有了这些基本知识，是时候介绍一个用于DOM遍历（以及其他功能）的出色库——jQuery。
- en: jQuery is a lightweight library designed to make common browser operations easier.
    Common operations such as DOM traversal and manipulation, event handling, animation,
    and Ajax can be tedious if done using pure JavaScript. jQuery provides you with
    easy-to-use and shorter helper mechanisms to help you develop these common operations
    very easily and quickly. jQuery is a feature-rich library, but as far as this
    chapter goes, we will focus primarily on DOM manipulation and events.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个轻量级库，旨在使常见的浏览器操作更加容易。纯JavaScript中进行诸如DOM遍历和操作、事件处理、动画和Ajax等常见操作可能会很繁琐。jQuery提供了易于使用且更短的助手机制，帮助你轻松快速地开发这些常见操作。jQuery是一个功能丰富的库，但就本章而言，我们将主要关注DOM操作和事件。
- en: 'You can add jQuery to your HTML by adding the script directly from a **content
    delivery network** (**CDN**) or manually downloading the file and adding it to
    the script tag. The following example shows you how to download jQuery from Google''s
    CDN:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从**内容分发网络**（**CDN**）直接添加脚本来将jQuery添加到你的HTML中，或者手动下载文件并将其添加到脚本标签中。以下示例将指导你如何从谷歌的CDN下载jQuery：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The advantage of a CDN download is that Google''s CDN automatically finds the
    nearest download server for you and keeps an updated stable copy of the jQuery
    library. If you wish to download and manually host jQuery along with your website,
    you can add the script as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDN下载的优势在于，谷歌的CDN会自动为你找到最近的下载服务器，并保持对jQuery库的更新稳定副本。如果你希望下载并手动托管jQuery以及你的网站，你可以按照以下方式添加脚本：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, the jQuery library is manually downloaded in the `lib` directory.
    With the jQuery setup in the HTML page, let''s explore the methods of manipulating
    the DOM elements. Consider the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，jQuery库是在`lib`目录中手动下载的。在HTML页面中设置jQuery后，让我们探索操纵DOM元素的方法。考虑以下示例：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After adding jQuery to the HTML page, we write the custom JavaScript that selects
    the element with a `greeting` ID and changes its value. The strange-looking code
    within `$()` is the jQuery in action. If you read the jQuery source code (and
    you should, it''s brilliant) you will see the final line:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在将jQuery添加到HTML页面后，我们编写自定义JavaScript，选择具有`greeting` ID的元素并更改其值。`$()`内的奇怪代码是jQuery在起作用。如果你阅读jQuery源代码（并且你应该阅读，它非常出色）你会看到最后一行：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `$` is just a function. It is an alias for the function called jQuery. The
    `$` is a syntactic sugar that makes the code concise. In fact, you can use both
    `$` and `jQuery` interchangeably. For example, both `$('#greeting').html('Hello
    World Martian');` and `jQuery('#greeting').html('Hello World Martian');` are the
    same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`只是一个函数。它是调用名为jQuery的函数的别名。`$`是一种语法糖，使代码更加简洁。实际上，你可以交替使用`$`和`jQuery`。例如，`$(''#greeting'').html(''Hello
    World Martian'');`和`jQuery(''#greeting'').html(''Hello World Martian'');`是相同的。'
- en: 'You can''t use jQuery before the page is completely loaded. As jQuery will
    need to know all the nodes of the DOM structure, the entire DOM has to be in-memory.
    To ensure that the page is completely loaded and in a state where it''s ready
    to be manipulated, we can use the `$(document).ready()` function. Here, the IIFE
    is executed only after the entire documented is *ready*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面完全加载之前不能使用jQuery。因为jQuery需要知道DOM结构的的所有节点，整个DOM必须保存在内存中。为了确保页面完全加载并处于可以被操纵的状态，我们可以使用`$(document).ready()`函数。在这里，IIFE仅在整个文档*准备就绪*后执行：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a very common thing to do when using jQuery—so much so that it has
    its own shortcut. You can replace the entire `ready()` call with a short `$()`
    call:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用jQuery时，这是一个非常常见的行为——以至于它有自己的快捷方式。你可以用一个短的`$()`调用替换整个`ready()`调用：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The most important function in jQuery is `$()`. This function typically accepts
    a CSS selector as its sole parameter and returns a new jQuery object pointing
    to the corresponding elements on the page. The three primary selectors are the
    tag name, ID, and class. They can be used either on their own or in combination
    with others. The following simple examples illustrate how these three selectors
    appear in code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中最重要的函数是`$()`。这个函数通常接受一个CSS选择器作为其唯一参数，并返回一个指向页面相应元素的新jQuery对象。三种主要的选择器是标签名、ID和类。它们可以单独使用，也可以与其他元素组合使用。以下简单示例展示了这三种选择器在代码中的表现形式：
- en: '| **Selector** | CSS Selector | jQuery Selector | Output from the selector
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **选择器** | CSS选择器 | jQuery选择器 | 选择器的输出 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Tag** | `p{}` | `$(''p'')` | This selects all the `p` tags from the document.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | `p{}` | `$(''p'')` | 这选择了文档中的所有`p`标签。 |'
- en: '| **Id** | `#div_1` | `$(''#div_1'')` | This selects single elements that have
    a `div_1` ID. The symbol used to identify the ID is `#`. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | `#div_1` | `$(''#div_1'')` | 这选择具有`div_1` ID的单个元素。用来标识ID的符号是`#`。|'
- en: '| **Class** | `.bold_fonts` | `$(''.bold_fonts'')` | This selects all the elements
    in the document that have the CSS class `bold_fonts`. The symbol used to identify
    the class match is "`.`". |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **类** | `.bold_fonts` | `$(''.bold_fonts'')` | 这选择文档中具有`bold_fonts` CSS类的所有元素。用来标识类匹配的符号是"`.`"。|'
- en: jQuery works on CSS selectors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery工作在CSS选择器上。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As CSS selectors are not in the scope of this book, I would suggest that you
    go to [http://www.w3.org/TR/CSS2/selector.html](http://www.w3.org/TR/CSS2/selector.html)
    to get a fair idea of the concept.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSS选择器超出了本书的范围，我建议你前往[http://www.w3.org/TR/CSS2/selector.html](http://www.w3.org/TR/CSS2/selector.html)以了解这个概念。
- en: 'We also assume that you are familiar with HTML tags and syntax. The following
    example covers the fundamental idea of how jQuery selectors work:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你对HTML标签和语法也很熟悉。以下示例涵盖了jQuery选择器的基本工作原理：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we are selecting several DOM elements in the HTML page using
    selectors. We have an H1 header with the text, `Are we there yet ?`; when the
    page loads, our jQuery script accesses all H1 headers and appends the text `Finally?`
    to them:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用选择器在HTML页面上选择几个DOM元素。我们有一个文本为`Are we there yet ?`的H1头部；当页面加载时，我们的jQuery脚本访问所有的H1头部并将文本`Finally?`附加到它们：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `$.html()` function sets the HTML for the target element—an H1 header in
    this case. Additionally, we select all H1 headers and apply a specific CSS style
    class, `highlight-blue`, to all of them. The `$('h1').addClass('highlight-blue')`
    statement selects all the H1 headers and uses the `$.addClass(<CSS class>)` method
    to apply a CSS class to all the elements selected using the selector.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.html()`函数设置目标元素的HTML——在这个例子中是一个H1头部。此外，我们选择所有的H1头部并为它们应用一个特定的CSS样式类，`highlight-blue`。`$(''h1'').addClass(''highlight-blue'')`语句选择所有的H1头部，并使用`$.addClass(<CSS类>)`方法为使用选择器选择的所有的元素应用一个CSS类。'
- en: 'We use the child combinator (`>`) to custom CSS styles using the `$.css()`
    function. In effect, the selector in the `$()` function is saying, "Find each
    header (`h1`) that is a child (`>`) of the element with an ID of header (`#header`)."
    For each such element, we apply a custom CSS. The next usage is interesting. Consider
    the following line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用子组合符（`>`）和`$.css()`函数自定义CSS样式。实际上，`$()`函数中的选择器是在说：“找到每个`h1`头部元素（`#header`的子元素）。”
    对每个这样的元素，我们应用一个自定义的CSS。下一个用法是有趣的。考虑以下行：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are selecting "For all list elements (`li`) that do not have the class `highlight-blue`
    applied to them, apply CSS class `highlight-green`. The final line—`$(''tr:nth-child(odd)'').addClass(''zebra'')`—can
    be interpreted as: From all table rows (`tr`), for every odd row, apply CSS style
    `zebra`. The *n*th-child selector is a custom selector provided by jQuery. The
    final output looks something similar to the following (Though it shows several
    jQuery selector types, it is very clear that knowledge of jQuery is not a substitute
    for bad design taste.):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择“对所有未应用`highlight-blue`类的`li`列表元素，应用`highlight-green` CSS类。最后一行—`$('tr:nth-child(odd)').addClass('zebra')`—可以解释为：从所有表格行（`tr`）中，对每一行，应用`zebra`
    CSS样式。第*n*个孩子选择器是jQuery提供的自定义选择器。最终输出类似于以下内容（虽然它展示了几个jQuery选择器类型，但非常清晰地表明了，了解jQuery并不是设计糟糕的替代品。）：
- en: '![Accessing specific nodes](img/00026.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![访问特定节点](img/00026.jpeg)'
- en: Once you have made a selection, there are two broad categories of methods that
    you can call on the selected element. These methods are **getters** and **setters**.
    Getters retrieve a piece of information from the selection, and setters alter
    the selection in some way.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做出了一个选择，你可以在选定的元素上调用两种广泛的方法。这些方法是**获取器**和**设置器**。获取器从选择集中检索信息，设置器以某种方式更改选择集。
- en: Getters usually operate only on the first element in a selection while setters
    operate on all the elements in a selection. Setters use implicit iteration to
    automatically iterate over all the elements in the selection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器通常只对选择集中的第一个元素进行操作，而设置器则对选择集中的所有元素进行操作。设置器通过隐式迭代来自动遍历选择集中的所有元素。
- en: 'For example, we want to apply a CSS class to all list items on the page. When
    we call the `addClass` method on the selector, it is automatically applied to
    all elements of this particular selection. This is implicit iteration in action:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要给页面上的所有列表项应用一个 CSS 类。当我们对选择器调用 `addClass` 方法时，它自动应用于这个特定选择的所有元素。这就是隐式迭代在行动：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, sometimes you just don''t want to go through all the elements via
    implicit iteration. You may want to selectively modify only a few of the elements.
    You can explicitly iterate over the elements using the `.each()` method. In the
    following code, we are processing elements selectively and using the `index` property
    of the element:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你只是不想通过隐式迭代来遍历所有元素。你可能只想选择性地修改几个元素。你可以使用 `.each()` 方法显式地遍历元素。在以下代码中，我们选择性地处理元素并使用元素的
    `index` 属性：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Chaining
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式操作
- en: 'Chaining jQuery methods allows you to call a series of methods on a selection
    without temporarily storing the intermediate values. This is possible because
    every setter method that we call returns the selection on which it was called.
    This is a very powerful feature and you will see it being used by many professional
    libraries. Consider the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 链式 jQuery 方法允许你在选择上调用一系列方法，而无需临时存储中间值。这是可能的，因为我们所调用的每个设置器方法都会返回它被调用的选择。这是一个非常强大的特性，你将会看到许多专业库在使用它。考虑以下示例：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Traversal and manipulation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历和操作
- en: We discussed various methods of element selection using jQuery. We will discuss
    several DOM traversal and manipulation methods using jQuery in this section. These
    tasks would be rather tedious to achieve using native DOM manipulation. jQuery
    makes them intuitive and elegant.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用 jQuery 进行元素选择的各种方法。我们在本节中将讨论使用 jQuery 进行 DOM 遍历和操作的几个方法。这些任务如果使用原生的
    DOM 操作来实现将会相当繁琐。jQuery 使它们变得直观和优雅。
- en: 'Before we delve into these methods, let''s familiarize ourselves with a bit
    of HTML terminology that we will be using from now on. Consider the following
    HTML:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入这些方法之前，让我们先熟悉一些我们接下来会使用的 HTML 术语。考虑以下 HTML：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using jQuery traversal methods, we select the first element and traverse through
    the DOM in relation to this element. As we traverse the DOM, we alter the original
    selection and we are either replacing the original selection with the new one
    or we are modifying the original selection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jQuery 遍历方法，我们选择第一个元素并相对于这个元素遍历 DOM。在遍历 DOM 的过程中，我们改变了原始选择，我们或者是用新的选择替换原始选择，或者是修改原始选择。
- en: 'For example, you can filter an existing selection to include only elements
    that match a certain criterion. Consider this example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以过滤现有的选择，只包括符合某些标准的元素。考虑这个例子：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'jQuery allows you to add and remove classes to elements. If you want to toggle
    class values for elements, you can use the `toggleClass()` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 允许你给元素添加和移除类。如果你想要切换元素的类值，你可以使用 `toggleClass()` 方法：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most often, you may want to alter the value of elements. You can use the `val()`
    method to alter the form of element values. For example, the following line alters
    the value of all the `text` type inputs in the form:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你可能想更改元素的值。你可以使用 `val()` 方法来更改元素值的形式。例如，以下行更改了表单中所有 `text` 类型输入的值：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To modify element attributes, you can use the `attr()` method as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改元素属性，你可以如下使用 `attr()` 方法：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: jQuery has an incredible depth of functionality when it comes to DOM manipulation—the
    scope of this book restricts a detailed discussion of all the possibilities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 在 DOM 操作方面具有 incredible 的功能深度——本书的范围限制了对所有可能性的详细讨论。
- en: Working with browser events
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理浏览器事件
- en: When are you developing for browsers, you will have to deal with user interactions
    and events associated to them, for example, text typed in the textbox, scrolling
    of the page, mouse button press, and others. When the user does something on the
    page, an event takes place. Some events are not triggered by user interaction,
    for example, `load` event does not require a user input.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为浏览器开发时，你将不得不处理与它们相关的用户交互和事件，例如文本框中输入的文本、页面的滚动、鼠标按键按下等。当用户在页面上做些什么时，一个事件就会发生。有些事件不是由用户交互触发的，例如，`load`
    事件不需要用户输入。
- en: When you are dealing with mouse or keyboard events in the browser, you can't
    predict when and in which order these events will occur. You will have to constantly
    look for a key press or mouse move to happen. It's like running an endless background
    loop listening to some key or mouse event to happen. In traditional programming,
    this was known as polling. There were many variations of these where the waiting
    thread used to be optimized using queues; however, polling is still not a great
    idea in general.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中处理鼠标或键盘事件时，你无法预测这些事件何时以及以何种顺序发生。你必须不断寻找按键或鼠标移动事件的发生。这就像运行一个无尽的后台循环，监听某个键或鼠标事件的发生。在传统编程中，这被称为轮询。有许多变体，其中等待线程通过队列进行优化；然而，轮询通常仍然不是一个好主意。
- en: 'Browsers provide a much better alternative to polling. Browsers provide you
    with programmatic means to react when an event occurs. These hooks are generally
    called listeners. You can register a listener that reacts to a particular event
    and executes an associated callback function when the event is triggered. Consider
    this example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器提供了一种比轮询更好的替代方案。浏览器为您提供了在事件发生时做出反应的程序化手段。这些钩子通常称为监听器。您可以注册一个监听器，用于在特定事件发生时执行关联的回调函数。请参考这个例子：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `addEventListener` function registers its second argument as a callback
    function. This callback is executed when the event specified in the first argument
    is triggered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener` 函数将其第二个参数注册为回调函数。当第一个参数指定的事件触发时，执行此回调。'
- en: 'What we saw just now was a generic listener for the `click` event. Similarly,
    every DOM element has its own `addEventListener` method, which allows you to listen
    specifically on this element:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才我们看到的是一个通用的 `click` 事件监听器。同样，每个 DOM 元素都有自己的 `addEventListener` 方法，允许你在这个元素上特别监听：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we are using the reference to a specific element—a button with
    a `Bigbutton` ID—by calling `getElementById()`. On the reference of the button
    element, we are calling `addEventListener()` to assign a handler function for
    the click event. This is perfectly legitimate code that works fine in modern browsers
    such as Mozilla Firefox or Google Chrome. On Internet Explorer prior to IE9, however,
    this is not a valid code. This is because Microsoft implements its own custom
    `attachEvent()` method as opposed to the W3C standard `addEventListener()` prior
    to Internet Explorer 9\. This is very unfortunate because you will have to write
    very bad hacks to handle browser-specific quirks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过调用 `getElementById()` 使用特定元素的引用——一个具有 `Bigbutton` ID 的按钮。在按钮元素的引用上，我们调用
    `addEventListener()` 为点击事件分配一个处理函数。在 Mozilla Firefox 或 Google Chrome 等现代浏览器中，这段代码完全合法且运行良好。然而，在
    IE9 之前的 Internet Explorer 中，这段代码是无效的。这是因为微软在 Internet Explorer 9 之前实现了自己的自定义 `attachEvent()`
    方法，而不是 W3C 标准的 `addEventListener()`。这非常不幸，因为你将不得不编写非常糟糕的快捷方式来处理浏览器特定的怪癖。
- en: Propagation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传播
- en: 'At this point, we should ask an important question—if an element and one of
    its ancestors have a handler on the same event, which handler will be fired first?
    Consider the following figure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们应该问一个重要的问题——如果一个元素和它的一个祖先元素都有同一个事件处理程序，哪个处理程序将首先被触发？请参考以下图形：
- en: '![Propagation](img/00027.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![传播](img/00027.jpeg)'
- en: For example, we have **Element2** as a child of **Element1** and both have the
    `onClick` handler. When a user clicks on Element2, `onClick` on both Element2
    and Element1 is triggered but the question is which one is triggered first. What
    should the event order be? Well, the answer, unfortunately, is that it depends
    entirely on the browser. When browsers first arrived, two opinions emerged, naturally,
    from Netscape and Microsoft.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个 **Element2** 作为 **Element1** 的子元素，两者都具有 `onClick` 处理程序。当用户点击 Element2
    时，Element2 和 Element1 的 `onClick` 都会被触发，但问题是哪个先被触发。事件顺序应该是怎样的？嗯，不幸的是，答案完全取决于浏览器。当浏览器首次出现时，自然会从
    Netscape 和 Microsoft 出现两种观点。
- en: Netscape decided that the first event triggered should be Element1's `onClick`.
    This event ordering is known as event capturing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Netscape 决定首先触发的是 Element1 的 `onClick` 事件。这种事件排序被称为事件捕获。
- en: Microsoft decided that the first event triggered should be Element2's `onClick`.
    This event ordering is known as event bubbling.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 决定首先触发的是 Element2 的 `onClick` 事件。这种事件排序被称为事件冒泡。
- en: These are two completely opposite views and implementations of how browsers
    handled events. To end this madness, **World Wide Web Consortium** (**W3C**) decided
    a wise middle path. In this model, an event is first captured until it reaches
    the target element and then bubbles up again. In this standard behavior, you can
    choose in which phase you want to register your event handler—either in the capturing
    or bubbling phase. If the last argument is true in `addEventListener()`, the event
    handler is set for the capturing phase, if it is false, the event handler is set
    for the bubbling phase.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法完全代表了浏览器处理事件的两种相反观点和实现。为了结束这种疯狂，**万维网联盟**（**W3C**）决定采取明智的中庸之道。在这个模型中，事件首先被捕获，直到它到达目标元素，然后再次冒泡。在这个标准行为中，你可以选择在哪个阶段注册你的事件处理程序——捕获阶段或冒泡阶段。如果在`addEventListener()`中的最后一个参数为true，则事件处理程序设置为捕获阶段，如果为false，则事件处理程序设置为冒泡阶段。
- en: There are times when you don't want the event to be raised by the parents if
    it was already raised by the child. You can call the `stopPropagation()` method
    on the event object to prevent handlers further up from receiving the event. Several
    events have a default action associated with them. For example, if you click on
    a URL link, you will be taken to the link's target. The JavaScript event handlers
    are called before the default behavior is performed. You can call the `preventDefault()`
    method on the event object to stop the default behavior from being triggered.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果你已经通过子元素触发了事件，你不想让父元素也触发事件。你可以在事件对象上调用`stopPropagation()`方法，以防止更高层次的处理程序接收事件。一些事件与它们关联的默认动作。例如，如果你点击一个URL链接，你会被带到链接的目标。在默认行为执行之前调用JavaScript事件处理程序。你可以在事件对象上调用`preventDefault()`方法，以阻止默认行为的触发。
- en: These are event basics when you are using plain JavaScript on a browser. There
    is a problem here. Browsers are notorious when it comes to defining event-handling
    behavior. We will look at jQuery's event handling. To make things easier to manage,
    jQuery always registers event handlers for the bubbling phase of the model. This
    means that the most specific elements will get the first opportunity to respond
    to any event.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器上使用纯JavaScript时，这些都是事件基础。这里有一个问题。浏览器在定义事件处理行为方面臭名昭著。我们将看看jQuery的事件处理。为了使管理更加容易，jQuery总是为模型的冒泡阶段注册事件处理程序。这意味着最具体的元素将首先有机会对任何事件做出响应。
- en: jQuery event handling and propagation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery事件处理和传播
- en: 'jQuery event handling takes care of many of these browser quirks. You can focus
    on writing code that runs on most supported browsers. jQuery''s support for browser
    events is simple and intuitive. For example, this code listens for a user to click
    on any button element on the page:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery事件处理可以解决浏览器许多怪癖。你可以专注于编写在大多数受支持的浏览器上运行的代码。jQuery对浏览器事件的支持简单直观。例如，这段代码监听用户点击页面上的任何按钮元素：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just like the `click()` method, there are several other helper methods to cover
    almost all kinds of browser event. The following helpers exist:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`click()`方法一样，还有几个其他助手方法来涵盖几乎所有类型的浏览器事件。以下助手方法存在：
- en: '`blur`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur`'
- en: '`change`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change`'
- en: '`click`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click`'
- en: '`dblclick`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dblclick`'
- en: '`error`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`'
- en: '`focus`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus`'
- en: '`keydown`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keydown`'
- en: '`keypress`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keypress`'
- en: '`keyup`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyup`'
- en: '`load`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`'
- en: '`mousedown`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mousedown`'
- en: '`mousemove`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mousemove`'
- en: '`mouseout`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseout`'
- en: '`mouseover`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseover`'
- en: '`mouseup`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseup`'
- en: '`resize`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize`'
- en: '`scroll`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scroll`'
- en: '`select`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`'
- en: '`submit`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit`'
- en: '`unload`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unload`'
- en: Alternatively, you can use the `.on()` method. There are a few advantages of
    using the `on()` method as it gives you a lot more flexibility. The `on()` method
    allows you to bind a handler to multiple events. Using the `on()` method, you
    can work on custom events as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用`.on()`方法。使用`.on()`方法有几个优点，因为它为你提供了更多的灵活性。`.on()`方法允许你将处理程序绑定到多个事件。使用`.on()`方法，你也可以处理自定义事件。
- en: 'Event name is passed as the first parameter to the `on()` method just like
    the other methods that we saw:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称作为`on()`方法的第一个参数传递，就像我们看到的其它方法一样：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once you''ve registered an event handler to an element, you can trigger this
    event as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你向元素注册了一个事件处理程序，你可以按照以下方式触发这个事件：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This event can also be triggered as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件也可以按照以下方式触发：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can unbind an event using jQuery''s `.off()` method. This will remove any
    event handlers that were bound to the specified event:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用jQuery的`.off()`方法解除事件绑定。这将移除绑定到指定事件的任何事件处理程序：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can add more than one handler to an element:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向元素添加多个处理程序：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the event is fired, both the handlers will be invoked. If you want to
    remove only the first handler, you can use the `off()` method with the second
    parameter indicating the handler that you want to remove:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被触发时，两个处理器都会被调用。如果你只想删除第一个处理器，你可以使用带有第二个参数的`off()`方法，该参数指明你想删除的处理器：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is possible if you have the reference to the handler. If you are using
    anonymous functions as handlers, you can''t get reference to them. In this case,
    you can use namespaced events. Consider the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有处理器的引用，这是可能的。如果你使用匿名函数作为处理器，你不能获取对它们的引用。在这种情况下，你可以使用命名空间事件。考虑以下示例：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that you have a namespaced event handler registered with the element, you
    can remove it as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为元素注册了一个命名空间事件处理器，你可以按照以下方式删除它：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A major advantage of using `.on()` is that you can bind to multiple events
    at once. The `.on()` method allows you to pass multiple events in a space-separated
    string. Consider the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.on()`的一个主要优点是，你可以一次绑定多个事件。`.on()`方法允许你通过空格分隔的字符串传递多个事件。考虑以下示例：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can add multiple event handlers for multiple events as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为多个事件添加多个事件处理器如下：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As of jQuery 1.7, all events are bound via the `on()` method, even if you call
    helper methods such as `click()`. Internally, jQuery maps these calls to the `on()`
    method. Due to this, it's generally recommended to use the `on()` method for consistency
    and faster execution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 截至jQuery 1.7，所有事件都是通过`on()`方法绑定的，即使你调用如`click()`的帮助方法。内部地，jQuery将这些调用映射到`on()`方法。因此，通常建议使用`on()`方法以保持一致性和更快的执行。
- en: Event delegation
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件委托
- en: Event delegation allows us to attach a single event listener to a parent element.
    This event will fire for all the descendants matching a selector even if these
    descendants will be created in the future (after the listener was bound to the
    element).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 事件委托允许我们将一个事件监听器附加到父元素上。这个事件将会为所有匹配选择器的后代元素触发，即使这些后代元素是在监听器绑定后创建的（将来创建）。
- en: 'We discussed *event bubbling* earlier. Event delegation in jQuery works primarily
    due to event bubbling. Whenever an event occurs on a page, the event bubbles up
    from the element that it originated from, up to its parent, then up to the parent''s
    parent, and so on, until it reaches the root element (`window`). Consider the
    following example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了*事件冒泡*。jQuery中的事件委托主要归功于事件冒泡。每当页面上的事件发生时，事件会从它起源的元素开始冒泡，一直冒泡到它的父元素，然后冒泡到父元素的父元素，依此类推，直到它达到根元素（`window`）。考虑以下示例：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s say that we want to perform some common action on any of the URL
    clicks. We can add an event handler to all the `a` elements in the list as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要对任何URL的点击执行一些常见操作。我们可以如下向列表中的所有`a`元素添加事件处理器：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This works perfectly fine, but this code has a minor bug. What will happen
    if there is an additional URL added to the list as a result of some dynamic action?
    Let''s say that we have an **Add** button that adds new URLs to this list. So,
    if the new list item is added with a new URL, the earlier event handler will not
    be attached to it. For example, if the following link is added to the list dynamically,
    clicking on it will not trigger the handler that we just added:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全没问题，但这段代码有一个小错误。如果由于某些动态操作在列表中添加了一个额外的URL会发生什么？比如说，我们有一个**添加**按钮，它将新的URL添加到这个列表中。所以，如果新列表项是通过一个新的URL添加的，那么早先的事件处理器将不会附加到它。例如，如果以下链接动态地添加到列表中，点击它将不会触发我们刚刚添加的处理器：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is because such events are registered only when the `on()` method is called.
    In this case, as this new element did not exist when `.on()` was called, it does
    not get the event handler. With our understanding of event bubbling, we can visualize
    how the event will travel up the DOM tree. When any of the URLs are clicked on,
    the travel will be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这样的事件只有在调用`on()`方法时才注册。在这种情况下，由于这个新元素在调用`.on()`时不存在，所以它不会获得事件处理器。根据我们对事件冒泡的理解，我们可以想象事件将如何在DOM树中向上传播。当点击任何一个URL时，传播将如下进行：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can create a delegated event as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下创建一个委托事件：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We moved `a` from the original selector to the second parameter in the `on()`
    method. This second parameter of the `on()` method tells the handler to listen
    to this specific event and check whether the triggering element was the second
    parameter (the `a` in our case). As the second parameter matches, the handler
    function is executed. With this delegate event, we are attaching a single handler
    to the entire `ul#list`. This handler will listen to the click event triggered
    by any descendent of the `ul` element.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把`a`从原来的选择器移动到了`on()`方法的第二个参数。`on()`方法的第二个参数使得处理程序监听这个特定的事件，并检查触发元素是否为第二个参数（在我们这个案例中的`a`）。由于第二个参数匹配，处理函数将被执行。通过这种委派事件，我们为整个`ul#list`添加了一个处理程序。这个处理程序将监听`ul`元素的任何后代元素触发的点击事件。
- en: The event object
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件对象
- en: 'So far, we attached anonymous functions as event handlers. To make our event
    handlers more generic and useful, we can create named functions and assign them
    to the events. Consider the following lines:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们为匿名函数添加了事件处理程序。为了使我们的事件处理程序更具通用性和可用性，我们可以创建命名函数并将它们分配给事件。考虑以下几行：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we are passing a named function instead of an anonymous function to the
    `on()` method. Let''s shift our focus now to the `event` parameter that we pass
    to the function. jQuery passes an event object with all the event callbacks. An
    event object contains very useful information about the event being triggered.
    In cases where we don''t want the default behavior of the element to kick in,
    we can use the `preventDefault()` method of the event object. For example, we
    want to fire an AJAX request instead of a complete form submission or we want
    to prevent the default location to be opened when a URL anchor is clicked on.
    In these cases, you may also want to prevent the event from bubbling up the DOM.
    You can stop the event propagation by calling the `stopPropagation()` method of
    the event object. Consider this example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们传递了一个命名函数而不是一个匿名函数给`on()`方法。现在让我们将注意力转移到我们传递给函数的`event`参数。jQuery为所有事件回调传递了一个事件对象。事件对象包含了有关触发的事件的非常有用的信息。在不想让元素的默认行为发生的情况下，我们可以使用事件对象上的`preventDefault()`方法。例如，我们希望在提交完整表单之前发起一个AJAX请求，或者在点击URL锚点时阻止默认位置的打开。在这些情况下，您可能还希望阻止事件在DOM上冒泡。您可以通过调用事件对象的`stopPropagation()`方法来停止事件传播。考虑以下示例：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Apart from the event object, you also get a reference to the DOM object on
    which the event was fired. This element can be referred by `$(this)`. Consider
    the following example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事件对象，您还可以获得一个对触发事件的DOM对象的引用。这个元素可以通过`$(this)`来引用。考虑以下示例：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about understanding JavaScript in its most important role—that
    of browser language. JavaScript plays the role of introducing dynamism on the
    web by facilitating DOM manipulation and event management on the browser. We discussed
    both of these concepts with and without jQuery. As the demands of the modern web
    are increasing, using libraries such as jQuery is essential. These libraries significantly
    improve the code quality and efficiency and, at the same time, give you the freedom
    to focus on important things.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲解的是JavaScript在其最重要的角色——浏览器语言中的使用。JavaScript通过在浏览器上实现DOM操作和事件管理，引入了网页的动态性。我们讨论了有无jQuery的情况下这两种概念。随着现代网页需求的增加，使用如jQuery的库变得至关重要。这些库能显著提高代码质量和效率，同时让你有更多的自由去关注重要的事情。
- en: We will focus on another incarnation of JavaScript—mainly on the server side.
    Node.js has become a popular JavaScript framework to write scalable server-side
    applications. We will take a detailed look at how we can best utilize Node.js
    for server applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注JavaScript的另一种化身——主要是服务器端。Node.js已经成为一个流行的JavaScript框架，用于编写可扩展的服务器端应用程序。我们将详细探讨如何最佳地利用Node.js进行服务器应用程序的开发。
