["```js\nvar eventData = {\n    type: 'app.click',\n    timestamp: new Date(),\n    target: 'button.next'\n};\n```", "```js\n// click-event.js\n// All instances will have \"type\" and \"timestamp\"\n// properties, plus any passed-in properties. What's\n// important is that anything using \"ClickEvent\"\n// knows that \"type\" and \"timestamp\" will always be\n// there.\nexport default class ClickEvent {\n\n    constructor(properties) {\n        this.type = 'app.click';\n        this.timestamp = new Date();\n        Object.assign(this, properties);\n    }\n\n};\n\n// main.js\nimport ClickEvent from 'click-event.js';\n\n// Create a new \"ClickEvent\" and pass it some properties.\n// We can override some of the standard properties,\n// and pass it new ones.\nvar clickEvent = new ClickEvent({\n    type: 'app.button.click',\n    target: 'button.next',\n    moduleState: 'enabled'\n});\n\nconsole.log(clickEvent);\n```", "```js\n// events.js\n// A simple event broker.\nexport default class Events {\n\n    // Accepts a \"log()\" function when created,\n    // used when triggering events.\n    constructor(log) {\n        this.log = log;\n        this.listeners = {};\n    }\n\n    // Calls all functions listening to event \"name\", passing\n    // \"data\" to each. If the \"log()\" function was provided to\n    // the broker when created, then it logs BEFORE each callback\n    // is called, and AFTER.\n    trigger(name, data) {\n        if (name in this.listeners) {\n            var log = this.log;\n            return this.listeners[name].map(function(callback) {\n                log && console.log('BEFORE', name);\n\n                var result = callback(Object.assign({\n                    name: name\n                }, data));\n\n                log && console.log('AFTER', name);\n\n                return result;\n            });\n        }\n    }\n};\n\n// main.js\nimport Events from 'events.js';\n\n// Two event callback functions that log\n// data. The second one is async because it\n// uses \"setTimeout()\".\nfunction callbackFirst(data) {\n    console.log('CALLBACK', data.name);\n}\n\nfunction callbackLast(data) {\n    setTimeout(function() {\n        console.log('CALLBACK', data.name);\n    }, 500);\n}\n\nvar broker = new Events(true);\n\nbroker.listen('first', callbackFirst);\nbroker.listen('last', callbackLast);\n\nbroker.trigger('first');\nbroker.trigger('last');\n\n//\n// BEFORE first\n// CALLBACK first\n// AFTER first\n// BEFORE last\n// AFTER last\n// CALLBACK last\n//\n// Notice how we can trace the event broker\n// invocation? Also note that \"CALLBACK last\"\n// is obviously async because it's not in between\n// \"BEFORE last\" and \"AFTER last\".\n```", "```js\n// events.js\n// The event broker. Sets sets the threshold\n// for event triggering frequency to 100\n// milliseconds.\nexport default class Events {\n\n    constructor() {\n        this.last = null;\n        this.threshold = 100;\n        this.size = 0;\n        this.listeners = {};\n    }\n\n    // Triggers the event, but only if the it meets the\n    // frequency threshold.\n    trigger(name, data) {\n        var now = +new Date();\n\n        // If we're passed the wait threshold, or we've never\n        // triggered an event, we can call \"_trigger()\", where\n        // the event callback functions are processed.\n        if (this.last === null || now - this.last > this.threshold) {\n            this._trigger(name, data);\n            this.last = now;\n        // Otherwise, we've triggered something recently, and we\n        // need to set a timeout. The \"size\" multiplier is\n        // for spreading out the lineup of triggers.\n        } else {\n            this.size ++;\n            setTimeout(() => {\n                this._trigger(name, data);\n                this.size --;\n            }, this.threshold * this.size || 1);\n        }\n    }\n\n    // This is the actual triggering mechanism, called by\n    // \"trigger()\" after it checks the frequency threshold.\n    _trigger(name, data) {\n        if (name in this.listeners) {\n            return this.listeners[name].map(function(callback) {\n                return callback(Object.assign({\n                    name: name\n                }, data));\n                return result;\n            });\n        }\n    }\n\n};\n\n//main.js\nimport Events from 'events.js';\n\nfunction callback(data) {\n    console.log('CALLBACK', new Date().getTime());\n}\n\nvar broker = new Events(true);\n\nbroker.listen('throttled', callback);\n\nvar counter = 5;\n\n// Trigger events in a tight loop. This will\n// cause the broker to throttle the callback\n// processing.\nwhile (counter--) {\n    broker.trigger('throttled');\n}\n//\n// CALLBACK 1427840290681\n// CALLBACK 1427840290786\n// CALLBACK 1427840290886\n// CALLBACK 1427840290987\n// CALLBACK 1427840291086\n//\n// Notice how the logged timestamps in each\n// callback are spread out?\n```", "```js\nimport Events from 'events.js';\n\n// These callbacks trigger \"logic\" events. This\n// small indirection keeps our logic decoupled\n// from event handlers that might have to perform\n// other boilerplate activities.\nfunction callbackFirst(data) {\n    data.broker.trigger('logic', {\n        value: 'from first callback'\n    });\n}\n\nfunction callbackSecond(data) {\n    data.broker.trigger('logic', {\n        value: 'from second callback'\n    });\n}\n\nvar broker = new Events();\n\nbroker.listen('click', callbackFirst);\nbroker.listen('click', callbackSecond);\n\n// The \"logic\" callback is small, and focused. It\n// doesn't have to worry about things like DOM\n// access or fetching network resources.\nbroker.listen('logic', (data) => {\n    console.log(data.name, data.value);\n});\n\nbroker.trigger('click');\n//\n// logic from first callback\n// logic from second callback\n```", "```js\n// events.js\nexport default class Events {\n\n    constructor() {\n        this.listeners = {};\n    }\n\n    // Triggers an event...\n    trigger(name, data) {\n        if (!(name in this.listeners)) {\n            return;\n        }\n\n        // We need this to keep track of the error state.\n        var error = false,\n            mapped;\n\n        mapped = this.listeners[name].map((callback) => {\n            // If the previous callback caused an error,\n            // we don't run any more callbacks. The values\n            // in the mapped output will be \"undefined\".\n            if (error) {\n                return;\n            }\n\n            var result;\n\n            // Catch any exceptions thrown by the callback function,\n            // and the result object sets \"error\" to true.\n            try {\n                result = callback(Object.assign({\n                    name: name,\n                    broker: this\n                }, data));\n            } catch (err) {\n                result = { error: true };\n            }\n\n            // The callbacks can throw an exception, or just return\n            // an object with the \"error\" property set to true. The\n            // outcome is the same - we stop processing callbacks.\n            if (result && result.error) {\n                error = true;\n            }\n\n            return result;\n        });\n\n        // Something went wrong, so we let other components know\n        // by triggering an error variant of the event.\n        if (error) {\n            this.trigger('${name}:error');\n        }\n    }\n\n}\n\n// main.js\nimport Events from 'events.js';\n\n// Callback fails by returning an error object.\nfunction callbackError(data) {\n    console.log('callback:', 'going to return an error');\n    return { error: true };\n}\n\n// Callback fails by throwing an exception.\nfunction callbackException(data) {\n    console.log('callback:', 'going to raise an exception');\n    throw Error;\n}\n\nvar broker = new Events();\n\n// Listens to both the regular events (the happy path),\n// and the error variants.\nbroker.listen('shouldFail', callbackError);\nbroker.listen('shouldFail:error', () => {\n    console.error('error returned from callback');\n});\n\nbroker.listen('shouldThrow', callbackException);\nbroker.listen('shouldThrow:error', () => {\n    console.error('exception thrown from callback');\n});\n\nbroker.trigger('shouldFail');\nbroker.trigger('shouldThrow');\n// callback: going to return an error\n// error returned from callback\n// callback: going to raise an exception\n// exception thrown from callback\n```"]