["```js\nvar promState = {\n pending: 1,\n fulfilled: 2,\n rejected: 3\n};\n```", "```js\nvar PromiseMe = {\n    //set default state\n myState: promState.pending,\n changeMyState: function(newState, newValue) {\n\n  // check if we are changing to same state and report it\n  if (this.myState == newState) {\n   throw new Error(\"Sorry, But you can't do this to me! You are transitioning to same state: \" + newState);\n  }\n\n  // trying to get out of the fulfilled or rejected states\n  if ( this.myState == promState.fulfilled ||\n    this.myState == promState.rejected ) {\n   throw new Error(\"You can't leave this state now: \" + this.myState);\n  }\n  // if promise is rejected with a null reason\n  if ( newState == promState.rejected &&\n    newValue === null ) {\n   throw new Error(\"If you get rejected there must be a reason. It can't be null!\");\n  }\n\n  // if there was no value passed with fulfilled\n  if (newState == promState.fulfilled &&\n    arguments.length < 2 ) {\n   throw new Error(\"I am sorry but you must have a non-null value to proceed to fulfilled!\");\n  }\n\n  //we passed all the conditions, we can now change the state\n  this.myState = newState;\n  this.value = newValue;return this.myState;\n }\n};\n```", "```js\nthen: function (onFulfilled, onRejected) {\n        // define an array named handlers\n        this.handlers = this.handlers || [];\n        // create a promise object to return\n        var returnedPromise = Object.create(PromiseMe);\n\n        this.handlers.push({\n            fulfillPromise: onFulfilled,\n            rejectPromise: onRejected,\n            promise: returnedPromise\n        });\n        return returnedPromise;\n    }\n```", "```js\nfulfillPromise: function (value) {\n//change state to fulfilled and return a promise with a value\n        this.changeMyState(promState.fulfilled, value);\n    },\nrejectPromise: function (reason) {\n//change state to rejected and return a promise rejected with a reason\n        this.changeMyState(promState.rejected, reason);\n    }\n```", "```js\n    resolve: function () {\n        // check for pending and exist\n        if (this.myState == promState.pending) {\n            return false;\n        }\n```", "```js\n// loop through each then as long as handlers array contains items\nwhile(this.handlers && this.handlers.length) {\n\n//return and remove the first item in array\nvar handler = this.handlers.shift();\n```", "```js\n//set the function depending on the current state\nvar doResolve = (this.myState == promState.fulfilled ? handler.fulfillPromise : handler.rejectPromise);\n```", "```js\nif (condition == true) result = \"pick me\"; else result = \"No! pick me instead\";\n```", "```js\nresult = (condition == true) ? \"pick me\" : \"No! pick me instead\";\n```", "```js\n//if doResolve is not a function\nif (typeof doResolve != 'function') {\nhandler.promise.changeMyState(this.myState, this.value);\n\n}\n```", "```js\nelse {\n//fulfill the promise with value or reject with error\ntry {\n```", "```js\nvar promiseValue = doResolve(this.value);\n```", "```js\n// deal with promise returned\n        if (promiseValue && typeof promiseValue.then == 'function') {\n```", "```js\n//invoke then on the promise\npromiseValue.then(function (val) {\n    handler.promise.changeMyState(promState.fulfilled, val);\n}, function (error) {\n    handler.promise.changeMyState(promState.rejected, error);\n});\n}\n```", "```js\n// if the value returned is not a promise\nelse {\nhandler.promise.changeMyState(promState.fulfilled, promiseValue);\n}\n```", "```js\n// deal with error thrown\n} catch (error) {\nhandler.promise.changeMyState(promState.rejected, error);\n   }\n}\n}\n}\n```", "```js\nvar that = this;setTimeout(function () {\n    that.handlers.push({\n         fulfillPromise: onFulfilled,\n         rejectPromise: onRejected,\n         promise: returnedPromise\n      });\n    that.resolve();\n }, 2);\n```", "```js\nvar PromiseMe = function () {\n    var promState = {\n        pending: 1,\n        fulfilled: 2,\n        rejected: 3\n    };\n    //check the enumeration of promise states\n\n    var PromiseMe = {\n        //set default state\n        myState: promState.pending,\n        changeMyState: function (newState, newValue) {\n\n            // check 1: if we are changing to same state and report it\n            if (this.myState == newState) {\n                throw new Error(\"Sorry, But you can't do this to me! You are transitioning to same state: \" + newState);\n            }\n\n            // check2: trying to get out of the fulfilled or rejected states\n            if (this.myState == promState.fulfilled || this.myState == promState.rejected) {\n                throw new Error(\"You can't leave this state now: \" + this.myState);\n            }\n            // check 3: if promise is rejected with a null reason\n            if (newState == promState.rejected && newValue === null) {\n                throw new Error(\"If you get rejected there must be a reason. It can't be null!\");\n            }\n            //check: 4 if there was no value passed with fulfilled\n            if (newState == promState.fulfilled && arguments.length < 2) {\n                throw new Error(\"I am sorry but you must have a non-null value to proceed to fulfilled!\");\n            }\n\n            // we passed all the conditions, we can now change the state\n            this.myState = newState;\n            this.value = newValue;\n            this.resolve();\n            return this.myState;\n        },\n        fulfillPromise: function (value) {\n            this.changeMyState(promState.fulfilled, value);\n        },\n        rejectPromise: function (reason) {\n            this.changeMyState(promState.rejected, reason);\n        },\n        then: function (onFulfilled, onRejected) {\n            // define an array named handlers\n            this.handlers = this.handlers || [];\n            // create a promise object\n            var returnedPromise = Object.create(PromiseMe);\n            var that = this;\n            setTimeout(function () {\n                that.handlers.push({\n                    fulfillPromise: onFulfilled,\n                    rejectPromise: onRejected,\n                    promise: returnedPromise\n                });\n                that.resolve();\n            }, 2);\n\n            return returnedPromise;\n        },\n        resolve: function () {\n            // check for pending and exist\n            if (this.myState == promState.pending) {\n                return false;\n            }\n            // loop through each then as long as handlers array contains items\n            while (this.handlers && this.handlers.length) {\n                //return and remove the first item in array\n                var handler = this.handlers.shift();\n\n                //set the function depending on the current state\n                var doResolve = (this.myState == promState.fulfilled ? handler.fulfillPromise : handler.rejectPromise);\n                //if doResolve is not a function\n                if (typeof doResolve != 'function') {\n                    handler.promise.changeMyState(this.myState, this.value);\n\n                } else {\n                    // fulfill the promise with value or reject with error\n                    try {\n                        var promiseValue = doResolve(this.value);\n\n                        // deal with promise returned\n                        if (promiseValue && typeof promiseValue.then == 'function') {\n                            promiseValue.then(function (val) {\n                                handler.promise.changeMyState(promState.fulfilled, val);\n                            }, function (error) {\n                                handler.promise.changeMyState(promState.rejected, error);\n                            });\n                            //if the value returned is not a promise\n                        } else {\n                            handler.promise.changeMyState(promState.fulfilled, promiseValue);\n                        }\n                        // deal with error thrown\n                    } catch (error) {\n                        handler.promise.changeMyState(promState.rejected, error);\n                    }\n                }\n            }\n        }\n    };\n    return Object.create(PromiseMe);\n};\n```", "```js\nvar multiplyMeAsync = function (val) {\n    var promise = new PromiseMe();\n    promise.fulfillPromise(val * 2);\n\n    return promise;\n};\nmultiplyMeAsync(2)\n    .then(function (value) {\n    alert(value);\n});\n```", "```js\nvar alertResult = function (value) {\n    alert(value);\n};\n```", "```js\nvar onError = function(errorMsg) {\n alert(errorMsg);\n};\n```", "```js\nvar divideAsync = function (val) {\n    var promise2 = new PromiseMe();\n    if (val == 0) {\n        promise2.rejectPromise(\"cannot divide by zero\");\n    }\n    else{\n        promise2.fulfillPromise(1 / val);\n    }\n    return promise2;\n};\n```", "```js\nmultiplyMeAsync(0)\n    .then(divideAsync)\n    .then(undefined, onError);\n```"]