- en: Chapter 2. JavaScript and HTML5 for Visualizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 JavaScript 和 HTML5 用于可视化
- en: 'In the previous chapter I mentioned that there have been some developments
    in HTML5 that have made visualizations far easier. This chapter is going to explore
    a couple of them, namely the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我提到了 HTML5 的一些发展使可视化变得更容易。这一章将探讨其中的一些，具体如下：
- en: Canvas
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画布（Canvas）
- en: Scalable Vector Graphics (SVG)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展矢量图形（SVG）
- en: If you're familiar with the functionality of these two tools, you might want
    to give this chapter a skip.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉这两个工具的功能，您可能想跳过这一章节。
- en: Canvas
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布
- en: Canvas is one of the features of HTML5 that gets the most play in technical
    articles and in demos. The things that can be done with canvas are very impressive,
    so it is no surprise that it appears so frequently. Canvas provides a low-level
    bitmap interface for drawing. You can think of it as Microsoft Paint in a browser.
    The images that are generated on the canvas are all raster images, meaning that
    the images are built from a grid of pixels rather than a set of geometric objects,
    as is the case in a vector image. Interaction with elements drawn on a canvas
    must be done through filters and global transformations; precise control is problematic
    if not impossible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 是 HTML5 的一个功能，在技术文章和演示中经常被提及。Canvas 所能实现的功能非常令人印象深刻，因此它频繁出现并不令人意外。Canvas
    提供了一个低级的位图接口用于绘图。您可以把它想象成浏览器中的 Microsoft Paint。画布上生成的所有图像都是光栅图像，这意味着图像是由像素网格而不是几何对象集合构建的，这与矢量图像的情况不同。与画布上绘制的元素交互必须通过过滤器和全局转换；精确控制如果可能的话会遇到问题。
- en: 'Creating a canvas element on your page is simple. You simply need to add an
    HTML element such as the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的页面上创建一个画布元素很简单。您只需要添加一个如下所示的 HTML 元素：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Packt 出版社网站上购买的图书的示例代码文件可以从您的账户[http://www.packtpub.com](http://www.packtpub.com)下载。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: You can also find all the code examples for this book at [https://github.com/stimms/SocialDataVisualizations](https://github.com/stimms/SocialDataVisualizations).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在这本书的所有代码示例中找到[https://github.com/stimms/SocialDataVisualizations](https://github.com/stimms/SocialDataVisualizations)。
- en: This will create a square canvas of 200 x 200 pixels. Should the browser being
    used not support the canvas element, the alternate text will be shown. Fortunately,
    it is pretty rare that you'll see this warning, as canvas has wide support. By
    the middle of 2013 canvas was available to 87 percent of Internet users. For the
    latest numbers, check out [http://caniuse.com/#feat=canvas](http://caniuse.com/#feat=canvas).
    This site also has browser support information for other HTML5 features. There
    is even support for mobile browsers on iOS, Android, BlackBerry, and Windows Phone.
    The only commonly used browsers that don't have support for canvas are versions
    of Internet Explorer prior to Version 9.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 200 x 200 像素的方形画布。如果使用的浏览器不支持画布元素，将显示替代文本。幸运的是，您看到这个警告的情况相当罕见，因为画布得到了广泛支持。到
    2013 年中，87% 的互联网用户可以使用画布。要获取最新的数字，请查看[http://caniuse.com/#feat=canvas](http://caniuse.com/#feat=canvas)。这个网站还提供了其他
    HTML5 功能的浏览器支持信息。在 iOS、Android、BlackBerry 和 Windows Phone 上，移动浏览器也有支持。唯一不支持画布的常用浏览器是
    Internet Explorer 的版本 prior to Version 9。
- en: 'If you''re in a situation where your target demographic makes heavy use of
    older Internet Explorer versions, all is not lost. There is a handy JavaScript
    **polyfill**; a downloadable piece of code that provides canvas functionality
    to older versions of Internet Explorer. The library is available at [https://code.google.com/p/explorercanvas](https://code.google.com/p/explorercanvas).
    To make use of it, a conditional include may be used, as shown in the following
    code snippet:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您处于目标受众广泛使用较旧的 Internet Explorer 版本的情况，不必过于担忧。有一个方便的 JavaScript **polyfill**；一段可下载的代码，为较旧的
    Internet Explorer 版本提供画布功能。这个库可以在[https://code.google.com/p/explorercanvas](https://code.google.com/p/explorercanvas)找到。要使用它，可以使用条件包含，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will only include `excanvas.js` if the browser running is an older version
    of Internet Explorer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有在运行的浏览器是较旧的 Internet Explorer 版本时，才会包含 `excanvas.js`。
- en: '**Excanvas** does not fully support canvas, with features such as shadows and
    3D missing, but the vast majority of the features are available. There is also
    a performance hit to using the JavaScript version of canvas, so, if you make use
    of animations, they may not be as smooth as they would on a modern browser. This
    is a small price to pay for reaching the remaining few percent of users. As browsers
    are updated, this problem will become less and less important.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Excanvas**并不完全支持画布，缺少阴影和3D等特性，但大部分功能都是可用的。使用JavaScript版本的画布也会有性能损失，所以，如果你使用动画，它们可能不会像现代浏览器上那样流畅。这是为了触及剩下的一小部分用户而付出的小小代价。随着浏览器的更新，这个问题会变得越来越不重要。'
- en: Drawing simple shapes on the canvas is easy, but there is also the power to
    draw some very complex objects, including drawing in 3D. We'll limit our discussion
    to some of the simpler shapes and functions that would be useful in creating visualizations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制简单形状是容易的，但也有能力绘制一些非常复杂的对象，包括绘制3D。我们将限制讨论一些更简单的形状和函数，这些函数在创建可视化时会有用。
- en: 'Before we get into drawing, we hold the introduction of the coordinate system
    for canvas. The origin of the coordinate system is located in the top-left corner
    and grows towards the bottom-right. To draw on the canvas, as shown in the following
    figure, JavaScript is used:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始绘制之前，我们介绍一下画布的坐标系统。坐标系统的原点位于左上角，向右下方增长。要在画布上绘制，如以下所示，使用JavaScript：
- en: '![Canvas](img/6542OS_02_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas](img/6542OS_02_01.jpg)'
- en: 'The first step in drawing is to get a handle for the instance of the canvas
    to which you would like to draw. You can, of course, have as many canvas elements
    on a page as you wish. Here, we''ll create a canvas with an ID of `demo`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制的第一步是获取一个画布实例的句柄，你想要在其中绘制。当然，你可以在页面上拥有尽可能多的画布元素。在这里，我们将创建一个ID为`demo`的画布：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now select the element using standard JavaScript methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用标准的JavaScript方法选择该元素：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternately, if you''re making use of a CSS selector library, such as jQuery,
    you can select the element using that:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你正在使用一个CSS选择器库，如jQuery，你可以使用那个来选择元素：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to get a reference to the drawing context itself. The context
    contains a collection of methods for drawing and will be what we use for all canvas
    operations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取对绘制上下文本身的引用。上下文包含了一组用于绘制的函数，我们将用它进行所有的画布操作：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Canvas supports a number of basic shapes from which it is possible to build
    complex objects. The simplest shape is the lowly rectangle. This can be created
    by calling the `strokeRect()` function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 画布支持多种基本形状，从中可以构建复杂的对象。最简单的形状就是矩形。可以通过调用`strokeRect()`函数来创建这个矩形：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will create a rectangle that starts at coordinates (20, 30) with a width
    of 100 pixels and a height of 50 pixels. In fact, this will draw the previously
    shown rectangle but shifted 20 pixels to the right and 30 pixels down. So, the
    signature for this method is to give the x, y coordinates for the starting point
    of the rectangle followed by the width and height. In addition to the `strokeRect()`
    function, there are `fillRect` and `clearRect`. When drawing on canvas, one can
    draw a stroke which is a line, draw a filled structure, or clear the content of
    an area.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个从坐标(20,30)开始的矩形，宽度为100像素，高度为50像素。实际上，这将绘制一个之前显示的矩形，但向右移动了20像素，向下移动了30像素。所以，这个方法的签名是给出矩形的x，y起始坐标，然后是宽度和高度。除了`strokeRect()`函数外，还有`fillRect`和`clearRect`。在画布上绘制时，可以画一个线条，画一个填充结构，或者清除一个区域的
    content。
- en: 'If rectangles aren''t your style, perhaps you would be more interested in drawing
    a circle? Canvas actually considers a circle to be a special case of an arc. Thus,
    to draw a circle with a radius of 50px, you need to specify not just the center
    point and radius, but also the starting and ending angle. The code for such a
    circle is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩形不是你的风格，也许你会更感兴趣地画一个圆？画布实际上认为圆是弧的一个特殊情况。因此，要画一个半径为50px的圆，你需要指定的不仅仅是中心点和半径，还有起始角度和结束角度。这样一个圆的代码如下：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the center point is given as (75, 75) and the radius 50\. The fourth term
    is the starting angle which we give as 0 and the `2*Math.PI` is the ending angle—the
    whole way round the circle. An optional final argument determines if the arc is
    to be drawn anti-clockwise. It defaults to `false` or `clockwise`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，中心点被指定为(75, 75)，半径为50。第四个术语是起始角度，我们给出为0，而`2*Math.PI`是结束角度——整个圆周。一个可选的最终参数确定是否按逆时针方向绘制弧。它默认为`false`或`顺时针`。
- en: 'Alerting the final parameter gives different arcs, as shown in the following
    screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 警告最终参数会给出不同的弧，如下面的屏幕截图所示：
- en: '![Canvas](img/6542OS_02_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![画布](img/6542OS_02_02.jpg)'
- en: As you can see, all of the angles used in canvas are denoted in radians. To
    convert from an angle in degrees to one in radians, you can multiply it by `Pi/180`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，画布中使用的所有角度都是以弧度表示的。要将角度（以度为单位）转换为弧度，你可以乘以`Pi/180`。
- en: 'For more complex shapes, canvas supports straight line or a path. To draw a
    line, you set a starting coordinate, then give an ending point, and then call
    the `stroke()` function. Canvas will extrapolate where to draw the line, as shown
    in the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的形状，画布支持直线或路径。要绘制一条线，你需要设置一个起始坐标，然后指定一个结束点，最后调用`stroke()`函数。画布会推断出在哪里绘制线条，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we start a new path; the pen is moved to (0, 0), then a line is drawn to
    (50, 120), and then the path is ended. It is important to begin and end your paths,
    or subsequent calls to `stroke()` functions will result in a continuation from
    the last point. You can think of it like using a pen; `beginPath` puts the pen
    on the piece of paper, `moveTo` temporarily lifts the pen and moves it, `lineTo`
    moves the pen to the destination and draws a line behind it, and finally `closePath`
    picks the pen back up off the paper. Without picking the pen up, the next time
    you draw a line to somewhere, the pen will already be on the paper and you'll
    get an extra line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们开始一个新的路径；笔移动到(0, 0)，然后绘制到(50, 120)的直线，然后结束路径。开始和结束路径很重要，否则后续调用`stroke()`函数将从最后一个点继续绘制。你可以把它想象成使用一支笔；`beginPath`把笔放在纸上，`moveTo`暂时抬起笔移动，`lineTo`把笔移动到目的地并绘制线条，最后`closePath`把笔从纸上拿起来。不拿起笔，下次你绘制到某个地方的线条时，笔已经在纸上了，你会得到多余的一条线。
- en: 'If you think the syntax for drawing a line is a bit arcane, you''re not alone.
    The multiple calls enable you to build more complex lines with several segments.
    By using a loop, we can build relatively complex shapes, as shown in the following
    code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为绘制线条的语法有些复杂，你并不孤单。多次调用使你可以构建具有多个段的更复杂线条。通过使用循环，我们可以构建相对复杂的形状，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code will generate a spiral. On each iteration of the loop, we move towards
    the center of the image by 4 pixels, one pixel on each edge. The result is as
    shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将生成一个螺旋。循环的每次迭代，我们向图像中心移动4个像素，每个边缘一个像素。结果如下面的屏幕截图所示：
- en: '![Canvas](img/6542OS_02_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![画布](img/6542OS_02_03.jpg)'
- en: The canvas maintains a state between calls to it, so, if you set the color of
    the fill using `context.fillStyle`, all subsequent calls to fill a shape will
    take on the same fill style. As you can probably imagine, this is a common source
    of bugs when building a visualization using canvas. It is especially problematic
    when calling functions to operate on the canvas.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 画布在调用之间保持状态，所以，如果你使用`context.fillStyle`设置填充颜色，所有后续的填充形状都将采用相同的填充样式。正如你所想象的，这在使用画布构建可视化时是一个常见的bug来源。特别是在调用操作画布的函数时，这个问题尤为严重。
- en: 'Fortunately, there is an easy solution: the context state can be saved and
    restored when entering and exiting a function. It is polite to keep your functions
    from messing around with a global state and will certainly reduce the number of
    bugs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单的解决方案：上下文状态可以在进入和退出函数时保存和恢复。保持你的函数不干扰全局状态是一种礼貌，这肯定会减少bug的数量：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the first line of the function, the current drawing context is pushed onto
    a stack and then it is restored on the last line of the function. By doing this,
    we can make as many changes to the context within the method as we like and rest
    assured that the context of the caller will not be corrupted.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第一行，当前的绘图上下文被推入一个堆栈，然后在函数的最后一行恢复。通过这样做，我们可以在方法内部对上下文进行尽可能多的更改，并确信调用者的上下文不会被破坏。
- en: 'Canvas has support for a full palette of colors and also allows for transparency
    and even gradients. So far, the examples have used color names. These names date
    way back to the mid 1990s and actually hail from the X11 windowing system. However,
    there are two other ways to specify a color for canvas. The first is by using
    a hexadecimal string that specifies the values for red, green, and blue as two-digit
    hexadecimals digits. The larger the value, the higher is the intensity of that
    color, as shown in the following figure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 支持完整的颜色调色板，还允许透明度和甚至渐变。到目前为止，示例中使用的是颜色名称。这些名称可以追溯到1990年代中期，实际上源自 X11
    窗口系统。然而，还有两种其他方法可以为 canvas 指定颜色。第一种是使用十六进制字符串，指定红色、绿色和蓝色的两个十六进制数字值。值越大，该颜色的强度越高，如下面的图所示：
- en: '![Canvas](img/6542OS_02_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas](img/6542OS_02_04.jpg)'
- en: 'The final, and my preference, is to use decimal RGB values, as shown in the
    following figure, which I think is far more readable and also easier to build
    programmatically:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种，也是我更喜欢的，是使用十进制 RGB 值，如下面的图所示，我认为这要清晰得多，而且编程时也更容易构建：
- en: '![Canvas](img/6542OS_02_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas](img/6542OS_02_05.jpg)'
- en: A slight variant on the decimal format is to use the `rgba` function instead
    of `rgb`. This adds an extra parameter, which is a decimal number between 0 and
    1, which denotes the opacity. 1 is fully opaque and 0 is completely transparent.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制格式上有一个轻微的变体，即使用 `rgba` 函数而不是 `rgb`。这增加了一个额外的参数，这是一个介于 0 和 1 之间的十进制数，表示不透明度。1
    表示完全不透明，0 表示完全透明。
- en: As canvas is a raster-based drawing system, it is possible to include most other
    raster files in it. Raster file formats include JPEG, PNG, GIF, and BMP. Being
    able to import an existing image can be a very handy tool for visualizations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 canvas 是一个基于栅格的绘图系统，因此可以在其中包含大多数其他栅格文件。栅格文件格式包括 JPEG、PNG、GIF 和 BMP。能够导入现有图像对于可视化来说是一个非常方便的工具。
- en: 'However, there are some caveats to using images on canvas. When you''re including
    an image, you can''t just load it from a URL directly. First, a JavaScript Image
    object needs to be created and the source of that image needs to be set to the
    URL. This Image object can then be used on the canvas:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 canvas 上使用图像有一些注意事项。当你包含一个图像时，你不能直接从 URL 加载它。首先，需要创建一个 JavaScript Image
    对象，并将该图像的来源设置为 URL。这个 Image 对象然后可以用于画布上：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Requesting images from another domain can be tricky. In order to maintain security
    in the browser requesting data, other domains are restricted. For images, you
    can request permission from the hosting domain to use the image by setting the
    `crossOrigin` property on the image:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他域请求图像可能会有点棘手。为了保持浏览器在请求数据时的安全性，其他域受到限制。对于图像，可以通过设置图像的 `crossOrigin` 属性来请求托管域的使用权限：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the value of the `crossOrigin` policy has been set to `anonymous`. This
    means that the browser won't pass on any authentication information to the server
    hosting the image. You can also set a value of user-credentials if you do want
    to pass credential information. Support for `crossOrigin` on images is relatively
    new, so you may do better to host the images on the same domain as the canvas.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`crossOrigin` 策略的值被设置为 `anonymous`。这意味着浏览器不会将任何身份验证信息传递给托管图像的服务器。如果您确实希望传递身份验证信息，也可以设置一个值为
    user-credentials。对图像的支持相对较新，所以您最好将图像托管在与 canvas 相同的域上。
- en: 'Because loading an image can take some time, it is not advisable to set the
    value of `src` on an image and immediately attempt to draw it on the canvas. Instead,
    you should hook into the `onload` event on the image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为加载图像可能需要一些时间，所以不建议在 image 对象的 `src` 上设置值，并立即尝试在画布上绘制它。相反，你应该连接到图像的 `onload`
    事件：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the `onload` function will prevent an empty image from being rendered
    to the canvas. If you're loading multiple images, the order in which they are
    loaded is indeterminate. You may wish to check that all images are loaded before
    continuing. Complex dependency chains can be managed using jQuery's `Deferred`
    functionality. The second and third parameter to `drawImage` is, predictably,
    the coordinates at which to draw the image. There are more advanced versions of
    `drawImage` that allow for scaling and cropping of an image before drawing it
    to the canvas.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `onload` 函数可以防止将空图像渲染到 canvas 上。如果您正在加载多个图像，它们被加载的顺序是不确定的。您可能希望检查所有图像是否已加载再继续。复杂的依赖链可以使用
    jQuery 的 `Deferred` 功能进行管理。`drawImage` 的第二和第三个参数，不出所料，是指定绘制图像坐标的。`drawImage` 还有更高级的版本，允许在将图像绘制到画布之前对图像进行缩放和裁剪。
- en: The final feature of canvas which we'll look at is the transformation. When
    composing more complex scenes or visualizations, it is frequently easier to build
    the object at a different scale, location, or orientation. Transformations provide
    a mechanism for altering the shapes you draw on canvas.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要看的画布特性是转换。当组合更复杂的场景或可视化时，通常更容易以不同的比例、位置或方向构建对象。转换提供了一种改变画布上绘制形状的机制。
- en: 'A function, in this context the scaling function, will multiply every coordinate
    by the x or y scaling factor. Canvas provides for independently scaling the x
    and y values. This means that it is easy to stretch a shape in just one direction:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中的函数，即缩放函数，将把每个坐标乘以x或y的缩放因子。画布为独立缩放x和y值提供了支持。这意味着很容易只在一个方向上拉伸形状：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code, which simply draw a series of three rectangles, will produce
    an output that looks like the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码，仅仅绘制了一系列三个矩形，将产生如下屏幕截图所示的输出：
- en: '![Canvas](img/6542OS_02_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas](img/6542OS_02_06.jpg)'
- en: You'll note that our scaling didn't just create larger images, it also multiplied
    the coordinates of the rectangles. The other thing to note is that the size increase
    doesn't seem to be uniform. That's because canvas is stateful. If you apply several
    scale functions in a series without resetting the scaling, each one will build
    on the last scaling. You can keep a track of your transformations and apply a
    reversing function. For instance, if you have scaled by 2, you can scale by the
    multiplicative inverse of 2, which is 1/2, to get back to the original scaling.
    It is more likely easier to save the context and restore it using the `save` and
    `restore` functions we spoke of earlier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们的缩放不仅仅是生成了更大的图像，它还放大了矩形的坐标。另外要注意的是，尺寸的增加似乎并不是均匀的。这是因为画布是状态ful的。如果你在系列中应用了几个缩放函数而没有重置缩放，每个都会建立在前一个缩放的基础上。你可以跟踪你的转换并应用一个逆转换函数。例如，如果你按2倍缩放，你可以按2的乘法逆，即1/2，来回到原始缩放。更可能的是，保存上下文并使用我们之前提到的`save`和`restore`函数恢复它要容易些。
- en: 'If we modify our function, you can see that the resulting image is very different,
    as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改我们的函数，你可以看到结果图像非常不同，如下面的屏幕截图所示：
- en: '![Canvas](img/6542OS_02_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas](img/6542OS_02_07.jpg)'
- en: 'Frequently, when applying a scaling transformation, you''ll want to apply a
    translation transformation to move the starting coordinates to where you expect
    them to be. You can do this by employing a translate transformation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 经常在应用缩放转换时，你会想应用一个平移转换来将起始坐标移动到你期望的位置。你可以通过使用平移转换来实现：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the highlighted line, we shift the canvas over so it is as if the rectangle
    is drawn at the origin. The order of the application of transformations is important,
    as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在突出显示的行上，我们将画布向右移动，使其好像矩形在原点处绘制。转换应用的顺序很重要，如下面的屏幕截图所示：
- en: '![Canvas](img/6542OS_02_08.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas](img/6542OS_02_08.jpg)'
- en: On the left-hand side, you can see the output of our code and on the right-hand
    side, the result of swapping the `translate` and `scale` operations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你可以看到我们代码的输出，在右侧，交换`translate`和`scale`操作的结果。
- en: There are a lot of other great features of canvas. Going into everything is
    just too much for a book of this length; it is most likely a book in its own right.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 画布还有很多其他很棒的特性。一一介绍实在太多，对于这么长的书来说；这很可能是一本自己的书。
- en: Scalable Vector Graphics
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可缩放矢量图形
- en: Scalable Vector Graphics, or as they are more commonly known, SVGs, are another
    feature relatively new to HTML. They fulfill a similar role to canvas, but differ
    by the fact that they are vector-based instead of raster-based. This means that
    every image is made up of a series of basic shapes. This might sound a bit like
    canvas, after all, we created all our canvas images using basic shapes. The difference
    is that with SVG, the basic shapes remain as distinct objects after they've been
    drawn. With canvas, the source commands used to create the image are lost as soon
    as it is rendered. The information about the source of the pixel is lost in a
    jumble of canvas commands.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可缩放矢量图形，或者如人们更常见的称呼，SVG，是HTML中相对较新的特性。它们执行的角色与画布类似，但不同之处在于它们是基于矢量而非位图的。这意味着每个图像都由一系列基本形状组成。这听起来可能有点像画布，毕竟，我们是用基本形状创建了所有的画布图像。不同的是，在SVG中，基本形状在绘制后仍然是独立的对象。而在画布上，创建图像的源命令在渲染后就会丢失。关于像素源的信息在画布命令的混乱中丢失。
- en: Conveniently, SVGs are stored as XML files. While I would typically not even
    consider the idea of storing anything but the combination to my safety deposit
    box, in such an inaccessible file format it does integrate nicely with HTML. Raster
    images are typically linked in a separate file from the HTML. SVGs can be embedded
    directly into the HTML document. This technique can be used to reduce the number
    of server trips necessary to render a page on a user agent. However, the real
    advantage is that it allows for the SVG to be integrated into the HTML **Document
    Object Model** (**DOM**), allowing you to manipulate the SVG using the same techniques
    you might use to manipulate any other element.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，SVG作为XML文件存储。虽然我通常连保险箱的组合锁都不会考虑存储，但这种难以访问的文件格式与HTML结合得很好。位图图像通常与HTML在单独的文件中链接。SVG可以直接嵌入到HTML文档中。这种技术可以减少在用户代理上渲染页面所需的服务器请求次数。然而，真正的优势在于它允许SVG集成到HTML
    **文档对象模型**（**DOM**）中，让你可以使用与操作任何其他元素相同的技巧来操作SVG。
- en: 'The source for a simple SVG may look like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单SVG的源代码可能如下所示：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can paste this into any HTML document and you''ll get a simple rectangle
    that looks like the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这复制到任何HTML文档中，你会得到一个如下截图所示的简单矩形：
- en: '![Scalable Vector Graphics](img/6542OS_02_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![可缩放矢量图形](img/6542OS_02_09.jpg)'
- en: The code is quite easy to understand, and the syntax should be familiar to anybody
    who has built a website. We first open new SVG element. Without any explicit sizing
    information the SVG fills its container. Inside of the SVG, we create a new rectangle
    with a width of 50px and a height of 150px. The outline of the rectangle is black
    and has a width of 2px while the inside is filled with a grey color.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当容易理解，其语法对于任何构建过网站的人来说都应该很熟悉。我们首先打开一个新的SVG元素。由于没有显式的尺寸信息，SVG会填满其容器。在SVG内部，我们创建了一个宽度为50px、高度为150px的新矩形。矩形的轮廓是黑色的，宽度为2px，而内部则填充了灰色。
- en: The primitives you can use to build your images should also be somewhat familiar,
    now that you've seen canvas in action. `rect` and `path` remain unchanged from
    canvas. However, SVG differs in its treatment of circles and provides an actual
    `<circle>` tag as well as an `<elipse>` tag for round shapes with two foci. `<polygon>`
    and `<polyline>` tags provide for drawing free-form straight-edged shapes with
    the polygon being a filled shape and the polyline being just a line. Should you
    desire a more curvy shape, SVG provides a `path` element that allows for defining
    complex curves and arcs. It is very tricky to build a curved path by hand. Typically,
    for curved paths you'll want to make use of an editor or an SVG library. Finally,
    SVG has support for writing text using the aptly named `<text>` element.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用来构建图像的基本元素应该对你来说现在有些熟悉，既然你已经看到了画布的实际应用。`rect`和`path`从画布继承而来，没有发生变化。然而，SVG在处理圆形方面有所不同，它提供了实际的`<circle>`标签，以及用于具有两个焦点的圆形形状的`<elipse>`标签。`<polygon>`和`<polyline>`标签用于绘制具有自由直边的形状，其中多边形是填充形状，而多段线只是一条线。如果你想要更弯曲的形状，SVG提供了一个`path`元素，允许定义复杂的曲线和弧。手工构建曲线路径非常棘手。通常，对于曲线路径，你会想使用一个编辑器或SVG库。最后，SVG支持使用恰当地命名为`<text>`的元素编写文本。
- en: 'Building multiple elements in SVG is as simple as adding another child to the
    SVG , as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在SVG中构建多个元素就像向SVG中添加另一个子元素一样简单，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in an image that looks like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致图像看起来像下面这样：
- en: '![Scalable Vector Graphics](img/6542OS_02_10.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![可缩放矢量图形](img/6542OS_02_10.jpg)'
- en: 'As you can see, the code is quite repetitive. On every single rectangle, we
    specify the `stroke` and `fill` information. This repetition can be eliminated
    in two ways. The first is to use a group of elements to define the styling information.
    SVG provides a generic grouping container which is denoted by the `<g>` tag. The
    styling information can be applied to that container instead of the individual
    elements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，代码相当重复。在每一个矩形上，我们都指定了`stroke`和`fill`信息。这种重复可以通过两种方式消除。第一种是使用一组元素来定义样式信息。SVG提供了一个通用的分组容器，由`<g>`标签表示。样式信息可以应用于该容器，而不是个别元素：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'An alternative is to use CSS to do the styling for you:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个替代方法是使用CSS为你完成样式设计：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, the styling information is attached directly to all elements
    of type `rect`. Typically, you would want to avoid using broad selectors such
    as these, as they will apply to all the SVG elements on the page. It is better
    to narrow the selectors either by making them apply to just that one SVG or, preferably,
    by assigning a class to the SVG elements you wish to style. It is generally preferred
    to style your elements, even those that are part of an SVG, using CSS. It is likely
    that your SVG will contain multiple rectangles that you don't want to take on
    the same styling.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，样式信息直接附加到所有类型为`rect`的元素上。通常，你希望避免使用像这样的广泛选择器，因为它们将应用于页面上的所有SVG元素。最好通过使它们仅适用于那个一个SVG，或者更佳，通过为希望样式的SVG元素分配一个类来缩小选择器。通常，建议使用CSS样式化你的元素，即使它们是SVG的一部分。你的SVG很可能包含多个你不想采用相同样式的矩形。
- en: 'The style properties (`fill,` `stroke`, and so on) used in the CSS do not differ
    from those used in in the SVG markup. More advanced CSS selectors are also available,
    such as `nth-child`, which selects just children matching a specific pattern.
    Consider the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中使用的样式属性（`fill,` `stroke`等）与SVG标记中使用的并无不同。还有更先进的CSS选择器可用，如`nth-child`，它仅选择匹配特定模式的子元素。考虑以下代码片段：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Adding the preceding code in our example will, very simply, create a zebra
    striping effect on our graph, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中添加前面的代码将非常简单地创建我们图形的斑马条纹效果，如下面的屏幕截图所示：
- en: '![Scalable Vector Graphics](img/6542OS_02_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![可缩放矢量图形](img/6542OS_02_11.jpg)'
- en: 'We can even get fancy and use CSS to add some interaction to our graph by simply
    specifying a `:hover` pseudo selector in the CSS and changing the color under
    the cursor:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更花哨地使用CSS通过在CSS中指定`:hover`伪选择器并改变光标下的颜色来为我们的图形添加一些交互：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following screenshot shows the resulting graph:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图展示了结果图形：
- en: '![Scalable Vector Graphics](img/6542OS_02_12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![可缩放矢量图形](img/6542OS_02_12.jpg)'
- en: Of course, having the SVG as part of the DOM opens other doors to factors other
    than styling. It is also possible to manipulate the elements of an SVG using JavaScript.
    You can even assign event listeners to the SVG elements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将SVG作为DOM的一部分打开了除了样式以外的其他门。还可以使用JavaScript操作SVG的元素。你甚至可以为SVG元素分配事件监听器。
- en: 'By making use of the fantastic jQuery library, we can easily add event listeners
    to the nodes in the graph SVG we''ve been building so far:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用出色的jQuery库，我们可以轻松地为到目前为止我们构建的图SVG中的节点添加事件监听器：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you've never seen jQuery before, what is happening here is that we're selecting
    all the `rect` elements on the page, and when a click is fired, it opens an alert
    box with the height of the column on which we clicked.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未见过jQuery，那么在这里发生的事情是，我们选择了页面上的所有`rect`元素，当点击事件触发时，它会打开一个带有我们点击的列的高度的警告框。
- en: Throughout this book, we'll be making extensive use of the jQuery library and
    this style of lambda-based programming. If you're not familiar with jQuery, it
    would be advisable to take a break and read some tutorials, such as [http://try.jquery.com/](http://try.jquery.com/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将广泛使用jQuery库和这种基于lambda的编程风格。如果你不熟悉jQuery，建议暂时停下来阅读一些教程，比如[http://try.jquery.com/](http://try.jquery.com/)。
- en: 'We''ve covered all the basic functionality of SVGs, but there is one advanced
    feature I''d like to mention: filters. **Filters** are transformations that can
    be applied to elements of an SVG. These filters go beyond the scaling and translation
    transformations we saw in canvas, although both `scale` and `translate` are supported
    in SVG. There are about 20 of these filters and each one performs different transformations.
    We won''t be able to go into each, but we''ll look at a couple of them.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了SVG的所有基本功能，但我想提一下的一个高级功能是：滤镜。**滤镜**是可以应用于SVG元素的转换。这些滤镜超越了我们在画布上看到的缩放和平移转换，尽管`scale`和`translate`在SVG中都是支持的。大约有20种这样的滤镜，每一种都执行不同的转换。我们不可能一个个深入讲解，但我们会看其中几个。
- en: 'One of the most common requirements in visualization is to give things a 3D
    feel. Full 3D can be very difficult, but we can trick the eye by using shadows.
    These shadows can be created using a combination of three different filters: offset,
    Gaussian blur, and blend.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化中最常见的需求之一就是给物体赋予立体感。完美的3D效果可能很难实现，但我们可以通过使用阴影来欺骗眼睛。这些阴影可以通过三种不同滤镜的组合来创建：偏移、高斯模糊和混合。
- en: 'To use a filter, we start by defining it. A `filter` element can be defined
    as a number of sequentially applied filters. To figure out what filters we need
    for a shadow, we can work backwards from the properties of a shadow. The first
    thing to notice is that shadows are offset from the things casting them. For this,
    we can use an offset filter that will shift the element in one direction or another.
    Where you want to shift the element depends on where your light source is. For
    our purposes, let''s say that it is above and to the left of the SVG. This will
    cast shadows down and to the right:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用滤镜，我们首先需要定义它。`filter`元素可以定义为一系列依次应用的滤镜。为了弄清楚给阴影需要哪些滤镜，我们可以从阴影的属性反向工作。首先要注意到的是，阴影是从
    casting 它们的东西上偏离的。为此，我们可以使用一个偏移滤镜，使元素向一个方向或另一个方向移动。你要将元素移动到哪里取决于你的光源位置。为了我们的目的，假设光源在SVG的上方和左侧。这将使阴影向下和向右投射：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On the filter line, we need to specify a height for our filtered element, which
    is greater than the original. If we don't do so, much of our shadow will be cut
    off as it extends beyond the boundary of the source object. Here we have given
    our filter an ID so it is easily applied later. You'll also note that we've specified
    an `in` and `out` property for `feOffset`. This allows us to chain the filters
    together. In our case, we're taking `SourceAlpha`, which is just the alpha, or
    the `transparency` property from the original image.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在滤镜属性行中，我们需要为被过滤的元素指定一个高度，这个高度要大于原高度。如果不这样做，我们的阴影会在超出源对象边界时被大量剪切掉。在这里，我们给滤镜指定了一个ID，以便以后容易应用。你还会注意到，我们为`feOffset`指定了`in`和`out`属性。这允许我们将滤镜串联起来。在我们的案例中，我们使用`SourceAlpha`，这只是原图的alpha，或者说是原图的`透明度`属性。
- en: 'Let''s apply this filter to just one element of our graph so we can see what
    is happening to it. I''ve removed the other styling so as not to confuse matters.
    The filter is applied by using the `filter` attribute and giving it the ID of
    the filter created previously:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个滤镜应用到我们图表中的一个元素上，看看它会发生什么变化。我已经移除了其他样式，以免混淆。滤镜通过使用`filter`属性并给出先前创建的滤镜的ID来应用：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following will be the result:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是结果：
- en: '![Scalable Vector Graphics](img/6542OS_02_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![可缩放矢量图形](img/6542OS_02_13.jpg)'
- en: 'Shadows are also fuzzier than the original image. This can be achieved by using
    a Gaussian blur filter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影也比原图更模糊。这可以通过使用高斯模糊滤镜来实现：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Gaussian filters randomly move points inside your image based on a normal distribution
    function. You might wish to play around with the standard deviation to achieve
    different blur effects; I found somewhere in the 8-12 range to be good for shadows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯滤镜会根据正态分布函数在图像内部随机移动点。你可能想尝试不同的模糊效果，我发现在8-12范围内的标准差对于阴影来说很不错：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we want to take the blurred black box we''ve created and combine it
    with the original:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要创建的模糊黑色盒子与原图结合：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Applying this filter on hover gives a very convincing pop-up effect when users
    hover over the image, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在悬停时应用这个滤镜可以产生非常逼真的弹出效果，如图所示：
- en: '![Scalable Vector Graphics](img/6542OS_02_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![可缩放矢量图形](img/6542OS_02_14.jpg)'
- en: SVG provides for easy manipulation of parts of an image though the styling tools
    that are already well known to you from your work with CSS. At the same time,
    being able to attach events to the image allows the creation of impressive user
    interaction.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SVG提供了通过你已经熟悉的CSS样式工具轻松操作图像部分的方法。同时，能够为图像附加事件允许创建令人印象深刻用户交互。
- en: Which one to use?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用哪个？
- en: Deciding whether to use canvas or SVG can be a difficult problem. It mostly
    comes down to which one feels more comfortable. Those with a background in computer
    graphics or animation are more likely going to be happier with canvas, as the
    `redraw` loop of canvas will be familiar. Canvas is better suited to redrawing
    entire scenes or even if you plan on using 3D elements. If your visualization
    makes use of textures or rendered images, canvas' ability to draw them to the
    canvas directly is almost certainly going to be advantageous. For visualizations
    that have some reliance on maintaining a fast frame rate, canvas is generally
    high performing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 决定是使用画布还是SVG可能是一个难题。这主要取决于哪一个更让人感到舒适。有计算机图形或动画背景的人可能会更满意画布，因为画布的`redraw`循环会更熟悉。画布更适合重新绘制整个场景，甚至如果你计划使用3D元素。如果你的可视化利用了纹理或渲染的图像，画布能够直接将它们绘制到画布上，这几乎肯定会是有优势的。对于那些对保持快速帧率有依赖的可视化，画布通常表现良好。
- en: On the other hand, SVG can be a much simpler technology to use. Each element
    in an SVG can be individually manipulated, which makes small animations far easier.
    The integration with the DOM allows for events to be fired on interaction with
    a single element of the SVG. To achieve that in the canvas, you must manually
    track what is being drawn at that location. That SVG can also be styled using
    CSS, which allows for components to be more easily reusable on sites with different
    themes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，SVG可以使用得更简单。SVG中的每个元素都可以单独操作，这使得小动画变得容易得多。与DOM的集成允许在与SVG的单个元素交互时触发事件。在画布上实现这一点，你必须手动跟踪在该位置正在绘制的内容。SVG也可以使用CSS进行样式设计，这使得组件更容易在具有不同主题的网站上重复使用。
- en: For the purposes of this book, we're going to focus on SVGs. The resolution
    independence of SVG coupled with the ease of use and fantastic support libraries
    makes it a logical choice. I don't believe there is a visualization we'll be creating
    that cannot be created with canvas but the effort would be far greater. This is
    doubly so for the interactive visualizations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们将关注SVG。SVG的分辨率独立性，加上易用性和出色的支持库，使其成为一个合理的选择。我不相信有任何可视化是我们不能用画布创造的，但努力要大得多。尤其是对于交互式可视化来说，更是如此。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You should now be able to make an informed decision between SVG and canvas-build
    simple static images. We're going to take a break from the visual aspects in the
    next chapter and talk about the OAuth protocol, which is used by many social media
    sites to protect their data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够做出明智的决定，在SVG和画布之间构建简单的静态图像。在下一章，我们将暂时离开视觉方面，谈谈OAuth协议，该协议被许多社交媒体网站用来保护他们的数据。
