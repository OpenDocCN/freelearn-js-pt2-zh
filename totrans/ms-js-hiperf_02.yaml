- en: Chapter 2. Increasing Code Performance with JSLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about confirming performance fixes in JavaScript,
    and we will also learn about JSLint. There are two very good JavaScript validation
    and optimization tools, and we will learn how to use both and how to set the options
    to get the best code performance optimization results.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are going to cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the JavaScript code performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is JavaScript linting?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSLint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the JavaScript code performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start talking about how to improve our JavaScript performance,
    we have to ask ourselves a hard question about what code improvements actually
    improve the JavaScript application speed. In the earlier days of JavaScript development,
    many performance improvements were mainly implemented based on known JavaScript
    coding standards, watching for global variables without the variable being declared,
    keeping the variable scope in line, and so on without much verification beyond
    anything visual inside a website.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we have new APIs to take advantage of this problem and scope solutions
    for small parts of our code.
  prefs: []
  type: TYPE_NORMAL
- en: About the console time API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve this issue, modern browsers implemented new console functions called
    `console.time` and `console.timeEnd`. What these two functions do is allow a developer
    to specify a label for the `console.time` and `console.timeEnd` functions, measure
    the amount of time a code block between the `time` and `timeEnd` instances would
    need to function, and finally, show the result in a console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to use `console.time()` and `console.timeEnd()` in
    a working example. Here, in our `02_01.js` example file, we have a simple code
    block creating 100 simple JavaScript objects using the `new` keyword inside a
    `for` loop, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About the console time API](img/7296OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see on line 5, we call the `console.time` function and, inside as
    its parameters, we have the `100 objects in For Loop` string label for our code
    block. We then add a `NewObj` object constructor on line 7\. Following that, we
    have a simple JavaScript `for` loop on line 11 that creates `100` instances of
    the `NewObj` constructor, passing in the value from each instance from the `for`
    loop on line 13\. Finally, on line 16, we end the time block with the `console.timeEnd`
    function, using the same label we declared at the start of the `time` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this code out in a browser; I''ll be using Google Chrome for this,
    but any modern browser, such as the latest version of Firefox, Internet Explorer,
    or Safari, should be fine. We''ll open `about:blank` in our browser''s URL so
    that we can have a simple test environment to work in, and then we will open our
    Web Inspectors or browser debuggers, paste the code snippet into our console,
    and press *Enter*. Here are the results that are displayed in my browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About the console time API](img/7296OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we take a look just before the `undefined` line in the output, we can see
    the label defined in the `console.time` function output: `100 objects in For loop:
    0.274ms`. So, with some hard data, we can visually see that the block of code
    we wrote takes the `0.274ms` JavaScript interpreter to process that bit of code.
    Great, but what happens if we tweak our code and make it more efficient, say,
    by changing our `for` loop to stop at `10` rather than `100`. Well, here''s an
    updated code sample for the `02_02.js` file in our example files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About the console time API](img/7296OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we changed the amount the `for` loop iterates on lines 5, 11, 12, and
    16; let''s run this code and see what happens as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About the console time API](img/7296OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now see that dropping our `for` loop to `10` iterations versus `100`
    iterations drops our processing time from `0.274ms` to `0.099ms`. We can visualize
    scaling this up to much larger applications knowing that this performance-testing
    API can be very helpful in evaluating performance in our JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: When to use console.time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `console.time()` method allows developers to have an understanding of what
    code affects performance and what doesn't. The `console.time()` method delivers
    results based on not only what browser you're using, but also what operating system
    and system hardware you're using. If you ran the preceding code snippets, they
    should be near the values given in this book but more than likely not the same
    by a small variation.
  prefs: []
  type: TYPE_NORMAL
- en: So, when using `console.time()`, think of them as a guide but not as a hard
    result. As we work through the book using the `console.time()` method, there may
    be some variation between the results listed here and what you experience depending
    on your work environment. What should be consistent is that you will be seeing
    performance improvements in general when using the `console.time()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now with our performance-testing knowledge in hand, we will start learning about
    common performance bottlenecks in JavaScript but, before we dig deep into these
    concepts, we are going to look at tools that help with the evaluation process.
  prefs: []
  type: TYPE_NORMAL
- en: What is JavaScript linting?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we talk about JSLint, we need to discuss linters in general, what they
    are, and how they influence JavaScript performance. A lint is, simply put, a code-validation
    checker. It allows a developer to point to a code file and check for errors or
    potential issues ranging from spacing issues to pure code errors.
  prefs: []
  type: TYPE_NORMAL
- en: Linters typically receive the contents of a file and build a source tree. In
    the case of JavaScript, this can be objects such as global variables, functions,
    prototypes, arrays, and so forth. After the tree is created, analyzers will take
    parts of the source tree and report anything an analyzer that was written would
    flag. Lastly, any rule readers or parameters flagged before running the linter
    will look for any options to ignore and generate a final report.
  prefs: []
  type: TYPE_NORMAL
- en: Common rule readers for JavaScript options would be settings such as checking
    for EcmaScript 3, allowing white space, allowing the `continue` keyword, allowing
    non-strict conditionals for the `if` statements, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: About JSLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSLint is a JavaScript code analysis tool that was written in JavaScript by
    Douglas Crockford, who also helped in popularizing JSON in software development.
    JSLint can be used in many ways, as mentioned in [Chapter 1](ch01.html "Chapter 1. The
    Need for Speed"), *The Need for Speed*. Many IDEs have features beyond just editing
    code; some of these features include things such as error checking and, in some
    cases, the IDEs use a version of JSLint.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter we will discuss how to use JSLint using the official JSLint
    online site at [http://www.jslint.com/](http://www.jslint.com/), as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About JSLint](img/7296OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using JSLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSLint is very easy to use with a site; all you need is some JavaScript and
    to paste your code file into JSLint. Let''s try a small code sample, as shown
    in the following screenshot and that you can reference in the example file as
    the `02_03.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using JSLint](img/7296OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s paste our code into the input box present at [http://www.JSLint.com](http://www.JSLint.com)
    and click on the **JSLint** button. Immediately, we should see a list of errors
    showing up on the site below the **JSLint** button, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using JSLint](img/7296OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'See also these remaining errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using JSLint](img/7296OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reviewing errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before looking at these errors, let''s look at the bottom of the error list;
    we will see an error: `Stopping. (52% scanned)`. This is a warning that JSLint
    found so many errors that the analyzer tools in JSLint simply gave up reviewing
    errors. It''s important to keep this error in mind when reviewing JSLint messages;
    as only 52 percent of the code was reviewed, additional errors may appear once
    we fix them.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now that we've understood JSLint's limitation, let's fix these errors.
    When working with JSlint, work through the error list top down, so error 1 is
    `Unexpected character '(space)'.`. Well, what does that mean? To explain, JSLint
    is *very* picky about the way spacing should be in JavaScript files. A JavaScript
    interpreter assumes a specific spacing within certain JavaScript objects and variables.
  prefs: []
  type: TYPE_NORMAL
- en: This empty space is displayed before any other errors in the code appear, so
    we can assume that this error comes before any code appears and, in fact, that
    is the case. If we look at the `02_03.js` file, actually line 4 is causing the
    issue, which is the space between the comment header and our `my_count` global
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring messy white space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can address our spacing errors in two ways: we can review each space and
    correct it line by line or, if we are using a minifier, we can tell JSLint to
    ignore empty and unnecessary lines. To do this, we will navigate to **Options**
    on the bottom of the page, and we will set the **messy white space** option to
    **true** *.* This will tell JSLint to ignore any spacing issues that aren''t directly
    associated with code interpretation, as indicated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring messy white space](img/7296OS_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once this is set to **true**, we will see a new panel appear under options,
    called **JSLint Directives**. The **JSLint Directives** panel provides a quick
    list of the parameters JSLint will pass in when reviewing code, before executing
    the validator. Seeing directives here is very helpful if we're trying to copy-and-paste
    this configuration in another instance of JSLint, say a build system… but more
    on this soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'With messy white space ignored, we can rerun JSLint on our code and see an
    updated list of errors, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring messy white space](img/7296OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we check how much of the code JSLint detected. This time, if we look at
    the last error, we can see that JSLint stopped at `84%`, which is much better
    than before, but we can do better here. Let's take a look at the first new error.
    At the top of the error list, we can see the error stating `'my_count' was used
    before it was defined.` This is line 5, character 1 in the **Errors** panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'This indicates that we forgot to declare `var` before our `my_count` variable,
    so let''s update it as shown in the following screenshot, adding `var` to `my_count`
    on line 5, and then let''s rerun JSLint. You can reference the update in the exercise
    files as `02_03_01` `.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring messy white space](img/7296OS_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, after rerunning JSLint with our updated code, let''s look at the next
    two lines. The first line states `Unexpected TODO comment`. This is pretty straightforward;
    in JSLint, we can specify allowing **TODO comments** in our JavaScript code, which
    is pretty handy! Let''s allow this as we are just improving our code in JSLint
    and are not completing the file for now. Take a look at the options I''ve highlighted,
    where you can set TODO to be allowed or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring messy white space](img/7296OS_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will now set **TODO comments** in the **Options** panel to **true**; next,
    let's take a look at the remaining errors.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the use strict statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, here''s what''s now left in our JSLint error list, shown in the following
    screenshot. The next error we see is `Missing ''use strict'' statement.`. Now,
    if you haven''t seen the `use strict` statement in JavaScript previously, I''ll
    explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the use strict statement](img/7296OS_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `use strict` statement is a hint to a browser to enable *strict mode* when
    reading JavaScript at runtime. This allows errors typically displayed as warnings
    to return as errors in our browser. One other advantage to using the `use strict`
    statement in our code is that it allows the JavaScript interpreter to run faster
    as it assumes the code has been optimized and bug-tested properly. This tells
    the JavaScript interpreter that code here has been written properly and the interpreter
    doesn't have to run as many checks on the code at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `use strict` statement isn''t hard to implement, and we can add it
    before any code inside every function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the use strict statement](img/7296OS_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also include it globally in the full JavaScript file by adding it above
    the first line of the code, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the use strict statement](img/7296OS_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One thing to know about the `use strict` statement with regard to JSLint is
    that JSLint *prefers* to set the `use strict` statement at the function level
    (shown previously in the first `use strict` example). The idea is that it properly
    sets the scope for the `use strict` statement as per the function for better code
    testing and analyzing, but both are correct in terms of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish up these remaining issues under our `TODO` comment; on line 9,
    we will add `"use strict"` followed by adding a semicolon to what would now be
    line 10 after our `console.log` statement. With that finished, it should resemble
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the use strict statement](img/7296OS_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using console in JSLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are nearly finished with this code. However, on executing it we get a list
    of errors in which the first line, which may seem odd, states: `''console'' was
    used before it was defined.` in the **Errors** panel. JSLint can validate JavaScript
    that may not be designed for a browser; this could be a Node.js script, for example.
    To enable browser objects, we need to enable the **console, alert, …** and **a
    browser** options in our JSLint **Options** panel; we can set these to **true**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using console in JSLint](img/7296OS_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With these enabled, lets rerun the script; the remaining errors should be straightforward.
    The first error complains that we should `Combine this with the previous 'var'
    statement.`. We can remove the `number1` and `number2` variables and simply assign
    `my_count = 42;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, our `if` statement could use some work. First, JSLint complains that
    we are using a loose conditional (a double equals for comparison) in our `if`
    statement. If we use triple equals for comparison, we compare the type as well.
    By doing this, our code will run the comparison faster than before. Also, the
    `if` statement doesn''t include brackets around the conditional code, and this
    can slow the interpreter down, so let''s add them. Our final code should resemble
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using console in JSLint](img/7296OS_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s re-run our finalized code thru JSLint and we should see a screen
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using console in JSLint](img/7296OS_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we now have no errors in JSLint, and we can also see a **Function
    Report** panel, indicating a variable scope as a note of what variables are global
    to the file and what variables and functions exist inside a function, including
    our anonymous function example.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap up this chapter, let's try the `console.time` method on both
    our `2_03_01.js` and `02_03_03.js` code files with the `console.time` function
    wrapped around. The time I get on my end for the former is `0.441ms`, and the
    optimized code with JSLint is `0.211ms`! Not bad; *double* the performance!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of the `console.time` and `console.timeEnd`
    methods, and we also learned about JSLint and how it can improve our JavaScript
    performance. In the next chapter, we will take a quick look at JSLint and get
    our hands dirty by integrating it into a build system!
  prefs: []
  type: TYPE_NORMAL
