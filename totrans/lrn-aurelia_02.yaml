- en: Chapter 2. Layout, Menu, and Getting Familiar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should have a good understanding of how to create an Aurelia
    application. The big picture is probably still vague, but details will keep emerging
    as we go through this chapter. We will first see how dependency injection and
    Aurelia's plugin system work, then we will see how to use, configure, and customize
    the Aurelia logger so we can trace and monitor what's going on in our code. Lastly,
    we will explore the Aurelia router and navigation model. Incidentally, we will
    keep scratching at templating, while we start building a real-life application
    by creating a global layout template and its navigation menu.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will build, step by step, an application. In each chapter,
    we will add both functional and technical features. It starts in this chapter.
    So before getting technical, let me first describe what our application will do.
  prefs: []
  type: TYPE_NORMAL
- en: We will be building a contact management application. This application will
    allow users to browse through contacts, perform searches, create, and edit entries.
    Of course, it will rely on an HTTP API to manage the data. This backend is available
    [https://github.com/PacktPublishing/Learning-Aurelia](https://github.com/PacktPublishing/Learning-Aurelia);
    it is a simple Node.js-based service. Just download it, unzip it in a directory,
    fire a console into that directory and run `npm install` to restore the required
    packages and then `npm start` to launch the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you should go and create an empty project with the Aurelia CLI, preferably
    using the default options. All the examples and code samples in this book having
    been built with the default CLI setup in mind; some code snippets won't work if
    you customize the project creation or use a skeleton instead. So in order to keep
    the learning process as smooth as possible, I strongly suggest you start with
    the default setup.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **SOLID** principles were first introduced by Robert C. Martin, a.k.a.
    Uncle Bob, in the early 2000s. The mnemonic acronym, later coined by Michael Feathers,
    contributed to the principles'' popularity. They describe five concerns at the
    core of good object-oriented design. Although the SOLID principles themselves
    are outside the scope of this book, we will dwell on one of them: dependency inversion.'
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle states that classes and modules should depend
    on abstractions. When a class depends on abstractions, it cannot be responsible
    for creating those dependencies, and they must be injected in the object. That's
    what we refer to as **dependency injection** (**DI**). It greatly increases decoupling
    and composability, and enforces a style of coding where graphs of objects are
    composed at the top of the hierarchy, at or near the application's entry point.
    The application's behavior can then be changed without modifying lots of code,
    just by changing how objects are composed at the application root.
  prefs: []
  type: TYPE_NORMAL
- en: However, manual creation of the whole object graph, or Poor Man's DI as Mark
    Seemann calls it, can quickly get tedious. This is where dependency injection
    containers come into play. A DI container, using both conventions and configuration,
    is able to understand how to create graphs of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Aurelia, almost all objects are provided by a DI container. This container
    has two responsibilities: creating and assembling objects and, afterwards, managing
    their lifetime. One way it can do this is by using metadata attached to the class
    it has to instantiate.'
  prefs: []
  type: TYPE_NORMAL
- en: The inject decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s imagine a `PersonListView` component displaying a list of people. The
    view-model requires a `PersonService` instance, used to retrieve a list of `Person`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/person-list-view.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a simple view-model, whose constructor expects a `personService`
    parameter. This parameter is then stored on an instance variable, so it can be
    used later. The view-model also has a `getPeople` method, which calls the `getAll`
    method on the `personService` to retrieve the list of people. If you're a familiar
    with object-oriented design and dependency inversion, there's nothing new here.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s interesting in this code snippet is the `inject` decorator on the `PersonListView`
    class. This decorator is imported from Aurelia and instructs the DI container
    to resolve an instance of `PersonService` and inject it as the constructor''s
    first parameter when creating a new instance of `PersonListView`. The important
    thing here is that the list of dependencies passed to the `inject` decorator matches
    the list of parameters expected by the constructor. If the class has multiple
    dependencies, you must pass them all to `inject` in the proper order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/person-list-view.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decorators are an ESNext feature; they are not currently supported by any browser.
    Additionally, Babel does not support them by default, so you need to add the `babel-plugin-transform-decorators-legacy`
    plugin if you want to use them in your code. A project created using the CLI comes
    with this setting already enabled.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript and autoinject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use TypeScript, using the `inject` decorator is pretty redundant when
    you specify the type of every dependency in the constructor declaration. To make
    things easier, Aurelia provides an `autoinject` decorator, which leverages type
    metadata added by the TypeScript transpiler to the transpiled JS classes.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use `autoinject`, you will first need to enable decorators and the
    metadata emission in TypeScript by setting `experimentalDecorators` to `true`
    in your `tsconfig.json` file, and then setting `emitDecoratorMetadata` to `true`
    in the `compilerOptions` section of the same file. A TypeScript project created
    by the CLI comes with these settings already enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of the same `PersonListView` using TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/person-list-view.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the DI container will know that, in order to create an instance of `PersonListView`,
    it first needs to resolve an instance of `PersonService` and inject it in the
    constructor of `PersonListView`, thanks to the `autoinject` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The static inject method or property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you aren''t using ESNext decorators nor TypeScript, or don''t want to have
    a dependency on Aurelia inside a given class, you can declare the dependencies
    of a class using a static `inject` method returning those dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/person-list-view.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The static `inject` method should return an array containing the class' dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a static `inject` property containing the dependency array is
    also supported. This is actually what happens behind the scene when you use the
    `inject` or `autoinject` decorators, they just assign the dependencies to a static
    `inject` property on the class. They are simply syntactic sugar.
  prefs: []
  type: TYPE_NORMAL
- en: Root and child containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Aurelia, a container can create child containers, which can themselves create
    their own children, forming a tree of containers starting from the application's
    root container. Each child container inherits the services of their parent, but
    can register their own to override their parent's.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*,
    an application starts with a root component. It also starts with a root container.
    When evaluating a view, the templating engine will create a child container each
    time it encounters a child component inside the view, may it be a custom element,
    an element with a custom attribute or a view-model created through routing or
    composition. The child component's view-model class will be registered as a singleton
    in the child container, which will then be used to resolve a child component instance.
    As this component's view is loaded and analyzed by the templating engine, the
    process goes on recursively. As the components are composed into a tree, so are
    the containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since child containers are created by the templating engine most of the time,
    it is likely that you will never have to manually create a child container. However,
    here''s an example of how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Resolving an instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resolution of an instance involves resolvers. We'll come back to those a little
    later to explain in more details how they work and how they are used, but in the
    meantime, think of them as strategies responsible for resolving a class instance
    requested by a DI container.
  prefs: []
  type: TYPE_NORMAL
- en: When resolving an instance, the root container first checks if it already has
    a `Resolver` for the class. If it does, this `Resolver` is used to acquire an
    instance. If no `Resolver` is found, the root container will automatically register
    a singleton `Resolver` for the class and use it to acquire an instance.
  prefs: []
  type: TYPE_NORMAL
- en: When resolving an instance using a child container, things are a little different.
    The child container still checks if it has a `Resolver` for the class and still
    uses it to acquire an instance if it does. However, if no `Resolver` is found,
    the child container will delegate resolution to its parent container. The parent
    will repeat this process until the instance is resolved or the resolution request
    goes up to the root container. When it does, the root container resolves the instance
    as described previously.
  prefs: []
  type: TYPE_NORMAL
- en: That means that instances of classes that are registered on the fly when first
    resolved are application singletons, because they are registered at the root container,
    so every child container will end up resolving to this single instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'View-models are resolved by the templating engine using a container, so you''ll
    mostly never have to manually resolve an instance. However, there are scenarios
    where you''ll want to inject a container in an object and manually resolve services.
    Here''s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here the `get` method is called with the `PersonService` class and returns an
    instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any object created by a container has a lifetime. There are three typical lifetimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container Singleton**: The container instantiates the class when it is first
    requested and then keeps a reference to that instance. Every other time an instance
    of the class is requested from the container, this same instance is returned.
    This means the instance''s life is tied to the container''s. It won''t be garbage
    collected until the container is discarded and no other object holds a reference
    to the instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Singleton**: A class registered as an application singleton is
    simply a container singleton registered in the application''s root container,
    so the same instance is reused throughout the whole application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transient**: When a class is registered as transient, the container will
    create a new instance each time an instance is requested. It will keep no reference
    to any of those instances. The container simply acts as a factory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to resolve an instance of a class, a container must first learn about
    it. This learning process is called registration. Most of the time, it is performed
    automatically and on the fly by the container when it receives a resolution request.
    It can also be performed manually, using the container's registration API.
  prefs: []
  type: TYPE_NORMAL
- en: The container registration API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Container` class offers multiple methods to manually register a class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method registers a class as a container singleton. The `key` will be used
    for lookup and the `fn` is expected to be the class that will be instantiated.
    If only the `key` is provided, it is expected to be a class because it will be
    used for both lookup and instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `container.registerSingleton(HttpClient)` registers the `HttpClient`
    class as a singleton. When resolving `HttpClient` for the first time, an instance
    will be created and returned. For each subsequent resolution request for `HttpClient`,
    this single instance will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, `container.registerSingleton(PersonService, CachingPersonService)`
    registers the `CachingPersonService` class using `PersonService` as the key. This
    means that when resolving the `PersonService` class, the single instance of `CachingPersonService`
    will be returned. This mapping is crucial when dealing with abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the fact that the class is a container singleton or an application
    singleton simply depends on whether the container upon which it is called is the
    application's root container or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method registers a class as transient, meaning that every time the `key`
    is requested, a new instance of `fn` is created. Just like with `registerSingleton`,
    `fn` can be omitted, in which case the `key` will be used both for lookup and
    instance creation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method registers an existing instance as a singleton. This is useful if
    you already have an instance and want to register it in the container. The only
    difference with `registerSingleton` is that instead of passing the class, you
    pass the actual single instance to use. If only the `key` is provided, it will
    be used both for look up and as the instance, but I can't really see scenarios
    where this would be useful, as you need to already have the value in order to
    look it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `container.registerInstance(HttpClient, myClient)` registers the
    `myClient` instance for the `HttpClient` class. Each time an `HttpClient` instance
    is requested from the container, the `myClient` instance will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method registers a custom handler, which is a function that will be called
    every time the container is requested for the `key`. This handler function will
    be passed the container, the `key` and the internal `Resolver` storing the handler.
    This allows support for multiple scenarios outside of the standard singleton and
    transient lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `container.registerHandler(PersonService, () => new PersonService(myConfig))`
    registers a factory function. Each time a `PersonService` instance is requested
    from the container, the handler function will be called and will create a new
    instance of `PersonService` using the captured value of `myConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method registers a custom `Resolver` instance. Behind the scene, all container
    methods we saw previously use this method with built-in resolvers. It is, however,
    possible to create our own `Resolver` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although keys are, most of the time, classes, they can be anything, including
    strings, numbers, symbols, or objects.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Automatic registration of a class is handled by the following class method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This method can be called with either a single parameter, being the class to
    register, or with two parameters, the first being the key under which the class
    must be registered and the second being the class to register. When only one parameter
    is passed, the class itself is used as the key.
  prefs: []
  type: TYPE_NORMAL
- en: The container automatically calls `autoRegister` when it tries resolve an instance
    of a class for which it can't find any resolver. It is rarely used directly by
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Registration strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The automatic registration process for a given class can be customized by attaching
    a `Registration` strategy to the class'' metadata. This can be done using one
    of the registration decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `transient` decorator will tell the `autoRegister` method
    that the `MyModel` class must be registered as transient, so every time a container
    must resolve a `MyModel` instance, it will create a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the `singleton(registerInChild: boolean = false)`
    decorator. When the `registerInChild` argument is `false`, which it is by default,
    this decorator tells the `autoRegister` method that the class should be registered
    as a singleton on the root container. This makes the class an application singleton,
    which is the container''s default behavior anyway, so using `singleton` with `registerInChild`
    set to `false` or left to its default value is kind of useless.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `singleton` with `registerInChild` set to `true` indicates that the
    class should be registered as singleton, not on the root container, but on the
    actual container on which the `autoRegister` method was called. This allows us
    to decorate a class so that each container has its own instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `MyModel` will be registered as a container singleton. Each
    container will have its own instance of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those two decorators rely behind the scene on `registration(registration: Registration)`.
    This third decorator is used to associate a `Registration` strategy to a class.
    It can be used if you create your own custom `Registration` strategy. It is used
    behind the scene by `transient` and `singleton` to attach one of the built-in
    `Registration` strategies to the class they decorate.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom registration strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A registration strategy must implement the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `autoRegister` method registers the class passed to it as an
    application singleton. However, when called for, a class having a `Registration`
    strategy attached to its metadata, `autoRegister` will delegate the class' registration
    to the `Registration`'s `registerResolver` method, which is expected to create
    a `Resolver` for the class, to register it in the container, and to return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a `registerResolver` method implementation will use the registration
    API of the `Container` instance passed as parameter to register the class. For
    example, the `registerResolver` method of the built-in `TransientRegistration`
    class, which is used behind the scene by the `transient` decorator, looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the method calls the container's `registerTransient` method, which creates
    a transient `Resolver`, and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Resolvers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously defined `Resolver` as strategies responsible for resolving instances.
    A container, when stripped to the bare minimum, simply manages a `Map` correlating
    `key` with their respective `Resolver`, which are created either by `Registration`
    strategies or by container registration methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally to being used when registering a service, resolvers can also be
    used when declaring a dependency: the `inject` decorator, so incidentally the
    `inject` static method or property, can be passed as `Resolver` instead of `key`.
    Like we saw earlier, during resolution of a `key` dependency, the container or
    one of its ancestors will find the `Resolver` for the key, or the root container
    will auto-register a singleton `Resolver`, and this `Resolver` will be used to
    resolve an instance. But when resolving a `Resolver` dependency, the container
    will directly use this `Resolver` to resolve an instance. This allows us to override
    a given class'' registered resolution strategy in the context of a specific injection.'
  prefs: []
  type: TYPE_NORMAL
- en: There are typically six resolvers that are useful during injection.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Lazy` resolver injects a function that, when evaluated, lazily resolves
    the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This means that resolution of `PersonService` is not performed during the creation
    of the instance, but rather when the `personServiceAccessor` function is called.
    This can be useful if the resolution needs to be delegated to a later time rather
    than when creating the object, or when the resolution must be re-evaluated multiple
    time during the object's lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: All
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the `Container` resolves to the first instance matching the requested
    key. The `All` resolver allows us to inject an array containing all the services
    registered for a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can imagine that multiple objects or classes have been registered using
    the `PersonValidator` key, and they are all injected as an array in the `PersonForm`
    view-model.
  prefs: []
  type: TYPE_NORMAL
- en: Optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Optional` resolver injects an instance only if a given key is already registered.
    If not, instead of auto-registering it, it will inject `null`. The second parameter,
    when omitted or set to `true`, makes the lookup for a resolver go up the container
    hierarchy. If set to `false`, only the current container will be checked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, an instance of `PersonService` is injected in the `PersonListView` constructor
    only if it was already registered in the current container. If not, `null` is
    injected instead.
  prefs: []
  type: TYPE_NORMAL
- en: Parent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Parent` resolver skips the current container and starts the resolution
    at the parent container. If the current container is the root container, `null`
    is injected instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Factory` resolver injects a factory function. Each time the factory function
    is executed, it will request a new instance from the container. Additionally,
    any parameters passed to this factory function will be passed to the class constructor
    by the container. If the class has dependencies, declared using any `inject` strategy,
    the additional parameters will be appended to the resolved dependencies when passed
    to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first see a `Person` class decorated with `inject`, which
    suggests to the container that its constructor needs an `AddressService` instance
    as its first parameter. We can also see that the constructor actually expects
    a second parameter called `address`, which the container knows nothing about.
    Next, we have a `PersonListView` class, decorated in such a way that a `Person`
    factory gets injected in its constructor. Its `createPerson` method, which is
    passed an `address`, calls the `Person` factory function with this address.
  prefs: []
  type: TYPE_NORMAL
- en: When called, in order to create an instance of `Person`, the container will
    first resolve an instance of `AddressService` to fulfill the `Person` dependencies,
    and will then call the `Person` constructor with the resolved `AddressService`
    instance and the `address` passed to the factory function.
  prefs: []
  type: TYPE_NORMAL
- en: NewInstance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NewInstance` resolver makes the container inject a new instance of the
    class each time, completely ignoring any existing registration for the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The plugin system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good understanding of how dependency injection works in Aurelia,
    we can start using it. Apart from being used for components creation and composition
    using `inject` and `Resolver`s, dependency injection is also central to Aurelia's
    plugin system.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost every part of Aurelia comes as a plugin. In fact, the `aurelia-framework`
    library is just a plugin system and configuration mechanism, and every other Aurelia
    core library comes and plugs in this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: An Aurelia plugin starts with an `index.js` file, which must export a `configure`
    function. This function will be called by Aurelia upon start up and will receive
    an Aurelia configuration object as its first parameter and an optional configuration
    callback function.
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s imagine a plugin named `our-plugin`. This plugin would first need to
    be enabled in the `configure` function of our `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**src/main.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, additionally to the standard application configuration, we tell Aurelia
    to load `our-plugin`. We also tell Aurelia to configure `our-plugin` using the
    callback provided as the second parameter of the `plugin` function. This callback
    receives a configuration object defined by `our-plugin` and we set its `debug`
    property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now imagine our plugin''s `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we could first create a default configuration object for our plugin and,
    if a configuration callback was provided, we would call it with our configuration,
    giving the user of our plugin the opportunity to change it. Then we could register
    our configuration object as the single instance of the `OurPluginConfig` class.
    We can then imagine that services exposed by `our-plugin` would have a dependency
    on this `OurPluginConfig`, so when they are instantiated by the container, they
    would have injected the configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: Registering global resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using this `configure` function, any plugin can register its own services,
    or even alter or override services declared by other plugins. It can also register
    resources for the templating engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, a plugin registers a resource named `my-component`. This resource may
    be different things; we will cover templating resources in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plugins are a great way to structure and decouple code. But plugins sit as project
    dependencies, with external libraries. For example, when using the CLI, plugins
    sit in the `node_modules` directory. In a typical project, the code sitting there
    is not version controlled. This code must not be modified as part of the project.
    It doesn't actually belong with the project; it is managed by someone else or,
    at least, in a distinct project workflow.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we would like to structure our own application like this? Using
    the plugin mechanism makes this pretty complicated, because we need to consider
    our different plugins as separate projects, and package them individually, then
    install them on our application. Each time a change is required in one of the
    plugins, it needs to be changed individually, then released and its dependency
    updated in the application. Although it's sometimes useful to share common components
    or behaviors used in multiple projects, this workflow is more complicated and
    adds a burden on the development process when not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Aurelia has a solution for this, features. A feature works exactly
    like a plugin, but it is located inside the application. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/my-feature/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**src/main.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Features work the exact same way plugins do, except that we use the `feature`
    method instead of the `plugin` method to load them and that they sit inside the
    `src` directory. Like a plugin, a feature is expected to have an `index.js` file
    at its root, which should export a `configure` function. Like a plugin, it can
    be passed a configuration callback as the second parameter of the `feature` method,
    and this callback will be passed to the `configure` function of `feature`.
  prefs: []
  type: TYPE_NORMAL
- en: The `feature` method expects the relative path to the directory containing the
    feature's `index.js` file. For example, if my feature sits at `src/some/path/index.js`,
    the call to load it would be `feature('some/path')`.
  prefs: []
  type: TYPE_NORMAL
- en: Features are a great way to organize your code. They make it easier to break
    down what could be a huge, monolithic application into a well-designed set of
    modules. Of course, it all depends on the design skills of the development team.
    In [Chapter 6](ch06.html "Chapter 6. Design Concerns - Organizing and Decoupling"),
    *Design Concerns - Organizing and Decoupling*, we will go over some patterns,
    strategies and ways to organize code to build better Aurelia applications.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aurelia comes with a simple yet powerful logging system. It supports log levels
    and pluggable appenders.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure logging, at least one log appender must be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '**src/main.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, an instance of the `ConsoleAppender`, imported from the `aurelia-logging-console`
    library, is first added to the logging module. This appender simply outputs the
    logs to the browser's console.
  prefs: []
  type: TYPE_NORMAL
- en: At least one appender must be added for logging to work. If no appender is added,
    the logs will simply be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the log level is set to `info`. This means that all logs with a lower
    level won''t be dispatched to the appenders. Aurelia supports four log levels,
    from lowest to highest: `debug`, `info`, `warn`, and `error`. For example, setting
    the minimal log level to `warn` means that `debug` and `info` logs will be ignored.
    Additionally, a `none` log level is available. When set, it simply performs no
    filtering at all and dispatches all logs to the appenders.'
  prefs: []
  type: TYPE_NORMAL
- en: Default configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous example was intended to show a fully customized setup. Instead,
    you can use the `developmentLogging` method when configuring your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**src/main.js**`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This default configuration installs the `ConsoleAppender` and sets the log level
    to `none`.
  prefs: []
  type: TYPE_NORMAL
- en: An appender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Appenders must implement a simple interface, with one method for each log level.
    For example, here is Aurelia''s `ConsoleAppender` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each method receives first the logger that initiated the log,
    followed by the arguments passed to the logger's logging method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write logs, you first need to acquire a logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `getLogger` method expects the name of the logger, and returns the logger
    instance. If no logger exists for the provided name, a new one is created. Loggers
    are singletons, so the same instance is always returned for a given name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a logger instance, you can call one of its four logging methods:
    `debug()`, `info()`, `warn()`, or `error()`. Each of these methods will dispatch
    a call to the corresponding level method on all appenders, assuming the method''s
    log level is equal or greater than the configured minimum log level. Otherwise,
    the appenders are not called and the log is discarded.'
  prefs: []
  type: TYPE_NORMAL
- en: The logger methods can be passed any number of arguments, and these arguments
    will be dispatched to the appenders. For example, when calling `error('A message',
    12)` on the logger, the call will be delegated to the appenders' as `appender.error`(`logger,
    'A message', 12)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all loggers are configured with the global log level. However,
    loggers also have a `setLevel` method, which allows to set a different log level
    for a single logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Except for really simple cases, a typical single-page application is made of
    multiple views. Most of the time, such an application has some fixed, global layout
    comprising a variable area that displays the current view and a menu that allows
    the user to navigate from one view to another. In Aurelia, those features are
    supported by the router plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable routing, make sure your application depends on the `aurelia-router`
    and the `aurelia-templating-router` libraries as CLI-based projects do by default.
    Then load the router plugin in the `configure` function of your `main.js` file,
    by either loading the whole `standardConfiguration()`, which includes the router,
    or by loading the `router()`individually. See [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*, for more information about how to load plugins in
    the application `configure` function.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by adding a `configureRouter` method to our root component. When
    Aurelia detects this callback method on a component, it calls it as part of the
    component initialization cycle. This method receives two parameters: a router
    configuration object and the router itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the `configureRouter` method, we start by assigning the router to an instance
    variable. This is important, because our root component's view will need to access
    the router to render the menu and the active route component.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we set the global title. This value will be displayed in
    the browser's title bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we configure two routes using the `map` method. A route configuration
    is basically a mapping between a URL path pattern which, when matched, causes
    the route to be activated, and a component, which is displayed when the route
    is activated. It also contains other properties. Let''s decompose a route configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `route` property is the URL path pattern. It is important to notice that
    the patterns omit the path''s leading slash. There are three types of patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static routes**: The pattern matches the path exactly. The first pattern
    of our first route is an example of this: it matches the root path (`/`) which,
    since the leading slash is omitted, matches an empty string. This makes it the
    default route.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameterized routes**: The pattern matches the path exactly, and the parts
    of the path matching the placeholders, prefixed by a colon (`:`), are parsed as
    route parameters. The value of those parameters are made available to the route
    component as part of the screen activation life cycle. The pattern of our second
    route is an example of this: it matches paths starting with `/contacts/`, followed
    by a second part interpreted as the contact''s `id`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Additionally, a route parameter can be made optional by adding a trailing question
    mark to it. For example, the `contacts/:id?/details` pattern would be matched
    by both `/contacts/12/details` and `/contacts/details`. When the parameter is
    omitted in the path, the corresponding parameter passed to the route component
    will be `undefined`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Wildcard routes**: The pattern matches the beginning of the path, and the
    rest of the path is considered a single parameter, whose value is made available
    to the route component as part of the screen activation life cycle. For example,
    the `my-route*param` pattern will match any path starting with `/my-route` and
    `param` will be a parameter whose value is the rest of the matched path.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` property uniquely identifies the route. We will see later how to
    use it to generate the URL of the route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `moduleId` property is the path of the route component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `nav` property, when set to a `true` value, tells the router to include
    this route in its navigation model, which is used to automatically build the application's
    navigation menu. Additionally, if `nav` is a number, the router will use it to
    sort the items in the navigation menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `title` property will be displayed in the browser's title bar when this
    route is active, unless the component overrides it. It is also used as the text
    of the menu item for the route if `nav` is `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `settings` property is optional, and can contain arbitrary data that can
    be used by activated components or pipeline steps, which we'll see later in this
    chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection route
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of a `moduleId`, a route can declare a `redirect` property. When such
    a route is activated, the router will perform an internal redirection to the path
    represented by the value of this property. This allows an alternative to the multiple
    patterns technique to declare a default route, as illustrated by our first route.
    Instead, we could declare the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The main difference with this configuration is that, when accessing `/`, the
    URL in the browser address bar will change to `/contacts`, because the router
    will perform a redirection.
  prefs: []
  type: TYPE_NORMAL
- en: When using this pattern, the `nav` property should be made `true` only on the
    target route. If it is set on the redirection route and not the target route,
    the router won't be able to highlight the corresponding menu item because the
    route is technically activated for just a brief moment before the target route
    is in turn activated. Finally, making it `true` on both the redirection route
    and its target route would cause both to be rendered in the menu, which is kind
    of pointless, because they both lead to the same place.
  prefs: []
  type: TYPE_NORMAL
- en: If the `nav` property is `false`, then setting the `title` is also pointless,
    since the route never stays activated long enough for the title to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: However, setting a `name` on a redirection route may be useful. When a redirection
    is expected to change in the future, links can be generated using the redirection
    route's `name` instead of the target route's. This way, the route's `redirect`
    property is the only thing that needs to change and every link that depends on
    this route will follow.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alternatively to the `moduleId` and `redirect` properties, a route can have
    a `navigationStrategy` property. Its value must be a function that will be called
    by the router and passed a `NavigationInstruction` instance. This object can then
    be configured dynamically. For example, our last route could be configured like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, this route does the same thing as it did before. But for scenarios
    requiring more flexibility than `moduleId` and `redirect` can offer, this alternative
    can become handy, as a `NavigationInstruction` instance contains the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config`: The configuration object of the route being navigated to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fragment`: The URL path that triggered the navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: An object containing a property for each parameter extracted from
    the route pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parentInstruction`: The instruction of the parent router, if this router is
    a child router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plan`: The navigation plan, built and used internally by the router to perform
    navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previousInstruction`: The navigation instruction which the current instruction
    will replace in the router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryParams`: An object containing the values parsed from the query string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryString`: The raw query string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewPortInstructions`: The viewport instructions, built and used internally
    by the router to perform navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying out our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on its routes configuration, the router generates a navigation model that
    can be used to automatically generate a navigation menu. Thanks to this, when
    adding new routes, we don't have to change both the route's configuration and
    the menu view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our root component''s view-model is the one responsible for declaring
    the routes, it just makes sense for its view to be the global layout and render
    the navigation menu. Let''s use this navigation model and create our root component''s
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The interesting parts in this template are highlighted. Let's go over them.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that we require a file named `app.css`, which we
    will write in a moment. This file will style our app component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the view uses the `router` property, defined in the `configureRouter`
    method of our root component's view-model. We first see it inside the `a` tag
    with the `nav-brand` class, where a string interpolation instruction renders the
    document title.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we find a `repeat.for="row of router.navigation"` attribute on a `li`
    tag. This binding instruction repeats the `li` tag for each item in the `router.navigation`
    array. This `navigation` property contains the router's navigation model, built
    using the route's truthy `nav` property. When rendering each `li` tag, a `row`
    variable containing the current navigation model item is available in the template
    engine's binding context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `li` tag additionally has a `class="${row.isActive ? ''active'' : ''''}"`
    attribute. This string interpolation instruction uses the current navigation model
    item''s `isActive` property. It assigns an `active` CSS class to the `li` tag
    if `isActive` evaluates to a `true` value. This property is managed by the router
    and is `true` only if the navigation model item belongs to the active route. In
    this template, it is used to highlight the active menu item.'
  prefs: []
  type: TYPE_NORMAL
- en: The anchor inside the `li` tag has a `href.bind="row.href"` attribute. This
    instruction binds the tag's `href` attribute to the `href` property of the current
    navigation model item. This `href` property is built by the router using the route's
    path pattern. Additionally, inside the anchor, the route's `title` is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of the menu, we can see a `li` tag with a `loader` CSS class.
    This element contains a spinner icon. It has an `if.bind="router.isNavigating"`
    attribute, which binds the presence of this element in the DOM with the value
    of the router's `isNavigating` property. This means that when the router is performing
    a navigation, a spinner icon will be visible in the top right corner of the application.
    When no navigation is occurring, the icon is not only invisible, it is actually
    not even present in the DOM, thanks to the `if` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `router-view` element acts as the router viewport and displays the
    active route component. This is the only required part in this whole template.
    When a component configures a router, its view must contain a `router-view` element,
    otherwise an error will be thrown. Exploiting the navigation model is optional,
    a menu can be static, or built by any other means you can imagine. Displaying
    the title is also optional. Leveraging the `isNavigating` indicator is absolutely
    not mandatory. However having a component configure a router is completely pointless
    if its view cannot display the active route component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This view uses a structure that you may be familiar with if you''ve ever worked
    with Bootstrap. Bootstrap is a CSS framework developed by Twitter, and we will
    use it in our application. Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to load it in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `app` component is still missing one last piece before it can work, the
    `app.css` file. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Trying it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, if you run our application, you should see a router error in
    your browser console. That's because the default route tries to load the `contact-list`
    component, which doesn't exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just create it and leave it empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-list.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`src/contact-list.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now if you try and run the application again, you should see the application
    load correctly, display the top menu and the empty `contact-list` component.
  prefs: []
  type: TYPE_NORMAL
- en: The screen activation life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the router detects a URL path change, it goes through the following life
    cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: The target route is identified. If no route matches the new path, an error is
    thrown and the process stops here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A chance is given to the active route component to refuse deactivation, in which
    case the router restores the previous URL and stops the process here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A chance is given to the target route component to refuse activation, in which
    case the router restores the previous URL and stops the process here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The active route component is deactivated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target route component is activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The views are swapped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Components, in order to opt in this life cycle, can implement any of the following
    callback methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canActivate(params, routeConfig, navigationInstruction)`: Called at step #2
    to know if the component can be activated. Can return a `boolean` value, a `Promise`
    of a `boolean` value, a navigation command, or a `Promise` of a navigation command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activate(params, routeConfig, navigationInstruction)`: Called at step #5,
    when the component gets activated. Can optionally return a `Promise`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canDeactivate()`: Called at step #3 to know if the component can be deactivated.
    Can return a `boolean` value, a `Promise` of a `boolean` value, a navigation command,
    or a `Promise` of a navigation command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deactivate()`: Called at step #4, when the component gets deactivated. Can
    optionally return a `Promise`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Promise`s are supported through the whole life cycle. This means that when
    any of the callback methods returns a `Promise`, the router will wait for its
    resolution before continuing the process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `canActivate` and `activate` both receive arguments related to
    the navigation context:'
  prefs: []
  type: TYPE_NORMAL
- en: The `params` object will have a property for each parsed parameter in the route
    pattern, as well as a property for each query string value. For example, our `contact-details`
    component will receive a `params` object with an `id` property. Optional parameters
    that have no value in the matched path will be `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `routeConfig` will be the original route configuration object, with an
    additional `navModel` property. This `navModel` object has a `setTitle(title:
    string)` method, which can be used by the component to change the document title
    to a dynamic value, such as data loaded during activation. We will see more of
    this when we start building our data display components in [Chapter 3](ch03.html
    "Chapter 3. Displaying Data"), *Displaying Data*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `navigationInstruction` is the `NavigationInstruction` instance used by
    the router to perform the navigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `canDeactivate` and `canActivate` can both cancel the navigation if
    they return `false`, a `Promise` resolving to `false`, a navigation command or
    a `Promise` resolving to a navigation command.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A navigation command is an object with a `navigate(router: Router)` method.
    When a navigation command is returned from `canDeactivate` or `canActivate`, the
    router cancels the current navigation and delegates control to the command. Aurelia
    ships with a single navigation command out of the box: `Redirect`. Here''s an
    example of how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/contact-details.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the `canActivate` callback method, the `ContactDetails` view-model
    tries to load a contact by its `id`. If the `Promise` returned by `getById` is
    rejected, the user is redirected to an `error` route.
  prefs: []
  type: TYPE_NORMAL
- en: Handling unknown routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the router cannot match the URL path to any route, it throws an error.
    But before raising this error, it first delegates the navigation instruction to
    an unknown route handler, if any. This handler can be configured using the `mapUnknownRoutes`
    method, which can take one of the following values as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: The path of the component to display instead of throwing an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A route configuration object, containing either a `moduleId`, a `redirect`,
    or a `navigationStrategy` property. The router will delegate navigation to this
    route instead of throwing an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function receiving the `NavigationInstruction` instance and returning the
    path of the component to display instead of throwing an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s implement a `not-found` component that our application will display
    when a link is broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/not-found.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`src/not-found.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In our root component, we simply need to add the highlighted line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Any time the router is unable to match the URL path to an existing route, our
    `not-found` component will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another option offered by `mapUnknownRoutes` is to use conventions for routing
    instead of a set of statically defined routes. If all of your routes follow the
    same naming pattern between the path and the `moduleId`, we could imagine having
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, the routing is relying on a convention that is to be implemented by the
    `getComponentForRoute` function, which receives the URL path that triggered navigation
    and returns the path of the component that must be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Activation strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When multiple static routes lead to the same component and a navigation between
    two of those routes occur, the router just keeps the same component instance.
    Because of this, the activation life cycle is not executed. This behavior is determined
    by the activation strategy. The `activationStrategy` enumeration has two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`replace`: Replace the current route with the new one, keeping the same component
    instance, without going through the activation life cycle. This is the default
    behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invokeLifecycle`: Go through the activation life cycle even though the active
    component does not change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways to change this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: In the configuration object of a route, you can add an `activationStrategy`
    property specifying which strategy should be used when activating this route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the route component's view-model, you can add a `determineActivationStrategy`
    method, which must return the strategy to be used for all routes displaying this
    component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Child routers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like DI, containers can have children and form a container tree; just like
    components can include child components and form a component tree, routers can
    also have children. This means that a route component's view-model can have its
    own `configureRouter` method, and its view a `router-view` element. When such
    a component is encountered, the router will create a child router for this sub-component.
    The route patterns of this child router will be relative to the parent route's
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: This allows for an application to have a navigation tree, with multiple levels.
    We will see how to leverage this feature when we discuss how to organize a large
    application in [Chapter 6](ch06.html "Chapter 6. Design Concerns - Organizing
    and Decoupling"), *Design Concerns - Organizing and Decoupling*
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may be useful to connect the router with some logic that gets invoked each
    time a navigation request is issued. For example, an application with an authentication
    mechanism may need to restrict some routes to authenticated users only. The Aurelia
    router's pipelines were conceived exactly for such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router supports four pipelines: `authorize`, `preActivate`, `preRender`,
    and `postRender`. Those pipelines are called at different stages during the navigation
    process. Let''s see where each of them occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: The current route component's `canDeactivate` method is called, if present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `authorize` pipeline is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target route component's `canActivate` method is called, if present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `preActivate` pipeline is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current route component's `deactivate` method is called, if present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target route component's `activate` method is called, if present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `preRender` pipeline is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The views are swapped in the router viewport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `postRender` pipeline is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pipeline is composed of steps, which are called in sequence. A pipeline step
    is a class with a `run(instruction, next)` method, where `instruction` is a `NavigationInstruction`
    instance and `next` a `Next` object.
  prefs: []
  type: TYPE_NORMAL
- en: A `Next` object is a function with methods.
  prefs: []
  type: TYPE_NORMAL
- en: When `next()` is invoked, it tells the router pipeline to keep going with the
    next step. The `next.cancel()` method cancels the navigation process and expects
    either a navigation command or an `Error` object to be passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Both return `Promise`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to notice here is that the `AuthenticatedStep` class is
    added to the `authorize` pipeline. Pipeline steps are added as classes, not as
    instances. That's because the router uses its DI container to resolve instances
    of the steps. This allows steps to have dependencies, which are resolved and injected
    just before being executed.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to notice is that the `management` route has a `settings` object
    with a `secured` property, set to `true`. It will be used by the pipeline step
    depicted in the following snippet to identify routes that need to be restricted
    to authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: '`src/authenticated-step.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is the actual pipeline step. In this example, we can imagine that our application
    contains a `User` class, which exposes the current user's information. Our pipeline
    relies on an instance of this class to know if the current user is authenticated
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `run` method first checks if any of the routes in the instruction are configured
    as secured. This is achieved by inspecting all the navigation instructions, including
    instructions for potential parent routers, and checking their configuration's
    `settings` for a truthy `secured` property.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when navigating to the `management` route defined in the previous
    code snippet, the value assigned to `isRouteSecured` would be `true`. That would
    also be the case if the `management` component declared child routes and the navigation
    occurred for one of those. In such a scenario, even if the child route was not
    configured as `secured`, `isRouteSecured` would still be `true` because one of
    the parent routes would be `secured`.
  prefs: []
  type: TYPE_NORMAL
- en: When the target route or one of its parents is secured, if the user is not authenticated,
    navigation is canceled and the user is redirected to the `login` route. Otherwise,
    `next` is invoked, letting the router know it can keep going with the navigation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Aurelia router offers yet another extension point. Additionally to the screen
    activation life cycle and to pipelines, the router publishes events through the
    event aggregator, which is another of Aurelia's core libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A demo of the router events can be found in `samples/chapter-2/router-events`.
    Let''s see those events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`router:navigation:processing`: This event is fired every time the router starts
    processing a navigation instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router:navigation:error`: This event is fired when a navigation instruction
    triggers an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router:navigation:canceled`: This event is fired when a navigation instruction
    is canceled, either by one of the screen activation life cycle callback methods
    of either the current or target route component, or by a pipeline step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router:navigation:success`: This event is fired when a navigation instruction
    is successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router:navigation:complete`: This event is fired once a navigation instruction''s
    processing is completed, no matter if it failed, was canceled, or was successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The payload of all of these events contains the `NavigationInstruction` instance,
    stored as an `instruction` property. Also, except for `router:navigation:processing`,
    all other events' payload has the `PipelineResult` as a `result` property. For
    example, when handling the `error` event, the `Error` object that was thrown can
    be accessed using the `output` property of `result`.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how the event aggregator works in [Chapter 6](ch06.html "Chapter 6. Design
    Concerns - Organizing and Decoupling"), *Design Concerns - Organizing and Decoupling*
  prefs: []
  type: TYPE_NORMAL
- en: Multiple viewports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all previous examples, the `router-view` element never has any attribute.
    It can actually have a `name` attribute. When this attribute is omitted, the viewport
    declared on the router by the element is named `default`. Can you see the implication
    here?
  prefs: []
  type: TYPE_NORMAL
- en: 'If your answer is that the router supports multiple viewports, you guessed
    right. Of course, it also means that each route must be configured for every viewport
    declared in the view. Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippets are excerpts of `samples/chapter-2/router-multiple-viewports`.
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the interesting thing to notice in the component''s view is that there
    are two `router-view` elements, with different `name` attributes. This component''s
    router will end up with two viewports: one named `header` and another named `content`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the view-model's `configureRouter` callback method, both routes are configured
    with a specific `moduleId` for both the `header` and the `content``viewPorts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If not every router''s viewports are accounted for by the route configuration
    when activated, the router will throw an error. It doesn''t matter if the route
    was configured statically with a `viewPorts` property defining a `moduleId` for
    every viewport, or if the `viewPorts` property was dynamically configured by a
    `navigationStrategy`. In the previous example, the `page-2` route could be replaced
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This route would have the same effect as in the previous example. The only difference
    here is that the viewports are configured dynamically each time the route is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, redirection routes are not affected by viewports, since they don't
    render anything.
  prefs: []
  type: TYPE_NORMAL
- en: Push state versus hash change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The router works by reacting to URL changes. In older browsers, only the part
    of the URL after the hash sign (#), called the hash, can change without triggering
    a page reload. So routers running on those browsers can only change the hash part,
    and listen for changes in the hash part.
  prefs: []
  type: TYPE_NORMAL
- en: With HTML5, a new History API has been introduced to enable manipulation of
    the browser history. This allows a JavaScript router running on a modern browser
    to directly manipulate its current URL and its browsing history, and to monitor
    changes to its current URL. This API enables the router to use the full URL, and
    allows things such as isomorphic applications, with server rendering and progressive
    enhancement. Those techniques can make an application's content accessible to
    a wider range of clients, and will also increase the application's SEO, as Google
    deprecated hash-based applications with AJAX content loading (see [https://googlewebmastercentral.blogspot.com/2015/10/deprecating-our-ajax-crawling-scheme.html](https://googlewebmastercentral.blogspot.com/2015/10/deprecating-our-ajax-crawling-scheme.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application is isomorphic when it can be executed on both the client and
    the server. Typically, an isomorphic application is executed server-side to render
    a text-based HTML representation that can then be returned to a client; a search
    engine crawler, for example. When executed client-side, it is normally enhanced
    with runtime event handlers, data bindings, and actual behavior so users can interact
    with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia's router plugin can work with either of those two strategies. By default,
    it is configured to use the hash-based strategy, because push-state requires the
    server to be configured accordingly. Also, the hash-based strategy supports older
    browsers not fully compatible with HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: However, if support of older browsers is not needed, or server-side rendering
    is required and the application will likely evolve toward isomorphism, the router
    can be configured to use the History API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippets are excerpts of `samples/chapter-2/router-push-state`.
  prefs: []
  type: TYPE_NORMAL
- en: First, in the `index.html` file, in the head section, a `<base href="/">` tag
    must be added. This element instructs the browser that `/` is the base for all
    relative URLs in the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the root component''s view-model, the router must be configured differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, for the right route to be displayed when a user accesses the application
    using a URL other than the root URL, the server needs to output the `index.html`
    page instead of a 404 response to requests for unknown paths. This way, when a
    user accesses an application route, the server will respond with the index page,
    then the application will boot and the router will handle the route and display
    the right view. Implicitly, this means that there must be no naming conflicts
    between the routes in your application and server-side resources, such as CSS,
    images, fonts, JS, HTML, or whatever files that must be loaded by the index page
    or the application from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Generating URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The router being able to react to URL changes and update its viewport accordingly
    is one thing. But what about links allowing it to navigate? If we hardcode URLs,
    any change in a route's path pattern would require not just changing the route
    configuration, but also to go over every place this URL is used for navigation,
    may it be in JS code or in views, and change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the router is also able to generate URLs. There are two requirements
    to generate a route path:'
  prefs: []
  type: TYPE_NORMAL
- en: The route configuration must have a unique `name` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the route has a parameterized or a wildcard pattern, a parameter object containing
    a value for each parameter must be provided when generating the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To generate a URL path in JS code, you must first have an instance of the router,
    generally by injecting it in the class where you need it. Then, you can call the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This method must be called with the name of the route, the parameters object
    if the route has any, and an optional options object, and will return the resulting
    URL. The only supported option at the moment is `absolute` which, when set to
    `true`, forces the router to return an absolute URL instead of a relative one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for our route named `contact-details` with the path pattern `contacts/:id`,
    the call to generate the URL for a contact whose `id` is 12 would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And for an absolute URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if we need to render a link to one of our routes inside a view? I guess
    you can see how you could inject the router inside a view-model, call the `generate`
    method, and data-bind an anchor's `href` attribute to the result. That would quickly
    get tedious at best.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aurelia-templating-router` library ships with a `route-href` attribute,
    which makes this much easier. For example, the template snippet to render a link
    to the contact with the `id 12` for our route named `contact-details` would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Chances are the ID won''t be hardcoded but will be stored in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `route-href` attribute will assign the resulting URL to the
    `href` attribute of the element it is on, but it supports an `attribute` property,
    which can be used to specify the name of the attribute on which the URL must be
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, the URL for the `quote` route will be assigned to the `cite` attribute
    of the `q` element.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The router offers convenient methods to perform navigation from JS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`navigate(fragment: string, options?: any): boolean`: Navigates to a new location,
    whose path is `fragment`. Returns `true` if the navigation succeeded, `false`
    otherwise. There are two supported `options`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace: boolean`: If set to `true`, the new URL will replace the current
    location in history, instead of being appended to history.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trigger: boolean`: If set to `false`, Aurelia''s router will not be triggered.
    This means that if the URL is relative, it will change in the browser''s address
    bar but no actual navigation will occur.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navigateToRoute(name: string, params?: any, options?: any): boolean`: Conveniently
    wraps a call to `generate` and then to `navigate`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navigateBack(): void`: Navigates back to the previous location in history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection, being at the core of Aurelia, it is important to understand
    how it works. If you were not familiar with the concept before this chapter, it
    may be a lot to process at once; but rest assured, as we will keep using those
    features a lot in the remainder of the book, it will help you get more familiar
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing goes with plugins, features, and routing. We will keep digging
    those subjects later in the book, particularly in [Chapter 6](ch06.html "Chapter 6. Design
    Concerns - Organizing and Decoupling"), *Design Concerns - Organizing and Decoupling*,
    when we will discuss various ways to structure an application.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting there, we still have a lot of ground to cover. In the next chapter,
    we will discuss data binding and the basics of templating, and we will add components
    to fetch and display data in our contact management application.
  prefs: []
  type: TYPE_NORMAL
