- en: Chapter 1. Promises.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Promises.js
- en: In today's world, computer programming languages are getting much more advanced
    and there is a shift in the approach of using technologies. This is due to the
    fact that technology has been emerging with the rapid change in businesses and
    their needs. The vast expansion of business on electronic devices has led universities,
    researchers, and industries to invest in generating the latest technologies and
    tools that result in the inception of many new computer languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界里，计算机编程语言正在变得更加先进，使用技术的方法也在发生变化。这是由于技术随着商业和他们需求的变化而不断涌现。电子商务的广泛扩展导致大学、研究人员和工业界投资于生成最新技术和工具，从而导致了许多新计算机语言的产生。
- en: However, this is not the case with JavaScript. It's relatively new. It has been
    used and dumped at least three times by the modern programming landscape and is
    now widely accepted as the tool to develop modern, scalable, and real-time web
    applications in today's cyberspace.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript并非如此。它相对较新。现代编程景观至少三次使用并抛弃了它，现在它被广泛接受为开发现代、可扩展和实时网络应用的工具。
- en: In the mid 90s, the era of dot-com was born and it was during this time when
    companies wanted to dominate the newly created market called cyberspace. Although
    this was a virtual place and had no physical existence, the war for dominance
    was at its peak. Netscape Communications Corporation wanted its own variant of
    a lightweight interpreted language that would complement Java by appealing to
    nonprofessional programmers. This task was given to Brendan Eich who developed
    the first version of JavaScript with the name "Mocha". Officially, it was called
    LiveScript when it was first released in September 1995 in Netscape's browser
    in beta version 2.0.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在90年代中期，点com时代诞生了，正是在这个时候，公司想要主导一个名为网络空间的新市场。尽管这是一个虚拟的地方，没有实体存在，但争夺主导地位的战争达到了顶峰。Netscape通信公司想要自己的轻量级解释语言，以补充Java，并吸引非专业程序员。这项任务交给了布兰登·艾ich，他开发了名为"Mocha"的JavaScript的第一版。正式地，当1995年9月在Netscape的浏览器中以2.0测试版首次发布时，它被称为LiveScript。
- en: However, the name was changed to JavaScript when the version 2.0 B3 rolled out
    later. Since 1995, JavaScript has seen many ups and downs. There are stories of
    it being adopted, rejected, and adopted again. Soon after its launch, JavaScript
    gained a very popular response throughout the industry. Every major company contributed
    to its growth and used it after slight adjustment for their needs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当版本2.0 B3推出时，名称改为了JavaScript。自1995年以来，JavaScript经历了许多起伏。它的被采用、被拒绝和再次被采用的故事。在其推出后不久，JavaScript在整个行业中获得了非常流行的响应。每个主要公司都为其增长做出了贡献，并对其进行微调以满足自己的需求。
- en: The fall and rise of JavaScript
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的衰落与崛起
- en: The Netscape browser witnessed the fall of JavaScript in the late 90s and early
    2000\. The face of web development was maturing, but very few were still interested
    in investing in JavaScript.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网景浏览器见证了90年代末至2000年初JavaScript的衰落。网页开发的面孔正在成熟，但很少有人还对投资JavaScript感兴趣。
- en: It was the advent of the Mozilla foundation that released the first open source
    browser, Firefox, in early 2002-2003 since the base was the successor of the former
    Netscape browser. They employed JavaScript again within their product. In 2004,
    Google introduced **Asynchronous JavaScript and XML** (**AJAX**). This led to
    the foundation of many techniques and made communication easy with a black and
    white frontend and server by minimizing the server calls.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 是Mozilla基金会发布了第一个开源浏览器Firefox，自2002年初至2003年初以来，该基础是前Netscape浏览器的继承者。他们在自己的产品中再次使用了JavaScript。2004年，谷歌推出了**异步JavaScript和XML**
    (**AJAX**)。这导致了许多技术的基础，并通过最小化服务器调用，使黑白的前端和服务器之间的通信变得容易。
- en: Google's contributions to JavaScript
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌对JavaScript的贡献
- en: Google has made more contributions in evolving, developing, and utilizing of
    JavaScript than any other organization. It was Google that introduced the V8 engine
    in its flagship web browser, Chrome. V8 is the backbone engine of the browser,
    and due to the smart usage of JavaScript, the browser is faster, robust, and adaptable
    to web and Android devices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌在JavaScript的演变、发展和应用方面的贡献超过了任何其他组织。正是谷歌在其旗舰浏览器Chrome中引入了V8引擎。V8是浏览器的核心引擎，由于
    smart usage of JavaScript，浏览器更快、更健壮，并适应于网页和安卓设备。
- en: In the year 2009, Node.js arrived based on the same V8 engine as in Chrome.
    This is the server side of JavaScript, but far more better and advanced than what
    Netscape had introduced in late 90s. The whole idea of Node.js is to develop nonblocking
    **input/output** (**I/O**) and with few lines of codes, the server can serve up
    to 20K clients at a given slot of time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，基于与Chrome相同的V8引擎的Node.js问世。这是JavaScript的服务器端，但比90年代末Netscape引入的要好得多和先进。Node.js的全局理念是开发非阻塞的**输入/输出**（**I/O**），并且用几行代码，服务器可以在给定的时间段内服务于多达20K的客户端。
- en: Soon after Node.js, an entire stack of development has been introduced by the
    name of MEAN stack, which is an acronym of MongoDB, Express.js, Angular.js, and
    Node.js; where MongoDB is document based, NoSQL is a JavaScript-based database,
    Express.js is for a presentation layer, Angular.js is for frontend development
    of an app, and Node.js as the server that runs the entire show.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js之后，一个名为MEAN栈的开发栈被引入，它是由MongoDB、Express.js、Angular.js和Node.js的首字母缩写而成；其中MongoDB是文档型的，NoSQL是基于JavaScript的数据库，Express.js用于表示层，Angular.js用于应用程序的前端开发，Node.js作为运行整个节目的服务器。
- en: Where Promises.js came in?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises.js是做什么的？
- en: Those of you who are aware of how a server-side script executes in an I/O event
    know that reading or writing data to and from a drive is blocking in nature, that
    is, during its execution, no other operation can be performed by a server-side
    language, even by the client. Well, with Promises.js, this is no longer the case.
    Promises.js utilizes a nonblocking strategy to perform I/O operations, so a client
    using your web app is free to perform any other tasks they want to without having
    to wait for the data read/write operation to be completed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那些了解服务器端脚本在I/O事件中如何执行的人知道，从驱动器读取或写入数据是阻塞性的，也就是说，在其执行期间，服务器端语言不能执行其他操作，即使是客户端。好吧，有了Promises.js，这种情况就不再存在了。Promises.js利用非阻塞策略进行I/O操作，所以使用你的网络应用程序的客户端可以自由地执行任何他们想执行的其他任务，而无需等待数据读/写操作完成。
- en: What is a promise?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺是什么？
- en: When an eventual value is returned from the completion of a single operation,
    it represents a **promise**. If we analyze promise as a pact from human, it will
    help us understand the concept of promises in computer programming especially
    from the JavaScript perspective. Every promise is a pact among two or more parties
    to deliver some value to the other. The value can either be tangible or intangible,
    but a promise must deliver something in return. Until the promise is fulfilled,
    it remains in an unfulfilled state. However, when the said commitment has been
    made, the promise is said to be fulfilled. If the promise is not delivered as
    anticipated, the promise is said to fail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个操作的完成返回一个最终的值时，它代表一个**承诺**。如果我们把承诺比作人类之间的约定，它将帮助我们理解计算机编程中特别是在JavaScript角度的承诺概念。每个承诺都是两个或更多方之间交付一些值给另一方的约定。这个值可以是具体的或无形的，但承诺必须有所回报。直到承诺得到满足，它才处于未满足的状态。然而，当所说的承诺已经完成，承诺就被认为是得到了满足。如果承诺没有如预期那样交付，那么这个承诺就被认为是失败的。
- en: 'So, what is a promise? According to the official definition:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是承诺？根据官方定义：
- en: '*Promise is an object or a function with a then method whose behavior confirms
    to this specification and represents the eventual result of an asynchronous operation.*'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 承诺是一个具有then方法的对象或函数，其行为符合此规范，代表异步操作的最终结果。
- en: The source of this definition is slide number 21 at [http://www.slideshare.net/wookieb/callbacks-promises-generators-asynchronous-javascript](http://www.slideshare.net/wookieb/callbacks-promises-generators-asynchronous-javascript).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义的来源是[http://www.slideshare.net/wookieb/callbacks-promises-generators-asynchronous-javascript](http://www.slideshare.net/wookieb/callbacks-promises-generators-asynchronous-javascript)的第21张幻灯片。
- en: Why do we need promise in JS?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要在JS中使用承诺？
- en: Promises.js is a JavaScript library that promises asynchronous I/O operations
    such as reading and writing on a file. Whenever there is a callback method that
    involves making all operations related to I/O, they are to be made asynchronous.
    This extra callback parameter confuses our idea of what is the input and what
    will be its return value. It never works with control flow primitives. It also
    doesn't handle errors thrown by a callback method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Promises.js是一个JavaScript库，它承诺进行异步I/O操作，如文件读写。每当涉及到I/O的所有操作的回调方法，它们都必须是异步的。这个额外的回调参数使我们的输入和返回值是什么的想法变得混乱。它从不与控制流原语一起工作。它也不处理由回调方法抛出的错误。
- en: So, we need to handle errors thrown by a callback method, but also need to be
    careful not to handle errors thrown by the callback method. By the time we are
    done with this, our code will be a mess of error handling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要处理回调方法抛出的错误，但也要小心不要处理回调方法抛出的错误。到这一步，我们的代码将变成一个错误处理的混乱局面。
- en: Despite all this mess of error handling code, we are still left with the problem
    of the extra callback parameter hanging around. Promises help you naturally handle
    errors, and write cleaner code by not having callback parameters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管处理错误代码如此混乱，我们仍然面临着一个额外回调参数悬而未决的问题。Promises通过自然地处理错误，不使用回调参数来编写更干净的代码来帮助你。
- en: Software prerequisites
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件先决条件
- en: Before starting [Chapter 2](ch02.html "Chapter 2. The JavaScript Asynchronous
    Model"), The *JavaScript Asynchronous Model*, you must need a set of prerequisite
    concepts that will make you better understand where to use Promises.js, and how
    it can save your time and effort in your recent or upcoming projects. The following
    section will elaborate what these concepts are and how we will use these as a
    base for our understanding of promise.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始[第二章](ch02.html "第2章 JavaScript异步模型")，*JavaScript异步模型*之前，你必须掌握一组先决概念，这将使你更好地理解在哪里使用Promises.js，以及它如何在你的近期或即将到来的项目中节省时间和精力。下一节将详细说明这些概念是什么，以及我们如何将它们作为我们理解承诺的基础。
- en: The prerequisite of this book is that you have a good understanding of procedural
    programing and a compulsory knowledge of basic JavaScript. Since this book is
    designed to develop a deeper knowledge of a concept (promise) and its use in different
    technologies, it's also imperative that you have a very good understanding of
    HTML and how to embed the code for your need.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的先决条件是你对过程编程有深入的了解，并且必须掌握基本的JavaScript知识。由于本书旨在深入理解概念（promise）及其在不同技术中的使用，因此你还需要对HTML有非常深入的了解，以及如何嵌入你的代码。
- en: An understanding of basic programming will help you begin with experiments with
    the help of a sample code as soon as you are done with any chapter/section. In
    this book, I've tried to make every section self-explanatory and every sample
    of code as a standalone script/program up to maximum strength. However, where
    there was need, we've added a snippet of code or algorithm to present our point
    more clearly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对基本编程的理解将帮助你一旦完成任何章节/部分后，就能在样例代码的帮助下开始实验。在这本书中，我试图使每一个部分都自解释，每一个代码示例都是一个独立的脚本/程序，尽最大可能地展示。然而，在需要的地方，我们添加了一段代码或算法，以更清晰地表达我们的观点。
- en: Environment you need before getting started
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始之前你需要了解的环境
- en: To use the code within this book, you don't need any extra piece of software/IDE
    to start. To sample the code provided in this book, you only need free software/IDE
    such as Notepad++ or any other preferred open source GPL or GNU product.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本书中的代码，你不需要任何额外的软件/集成开发环境（IDE）来开始。要尝试本书中提供的代码，你只需要使用免费的软件/IDE，如Notepad++或任何其他首选的开源GPL或GNU产品。
- en: Also, to view the result of your code, you need a web browser such as Google's
    Chrome or Mozilla's Firefox. For some examples related to Microsoft technologies,
    you will need Internet Explorer 9 or higher.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了查看你的代码结果，你需要一个像谷歌的Chrome或Mozilla的Firefox这样的网络浏览器。对于与微软技术相关的一些示例，你需要Internet
    Explorer 9或更高版本。
- en: Future, promise, and delay
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来（Future）、承诺（promise）和延迟（delay）
- en: Future, promise, and delay describe an object that acts as proxy to a result
    that is initially unknown due to computation of its value, which is yet to be
    completed. They are normally referred to as constructs used for synchronizing
    in some concurrent programming language.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 未来（Future）、承诺（promise）和延迟（delay）描述了一个作为代理来获取最初未知的值的代理对象，其值尚未计算完成。它们通常被称作某些并发编程语言中用于同步的构造。
- en: Daniel P. Friedman and David Wise proposed the term "promise" in 1975\. Peter
    Hibbard called it "eventual". The term promise was coined by Liskov and Shrira,
    although they referred to the pipelining mechanism by the name "call-stream".
    The term promise refers to the fact that in completion of any said operation,
    an eventual value will be obtained. In the same way, the value can also be taken
    as eventual because it will only yield out on the occurrence of any event. Thus,
    both terms refer to the same fact simultaneously.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 丹尼尔·P·弗里德曼和戴维·怀斯在1975年提出了“承诺”这个术语。彼得·希巴德称其为“最终”。承诺这个术语是由利斯科夫和希拉提出的，尽管他们用“call-stream”这个名字来指代流水线机制。承诺这个术语指的是在任何所述操作完成时，将获得一个最终值。同样，值也可以被视为最终值，因为它只有在任何事件发生时才会产生。因此，这两个术语同时指的是同一个事实。
- en: The terms future, promise, and delay are often used interchangeably. There is
    some core difference in implementing these terms. Future is revered as the read-only
    placeholder view of the variable, while promise is a writeable single assignment
    container that sets the value of the future.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 未来（Future）、承诺（Promise）和延迟（Delay）这些术语经常可以互换使用。实现这些术语有一些核心的区别。未来被认为是变量的只读占位符视图，而承诺是一个可写单分配容器，设置未来的值。
- en: In many cases, future promise are created together. In simple words, future
    is a value and promise is a function that sets the value. The future reruns the
    value of an async function (promise); setting the value of future is also called
    **resolving**, **fulfilling**, or **binding** it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，未来承诺是一起创建的。简单来说，未来是一个值，承诺是一个函数，用来设置这个值。未来重新运行异步函数（承诺）的值；未来设置值也称为**解析**、**满足**或**绑定**。
- en: Promise pipelining
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺流水线
- en: Using future can dramatically reduce the latency in distributed systems; for
    example, promise enables promise pipelining in programming languages E and Joule,
    which were also called **call-stream** in the Argus language.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未来（Future）可以显著降低分布式系统中的延迟；例如，在编程语言E和Joule中，承诺（Promise）使得承诺流水线（Promise pipelining）成为可能，而在Argus语言中，这被称为**call-stream**。
- en: A note to remember here is that promise pipelining should be distinguished from
    a parallel asynchronous message passing to a system supporting parallel message
    passing but not pipelining. It should also not be confused with pipelined message
    processing in actor systems, where it is possible for an actor to specify and
    begin executing a behavior for the next message before having completed processing
    of the current message.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，承诺流水线应该与支持并行消息传递但不支持流水线的系统的并行异步消息传递区分开来。它还应该与演员系统中的流水线消息处理区分开来，在演员系统中的流水线消息处理中，一个演员可以在完成当前消息的处理之前指定并开始执行下一个消息的行为。
- en: Read-only views
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读视图
- en: The read-only view allows reading its value when resolved, but doesn't permit
    you to resolve it, thus making it possible to obtain a read-only view of the future.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只读视图在解析时允许读取其值，但不允许您解析它，从而使获得只读视图的未来成为可能。
- en: The support for read-only views is consistent with the principle of least authority.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只支持只读视图与最小权限原则保持一致。
- en: The read-only view enables you to set the value to be restricted to the subject
    that needs to set it. The sender of an asynchronous message (with result) receives
    the read-only promise for the result, and the target of the message receives the
    resolver.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只读视图允许您将值设置为仅限于需要设置它的主体。异步消息（带有结果）的发件人收到结果的只读承诺，而消息的目标收到解决器。
- en: States of a promise
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺的状态
- en: 'Promise is based on three states. Each state has a significance and can be
    used to drive a certain level of result as per the need. This can help a programmer
    choose as per his/her need. The three states of a promise are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺基于三种状态。每种状态都有其重要性，可以根据需要驱动一定级别的结果。这可以帮助程序员根据需要进行选择。承诺的这三种状态如下：
- en: '**Pending**: This is the initial state of a promise'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：这是承诺的初始状态。'
- en: '**Fulfilled**: This is the state of a promise representing a successful operation'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**满足**：这代表一个成功操作的承诺状态。'
- en: '**Rejected**: This is the state of a promise representing a failed operation'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝**：这代表一个失败操作的承诺状态。'
- en: Once a promise is fulfilled or rejected, it is immutable (that is, it can never
    change again).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦承诺被满足或拒绝，它就是不可变的（也就是说，它永远不能再改变）。
- en: With reference to the concepts discussed earlier, it's now clear what a promise
    is and how you can use it with all its potential.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 参照前面讨论的概念，现在很清楚承诺是什么以及如何使用它及其全部潜力。
- en: How do we keep Promises.js in this book?
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何在本书中保持Promises.js的适用性？
- en: This book will cover the use of Promises.js with every major technology that
    has implemented the concept of promise. The book has been carefully divided into
    chapters to introduce, discuss, and explain the use of promise within that particular
    technology. Every chapter has its standalone set of examples of code to better
    understand the best use of Promises.js and its outcome.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将涵盖Promises.js与每种实现承诺概念的主要技术的使用。这本书被仔细地分成章节，以介绍、讨论和解释在该特定技术中使用承诺的方法。每个章节都有其独立的代码示例，以便更好地理解Promises.js的最佳使用和其结果。
- en: The examples will be assuming that the selection of an operating system is purely
    your discretion. It may vary from reader to reader based on his/her licenses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的例子将假设操作系统的选择完全由您自主决定。这可能因读者而异，取决于他的/她的许可证。
- en: All the code is clearly printed with instructions and comments for a better
    understanding. Also, a soft copy is provided with this book enlisting every piece
    of code sorted in its respective chapter/section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都清晰地打印出来，带有说明和注释，以便更好地理解。此外，本书还提供了一份电子副本，列出了按其相应章节/部分分类的每一行代码。
- en: Browser compatibility
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器兼容性
- en: 'Promises support is extended to many modern browsers but not to all. A handy
    reference of what browser it supports is given in desktop and mobile screen resolutions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Promises支持扩展到许多现代浏览器，但并非全部。有关它支持的浏览器的手册参考，请参阅桌面和移动屏幕分辨率：
- en: 'Desktop compatibility:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面兼容性：
- en: '| Feature | Chrome | Firefox | Internet Explorer | Opera | Safari |'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 特性 | Chrome | Firefox | Internet Explorer | Opera | Safari |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Basic support | 36 | 31 | Not supported till IE 11\. Added inEdge | 27 |
    8 |'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 基本支持 | 36 | 31 | 直到IE 11不支持。在Edge中添加 | 27 | 8 |'
- en: 'Mobile compatibility:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动兼容性：
- en: '| Feature | Android | Firefox Mobile (Gecko) | IE Mobile | Opera Mobile | Safari
    Mobile | Chrome for Android |'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 特性 | 安卓 | Firefox移动版（Gecko）| IE移动版 | Opera移动版 | Safari移动版 | 安卓版Chrome |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| Basic support | 4.4.4 | 31 | Edge | Not supported | Not supported | 42 |'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 基本支持 | 4.4.4 | 31 | Edge | 不支持 | 不支持 | 42 |'
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned where JavaScript began and how it shaped into one
    of the leading technologies in modern application development. We discussed why
    there was a need for JavaScript in the early 90s and how this language has seen
    ups and downs throughout its existence.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了JavaScript的起源以及它是如何发展成为现代应用开发中的领先技术的。我们讨论了为什么90年代初需要JavaScript，以及这种语言在其存在期间是如何经历起伏的。
- en: We have also seen how investments from tech companies made their contributions
    in creating, developing, and evolving JavaScript as a major player in a dynamic
    and fast growing market of web, mobile, and real-time apps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到科技公司的投资如何有助于创建、开发和演变JavaScript，使其成为动态和快速增长的网络、移动和实时应用市场的关键参与者。
- en: The adaptation of promises concept will make JavaScript much stronger and will
    help developers and engineers to write better code in an efficient manner.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺概念的适应将使JavaScript变得更强有力，并将帮助开发者和工程师以高效的方式编写更好的代码。
- en: In the next chapter, we will see what is an asynchronous model and how it's
    better fitted with JavaScript. This will help us understand to adopt and implement
    Promises.js in various languages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解异步模型以及它是如何与JavaScript更好地配合的。这将帮助我们理解如何采用并在各种语言中实现Promises.js。
