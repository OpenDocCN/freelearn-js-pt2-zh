- en: Chapter 9. Advanced Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 高级主题
- en: 'In this chapter, we will explore a few high-level topics designed to point
    you in the right direction when building Sencha Touch applications, such as the
    following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个高级主题，旨在为构建 Sencha Touch 应用程序指出正确的方向，例如以下内容：
- en: Talking to your own server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你的服务器通信
- en: Going offline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线工作
- en: Compiling your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译你的应用程序
- en: Getting into the marketplace
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入市场
- en: Talking to your own server
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与你的服务器通信
- en: 'Up to this point, we have used local storage as the way to create a database
    directly on the device that is running our program. While this is very useful,
    it can also be limiting in a few ways listed as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用本地存储作为在运行我们程序的设备上直接创建数据库的方法。虽然这非常有用，但在某些方面它也可能是有局限的，如下所述：
- en: If any data is stored in the device, you cannot view it from another device
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设备上存储了任何数据，你无法从另一台设备查看它
- en: If the device is stolen/broken/lost or otherwise unavailable, you also lose
    its data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设备被盗窃/损坏/丢失或无法使用，你也会丢失其数据
- en: Options for sharing are limited to transferring copies of the data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享选项限于传输数据的副本
- en: Collaborative editing of the data is not possible
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据协同编辑不可用
- en: Each of these concerns can be addressed by storing the data in an external database,
    such as MySQL, PostgreSQL, or Oracle. These databases can run on the same server
    as our application and handle multiple connections from different devices. Since
    all of the devices contact a single central database, sharing data across devices
    becomes much easier to accomplish.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个这些问题都可以通过将数据存储在外部数据库中得到解决，比如 MySQL、PostgreSQL 或 Oracle。这些数据库可以运行在与我们的应用程序相同的服务器上，并处理来自不同设备的多个连接。由于所有设备都联系同一个中央数据库，跨设备共享数据变得更容易实现。
- en: Unfortunately, the Sencha Touch framework doesn't communicate directly with
    these types of external databases. In order to use a Sencha Touch application
    along with an external database, we need to use a third-party API or create our
    own. On the plus side, this means we can use any database we want on which to
    store our data. However, it also means that we will need to write a bit more code
    in order to connect Sencha with an external database.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Sencha Touch 框架不能直接与这些类型的外部数据库进行通信。为了使用 Sencha Touch 应用程序与外部数据库，我们需要使用第三方
    API 或创建我们自己的。积极的一面是，这意味着我们可以使用任何我们想要的数据库来存储我们的数据。然而，这也意味着我们将需要编写一些代码以便将 Sencha
    与外部数据库连接起来。
- en: Using your own API
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用你自己的 API
- en: In the previous chapters, we have learned about using external APIs to work
    with data from services such as Flickr and Google. External APIs make it possible
    to grab data stored in the databases for these various services, but what about
    when you need to get data in and out of your own database server?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经学习了如何使用外部 API 来处理来自如 Flickr 和 Google 服务等数据。外部 API 使得获取存储在这些各种服务数据库中的数据成为可能，但当你需要将数据传入和传出你自己的数据库服务器时该怎么办呢？
- en: As it turns out, the best way to do this using Sencha Touch is to create your
    very own API. In order to do this, we need to step back and talk a little bit
    more about what an API is and what it does.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，使用 Sencha Touch 最好的方式是创建你自己的 API。为了做到这一点，我们需要退一步，更多关于 API 是什么以及它做什么的话题进行讨论。
- en: At its most basic level, an API serves as a translator between the storage and
    interface parts of the application. The frontend makes a request to the API for
    data (say, a list of contacts) and the API pulls information from the database.
    The API then translates that data into JSON or XML and sends it back to the frontend
    for display.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在最为基础的层面上，API 充当了应用程序的存储部分与界面部分之间的翻译者。前端向 API 请求数据（比如说，联系人的列表），API 从数据库中提取信息。API
    然后将那些数据翻译成 JSON 或 XML，并将其发送回前端进行展示。
- en: While this might seem an unnecessary separation for an application, it actually
    has a number of benefits. Firstly, it allows the backend and the frontend to be
    written in different programming languages. This is important to us because JavaScript,
    while being a wonderful language for creating interfaces, is not a great tool
    for talking to more robust database systems, such as MySQL, PostgreSQL, Microsoft
    SQL Server, and Oracle. The code for an API can be created in a database-friendly
    language, such as PHP, RUBY, or PERL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于一个应用程序来说可能看起来是一种不必要的分离，但实际上它有许多好处。首先，它允许后端和前端用不同的编程语言编写。这对我们来说很重要，因为尽管JavaScript是一种创建界面的好语言，但它并不是与更强大的数据库系统（如MySQL、PostgreSQL、Microsoft
    SQL Server和Oracle）通信的好工具。API的代码可以用一种对数据库友好的语言，如PHP、RUBY或PERL来创建。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will be using PHP for our examples, but the choice of API language is entirely
    up to you. We are also going to be very general when covering the PHP side of
    things. Our goal is to communicate the concept rather than provide specific PHP
    code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用PHP作为我们的示例，但API语言的选择完全取决于你。当我们覆盖PHP方面的事情时，我们也会非常一般化。我们的目标是传达概念，而不是提供特定的PHP代码。
- en: The second benefit is that multiple applications can use the API to access the
    data. This makes it much easier to share data between users and also makes it
    possible to provide the same data set to completely different applications (as
    the Flickr API does). We don't even have to care about which programming language
    has been used to build the frontend as the API handles the translation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个好处是，多个应用程序可以使用API来访问数据。这使得在用户之间共享数据变得容易得多，也使得向完全不同的应用程序提供相同的数据集成为可能（正如Flickr
    API所做的那样）。我们甚至不需要关心前端是用哪种编程语言编写的，因为API处理翻译。
- en: 'Let''s re-examine our `FlickrFindr` store to explore how this works:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下我们的`FlickrFindr`存储器，探索这是如何工作的：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We directed this store to a particular URL ([http://api.flickr.com/services/rest/](http://api.flickr.com/services/rest/))
    and now, in the listener portion of our controller, we also send our location,
    radius, and accuracy settings:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个存储器指向一个特定的URL（[http://api.flickr.com/services/rest/](http://api.flickr.com/services/rest/)），现在，在我们控制器的监听部分，我们还发送我们的位置、半径和准确性设置：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of these parameters is sent along as a set of `POST` variables to the Flickr
    API URL. Flickr then performs the function `flickr.photos.search` using the variables
    we've supplied in the previous code. The API then assembles the results in the
    JSON format and passes them back to us. This is what is referred to as a REST
    request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些参数都作为一组`POST`变量发送到Flickr API URL。Flickr然后使用我们在前面的代码中提供的变量执行`flickr.photos.search`功能。API然后将这些结果组装成JSON格式并传递给我们。这被称为REST请求。
- en: REST
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST
- en: '**REST** stands for **Representational State Transfer**, which is an overly
    complicated way to say that we want to use the standard methods already built
    into HTTP in order to communicate. These methods allow HTTP to transmit data via
    `POST`, `PUT`, `DELETE` and `GET`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**代表性状态转移**，这是一个过于复杂的说法，意思是我们要使用已经内置到HTTP中的标准方法来进行通信。这些方法允许HTTP通过`POST`、`PUT`、`DELETE`和`GET`传输数据。'
- en: 'The Sencha Touch Version 2.1 proxy `Ext.data.proxy.Rest` is a strict REST implementation
    that uses these four separate methods to handle CRUD functions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch Version 2.1代理`Ext.data.proxy.Rest`是一个严格的REST实现，使用这四个单独的方法来处理CRUD功能：
- en: '`POST` handles the creation of new records'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`处理新记录的创建'
- en: '`GET` handles the reading of records'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`处理记录的读取'
- en: '`PUT` handles the updating of existing records'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`处理现有记录的更新'
- en: '`DELETE` handles the deletion of records'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`处理记录的删除'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `Ext.data.proxy.Ajax` proxy works similar to `Ext.data.proxy.Rest`, but
    uses only `POST` and `GET`. If the API you're using requires stricter REST compliance,
    be sure to use the REST proxy instead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.data.proxy.Ajax`代理与`Ext.data.proxy.Rest`代理类似，但只使用`POST`和`GET`。如果你正在使用的API需要更严格的REST符合性，请确保使用REST代理。'
- en: 'If you have worked with forms on the Web, you are likely to be familiar with
    `GET` and `POST`. Both are ways to pass extra variables to a web page for processing.
    For example, `GET` uses a URL to pass its variables, such as the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在Web上处理过表单，你可能对`GET`和`POST`很熟悉。两者都是向网页传递额外变量的方法。例如，`GET`使用URL传递其变量，如下所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sends `userID=5` and `access=admin` to the web page for processing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将`userID=5`和`access=admin`发送到网页进行处理。
- en: '`POST`, `PUT`, and `DELETE` variables are sent as part of the HTTP request
    and do not appear in the URL. However, they transmit the same kind of data as
    do key-value pairs.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`、`PUT` 和 `DELETE` 变量作为 HTTP 请求的一部分发送，并不出现在 URL 中。然而，它们传输的数据与键值对相同。'
- en: Designing your API
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计你的 API
- en: It's a good idea before you start coding to think about how you would like your
    API to work. APIs can get complex rather quickly, and spending some time figuring
    out what yours will and won't do can help you greatly as you build your application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编码之前，先考虑一下你希望你的 API 如何工作是一个好主意。API 可能会很快变得复杂，花些时间弄清楚你的 API 将会和不会做什么可以帮助你在构建应用程序时节省大量时间。
- en: Different programmers have different philosophies on how to build APIs, so what
    we present here is just one possible approach.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的程序员对于如何构建 API 有不同的哲学观点，所以我们这里提出的方法只是可能的方法之一。
- en: Sencha Touch's models and proxies come with several methods, specifically the
    **CRUD** functions (**Create**, **Read**, **Update**, and **Delete**), which map
    quite well to API calls. This makes them a good place to start. First, make a
    list of which models you think you will need. For each model, you will need the
    Create, Read, Update, and Delete functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch 的模型和代理带有几个方法，特别是 CRUD 函数（创建、读取、更新和删除），它们与 API 调用非常相符。这使它们成为一个很好的起点。首先，列出你认为需要的每个模型的方法。对于每个模型，你需要创建、读取、更新和删除函数。
- en: Then, you should take a careful look at the models to see which ones may need
    additional API methods. A good example is a `user` model. You will definitely
    need the basic CRUD methods, but probably also an authentication method to log
    the user in, and perhaps an additional method for checking permissions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该仔细查看模型，看看哪些可能需要额外的 API 方法。一个好的例子是 `user` 模型。你肯定需要基本的 CRUD 方法，但也许还需要一个认证方法来让用户登录，以及可能一个检查权限的额外方法。
- en: You may find as you go on that you need to add additional API methods to specific
    models, but the standard CRUD functions should give you a good start when designing
    your API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的进展，你可能会发现你需要为特定的模型添加额外的 API 方法，但标准的 CRUD 函数应该会在你设计你的 API 时给你一个很好的起点。
- en: Creating the model and store
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型和 store
- en: For this example, we will use a variation of the `Bookmarks` model and the store
    from our `FlickrFindr` application in the previous chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用 `Bookmarks` 模型的一个变种和我们上一章的 `FlickrFindr` 应用程序中的 store。
- en: 'Since our `Bookmarks` component would now be pulled from a database, we need
    some extra options in the model. Instead of using the `SearchResults` model as
    we''ve done before, we will use a new model, such as the following one:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `Bookmarks` 组件现在将从数据库中获取，模型中需要一些额外的选项。我们不再像以前那样使用 `SearchResults` 模型，而是使用一个新的模型，例如以下的一个：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have added a `rest` proxy and `url` values to our model. This will
    allow us to save, edit, and delete directly from the model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在我们的模型中添加了一个 `rest` 代理和 `url` 值。这将允许我们直接从模型中保存、编辑和删除。
- en: 'For example, to save a new bookmark, we can call the following code in Sencha
    Touch:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要保存一个新的书签，我们可以在 Sencha Touch 中调用以下代码：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code will perform an HTTP `POST` request to `/api/bookmarks.php` using
    all of our `bookmark` variables as key-value pairs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将执行一个 HTTP `POST` 请求到 `/api/bookmarks.php`，使用我们的所有 `bookmark` 变量作为键值对。
- en: Similarly, we can take an existing bookmark, change some of its information,
    and then call `bookmark.save()`. If we do this on an existing bookmark, the model
    will send the variables as part of a `PUT` request to `/api/bookmarks.php`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以取一个现有的书签，修改一些它的信息，然后调用 `bookmark.save()`。如果我们这样做在一个现有的书签上，模型会将变量作为 `PUT`
    请求的一部分发送到 `/api/bookmarks.php`。
- en: As you might expect, calling `bookmark.destroy()` will send our variables to
    `/api/bookmarks.php` as part of a `DELETE` request.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，调用 `bookmark.destroy()` 会将我们的变量作为 `DELETE` 请求的一部分发送到 `/api/bookmarks.php`。
- en: 'We also have to modify our Saved Photos store in a similar fashion:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以类似的方式修改我们的已保存照片 store：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Compared to the store discussed earlier in this chapter, the big difference
    with this one is the proxy configuration. We are using the same `/api/bookmarks.php`
    file to process our requests. In this case, the store will use the `GET` request
    method when contacting the `/api/bookmarks.php` file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前面讨论的 store 相比，这个 store 的主要区别是代理配置。我们使用相同的 `/api/bookmarks.php` 文件来处理我们的请求。在这种情况下，store
    在联系 `/api/bookmarks.php` 文件时将使用 `GET` 请求方法。
- en: 'Our `reader` has a root property called `children`. This denotes that the data
    received should look something like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`reader`有一个名为`children`的根属性。这表示接收到的数据应该如下所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our store will begin looking for records inside the `children` array and will
    use the default variable `total` to get the total number of records.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的存储将开始在`children`数组内寻找记录，并使用默认变量`total`来获取记录总数。
- en: Making a request
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发起请求
- en: 'Once our model and store understand how to make these requests, our PHP-based
    API file has to decide what to do with them. This means that we have to set our
    `bookmarks.php` file to process the requests. At a very high level, this means
    executing something similar to the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的模型和存储理解了如何发起这些请求，我们的基于PHP的API文件就必须决定如何处理它们。这意味着我们必须将我们的`bookmarks.php`文件设置为处理这些请求。在很高的层次上，这意味着执行类似于以下代码的操作：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `<?PHP` and `?>` tags simply denote the beginning and end of PHP code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`<?PHP`和`?>`标签 simply denote the beginning and end of PHP code.'
- en: The `$action = $_SERVER['REQUEST_METHOD'];` line grabs the `request` method
    and we then base our code decisions (`add`, `edit`, `read`, or `delete`) on that
    result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`$action = $_SERVER[''REQUEST_METHOD''];`行获取了`request`方法，然后根据该结果决定我们的代码决策（`add`、`edit`、`read`或`delete`）。'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We don't want to get too far into code-specific examples as code will vary greatly
    depending on the language and database you want to use for your API. You will
    need to consult a guide for your specific API programming language in order to
    learn how to interact appropriately with your chosen database.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想深入到代码特定的例子中，因为代码将根据您希望用于API的语言和数据库而有很大的不同。您需要查阅特定于API编程语言的指南，以学习如何适当地与您选择的数据库进行交互。
- en: 'One thing to note when performing `add`, `edit`, and `delete` functions is
    that the data that comes to your functions will arrive as an array of records,
    such as the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`add`、`edit`和`delete`功能时要注意的一点是，传递给这些功能的数据将作为记录数组的形式到来，例如以下内容：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This indicates that for any `add`, `edit`, and `delete` options, you will need
    to loop through the values for each record and make database changes for each
    one. While you could conceivably access the records directly using `records[0].id`,
    looping through the values allows you to take advantage of the data store's ability
    to sync multiple changes at once.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明对于任何`add`、`edit`和`delete`选项，您将需要遍历每个记录的值并对每个记录进行数据库更改。虽然您可以通过`records[0].id`直接访问记录，但遍历值可以让您利用数据存储一次性同步多个更改的能力。
- en: When your API returns the results of the operation, Sencha Touch expects you
    to return the full record (or records) that was sent to the API in the first place.
    For example, if you create a new record, the API should, after a successful save,
    return that record as part of the results. If you modify several records and save
    them, the API should return all the modified records if they've been saved correctly.
    The reason for this is that it's possible that your API will make additional changes
    to the records, which should be reflected in your JavaScript code. Returning the
    full records ensures that your JavaScript application stays up-to-date with any
    changes made by your API.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的API返回操作结果时，Sencha Touch期望您返回最初发送到API中的完整记录（或记录）。例如，如果您创建了一个新记录，API在成功保存后应该将该记录作为结果的一部分返回。如果您修改了几个记录并保存它们，如果它们正确地被保存了，API应该返回所有被修改的记录。这是因为您的API可能会对记录进行额外的更改，这些更改应该在您的JavaScript代码中反映出来。返回完整记录确保了您的JavaScript应用程序与API所做的任何更改保持最新。
- en: 'For example, we can add a number of bookmarks to the store instead of creating
    them directly using the model as we did earlier in our code for bookmarks. When
    we call the `sync()` function in the store, it will send the data to our API as
    an array of bookmarks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以向存储中添加多个书签，而不是像我们代码中早期那样直接使用模型创建它们。当我们在存储中调用`sync()`函数时，它将把数据作为书签数组发送到我们的API：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This way, if we allow for looping in our API, we don't have to worry about whether
    the request came from the model or the store. From a receiving standpoint, the
    API only has to worry about whether the request is `POST` (`add`), `PUT` (`edit`),
    `GET` (`read`), or `DELETE` (`delete`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果我们允许API中循环，我们就不用担心请求来自模型还是存储。从接收角度来看，API只需要担心请求是`POST`（`add`）、`PUT`（`edit`）、`GET`（`read`）还是`DELETE`（`delete`）。
- en: However, there are also times when we need to communicate directly with the
    API and, perhaps, get a more complete response. This is where an Ajax request
    can come in handy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们需要直接与API通信，也许还需要得到更完整的响应。这时Ajax请求就能派上用场。
- en: Ajax requests in an API
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API中的Ajax请求
- en: While working with an external database, there are often times when we need
    to make data changes to other models. We might also need to receive responses
    that are more complex than those available to the data store in the current version
    of Sencha Touch. In these cases, we can use an Ajax request object to send data
    directly to our backend for processing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在与外部数据库合作时，我们经常需要对其他模型进行数据更改。我们可能还需要接收比当前版本Sencha Touch数据存储更复杂的响应。在这些情况下，我们可以使用Ajax请求对象直接将数据发送到我们的后端进行处理。
- en: 'For example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code makes a direct `GET` request to `/api/bookmarks.php` and passes
    an `id 6162337597` value as part of the request. The API can then use this information
    to grab a specific bookmark and return it to the Ajax request in JSON format.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码向`/api/bookmarks.php`发送了一个直接的`GET`请求，并将`id 6162337597`值作为请求的一部分。API然后可以使用这些信息抓取一个特定的书签，并以JSON格式将其返回给Ajax请求。
- en: 'Success or failure is indicated by returning an appropriate HTTP status code.
    If you''re returning a successful message, simply outputting JSON will return
    an acceptable status code. To indicate failure, you would return an error code
    in the 400 or 500 range; in PHP, it may look as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 成功或失败由返回适当的HTTP状态码来表示。如果你返回一个成功的消息，简单地输出JSON将返回一个可接受的状态码。要表示失败，你会返回一个400或500范围内的错误代码；在PHP中，它可能如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You'll need to look up how to send HTTP response headers in the documentation
    for your preferred API programming language.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要查阅你喜欢的API编程语言的文档，了解如何发送HTTP响应头。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a list of HTTP status codes, visit [http://restpatterns.org/HTTP_Status_Codes](http://restpatterns.org/HTTP_Status_Codes).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看HTTP状态码的列表，请访问[http://restpatterns.org/HTTP_Status_Codes](http://restpatterns.org/HTTP_Status_Codes)。
- en: Going offline
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线工作
- en: Inevitably, people using your application will find themselves without Internet
    access. With traditional web applications, this typically means that the application
    was inaccessible and unusable. But, with some careful planning, you can make your
    mobile application available offline.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不可避免地，使用你应用程序的人会发现他们没有互联网接入。在传统的网络应用程序中，这通常意味着应用程序无法访问和使用。但是，通过一些周密的计划，你可以使你的移动应用程序能够在离线状态下使用。
- en: Syncing local and remote data
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步本地和远程数据
- en: 'The first thing to think about is your data: which data will your users need
    even when they are offline? Let''s use a simple address book example. You would
    probably have a model for the contacts and a store that queries your remote address
    book server, along with perhaps a list view to display the contacts:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要考虑的是你的数据：用户即使在离线状态下也需要哪些数据？让我们用一个简单的通讯录例子来说明。你可能会有一个用于联系人的模型和一个查询远程通讯录服务器的存储，也许还有一个列表视图来显示联系人：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a very simple example, and we've left out creating an `index.html` file
    or adding the list to a viewport, even though both these actions would be necessary
    to make this application actually work.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，我们省略了创建`index.html`文件或把列表添加到视口中，即使这两个行动都是使这个应用程序真正工作的必要条件。
- en: You'll notice that our application uses a `jsonp` proxy, which is fine if we
    only want to load its data from a remote server. If we want our application to
    work offline, we will have to provide some local storage. Additionally, when the
    user comes back online, we want them to be able to retrieve updated contact information
    from the remote server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们的应用程序使用了`jsonp`代理，如果我们只是想从远程服务器加载其数据，这是可以的。如果我们想让我们的应用程序离线工作，我们必须提供一些本地存储。另外，当用户重新上线时，我们想让他们能够从远程服务器检索到更新的联系人信息。
- en: 'This means we''ll need two stores: our current store, which uses a `jsonp`
    proxy, and a new store to keep a copy of the data in local storage for when we
    go offline. The new store looks as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要两个存储：我们当前的存储，它使用一个`jsonp`代理，以及一个新的存储，用于在本地存储中保持数据的副本，以便我们在离线时使用。新的存储如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our next task is to make sure that the offline store has the most recent data
    from the online store. We do this by adding a listener to the online store''s
    `load` event. Each time the online store loads new data, we''ll update the offline
    store. In the following way, the offline store works as a cache for the online
    data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是确保离线商店拥有在线商店的最新数据。我们通过给在线商店的 `load` 事件添加一个监听器来实现。每次在线商店加载新数据时，我们将更新离线商店。离线商店作为在线数据的缓存以如下方式工作：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `load` event is called whenever the online store successfully loads new
    data. In our handler, we first retrieve the offline store and clear it (otherwise,
    we would end up duplicating our data each time we load the online store). Then,
    we use the online store's `.each()` function to iterate through every record,
    adding that record's data to the offline store.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`load` 事件在在线商店成功加载新数据时被调用。在我们的处理程序中，我们首先检索离线商店并清空它（否则，每次加载在线商店时我们都会复制数据）。然后，我们使用在线商店的
    `.each()` 函数遍历每一条记录，将该记录的数据添加到离线商店。'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The .each() function**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**`.each()` 函数**'
- en: '`.each()` is a function provided by the store that allows you to call a function
    for each record in that store. The function considers the individual record as
    a single argument. This allows you to perform operations on all the records one
    at a time rather than querying for them individually.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`.each()` 函数是 store 提供的，它允许你为 store 中的每一条记录调用一个函数。这个函数将单独的记录作为一个参数。这允许你逐条而不是单独查询所有记录执行操作。'
- en: 'Now, every time the online store is updated, the offline store is updated too.
    More importantly, though, when the online store is unable to be updated, the offline
    store will still have data in it. Since the offline store will always have data
    to display even when the online store doesn''t, we should use the offline store
    as the store for our list so that we''re always displaying something to our users.
    So, we change `ContactView` as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当在线商店更新时，离线商店也会更新。更重要的是，当在线商店无法更新时，离线商店中仍然会有数据。由于即使在线商店没有数据，离线商店总是有数据可以显示，因此我们应该将离线商店作为列表的商店使用，这样我们总是向用户显示一些内容。所以，我们将
    `ContactView` 更改为如下内容：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our online store will still autoload when our application starts, even though
    it's not bound to our list anymore, and if the user is online, all the data in
    both stores will be updated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的在线商店在应用启动时仍然会自动加载，尽管它不再绑定到我们的列表了。如果用户在线，两个商店中的所有数据都将更新。
- en: Of course, there are other ways in which you can accomplish the same goal. You
    could use the `Ext.List` component's `bindStore` function to switch between the
    two stores and the online store's `jsonp` proxy `exception` event to discover
    when you'd gone offline. Or, you could look at the value of the `window.navigator.onLine`
    variable to determine your online state and set up your stores accordingly. We'll
    talk about both the `jsonp` proxy's `exception` event and the `window.navigator.onLine`
    variable later in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他实现同一目标的方法。你可以使用 `Ext.List` 组件的 `bindStore` 函数在两个商店之间切换，或者使用在线商店的 `jsonp`
    代理 `exception` 事件来发现你何时离线。或者，你可以查看 `window.navigator.onLine` 变量的值来确定你的在线状态并相应地设置你的商店。我们将在本章后面讨论
    `jsonp` 代理的 `exception` 事件和 `window.navigator.onLine` 变量。
- en: Manifests
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清单
- en: Now that we've ensured our data is available offline, we need to make sure that
    the rest of our application is available as well. This includes all our JavaScript
    code, HTML, styles, and images. If our user has gone offline, they won't be able
    to load our application unless they've got a local copy to work from. That's where
    the Application Cache comes in.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确保了数据可以离线使用，我们还需要确保应用的其他部分也可以离线使用。这包括我们所有的 JavaScript 代码、HTML、样式和图片。如果用户已经离线，除非他们有本地副本可以从中工作，否则他们将无法加载我们的应用。Application
    Cache 就在这时发挥作用。
- en: HTML5 provides a mechanism for indicating to a web browser which parts of your
    application it should store for offline use. This isn't a functionality provided
    by Sencha Touch, but is something you should be familiar with nonetheless.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 为指示 web 浏览器将应用的哪些部分存储为离线使用提供了一个机制。这不是 Sencha Touch 提供的功能，但无论如何你都应该熟悉这个概念。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using Sencha Cmd to manage your application development process,
    the `cache.manifest` file will be created for you automatically.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Sencha Cmd 来管理你的应用开发过程，`cache.manifest` 文件将会自动为你创建。
- en: 'A manifest is a way in which you specify which files to cache. Let''s create
    one for our simple address book application. Open up an empty text file and add
    the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: manifest 文件是一种你指定要缓存的文件的方式。让我们为我们的简单地址簿应用程序创建一个。打开一个空文本文件并添加以下代码：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, save the file as `cache.manifest`. All lines starting with a hash (`#`)
    are comments and are ignored.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将文件保存为 `cache.manifest`。所有以井号（`#`）开头的行都是注释，将被忽略。
- en: In the preceding code snippet, the first section following the term `CACHE:`
    is a list of files that the mobile device should save for offline use. If you
    have any images or other files that you use, those should be listed here as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`CACHE:` 术语之后的第一个部分是移动设备应该为离线使用保存的文件列表。如果你有任何图片或其他文件，你也应该在这里列出。
- en: The `NETWORK:` section lists all the files that should only be available online.
    The asterisk (`*`) indicates that everything not listed in the `CACHE:` section
    should be available online only.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`NETWORK:` 部分列出了所有只能在线访问的文件。星号（`*`）表示 `CACHE:` 部分未列出的所有内容都应仅在线可用。'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most browsers limit offline storage to 5 MB. This includes both the files listed
    in your manifest as well as any data in local storage stores. So, if you've got
    an exceptionally big application, you may want to be selective about what you
    allow your application to do offline.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器将离线存储限制在 5 MB。这包括你在 manifest 中列出的文件以及任何在本地存储存储中的数据。因此，如果你有一个特别大的应用程序，你可能需要选择性地允许你的应用程序离线执行。
- en: 'In order to let browsers know about your manifest, you have to add a reference
    to it in the `index.html` file. However, this isn''t done in the same way in which
    we link to CSS or JavaScript files. Instead, we add an attribute to the opening
    `html` tag as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让浏览器了解你的 manifest 文件，你必须在你 的 `index.html` 文件中添加对它的引用。然而，这并不是我们链接 CSS 或 JavaScript
    文件的方式。相反，我们给 `html` 标签的开启标签添加一个属性，如下所示：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, when you launch your browser, you should see your files listed in the
    **Application Cache** in the developer console (click on the **Resources** tab
    and then on **Application Cache**) as shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你启动你的浏览器时，你应该在开发者控制台的**应用缓存**中看到你的文件列表（点击**资源**标签，然后点击**应用缓存**），如下图所示：
- en: '![Manifests](img/0748OS_09_01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Manifests](img/0748OS_09_01.jpg)'
- en: Setting up your web server
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的网页服务器
- en: Initially, you may find that your manifest isn't working properly. Usually,
    this means that your web server isn't configured to serve manifest files in the
    way mobile browsers expect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，你可能会发现你的 manifest 文件没有正常工作。通常，这意味着你的网页服务器没有配置好以按照移动浏览器期望的方式来提供 manifest 文件。
- en: Web servers use **MIME Types** to tell browsers how to handle certain files.
    MIME Types can get pretty complicated, but for manifests, all you have to do is
    add the MIME Type to your server. You should consult the documentation for your
    web server for instructions, but we will take the Apache web server as an example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 网页服务器使用**MIME 类型**来告诉浏览器如何处理某些文件。MIME 类型可能相当复杂，但对于 manifest 文件，你只需要在你的服务器中添加
    MIME 类型。你应该查阅你的网页服务器的文档以获取指导，但我们将以 Apache 网页服务器为例。
- en: 'For Apache, you should add the following MIME Type to your `httpd.conf` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Apache，你应该在你的 `httpd.conf` 文件中添加以下 MIME 类型：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, restart your web server for the changes to take effect.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重启你的网页服务器以使更改生效。
- en: For IIS, you will want to use the Administration UI to add the MIME Type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 IIS，你将需要使用管理界面来添加 MIME 类型。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Take a look at the following links for setting up your web server:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以设置你的网页服务器：
- en: 'For more on setting up Apache: [http://httpd.apache.org/docs/current/mod/mod_mime.html](http://httpd.apache.org/docs/current/mod/mod_mime.html).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置 Apache 的更多信息：[http://httpd.apache.org/docs/current/mod/mod_mime.html](http://httpd.apache.org/docs/current/mod/mod_mime.html)。
- en: 'For more on setting up IIS: [http://technet.microsoft.com/en-us/library/cc753281(WS.10).aspx](http://technet.microsoft.com/en-us/library/cc753281(WS.10).aspx).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置 IIS 的更多信息：[http://technet.microsoft.com/en-us/library/cc753281(WS.10).aspx](http://technet.microsoft.com/en-us/library/cc753281(WS.10).aspx)。
- en: Updating your cached application
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新你的缓存应用程序
- en: Once your application has been cached locally, the mobile device will no longer
    query your server to download your application files. This means that when you
    release updates or new versions of your application, users who've already cached
    your application won't get your updates.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用程序被本地缓存，移动设备就不再向你的服务器查询以下载你的应用程序文件。这意味着，当你发布你的应用程序的更新或新版本时，那些已经缓存了你应用程序的用户将不会收到更新。
- en: 'The only way to force users to download the new version of your code is to
    update the manifest file itself. That''s why we added the following lines at the
    top of the previous code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 强制用户下载代码新版本的方法的唯一途径是更新本身manifest文件。这就是为什么我们在前面的代码片段顶部添加了以下几行：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Just update the version number and save the file as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 只需更新版本号并保存文件如下：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This changes the manifest file, which will force anyone with cached copies to
    re-download all of the files in the `CACHE:` section of the manifest.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更改manifest文件，强制所有缓存副本重新下载manifest中`CACHE:`部分的所有文件。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more about the Application Cache and manifest files, check
    out the *Beginner's Guide to Using the Application Cache* at [http://www.html5rocks.com/en/tutorials/appcache/beginner/](http://www.html5rocks.com/en/tutorials/appcache/beginner/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于应用缓存和manifest文件的信息，请查看在[http://www.html5rocks.com/en/tutorials/appcache/beginner/](http://www.html5rocks.com/en/tutorials/appcache/beginner/)的*应用缓存初学者指南*。
- en: Interface considerations
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 界面考虑
- en: It's also important to let your users know when they're working in the offline
    mode. Most devices have an online icon in a status bar, but even so, it's not
    always apparent to the user when they've gone offline. You may want to let them
    know when you put your application in the offline mode.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户知道他们在线工作也很重要。大多数设备在状态栏中有一个在线图标，但即便如此，用户下线时也不总是显而易见的。你可能希望在将应用程序置于离线模式时让他们知道。
- en: Alerting your users
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告你的用户
- en: In our address book example, we have an online store that updates a second offline
    store. The offline store holds the data that the user sees displayed in the `Ext.List`
    class. However, we never explicitly tell the user when they've gone offline. In
    our first example, we don't keep track of the online or offline status ourselves
    because the application will work in either mode.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的通讯录示例中，我们有一个在线商店，它更新了一个离线商店的数据。离线商店持有用户在`Ext.List`类中看到的数据。然而，我们从不明确地告诉用户他们何时下线。在我们第一个例子中，我们不自己跟踪在线或离线状态，因为应用程序在任何模式下都能工作。
- en: 'If we want to tell our users when the application has gone offline, the most
    reliable method is by waiting for the online store''s request to time out. In
    the proxy, let''s add a `timeout` component and a function to call when `timeout`
    occurs:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要告诉用户应用程序何时下线，最可靠的方法是等待在线商店的请求超时。在代理中，让我们添加一个`timeout`组件和一个在`timeout`发生时调用的函数：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `exception` function will only be called after the timeout has elapsed.
    Timeouts in Sencha Touch are listed in milliseconds, so in this case, `2000` means
    two seconds. If the store doesn't get a response from the server in two seconds,
    the user is shown an alert informing them that the application has gone offline.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`exception`函数只有在超时发生后才会被调用。Sencha Touch中的超时以毫秒为单位列出，因此在这个例子中，`2000`意味着两秒钟。如果商店在两秒钟内没有从服务器获得响应，用户将看到一个警告，通知他们应用程序已经下线。'
- en: 'This is a good place to add other offline logic:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个添加其他离线逻辑的好地方：
- en: If you've set up polling in your store so that it automatically refreshes every
    so often, you may wish to turn it off
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在你的商店中设置了轮询，以便它每隔一段时间自动刷新一次，你可能希望关闭它。
- en: If there are special offline UI elements, you can enable them here
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有特殊的离线UI元素，你可以在這裡启用它们。
- en: If you have a lot of offline logic, you will probably want to put the code in
    a separate function so that you don't have to go hunting for it in the proxy configuration
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有很多离线逻辑，你可能会想要把代码放在一个单独的函数里，这样你就不必在代理配置中寻找它了。
- en: If you are using the MVC structure discussed in the previous chapter, the controller
    would be a good place for this kind of logic.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用前一章讨论的MVC结构，控制器将是这种逻辑的好地方。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are compiling your app via Sencha Cmd or some other method rather than
    running it as a web app, you may have access to the `onlinechange` event that
    is fired by the `Ext.device.Connection` object. Check the API docs for more on
    using the `Ext.device.Connection` object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过Sencha Cmd或其他方法编译你的应用程序，而不是作为网络应用程序运行，你可能可以访问由`Ext.device.Connection`对象引发的`onlinechange`事件。查看API文档以了解关于使用`Ext.device.Connection`对象更多信息。
- en: Updating your UI
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新你的UI
- en: Another way to visually inform your users that they are in the offline mode
    is to change the color or style of your application. While setting up an entirely
    different theme for offline mode may be overkill, there is a handy way to specify
    an offline stylesheet.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户视觉上知道他们处于离线模式的一种方法是改变应用的颜色或样式。虽然为离线模式设置一个完全不同的主题可能过于夸张，但有一种方便的方法可以指定一个离线样式表。
- en: 'Let''s create a file called `my-app-offline.css` and save it to our `css` folder.
    In the file, place the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`my-app-offline.css`的文件，并将其保存在我们的`css`文件夹中。在文件中，放置以下代码：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will turn the `contact-list` text red. Now, we need to load it when we're
    offline.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`contact-list`文本变成红色。现在，我们需要在离线时加载它。
- en: 'The Application Cache manifest file (`cache.manifest`) can have a section called
    `FALLBACK:` that is used to substitute an alternate file when a particular file
    is unreachable. Let''s add the following to the bottom of our `cache.manifest`
    file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 应用缓存清单文件（`cache.manifest`）可以有一个名为`FALLBACK:`的部分，用于当某个特定文件无法访问时替代另一个文件。让我们在`cache.manifest`文件的底部添加以下内容：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should also change the `css/my-app.css` line from the `CACHE:` section
    to reference `css/my-app-offline.css` instead as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将`CACHE:`部分中的`css/my-app.css`行更改为引用`css/my-app-offline.css`，如下所示：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the `index.html` file, you should leave `css/my-app.css` in the `style` tag
    as that will be the file that's loaded when we're online. When we're offline,
    however, the manifest tells our mobile browser to implicitly use `css/my-app-offline.css`
    instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，你应该保留`css/my-app.css`在`style`标签中，因为当我们在线时，这个文件会被加载。然而，当我们在离线时，清单告诉我们的移动浏览器隐式地使用`css/my-app-offline.css`。
- en: '![Updating your UI](img/0748OS_09_02.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![更新你的UI](img/0748OS_09_02.jpg)'
- en: As we can see in the preceding screenshot, now, when your application is offline,
    it will automatically use `my-app-offline.css` instead of `my-app.css`. You could
    also use this to provide an offline version of images or even JavaScript files
    if you want to completely segregate online and offline functionality. It should
    be noted that this method doesn't work if someone is online and then goes offline
    while using your application; say, if they went through a tunnel and lost signal.
    In that case, you would want to use the event listener method to switch your user
    to the offline mode.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的截图中看到的，现在，当你的应用处于离线状态时，它会自动使用`my-app-offline.css`而不是`my-app.css`。你也可以用这个方法来提供一个离线版本的图片，甚至是JavaScript文件，如果你想完全隔离在线和离线功能的话。需要注意的是，这个方法如果有人在使用你的应用时在线然后离线是行不通的，比如说，他们穿过一个隧道失去了信号。在这种情况下，你希望使用事件监听方法将用户切换到离线模式。
- en: Alternate methods of detecting the offline mode
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测离线模式的其他方法
- en: 'As mentioned earlier in the chapter, there are two alternate methods of detecting
    the offline mode: the `navigator.onLine` and `online`/`offline` browser events.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所提到的，有两种检测离线模式的备用方法：`navigator.onLine`和`online`/`offline`浏览器事件。
- en: 'The variable `navigator.onLine` will be `true` if the browser is online and
    `false` if it is not. In the `exception` function we discussed earlier in the
    chapter, we can add the following code to check it and change our message accordingly:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`navigator.onLine`如果浏览器在线则为`true`，如果浏览器不在线则为`false`。在前面章节中讨论的`exception`函数中，我们可以添加以下代码来检查它并相应地更改我们的消息：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternately, we can set up listeners for the browser''s `online` and `offline`
    events as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以为浏览器的`online`和`offline`事件设置监听器，如下所示：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You'll notice that we did not use Sencha Touch's event management concept here.
    This is because Sencha Touch does not provide custom events for `online` and `offline`
    events, so we have to use the browser's event listener function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们这里没有使用Sencha Touch的事件管理概念。这是因为Sencha Touch没有为`online`和`offline`事件提供自定义事件，所以我们不得不使用浏览器的事件监听函数。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not all desktop browsers support the `navigator.onLine` or `online`/`offline`
    events, so if you are making your application available to desktop users as well,
    you should use the timeout exception and manifest cache techniques instead.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有桌面浏览器都支持`navigator.onLine`或`online`/`offline`事件，所以如果你也让桌面用户可以使用你的应用，你应该使用超时异常和清单缓存技术。
- en: Getting into the marketplace
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入市场
- en: Sencha Touch applications offer developers a way to reach a wide audience using
    existing web technologies. Users can access an application via the Web and even
    save it to their devices for offline use. While this flexibility is extremely
    valuable, you may also want to distribute your application through the various
    application stores available for Apple and Android.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch应用程序为开发者提供了一种使用现有网络技术触达广大用户的方法。用户可以通过网络访问应用程序，甚至可以将它们保存到设备上以供离线使用。尽管这种灵活性非常有价值，但你也许还希望通过苹果和Android上可用的各种应用程序商店分发你的应用程序。
- en: In this section, we will take a look at some of the options available and the
    potential hurdles for releasing a compiled application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看一些可用的选项和发布编译应用程序可能遇到的潜在障碍。
- en: Compiling your application
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译你的应用程序
- en: A compiled application is one that runs natively on the device in question.
    For Apple's iOS products, this means Objective C, and for Google's Android OS,
    this means Java. Both iOS and Android use their own **Software Development Kits**
    (**SDK**) to create these native applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的应用程序是指在所述设备上本地运行的应用程序。对于苹果的iOS产品，这意味着Objective C，对于谷歌的Android操作系统，这意味着Java。iOS和Android都使用自己的**软件开发工具包**（**SDK**）来创建这些本地应用程序。
- en: An SDK is similar in functionality to Sencha Touch's framework, but it is much
    more complex and tied to a specific platform (iOS or Android). Since a native
    application is the only type that can be sold in the various app stores for Android
    and iOS, we need a way to translate our Sencha Touch JavaScript into one that
    the SDK can use. Fortunately, Sencha Touch developers have a few options for translating
    their JavaScript-based applications into either of these languages and creating
    compiled applications. The two most popular translation programs are Sencha Cmd
    and PhoneGap.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个SDK在功能上类似于Sencha Touch的框架，但它更加复杂且与特定平台（iOS或Android）紧密相关。由于本地应用程序是唯一可以在Android和iOS的各种应用程序商店中销售的类型，我们需要一种将我们的Sencha
    Touch JavaScript翻译成SDK可以使用的JavaScript的方法。幸运的是，Sencha Touch开发者有几个选项可以将他们的基于JavaScript的应用程序翻译成这两种语言并创建编译后的应用程序。最受欢迎的两个翻译程序是Sencha
    Cmd和PhoneGap。
- en: Both Sencha Cmd and PhoneGap use specialized command-line tools that allow you
    to take your existing code and place it into the SDK for iOS or Android. Both
    tools make extensive use of the Xcode and Android SDK libraries to translate your
    code into compiled applications. We will look at obtaining these SDKs in the *Registering
    for developer accounts* section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd和PhoneGap都使用专门的命令行工具，允许你将现有代码放入iOS或Android的SDK中。这两个工具都广泛使用Xcode和Android
    SDK库将你的代码翻译成编译后的应用程序。我们在*注册开发者账号*部分看看如何获取这些SDK。
- en: In addition to translating your Sencha Touch application to a native application,
    Sencha Cmd and PhoneGap also allow you to access some of the native features of
    the device. These features include access to the filesystem, camera, and sound
    and vibration options on the device.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将你的Sencha Touch应用程序翻译成本地应用程序之外，Sencha Cmd和PhoneGap还允许你访问设备的一些本地功能。这些功能包括访问文件系统、摄像头以及设备上的声音和振动选项。
- en: Let's take a look at the Sencha Cmd and PhoneGap translation programs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Sencha Cmd和PhoneGap翻译程序。
- en: Sencha Cmd
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sencha Cmd
- en: 'If you have been working alongside this book in Sencha Cmd, it is probably
    your best bet for compiling applications. By compiling the application, you gain
    access to more of the features in your iOS or Android device. These features include
    the foillowing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在用这本书和Sencha Cmd一起工作，那么它很可能是编译应用程序的最佳选择。通过编译应用程序，你可以访问iOS或Android设备上的更多功能。这些功能包括以下几点：
- en: '**Camera**: This feature allows you to take photos with the camera or access
    previously taken photos.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摄像头**：此功能允许你使用摄像头拍照或访问之前拍摄的照片。'
- en: '**Connection**: This feature allows you to see whether or not the device is
    online and what type of connection is being used.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：此功能允许你查看设备是否在线以及正在使用哪种类型的连接。'
- en: '**Contacts**: This feature allows access to search, sort, and filter contacts
    on the device.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联系人**：此功能允许访问搜索、排序和过滤设备上的联系人。'
- en: '**Geolocation**: This feature allows access to the device''s geolocation API
    (this is a more robust implementation of the browser''s geolocation functionality).'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地理定位**：此功能允许访问设备的地理定位API（这是浏览器地理定位功能的更健壮实现）。'
- en: '**Notification**: This feature shows simple notifications on the device. These
    notifications appear at the OS level and not just at the application level.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：此功能在设备上显示简单通知。这些通知出现在操作系统级别，而不仅仅是应用程序级别。'
- en: '**Orientation**: This feature gathers feedback on the orientation of the device.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**：此功能收集设备的朝向反馈。'
- en: '**Push**: This feature sends push notifications to the device (iOS only).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送**：此功能向设备发送推送通知（仅限iOS）。'
- en: These features are accessed using an object called `Ext.device`. For example,
    the `Ext.device.Camera.capture(…)` method allows you to grab an image from the
    camera or gallery and use it in your application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能通过一个名为`Ext.device`的对象访问。例如，`Ext.device.Camera.capture(...)`方法允许您从相机或相册中抓取图片，并将其用于您的应用程序。
- en: A step-by-step guide to native packaging can be found at [http://docs.sencha.com/cmd/3.1.2/#!/guide/native_packaging](http://docs.sencha.com/cmd/3.1.2/#!/guide/native_packaging).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本地打包的逐步指南，请参阅[http://docs.sencha.com/cmd/3.1.2/#!/guide/native_packaging](http://docs.sencha.com/cmd/3.1.2/#!/guide/native_packaging)。
- en: PhoneGap
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**PhoneGap**'
- en: 'Much like Sencha Cmd, PhoneGap offers a wide range of native functions through
    a global object called `navigator`. This object allows you to make JavaScript
    calls using commands in your JavaScript, such as the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与Sencha Cmd类似，PhoneGap通过一个名为`navigator`的全局对象提供广泛的本地功能。这个对象允许您使用JavaScript调用您的JavaScript中的命令，例如以下命令：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first command opens the camera on the device and lets your application take
    a picture. The picture is returned as a data string to your application, where
    you can manipulate it in JavaScript.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令在设备上打开相机，并允许您的应用程序拍照。照片作为数据字符串返回给您的应用程序，您可以在JavaScript中对其进行操作。
- en: The second function returns the orientation of the device in degrees. This can
    be very useful in games where play can be driven by tilting the device.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数返回设备的方向，以度为单位。这在游戏中有时候非常有用，因为游戏可以通过倾斜设备来操作。
- en: 'PhoneGap also offers access to the following features:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap还提供了以下功能：
- en: '**Accelerometer**: This feature gets information from the device''s motion
    sensor'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速度计**：此功能获取设备运动传感器的信息。'
- en: '**Camera**: This feature takes a photo using the device''s camera'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机**：此功能使用设备的相机拍照。'
- en: '**Capture**: This feature captures audio and video'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获**：此功能捕获音频和视频。'
- en: '**Compass**: This feature identifies the direction to which the device is pointing'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指南针**：此功能确定设备所指的方向。'
- en: '**Connection**: This feature checks the network status and gets cellular network
    information'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：此功能检查网络状态并获取蜂窝网络信息。'
- en: '**Contacts**: This feature works with the onboard contact database'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联系人**：此功能与内置的联系人数据库一起使用。'
- en: '**Device**: This feature gathers device-specific information'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：此功能收集设备特定信息。'
- en: '**Events**: This feature listens to native events on the device'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：此功能监听设备上的原生事件。'
- en: '**File**: This feature reads and writes to the native filesystem'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**：此功能读写本地文件系统。'
- en: '**Geolocation**: This feature gathers more detailed location information'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地理定位**：此功能收集更详细的地理位置信息。'
- en: '**Media**: This feature plays back audio files'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体**：此功能回放音频文件。'
- en: '**Notification**: This feature creates device notifications'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：此功能创建设备通知。'
- en: '**Storage**: This feature stores data directly on the device'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：此功能直接在设备上存储数据。'
- en: PhoneGap also offers options for compiling your applications in the Blackberry,
    WebOS, and Symbian platforms.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap还为您提供了在Blackberry、WebOS和Symbian平台编译应用程序的选项。
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Take a look at the following link for more resources on PhoneGap:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接有更多关于PhoneGap的资源，请查看：[链接](https://example.org)
- en: '[http://docs.phonegap.com/en/edge/](http://docs.phonegap.com/en/edge/)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.phonegap.com/en/edge/](http://docs.phonegap.com/en/edge/)'
- en: Other options
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他选项
- en: PhoneGap has also launched a cloud-based service for compiling applications
    called **PhoneGap Build** ([https://build.phonegap.com/](https://build.phonegap.com/)).
    This unique service does away with the need to download the SDKs for each platform
    you wish to compile for. Files are simply uploaded to the Build Service and the
    system generates the application for the platforms that you specify.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap还推出了一项基于云的服务，用于编译应用程序，名为**PhoneGap Build**([https://build.phonegap.com/](https://build.phonegap.com/)).
    这个独特的服务消除了为每个希望编译的平台下载SDK的必要性。文件只需上传到构建服务，系统就会为您指定的平台生成应用程序。
- en: '**Sencha Architect** is a graphical application builder for Sencha Touch and
    ExtJS. Architect now has the ability to compile applications for both iOS and
    Android built right into the application. More information can be found at [http://docs.sencha.com/architect/2/#!/guide/deploy](http://docs.sencha.com/architect/2/#!/guide/deploy).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sencha Architect**是Sencha Touch和ExtJS的图形应用程序构建器。Architect现在具有直接在应用程序中编译iOS和Android应用程序的功能。更多信息可以在[http://docs.sencha.com/architect/2/#!/guide/deploy](http://docs.sencha.com/architect/2/#!/guide/deploy)找到。'
- en: As with any of these options, you will need to be a licensed developer for the
    platform you want to compile for. This can be a bit of a lengthy process, so let's
    take a look at what's involved.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 像这些选项中的任何一个一样，您需要成为您想要编译的平台上的授权开发者。这可能是一个相当漫长的过程，所以让我们看看涉及哪些内容。
- en: Registering for developer accounts
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册开发者账户
- en: In order to publish your application onto the Apple Store or onto Google Play,
    you are going to have to sign up for their respective developer accounts. Both
    stores charge you a fee to become a developer and require quite a bit of information
    about you. They require this information for several reasons. Firstly, they have
    to know who you are so that you can get paid for apps that you sell in their stores.
    Secondly, they need to know how to contact you if there's a problem with your
    application. And lastly, they need to be able to track you down if you try to
    do something evil with your application. Not that you would, of course!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将您的应用程序发布到Apple Store或Google Play，您必须注册它们的相应开发者账户。这两个商店都会向您收取成为开发者的费用，并要求您提供大量的个人信息。它们需要这些信息有几个原因。首先，它们需要知道您是谁，这样您才能收到在它们的商店中销售的应用程序的付款。其次，如果您的应用程序出现问题，它们需要知道如何联系您。最后，如果有人试图用您的应用程序做坏事，它们需要能够找到您。当然，您不会这么做！
- en: '![Registering for developer accounts](img/0748OS_09_03.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![注册开发者账户](img/0748OS_09_03.jpg)'
- en: You will also need to download and install the appropriate SDK for that store
    in order to be able to package your application appropriately.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要下载并安装适合该商店的适当SDK，以便能够适当地打包您的应用程序。
- en: Becoming an Apple developer
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成为Apple开发者
- en: To become an Apple developer, first you must go to [http://developer.apple.com/programs/register/](http://developer.apple.com/programs/register/).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为Apple开发者，首先您必须前往[http://developer.apple.com/programs/register/](http://developer.apple.com/programs/register/)。
- en: You will need to either supply your existing Apple ID or sign up for a new one,
    fill out some lengthy profile information, agree to some legal documents, and
    then perform an e-mail verification. From there, you will have access to the Apple
    Developer Center. The two points that are of utmost interest to us as mobile developers
    are the **iOSDev Center** and the **iOS Provisioning Portal**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要提供您的现有Apple ID，或者注册一个新的ID，填写一些详尽的个人资料信息，同意一些法律文件，然后进行电子邮件验证。从那时起，您将能够访问Apple开发者中心。对我们这些移动开发者来说，最感兴趣的两个点是**iOS开发者中心**和**iOS配置门户**。
- en: The iOSDev Center is where you can download the iOS SDK (known as **Xcode**),
    read documentation, see sample code and how-tos, and view some videos about iOS
    development.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**iOS开发者中心**是您可以下载iOS SDK（称为**Xcode**）、阅读文档、查看示例代码和教学视频以及关于iOS开发的一些地方。'
- en: The iOS Provisioning Portal is where you add your application to the Apple Store
    or publish test versions of your application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**iOS配置门户**是您将应用程序添加到Apple Store或发布应用程序测试版本的地方。'
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to use Xcode or publish your application onto the Apple Store, you
    must have a computer running OS X. Windows and Linux computers cannot run Xcode
    or publish onto the Apple Store.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Xcode或将在Apple Store上发布您的应用程序，您的计算机必须运行OS X。Windows和Linux计算机无法运行Xcode或发布到Apple
    Store。
- en: Becoming an Android developer
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成为Android开发者
- en: Signing up for the Android Market is a very similar process. First, go to [https://market.android.com/publish/signup](https://market.android.com/publish/signup).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注册Android Market的过程非常相似。首先，前往[https://market.android.com/publish/signup](https://market.android.com/publish/signup)。
- en: There, you will be asked to fill out more profile information and pay your developer
    registration fee. You will also want to download the Android SDK at [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html),
    although, unlike Apple's SDK, the Android SDK will work on Windows, OS X, and
    Linux.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您会被要求填写更多的个人资料信息并支付开发者注册费用。您还应该下载Android SDK，位于[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)，尽管与Apple的SDK不同，Android的SDK可以在Windows、OS
    X和Linux上运行。
- en: The Android Developer Dashboard also has links to guides, reference material,
    and instructional videos.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓开发者仪表板还包含指南、参考资料和教学视频的链接。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've covered a few advanced topics for the aspiring Sencha
    Touch developer. We first talked about creating your own API to communicate with
    a database server. We've covered the REST method of communication for sending
    and receiving data from the server and discussed some options for building your
    own API.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向有抱负的Sencha Touch开发者介绍了一些高级主题。我们首先讨论了如何创建自己的API以与数据库服务器进行通信。我们介绍了与服务器发送和接收数据的REST通信方法，并讨论了构建自己的API的一些选项。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More resources on creating an API are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于创建API的资源如下：
- en: 'How to create an API: [http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/](http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建API：[http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/](http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/)
- en: 'Creating an API-centric web application: [http://net.tutsplus.com/tutorials/php/creating-an-api-centric-web-application/](http://net.tutsplus.com/tutorials/php/creating-an-api-centric-web-application/)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以API为中心的Web应用程序：[http://net.tutsplus.com/tutorials/php/creating-an-api-centric-web-application/](http://net.tutsplus.com/tutorials/php/creating-an-api-centric-web-application/)
- en: We've then covered how to take your application offline using manifests and
    the Application Cache. We've talked about best practices for alerting the user
    that the application is offline and how you can detect the availability of an
    Internet connection using Sencha Touch and the device's web browser.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了如何使用清单和应用程序缓存将您的应用程序离线。我们谈论了在应用程序离线时警告用户的最佳实践以及如何使用Sencha Touch和设备的Web浏览器检测Internet连接的可用性。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More resources on how to take your application offline are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于如何使应用程序离线的资源如下：
- en: 'Taking Sencha Touch applications offline:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让Sencha Touch应用程序离线：
- en: '[http://www.sencha.com/learn/taking-sencha-touch-apps-offline/](http://www.sencha.com/learn/taking-sencha-touch-apps-offline/)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.sencha.com/learn/taking-sencha-touch-apps-offline/](http://www.sencha.com/learn/taking-sencha-touch-apps-offline/)'
- en: 'The HTML manifest attribute:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: HTML清单属性：
- en: '[http://www.w3schools.com/tags/att_html_manifest.asp](http://www.w3schools.com/tags/att_html_manifest.asp)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.w3schools.com/tags/att_html_manifest.asp](http://www.w3schools.com/tags/att_html_manifest.asp)'
- en: We've closed the chapter with a look at getting into the application marketplace
    by compiling your application with Sencha Cmd and PhoneGap. We've also talked
    about the process for becoming an Apple or Android developer so you can sell your
    application in the marketplace.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以使用Sencha Cmd和PhoneGap编译您的应用程序来进入应用程序市场的方式结束了本章。我们还讨论了成为苹果或安卓开发者以便您可以在市场上销售应用程序的过程。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More resources on building Sencha Touch applications:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于构建Sencha Touch应用程序的资源：
- en: 'Enhancing iOS Sencha Touch applications using Sencha Cmd:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sencha Cmd增强iOS Sencha Touch应用程序：
- en: '[http://docs.sencha.com/cmd/3.1.2/](http://docs.sencha.com/cmd/3.1.2/)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.sencha.com/cmd/3.1.2/](http://docs.sencha.com/cmd/3.1.2/)'
- en: 'Building a Sencha Touch application using PhoneGap:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PhoneGap构建Sencha Touch应用程序：
- en: '[http://docs.phonegap.com/en/edge/](http://docs.phonegap.com/en/edge/)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.phonegap.com/en/edge/](http://docs.phonegap.com/en/edge/)'
