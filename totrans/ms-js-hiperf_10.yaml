- en: Chapter 10. Application Performance Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we've covered various ways of increasing our JavaScript's application
    performance at different stages of a project's life cycle. This includes activities
    ranging from choosing a proper editor at various stages in a project's lifespan,
    incorporating JavaScript linters to help proof our JavaScript before deployment
    to using build systems, and creating a deployment package or build separating
    final code from the developer-friendly code base.
  prefs: []
  type: TYPE_NORMAL
- en: The real secret in crafting high performing JavaScript is not the amount of
    JavaScript knowledge in our heads, but knowing the key "pain points" of the language
    itself; some of these pain points are the `for` loops, object creation, not incorporating
    strict operators, timers, and so on. Moreover, this category also includes incorporating
    these tools to better check our code before it is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Like all major web application projects, there is always some form of pre-flight
    check here, a final list of to-dos before a web application goes live. If we incorporate
    the tools covered in this book to this point, our JavaScript should be solid enough
    for deployment. But here, we will take it one step further.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to take a look at **Jasmine**, a JavaScript testing
    framework that will allow us to test our code in ways we haven''t realized yet.
    Unlike past linter tools such as, JSLint, these tests will rely on an application''s
    property types, and also on a concept we have yet to cover: unit testing in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is unit testing in JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing with Jasmine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is unit testing in JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing, simply put, is an application framework or toolset designed to
    test JavaScript or the code of any other programming languages in a specific way
    that's unique to any application. Unit tests typically cover error checking that
    doesn't exist inside standard linters. They are designed to check for application-specific
    errors. In other programming languages, unit tests are typically designed to check
    a project's classes and models, and to ensure that applications are running efficiently
    and correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Now JavaScript and unit-testing practices have never been associated well with
    one another, primarily due to the dynamic nature of JavaScript. Some factors that
    hamper their association include the many mistakes created unknowingly by developers,
    passing wrong values to variables that shouldn't have specific variable type,
    assigning a string when an application's object property requires a number, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, however, for client-side applications using JavaScript, whether
    they're on the web in a web browser or hosted inside a mobile app's web view,
    testing becomes more and more necessary. Now there are dozens of frameworks out
    there designed for JavaScript testing, but here, I will cover one in particular
    called Jasmine. Keep in mind that there are alternative testing frameworks such
    as Mocha or QUnit, but we will cover Jasmine as it doesn't require third-party
    frameworks to run.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is a JavaScript unit-testing framework; it allows us to write JavaScript
    without relying on external libraries such as jQuery. This is helpful for an application
    that requires a very tiny footprint in memory such as our JavaScript application
    in iOS, discussed in [Chapter 9](ch09.html "Chapter 9. Optimizing JavaScript for
    iOS Hybrid Apps"), *Optimizing JavaScript for iOS Hybrid Apps*. It also restricts
    the code to the code we've written, and there's no bug due to a framework in a
    current build of another vendor's library.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jasmine can be installed in various ways; we can use node package manager or
    NPM similar to how we structure our Gulp.js build system in [Chapter 3](ch03.html
    "Chapter 3. Understanding JavaScript Build Systems"), *Understanding JavaScript
    Build Systems*. But, to get our feet wet with testing in general, we are going
    to download the standalone version of the framework. I will be using version 2.1.3,
    which is the latest stable release of the framework and can be found at [https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases).
    To download, click the green `.zip` file button shown here on the Jasmine framework''s
    Github page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation and configuration](img/7296OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we download the standalone version of Jasmine, we can check to see if
    it is working; the standalone version includes some sample JavaScript that''s
    been set up with some unit tests. To run a set of unit tests in Jasmine, we will
    need to structure a `SpecRunner` page. A `SpecRunner` is a Jasmine-specific HTML
    page displaying the unit test results. If we open up the standalone versions `SpecRunner.html`
    file in our browser, we should see the example test results demonstrating all
    tests that have passed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation and configuration](img/7296OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before setting up a test, we will need to test some code. I've created a bit
    of JavaScript that is object oriented and relies heavily on specific JavaScript
    types, such as numbers and Booleans, which are used throughout the application.
    The application is a very simple banking application that returns customer data
    to a simple HTML page, but it is structured enough to resemble a large application.
    We are going to use Jasmine to check for types, ensure that the data being passed
    in is valid, and the verify the application is outputting customer data as it
    should.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the project code base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the following code sample for the project. Take a moment and look
    through the code shown here. As always, all code samples for this book are available
    on Packt Publishing's website too.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reviewing the project code base](img/7296OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have quite a bit of code here to test, but there's no need to worry about
    that! Let's review this slowly before we start using Jasmine. On lines 1 through
    7, we have a JavaScript enumeration for a gender type allowing us to predefine
    values for a customer type. In this example, the values are either `Male`, `Female`,
    or `Alien`. Starting on line number 10 is our `BankDB` object (also considered
    a JavaScript class); now this isn't really a database, but it could very well
    be connected to one in a real application.
  prefs: []
  type: TYPE_NORMAL
- en: The `BankDB` function is an instance-based object, meaning it requires a specific
    type of parameter in order for it to function, that we can find on line 56 called
    `newCustomer`. This JavaScript object contains a JavaScript object notation, which
    assigns values to a new customer entry. Think of this as a bit of JSON being returned
    by a clerk while using the system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on lines 66 through 72, we create the request with that user's data,
    and then append the data to the embedded web page's `document.body` statement
    with a bit of light styling and formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start writing our tests, let''s look at this in a self-contained
    page. I''ll add this to an empty HTML page just before the closing `body` tag.
    Let''s open the page and look at the results, which resemble the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reviewing the project code base](img/7296OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, our application is displaying all the correct information except
    the customer's name, which is showing as `Mr. e`, rather than `Mr. Leonard Adams`
    as indicated back on line 58 of our `10_01.js` file. Also, notice that, in our
    Chrome **Developer tools** option, we are not receiving any errors, and not really
    seeing much of a performance lag either. Nevertheless, we do know by the output
    of the customer's name that something is wrong. To correct this, we will unit-test
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing an application's spec for writing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing unit tests, there need to be well-defined instructions for writing
    the tests; in the case of the code sample shown in the previous screenshot, we
    want to ensure that our tests follow a few rules and, to help us write these tests,
    we'll use the rules listed in the following table with our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following list as an application specification, or documentation
    based on which the application should be built. Let''s look at the table and see
    what our code should be doing with the data being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Test Number | Test Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Test #1 | New Customer data test:`Customer''s ID should be a number.` |'
  prefs: []
  type: TYPE_TB
- en: '| Test #2 | New Customer data test:`Customer''s name should be in an array
    object, (ex [''FirstName'', ''LastName'']).` |'
  prefs: []
  type: TYPE_TB
- en: '| Test #3 | New Customer data test:`Customer''s bank balance should be a number.`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Test #4 | New Customer data test:`Customer''s city name should be a string.`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Test #5 | New Customer data test:`Customer''s gender should be a number.`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Test #6 | New Customer data test:`Customer''s marriage status is a boolean.`
    |'
  prefs: []
  type: TYPE_TB
- en: 'According to this list, we need our data values to pass these six tests in
    order to ensure that the JavaScript application is working properly. To do this,
    we will write a **spec** using Jasmine. In the Jasmine framework, a spec file
    is simply a JavaScript file with the JavaScript to be tested loaded into an HTML
    page that contains both the Jasmine testing framework and the file to be tested.
    Here, we can see what that combined page looks like; in Jasmine-based testing,
    it is typically called a `SpecRunner` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the `SpecRunner.html` page and notice that we have the Jasmine
    frameworks loaded first in the head tag, followed by our test script shown earlier
    in the chapter called `Chapter_10_01.js`, which is then followed by our spec file
    named as `Chapter_10_01_Spec.js` for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if, we open our Chrome **Developer tools** in our `SpecRunner.html`
    page, we can see a few errors coming from our `10_01.js` file where we append
    the `document.body` statement with our customer data. JavaScript that uses the
    DOM may cause issues with Jasmine and any other JavaScript testing frameworks
    as well, so be sure to use application-specific code to test rather than a user
    interface code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests using Jasmine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Jasmine, there are three keywords specific to the testing framework that
    we need to know. The first is `describe`; `describe` is like a class in testing.
    It groups our tests in one container to be referenced later. In the previous list
    from our application spec, we can use `New Customer data test` as our describe
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The second keyword is `it`; `it` is a Jasmine function that takes two parameters,
    a string that we use as our test description. For example, one `it` test could
    contain a description such as `Customer's ID should be a number`. This tells the
    user reviewing the test what exactly we are testing for. The other parameter is
    a function where we can inject code or set up code if needed. Remember that all
    of this is being run in the same page, so if we would like to change any variables,
    or prototypes for a test, we can do that within this function before we run our
    test. Keep in mind that, while writing the test, we don't need to modify our code
    in order to test properly; this is done only in case we don't have a code sample
    for review.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last keyword to remember is `expect`; `expect` is a function specific to
    Jasmine that takes a value and compares it with some other value. In Jasmine,
    this is done using the `toEqual` function that is a part of the `expect` function.
    Think of each test as readable like this: `We expect the typeof newCustomer.customerID
    to equal a number`. Now this is pretty simple if we think about it, but what does
    that look like in a spec file? Well, if we look at the following screenshot, we
    can see our `Chapter_10_01Spec.js` file with each of the tests written ready for
    Jasmine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing tests using Jasmine](img/7296OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see how our tests are written; on line 2, we have our `describe`
    keyword that wraps our tests in a single container should we have a larger test
    file. All our tests from our documentation spec can be found with each `it` keyword;
    test number 1 is on line 4 and, on line 5, we have the first test's `expect` keyword
    checking the `newCustomers.CustomerID` type, where we expect a `number`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the type being compared is using a string rather than number, as you
    would expect in a console. This is because `typeof`, the JavaScript keyword for
    returning the type of a variable or property, returns the type name using a string;
    so, in order to match it, we use strings with the type name here as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see on subsequent lines that we''ve added the remaining tests using
    the same style of comparison for each of the other tests. With that done, let''s
    open the `SpecRunner.html` page; we can see how our tests did in the **Spec List**
    view in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing tests using Jasmine](img/7296OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yikes! Three errors here, which is not good at all. Here, we were expecting
    a single error with the name of the customer not being displayed properly. But,
    our unit test has discovered that our application spec isn't being followed as
    it was written. In the Jasmine framework, this page layout is pretty common; on
    initial load, you will see a full error list. If you wish to see the list of all
    the tests that passed and failed, we can click **Spec List** at the top, and we
    will see the full list as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Tests that have failed here show up in red on your browser, and those that have
    passed show up in green. You may also see green circles and red Xs indicating
    how many tests passed and failed in both the **Failures** view and the **Spec
    List** view.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our test code working now, we can modify it to ensure this works properly.
    For this, we will need to update the `10_01.js` file and the `newCustomer` data,
    which is on lines 56 through 63 in the `10_01.js` file. Let''s review what went
    wrong with our sample customer data:'
  prefs: []
  type: TYPE_NORMAL
- en: The first test that failed was 2, which required the customer's name to be created
    as an object array, with the first name as an array item followed by the last
    name as the second item in the object array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second that failed was test 3, which required the `customerBalance` to be
    a type of number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third error was test 6, which required the customer's marriage status to
    be a boolean and not a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s update our `newCustomer` data; you can see that I''ve done that in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing our code](img/7296OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''ve updated the `newCustomer` information in our `10_01.js` file, we
    should be able rerun Jasmine and retest our code sample. If all tests pass, we
    will see the default **Spec List** showing all results in green; let''s reopen
    our page as shown in the following screenshot and see whether our tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing our code](img/7296OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nice, all six specs have passed! Great work! By ensuring that all our application's
    data is using the correct type, we can also ensure that our JavaScript application
    is not only performing well but also performing with a high degree of accuracy,
    as it was intended to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'When applications deviate from the developers, design, they can cause performance
    issues and affect the overall stability of the application. In Jasmine, we can
    see the completion time of the test; note that the performance on the final test
    is much faster than the one with errors. In the following screenshot, we have
    our final application page with no errors, as shown by **Developer tools** option
    in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing our code](img/7296OS_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One final fact to note here is the different approaches that can be used by
    JavaScript developers. One is the **Test Driven Development** (**TDD**) approach,
    where we write our tests before writing our application code. Another way in which
    many JavaScript developers test applications is called **Behavior Driven Development**
    (**BDD**) approach. This works by writing app code first and then interacting
    with an app, which includes opening a popup and confirming that the code worked
    as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these are valid methods to build applications, but for JavaScript applications,
    which use a bit of data that must be accurate, TDD is the way to go!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of unit testing JavaScript applications.
    We introduced Jasmine, a behavior-driven unit-testing framework for JavaScript.
    Together we created a real-world application that had no technical errors but
    was causing application issues.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed how to read and write an application spec and how to write tests
    in Jasmine using the applications spec. We then ran our test against our code
    and quickly updated our customer data to reflect the spec, allowing our unit test
    to pass. Lastly, we learned that unit-testing our code improves our JavaScript
    performance, and also minimizes risk to our application.
  prefs: []
  type: TYPE_NORMAL
