- en: Chapter 8. Creating the Flickr Finder Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 创建Flickr Finder应用
- en: 'So far, we have looked at Sencha Touch components individually or in small,
    simple applications. In this chapter, we are going to create a well-structured
    and more detailed application using Sencha Touch. We will attempt to leverage
    all of the skills from our previous chapters to create an application that will
    let us search for photos taken near our location. This chapter will include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经单独或在小型的简单应用中查看了Sencha Touch组件。在本章中，我们将使用Sencha Touch创建一个结构良好且更详细的应用。我们将尝试利用我们前几章的所有技能来创建一个允许我们搜索靠近我们位置的照片的应用。本章将包括：
- en: An introduction to the **Model View Controller** (**MVC**) design pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍**模型视图控制器**（**MVC**）设计模式
- en: Setting up a more robust folder structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置更健壮的文件夹结构
- en: Setting up the main application files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置主要应用文件
- en: Using the Flickr API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flickr API
- en: Registering components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册组件
- en: Setting up the `SearchPhotos` component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`SearchPhotos`组件
- en: Setting up the `SavedPhotos` component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`SavedPhotos`组件
- en: Adding the finishing touches to publish the application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给应用添加最后的润色以发布
- en: Generating the basic application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成基本应用
- en: The basic idea for this application will be to use the Flickr API to discover
    photos taken near our location. We will also add the ability to save interesting
    photos we might want to look at later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的基本想法是使用Flickr API来发现靠近我们位置的照片。我们还将增加保存有趣照片的功能，以便我们以后想看时能够找到。
- en: When you are first creating an application, it's always a good idea to sketch
    out the interface. This gives you a good idea of the pieces you will need to build
    and also allows you to navigate through the various screens the way a user would.
    It doesn't need to be pretty; it just needs to give you a basic idea of all the
    pieces involved in creating the application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次创建一个应用时，最好先勾勒出界面草图。这让你对需要构建的各个部分有一个大致的了解，同时也允许你像用户一样遍历各种屏幕。它不需要很漂亮；它只需要给你一个创建应用的所有部分的基本概念。
- en: 'Aim for something very basic, such as this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 目标应该是非常基础的，比如这样：
- en: '![Generating the basic application](img/0748OS_08_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![生成基本应用](img/0748OS_08_01.jpg)'
- en: Next, you will want to tap your way through the paper interface, just as you
    would with a real application and think about where each tap will take the user,
    what might be missing, and what might be confusing for the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你希望通过纸质界面点击你的方式，就像你会在一个真实应用中那样，思考每次点击会将用户带到哪里，可能缺少什么，以及可能对用户造成困惑的地方。
- en: Our basic application needs to be able to display a list of photos as well as
    a close-up of a single photo. When we tap on a photo in the list, we will need
    to show the larger close-up photo. We will also need a way to get back to our
    list when we are done with the photo.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本应用需要能够显示照片列表以及单张照片的特写。当我们点击列表中的照片时，我们需要显示更大的特写照片。我们还需要一种在查看完照片后返回列表的方法。
- en: When we see a photo we like, we need to be able to save it, which means that
    we will need a button to save the photo, as well as a separate list of saved photos,
    and a close-up single view for the saved photo.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到喜欢照片时，我们需要能够保存它，这意味着我们需要一个保存照片的按钮，以及一个保存照片的单独列表和一个保存照片的特写视图。
- en: 'Once we are happy with the drawings, we can start putting together the code
    to make our paper mock-up into something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对草图感到满意，我们就可以开始编写代码，将我们的纸质原型转变为类似这样的东西：
- en: '![Generating the basic application](img/0748OS_08_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![生成基本应用](img/0748OS_08_02.jpg)'
- en: Introducing the Model View Controller
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍模型视图控制器
- en: Before we get started with building our application, we should spend some time
    talking about structure and organization. While this might seem like a boring
    detour into application philosophy, it's actually one of the most critical considerations
    for your application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建应用之前，我们应该花些时间谈论一下结构和组织。虽然这可能看起来像是应用哲学的乏味偏离，但实际上，这是你应用中最关键的考虑因素之一。
- en: First, consider the monolithic application, with everything in one enormous
    file. It seems crazy, but you will encounter hundreds of applications that have
    been coded in just this fashion. Attempting to debug something such as this is
    a nightmare. Imagine finding the missing closing curly brace inside of a component
    array 750 lines long. Yuck!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑一下单片应用程序，所有内容都集中在一个巨大的文件中。这似乎很疯狂，但你会遇到成百上千个以这种方式编写的应用程序。试图调试这种东西是一场噩梦。想象一下在一个750行长的组件数组中找到缺失的闭合花括号。糟糕！
- en: The question then becomes one of how to break up the files in a logical fashion.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题变成了如何逻辑地分割文件。
- en: 'As discussed earlier in this book, the Model View Controller, or MVC, architecture
    organizes the application files based on the functionality of the code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书前面所讨论的，模型-视图-控制器（MVC）架构根据代码的功能组织应用程序文件：
- en: Models describe your data
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型描述你的数据。
- en: Views control how the data will be displayed
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图控制数据如何显示。
- en: Controllers handle the user interactions by taking input from the user and telling
    the views and models how to respond based on the user's input
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器通过从用户那里获取输入并告诉视图和模型根据用户的输入如何响应来处理用户交互。
- en: 'Sencha Touch also uses stores, which describe the storage and transmission
    of the data between components. When we split these pieces of the application
    apart, it means each part of your application will have separate files for each
    of these parts. Let''s take a look at how this is structured:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch还使用存储库，描述组件之间数据存储和传输的情况。当我们把应用程序的这些部分分开时，意味着你应用程序的每个部分都将有这些部分的单独文件。让我们来看看这个结构是怎样的：
- en: '![Introducing the Model View Controller](img/0748OS_08_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![介绍模型视图控制器](img/0748OS_08_03.jpg)'
- en: 'This is a basic application skeleton output from Sencha Cmd, which we will
    be using for our `FlickrFindr` project. In the root directory, we have folders
    for:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的应用程序骨架，由Sencha Cmd输出，我们将用它来开发我们的`FlickrFindr`项目。在根目录中，我们有文件夹：
- en: '**app**: This folder contains our main application files'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**app**：这个文件夹包含我们的主要应用程序文件。'
- en: '**packages**: This folder is used for any external libraries we might need'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包**：这个文件夹用于存放我们可能需要的任何外部库。'
- en: '**resources**: This folder contains our CSS, SASS, icons, and various image
    files'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：这个文件夹包含我们的CSS、SASS、图标和各种图片文件。'
- en: '**touch**: This folder contains a copy of the Sencha Touch library'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触摸**：这个文件夹包含Sencha Touch库的副本。'
- en: 'Inside our **app** directory, we have separate files for:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的**app**目录中，我们有自己的文件：
- en: '**controller**: Our controllers will contain the functionality of our application.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：我们的控制器将包含我们应用程序的功能。'
- en: '**form**: Our forms will control the appearance of any forms we use.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单**：我们的表单将控制我们使用的任何表单的外观。'
- en: '**model**: Our models will describe the data we are using.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：我们的模型将描述我们使用的数据。'
- en: '**profile**: Our profiles will contain display information for different types
    of devices. This is not covered in this book, but a detailed explanation can be
    found on the Sencha website at [http://docs.sencha.com/touch/2.2.1/#!/guide/profiles](http://docs.sencha.com/touch/2.2.1/#!/guide/profiles).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：我们的配置文件将包含不同类型设备的显示信息。本书不涉及这部分内容，但详细解释可以在Sencha网站上的[http://docs.sencha.com/touch/2.2.1/#!/guide/profiles](http://docs.sencha.com/touch/2.2.1/#!/guide/profiles)找到。'
- en: '**store**: Our stores determine how the application''s data will be stored.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储库**：我们的存储库决定应用程序数据如何存储。'
- en: '**view**: Our views control the appearance of the application.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：我们的视图控制应用程序的外观。'
- en: By splitting the files out this way, it is much easier to re-use code across
    applications. For example, let's say you build an application that has a model,
    store, controller, and views for a user. If you want to create another application
    that needs to deal with users, you can simply copy over the individual files for
    the model, store, views, and controller into your new application. If all the
    files are copied over, then the user code should work just as it did in the earlier
    application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式分割文件，跨应用程序重用代码要容易得多。例如，假设你构建了一个具有模型、存储库、控制器以及用户视图的应用程序。如果你想创建另一个需要处理用户的新应用程序，你只需将模型、存储库、视图和控制器的单个文件复制到你的新应用程序中即可。如果所有文件都被复制过去，那么用户代码应该和在前一个应用程序中一样正常工作。
- en: If we build a monolithic application, you would have to hunt through the code,
    grab out bits and pieces, and reassemble them in the new application. This would
    be a slow and painful process. By separating our components through functionality,
    it's much easier to re-use code between projects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建一个单体应用程序，您必须浏览代码，提取出片段，并将它们重新组装到新应用程序中。这将是一个缓慢且痛苦的过程。通过按功能分离我们的组件，项目间复用代码要容易得多。
- en: Splitting up the pieces
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割组件
- en: The next thing we need to consider is how our application gets split into our
    separate MVC pieces. For example, if your application tracks people and what cars
    they own, you would likely have a model and controller for the people and a separate
    model and controller for the cars. You would also likely have multiple views for
    both cars and people, such as `add`, `edit`, `list`, and `details`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的下一件事是应用程序如何被拆分成独立的MVC部分。例如，如果您的应用程序跟踪人和他们拥有的汽车，您可能会为人和汽车分别有一个模型和控制器。您还可能为汽车和人都有多个视图，如`添加`、`编辑`、`列表`和`详情`。
- en: In our application, we will be dealing with two different types of data. The
    first is search data for our photos and the second is our saved photos.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将处理两种不同类型的数据。第一种是照片的搜索数据，第二种是我们保存的照片。
- en: 'If we break this down into models, stores, views, and controllers, we get something
    like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把这个分解成模型、存储、视图和控制器，我们得到类似于以下的内容：
- en: '![Splitting up the pieces](img/0748OS_08_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![分割组件](img/0748OS_08_04.jpg)'
- en: Our controllers are separated through functionality for **Saved Photos** and
    **Search Photos**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器通过功能分为**保存照片**和**搜索照片**。
- en: Since they are dealing with the same type of data, each of our controllers can
    use the same **Photos** model, but they will need different stores (**Search Photos**
    and **Saved Photos**), since they're each using different actual data sets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们处理相同类型的数据，我们的每个控制器都可以使用相同的**照片**模型，但它们将需要不同的存储（**搜索照片**和**保存照片**），因为它们各自使用不同的实际数据集。
- en: For views, our search needs a list view for **Search List** and a **Search Details**
    view. The saved photos will also need a view for the **Saved List** list and a
    view for editing/adding **Saved Details**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图，我们的搜索需要一个**搜索列表**的列表视图和一个**搜索详情**视图。保存的照片也需要一个**保存列表**视图和一个用于编辑/添加**保存详情**的视图。
- en: Now that we have a clear map of the files we need, it's time to start building
    our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地了解了我们需要的文件，是时候开始构建我们的应用程序了。
- en: Building the foundation with Sencha Cmd
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sencha Cmd建立基础
- en: In Version 1 of Sencha Touch, the setup process for an application was very
    manual and time consuming. However, the introduction of Sencha Cmd allows us to
    generate most of the core application files with a single command.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha Touch的1.0版本中，应用程序的设置过程非常手动且耗时。然而，Sencha Cmd的引入允许我们用一条命令生成大多数核心应用程序文件。
- en: 'Sencha Cmd is a set of command-line tools that perform a number of basic tasks
    in Sencha Touch, such as:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd是一组命令行工具，在Sencha Touch中执行许多基本任务，例如：
- en: Generating an application skeleton that you can use as the basis for your application
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个可以用作应用程序基础的应用程序骨架
- en: Generating controllers, forms, and models
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成控制器、表单和模型
- en: Building your application to "minify" and compress JavaScript and images for
    production applications
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建您的应用程序以“最小化”和压缩JavaScript和图片以供生产应用程序使用
- en: Building your application as a standalone binary that you can sell in the App
    Store
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的应用程序作为可以在App Store中销售的独立二进制文件构建
- en: 'Sencha Cmd has a number of additional uses and configuration options. More
    information on these can be found at [http://docs.sencha.com/touch/2.2.1/#!/guide/command](http://docs.sencha.com/touch/2.2.1/#!/     guide/command).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'Sencha Cmd有许多其他用途和配置选项。有关这些信息，请参阅[http://docs.sencha.com/touch/2.2.1/#!/guide/command](http://docs.sencha.com/touch/2.2.1/#!/     guide/command)。'
- en: For this project, we will mainly be using the `generate` command to build our
    basic application, controllers, and models. However, first we need to get everything
    installed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将主要使用`generate`命令来构建我们的基本应用程序、控制器和模型。然而，首先我们需要安装所有内容。
- en: Installing Sencha Cmd
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Sencha Cmd
- en: 'Sencha Cmd is a separate download from our Sencha Touch code and can be found
    at: [http://www.sencha.com/products/sencha-cmd/download](http://www.sencha.com/products/sencha-cmd/download).
    This download is available for Windows, OS X, and Linux (32 bit and 64 bit). When
    you unzip the downloaded file, you can double-click on it to install Sencha Cmd.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd是我们从Sencha Touch代码下载的独立文件，可以在以下网址找到：[http://www.sencha.com/products/sencha-cmd/download](http://www.sencha.com/products/sencha-cmd/download)。这个下载文件支持Windows、OS
    X和Linux（32位和64位）。解压缩下载的文件后，你可以双击它来安装Sencha Cmd。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this book, we are using Sencha Cmd Version 3 (at least Version 3.1.2 or
    greater is required). Detailed installation instructions can be found at [http://docs.sencha.com/touch/2.2.1/#!/guide/command](http://docs.sencha.com/touch/2.2.1/#!/guide/command).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们使用的是Sencha Cmd版本3（至少需要版本3.1.2或更高版本）。详细的安装说明可以在[这里](http://docs.sencha.com/touch/2.2.1/#!/guide/command)找到。
- en: 'Once you have installed Sencha Cmd, you can open up the command line on your
    computer as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了Sencha Cmd，你可以按照以下方式打开计算机上的命令行：
- en: On Mac OS X, go to **Applications** and launch **Terminal**
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mac OS X上，前往**应用程序**并启动**终端**
- en: On Windows, go to **Start** | **Run** and type `cmd`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，前往**开始** | **运行** 并输入`cmd`
- en: 'Once your terminal is open, type `sencha`. You should see something like the
    following screenshot in your terminal:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的终端打开，输入`sencha`。你应该会在终端中看到如下截图：
- en: '![Installing Sencha Cmd](img/0748OS_08_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![安装Sencha Cmd](img/0748OS_08_05.jpg)'
- en: Now that we have Sencha Cmd installed, it's time to generate the skeleton for
    our application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Sencha Cmd，是时候为我们的应用程序生成骨架了。
- en: 'First, you will need to change to the directory where your Sencha Touch files
    are installed (not the Sencha Cmd files we just downloaded, but your original
    Sencha Touch 2.1 files):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要切换到你的Sencha Touch文件安装的目录（不是我们刚刚下载的Sencha Cmd文件，而是你原始的Sencha Touch 2.1文件）：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Sencha Cmd will use the files from this Sencha Touch directory to generate
    our application. From here, we use the `generate` command as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd将使用来自这个Sencha Touch目录的文件来生成我们的应用程序。从这里，我们使用`generate`命令如下：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will, of course, need to adjust the preceding path to match your own personal
    development environment. This will create our basic application with the directory
    structure we showed in the the *Introducing the Model View Controller* section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要根据你自己的开发环境调整前面的路径，以创建我们在*介绍模型视图控制器*部分展示的目录结构的基本应用程序。
- en: In addition to the folders we covered earlier, you will also see a number of
    files that are already created. You can consult the Sencha Cmd documentation for
    a full listing of what all the files do, but for now we only want to look at the
    file called `app.js`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前提到的文件夹，你还会看到许多已经创建的文件。你可以查阅Sencha Cmd文档，了解所有文件的详细信息，但现在我们只需要关注一个名为`app.js`的文件。
- en: 'The `app.js` file loads when our application launches and takes care of our
    basic setup. If you look beneath the comments at the top of the file, you should
    see something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`文件在我们应用程序启动时加载，并处理我们的基本设置。如果你查看文件顶部的注释，你应该会看到类似这样的内容：'
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sets the path to our copy of the Sencha Touch Framework, which Sencha Cmd
    copied into a `touch` directory as part of our `generate app` command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的Sencha Touch框架副本设置了路径，Sencha Cmd在我们执行`generate app`命令时，将其复制到了一个`touch`目录中。
- en: 'The few lines that follow set our namespace (`name`) for the application and
    handle our required files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行设置了我们的应用程序命名空间（`name`）和处理我们需要的文件：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `requires` section lists any internal or external libraries that we need
    for our application. The `Ext.MessageBox` component is included by default. We
    also have a `views` section where we can list any of the views our application
    requires. Separate sections can also be added for models, stores, and controllers.
    We will get to those a bit later.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires`部分列出了我们应用程序需要的任何内部或外部库。`Ext.MessageBox`组件是默认包含在内的。我们还有一个`views`部分，可以列出我们应用程序需要的任何视图。还可以为模型、存储和控制器添加单独的部分。我们稍后会涉及到这些。'
- en: The next few sections concern themselves with our application icon and startup
    screen (`startupImage`). These images can be modified by either replacing the
    existing image or changing the URL to point to a new image file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几部分将涉及到我们的应用程序图标和启动屏幕（`startupImage`）。这些图像可以通过替换现有图像或更改URL来指向新的图像文件进行修改。
- en: 'The last part of our `app.js` file is the `launch` function. This gets called
    after all our components are loaded:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`app.js`文件的最后一部分是`launch`函数。所有组件加载完毕后会被调用：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function removes the loading indicator and displays our main window. The
    `FlickrFindr.view.Main` file is in our `views` folder; we will be modifying that
    shortly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数移除了加载指示器并显示我们的主窗口。`FlickrFindr.view.Main`文件在我们的`views`文件夹中；我们很快就会修改它。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that the name of the file in our example is `FlickrFindr.view.Main`,
    which tells the application that this file is called `Main.js` and that it is
    located in our `app/view` folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们示例中的文件名是`FlickrFindr.view.Main`，这告诉应用程序这个文件叫做`Main.js`，并且它位于我们的`app/view`文件夹中。
- en: If we had a significant number of views, we could split them up into directories
    inside the `views` folder. For example, we could have `search` and `saved` folders
    for our application. In that case, the `Details.js` view for our `search` folder
    would be `FlickrFindr.view.search.Details`, and the `Details.js` view for our
    `saved` folder would be `FlickrFindr.view.saved.Details`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有很多视图，我们可以将它们分成`views`文件夹内的目录。例如，我们可以为我们的应用程序创建`search`和`saved`文件夹。在这种情况下，我们`search`文件夹的`Details.js`视图将是`FlickrFindr.view.search.Details`，而我们的`saved`文件夹的`Details.js`视图将是`FlickrFindr.view.saved.Details`。
- en: We will come back to this file a bit later, but for now, just familiarize yourself
    with the contents.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到这个文件，但现在，只需熟悉一下内容。
- en: Now that we have an idea of how our application needs to be laid out, we have
    one last task to perform before we really get started. We need to get an API key
    from Flickr.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道我们的应用程序应该如何布局，那么在真正开始之前我们还有一项任务要完成。我们需要从Flickr获取一个API密钥。
- en: Using the Flickr API
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Flickr API
- en: The majority of popular web applications have made an **API** (**Application**
    **Programming Interface**) available for use in other applications. This API works
    in pretty much the same way as our Sencha Touch Framework. The API provides a
    list of methods that can be used to read from, and even write data to, the remote
    server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数流行的网络应用程序都为其他应用程序提供了一个**API**（**应用程序编程接口**）。这个API的工作方式与我们的Sencha Touch框架几乎相同。API提供了一系列可以用来从远程服务器读取，甚至写入数据的方法。
- en: These APIs typically require a key in order to use them. This allows the service
    to keep track of who is using the service and curtail any abuses of the system.
    API keys are generally free and easy to acquire.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API通常需要一个密钥才能使用。这使得服务能够跟踪谁在使用服务并限制对系统的任何滥用。API密钥通常是免费且容易获得的。
- en: Go to the Flickr API site [http://www.flickr.com/services/api/](http://www.flickr.com/services/api/)
    and look for the phrase **API Keys**. Follow the link and apply for an API key
    using the form provided. When you receive your API key, it will be a 32-character-long
    string composed of numbers and lowercase letters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Flickr API网站[http://www.flickr.com/services/api/](http://www.flickr.com/services/api/)，寻找**API密钥**这个短语。点击链接，使用提供的表单申请API密钥。当您收到API密钥时，它将是一个由数字和小型字母组成的32个字符长的字符串。
- en: Each time you send a request to the Flickr API server, you will need to transmit
    this key as well. We will get to that part a bit later.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您向Flickr API服务器发送请求时，您都需要传输这个密钥。我们稍后会谈到这部分。
- en: The Flickr API covers a little over 250 methods. Some of these require you to
    be logged in with a Flickr account, but the others only require an API key.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Flickr API涵盖了超过250个方法。其中一些需要您使用Flickr账户登录，但其他方法只需要API密钥。
- en: For our purposes, we will be using a single API method called `flickr.photos.search`,
    which requires no login. This method looks for photos based on some criteria.
    We will be using the current latitude and longitude of the device to get back
    photos within a specified distance from our current location.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 出于我们的目的，我们将使用一个单一的API方法，称为`flickr.photos.search`，该方法无需登录。此方法根据某些标准寻找照片。我们将使用设备的当前纬度和经度来获取距离我们当前位置指定距离内的照片。
- en: Our search results come back to us as a big bundle of JSON format that we will
    need to decode for display.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的搜索结果以一大堆JSON格式返回，我们需要对其进行解码以显示。
- en: Once we have the API key, we can begin setting up our models, stores, views,
    and controllers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了API密钥，我们就可以开始设置我们的模型、存储、视图和控制器。
- en: Adding to the basic application
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向基本应用程序添加内容
- en: 'Let''s start by taking a look at our raw generated application. Currently,
    if you load the application into your web browser, you should see something like
    this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们生成的原始应用程序。目前，如果您将应用程序加载到您的网络浏览器中，您应该会看到类似这样的内容：
- en: '![Adding to the basic application](img/0748OS_08_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![添加到基本应用程序](img/0748OS_08_06.jpg)'
- en: 'This view we are looking at comes from the `app/view/Main.js` file, which is
    a tab panel with two subpanels. We are going to replace this code with a much
    simpler tab panel:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在查看的这个视图来自`app/view/Main.js`文件，这是一个带有两个子面板的标签面板。我们将用一个更简单的标签面板替换这段代码：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Like the code we are replacing, this component extends a tab panel and sets
    an `xtype` of `main`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们正在替换的代码一样，这个组件扩展了一个标签面板并设置了一个`xtype`为`main`。
- en: In this context, `xtype` can seem a little confusing since `Ext.tab.Panel` already
    has `xtype` of `tabpanel`. However, since we are extending the tab panel, we are
    actually creating a new component, and this means that we can set `xtype` for
    the component. `xtype` is completely arbitrary, but it must be unique across all
    components (including Sencha's own components). The use of `main` as `xtype` is
    a general convention for the starting container of your application. By setting
    a custom `xtype`, we can easily find the container from the controllers that we
    will create later on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`xtype`可能会有些令人困惑，因为`Ext.tab.Panel`已经有了`xtype`为`tabpanel`。然而，由于我们正在扩展标签面板，我们实际上是在创建一个新的组件，这意味着我们可以为这个组件设置`xtype`。`xtype`完全是任意的，但必须在所有组件（包括Sencha自己的组件）中唯一。使用`main`作为`xtype`是您应用程序开始容器的一般约定。通过设置自定义`xtype`，我们可以很容易地从我们稍后创建的控制器中找到容器。
- en: In our `requires` section, we have two new views listed, one for `FlickrFinder.view.SearchPanel`
    and the other for `FlickrFinder.view.SavedPanel`. Further down in this code block,
    you will see two `xtype` values listed in the `items` section, `searchpanel` and
    `savedpanel`, which correspond to these two required files. We need to create
    these files next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`requires`部分，我们列出了两个新的视图，一个是`FlickrFinder.view.SearchPanel`，另一个是`FlickrFinder.view.SavedPanel`。在这个代码块的稍下方，你将看到在`items`部分列出的两个`xtype`值，`searchpanel`和`savedpanel`，它们对应于这两个必需的文件。我们接下来需要创建这些文件。
- en: 'In your text editor, you need to create two new panel files in your `app/view`
    folder. The first one is called `SearchPanel.js`, and the code will look like
    this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中，你需要在你的`app/view`文件夹中创建两个新的面板文件。第一个叫做`SearchPanel.js`，代码将如下所示：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As with our `Main.js` file, we start out by setting the filename within the
    namespace to `FlickrFinder.view.SearchPanel`. However, this time we extend the
    `Ext.Panel` component instead of the tab panel.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的`Main.js`文件一样，我们首先将文件名设置在命名空间内为`FlickrFinder.view.SearchPanel`。然而，这次我们扩展了`Ext.Panel`组件而不是标签面板。
- en: We also set `xtype` to `searchpanel`, which should match the value we had in
    the `items` section of `app/view/Main.js`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了`xtype`为`searchpanel`，这应该与我们在`app/view/Main.js`的`items`部分中的值相匹配。
- en: Lastly, we set up our `config` section with `title`, `iconCls`, and `html`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用`title`、`iconCls`和`html`设置了我们的`config`部分。
- en: 'Next, we create a second panel in `app/view` called `SavedPanel.js`. This panel''s
    code looks almost the same as our previous panel:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`app/view`中创建了一个名为`SavedPanel.js`的第二个面板。这个面板的代码几乎与我们的上一个面板一样：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, we have just replaced the word `search` with the word `saved`.
    Once this second panel has been saved, you can reload the page to see this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只是将单词`search`替换为单词`saved`。一旦这个第二个面板保存完毕，你可以重新加载页面来看这个：
- en: '![Adding to the basic application](img/0748OS_08_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![添加到基本应用程序](img/0748OS_08_07.jpg)'
- en: We now have our tab panel with two base panels, and we can switch back and forth
    between the two.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个带有两个基本面板的标签面板，我们可以在这两个面板之间相互切换。
- en: Right now, our application doesn't do a lot, but we can fix that. Let's start
    by adding a pair of controllers to our application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序还做不了太多事情，但我们可以解决这个问题。让我们先为我们的应用程序添加一对控制器。
- en: Generating controllers with Sencha Cmd
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sencha Cmd生成控制器
- en: 'Much like our starter application, we can also generate controllers with Sencha
    Cmd. To do this, you will need to switch back to your terminal program and from
    there, change into your application directory (not the Sencha directory like we
    did when we generated the application). Changing into this directory lets Sencha
    Cmd know where to create the controller file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的入门应用程序一样，我们也可以使用Sencha Cmd生成控制器。为此，你需要回到你的终端程序，并从那里切换到你的应用程序目录（而不是Sencha目录，就像我们生成应用程序时那样）。切换到这个目录让Sencha
    Cmd知道在哪里创建控制器文件：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will create two starter files for our controllers, and adds a reference
    to those files in `app.js`. If you open up `app.js` after running those commands,
    you should now see a `controllers` section like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们的控制器创建两个启动文件，并在`app.js`中添加对这些文件的引用。如果您在运行这些命令后打开`app.js`，现在应该看到一个`controllers`部分，如下所示：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you open up one of the new controller files, you should see something like
    this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开其中一个新控制器文件，你应该看到类似这样的内容：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By creating these two empty controllers first, we can then add any models, views,
    and stores into our two `controller` files and leave `app.js` as it is (as it
    already includes our controllers).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先创建这两个空的控制器，我们然后可以将任何模型、视图和存储区添加到我们的两个`controller`文件中，并保持`app.js`不变（因为它已经包括了我们的控制器）。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注解
- en: In some older versions of Sencha Cmd, using the `generate controller` command
    would create the files but not add the `controllers` section to `app.js`. It's
    a good idea to check and make sure that the `controllers` section gets added or
    your files will fail to load. This will lead to errors and a lot of hair-pulling.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Sencha Cmd的旧版本中，使用`generate controller`命令会创建文件，但不会向`app.js`添加`controllers`部分。最好检查并确保`controllers`部分被添加，否则您的文件将无法加载。这将导致错误和很多扯头发的情况。
- en: A brief word about including files
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于包含文件的一些简要说明
- en: When you split code out into separate files, the framework needs to have a basic
    understanding of what files need to be included in order to make the application
    work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把代码分离到单独的文件中时，框架需要具备基本的理解，了解需要包含哪些文件才能使应用程序运行。
- en: Both `app.js` and our `controller` files can include sections for models, views,
    and stores. These sections can be specified in either set of files, but the best
    practice is to include `controllers` in `app.js` and let the individual controllers
    include the models, stores, and views.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`和我们`controller`文件都可以包括模型、视图和存储区段。这些部分可以在任意一组文件中指定，但最佳实践是在`app.js`中包括`controllers`，并让各个控制器包括模型、存储和视图。'
- en: Other components can contain a `required` section for including files. For example,
    in our `main.js` view, we require the two panel views (`savedPanel` and `searchPanel`)
    that are used in the `items` section of our `main.js` file. The `requires` section
    is used for any dependencies that are used directly in the component.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其他组件可以包含一个`required`部分来包含文件。例如，在我们的`main.js`视图中，我们要求两个面板视图（`savedPanel`和`searchPanel`），这些视图在我们的`main.js`文件中的`items`部分使用。`requires`部分用于任何直接在组件中使用的依赖项。
- en: We will see some examples of this when we create our models and stores.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建我们的模型和存储时将看到这个例子。
- en: Creating the Photo data model
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Photo数据模型
- en: Both our search and saved photos will be dealing with the same set of information.
    This means we can create a single shared model called Photo.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的搜索和保存的照片都将处理相同的信息集。这意味着我们可以创建一个单一共享的模型，称为Photo。
- en: Our photo data will be constrained in part by the data we can get back from
    the Flickr API. However, we also want to display the images as part of our search
    results. This means that we need to look at the Flickr API and see what is required
    to display an image from Flickr in our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的照片数据将在一定程度上受到我们从Flickr API能够获取的数据的限制。然而，我们还希望将图片作为搜索结果的一部分显示出来。这意味着我们需要查看Flickr
    API，并了解在应用程序中显示Flickr图片需要什么。
- en: 'If we take a look at [http://www.flickr.com/services/api/misc.urls.html](http://www.flickr.com/services/api/misc.urls.html),
    we see that **Photo Source URLs** in Flickr has the following structure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看[http://www.flickr.com/services/api/misc.urls.html](http://www.flickr.com/services/api/misc.urls.html)，我们会发现Flickr中的**Photo
    Source URLs**具有以下结构：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This means that, in order to display each photo, we need the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，为了显示每张照片，我们需要以下内容：
- en: '`farm-id`: This variable indicates the group of servers the image is on'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`farm-id`：这个变量指示图片所在的服务器群组'
- en: '`server-id`: This variable indicates the specific server the image is on'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server-id`：这个变量指示图片所在的特定服务器'
- en: '`id`: This variable indicates a unique ID for the image'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这个变量指示图片的唯一ID'
- en: '`secret`: This variable indicates the code used by the Flickr API to route
    requests'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret`：这个变量指示Flickr API用于路由请求的代码'
- en: These are all the variables that we get back as part of our `flickr.photos.search`
    request. We also get back the title for the photo, which we can use as part of
    our display. Now, we will use this information to create our model.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们作为`flickr.photos.search`请求的一部分收到的所有变量。我们还收到照片的标题，我们可以将其作为显示部分使用。现在，我们将使用这些信息来创建我们的模型。
- en: 'In the model directory, create a new file called `Photo.js`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型目录中，创建一个名为`Photo.js`的新文件：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start by defining our new model and extending `Ext.data.Model`. Next, we
    supply our field definitions in a series of `name type` values. If you leave the
    type blank, Sencha Touch will try to figure things out on its own, but it's a
    good idea to specify the type whenever possible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们新的模型并扩展`Ext.data.Model`。接下来，我们提供字段定义的一系列`name type`值。如果您留空类型，Sencha
    Touch会试图自己找出答案，但尽可能指定类型是个好主意。
- en: Now that we have a shared `Photo` model defined, we need to set up our individual
    components starting with our `SearchPhotos` components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了一个共享的`Photo`模型，接下来我们需要从我们的`SearchPhotos`组件开始设置个体组件。
- en: Making the SearchPhotos components
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作SearchPhotos组件
- en: For searching photos, we will need a store and two views (list and details).
    When our application launches, the `SearchPhotos.js` controller will determine
    the user's current location. The controller will then load the store based on
    that location and display the photos in our list component. When the user taps
    on an item in the list, the controller will grab our details view and use it to
    display more information about the photo.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搜索照片，我们将需要一个存储和两个视图（列表和详细信息）。当我们的应用程序启动时，`SearchPhotos.js`控制器将确定用户的当前位置。控制器然后根据该位置加载存储并在我们的列表组件中显示照片。当用户在列表中点击一个项目时，控制器将抓取我们的详细视图并使用它来显示有关照片的更多信息。
- en: Let's start by creating our data store.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建我们的数据存储。
- en: Creating the SearchPhotos store
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SearchPhotos存储
- en: The data store is in charge of contacting the Flickr API and getting the photos
    for our list. We will also need to include some basic information for paging and
    a reference to our shared model file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储负责与Flickr API联系并获取我们的列表中的照片。我们还需要包括一些基本的分页信息和对我们共享模型文件的引用。
- en: 'Create a new file in `app/store` called `SearchPhotos.js` and add the following
    code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/store`中创建一个名为`SearchPhotos.js`的新文件，并添加以下代码：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we define the `FlickrFindr.store.SearchPhotos` store and extend the standard
    `Ext.data.Store` store. Since we are using our previously created `Photo` model,
    we also need to add it to our `requires` section. We will be using a `jsonp` proxy
    for this store.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`FlickrFindr.store.SearchPhotos`存储，并扩展了标准的`Ext.data.Store`存储。由于我们正在使用我们之前创建的`Photo`模型，我们还需要将其添加到我们的`requires`部分。我们将使用一个`jsonp`代理来进行此存储。
- en: If you remember from [Chapter 6](ch06.html "Chapter 6. Getting the Data In"),
    *Getting the Data In*, this proxy type is used for handling requests to a separate
    server, much like JSONP. These cross-site requests require a callback function
    in order to process the data returned by the server. However, unlike JSONP, the
    `jsonp` proxy will handle the callback functionality for us almost automatically.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得从[第6章](ch06.html "第6章 获取数据 ")，*获取数据*，这个代理类型用于处理对不同服务器的请求，这与JSONP类似。这些跨站请求需要回调函数来处理服务器返回的数据。然而，与JSONP不同，`jsonp`代理将几乎自动处理回调功能为我们。
- en: 'We say almost because Flickr''s API expects to receive the callback variable
    as:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说几乎是因为Flickr的API期望回调变量作为：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By default, the store sends this variable as:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，存储将此变量作为：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Fortunately, we can change this by setting the following configuration option:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过设置以下配置选项来改变这一点：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next section in the previous code snippet sets the URL for contacting the
    Flickr API, that is, `url: ''`[http://api.flickr.com/services/rest/](http://api.flickr.com/services/rest/)`''`.
    This URL is the same for any requests to the Flickr API.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码片段中的下一部分设置了用于与Flickr API联系的URL，即`url: ''`[http://api.flickr.com/services/rest/](http://api.flickr.com/services/rest/)`''`。这个URL对Flickr
    API的任何请求都相同。'
- en: There are a number of additional parameters we will need to send to the Flickr
    API to get what we need, but we will handle that later on in the controller.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向Flickr API发送许多其他参数以获取我们需要的内容，但我们会稍后在控制器中处理。
- en: 'Once we get our data back, we pass it to the reader:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们返回数据，我们就将其传递给读取器：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since our response from Flickr''s API will be in JSON, we need to set `type:
    ''json''` in our `reader` function, We also need to tell the `reader` function
    where to start looking for photos in the `json` array that gets returned from
    Flickr. In this case, `root: ''photos.photo''` is the correct value. The last
    thing we need is `totalProperty` that tells the reader where to get the total
    number of photos we get back from Flickr. We will use this value for paging.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们从Flickr API得到的响应是JSON格式，我们需要在`reader`函数中设置`type: ''json''`。我们还需要告诉`reader`函数在从Flickr返回的`json`数组中寻找照片的开始位置。在这个例子中，`root:
    ''photos.photo''`是正确的值。我们需要的最后一件事是`totalProperty`，它告诉读者我们从Flickr返回的总照片数。我们将使用这个值进行分页。'
- en: 'Now that we have our data model and store set up, we need two views: the `SearchPhotoList`
    view and the `SearchPhotoDetails` view.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了数据模型和存储，我们还需要两个视图：`SearchPhotoList`视图和`SearchPhotoDetails`视图。
- en: Creating the SearchPhotos list
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SearchPhotos列表
- en: 'We need two views for the `SearchPhotos` part of our applications: a list component
    and a panel for the details. We will start out by creating our list component.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为应用程序中的`SearchPhotos`部分创建两个视图：一个列表组件和一个用于详细信息的面板。我们将从创建列表组件开始。
- en: Create a `SearchPhotoList.js` file in our `views` folder. This will be the first
    of our two views for `SearchPhotos`. Each view represents a single Sencha Touch
    display component. In this case, we will be using an `Ext.dataview.List` class
    for display and an XTemplate to control the layout of the list.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`views`文件夹中创建一个`SearchPhotoList.js`文件。这将是我们的两个`SearchPhotos`视图中的第一个。每个视图代表一个Sencha
    Touch显示组件。在这个例子中，我们将使用`Ext.dataview.List`类进行显示和XTemplate来控制列表的布局。
- en: 'At the top of the file, our XTemplate looks as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，我们的XTemplate看起来如下：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first part of our XTemplate supplies the HTML we are going to populate with
    our date. We start by declaring a `div` tag with the class `searchresult`. This
    gives us a class we can use later on to specify which photo result is being tapped.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的XTemplate的第一部分为我们提供了将要填充日期的HTML。我们首先声明一个带类`searchresult`的`div`标签。这给了我们一个类，我们可以稍后用来指定哪个照片结果被点击。
- en: Next, we have an image tag, which needs to include a Flickr image URL for the
    photo we want in the list. We could assemble this string as part of the HTML of
    our XTemplate, but we are going to take the opportunity to add some flexibility
    by making this into a function on our XTemplate.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个图片标签，需要包含我们要在列表中的Flickr图片的URL。我们可以在XTemplate的HTML中组装这个字符串，但我们打算通过将其变成XTemplate上的一个函数来增加一些灵活性。
- en: 'Flickr offers us a number of sizing options when using photos in this way.
    We can pass any of the following options along as part of our Flickr image URL:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Flickr在使用照片时为我们提供了多种尺寸选项。我们可以作为我们Flickr图片URL的一部分传递以下任何一个选项：
- en: '`s`: This refers to a small square, 75 x 75'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：这指的是小尺寸的正方形，75 x 75像素'
- en: '`t`: This refers to a thumbnail, 100 on the longest side'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`：这指的是缩略图，最长边为100像素'
- en: '`m`: This refers to a small image, 240 on the longest side'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：这指的是小尺寸的图片，最长边为240像素'
- en: '`-`: This refers to a medium image, 500 on the longest side'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：这指的是中等尺寸的图片，最长边为500像素'
- en: '`z`: This refers to a larger image, 640 on the longest side'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z`：这指的是更大尺寸的图片，最长边为640像素'
- en: '`b`: This refers to a large image, 1024 on the longest side'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：这指的是大尺寸图片，最长边为1024像素'
- en: '`o`: This refers to the original image, either JPG, GIF, or PNG, depending
    on the source format'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o`：这指的是原始图片，根据源格式是JPG、GIF还是PNG'
- en: We want to set our function to take one of these options along with our template
    values and create the Flickr image URL. Our function first looks to see if we
    were passed a value for size, and if not, we set it to `s`, by default using `size
    = size || 's';`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要设置我们的函数，接收这些选项之一以及我们的模板值，并创建Flickr图片URL。我们的函数首先查看是否传递了尺寸的值，如果没有，我们将其设置为默认的`s`，即`size
    = size || 's';`。
- en: Next, we assemble the URL using our XTemplate values and the respective sizes.
    Finally, we return the URL for use in our XTemplate HTML. This will let us create
    a thumbnail for each of our images.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们的XTemplate值和相应的尺寸组装URL，最后返回URL供我们的XTemplate HTML使用。这将让我们为我们的每张图片创建一个缩略图。
- en: 'Now, we need to define our list and pass it the XTemplate and store we created
    previously. After the definition for our XTemplate, add the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义我们的列表，并向其传递我们之前创建的XTemplate和存储。在我们XTemplate的定义之后，添加以下代码：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we define and extend, just as we have done with our other components.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义并扩展，就像我们对待其他组件一样。
- en: Since we are using `SearchPhotosStore` to feed our list, we also need to have
    it in our `requires` section. Down in the `config` section, we have the basic
    `store` and `itemTpl` configurations for our `list` component.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`SearchPhotosStore`来填充我们的列表，我们还需要在`requires`部分中包含它。在`config`部分，我们有我们的`list`组件的基本`store`和`itemTpl`配置。
- en: Creating the Navigation view
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建导航视图
- en: Now that we have `SearchPhotoList`, we need to add it to the `SearchPhotos`
    panel, but before we do that, we need to talk a bit about our functionality.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`SearchPhotoList`，我们需要将其添加到`SearchPhotos`面板上，但在我们这样做之前，我们需要谈谈我们的功能。
- en: 'The idea of a list-and-details view is very common among applications: This
    comprises a list of items with limited information, which the user can select
    to view a more detailed page on the item. The details page typically includes
    a button or link back to the main list. In fact, this functionality is so common
    that Sencha has a built-in component for handling it, called a **Navigation view**.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和详情视图的应用程序非常普遍：这包括一个带有有限信息的条目列表，用户可以选择查看关于该项目的更详细页面。详情页通常包括一个回到主列表的按钮或链接。实际上，这种功能如此普遍，以至于Sencha有一个内置组件来处理它，称为**导航视图**。
- en: 'The Navigation view functions much like a card layout, where only one of the
    items inside the container is visible at a time. However, the Navigation layout
    has two special functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 导航视图的运作方式类似于卡片布局，其中容器内的只有一个项目是可见的。然而，导航布局有两个特殊功能：
- en: '**push**: This function adds a new component to the Navigation view and shows
    the new component with an animated transition'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**push**：此函数将新组件添加到导航视图中，并通过动画过渡显示新组件'
- en: '**pop**: This function removes a component from the Navigation view and shows
    the previous component with an animated transition'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pop**：此函数从导航视图中删除组件，并通过动画过渡显示上一个组件'
- en: The Navigation view also adds a **Back** button each time you push a new container
    onto it. This allows you to deeply nest data and have the layout itself control
    your navigation.We will use this type of view to control the flow between our
    list and details views, which means that we need to make a change to our `SearchPanel.js`
    file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 导航视图还会每次向其添加新容器时添加一个**返回**按钮。这允许您深入嵌套数据，并使布局本身控制您的导航。我们将使用这种视图来控制列表和详情视图之间的流程，这意味着我们需要对我们的`SearchPanel.js`文件进行一些更改。
- en: 'First, locate the line that says:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，找到如下行：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then change it to:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其更改为：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This single change turns our exiting panel into a Navigation view.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一的更改把我们现有的面板变成了一个导航视图。
- en: 'Next, we need to remove our HTML from the old panel and add in our `ShowPhoto`
    list. By adding it directly to the Navigation view, we will make it the first
    thing we see when the panel loads. To do this, change the line:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的HTML从旧的面板中移除，并添加我们的`ShowPhoto`列表。通过直接将其添加到导航视图中，它将成为面板加载时我们首先看到的内容。为此，更改该行：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Later on in the controller, we will see how the details panel is added to the
    navigation view, but first we need to create the details view itself.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后在我们控制器中，我们将了解如何将详情面板添加到导航视图中，但首先我们需要创建一个详情视图。
- en: Creating the SearchPhotoDetails view
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SearchPhotoDetails视图
- en: As we said before, when the user clicks on a photo in the list, we want to be
    able to show a larger version of the photo and offer the user the opportunity
    to add this to a saved list of photos.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，当用户在列表中点击一个照片时，我们希望能够显示照片的大图，并给用户提供将此照片添加到照片收藏列表的机会。
- en: 'We will start out with a very basic panel for this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个非常基础的面板开始：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have our two views, we need to edit our controller to make the views
    actually work.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的两个视图，我们需要编辑我们的控制器以使视图真正工作。
- en: Creating the SearchPhotos controller
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SearchPhotos控制器
- en: 'Our `SearchPhotos` controller needs to accomplish the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SearchPhotos`控制器需要实现以下功能：
- en: Obtain the user's location
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户的位置
- en: Load photos from Flickr that are close to that location
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Flickr加载接近该位置的照片
- en: Allow the user to page through the photos
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户翻页查看照片
- en: Allow the user to select a photo from the list and view a larger version
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户从列表中选择照片并查看大图
- en: The first two pieces of this will be accomplished inside the controller's `launch`
    function so that they happen automatically when the application starts. The others
    will be handled by separate functions that we attach to the events from our components.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个部分将在控制器`launch`函数内完成，以便在应用程序启动时自动执行。其他部分将由我们附加到组件事件的单独函数处理。
- en: Before we get to that, we want to include our store and view files and set up
    a few references to make it easier to address the components inside our controller.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之前，我们想要包括我们的存储和视图文件，并设置一些引用，以便更容易地从控制器内部引用组件。
- en: 'Open up our `SearchPhotos.js` file in the `controller` folder. If you followed
    along with us and generated the controller files from Sencha Cmd, you will see
    placeholders for `refs` and `controls`. On top of these placeholders and inside
    the `config` section, we need to add our views and our store:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`controller`文件夹中的`SearchPhotos.js`文件。如果你跟随我们一起使用Sencha Cmd生成控制器文件，你会看到`refs`和`controls`的占位符。在这些占位符上方并在`config`部分内，我们需要添加我们的视图和我们的存储：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `views` and `stores` sections list the pieces of our application that this
    controller will be communicating with. Next, we will add some references to make
    it easier to access these pieces from inside the controller. In the `refs` section
    (after our `stores` section), add the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`views`和`stores`部分列出了我们应用程序中此控制器将进行通信的部分。接下来，我们将添加一些引用，以便更容易从控制器内部访问这些部分。在`refs`部分（在我们的`stores`部分之后），添加以下内容：'
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `refs` section consists of sets of name: target pairs. The name is arbitrary
    and the target can be `xtype` or a valid `Ext.ComponentQuery()` string.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`refs`部分由一系列名称：目标对组成。名称是任意的，目标可以是`xtype`或者一个有效的`Ext.ComponentQuery()`字符串。'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Ext.ComponentQuery` lets you search for a specific component using a language
    similar to a standard CSS selector. For more details, see [http://docs.sencha.com/touch/2.2.0/#!/api/Ext.ComponentQuery](http://docs.sencha.com/touch/2.2.0/#!/api/Ext.ComponentQuery).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.ComponentQuery`让你使用类似于标准CSS选择器的语言来搜索特定的组件。有关详细信息，请参阅[http://docs.sencha.com/touch/2.2.0/#!/api/Ext.ComponentQuery](http://docs.sencha.com/touch/2.2.0/#!/api/Ext.ComponentQuery)。'
- en: 'These `refs` will allow us to grab a component from anywhere inside our controller
    using `this.getName()`. For example, if we need to add a component to our `searchpanel`
    from inside our controller, we can simply use the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`refs`将允许我们从控制器内的任何地方抓取组件，使用`this.getName()`。例如，如果我们需要从控制器内部向我们的`searchpanel`添加一个组件，我们可以简单地使用以下代码：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that the names will always be uppercased when using
    `this.getName()`. So if we had set up our reference to be `searchPhotoList:'searchphotolist'`
    (with a lowercase "s"), we would still need to use `this.getSearchPhotoList()`
    (with a capital "S") to return the component.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在使用`this.getName()`时，名称总是大写的。所以如果我们设置我们的引用为`searchPhotoList:'searchphotolist'`（有一个小写的"s"），我们仍然需要使用`this.getSearchPhotoList()`（有一个大写的"S"）来返回组件。
- en: Now that we have our references, we are going to skip the `controls` section
    right now and set up our `launch` function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的引用，我们将跳过当前的`controls`部分，并设置我们的`launch`函数。
- en: Setting up the launch function
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置launch函数
- en: Our `launch` function is where we find the user's location and contact the Flickr
    API to get back our photos. The first thing we need to do is set up some default
    values—just in case the user declines to share their location, or we can determine
    their location.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`launch`函数是我们查找用户位置并与Flickr API联系以获取我们的照片的地方。我们需要做的第一件事是设置一些默认值——以防用户拒绝分享他们的位置，或者我们可以确定他们的位置。
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first part of the preceding code snippet creates a new date by using the
    current date and subtracting one year from it. This gives us the date exactly
    one year ago from this date. We will use this date to get back only photos that
    have been posted in the last year.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段的第一部分通过使用当前日期并从中减去一年来创建一个新的日期。这给了我们正好是一年前的日期。我们将使用这个日期来获取仅在过去一年内发布的照片。
- en: Our `easyparams` variable is a set of default parameters that we will send to
    Flickr's API if we cannot get a valid user location. These include our minimum
    upload date, latitude, and longitude (our defaults are for New York, in the middle
    of Times Square). We also include values for accuracy, radius, and radius units,
    to define how wide our search should be.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`easyparams`变量是一组默认参数，如果我们无法获取有效的用户位置，我们将发送给Flickr的API。这些包括我们的最小上传日期、纬度和经度（我们的默认值是纽约，位于时代广场中央）。我们还包括准确度、半径和半径单位的值，以定义我们的搜索应该有多宽。
- en: Lastly, we have a method (which is the API method we will use), your Flickr
    API key, and a format for the returned data (in this case, JSON). As previously
    noted in the *Using the Flickr API* section, you will need to obtain your own
    API key and use it here.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个方法（这是我们将会使用的API方法），你的Flickr API密钥，以及返回数据的格式（在这个例子中，是JSON）。如在*使用Flickr
    API*部分 previously noted所提到的，你需要获取你自己的API密钥并在这里使用它。
- en: Now that we have some defaults, let's see if we can grab the user's location
    with `Ext.util.Geolocation`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有一些默认值，让我们看看是否可以用`Ext.util.Geolocation`获取用户的地理位置。
- en: Using Ext.util.Geolocation
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Ext.util.Geolocation
- en: The `Ext.util.Geolocation` component allows us to use the web browser to retrieve
    the user's location. This class is based on the Geolocation API specification
    built into most modern browsers. When this component is called, the user is prompted
    and asked if they are willing to share their location with the application. If
    they confirm, the component will return a latitude and longitude for the user's
    current location.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.util.Geolocation`组件允许我们使用网络浏览器检索用户的地理位置。这个类是基于大多数现代浏览器内置的Geolocation API规范。当这个组件被调用时，用户会被提示并询问他们是否愿意与应用程序分享他们的位置。如果他们确认，组件将返回用户当前位置的纬度和经度。'
- en: 'After our default `easyparams` definition, add the following code to access
    the Geolocation component:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的默认`easyparams`定义之后，添加以下代码以访问Geolocation组件：
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This one is a bit long, so let's take it one piece at a time.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分有点长，所以我们一次看一部分。
- en: We begin by creating a new instance of the `Ext.util.Geolocation` component.
    We set `autoUpdate` to `false`, which keeps the component from trying to continually
    update our location. The idea is that the component will fire only once the application
    opens (this also keeps us from hammering the user's battery life). Next, we set
    a `timeout value` of 10000 milliseconds (10 seconds). This means that once the
    user confirms we are allowed to access their location, the component will spend
    10 seconds attempting to get the location information before timing out and reporting
    an error.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`Ext.util.Geolocation`组件的新实例。我们将`autoUpdate`设置为`false`，这使得组件不会试图不断更新我们的位置。想法是组件会在应用程序打开时仅触发一次（这也让我们不会过度消耗用户的电池寿命）。接下来，我们将`timeout
    value`设置为10000毫秒（10秒）。这意味着一旦用户确认我们被允许访问他们的位置，组件将在10秒内尝试获取位置信息，然后在超时并报告错误。
- en: That's really it for the configuration of `Ext.util.Geolocation`, but now we
    need to set up listeners for dealing with the data that comes back from the component.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Ext.util.Geolocation`的配置就这样了，但现在我们需要为处理组件返回的数据设置监听器。
- en: 'We have two basic possibilities for event feedback from `Ext.util.Geolocation`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Ext.util.Geolocation`中获得了事件反馈的两个基本可能性：
- en: '`locationupdate`: We get this if we got back a valid location for the user'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locationupdate`: 如果我们为用户返回了一个有效的地理位置，就会得到这个。'
- en: '`locationerror`: We get this if something happened and we are unable to get
    a valid location for the user'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locationerror`: 如果发生了一些事情，我们无法为用户获取有效的地理位置，就会得到这个。'
- en: 'Both of these events return our `Geolocation` object with some new data attached
    to it. In the case of `locationUpdate`, we get back:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个事件都返回我们的`Geolocation`对象，附带了一些新数据。在`locationUpdate`的情况下，我们返回：
- en: '`accuracy`: This gives the last retrieved accuracy level of the latitude and
    longitude coordinates'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accuracy`: 这给出了最后检索到的纬度和经度坐标的准确度级别。'
- en: '`altitude`: This gives the last retrieved height of the position specified
    in meters above the ellipsoid'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`altitude`: 这给出了指定位置上椭圆体以上的最后检索到的米高度。'
- en: '`altitudeAccuracy`: This gives the last retrieved accuracy level of the altitude
    coordinate, specified in meters'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`altitudeAccuracy`: 这给出了高度坐标的最后检索到的准确度级别，以米为单位。'
- en: '`heading`: This gives the last retrieved direction of travel of the hosting
    device, specified in non-negative degrees between 0 and 359, counting clockwise
    relative to the true north (this reports `NAN` if the speed is zero)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heading`: 这给出了托管设备的最后检索到的旅行方向，以0到359之间的非负度数表示，相对于真北顺时针计数（如果速度为零，则报告`NAN`）'
- en: '`latitude`: This gives the last retrieved geographical coordinate specified
    in degrees'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`latitude`: 这给出了最后检索到的地理坐标，以度为单位。'
- en: '`longitude`: This gives the last retrieved geographical coordinate specified
    in degrees'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longitude`: 这给出了最后检索到的经度坐标，以度为单位。'
- en: '`speed`: This gives the last retrieved current ground speed of the device specified
    in meters per second'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speed`: 这给出了设备最后检索到的当前地面速度，以每秒米为单位。'
- en: 'For this application, we are only interested in the latitude and longitude
    that we will pass in to our `easyparams` object. From the previous example code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们只对我们将传递给我们的`easyparams`对象的纬度和经度感兴趣。从前面的示例代码：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is the same as our default object, but with accurate coordinates for our
    location. We can then grab our data `store`, add the `easyparams` object, so it
    gets sent with our request, and call the store's `load` function to retrieve the
    photos.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这和我们的默认对象一样，但我们的位置有了准确的坐标。然后我们可以获取我们的数据`store`，添加`easyparams`对象，以便它随我们的请求发送，并调用商店的`load`函数来获取照片。
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will cause the photos to appear in our `SearchPhotoList` component.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致照片出现在我们的`SearchPhotoList`组件中。
- en: The `locationError` listener will fire if we can't get a location for the user.
    It simply alerts the user that we could not get a location and then loads our
    default set of `easyparams`, with the New York location.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法为用户获取位置，`locationError`监听器将会触发。它 simply 提示用户我们无法获取位置，然后加载我们的默认`easyparams`设置，以纽约的位置为准。
- en: The last thing we do in our `launch` function is fire the `updateLocation` function
    on our `Geolocation` object using `geo.updateLocation();`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`launch`函数做的最后一件事是使用`geo.updateLocation();`调用我们的`Geolocation`对象的`updateLocation`函数。
- en: At this point, you should be able to launch the application and see a list of
    photos near your location.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该能够启动应用程序并看到靠近你位置的一组照片。
- en: '![Using Ext.util.Geolocation](img/0748OS_08_08.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Ext.util.Geolocation](img/0748OS_08_08.jpg)'
- en: Now that we have our basic list working, we can swipe up or down to scroll.
    However, we need to add a bit more functionality before we finish up with our
    controller.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基本的列表，我们可以上下滑动来滚动。然而，在完成我们的控制器之前，我们需要添加一些更多功能。
- en: As you may have noticed, we can scroll but can't view any details yet. Also,
    we only loaded the first 25 photos from our search results. We need to have a
    way to tell the list that we want to tap an item to view the details and swipe
    an item to page through our list of photos. However, as it turns out, we don't
    want to tell the list anything. We actually want to listen to it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们可以滚动，但还不能查看任何详细信息。此外，我们从搜索结果中只加载了前25张照片。我们需要有一种方法来告诉列表，我们想要点击一个项目来查看详细信息，滑动一个项目来浏览我们的照片列表。然而，结果证明，我们并不想告诉列表任何东西。我们实际上想要监听它。
- en: Listening to the list
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听列表
- en: Our list has a number of helpful events that it sends out in response to the
    user's interactions. The ones we are most concerned with are `itemswipe` and `itemtap`.
    We need to listen for those events in our controller and write functions to execute
    when those events occur. Let's start with our `itemtap` event.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的列表在响应用户互动时会发送许多有用的活动。我们最关心的是`itemswipe`和`itemtap`这两个事件。我们需要在我们的控制器中监听这些事件，并编写在事件发生时执行的函数。让我们从`itemtap`事件开始。
- en: 'In order to listen to an event, we need to add it into the `controls` section
    of `controller` as shown in the following code snippet:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监听一个事件，我们需要将其添加到`controller`的`controls`部分，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since we previously made a reference to `SearchPhotoList:'searchphotolist'`
    in our `controller`, we can use the shorthand `SearchPhotoList` to indicate that
    we are adding listeners to our list.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们之前在`controller`中提到了`SearchPhotoList:'searchphotolist'`，我们可以使用缩写`SearchPhotoList`来表示我们正在为我们的列表添加监听器。
- en: Here, we have specified that when our list fires the `itemtap` event, we want
    to execute a function called `showSearchPhotoDetails`. Next, we need to add that
    function to our `controller`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定当我们的列表触发`itemtap`事件时，我们想要执行一个名为`showSearchPhotoDetails`的函数。接下来，我们需要将该函数添加到我们的`controller`中。
- en: 'Add a comma after the `launch` function in `controller`, and then add the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在`controller`中的`launch`函数后加一个逗号，然后添加以下内容：
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function creates a new instance of our `SearchPhotoDetails` panel and sets
    its `title` and `record` based on the list item that was tapped (the record is
    passed along as part of the item tap event).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了我们`SearchPhotoDetails`面板的新实例，并根据被点击的列表项设置了它的`title`和`record`（记录作为项点击事件的一部分传递）。
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Sencha Touch Docs available at [http://docs.sencha.com/touch/2.2.0/](http://docs.sencha.com/touch/2.2.0/)
    will show a list of any values passed for a given event. Locate your component
    and then select an event from the **Events** list. A list of values passed by
    the event will be on the right-hand side of the event name. Clicking on the blue
    disclosure triangle will provide details on those event values.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch 文档可在此处找到：[http://docs.sencha.com/touch/2.2.0/](http://docs.sencha.com/touch/2.2.0/)，它将显示给定事件传递的任何值列表。找到您的组件，然后从**事件**列表中选择一个事件。事件的右侧将显示传递给事件的值列表。点击蓝色的展开三角形，将提供有关这些事件值的详细信息。
- en: By setting the record, we are also setting the data that will be used by our
    details template for display.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置记录，我们也设置了将被我们的详情模板用于显示的数据。
- en: Lastly, we push the new panel onto our `SearchPanel` navigation view component.
    Remember, since we added `ref` for this in `controller`, we can retrieve it using
    `this.getSearchPanel()`. Once we push the new panel onto our navigation view,
    the list will be hidden and the new panel shows up with our **Back** button. Give
    it a try.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将新面板推送到我们的`SearchPanel`导航视图组件。记住，由于我们在`controller`中为此添加了`ref`，我们可以使用`this.getSearchPanel()`来获取它。一旦我们将新面板推送到我们的导航视图，列表将被隐藏，而带有**返回**按钮的新面板将显示出来。试试看。
- en: '![Listening to the list](img/0748OS_08_09.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![监听列表](img/0748OS_08_09.jpg)'
- en: If you click on the **Back** button, the details panel is automatically removed
    from the stack, and the list will show up again.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**返回**按钮，详情面板会自动从堆栈中移除，列表会再次显示。
- en: Next, we need to handle the `itemswipe` function, so that it will load the next
    or previous page of items. In this case, we also need to do a bit of math to make
    sure that we don't try to page further than the beginning or end of our list.
    We will also need to do a bit of exploring to get the information we need from
    the event.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理`itemswipe`函数，以便它加载项目的下一页或上一页。在这种情况下，我们还需要做一点数学运算，以确保我们不会尝试翻页到列表的开始或结束。我们还需要探索一下，以获取我们从事件中需要的信息。
- en: 'First, let''s add our listener to `controller` by modifying the `controls`
    section to look like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过修改`controls`部分，将我们的监听器添加到`controller`中，使其看起来像这样：
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, we need to add our `pageChange` function after our previous `showSearchPhotoDetails`
    function. We will use this function to figure out the direction in which the user
    has swiped, so we know if we should go forward or backward in our paging.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的`showSearchPhotoDetails`函数之后添加我们的`pageChange`函数。我们将使用这个函数来确定用户滑过的方向，这样我们才知道是否应该在我们的分页中向前或向后。
- en: 'From the Sencha Docs, we can see that the `itemswipe` event returns the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Sencha 文档中，我们可以看到`itemswipe`事件返回以下内容：
- en: '`this`: This is our list component'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`：这是我们列表组件'
- en: '`index`: This is the index of the item swiped'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：这是被滑过的项目的索引'
- en: '`target`: This is the element or `DataItem` swiped'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这是被滑过的元素或`DataItem`。'
- en: '`record`: This is the record associated with the item'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`record`：这是与项目相关的记录'
- en: '`e`: This is the `event` object'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`：这是事件对象'
- en: '`eOpts`: This is the `options` object passed to `Ext.util.Observable.addListener`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eOpts`：这是传递给`Ext.util.Observable.addListener`的`options`对象'
- en: 'The direction that the user is swiping is buried inside the event object `e`.
    We can find the values we need by outputting the `event` object to the console
    log. So to begin with, let''s make our `pageChange` function look like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 用户滑动的方向存储在事件对象`e`中。我们可以通过将`event`对象输出到控制台日志来获取我们需要的值。所以首先，让我们让我们的`pageChange`函数看起来像这样：
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we reload our application and swipe one of the items in our list, we should
    see a listing for `e` in our console. Click on the disclosure triangle next to
    the listing to see all the details as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新加载我们的应用程序并滑动我们列表中的一个项目，我们应该在控制台看到`e`的列表。点击列表旁边的展开三角形，查看以下所有详细信息：
- en: '![Listening to the list](img/0748OS_08_10.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![监听列表](img/0748OS_08_10.jpg)'
- en: From the details in the preceding screenshot, we can see that we get a lot of
    information back from the event, but the piece we need is just the **direction**.
    This means we can test for `e.direction` in our function to see which way we need
    to page the list of photos.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面屏幕截图的详情中，我们可以看到我们从事件中获得了很多信息，但我们需要的只是**方向**。这意味着我们可以在我们的函数中测试`e.direction`，以查看我们需要翻页列表照片的方向。
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we get our store by grabbing the list and calling `getStore()`. Next,
    we test whether our swipe direction is to the `left` or not. If the swipe goes
    to the left, we are paging back.If our current page is `1`, we don't want to go
    backwards. If our page is greater than `1`, we page back using `store.previousPage();`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过获取列表并调用`getStore()`来获取我们的商店。接下来，我们测试我们的滑动方向是否是向`左`。如果滑动方向是向左，我们是在翻页回退。如果我们的当前页面是`1`，我们不想后退。如果我们的页面大于`1`，我们使用`store.previousPage();`进行后退翻页。
- en: If we have swiped to right, we need to make sure we are not at the last page
    before we try to go to the next page. We do this by grabbing the `total` number
    of photos and `pageSize` from `store`. By dividing the total number of photos
    by the page count and rounding it off (`Math.floor`), we can get the number of
    the last page. We can then compare that to `currentPage` and decide whether we
    need to move forward to the next page.You should now be able to swipe back and
    forth across an item to navigate the pages of the list.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向右滑动，我们需要确保在尝试翻到下一页之前，我们不在最后一页。我们通过获取商店中的`total`照片数量和`pageSize`来实现。通过将照片总数除以页数并四舍五入（`Math.floor`），我们可以得到最后一页的编号。然后，我们将该编号与`currentPage`进行比较，以决定是否需要翻到下一页。现在，您应该能够通过在项目之间左右滑动来导航列表的页面。
- en: Now that we can view our photos in full size, let's set up a `savedphoto` component
    that will allow us to save a link to any photos we like.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以查看我们的照片的全尺寸，让我们设置一个`savedphoto`组件，允许我们保存任何我们喜欢的照片的链接。
- en: Building the SavedPhotos components
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建SavedPhotos组件
- en: Our `SavedPhotos` components will need to store the information for a single
    photo from our search results. We will also need a list view for our saved photos
    and a details view, just like our previous `SearchPhotosList` and `SearchPhotoDetails`
    models.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SavedPhotos`组件将需要存储我们搜索结果中单张照片的信息。我们还需要一个用于保存照片的列表视图和一个详细视图，就像我们之前的`SearchPhotosList`和`SearchPhotoDetails`模型一样。
- en: Creating the SavedPhotos store
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SavedPhotos商店
- en: Since our `SavedPhotos` and `SearchPhotos` components are storing the same type
    of data, we don't need to create a new model. We can just use our `Photo.js` model.
    However, we do need a separate data store, one that will store our `Photo` model
    locally.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`SavedPhotos`和`SearchPhotos`组件存储的是相同类型的数据，我们不需要创建一个新的模型。我们只需使用我们的`Photo.js`模型。然而，我们确实需要一个单独的数据存储，一个可以本地存储我们的`Photo`模型的存储。
- en: 'Let''s create a new file called `SavedPhotosStore.js` in our `app/store` folder
    and add the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`app/store`文件夹中创建一个名为`SavedPhotosStore.js`的新文件，并添加以下代码：
- en: '[PRE37]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we just create our `FlickrFindr.store.SavedPhotosStore` class and extend
    `Ext.data.store`. We also reuse our `FlickrFindr.model.Photo` model and set it
    as part of our required files. We also want this store to load up when the application
    launches (`autoLoad: true`) and we want it to set the page size to `25`. Since
    it is grabbing local data, this should not present a huge load for the application.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们只需创建一个`FlickrFindr.store.SavedPhotosStore`类，并扩展`Ext.data.store`。我们还重用了我们的`FlickrFindr.model.Photo`模型，并将其设置为我们所需文件的一部分。我们还希望这个商店在应用程序启动时加载（`autoLoad:
    true`），并将其页面大小设置为`25`。由于它正在获取本地数据，这对应用程序的加载不会造成很大的负担。'
- en: For this store, we are going to include a `storeId`, so we can grab the store
    later on in our `controller`.We set our proxy to store the data locally and assign
    the proxy an `id` component, `flickr-saved`, that will be used to store our data.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个商店，我们将包含一个`storeId`，这样我们可以在稍后的控制器中获取商店。我们将我们的代理设置为本地存储数据，并为代理分配一个`id`组件，`flickr-saved`，用于存储我们的数据。
- en: 'Once we are finished with the `SavedPhotosStore.js` file, we will need to add
    it to our `SavedPhotos.js` controller. Open the `controller` file and add the
    following in the `config` section:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成`SavedPhotosStore.js`文件后，我们需要将其添加到我们的`SavedPhotos.js`控制器中。打开`controller`文件，在`config`部分添加以下内容：
- en: '[PRE38]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will make sure our store gets loaded. Next, we need to set up our two views
    for list and details.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们的商店被加载。接下来，我们需要为列表和详细信息设置两个视图。
- en: Creating the SavedPhoto views
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SavedPhoto视图
- en: For the `SavedPhoto` views, we need a list and a details view. These views will
    be very close to what we already have for our `SearchPhotosList` and `SearchPhotoDetails`
    models. In fact, we can start by making copies of those two files and tweaking
    our layouts a bit.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SavedPhoto`视图，我们需要一个列表和一个详细视图。这些视图将非常类似于我们为`SearchPhotosList`和`SearchPhotoDetails`模型已经拥有的视图。实际上，我们可以先复制这两个文件，并稍微调整一下我们的布局。
- en: 'In the `views` folder, make a copy of `SearchPhotoList.js`, and rename it as
    `SavedPhotoList.js`. You will also need to replace all the occurrences of `SearchPhoto`
    and `searchphoto`, with `SavedPhoto` and `savedphoto`, respectively (remember
    that JavaScript is case-sensitive). Your code should look as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views`文件夹中，复制`SearchPhotoList.js`文件，并将其重命名为`SavedPhotoList.js`。你还需要将所有出现的`SearchPhoto`和`searchphoto`替换为`SavedPhoto`和`savedphoto`（记住JavaScript是大小写敏感的）。你的代码应如下所示：
- en: '[PRE39]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You will notice that we have created a duplicate of the original `SearchResultTpl`
    template in this file. If we wanted, we could simply reuse our `FlickrFindr.view.SearchResultTpl`
    class from the `SearchPhotos.js` file. It is perfectly fine to reuse the template,
    but this allows us the option of changing the look of saved photos in a list if
    we choose to.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在这个文件中创建了原始`SearchResultTpl`模板的副本。如果我们愿意，我们完全可以重用`SearchPhotos.js`文件中的`FlickrFindr.view.SearchResultTpl`类。重用模板是可以的，但这允许我们选择更改保存照片列表的外观。
- en: Other than that, the file is largely the same as our `SearchPhotosList.js` file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，文件与我们的`SearchPhotosList.js`文件基本相同。
- en: Note
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While it might seem a bit redundant to have two files that are so similar, it
    should be noted that they both read from different data stores, and that they
    need to be addressed differently by the controllers. It also gives us the opportunity
    to tweak the look of our different views later on.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能看起来有点冗余，拥有两个如此相似的文件，但应该注意的是，它们都从不同的数据存储中读取，并且需要被控制器以不同的方式处理。这也给了我们稍后调整不同视图外观的机会。
- en: For our `SavedPhotoDetails` view, we will take a similar approach. Copy the
    `SearchPhotoDetails.js` file to your `views` folder and rename it as `SavedPhotoDetails.js`.
    This file will display a single saved photo. However, unlike the details for our
    search photos, this saved photo details panel will get a **Remove** button instead
    of a **Save** button.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`SavedPhotoDetails`视图，我们将采取类似的步骤。将`SearchPhotoDetails.js`文件复制到你的`views`文件夹中，并将其重命名为`SavedPhotoDetails.js`。这个文件将显示一张保存的照片。然而，与我们的搜索照片详情不同，这个保存的照片详情面板将获得一个**Remove**按钮而不是**Save**按钮。
- en: 'You will need to modify the file to change the **Save** button as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改文件，将**Save**按钮更改为以下内容：
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is much the same as the `SearchPhotoDetails` file we created earlier; we
    have switched the names and changed our **Add** button to a **Remove** button.
    We will add the functionality for these buttons into our controllers in just a
    moment.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前创建的`SearchPhotoDetails`文件非常相似；我们只是交换了名称并将我们的**Add**按钮更改为**Remove**按钮。我们将在控制器中为这些按钮添加功能。
- en: First, as we did with `SearchPhotosList`, we need to add `SavedPhotosList` to
    our `SavedPanel.js` file, and change it to extend `Ext.navigation.View` instead
    of `Ext.Panel`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像我们对待`SearchPhotosList`一样，我们需要在`SavedPanel.js`文件中添加`SavedPhotosList`，并将其更改为扩展`Ext.navigation.View`而不是`Ext.Panel`。
- en: 'Open up `SavedPanel.js` and modify the code to make it look like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`SavedPanel.js`并修改代码，使其看起来像这样：
- en: '[PRE41]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once we have the two views, we will need to add them into our `SavedPhotos.js`
    controller. Open the `app/controller/SavedPhotos.js`file and add the following
    code inside the `config` section:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两个视图，我们还需要将它们添加到我们的`SavedPhotos.js`控制器中。打开`app/controller/SavedPhotos.js`文件，在`config`部分添加以下代码：
- en: '[PRE42]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we can start hooking up the rest of the controllers. We will start by taking
    a trip back to our `SearchPhotos.js` controller to hook up the **Add** button.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始连接其他的控制器。我们将首先回到我们的`SearchPhotos.js`控制器来连接**Add**按钮。
- en: Finishing up the Add button in SearchPhotos
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成SearchPhotos中的Add按钮
- en: 'Open up `SearchPhotos.js` in the `controller` folder; let''s add a control
    for our **Save** button. In the `control` section, underneath our `SearchPhotoList`
    control, we add the control for the button as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`controller`文件夹中的`SearchPhotos.js`；让我们给我们的**Save**按钮添加一个控制。在`control`部分，在我们的`SearchPhotoList`控制下方，我们添加按钮的控制如下：
- en: '[PRE43]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we need to add our `savePhoto` function after our previous function definitions:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的上一个函数定义之后添加我们的`savePhoto`函数：
- en: '[PRE44]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need two pieces to make this function work: the record from our details
    panel and the Saved Photos store, so we can load `SavedPhotoList` once the record
    is saved.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两件东西来让这个功能工作：来自我们的详情面板的记录和Saved Photos存储，这样我们就可以在记录保存后加载`SavedPhotoList`。
- en: We grabbed the record by using the `up` function on our button to look for our
    `searchphotodetails` panel and then used `getRecord();`. We used `StoreManager`
    to `lookup` the store by its unique ID.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用按钮上的`up`函数查找我们的`searchphotodetails`面板，然后使用`getRecord();`获取记录。我们使用`StoreManager`通过其唯一ID`lookup`了商店。
- en: Next, we used the model's `save()` function to save the model using the model's
    proxy (not the store's proxy). We then used the callback function to load the
    store and switch our view after the model had been saved successfully.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用了模型的`save()`函数来使用模型的代理（而不是商店的代理）保存模型。然后我们使用回调函数在模型成功保存后加载商店并切换我们的视图。
- en: Tip
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You will notice that we also have an option `this` set on the end of the `save`
    function. As part of the `save` function, we can set the scope of our `callback`
    function, which you may remember from earlier in the book. By setting the scope
    to `this`, when we reference `this` inside our function (`this.getMain()`), we
    are talking about the controller and not the function itself.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们还在`save`函数的末尾设置了一个选项`this`。作为`save`函数的一部分，我们可以设置我们`callback`函数的作用域，这可能会让你想起书早先的部分。通过将作用域设置为`this`，当我们在函数内部引用`this`（`this.getMain()`）时，我们是在谈论控制器，而不是函数本身。
- en: Now that you have our function set up, you should be able to reload the application
    and save photos.We still need to be able to access the details for Saved Photos
    and remove the ones we no longer want.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然你已经设置了我们的函数，你应该能够重新加载应用程序并保存照片。我们还需要能够访问已保存照片的详细信息，并删除我们不再想要的照片。
- en: Updating the SavedPhotos controller
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新`SavedPhotos`控制器
- en: Inside our `SavedPhotos` controller, we need to add some refs and controls just
    like we did in the `SearchPhotos` controller.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`SavedPhotos`控制器内部，我们需要添加一些引用和控件，就像我们在`SearchPhotos`控制器中做的那样。
- en: 'Open the `SavedPhotos.js` file and modify the `refs` and `controls` sections
    like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`SavedPhotos.js`文件，像这样修改`refs`和`controls`部分：
- en: '[PRE45]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This gives us `refs` for our list and panel (we don't need one for `main`),
    and `controls` for three functions that will work in pretty much the same way
    as our `SearchPhotos` functions.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们列表和面板的`refs`（我们不需要`main`的），以及三个将几乎以与我们的`SearchPhotos`函数相同方式工作的`controls`。
- en: 'Let''s start with the `showSavedPhotoDetails` function and add the following
    after the `config` section:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`showSavedPhotoDetails`函数开始，在`config`部分后添加以下内容：
- en: '[PRE46]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Much like our previous `showSearchPhotosDetails` function, this creates a new
    copy of our `SavedPhotoDetails` view, assigns a title and record, and then pushes
    it onto our `SavedPanel`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的上一个`showSearchPhotosDetails`函数非常相似，这个创建了我们`SavedPhotoDetails`视图的新副本，分配了一个标题和记录，然后将其推到我们的`SavedPanel`中。
- en: 'Next, we have our `pageChange` function. You can copy and paste this one from
    our `SearchPhotos.js` controller:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的`pageChange`函数。你可以从我们的`SearchPhotos.js`控制器中复制并粘贴这个函数：
- en: '[PRE47]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The only line we need to change in the preceding code snippet is the third line,
    where we get `store` for our `SavedPhotoList`. Other than that, this function
    accomplishes the same outcome as it did in our other controller; it detects the
    swipe from the user and pages back and forth through the results.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前代码片段中需要更改的只有一行，即第三行，我们在那里获取我们的`SavedPhotoList`的`store`。除此之外，这个函数实现了与我们的另一个控制器相同的结果；它检测用户的滑动，并在结果之间前后翻页。
- en: 'The last piece we need is our `removePhoto` function. This one will be a bit
    different. When we remove a photo from our list of saved photos, we need to `pop`
    the details view off our `SavedPanel` navigation view instead of changing the
    view:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一片是我们的`removePhoto`函数。这个会有些不同。当我们从我们的已保存照片列表中删除一张照片时，我们需要从我们的`SavedPanel`导航视图中`pop`掉详细信息视图，而不是更改视图：
- en: '[PRE48]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For this function, we used the `erase()` method to remove the record from our
    local storage. We then loaded the store as before and used the `pop()` function
    to remove our details view. When this view is removed, our `SavedPanel` navigation
    view will automatically switch back to `SavedPhotosList`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数，我们使用了`erase()`方法从我们的本地存储中删除记录。然后像以前一样加载商店，并使用`pop()`函数删除我们的详细信息视图。当这个视图被删除时，我们的`SavedPanel`导航视图将自动切换回`SavedPhotosList`。
- en: Polishing your application
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打磨你的应用程序
- en: Now that we've finished our application, we will want to add some finishing
    touches to really make our application shine and add a level of professionalism
    to the completed product. The good news is that all of these are easily and quickly
    implemented.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们已经完成了我们的应用程序，我们将会想要添加一些最后的润色，真正让我们的应用程序焕发光彩，并给完成的产品增加一层专业性。好消息是，所有这些都可以很容易地快速实施。
- en: Adding application icons and startup screens
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加应用程序图标和启动屏幕
- en: As mentioned back in [Chapter 1](ch01.html "Chapter 1. Let's Begin with Sencha
    Touch"), *Let's Begin with Sencha Touch*, users can navigate to your web application,
    and then choose to save it to the desktop of their mobile device.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](ch01.html "第1章 Let's Begin with Sencha Touch")中提到的*Let's Begin with
    Sencha Touch*，用户可以导航到你的网络应用程序，然后选择将其保存到他们移动设备的桌面。
- en: '![Adding application icons and startup screens](img/0748OS_08_11.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![添加应用程序图标和启动屏幕](img/0748OS_08_11.jpg)'
- en: In our current application, when someone installs it in this fashion, the default
    Sencha icon is displayed. However, you can modify the default icon that is displayed
    on the home screen.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的应用程序中，当某人以此方式安装它时，默认的Sencha图标会被显示。然而，你可以修改在主屏幕上显示的默认图标。
- en: The `references` folder contains all of the icons that your application will
    use for various devices. It also contains a startup folder with images for the
    startup screens used by the application on various devices.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`references`文件夹包含你的应用程序将用于各种设备的所有图标。它还包括一个启动文件夹，其中包含应用程序在各种设备上使用的启动屏幕图像。'
- en: Any of these images can be edited to customize your application's appearance.
    Just make sure you save them in the same format, the same size, and with the same
    name.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图片都可以编辑以自定义应用程序的外观。只需确保你将它们保存为相同的格式、大小和名称。
- en: Improving the application
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进应用程序
- en: 'There''s still plenty of room for improvement in our application, but we will
    leave this as extra credit for the reader. Some things you might want to try are
    as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序仍有很大的改进空间，但我们将这一点留给读者作为额外的加分项。你可能想要尝试的一些事情如下：
- en: Allow the user to rename photos when they are saved
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户在保存时重新命名照片
- en: Add an expert search, where you can set your location manually or widen the
    search radius
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个专家搜索功能，你可以手动设置你的位置或扩大搜索半径
- en: Change the theme and make XTemplates more appealing
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改主题并使XTemplates更具吸引力
- en: Add the ability to save locations as well as photos
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加保存位置以及照片的能力
- en: Try using the MVC organization techniques we have covered in this chapter to
    expand the application and sharpen your skills.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用我们在本章中介绍的MVC组织技巧来扩展应用程序并提高你的技能。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gave you an introduction to the MVC design pattern. We talked
    about setting up a more robust folder structure and created your main application
    files. We started our application with an overview of Flickr API and explored
    how to register our various model, view, and controller components. We then set
    up our components for the `SearchPhotos` and `SavedPhotos` components. We wrapped
    up the chapter with some hints for putting the finishing touches on your application
    and talked about a few extra pieces you might want to add to the application.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向你介绍了MVC设计模式。我们谈论了建立一个更健壮的文件夹结构，并创建了你的主要应用程序文件。我们以Flickr API的概览开始了我们的应用程序，并探讨了如何注册我们的各种模型、视图和控制器组件。然后我们为`SearchPhotos`和`SavedPhotos`组件设置了我们的组件。我们最后给出了几点关于为你的应用程序添加收尾工作的建议，并谈论了几件你可能想要添加到应用程序中的额外内容。
- en: In the next chapter, we will cover a few advanced topics such as building your
    own API's, creating offline applications using a manifest system, and compiling
    applications with a program such as PhoneGap.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些高级主题，例如构建你自己的API、使用清单系统创建离线应用程序，以及使用PhoneGap等程序编译应用程序。
