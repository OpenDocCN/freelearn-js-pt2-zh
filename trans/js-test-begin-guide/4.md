# 四、规划测试

> 欢迎来到第四章。 在我们进入一个更正式的测试过程之前，我们必须首先理解测试是关于什么的。 在本章中，我们将学习如何制定测试 JavaScript 程序的计划。 我们将学习您应该知道的各种测试概念，然后我将向您介绍一个简短的指导方针，作为下一章的基础。

在我们进入各种测试概念之前，我们首先需要对以下问题有一个简短的了解:

*   为了进行测试，我们真的需要一个测试计划吗?
*   我们应该在什么时候为代码开发测试计划?
*   我们的程序需要多少测试?

在介绍完以上问题后，我们将学习以下测试概念和思路:

*   黑盒测试、白盒测试以及相关概念
*   边界条件
*   单元测试
*   网页功能测试
*   集成测试
*   非功能测试，例如性能测试
*   可用性测试
*   测试顺序——我们首先执行上述哪个测试?
*   回归测试——这通常在我们对代码进行更改时进行

为了更好地概述测试在何时何地起作用，我们将首先非常简要地介绍软件生命周期。

# 软件生命周期的简要介绍

理解软件生命周期将帮助您对软件开发过程有更深入的了解，更重要的是，测试将在何时何地发挥作用。

软件生命周期一般分为以下几个阶段:

2.  设计

5.  部署

在第一阶段，我们通常执行分析以了解涉众的需求是什么。 例如，如果您正在为客户执行一个定制的项目，您将需要了解用户需求、系统需求和业务目标。 一旦您了解了需求，您将需要设计软件。 在这个阶段要做的事情包括绘制数据流程图，设计数据库，等等。 下一阶段是实现阶段。 我们可以把这看作是实际的编码过程。

接下来是测试，这是本书的主要重点。 在本章中，我们将学习如何基于各种测试概念来计划我们的测试。 在测试阶段之后，我们将部署项目，最后我们将维护项目。 因为这是一个循环，理论上我们会在维护阶段期间或之后回到分析阶段。 这是因为软件或程序是进化的; 随着需求和需求的变化，我们的软件也在变化。

尽管术语和阶段的数量可能与您在其他相关内容中看到的略有不同，但过程通常是相同的。 这里的主要要点是，测试通常在实现之后进行。

## 敏捷方法

您可能听说过敏捷方法，它包括敏捷软件开发方法，当然还有敏捷测试方法。

一般来说，敏捷软件开发和测试方法通常是考虑到最终用户或客户的。 通常很少有文档，并且关注较短的软件开发周期，通常持续一到四周。

那么，这与您在前一节中读到的软件开发周期有什么关系呢? 一般来说，测试本身并不是一个单独的阶段，而是与开发过程紧密地结合在一起的，当代码变得足够稳定，可以执行测试时，从客户的角度尽可能早地对代码进行测试。

### 敏捷方法和软件周期的行动

你可能很难想象以前的理论是如何产生的。 为本书创建示例代码的过程非常类似于软件生命周期和敏捷方法。 因此，我想我将非常简短地与您分享我的经验，当我为这本书创建代码示例时，基于我们所学的理论。

### 分析设计

从技术上讲，分析和设计阶段发生在我考虑什么样的代码样本可以满足这本书的目标时。 我认为代码应该足够简单，而且最重要的是应该演示 JavaScript 的各种特性。 在后面的章节中，代码应该为代码测试奠定基础。

### 实现和测试

实现阶段发生在我编写代码示例时。 当我为代码片段创建函数时，我尽可能地进行测试，并自问代码是否可以演示 JavaScript 的使用并在以后方便测试。

所以，这里所发生的是，我使用了某种形式的敏捷测试，我尽可能经常地测试。

### 部署

在业务世界中，代码的部署通常发生在代码被转移给最终用户之后。 然而，在我的情况下，部署涉及将代码示例发送给编辑器。

### 维护

当我在代码提交后修复编辑器发现的错误时，就出现了维护阶段。 尽管有最好的意图，代码并不总是没有错误的。

# 你是否需要一个测试计划来进行测试?

您很可能需要一个测试计划来执行测试。 这是因为计划可以帮助你明确测试的目标。 它还可以帮助您确定要在程序上执行何种测试。

最重要的是，正如您将认识到的那样，为了执行彻底的测试，您将需要实现各种测试，包括基于白盒测试和黑盒测试、网页测试、单元测试、集成测试等的测试概念。 测试计划还可以作为测试数据、错误、测试结果和错误的可能解决方案的记录。 这意味着为了确保您不会错过任何东西，最好有一个关于测试什么、什么时候测试以及如何测试您的程序的可靠计划。

# 什么时候制定测试计划

理论上，如果您查看软件开发周期，您将看到测试在实现之后进行。 测试计划的开发应该在您完成程序的实现(实际的编码过程)之后进行。 这是因为只有在这一点上，您才确定了哪些特性、方法和模块; 基于您已经做过的事情来计划要测试什么具有良好的商业意义，因为您知道要关注什么。

然而，在实践中，建议在实现过程之前就开始规划。 根据您的情况，您当然可以开发一个高级测试计划(HLTP)或高级测试用例(HLTC)。 如果您正在开发一个大型而复杂的系统，并且打算解决总体需求，那么就需要使用 HLTP。 其他支持测试计划用于处理系统的细节。 HLTC 有点类似于 HLTP，除了它涵盖了与系统的总体需求直接相关的主要功能的测试用例之外。

您应该注意的另一点是，在实践中，测试计划可以大致分为系统测试和用户验收测试。 系统测试涵盖了所有形式的功能测试和非功能测试(稍后您将了解到)，而用户验收测试是在将所有权转移给最终用户之前由最终用户执行测试的阶段。

# 需要多少测试?

您可能急于确定哪些需要测试，哪些不需要。 尽管对于需要多少测试有许多不同的争论，但我个人认为，在下面的部分中列出的程序的各个方面应该定义测试计划的范围。

## 代码的目的是什么?

首先，您需要理解代码的目的是什么。 例如，前几章中代码的业务需求是根据用户的输入(例如他的当前年龄、他希望退休的年龄、他的当前支出、当前工资等)计算用户是否能按时退休。 因此，我们创建了满足业务需求的代码。 一旦我们知道代码要做什么，我们就可以测试代码是否满足我们的业务需求。

## 测试代码是否满足我们的需求

通过测试代码，看看它是否满足我们的业务需求，我们的意思是，对于每个输入，我们需要得到正确的输出。 回到我们的例子在第二章,*特别的测试和调试 JavaScript*和[第三章](3.html "Chapter 3. Syntax Validation"),*语法验证*,我需要确保如果剩饭总收入不到所需的钱退休,输出将是“无法退休”, 至少是伪意义上的。 从测试的角度来看，我们需要做的是确保无论何时所提到的条件为真，输出都将是“无法退休”的。

这可以通过一个叫做白盒测试的概念来实现，在白盒测试中，测试是基于测试人员知道代码是关于什么的假设进行的。 我将在接下来的章节中介绍白盒测试和其他测试概念的具体细节。 为了给您一个提示，您将遇到的一些测试概念包括单元测试(在小单元中测试代码)和边界值测试(测试代码的最大或最小可接受值)。

我们需要考虑的下一件事是如何测试或检测用户的无效操作。

## 测试用户的无效操作

“永远不要相信用户”是我们在开发 Web 时最常听到的一句话。 这是因为可能有恶意用户试图通过提供无效输入来“破坏”您的应用。 使用前面章节的示例，名称的输入字段只能接受字符和空格，年龄和工资的输入字段只能接受数字，而不能接受字符。 然而，如果有人试图在年龄或薪水字段中输入字符，这将是无效的行为。

我们的程序必须足够健壮，以测试或检查无效的操作; 错误的输入将导致错误的输出。

## 对以上问题的简要总结

通过了解代码的目的和目的，并了解检测用户无效操作的需要，您已经定义了测试计划的范围。 您的测试应该围绕这些标准进行。

现在，我们可以继续讨论您将用于测试的各个方面的各种测试概念，以及测试计划的构建块—主要的测试概念和策略。

# 主要测试概念和策略

在本节中，我们将介绍不同类型的测试概念和策略。 我不打算对每个概念进行过多的详细介绍，但我需要你了解其中的要点，并了解这些概念的来源。 在您熟悉了这些概念之后，我们将继续创建实际的测试计划。 作为开始，我将从开发人员遵循的业务策略开始(无论您是为外部客户还是内部客户执行项目)，以便您能够对如何执行测试有一个高层次的了解。 一般来说，无论您采用什么测试概念、方法或意识形态，您都将面临以下测试用例:

*   功能性需求测试
*   非功能性需求测试
*   验收测试

## 功能需求测试

功能需求测试是指对软件系统的代码、功能或模块进行测试。 例如，回到我们为前几章编写的代码，功能需求包括以下内容:

1.  检查用户输入的有效性。
2.  如果第 1 步的输入有效，则在用户将鼠标移到下一个输入框后，当前输入框的右侧将出现一个新的输入框。
3.  根据用户的输入，提供正确的计算输出。 例如，如果用户退休需要 100 万美元，而他退休时只有 50 万美元，那么他将无法退休。

本章中涉及的功能需求测试的例子如下:

*   网页测试
*   边界测试
*   等价划分

## 非功能性需求测试

非功能性需求测试是指与软件的功能或特定行为无关的测试需求。 相反，它是一个需求，指定了可以用来判断软件操作的标准。

例如，功能性需求是我们的软件应该能够存储用户输入的值，而非功能性需求是数据库应该实时更新。

另一个例子在前几章,有关我们的样例代码是一个功能性需求将是一个软件,它能够计算我们的用户是否能够按时退休,和一个非功能性需求将是一个我们应该直观的用户界面。 现在您看到非功能性需求和功能性需求之间的区别了吗?

本章中涉及的非功能需求测试的例子如下:

*   性能测试
*   可用性测试
*   集成测试

作为软件开发人员，您在整个职业生涯中可能遇到的其他非功能性需求如下:

*   快速加载页面
*   搜索引擎优化网页
*   您创建的软件的文档
*   系统效率
*   软件的可靠性
*   您所生成的软件代码的互操作性。 例如，您可以跨主流浏览器编写 JavaScript 代码

## 验收测试

验收测试通常是整个测试过程的最后阶段。 这通常是在客户最终接受软件之前完成的。 验收测试可以进一步分为两部分。 软件供应商首先执行验收测试，然后执行最终用户的验收测试(称为用户验收测试)。

验收测试是您的客户(或最终用户)将在您创建的软件上执行实际测试(类似于系统的实际使用)的时间。 一个典型的过程将包括由反映软件业务使用的最终用户创建的测试用例。

如果您正在使用敏捷测试方法，这样的测试用例通常被称为故事。 这取决于客户将如何在业务环境中使用它们。 在用户验收测试之后，您将把产品的所有权转移给您的客户。

在介绍了最常见的测试场景之后，我们将继续讨论测试概念的细节。 我们将从最常见的测试概念之一开始，即黑盒测试概念。

## 黑匣子测试

黑盒测试属于“盒子方法”，在这种方法中，一个软件被视为一个盒子，这个盒子包含各种功能、方法、类等等。 打个比方，“黑盒子”通常意味着我们看不到盒子里面是什么。 这意味着我们在不知道程序内部结构的情况下实现测试; 我们采用程序的外部视角，使用有效和无效输入来确定输出是否正确。

因为我们不知道程序的内部结构和代码，我们只能从用户的角度来测试程序。 在这种情况下，我们可以尝试确定主要的功能是什么，然后尝试基于这些功能实现我们的测试。

黑盒测试的主要优点是测试结果通常是独立的，因为测试人员对代码没有任何了解。 然而，缺点是，因为测试人员不知道代码是关于什么的，测试人员可能会创建或执行重复的测试，或者无法测试软件最重要的方面的测试。 或者更糟的是，测试人员可能会错过整个函数或方法。

这就是为什么在现实世界中，测试用例是在开发周期的早期阶段准备的，这样我们就不会错过某些需求。 优点是测试人员可以访问所需的测试用例，但是同时，测试人员不需要完全了解代码。

黑盒测试的一些例子包括可用性测试、边界测试和 beta 测试。

### 可用性测试

简单地说，可用性测试通常包括从用户的角度进行测试，看看我们创建的程序是否易于使用。 这里的关键目标是观察使用我们程序的用户，发现错误或需要改进的地方。 可用性测试一般包括以下几个方面:

*   **性能:特别是在点击(或行动)，用户必须在订单中完成一个特定的任务，如注册为会员，或从网站购买产品，等等。**
*   **回忆:**用户在使用一段时间后，是否还记得如何使用该程序?
*   **准确性:**我们的程序设计是否会导致最终用户的错误?
*   **反馈:**反馈当然是最重要的 ajax 相关应用问题之一。 例如，在提交 AJAX 表单后，用户通常会等待某种形式的反馈(以视觉反馈的形式，如成功消息)。 但是想象一下——如果没有视觉反馈或成功信息，用户如何知道他提交的表单是成功还是失败呢?

### 边界测试

边界测试是测试最大值和最小值的一种测试方法。 边界测试有时包括误差值和典型值的测试。

例如，在前几章的程序中，我们允许输入名称的最大字符数是 20 个字符。

### 等价划分

等价分区测试是一种将一系列数据划分成测试用例可以从中导出的分区的技术。 例如，对于接受用户年龄的输入框，应该显示以下分区:

![Equivalence partitioning](graphics/0004_04_04.jpg)

注意，在我们的示例中，用户的年龄只接受正值，因为从技术上讲，一个人的年龄应该是正值。 因此，任何负值都是不可接受的值。

**的范围小于-231**和**比 231 - 1**,它是 asssumed 之间的整数只能持有价值-231**【5】和**231 - 1**由于硬件和 EMCA 运营商的需求。**

### Beta 测试

Beta 测试已经被当前流行的 Web 2.0 公司(如谷歌)所普及，在这些公司中，Web 应用通常发布给核心编程团队以外的有限用户。 Beta 测试发生在 alpha 测试之后，其中大多数错误和错误已经被检测和修复。 Beta 测试通常被用作从潜在用户那里获得反馈的一种方式。

这样的过程在开源项目中很常见，比如 Ubuntu(基于 Linux 的开源操作系统)、jQuery (JavaScript 库)和 Django(基于 python 的 web 框架)。 这样的开源项目或软件通常有一系列的 alpha 和 beta 版本。 在发布软件或项目的主要版本之前，他们通常也有候选版本。

## 白盒测试

白盒测试又称透明盒测试、玻璃盒测试或透明测试。 白盒测试可以被看作是黑盒测试的对立面; 我们用程序内部结构的知识来测试程序。 我们采用程序的内部透视图，并在执行测试计划时使用这个透视图。

白盒测试通常发生在测试可以访问程序的内部代码和数据结构时。 因为我们对我们的程序有一个内部的观点，并且有源代码的知识，所以我们基于我们的代码设计测试计划。

我们可能会发现自己在跟踪代码的执行路径，并计算出程序的各种函数或方法的输入和输出值。

白盒测试的一些例子包括 Branch 测试和 Pareto 测试。

### 分支检测

分支测试是一个概念，其中每个代码分支都应该至少测试一次。 这意味着所有已编写的函数或代码都应该进行测试。 在软件测试中，有一个被称为代码覆盖率的度量，它指的是一个程序的源代码被测试了多少。 一些更重要的分支测试覆盖类型包括以下内容:

*   功能覆盖:确保代码的每个功能都被调用(测试)
*   决策覆盖范围:每个 `if else`语句都经过了测试。 可能存在代码的 `if`部分有效，但 `else`部分无效的情况，反之亦然。

### 帕累托检验

帕累托测试是我个人所说的“现实世界”测试，它是在严格的时间和金钱限制下进行的。 这是因为帕累托测试只关注最常用的函数; 最常用的函数是最重要的，因此我们应该把时间和精力集中在测试这些函数上。 或者，我们可能会看到帕累托测试，大多数错误来自我们程序的少数几个函数; 因此，通过发现这些函数，我们可以更有效地测试程序。

### 注释

帕累托测试源于一个叫做“帕累托原则”的想法，或者更广为人知的“二八原则”。 帕累托原则表明，大约 80%的结果来自 20%的原因。 例如，80%的销售收入可能来自 20%的销售团队或客户。 或者另一个例子是世界上 80%的财富被世界上 20%的人口控制着。 应用在我们这里的例子中，我们可以说 80%的错误或程序错误来自于我们 20%的代码，因此我们应该集中测试这 20%的代码。 或者，我们可以说 80%的程序使用活动来自于 20%的代码。 类似地，我们可以集中测试那 20%的代码。 简单地说，帕累托测试可以被视为一种通用的测试原则，而不仅仅是一种白盒测试形式。

## 单元测试

单元测试将代码分解成用于测试的逻辑块，通常一次只关注一种方法。 单元可以看作是最小的代码块，如函数或方法。 这意味着在理想情况下，每个单位应该独立于所有其他单位。

当我们执行单元测试时，我们尝试在完成每个函数或方法时进行测试，从而确保在继续执行下一个函数或方法之前，我们拥有的任何代码都可以正常工作。

这有助于减少错误，您可能已经注意到，在前面的章节中，我们在开发 JavaScript 程序时以某种方式应用了单元测试的思想。 在创建每个函数时，我们会尽可能地测试它。

单元测试的一些好处包括最小化错误，并允许易于更改，因为每个功能或方法都是单独测试的，并且在很大程度上简化了集成。

在我看来，主要的好处是单元测试是灵活的，并且易于编写文档。 这是因为在编写和测试新函数时，我们可以很容易地注意到问题是什么，以及代码是否可以正确工作。 实际上，我们是在做增量文档——在测试时记录结果。

单元测试也是集成测试的一个组成部分，特别是在自下而上的方法中，因为我们从最小的单元开始测试程序，然后再转向更大的单元。 例如，当我为[Chapter 2](2.html "Chapter 2. Ad Hoc Testing and Debugging in JavaScript")，*Ad Hoc 测试和调试 Javascript*创建代码时，我基本上非正式地执行了单元测试。 我通过将每个函数作为单独的单元进行单元测试，并使用相关的 HTML 输入字段测试每个 JavaScript 函数，以确保获得正确的输出。 这种技术可以看作是在编写新代码时执行持续集成的一部分。

持续集成是一个过程，开发人员经常集成他们的代码，以防止集成错误。 这通常是在代码的自动构建(包括测试)的帮助下完成的，以检测集成测试。 当我们创建新代码时，与现有代码集成是很重要的，以确保不引入兼容性问题或新错误(甚至旧错误)。 持续集成正变得越来越流行，因为它集成了单元测试、修订控制和构建系统。

## 网页测试

如前所述，网页测试是功能测试的一种形式，通常是指从用户的角度对用户界面进行测试。 出于本文的目的，我们将结合 HTML 和 CSS 测试 JavaScript 程序。

Web 页面测试还包括针对不同浏览器和平台的正确性测试。 我们至少应该关注主要的网络浏览器，如 Internet Explorer 和 Firefox，看看演示文稿和 JavaScript 程序在不同的浏览器下是否可以工作。

要对浏览器的使用有一个简短的了解，您可能需要访问[http://www.w3schools.com/browsers/browsers_stats.asp](http://www.w3schools.com/browsers/browsers_stats.asp)，看看哪些浏览器是流行的，是在下降还是在上升。

### 注释

谷歌 Chrome 似乎获得了很大的发展势头，它有很好的机会成为一个流行的网络浏览器; 根据 w3schools 提供的统计数据，在不到两年的时间里，谷歌 Chrome 的市场份额从 3.15%增加到 14.5%。 这种流行程度的增加部分是由于它的 JavaScript 引擎性能。

网页测试的另一个重点还包括检查最常用的用户行为，如非法和合法的值、登录、注销、用户的错误行为、SQL、HTML 注入、检查 HTML 链接、图像、机器人攻击的可能性等。

由于 SQL、HTML 注入和机器人攻击超出了本书的范围，我们将重点关注其他问题，如确保 web 页面在不同的浏览器下工作，测试非法和合法的值，错误的行为和频繁的行为。

## 性能测试

性能测试有很多种类型，如负载测试、压力测试、持久测试、隔离测试、峰值测试等等。 我不想用细节来拖住你。 相反，我将重点讨论作为 JavaScript 程序员将面临的两个更常见的问题。

首先，性能可以指客户端下载一段 JavaScript 所需的时间。 你可能会说下载时间取决于网络连接。 但是，有一件简单的事情可以减少 JavaScript 的大小，而无需重构或重写，那就是压缩 JavaScript 代码。 JQuery 库是一个很好的例子，我们在第 3 章、*语法验证*中介绍了它。 如果您访问 JQuery 主页[http://jquery.com](http://jquery.com)，您可能会注意到 JQuery 有两种形式—生产版本和开发版本。 生产版本被缩小，文件大小为 24KB，而开发版本为 155KB。 显然，生产版本的文件更小，因此在下载 JavaScript 方面提高了性能。

### 注释

压缩代码或缩小代码是指为了减小文件大小而删除代码中所有不必要的空格和行。 有些代码缩小器会自动删除注释、替换函数、变量，甚至在不同的编码中进行编码。

其次，性能还可以指特定代码段在给定输入量下的执行速度。 一般来说，我们需要使用外部库或工具来帮助我们找出代码中哪些部分的执行速度相对较慢，或者瓶颈在哪里。 相关的工具，以及我们如何应用性能测试，将在[第 6 章](6.html "Chapter 6. Testing More Complex Code")，*测试更复杂的代码*中介绍。

## 集成测试

集成测试是验收测试之前测试过程的最后步骤之一。 因为我们已经确保了程序的基本构建模块作为一个单独的单元正确工作，我们现在需要确保它们是否可以一起工作。

集成测试指的是对程序中所有不同组件的测试。 不同的组成部分可以指我们到目前为止讨论过的各种单位。 集成测试的主要目标是确保功能、性能和可靠性需求得到满足。 我们还一起测试不同的单元，看看它们是否可以工作; 我们需要检查在组合单位时是否有任何不正常的地方。

集成测试可以采用不同的形式，例如自顶向下和自底向上的方法。

在自顶向下方法中，我们从最高层的集成模块开始，然后是子模块或每个模块的功能。 另一方面，自底向上的测试从最低层次的组件开始，然后再转移到更高层次的组件。

基于我们到目前为止看到的示例代码，很难理解集成测试是如何工作的。 一般来说，如果我们将 HTML 代码视为一个单元，将 CSS 视为一个单元，将每个单独的 JavaScript 函数视为一个单元，那么我们可以看到，集成测试将包括测试所有这三个单元，并确保它是正确的。

在自下而上的方法中，我们从基本的代码单元开始测试。 当我们测试基本的代码单元时，我们向上移动到测试更大的代码单元。 这个过程类似于单元测试。

## 回归测试——在做出更改后重复先前的测试

回归测试的重点是在程序被修改或升级时发现程序中的错误。 在现实生活中，我们倾向于对程序进行更改——无论是升级程序，还是添加新功能，等等。 关键的一点是，当我们对程序进行更改时，我们需要测试新组件，看看它们是否与旧组件协同工作。

我们需要执行回归测试，因为研究和经验表明，当程序被修改时，新的或旧的错误可能会出现。 例如，当添加新特性时，以前修复过的旧错误可能会重新引入程序，或者新特性本身可能包含影响现有特性的错误。 这就是回归测试的作用:我们执行以前的测试，以确保旧的组件仍然在运行，并且没有旧的错误重新出现。 我们用旧的组件测试新功能，以确保整个系统正常工作。 有时，为了节省时间和资源，我们可能只对新特性和旧组件一起执行测试。 此时，我们可以应用影响分析，通过添加或修改代码来确定应用的影响区域。

回归测试是真实的。 这是因为随着程序的增长，您可能会对代码进行更改。 当您对代码进行更改时，可能会给您的程序引入 bug 或不兼容性，而回归测试可以帮助您发现这些错误。

# 检测顺序

我们已经介绍了所需的背景知识，现在是了解应该从哪种测试开始的时候了。 我们执行测试的顺序取决于我们是想实现自底向上的测试还是自顶向下的测试。 这两种测试顺序都没有问题，但我个人更喜欢自下而上的测试:我通常首先开始单元测试，然后是其他类型的测试(取决于程序是什么样子的)，最后以集成测试结束。

采用这种方法的主要原因是单元测试允许我们更早地发现代码中的错误; 这可以防止错误或错误堆积。 此外，它还提供了选择如何记录测试结果的灵活性。

但是，如果您喜欢自顶向下的方法，那么您总是可以像终端用户一样开始测试程序。

在现实世界中，特别是在测试 web 应用方面，很难区分(至少在概念上)自下而上的测试和自顶向下的测试。 这是因为尽管用户界面和编程逻辑是分离的，但我们确实需要同时对两者进行测试，以便了解它是否按我们希望的方式工作。

尽管如此，测试顺序应该以用户验收测试结束，因为最终用户将最终使用我们的代码。

在下一节中，我们将向您展示如何记录您的测试计划。 您将注意到，我们将从用户的角度执行测试。 现在，是时候记录我们的测试计划了。

# 记录测试计划

既然我们已经涵盖了所需的测试概念，现在是学习如何创建测试计划的时候了。 同时，我们将记录我们的测试计划; 这将作为本章下一部分的基础，我们将在其中应用测试。

## 测试计划

我们的测试计划将包含一些我们之前提到过的概念，比如网页测试、边界测试、集成测试等等。 因为我们将测试应用在我们在[第二章](2.html "Chapter 2. Ad Hoc Testing and Debugging in JavaScript")、*Javascript*中使用过的代码上，所以我们有优势知道代码是关于什么的。 因此，我们可以以这样一种方式设计我们的测试过程，它可以结合黑盒测试和白盒测试的想法。

您可能想要进入 `source code`文件夹，并打开 `sample_test_plan.doc`文件，这是我们的示例测试计划。 这是一个非常简单和非正式的测试计划，它只包含所需组件的最低限度。 如果您正在编写文档供自己参考，那么使用简单的文档可以节省时间和精力。 但是，如果您正在为客户准备一个测试计划，那么您将需要一个更详细的文档。 为了简单起见，我们将使用 `source code`文件夹中提供的示例文档来帮助您快速理解规划过程。 我将简要介绍我们测试计划的组成部分，同时，我将向您介绍我们测试计划的主要组成部分。

### 版本管理

在第一个组件中，您将注意到有一个版本表，它记录了测试计划中的更改。 在现实世界中，计划会改变，因此，跟踪已经改变的事情是一个好习惯。

### 注释

另一种保持版本控制简单和可维护的方法是使用版本控制软件，如 Git 或 BitBucket。 这样的版本控制工具会记录您在代码中所做的更改; 这将使您能够跟踪所做的更改，并使创建测试计划更加容易。 Git 详情可访问[http://git-scm.com/](http://git-scm.com/)，BitBucket 详情可访问[http://bitbucket.org/](http://bitbucket.org/)。

### 测试策略

您应该注意到的下一个重要组件是测试策略。 测试策略代表了我们将用于测试计划的主要思想和想法。 您将看到我们同时使用白盒和黑盒测试，以及单元测试和集成测试。 因为我们的 JavaScript 程序是基于 web 的，所以我们隐式地执行了一种网页测试形式，尽管这在本章的后续部分中没有提到。 对于测试的每个阶段，我们将决定所需的测试值。 此外，如果您查看 `sample_test_plan.doc`，您将看到我以对期望值的简要描述的形式添加了测试每个部分的结果或响应。

#### 通过白盒测试测试预期值和可接受值

我们要做的第一件事是使用单元测试进行白盒测试。 因为我们对代码和用户界面(HTML 和 CSS 代码)有很强的理解，所以我们将在用户界面级别应用测试。 这意味着我们将通过输入我们决定的各种测试值来测试程序。

在本例中,我们将使用这个项目我们已经使用在第二章,*特别的测试和调试 Javascript*,[第三章](3.html "Chapter 3. Syntax Validation"),*语法验证*,看看这个项目我们预期的方式工作。 我们将在这里使用预期和可接受的值。 【显示】

输入将是程序要求我们输入的内容——对于需要输入姓名、出生地点等的输入字段，我们将在其中输入字符。 需要数字作为输入的输入字段，例如年龄、我们希望退休的年龄、工资、费用等等，我们将输入数字。

输入的详情如下(输入值只作示范用途):

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

输入字段

 | 

输入值(情况 1)

 | 

输入值(情况 2)

 |
| --- | --- | --- |
| 的名字 | 约翰尼的男孩 | 小比利 |
| 出生的地方 | San Francisco | San Francisco |
| 年龄 | 25 | 25 |
| 每月的支出 | 1000 | 1000 |
| 每月的工资 | 100000 | 2000 |
| 你希望退休的年龄 | 55 | 55 |
| 到退休年龄时我想要的钱 | 1000000 | 1000000 |

对于每个输入值，我们期望在屏幕中间的标题**Response**下动态创建一个相应的输入字段，同时，原始的输入字段将被禁用。 这就是测试的预期输出、结果或响应。 对于第一个表单的其余输入字段也是如此。 动态创建字段的示例如下图所示:

![Testing expected and acceptable values by using white box testing](graphics/0004_04_01.jpg)

注意，在截屏的中间，在标题**Response**下，有两个输入字段。 这些输入字段是动态创建的。

#### 通过黑盒测试测试预期值和不可接受值

我们要做的第二件事是通过使用边界值测试来执行黑盒测试。 这个测试分为两部分:首先测试程序的边界值，看看输出是否正确。 输入与我们在白盒测试中使用的类似，除了我们将为每个输入使用异常大的数字或异常多的字符。 我们还将使用单个数字和单个字符作为输入的一部分。 每个输入的输出应该与我们在白盒测试中看到的类似。

更具体地说，我们将使用以下测试值(注意，测试值纯粹是为了演示目的; 当你在创建你的程序时，你必须决定应该使用什么合适的边界值):

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

输入字段

 | 

最小值

 | 

共同价值

 | 

最大值

 | 

评论

 |
| --- | --- | --- | --- | --- |
| 的名字 | 单个字符，如' A ' | 尤金 | 一个非常长的字符串，不超过 255 个字符。 | 取值范围(X):单字符 1 <= X <= 255 个字符 |
| 出生的地方 | 单个字符，如 A | 纽约 | 一个非常长的字符串，不超过 255 个字符。 | 取值范围(X):单字符 1 <= X <= 255 个字符 |
| 年龄 | 1 | 25 | 不超过 200 年的历史 | 取值范围(X):1 <= x <= 200 |
| 每月的支出 | 1 | 2000 | 1000000000 | 取值范围(X):1 <= x <= 1000000000 |
| 每月的工资 | 2 | 5000 | 1000000000 | 注意，我们假设我们的用户赚的比花的多。取值范围(X): 1 <= X <= 1000000000 |
| 你希望退休的年龄 | 这个年龄应该比现在的年龄大 | 这个年龄应该比现在的年龄大 | 这个年龄应该比现在的年龄大 | 取值范围(X): 1 <= X <= 200 |
| 到退休年龄时我想要的钱 | 这里用 1 | 合适的数字，如 1000000 | 不超过一万亿美元 | 取值范围(X): 1 <= X <= 1000000000 |

如果您参考 `sample test`文档，您将意识到我为每个输入字段提供了一个值的示例范围。

### 注释

还记得我们在前面提到的等价划分吗? 在实践中，给定一个边界值，我们将测试与给定测试值相关的三个值。 例如，如果我们想测试一个边界值“50”，那么我们将测试 49、50 和 51。 然而，为了简单起见，我们只测试预期值。 这是因为在下一章中，我们将对给定值进行实际测试; 它可能会变得重复和乏味。 我只是想让你们知道现实世界的实践是什么。

这个测试的第二部分是我们将测试预期的非法值。 在第一个场景中，我们将使用既可接受又不可接受的值。 输入将类似于我们在白盒测试阶段所使用的，除了我们将使用字符作为需要数字的输入字段的输入，反之亦然。 当我们每次输入一个不可接受的值时，预期的输出是会有一个警告框告诉我们输入了一个错误的值。

具体请参见下表:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

输入字段

 | 

输入值

 | 

输入值情况 1

 | 

输入值情况 2

 | 

输入值情况 3

 |
| --- | --- | --- | --- | --- |
| 的名字 | 数字或空值 | 1 | ~!@#$%^&*()" | 测试 |
| 出生的地方 | 数字或空值 | 1 | ~!@#$%^&*()" | 测试 |
| 年龄 | 字符和空值 | 一个 | ~!@#$%^&*()" | - 1 |
| 每月的支出 | 字符和空值 | 一个 | ~!@#$%^&*()" | - 1 |
| 每月的工资 | 字符和空值 | 一个 | ~!@#$%^&*()" | - 1 |
| 你希望退休的年龄 | 字符和空值 | 一个 | ~!@#$%^&*()" | - 1 |
| 到退休年龄时我想要的钱 | 字符和空值 | 一个 | ~!@#$%^&*()" | - 1 |

一般来说，对于每个预期的非法值，我们应该期望程序用一个警告框来警告我们，告诉我们输入了错误类型的值。

在第二个测试场景中，我们将尝试输入非字母数字值，如感叹号、星号等。

在第三个测试场景中，我们将测试需要数字的输入字段是否为负值。 第三个测试场景的输入值如下:我们使用-1 来节省一些输入; 所以负的值，比如-100000，没有任何影响。

#### 程序逻辑测试

对于测试计划的这一部分，我们将尝试测试程序逻辑。 确保程序逻辑的一部分是确保输入是我们需要和想要的。 然而，程序逻辑的某些方面不能仅仅通过验证输入值来保证。

例如，我们对用户的一个隐含假设是，我们假设用户的退休年龄将大于他现在的年龄。 虽然这个假设在逻辑上是合理的，但用户可能根据传统的假设输入值，也可能不输入值。 因此，我们需要确保退休年龄大于现在的年龄，以保证方案的逻辑正确。

该测试的输入如下:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

输入字段

 | 

第一种形式的输入值

 |
| --- | --- |
| 的名字 | 约翰尼的男孩 |
| 出生的地方 | San Francisco |
| 年龄 | 30 |
| 每月的支出 | 1000 |
| 每月的工资 | 2000 |
| 你希望退休的年龄 | 25 |
| 到退休年龄时我想要的钱 | 1000000 |

这里需要注意的关键是“你希望退休的年龄”的值小于“age”。

我们应该期望我们的程序发现这个逻辑错误; 如果没有，我们将需要修复我们的程序。

#### 集成测试和测试意外值

最后一个阶段是集成测试，在这里我们测试整个程序，看看它是否可以一起工作，其中包括第一种形式，第二种形式是从第一种形式派生出来的，以此类推。

在第一个测试场景中，我们开始缓慢而稳定地测试预期和可接受的值。 第一个测试场景的输入值如下(输入值仅用于演示目的):

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

输入字段

 | 

输入值(案例 1)

 | 

输入值(情况 2)

 | 

输入值(情况 3)

 | 

输入值(案例 4)

 |
| --- | --- | --- | --- | --- |
| 的名字 | 约翰尼的男孩 | 约翰尼的男孩 | 约翰尼的男孩 | 约翰尼的男孩 |
| 出生的地方 | San Francisco | San Francisco | San Francisco | San Francisco |
| 年龄 | 25 | 25 | 25 | 25 |
| 每月的支出 | 1000 | 1000 | 1000 | 1000 |
| 每月的工资 | 100000 | 2000 | 2000 | 100000 |
| 你希望退休的年龄 | 55 | 55 | 28 | 28 |
| 到退休年龄时我想要的钱 | 2000000 | 2000000 | 1000000 | 100000 |

请注意带下划线的输入值。 设计这些输入值是为了确定我们是否会根据输入得到正确的响应。 例如,在输入的所有值和提交动态生成的第二种形式,例 1 和例 3 的输入值将导致输出说明用户将无法按时退休,而案例 2 和 4 的输入值将导致输出说明用户将退休。

下面的截图显示了如果用户可以按时退休，输出结果会是什么样子:

![Integrated testing and testing unexpected values](graphics/0004_04_02.jpg)

下一个截图显示了如果用户不能按时退休的输出:

![Integrated testing and testing unexpected values](graphics/0004_04_03.jpg)

请注意这两种不同情况的文本差异。

关于测试用例结果的详细信息，请打开 `sample_test_plan.doc`文件，该文件可以在本章的 `source code`文件夹中找到。

现在是第二个测试场景的时候了。 在第二个测试场景中，我们首先完成第一个表单中的值填充。 在提交动态创建的第二个表单之前，我们将尝试更改这些值。 输入值将包括我们在白盒测试和黑盒测试中使用的值。 第一个测试场景的输入值如下:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

输入字段

 | 

第一种形式的输入值

 | 

输入值第二种形式(随机值)

 |
| --- | --- | --- |
| 的名字 | 约翰尼的男孩 | 25 |
| 出生的地方 | San Francisco | 100 |
| 年龄 | 25 | 约翰尼的男孩 |
| 每月的支出 | 1000 | 一些字符 |
| 每月的工资 | 100000 | 多个字符 |
| 你希望退休的年龄 | 20 | 更多的字符 |
| 到退休年龄时我想要的钱 | 1000000 | 1000000 |

这个测试阶段的主要目标是测试第二种形式的健壮性，到目前为止，我们还没有对它进行验证。 如果第二种形式失败，我们将需要更改代码以增强程序的健壮性。

现在，我们将继续进行测试计划的下一个组件—发现的错误或 bug。

### Bug 形式

最后一个组件帮助我们记录我们发现的错误。 这个区域允许我们记录错误是什么，是什么导致了这些错误，以及这些错误发生的功能或特性。 一般来说，每当我们发现错误时，我们需要注意导致错误的确切函数，并对可能的解决方案进行注释。

## 我们测试计划的总结

上面介绍的组件是测试计划中一些最重要的组件。 一般来说，对于测试的每个阶段，我们都声明了我们的测试数据和预期的输出。 请注意，我们使用这个文档作为一种非正式的方式来提醒自己需要做什么测试，需要的输入，预期的输出，以及更重要的是我们已经发现的错误。 在这个示例文档中没有提到的一件事是，对发现的那些 bug 执行的操作; 这将在下一章中讨论。

# 小结

我们有效地执行了测试计划的规划过程。 尽管我们的测试计划是非正式的，但是我们已经看到了如何应用各种测试概念，以及不同的测试数据值来测试我们在前几章中创建的程序。

具体来说，我们涵盖了以下主题:

*   我们首先简要介绍了软件工程的关键方面。 我们已经知道测试发生在实现(编码)阶段之后。
*   我们已经学会了通过询问代码应该做什么来定义测试的范围，确保它做了它应该做的事情，最后测试用户的无效操作。
*   接下来，我们介绍了各种测试概念，如白盒测试、黑盒测试、单元测试、网页测试、性能测试、集成测试和回归测试。
*   我们也了解到我们需要从不同的方面来测试我们的程序，从而增强程序的健壮性。
*   虽然本章中介绍的测试概念可能在某些方面有所不同，但我们可以将它们归类为:测试预期但可接受的值，预期但不可接受的值，以及一般的意外值。 我们还学会了基于对所编写代码的理解来测试逻辑错误。
*   最后，我们计划并记录了我们的测试计划，其中包括测试过程描述、测试值、预期输出和其他重要组件，例如版本控制和 bug 形式。

尽管根据组织类型和应用类型的不同，测试方法可能有很大的不同，但这里列出的方法通常更适合轻量级 web 应用。 然而，这些概念也构成了大型复杂 web 应用的构建模块。

本章标志着测试计划的结束。 现在做好准备，我们将进入下一章，在那里我们将执行测试计划。