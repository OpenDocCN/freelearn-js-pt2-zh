# 从 JavaScript 的角度进行缩放

JavaScript 应用变得越来越大。 这是因为我们可以用语言做更多的事情——比大多数人认为可能的要多。 毕竟，JavaScript 被认为是一种激活静态网页的方法。 一种可以填补 HTML 空白的方法。 年复一年，越来越多的网站开始开发 JavaScript 代码来改善页面的功能。

尽管在某些语言特性上遇到了挫折，JavaScript 还是获得了极大的人气——今天它是 GitHub 上最受欢迎的编程语言([http://githut.info/](http://githut.info/))。 从那时起，网站开始变得更像用户安装在桌面上的应用。 库和框架开始从左到右，从中间出现。 为什么? 因为前端 JavaScript 应用庞大而复杂。

在当今的前端开发行业中，有很多工具可供我们使用。 JavaScript 语言已经发展成为一种可以独立使用的语言; 它越来越少地依赖库来执行最基本的编程任务。 ECMAScript 规范的下一个迭代尤其如此，在该规范中，困扰开发人员多年的问题至少部分地通过添加到语言中的结构得到了解决。 当然，这并不否定对应用框架的需求。 前端开发环境及其支持的 web 标准还远远不够完善，但它们正在改进。

很长一段时间以来，前端开发中一直缺少的是架构。 由于所实现的内容的复杂性，前端架构在最近几年变得非常流行。 先进的工具，允许前端开发人员设计一个架构，能够扩展我们试图解决的问题。 这就是本书的关键——可伸缩的 javascript 架构。 但规模到底有多大? 这不是传统计算中的伸缩性问题，在传统计算中，您需要在分布式服务器环境中处理更多负载。 前端的缩放呈现出其独特的挑战和限制。 本章将定义 JavaScript 架构所面临的一些可伸缩性问题。

# 扩大影响者

我们不会仅仅因为我们有能力就扩展我们的软件系统。 虽然吹捧可伸缩性是很常见的，但这些声明需要付诸实践。 为了做到这一点，必须有一个可扩展软件的理由。 如果不需要扩展，那么简单地构建一个不能扩展的系统就容易得多，更不用说成本效益了。 将一些用于处理各种扩展问题的内容放到一个不需要扩展的环境中，会让人觉得很笨拙。 尤其是对终端用户而言。

因此，我们，作为 JavaScript 开发人员和架构师，需要承认和理解可伸缩性所必需的影响。 虽然并非所有的 JavaScript 应用都需要扩展，但也并非总是如此。 例如，很难说我们知道这个系统不需要以任何有意义的方式进行扩展，所以让我们不要投入时间和精力使它具有可伸缩性。 除非我们开发的是一种一次性的系统，否则总是会有成长和成功的期望。

相反，JavaScript 应用并不是作为成熟的可伸缩系统诞生的。 他们在成长过程中积累了可扩展的资产。 对于我们这些从事 JavaScript 项目的人来说，缩放影响者是一个有效的工具。 我们不希望从一开始就过度设计一些东西，我们也不希望构建一些被早期决策束缚的东西，从而限制了它的扩展能力。

## 规模的需要

扩展软件是一个反应性事件。 考虑扩展影响者可以帮助我们提前准备这些扩展事件。 在其他系统中，比如 web 应用后端，这些伸缩事件可能是短暂的峰值，通常是自动处理的。 例如，由于更多用户发出更多请求，负载会增加。 负载均衡器启动并将负载均匀地分布到后端服务器。 在极端情况下，系统可能会在需要时自动提供新的后端资源，并在不再使用时销毁它们。

在前端缩放事件不是这样的。 相反，发生的伸缩事件通常发生在更长的时间内，也更复杂。 JavaScript 应用的独特之处在于，它们唯一可用的硬件资源是运行它们的浏览器可用的资源。 他们从后台获取数据，这可能会很好地扩展，但这不是我们所关心的。 随着软件的发展，成功的一个必然的副作用是，我们需要关注规模的影响因素。

![The need for scale](graphics/4369_01_01.jpg)

上图显示了一个自顶向下的影响者缩放流程图，从用户开始，他们需要我们的软件实现功能。 这取决于功能的不同方面，比如它们的大小以及它们与其他功能的关系，这将影响开发功能的开发团队。 当我们向下移动缩放影响者，这个增长。

## 不断增长的用户群

我们不是为一个用户开发应用。 如果我们是，就没有必要扩大我们的努力。 虽然我们构建的可能是基于一个用户代表的需求，但我们的软件服务于许多用户的需求。 随着应用的发展，我们需要预料到用户基础的增长。 虽然没有确切的目标用户数量，但根据我们的应用的性质，我们可以为活动用户的数量设定目标，可能是通过使用[http://www.alexa.com/](http://www.alexa.com/)之类的工具对类似的应用进行基准测试。 例如，如果我们的应用公开在公共互联网上，我们希望有大量注册用户。 另一方面，我们可能以私有安装为目标，在这种情况下，加入系统的用户数量会稍微慢一些。 但即使在后一种情况下，我们仍然希望部署的数量增加，增加使用我们软件的总人数。

与我们前端互动的用户数量是规模的最大影响因素。 随着每个用户的添加，以及不同的架构透视图，增长呈指数级增长。 如果你从自上而下的角度来看，，用户说了算。 最终，我们的应用将为它们提供服务。 我们能够更好地扩展我们的 JavaScript 代码，我们就会取悦更多的用户。

## 构建新功能

也许拥有强大用户基础的成功软件最明显的副作用是为了让这些用户满意而提供必要的功能。 特性集随着系统用户的增加而增长。 这常常被项目所忽略，尽管新特性很明显。 我们知道它们即将到来，但很少有人想到，源源不断的特性如何阻碍了我们扩大努力的能力。

当软件处于初期阶段时，这一点尤其棘手。 开发软件的组织将竭尽全力吸引新用户。 一开始这样做几乎没有什么后果，因为副作用是有限的。 它没有很多成熟的功能，也没有庞大的开发团队，而且也不太可能破坏现有用户所依赖的东西，从而惹恼他们。 当这些因素不存在时，我们更容易敏捷地创造出新功能，并吸引现有/潜在用户的注意。 但是我们如何强迫自己注意这些早期的设计决策呢? 在支持更多功能方面，我们如何确保我们不会不必要地限制我们扩展软件的能力?

正如我们在本书中所看到的，开发新特性以及增强现有特性是可伸缩 JavaScript 架构的一个持续问题。 我们需要关注的不仅仅是软件营销文献中列出的功能的数量。 还有给定功能的复杂性，我们的功能彼此之间有多相似，以及每个功能有多少运动部件。 如果从自顶向下的角度来看 JavaScript 架构，用户是第一个层次，那么每个特性就是下一个层次，从那里开始，它会扩展到巨大的复杂性。

并不是只有个别用户才会把一个特定的功能复杂化。 相反，它是一组用户，他们都需要相同的功能，以便有效地使用我们的软件。 从这里开始，我们必须开始考虑角色，或角色，以及哪个角色可以使用哪些功能。 这种类型的组织结构直到游戏后期才显现出来; 当我们做出决定，使得引入基于角色的特性交付变得困难之后。 根据我们的软件是如何部署的，我们可能必须支持各种独特的用例。 例如，如果我们有几个大型组织作为我们的客户，每个组织都有自己的部署，那么它们很可能对用户的结构有自己独特的约束。 这是一个挑战，如果我们要扩展，我们的架构需要支持许多组织的不同需求。

## 雇佣更多开发者

实现这些特性需要可靠的 JavaScript 开发人员，他们知道自己在做什么，如果幸运的话，我们还可以雇佣他们组成的团队。 团队合作不是自动发生的。 在团队成员开始积极地相互依赖以编写一些出色的代码之前，需要建立一定程度的信任和尊重。 一旦这种情况开始发生，我们就处于良好状态。 再次从自顶向下的角度来看，我们交付的特性可以直接影响我们团队的健康状况。 有一种平衡基本上是不可能维持的，但我们至少可以接近。 太多的特性和不够的开发人员会导致团队成员之间的一种永久的不满足感。 当没有机会实现预期的目标时，尝试也就没有多大意义了。 另一方面，如果你有太多的开发人员，并且由于有限的功能数量而产生了太多的沟通开销，那么就很难定义职责。 当没有对责任的共同理解时，事情就会开始崩溃。

比起拥有太多的开发人员，我们更容易处理缺少足够的开发人员来开发我们想要开发的功能。 当有很大的特性开发负担时，这是一个很好的机会来后退一步并思考——“如果我们有更多的开发人员，我们会有什么不同的做法?” 这个问题通常会被跳过。 我们雇佣更多开发者，当他们到来时，所有人都会惊讶地发现功能吞吐量并没有立即得到改善。 这就是为什么最好拥有一种开放的开发文化，在这种文化中没有愚蠢的问题，并定义职责。

没有一个正确的团队结构或开发方法。 开发团队需要将自己的精力投入到我们试图交付的软件所面临的问题上。 最大的障碍肯定是特性的数量、大小和复杂性。 这是我们在组建团队时需要考虑的问题，也是我们在发展团队时需要考虑的问题。 后一点尤其正确，因为我们在软件刚开发时使用的团队结构在功能扩展时并不适合我们所面对的情况。

# 建筑视角

前一节是影响 JavaScript 应用中规模的因素的一个示例。 从上面开始，每个影响者都会影响下面的影响者。 用户的数量和性质是最重要的影响因素，这直接影响到我们所开发功能的数量和性质。 此外，开发团队的规模和该团队的结构都受到这些特性的影响。 我们的工作是将这些影响规模的因素转化为从建筑角度考虑的因素:

![Architectural perspectives](graphics/4369_01_02.jpg)

伸缩性影响架构的透视图。 反过来，我们的架构决定了对规模影响者的响应。 这个过程是迭代的，并且在软件的整个生命周期中是永无止境的。

# 浏览器是一个独特的环境

传统意义上的扩展并不适用于浏览器环境。 当后端服务被需求淹没时，通常会“扔更多的硬件”来解决问题。 当然，说起来容易做起来难，但与 20 年前的相比，如今扩大我们的数据服务要容易得多。 今天的软件系统在设计时都考虑到了可伸缩性。 如果后端服务总是可用且总是响应，这对我们的前端应用是有帮助的，但这只是我们所面临的问题的一小部分。

我们不能在运行代码的浏览器上投入更多硬件; 考虑到; 我们的算法的时间和空间复杂性是重要的。 桌面应用通常有一组运行软件的系统要求，例如操作系统版本、最小内存、最小 CPU 等等。 如果我们要在我们的 JavaScript 应用中宣传这样的需求，我们的用户基础将急剧减少，并可能产生一些恶意邮件。

对基于浏览器的 web 应用精简和快速的期望是一个新兴的现象。 也许，这部分是由于我们面临的竞争。 市面上有很多臃肿的应用，无论它们是在浏览器中使用，还是在本地桌面中使用，用户都知道臃肿是什么感觉，通常会以另一种方式运行:

![The browser is a unique environment](graphics/4369_01_03.jpg)

JavaScript 应用需要许多不同类型的资源; 这些都是由浏览器代表应用获取的。

更麻烦的是，我们使用的平台被设计成一种下载和显示超文本、点击链接并重复的方式。 现在我们正在做同样的事情，除了在全尺寸的应用。 多页应用正逐渐被搁置一边，转而支持单页应用。 话虽如此，应用仍然被视为一个网页。 尽管如此，我们正处于巨大的变化之中。 浏览器是一个完全可行的网络平台，JavaScript 语言正在走向成熟，有许多 W3C 规范正在发展中; 它们有助于将 JavaScript 更像一个应用而不是文档。 看看下面的图表:

![The browser is a unique environment](graphics/4369_01_04.jpg)

在不断发展的网络平台中发现的技术样本

我们使用建筑视角来评估我们提出的任何建筑设计。 这是一个强大的技术，通过不同的镜头来检查我们的设计。 JavaScript 架构也不例外，特别是对于那些可伸缩的架构。 JavaScript 架构和其他环境架构的区别在于我们的架构有独特的视角。 浏览器环境要求我们以不同的方式思考如何设计、构建和部署应用。 在浏览器中运行的任何东西本质上都是短暂的，这改变了我们多年来习以为常的软件设计实践。 此外，我们花更多的时间编写架构代码，而不是绘制架构图。 当我们勾勒出任何东西的时候，它已经被另一个规范或另一个工具所取代。

## 元件设计

在架构层，组件是我们使用的主要构建块。 这些可能是具有多个抽象级别的非常高级的组件。 或者，它们可能是我们正在使用的框架暴露出来的东西，因为许多这些工具提供了它们自己的“组件”概念。 就我们在本书中的目的而言，组件位于中间——不太抽象，也不太特定于实现。 这个想法是，我们需要考虑我们的应用组合，而不是过多地担心细节。

当我们第一次着手构建 JavaScript 应用时，组件的组合就开始成形了。 我们的组件是如何组成的是我们如何扩展的一个巨大的限制因素，因为它们设定了标准。 组件实现模式是为了保持一致性，正确实现这些模式很重要:

![Component design](graphics/4369_01_05.jpg)

组件有一个内部结构。 此组合的复杂性取决于考虑的组件类型

正如我们将看到的，各种组件的设计与我们在其他透视图中所做的权衡密切相关。 这是一件好事，因为这意味着如果我们关注我们追求的可伸缩的质量，我们可以回头调整组件的设计，以满足这些质量。

## 组件通信

组件不会单独出现在浏览器中。 组件之间一直在进行通信。 我们这里有各种各样的沟通技巧可供使用。 组件通信可以像方法调用一样简单，也可以像异步发布-订阅事件系统一样复杂。 我们采用的架构方法取决于我们更具体的目标。 组件的挑战在于，在开始实现应用之前，我们通常不知道理想的通信机制是什么。 我们必须确保我们能够调整所选择的沟通路径:

![Component communication](graphics/4369_01_06.jpg)

组件通信机制将组件解耦，支持可伸缩的结构

我们很少为组件实现自己的通信机制。 在有这么多工具存在的情况下，至少为我们解决了部分问题。 最有可能的是，我们最终将使用现有的通信工具和我们自己的实现细节的组合。 重要的是，组件通信机制是它自己的透视图，可以独立于组件本身进行设计。

## 加载时间

JavaScript 应用总是在加载一些东西。 最大的挑战是应用本身，在允许用户做任何事情之前，加载它运行所需的所有静态资源。 然后是应用数据。 这需要在某个时间点加载，通常是按需加载，这对用户体验到的总体延迟有一定的影响。 加载时间是一个重要的视角，因为它极大地影响了我们对产品质量的整体认知。

![Load time](graphics/4369_01_07.jpg)

初始加载是用户的第一印象，这是大多数组件初始化的地方; 很难在不牺牲其他方面性能的情况下获得快速的初始负载

我们可以做很多事情来抵消等待加载的消极用户体验。 这包括使用 web 规范，允许我们将应用和它们使用的服务视为 web 浏览器平台上的可安装组件。 当然，这些都是初步的想法，但值得考虑，因为它们与我们的应用一起成熟。

## 响应性

我们体系结构的性能视图的第二部分与响应性有关。 也就是说，在加载完所有内容后，我们需要多长时间来响应用户输入? 尽管这是一个与从后端加载资源不同的问题，但它们仍然密切相关。 通常，用户操作会触发 API 请求，而我们用于处理这些工作流的技术会影响用户感知的响应能力。

![Responsiveness](graphics/4369_01_08.jpg)

组件响应 DOM 事件所花费的时间会影响用户感知的响应能力; 在初始 DOM 事件和最终通过更新 DOM 通知用户之间会发生很多事情。

由于这种必要的 API 交互，用户感知的响应非常重要。 虽然我们不能让 API 运行得更快，但我们可以采取措施，确保用户总是能从 UI 得到反馈，而且反馈是即时的。 然后，还有在 UI 中简单导航的响应性，使用已经加载的缓存数据，例如。 所有其他架构视角都与我们的 JavaScript 代码的性能密切相关，并最终与用户感知到的响应能力密切相关。 这个透视图是对我们的组件及其选择的通信路径的设计的一种微妙的检查。

## 可寻址性

仅仅因为我们正在构建一个单页面应用，并不意味着我们不再关心可寻址 uri。 这也许是网络最大的成就——指向我们想要的资源的唯一标识符。 我们将它们粘贴到浏览器地址栏，然后就可以看到奇迹发生了。 我们的应用肯定有可寻址的资源，我们只是以不同的方式指向它们。 而不是一个由后端 web 服务器解析的 URI，在那里页面被构造并发送回浏览器，而是我们的本地 JavaScript 代码理解 URI:

![Addressability](graphics/4369_01_09.jpg)

组件监听路由以获取路由事件并相应作出响应。 浏览器 URI 的变化会触发这些事件。

通常，这些 uri 将映射到一个 API 资源。 当用户在我们的应用中访问其中一个 URI 时，我们将把这个 URI 转换为另一个用于请求后端数据的 URI。 我们用来管理这些应用 uri 的组件叫做路由，有很多框架和库都有路由的基本实现。 我们可能会使用其中的一个。

可寻址性透视图在我们的体系结构中扮演着重要的角色，因为确保应用的各个方面都具有可寻址 URI 会使我们的设计变得复杂。 然而，如果我们聪明的话，它也可以让事情变得更简单。 我们可以让组件以与用户使用链接相同的方式使用 uri。

## 可配置性

软件很少能直接做你需要的事情。 高度可配置的软件系统被吹捧为好的软件系统。 前端的配置是一个挑战，因为配置有多个维度，更不用说在哪里存储这些配置选项的问题了。 可配置组件的默认值也有问题，它们从何而来? 例如，是否有一个默认的语言设置，在用户更改之前一直设置? 通常情况下，前端的不同部署需要不同的默认值:

![Configurability](graphics/4369_01_10.jpg)

组件配置值可以来自后端服务器，也可以来自 web 浏览器。 默认值必须存在于某处

我们软件的每一个可配置方面都使它的设计复杂化。 更不用说性能开销和潜在的 bug 了。 因此，可配置性是一个大问题，值得花时间预先与各种涉众讨论他们在可配置性方面的价值。 根据我们部署的性质，用户可能会通过配置来评估可移植性。 这意味着它们的值需要存储在后端，在它们的帐户设置下。 显然，像这样的决策涉及后端设计，有时最好采用不需要修改后端服务的方法。

# 做出架构上的权衡

如果我们要建造可伸缩的东西，我们需要从架构的各个角度考虑很多问题。 我们不可能同时从每个角度得到我们需要的所有东西。 这就是为什么我们要在架构上进行权衡——我们用设计的一个方面来换取另一个更可取的方面。

## 定义常量

在我们开始权衡之前，重要的是明确说明什么是不能交易的。 我们设计的哪些方面对实现规模至关重要，必须保持不变? 例如，常量可以是给定页面上呈现的实体数量，或者是函数调用**间接**的最大级别。 这些建筑常量不应该有很多，但它们确实存在。 我们最好把它们的范围限制在有限的数量上。 如果我们有太多的严格的设计原则，不能违背或改变，以适应我们的需求，我们将无法轻松地适应规模的变化。

考虑到影响者的不可预测性，保持不变的设计原则是否有意义? 确实如此，但只有在它们出现并显而易见的时候。 所以这可能不是一个预先的原则，尽管我们通常至少有一个或两个预先的原则要遵循。 这些原则的发现可能来自于早期的代码重构或软件的后期成功。 无论如何，我们今后使用的常数必须明确，并得到所有有关各方的同意。

## 易于开发的性能

在可能的情况下，首先需要修复或避免性能瓶颈。 一些性能瓶颈是明显的，对用户体验有明显的影响。 这些问题需要立即修复，因为这意味着我们的代码由于某些原因无法伸缩，甚至可能指向更大的设计问题。

其他性能问题相对较小。 开发人员通常会注意到这些问题，他们会对代码进行基准测试，尽一切可能提高性能。 这并不能很好地扩展，因为这些较小的性能瓶颈无法被最终用户观察到，修复它们是非常耗时的。 如果我们的应用是一个合理的大小，并且有很多开发人员在做它，如果每个人都在修复一些小的性能问题，我们将无法跟上特性开发的步伐。

这些微优化将专门的解决方案引入到我们的代码中，对于其他开发人员来说，它们并不容易阅读。 另一方面，如果我们让这些小的低效消失，我们将设法保持我们的代码更干净，从而更容易使用。 在可能的情况下，用优化的性能换取更好的代码质量。 这提高了我们从多个角度进行扩展的能力。

## 可配置性能

拥有几乎所有方面都可配置的通用组件是件好事。 然而，这种组件设计方法是以性能为代价的。 一开始，当有很少的组件时，这并不是显而易见的，但是随着我们的软件在特性数量上的扩展，组件的数量也在增长，配置选项的数量也在增长。 根据每个组件的大小(其复杂性、配置选项的数量等等)，性能下降的可能性呈指数级增加。 看看下面的图表:

![Configurability for performance](graphics/4369_01_11.jpg)

左边组件的配置选项是右边组件的两倍。 它的使用和维护难度也增加了一倍。

只要没有影响用户的性能问题，我们就可以保留配置选项。 请记住，为了消除性能瓶颈，我们可能不得不删除某些选项。 可配置性不太可能成为性能问题的主要来源。 当我们扩展和添加功能时，也很容易忘乎所以。 回顾一下，我们会发现，我们在设计时创建了我们认为会有帮助的配置选项，但结果只是开销而已。 当配置选项没有明显的好处时，要权衡可配置性对性能的影响。

## 可替代性性能

与可配置性相关的一个问题是可替换性。 我们的用户界面性能很好，但随着用户群的增长和功能的增加，我们发现某些组件无法轻易地用其他组件替代。 这可能是一个开发问题，我们想要设计一个新的组件来取代现有的组件。 或者我们可能需要在运行时替换组件。

我们替换组件的能力主要取决于组件通信模型。 如果新组件能够像现有组件一样发送/接收消息/事件，那么它就是一个相当简单的替换。 然而，并不是我们的软件的所有方面都是可替代的。 为了提高性能，甚至可能没有组件可以替换。

随着规模的扩大，我们可能需要将更大的组件重构为可替换的更小的组件。 通过这样做，我们引入了一个新的间接级别，并对性能造成了影响。 权衡较小的性能损失，以获得可替换性，这有助于扩展架构的其他方面。

## 易于开发，可寻址

在我们的应用中为资源分配可寻址 uri 无疑会使特性的实现更加困难。 对于应用公开的每个资源，我们真的需要 uri 吗? 可能不会。 但是，为了一致性起见，为几乎所有资源使用 uri 是有意义的。 如果我们没有一个一致且易于遵循的路由和 URI 生成方案，我们很可能会跳过为某些资源实现 URI。

将 uri 分配给应用中的每个资源几乎总是比忽略 uri 更好。 或者更糟的是，根本不支持可寻址资源。 uri 使我们的应用的行为像 Web 的其他部分一样; 我们所有用户的训练场。 例如，也许 URI 生成和路由对于我们的应用中的任何东西都是一个常量——这种权衡是不可能发生的。 在几乎所有情况下，都要在易于开发和可寻址性之间做出权衡。 随着软件的成熟，可以更深入地解决与 uri 有关的易于开发问题。

## 可维护性性能

在我们的软件中开发的功能的简单归结于开发团队和它的影响力。 例如，我们可能会因为预算原因而面临招聘初级开发人员的压力。 这种方法的伸缩性取决于我们的代码。 当我们关注性能时，我们可能会引入各种令人生畏的代码，相对缺乏经验的开发人员将难以接受这些代码。 显然，这阻碍了开发新特性的便利性，如果开发困难，则需要更长的时间。 这显然不符合客户的需求。

开发人员不必总是纠结于理解我们在代码的特定区域所采用的非正统的方法来解决性能瓶颈。 我们当然可以通过编写可理解的高质量代码来帮助解决这个问题。 甚至文档。 但我们不会免费得到所有这些; 如果我们要支持整个团队，我们需要在短期内付出生产力的代价，因为必须进行指导和指导。

在大量使用且不经常修改的关键代码路径中，要权衡开发的易用性和性能。 我们不能总是避免性能要求的丑陋，但如果它被很好地隐藏，我们将获得更常见的代码易于理解和自解释的好处。 例如，低级 JavaScript 库的性能很好，并且具有易于使用的内聚 API。 但是如果你看看一些底层的代码，它并不漂亮。 这就是我们的收获——让其他人维护那些出于性能原因而难看的代码。

![Maintainability for performance](graphics/4369_01_12.jpg)

左边的组件遵循一致且易于阅读的编码风格; 它们都利用了右边的高性能库，在隔离难以阅读和理解的优化代码的同时提高了应用的性能。

## 较少的可维护性特性

当所有其他方法都失败时，我们需要后退一步，全面地查看应用的特性集。 我们的架构能支持所有这些吗? 还有更好的选择吗? 放弃一个我们花了很多时间研究的架构几乎是没有意义的，但它确实发生了。 然而，大多数时候，我们会被要求引入一组具有挑战性的特性，这些特性会违反我们的一个或多个架构常量。

当这种情况发生时，我们正在破坏已经存在的稳定特性，或者我们正在向应用中引入一些质量很差的东西。 这两种情况都不好，值得花时间、让人头疼、让人咒骂的时间与涉众一起工作，找出必须要做的事情。

如果我们已经花时间通过权衡来确定我们的架构，我们应该有一个合理的理由来说明为什么我们的软件不能支持数百个特性。

![Less features for maintainability](graphics/4369_01_13.jpg)

当一个建筑已经满了，我们就不能继续扩展了。 关键是理解突破的门槛在哪里，这样我们就能更好地理解并与涉众沟通。

## 利用框架

框架的存在是为了帮助我们使用一组内聚的模式来实现架构。 有很多种类，选择哪种框架是个人品味的结合，并根据我们的设计适合。 例如，一个 JavaScript 应用框架可以为我们提供很多开箱即用的功能，而另一个框架有更多的功能，但其中很多功能我们并不需要。

JavaScript 应用框架的大小和复杂性各不相同。 有些产品包括电池，有些倾向于机制而不是政策。 这些框架都不是专门为我们的应用设计的。 对于框架的任何声称的功能都需要持保留态度。 框架宣传的特性适用于一般情况，而且是简单的情况。 在我们的架构环境中应用的是完全不同的东西。

也就是说，我们当然可以使用自己喜欢的给定框架作为设计过程的输入。 如果我们真的喜欢这个工具，并且我们的团队有使用它的经验，我们可以让它影响我们的设计决策。 只要我们明白这个框架不会自动对影响者做出反应——那部分取决于我们。

### 提示

值得花时间研究我们的项目要使用的框架，因为选择错误的框架是一个代价高昂的错误。 通常在我们实现了很多功能之后，才会意识到我们应该使用其他东西。 最终的结果是大量的重写、重新规划、重新培训和重新记录。 更不用提第一次实现所浪费的时间了。 明智地选择框架，并谨慎使用框架耦合。

# 框架与库

当我们有一个完整的框架，里面有我们需要的所有东西时，为什么要使用一个小型库的混搭呢? 库是我们的工具，如果它们满足了我们架构中的需求，那就一定要使用它们。 一些开发人员回避低级工具，因为随之而来的依赖关系混乱。 在实践中，这种情况无论如何都会发生，即使我们正在利用一个全面的框架。

最终，框架和库之间的区别对我们来说并不重要。 创建第三方依赖噩梦并不能很好地扩展。 只使用一种工具而自己维护大量代码也不可能。 这是关于在严重依赖其他项目和自己重新创造轮子之间找到正确的匹配。

## 一致地实现模式

我们用来帮助实现体系结构的工具是通过公开 JavaScript 应用中常见的模式来实现的。 而且他们一贯如此。 由于我们的应用的规模因不断增长的特性集而扩大，我们可以反复应用相同的框架组件。 框架还促进了我们自己实现的模式的一致性。 如果我们看看任何框架的内部，我们会看到它有自己的通用组件; 这些扩展为我们提供了可用的组件。

## 内置性能

开源框架让大多数开发人员查看代码，并让大多数项目在生产中使用框架。 他们从用户社区得到了很多反馈，其中包括性能增强。 第三方工具是关注性能的合适场所，因为它们可能是给定应用中使用最多的代码。 把所有性能结果都留给浏览器供应商和 JavaScript 库是不明智的。 利用我们一直使用的组件背后的性能是明智的。

## 利用社区智慧

成功的 JavaScript 框架周围都有强大的社区。 这比拥有健壮的文档更强大，因为我们可以在出现问题时提出问题。 很有可能，其他人正试图在他们的项目中做一些类似的事情，使用与我们相同的框架。 开源项目就像一个知识引擎; 即使我们需要的确切答案并不存在，我们也可以通过社区的智慧找到足够的答案来自己找出答案。

## 框架不能进行开箱即用的扩展

说一个框架的伸缩性比另一个好是不合理的。 编写一个**TODO**应用作为框架伸缩性的基准是没有什么用处的。 我们编写 TODO 应用来了解这个框架，以及它与其他框架的比较。 如果我们不确定哪个框架适合我们的风格，那么 TODO 应用是一个很好的开始。

我们的目标是针对有影响力的人实施一些有效的措施。 这些都是独特且未知的。 我们能做的最好的事情就是预测未来我们可能会遇到什么样的影响因素。 基于这些可能的影响因素，以及我们正在构建的应用的性质，有些框架比其他框架更好。 框架帮助我们扩展，但它们并不适合我们。

# 小结

扩展 JavaScript 应用与扩展其他类型的应用是不同的。 尽管我们可以使用 JavaScript 创建大规模的后端服务，但我们关注的是用户在浏览器中交互的应用的伸缩性。 有许多有影响力的因素指导我们的决策过程，以产生一个可伸缩的架构。

我们回顾了其中的一些影响因素，以及它们是如何以自上而下的方式流动的，这给前端 JavaScript 开发带来了独特的挑战。 我们研究了更多用户、更多功能和更多开发者的影响; 我们可以看到有很多东西需要思考。 虽然浏览器正在成为一个强大的平台，我们在其上交付应用，但它仍然有其他平台没有的限制。

设计和实现可伸缩的 JavaScript 应用需要有一个体系结构。 软件最终必须做的只是对设计的一个输入。 规模影响因素也是关键。 从那里，我们处理考虑中的体系结构的不同角度。 当我们谈论规模时，像组件组成和响应性这样的东西就会出现。 这些是我们的建筑的可观察的方面，受到规模的影响。

随着这些缩放因素随着时间的推移而变化，我们使用架构视角作为工具来修改我们的设计，或者将产品与缩放挑战保持一致。 下一章的重点将是更详细地研究这些规模影响者。 理解它们并将它们组合在一起将使我们能够实现响应这些事件的可伸缩 JavaScript。