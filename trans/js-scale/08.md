# 可移植性和测试

从几年前开始，Web 应用程序已经有了很大的发展。 在网页中嵌入 JavaScript 代码的时代已经一去不复返了。 在今天的网络中，我们构建 JavaScript 应用程序，如果你正在阅读这本书，应用程序的规模。 这意味着我们的架构在设计时需要考虑到可移植性; 为应用服务并为其提供数据的后端是可替代的。

伴随着可移植性而来的是可测试性的概念。 当我们在开发大规模的 JavaScript 代码时，我们不能对后端进行假设，这意味着我们能够在没有后端的情况下运行。 本章着眼于这两个密切相关的主题，以及它们对我们在不断变化的缩放影响面前的意义。

# 解耦后端

如果我们需要更多的动机来证明 JavaScript 不再只是用于可脚本化的网页，看看 NodeJS 吧。 它不需要完整的浏览器环境，只需要 V8 JavaScript 引擎。 Node 主要是作为后端服务器环境创建的，但它仍然是 JavaScript 作为一门语言发展到何种程度的一个很好的展示。 同样，我们希望我们的代码是可移植的，能够在任何后端基础设施上运行。

在这一节中，我们将讨论为什么我们要放松前端 JavaScript 代码与后端与之对话的 api 之间的耦合。 然后我们将介绍模拟 api 的第一步，完全不需要后端。

## 模拟后端 API

如果我们正在开发一个大规模的 JavaScript 应用程序，我们将有一个后端基础设施的开端。 那么，为什么我们要考虑将我们的代码从后端分离出来，这样它就不再依赖它了呢? 在努力实现可伸缩性时，支持松散耦合组件总是一个好主意，web 应用程序的前端和后端环境之间的耦合也是如此。 即使后端 API 永远不会改变，我们也不能假设用于构建 API 的技术和框架永远不会改变。 放松这种依赖性还有其他好处，比如能够独立于系统的其他部分更新 UI。 但是模仿后端 api 的主要好处来自于开发和测试的角度。 没有什么能替代将新的 API 端点组合在一起并使用请求敲打它们。 模拟 api 是我们的 JavaScript 代码的崩溃测试模型。

不管你喜不喜欢，有时候感觉就像我们在制作演示软件——在开发的过程中，我们必须向感兴趣的利益相关者炫耀我们所拥有的东西。 而不是让这导致绝望，我们将从我们的模拟数据中获得信心。 演示不再是一个大问题，有了我们对模拟数据的信心，我们将开始把这些事件视为对我们自己的小挑战。 当然，为了管理的缘故，我们总是必须保持英雄程序员的外表!

考虑到模拟数据有多棒，它的缺点是什么? 就像我们产品中的其他东西一样，这是一个需要维护的软件——而且总是带有风险。 例如，如果模拟 API 与实际 API 不同步，或者如果它混淆了 UI 中的功能和模拟的内容，那么模拟 API 就会失去一些价值。 为了应对这些风险，我们必须围绕如何设计和实现功能设置相应的流程，稍后我们将在这里详细介绍。

![Mocking the backend API](graphics/4639_08_01.jpg)

模拟 API 位于与实际 API 通信的任何组件之外; 当 mock 被删除时，组件并不知道什么更好

## 前端入口点

我们的前端与后端的接缝在哪里? 这就是我们想要在 mock数据和 API 正常返回的数据之间进行切换的地方。 seam 实际上可能位于 web 服务器的后面——在这种情况下，我们仍然在发出真正的 HTTP 请求，而不是与真正的应用程序交互。 在另一种情况下，我们完全在 web 浏览器内进行模拟，在 HTTP 请求离开浏览器之前，模拟库处理程序就会拦截它们。

在这两种嘲讽中，我们的前端应用程序之间都有一个概念性的接缝，这也是我们想要建立的。 这是关键，一旦我们找到它，因为它代表我们独立于后端。 这并不是说在生产中与后端紧密耦合有什么问题——这就是它存在的目的。 在其他情况下，例如在开发期间，能够协调组件发送 API 请求时发生的事情是一个关键的伸缩策略。

有可能直接使用模型和集合创建模拟数据模块。 例如，如果我们在模拟模式下运行，我们将导入这个模块，并使用模拟数据。 这种方法的问题是，我们的应用程序知道它并不真正与后端一起工作。 我们不希望那样。 因为我们希望代码像在生产环境中运行一样运行。 否则，我们将会遇到手动实例化模拟的一些副作用—它需要尽可能远离我们的实际代码。

无论我们决定采用哪种模拟机制，它都需要是模块化的。 换句话说，我们需要能够关闭它并将其完全从构建中移除。 在生产环境中，不应该有模拟。 事实上，我们的模拟代码甚至不应该出现在生产构建中。 如果我们的模拟是由 web 服务器提供的，那么这一点会更容易实现。 如果模拟处理程序驻留在浏览器中，我们需要以某种方式取出它们，这需要某种构建选项。 在本章的后面还会有更多关于构建工具的内容。

![Frontend entry points](graphics/4639_08_02.jpg)

在浏览器中模拟 API 请求，在 XHR 级别拦截调用。 如果那里有模拟代码，它将寻找模拟 api。 当取出 mock 时，本机 HTTP 请求照常运行。

## 模仿工具

如前一节所述，有两种主要的方法来模拟后端 API。 第一种方法是在应用程序中引入一个诸如 Mockjax 的库来拦截 XHR 请求。 第二种方法是有一个真正的 HTTP 服务器，但是并没有真正接触到真正的应用程序——它以与 Mockjax 方法相同的方式提供模拟数据。

Mockjax 的工作方式简单而巧妙。 它是在假设应用程序使用 jQuery`ajax()`调用来发出 HTTP 请求的情况下工作的，这是一个相当安全的假设，因为大多数框架都在底层使用这个。 当调用 Mockjax 时，它会用自己的功能覆盖一些核心的 jQuery XHR 功能。 每当发出 XHR 请求时，都会运行此命令。 它检查是否有与请求的 URI 匹配的路由规范，如果找到了，它将运行处理程序。 否则，它只会通过并尝试向后端发出请求——如果我们想将真实的 API 请求与模拟请求结合起来，这是很有用的。 我们稍后将深入研究这种组合。

任何给定的处理程序都可以返回 JSON 数据，或者任何其他格式的数据，就像我们真正的 API 一样。 关键是我们的核心代码——发起请求的模型和集合——对 Mockjax 一无所知，因为它都发生在较低的层次。 相同的模型和集合代码在生产后端未修改地运行。 我们所要做的就是*拔下*模块，在使用真正的 API 部署时调用 Mockjax。

我们也可以使用模拟 web 服务器技术来实现相同的属性——运行未修改的代码。 它实际上与劫持 XHR 请求的想法完全相同，只是在另一个级别上完成。 主要的好处是我们在部署期间没有任何特别的步骤。 它要么是模拟服务器，要么是真实服务器，而且在生产环境中，不太可能有模拟服务器在运行。 缺点是我们确实需要一个运行的服务器，这并不是什么大问题——不过这是一个额外的步骤。 我们确实失去了一点便携性。 例如，我们可以打包一个模拟构建并将其发送给某人。 如果它不需要 web 服务器，整个应用程序可以在浏览器中演示。

![Mocking tools](graphics/4639_08_03.jpg)

从浏览器或 web 服务器背后模仿 api; 这两种方法都实现了相同的结果——我们的代码并不知道它正在与一个 mock 对象对话。

## 生成模拟数据集

现在我们知道了声明模拟 API 端点的选项，我们需要数据。 假设 API 返回 JSON 数据，我们可以将模拟数据存储在 JSON 文件中。 例如，模拟模块可以将这些 JSON 模块作为依赖项引入，而模拟处理程序可以将它们用作数据源。 但是这些数据从何而来呢?

当我们开始构建模拟时，很可能已经有一个 API 在某处运行。 使用我们的浏览器，我们可以查看各种 API 端点返回的数据，并手动管理模拟数据。 如果 API 有文档记录，这个过程会简单得多，因为这样我们就可以了解任何给定实体中任何给定字段的允许值。 有时候我们并没有创建模拟数据的起始点——我们将在功能设计过程部分详细介绍。

像这样手工创建模拟数据集的好处是，我们可以确保它是准确的。 也就是说，我们不想创建一些不能反映我们所嘲笑的数据的东西，因为那样会破坏整个目的。 更不用提跟上 API 变化的伸缩瓶颈了。 最好是使用工具自动生成模拟数据集。 它只需要知道给定实体的模式，然后就可以处理剩下的事情，接受一些参数并抛出一些随机性。

另一个有用的模拟数据生成工具是从给定的部署中提取真实的 API 数据，并将它们存储为 JSON 文件。 例如，假设在一个登台环境中，我们的代码显示出了问题的迹象。 我们可以对该环境运行数据提取工具，以获得所需的模拟数据。 由于我们希望保持登台环境的完整性，因此这种方法是安全的，因为在诊断时对模拟数据造成的任何损害都在内存中，很容易清除。

## 执行动作

实现模拟 api 的一个具有挑战性的方面是执行操作。 这些请求不是 GET 请求，通常需要更改某些资源的状态。 例如，更改资源属性的值，或者完全删除资源。 我们需要一些处理程序可以利用的通用代码来执行这些操作，因为当涉及到对 API 端点执行操作时，它们应该遵循相同的模式。

实际实现的可管理性取决于 API 操作工作流的复杂性。 一个容易实现的操作是修改资源的属性值，然后返回`200`successful。 然而，我们的应用程序很可能有更复杂的工作流，比如长时间运行的操作。 例如，这些类型的操作可能返回新创建的*操作*资源的 ID，从那里，我们需要监控该操作的状态。 我们的前端代码已经做到了这一点，因为这正是使用真正的 api 所需要做的——我们需要在 mock 中实现应用程序的这些微妙之处。

行动很快就会变得很混乱。 特别是当应用程序是一个大型的，有许多实体类型和许多操作的应用程序时。 这个想法是为嘲笑这些行为而努力寻找最小可行的成功路径。 不要详细地尝试模拟应用程序所做的每一件事——它不能伸缩。

# 功能设计流程

我们创建 mockapi 不是为了好玩，而是为了帮助特性的开发。 考虑到我们可能有一个相当大的 API，因此有很多要 mock 的，我们需要一个适当的进程来控制我们做事情的顺序。 例如，我们是否需要等待 API 就绪后才开始实现某个特性? 如果我们可以模拟 API，那么我们就不必这样做，但是 API 本身仍然需要设计，而且有很多 API 涉众。

在这一节中，我们将回顾一些必要的步骤，以确保我们正确地使用模拟，并且以一种与我们的特性开发并行的方式。

## API 设计

有些 API 端点是通用的，可以支持多个特性。 这些是我们应用程序的核心实体。 通常情况下，有几个实体扮演着至关重要的角色，大多数功能都使用它们。 另一方面，我们开发的大多数新特性都需要扩展 API。 这可能意味着一个或多个新的 API 端点。 这是我们的后端资源如何组成的问题，这涉及到一定程度的设计工作。

尝试扩展我们的特性开发的问题是，实现一个新的 API 可能需要很长时间。 因此，如果我们在开始开发前端特性之前需要 API，我们最终会推迟特性的开发，这并不理想。 我们想在新鲜的时候开始工作。 如果某件事作为待办事项被列在待办事项列表中，它通常会永远留在那里。 为所提议的特性准备一个模拟 API 可以让我们毫不拖延地开始工作，这对扩展开发至关重要。

当我们实现一个新的 API 端点的模拟时，我们就进入了新设计领域。 这意味着我们必须考虑那些不一定是前端开发的人的考虑。 我们可能会也可能不会触及真正的 api 的实际实现——这完全取决于我们的团队结构。 也就是说，无论主题专家是谁，他们都需要透明地访问我们提议的 API 的设计。 他们可以提供建议、更改等等。 在不可能的道路上继续走下去是没有意义的。 另一种方法可能是让后端程序员勾勒出可能的 API 规范。 只有具有最小属性和操作的基本端点。 其余的细节可以很容易地在模拟和实际代码中更改。

在接触后端代码之前使用模拟 api 实现特性，可以帮助防止代价高昂的错误。 例如，假设我们使用模拟 api 在前端实现了一些特性，达到了可以演示的程度。 这为其他具有特定后端领域知识的工程师提供了一个机会，可以指出该特性的不可行性，我们也可以避免在未来犯下代价高昂的错误。

![Designing the API](graphics/4639_08_04.jpg)

设计模拟 API 并针对其实现特性的周期

## 实现模拟

现在我们已经完成了实现一个特性的任务，第一步是实现一个模拟 API 来支持前端代码的开发。 正如我们在前一节中看到的，我们应该与最终实现真正 API 的人密切交互。 第一步是弄清楚 API 在高层次上会是什么样子。 剩下的部分我们可以在实现真正的 API 的过程中进行微调。

然而，在模拟的开发过程中，我们并不总是需要依赖 API 团队成员的帮助。 我们可能有一些 API 端点，它们可能已经被我们的一些前端组件使用了。 也就是说，可能有一个可识别的模式，我们可以遵循，特别是如果模拟只是另一个平凡的实体类型，我们刚好错过了。 如果我们遵循一个好的模式，那就是一个好的起点，因为以后发生根本变化的机会更小。

当我们知道我们的模拟 API 是什么样子，以及我们可以用它做什么时，我们需要用模拟数据填充它。 如果我们有为其他模拟生成数据的工具，我们需要弄清楚如何扩展它。 或者，我们需要手动创建一些测试实体来开始。 我们不想花费大量时间预先输入数据。 我们只需要最小可行实体数来证明我们的方法是可行的。

### 提示

在创建数据之前，我们可能并不总是希望从实际的模拟端点开始。 相反，我们可能希望从数据向上设计正确的实体，而不是担心 API 本身的机制。 这是因为，数据最终需要存储在某个地方，这是一个重要的活动。 处理数据让我们以一种不同的心态工作。 选择最适合手头任务的方法。

我们创造的模拟并不总是创造全新的东西。 也就是说，我们正在模拟的 API 可能已经存在，或者正在进行实现。 这实际上使模拟更容易实现，因为为了构建模拟，我们可以要求 API 作者提供样例数据，或者提供一般的帮助。 记住，如果我们想要可移植，我们必须能够从后端移除前端，这意味着我们需要完全模拟 API。

## 实现功能

现在我们已经有了模拟 API，是时候盈利了。 这并不是说的和做的——模拟 api 一直在调整。 但这足以让我们使用真正的前端代码。 我们马上就会发现问题。 这些问题可能是建议的 API 的问题，也可能是与 API 通信的组件的问题。 我们不能让这些阻碍我们，因为这正是我们寻找的早期问题检测。 如果没有模拟 api，就无法实现这一点。

如果 API 被普遍接受，并且我们的组件代码正常工作，我们就可以在设计中发现性能瓶颈。 如果我们拥有能够生成模拟数据的工具，这一点就非常容易找到，因为生成 10 万个实体并查看前端代码会发生什么并不重要。 有时这是一个快速的重构，有时这是一个完全的方法上的改变。 关键是我们需要尽早发现这些问题。

我们还可以用 mock 做一些其他困难的事情，那就是经常演示。 当我们严重依赖有大量开销的大型后端环境时，做到这一点并不容易。 如果能够在几分钟内完成一个功能并进行演示，那么我们就可以自信地展示我们正在做的事情。 也许这是错误的，也许利益相关者在看到他们的想法变成现实后，想到了他们错过的东西。 这就是模拟如何通过早期和持续的反馈帮助我们扩展特性开发生命周期。

![Implementing the feature](graphics/4639_08_05.jpg)

正在开发的组件的内部，与模拟 API 端点通信

## 协调模拟数据与 API 数据

现在，该特性已经实现了，我们如何协调为该特性创建的模拟取决于实际 API 的状态。 例如，如果我们只是在 API 中模仿一些已经存在一段时间的东西，那么只要在我们的模仿和真实的东西之间有高保真度，就可以安全地假设什么都不需要发生。 然而，如果我们正在模拟一个新开发的 API，很有可能会发生一些变化，甚至是微妙的变化。 捕获这些更改非常重要，以确保我们现有的模拟在后续版本中保持相关性。

这是嘲笑过程中难以衡量的一部分，而且通常令人不快。 有很多不同的方法可以使我们的模拟与真正的 API 不同步，即使是尝试保持同步都是令人生畏的。 如果我们有生成模拟的工具，那就容易多了。 我们甚至可以基于 API 团队创建的规范生成整个 API。 但这也有问题，因为虽然模拟生成可以自动化，但规范本身需要在某个地方以某种方式创建。 因此，最好实现一个可以生成模拟数据的工具，但有我们自己的代码处理请求。 只要我们不重复太多，并且 API 有一个合适的模式，我们应该能够跟上模拟的速度。

另一种可能是关闭某些模拟 API 端点，而保留其他端点。 可以将它看作是一种传递—可以指定模拟端点的粒度，而不是只能切换整个模拟 API。 例如，如果我们试图对应用程序中的特定问题进行故障排除，并且为了复制问题，我们需要引导某些 API 端点返回特定的响应，那么这个功能就很有用。 我们可以在 Mockjax 等库中这样做，因为不符合请求路径规范的请求会被转发到本机 XHR 机制。

![Reconciling mock data with API data](graphics/4639_08_06.jpg)

一个组件使用模拟 API，而另一个组件使用实际 API

# 单元测试工具

现在是将我们的注意力转向测试的时候了，我们已经介绍了大规模模拟 API 端点的基础知识。 我们模拟 api 的能力与测试代码高度相关，因为我们可以针对相同的模拟进行测试，或者至少是相同的数据。 这意味着，如果我们的测试失败，我们可以开始与 UI 交互，如果我们需要，使用同样的数据，失败的测试，尝试来弄清楚发生了什么。

我们将研究使用 JavaScript 框架附带的单元测试工具，并找出它们的价值所在。 我们还将讨论如何使用更通用的独立测试框架来运行任何代码。 我们将以查看如何实现测试自动化，以及这种自动化如何适合于我们的开发工作流来结束本节。

## 工具内置在框架中

如果我们正在使用一个更大的、全面的 JavaScript 应用程序框架，那么它很有可能会附带一些单元测试工具。 这些并不意味着要取代现有的与框架无关的单元测试工具。 相反，它们是为了增强它们——为编写框架风格的测试提供特定的支持。

这对我们来说最终意味着编写更少的单元测试代码。 如果我们遵循框架的模式，那么有许多单元测试工具已经知道我们的代码。 例如，如果它已经知道我们将使用哪些类型的组件来实现我们的特性，那么它就可以为我们排除测试。 这是一个巨大的帮助，不需要重复我们自己，并且它最终导致我们在代码上获得更多的测试覆盖率。

除了为我们生成测试框架之外，框架测试工具还可以为我们提供在测试中使用的实用功能。 这意味着我们需要维护的单元测试代码更少，这是唯一可能的，因为框架知道我们想在测试中做什么，并可以以实用函数的形式为我们抽象它们。

依赖特定于框架的测试工具的挑战是，我们将把我们的产品与特定的框架耦合起来。 这对我们来说不太可能是一个问题，因为一旦选择了一个框架，我们就会坚持使用它，对吧? 好吧,不一定。 但在今天混乱的 JavaScript 生态系统中却并非如此。 可移植性的一部分要求我们的架构具有一定程度的敏捷性，这意味着我们必须能够适应变化。 这也许就是为什么现在的项目更少地依赖大型框架，而更多地依赖于库的组合。

![Tools built into frameworks](graphics/4639_08_07.jpg)

单元测试与框架中的组件和单元测试工具紧密耦合

### 注释

在大型 JavaScript 应用程序中有很多异步代码，我们的单元测试不应该忽略这些异步代码。 例如，我们需要确保我们的模型单元能够获取数据并执行操作。 这些类型的函数返回承诺，我们希望确保它们按照预期解决或失败。

如果有一个模拟 API，就更容易实现这一点。 使用浏览器内方法或 web 服务器方法都可以，因为我们的代码仍然将它们视为真正的异步操作。 我们还可以考虑模仿网络套接字连接。 这在浏览器中有点棘手，因为我们必须重写内置的 web 套接字类。 我们可以使用一个真实的 web 套接字连接来测试我们的 mock 是否位于 web 服务器后面。

不管怎样，模仿 web 套接字都是困难的，因为我们必须模仿触发 web 套接字消息以响应其他事情(比如一个 API 动作)的逻辑。 然而，在我们有了更基本的测试覆盖率之后，我们可能仍然想要考虑模拟 web 套接字，因为如果我们的应用程序依赖于它们，为它们自动化测试是很重要的。

## 独立单元测试工具

单元测试工具的另一种方法是使用独立框架。 也就是说，一个不关心我们使用的 JavaScript 应用框架或库的单元测试工具。 Jasmine 是用于这一目的的标准，因为它为我们提供了一种干净简洁的方式来声明测试规范。 它有一个可以在浏览器中工作的测试运行器，可以为通过的测试和失败的测试提供格式化良好的输出。

大多数其他独立单元测试工具使用 Jasmine 作为基础，并对其进行扩展以提供额外的功能。 例如，有一个 Jest 项目，它本质上是具有额外功能的 Jasmine，比如内置的模块加载和模拟。 同样，类似这样的东西是框架不可知论者; 它只专注于测试。 使用这些类型的独立工具进行单元测试是一种很好的可移植性策略，因为这意味着如果我们决定在代码中使用不同的技术，我们的测试仍然是有效的，并且可以帮助平稳地运行转换。

《Jasmine》并不是唯一的游戏，它只是最普通的游戏，并让我们能够自由地构建测试结构。 例如，Qunit 已经存在很长时间了。 它适用于任何框架，但最初的设想是作为 jQuery 项目的测试工具。 我们甚至可能想使用我们自己的测试工具，如果我们觉得可用的测试工具太笨重，并且没有给我们提供项目需要的灵活性或输出。 我们可能不想自己编写测试运行器。 我们的单元测试并不是随心所欲地运行。 它们通常是我们想要自动化的大型任务链的一部分。

### 注释

有些代码比其他代码更易于测试。 这仅仅意味着根据组件的结构，将它们分解成可测试单元可能很容易，也可能很困难。 例如，带有许多移动部件和许多副作用的代码意味着，如果我们想要对该组件进行适当的测试覆盖，就必须为该组件编写相对较大的测试套件。 如果我们的代码是松散耦合的，且副作用相对较少，那么编写测试就会容易得多。

虽然我们想要努力开发可测试的代码，以使编写单元测试的过程更容易，但这并不总是可能的。 因此，如果这意味着牺牲保险范围，有时这是更好的选择。 我们希望避免重写代码，或者更糟的是，为了编写更多的测试而改变我们喜欢的架构。 只有当我们觉得我们的组件足够大，值得更多的测试覆盖时，我们才应该这样做。 如果到了这一步，我们应该重新思考我们的设计。 好的代码很容易测试。

## 工具链和自动化

随着我们的应用程序变得越来越大和复杂，作为正在进行的开发过程的一部分，很多事情需要“离线”进行。 运行单元测试只是我们想要自动化的一个任务。 例如，在运行我们的测试之前，我们可能想要使用一个工具来检查我们的代码，以确保我们不会提交任何太草率的东西。 测试通过后，我们可能需要构建组件构件，以便应用程序的运行实例可以使用它们。 如果我们正在生成模拟数据，那么这可能也是同一个过程的一部分。

总的来说，我们有一个工具链，可以为我们自动化所有这些任务。 这些任务通常是较大、更粗粒度任务中的较小步骤，如*构建生产*或*构建开发*。 正如我们所定义的那样，大任务只是由小任务组成的。 这是一种灵活的方法，因为**工具链**可以处理任务的顺序，按照它们需要发生的顺序，或者，我们可以分段运行任务。 例如，我们可能只想运行测试。

最流行的工具链是一个名为 Grunt 的任务运行器。 其他类似的工具，如 Gulp，也正在获得关注。 这些工具的优点在于，它们有一个蓬勃发展的插件生态系统，可以完成我们需要的大部分工作——我们只需要配置使用这些插件的单个任务，以及我们想要组成的更大的任务。 对于我们来说，设置一个工具链只需要很少的努力，它可以自动化我们的大部分开发过程——除了编写代码本身之外几乎所有的事情。 如果没有工具链，要将我们的开发工作扩展到不止几个贡献者，从非常困难到不可能。

将工具链用于自动化任务的另一个好处是，我们可以更改正在动态构建的工件的类型。 例如，当我们正在开发一个特性时，我们不一定想要构建每个更改的产品工件。 事实上，这样做真的会减慢我们的速度。 如果我们的工具可以只部署原始的模块就更好了，这也可以使调试更加容易。 然后，当我们接近完成时，我们从产品构建开始，并针对它们进行测试。 我们的单元测试可以针对原始源代码和生成的工件构建运行——因为我们永远不知道编译后会引入什么。

# 测试模拟场景

我们的应用程序规模越大，需要处理的场景就越多。 这是更多用户使用更多特性的结果，以及我们的代码必须处理的所有后续复杂性。 使用模拟数据和单元测试确实有助于将这些场景放到测试中。 在本节中，我们将介绍一些可用的选项，用于创建这些模拟场景，然后通过单元测试和作为用户与系统交互对它们进行测试。

## 模拟 api 和测试 fixture

模拟数据对我们来说很有价值，原因有很多，其中之一就是单元测试。 如果我们正在模拟 API，我们可以像运行真正的 API 一样运行单元测试。 我们对模拟数据中的单个数据点有细粒度的控制，并且我们可以自由地更改它——它是沙箱数据，对外界没有负面影响。 即使我们使用工具生成模拟数据，我们也可以进入其中并打乱数据。

一些单元测试工具接受 fixture 和仅用于运行测试的数据。 这与我们使用 Mockjax 这样的 API 模拟工具所使用的数据并没有太大区别。 主要的区别是 fixture 在使用它们的单元测试框架之外对我们没有多大用处。

如果我们可以用它来测试和嘲笑呢? 例如，假设我们想要利用单元测试框架的 fixture 数据功能。 它有一些自动化的功能，如果我们不给它提供 fixture 数据，我们就无法使用这些功能。 另一方面，我们还希望为开发目的模拟 API，与特性进行交互，从后端分离，等等。 没有什么可以阻止我们将 fixture 数据提供给单元测试和 API 模拟。 这样，我们就可以使用我们创建的任何模拟数据生成器来生成由测试和浏览器中的用户交互共享的场景。

![Mock APIs and test fixtures](graphics/4639_08_08.jpg)

单元测试可以使用请求攻击模拟 API，或者直接使用 fixture 数据; 如果模拟 API 提供相同的数据，那么就更容易找出失败测试的问题所在

## 场景生成工具

随着时间的推移，我们将积累新特性和更多客户将使用这些特性的场景。 因此，作为我们工具链的一部分，拥有一个用于生成模拟数据的工具将非常有帮助。 更进一步，这个实用程序可以接受生成模拟的参数。 这些可能是简单的粗粒度参数，但这通常是我们将随机生成的模拟数据转换为我们需要的精心规划的场景所需要的全部内容。

我们将生成的各个模拟场景彼此之间不会有很大的差异。 这是一个点，我们需要一些作为基线的东西，所以如果我们确实对我们的情景有有趣的发现，我们可以问-*这些数据有什么不同?* 如果我们确实开始生成大量的场景，因为我们有一个工具使我们能够这样做，我们需要确保我们实际上有一个“黄金”模拟数据集，这是我们知道的一些东西，如预期的工作。

我们需要对黄金模拟数据进行的更改类型包括更改集合中的实体数量。 例如，假设我们想要查看某些内容在给定页面上的执行情况。 所以我们创建了一百万个模拟实体，看看会发生什么。 页面完全中断——进一步的研究揭示了一个`reduce()`函数，它试图对大于最大安全整数的数字进行求和。 场景可以揭示像这样有趣的 bug。 即使我们正在使用的场景是遥远的，不太可能发生在生产中，我们仍然应该修复这个错误，因为其他不太极端的场景肯定会触发它。

![Scenario generation tools](graphics/4639_08_09.jpg)

更改场景可能会导致测试失败; 通常我们会创建可伸缩的场景来查看我们的代码在哪里出了问题

我们可以模拟的可能性非常多。 例如，我们可以通过删除实体属性来破坏一些数据，确保前端组件有正常的默认值，或者优雅地失败。 后一点实际上非常重要。 随着我们扩展 JavaScript 代码，越来越多的情况我们无法修复，我们只需要确保我们的故障模式是可接受的。

# 端到端测试和持续集成

谜题的最后一部分是对我们的特性进行端到端测试，并将其连接到我们的持续集成过程中。 单元测试是一方面，当它们通过时，它们让我们相信我们的组件是可靠的。 用户不关心单元测试，端到端测试作为与 UI 交互的用户的代理。 例如，在我们实现的任何给定的特性的需求中，都可能嵌入一组用例。 端到端测试应该围绕这些进行设计。

像 Selenium 这样的工具使自动化端到端测试成为可能。 它们将测试记录为我们作为用户执行的一组步骤。 无论何时，我们都可以重复同样的步骤。 例如，端到端测试可能涉及创建、修改和删除资源。 工具知道在 UI 中寻找什么是成功的路径。 当这种情况没有发生时，我们就知道测试失败了，我们需要去解决一些问题。 自动化这些类型的测试对于扩展至关重要，因为随着我们添加特性，用户与应用程序交互的方式也在增加。

我们可以再次向工具链寻求帮助，因为它已经自动化了我们所有的其他任务，它可能也应该自动化我们的端到端测试。 工具链对于我们的持续集成过程也是必不可少的。 我们可能会共享一个 CI 服务器来构建我们系统的其他方面，只是操作方式不同。 工具链使我们很容易与 CI 过程集成，因为我们只需要编写适当的工具链命令的脚本。

有了模拟数据可以帮助我们运行端到端测试，因为如果工具要像用户一样运行，它将不得不发出后端 API 请求。 这使我们保持一致性，并帮助我们排除测试本身是问题来源的可能性。 使用模拟 api，我们可以开发单元测试，并针对同一源进行端到端测试。

![End-to-end tests and continuous integration](graphics/4639_08_10.jpg)

工具链、模拟数据和我们的测试都在 CI 环境中运行; 我们正在开发的代码就是输入

# 小结

本章介绍了 JavaScript 前端应用程序的可移植性的概念。 在这个上下文中，可移植性意味着不与后端紧密耦合。 可移植的主要优势意味着我们可以把 UI 当作它自己的应用程序，它不需要任何特定的后端技术。

为了帮助前端实现独立性，我们可以模拟它所依赖的后端 API。 Mocking 还可以让我们严格地专注于 UI 开发——消除后端问题阻碍我们开发的可能性。

mock 也可以帮助我们测试代码。 我们可以利用许多单元测试库，每个库都有自己的方法。 如果我们使用相同的模拟数据来运行测试，那么我们可以排除与浏览器中看到的不一致。 我们的测试需要自动化，同时还有一些作为开发过程一部分发生的其他任务。

我们实现的工具链很好地适应了持续集成服务器——一个基本的扩展工具。 这也是端到端测试自动化的地方，这让我们更好地了解用户在使用我们的软件时会遇到什么。 现在是时候转换一下方向了，仔细看看扩展我们的应用程序的限制。 我们不能无限扩大规模，下一章将探讨当我们扩大到一定规模时，如何避免撞墙。