# 二、规模影响力

规模影响者从我们软件的用户开始。 他们是最具影响力的人，因为他们是我们开始开发应用的原因。 正如我们在前一章中所看到的，用户会影响一些特性，这些特性最终会影响我们编写的代码以及实现代码的开发人员。 当我们停下来思考这些影响扩展的因素时，我们意识到一个能够处理它们的健全的 JavaScript 架构是一个谨慎的原因。 然后，我们可以利用我们的发现，从不同的架构角度查看我们的代码。 从下一章开始，我们将在本书中深入研究这些观点。

但在此之前，让我们更详细地了解这些影响规模的因素。 我们想要密切关注这些，因为我们对设计做出的每一个决定，其实际规模在很大程度上取决于我们预期的影响。 也许更重要的是，我们需要以这样一种方式来设计我们的体系结构，它使我们能够处理我们没有预料到的伸缩场景。

我们将从我们软件的用户开始。 他们为什么要用它? 我们的软件如何让他们开心? 这对我们有什么好处? 不管你信不信，这些问题都与我们编写 JavaScript 的方式有关。 从用户，我们向下移动到功能，我们的应用的外向个性。 有些特性并不适合我们的应用，但有时这并不重要——我们没有发言权。 如果我们要扩大规模，取悦我们的用户，有时我们必须充分利用这些功能。

开发资源，最终负责执行这些功能，是可以成就或破坏产品的规模影响者。 我们将着眼于开发团队所面临的挑战，以及他们是如何受到特性影响的约束。 我们将以这些影响者的一般清单来结束这一章; 以确保我们已经考虑到最紧迫的问题，有关我们的规模能力。

# 可伸缩用户

最重要的用户是我们——开发组织。 虽然我们的任务是通过交付可伸缩的软件来让用户高兴，但我们也需要让自己高兴。 这就需要一个可行的商业模式。 我们之所以关心这一点，是因为不同的模型意味着获取新用户和管理现有用户的不同方法。 从这里开始，扩展用户基础的复杂性就变得更深了。 我们需要考虑用户是如何组织的，他们如何使用我们的软件彼此通信，如何提供支持，收集反馈，以及收集用户指标。

JavaScript 应用可行的商业模式包括部署一个免费的、支持广告的服务，以及一个私有的、内部部署我们的软件，在那里我们收取许可费。 决定哪一种方法对组织来说是正确的可能不是我们能控制的。 然而，我们有责任理解所选择的业务模型，并将其与我们软件的当前和未来用户联系起来。

商业模式可能会变得相当复杂。 例如，组织通常会从一种明确的、让用户满意的方法开始，同时满足业务期望。 然而，随着组织的成长和成熟，曾经一致的业务模型变得模糊起来，变得难以接近，并对我们的体系结构产生不可预测的结果。 让我们来看看其中的一些业务模型，以及它们如何影响我们的用户基础的可伸缩性。

## 授权费用

软件授权是一个复杂的话题，我们不打算在此深入探讨。 重要的是我们是否依赖授权软件作为我们的商业模式。 如果是，那么我们可能会有其他组织部署我们的 JavaScript 应用。 我们不太可能让个人购买许可证。 但也不是不可能——这取决于软件的性质。 销售许可的可能情况是:我们的软件将被多个组织私下部署。

对于这个业务模型，有两个有趣的规模特性需要考虑。 首先，给定组织内的用户数量有一个基本限制。 虽然组织可以很大，我们可以向多个大型组织销售产品，但通常的情况是使用许可模型总体上拥有较少的用户。 其次，每个组织在定制方面有不同的需求。 这涉及到可配置性、用户组织等。 我们更有可能遇到使用许可模型的此类更改或增强的请求。

因此，虽然没有那么多的用户需要支持，但由于使用我们的软件的组织结构，支持他们的性质更加复杂，因此难以扩展。 在这些环境中，依赖关系管理同样具有挑战性，这是由于决定了我们的软件如何能够伸缩的限制。 在其他环境中，这些限制更为宽松。

## 订阅费用

订阅是我们为使用我们的软件而收取的经常性费用。 在大多数情况下，这种方法的成本更低。 它也是一种更灵活的商业模式，因为它可以很容易地应用于内部部署的软件，以及公开部署的软件。

由于对组织来说，部署基于订阅的软件比基于许可的软件更便宜，我们更有可能接触到更多的组织。 请注意，这些组织被划分为多个部门，每个部门都有自己的预算限制。

然而，就规模而言，订阅所面临的挑战与许可证所面临的挑战类似，即复杂的定制请求。 如果订阅能给我们带来更多的内部部署和更多神秘的功能请求。 订阅方式面临的另一个可伸缩性问题是客户保留。 如果价值不能持续传递，用户就不会继续支付订阅费用。

因此，如果我们选择订阅模式，我们就需要加大投入，推出新功能，让用户的经常性订阅成本变得合理。

## 消费费用

软件的另一种商业模式是消费，即随用随付。 这对用户来说是个很有吸引力的模式，因为他们不用为自己不使用的资源付费。 当然，这并不适用于所有应用。 如果没有有意义的资源供用户使用怎么办? 如果我们以一种与资源消耗无关的方式运行应用呢?

在其他情况下，资源的使用是非常明显的。 也许用户执行一些计算开销很大的任务，或者在一段时间内存储大量数据。 在这些情况下，消费模式对我们和用户都很有意义。 消费得少的用户支付得少。 用户行为可能不稳定，消费高峰。 然而，相对于他们使用我们的应用的其余时间，这些事件是简短的。

我们在这个业务模型中面临的扩展挑战是，除了应用的核心方面外，我们还需要好的工具。 首先，我们需要一个测量和记录消费的工具。 其次，我们需要工具来准确地描述这些消费指标，通常是视觉上的。 根据用户的消费情况，以及我们期望的集成级别，可能需要考虑第三方组件。

## 广告支持

另一个选择是在公共互联网上部署我们的应用，并使用显示广告来获取收入。 这些都是免费的应用，因此更有可能被使用。 另一方面，广告使许多人失去兴趣，这抵消了“免费”的吸引力。

也许使用这种方法的目标，而不是广告收入，是产生大量使用。 这两者实际上是相辅相成的，更多的用户意味着更多的广告收入。 然而，大规模采用在线 JavaScript 应用可以吸引投资者的注意。 因此，大量用户账户本身就有其优点。

这些类型的应用在扩展方式上不同于那些遵循其他业务模型的应用。 在互联网上获得广泛吸引力的应用为不同的用户角色解决不同的问题。 遵循这一模式意味着我们需要扩大覆盖范围，而扩大覆盖范围意味着降低进入门槛。 在使用这种商业模式时，我们的重点是易用性和社会有效性。

## 开源

我们要考虑的最后一个商业模式是开源。 别笑; 开源软件对网络的运作至关重要。 我们的 JavaScript 应用几乎不可能不使用任何开源组件。 更有可能的是，我们只使用开源组件。 但是，为什么人们要把宝贵的时间花在开发工具上供其他人使用，甚至是他们的竞争对手?

这里的第一个误解是，人们只是无所事事地坐着，为我们其他人构建开源软件。 事实是，我们将使用的大多数工具都是由那些使用与我们相同技术的公司中处于强势地位的人开发的。 他们甚至可能已经启动了开源项目来为公司解决一个问题——为他们的开发过程提供一个缺失的工具。

第二个误解是，我们通过启动或参与开源项目来帮助我们的竞争对手。 我们不可能单枪匹马地将自己置于比我们的竞争对手更糟糕的境地。 从其他方面来看，是的，通过伤害我们自己来帮助我们的竞争对手是完全可能的。

另一方面，开放源码项目可能对组织有好处。 它们必须是有效的项目; 一些可用和通用的东西。 如果它能长腿，我们就能在我们所依赖的技术中创造新的利益相关者，这是一件好事。 围绕开源项目的社区是无价的。 虽然开源本身不能支持一个组织，但它是任何 JavaScript 应用业务模型的组成部分，这是不可否认的事实。

组和角色组允许我们对用户进行分类。 可以将角色看作用户类型。 这是一个强大的抽象，因为它允许我们根据角色类型概括特性的各个方面。 例如，我们根据角色属性检查条件，而不是根据用户属性检查。 将用户从一个角色转移到另一个角色要比修改我们的逻辑容易得多。

弄清楚用户角色以及它们如何转化为组实现是一个棘手的问题。 我们唯一能指望的就是改变用户的组织结构。 因此，使分组机制尽可能通用是我们的首要目标。 这也有权衡——任何完全通用的东西都有负面的性能影响。

有些分组决定是显而易见的。 比如用户是否知道系统中的其他用户。 如果是，我们可以开始深入研究用户如何使用我们的应用进行通信的具体问题。 同样，根据应用所具有的特性类型，这一点是显而易见的。 我们所遵循的商业模式也影响着我们的用户管理设计。 如果我们正在销售软件许可证，并且很可能部署在本地，那么我们可以预期到用户角色的许多不同需求，以及随后的分组实现。 如果我们在互联网上公开部署，分组就不那么重要了——例如，我们可以选择一种有利于性能的简单方法。

随着我们的软件变得越来越复杂，随着我们添加更多的功能并吸引更多的客户，我们将开始看到对应用的各个部分进行分离的需求。 也就是说，我们需要基于访问控制权限绑定某些特性。 安装独立的软件系统，而不是拥有不同的用户角色; 对他们来说，拥有一个具有用户、组和访问控制的单一系统更容易。

这对我们作为 JavaScript 架构师来说是有意义的，因为一旦我们开始访问控制的路径，就无法回头了。 从那时起，我们必须保持一致—每个特性都需要检查适当的权限。 更复杂的是，如果我们以这种方式对用户进行分组，我们可能不得不在某些时候以类似的方式对系统的其他实体进行分组。 这只对最终用户有意义，这组东西是由这组用户访问和使用的。

## 通信用户

关于用户及其彼此之间的关系，需要考虑的另一个方面是这些用户可用的通信渠道。 他们是否明确地选择和其他用户交流? 或者是交流更含蓄? 后者的一个例子可能是与我们来自同一组的用户，正在查看图表。 这张图表是根据小组其他成员输入系统的数据生成的。 除了显性的通信渠道，还有必要考虑这些隐性的通信渠道吗?

应用的性质决定了哪些通信通道是对用户开放的。 这也可能取决于用户自己。 有些应用有用户需要进入其中，并且熟练地执行任务——与其他用户通信是不必要的。 另一方面，我们可能会发现自己发展出一些更具社会意识的东西。 事实上，我们甚至可能依赖外部社交网络的服务。

如果我们要依赖第三方用户管理、社交网络或其他方式，我们必须小心与这些服务的紧密联系。 就规模而言，使用第三方认证机制可能会有我们想要的社交奖励功能——尤其是考虑到大多数用户会喜欢他们不需要另一个账户来使用我们的应用。 一旦我们开始实现新特性，第三方集成就很复杂，从其他角度来看，将这种方法扩展到用户管理就会成为一个问题。 例如，使用 Facebook 登录可以更好地扩展照片编辑应用，因为大多数用户的照片都来自 Facebook。

如果我们的应用有用或有趣，用户就会找到一种相互通信的方式。 我们可以对抗它，或者我们可以利用用户交流作为工具来帮助我们扩大规模。 也就是说，扩大透明度，我们的用户可以向他们的同行指出一些有用的东西，否则他们将不得不去挖掘。

## 支持机制

很高兴我们的 JavaScript 应用能够正常工作。 即使一切都按照计划进行，我们已经部署，没有 bug，我们也必须支持用户不知道如何使用的情况。 或者他们做了一些不应该做的事。 或者在其他一千万个可用性问题中有一个是相关的，迅速补救是必要的。

我们的支持机制不扩展会使我们的业务陷入停滞。 所以，除了我们的软件扩展性，我们还需要考虑用户支持系统如何与之同步扩展。 支持可以紧密集成，也可以外包给第三方软件和人员。

如果用户使用我们的软件不需要支持，那就更好了。 这就是为什么我们在设计时要考虑到可用性。 我们经常与专家和/或实际用户探讨各种用户体验，并在我们的软件中为他们集成设计。 当涉及到支持用户时，这是我们可以解决的最明显的问题。 因为如果我们能够做到这一点，通过可用性设计，我们就可以消除在扩展过程中可能面临的很大一部分支持问题。

无论如何，我们仍然必须假设我们没有考虑部署后不可避免地出现的支持情况。 用户是好奇的。 即使一切顺利，他们仍然可能有问题。 所以我们不能说，“我们已经为你设计了一个很棒的用户体验，一切正常，所以离开吧。” 我们需要及时回应用户的问题和关切。 因为一旦我们忽视了询问，我们就无法扩展应用。

我们的 JavaScript 组件能帮助支持我们的用户吗? 如果这是我们想要的，那当然! 事实上，上下文帮助可能是最有效的。 如果用户对一个特定的组件有疑问，他们看到一个帮助按钮，就在有问题的组件中，然后他们可以使用这个按钮来提交他们的问题。 在接受支持的问题上，困惑更少。 我们确切地知道用户想要做什么，不再需要花时间围绕问题创建上下文。

这绝对是说起来容易做起来难，而且对我们来说还有其他可扩展性的影响。 这些上下文帮助系统并不是免费的。 如果我们决定走这条路，我们就必须考虑我们执行的每个功能的上下文帮助。 这能与我们正在做的其他事情相提并论吗?

我们可能想要考虑的另一种方法是一个知识库，其中包含来自创建软件的组织的信息，以及来自使用它的组织的信息。 那些为了特定目的而使用它的人往往会有比我们更好的答案，而这些答案是超级有价值的。 不仅是对寻求答案的用户，也是对我们。

## 反馈机制

反馈是否真的值得区别于支持? 支持绝对是反馈。 如果我们关注我们在一段时间内遇到的各种支持问题，我们就可以将其转化为反馈，并使用这些信息作为反馈。 然而，这两种形式仍然值得区分，因为用户处于不同的心境。 当遇到支持问题时，会有从轻微到强烈的挫败感。 这类用户现在并不关心改进产品，他们需要完成自己的工作。

另一方面，已经使用我们软件一段时间的用户会敏锐地意识到他们工作流程的低效性。 收集这种类型的反馈非常重要。 我们怎么得到它? 一个选项是在应用中提供一个反馈按钮，就像我们使用上下文支持按钮一样。 另一种选择是让第三方处理反馈收集。 与支持一样，自动化上下文对我们来说总是更好的，因为它可以帮助我们理解用户在谈论什么，而不需要花费太多的时间。

反馈的关键是让客户参与进来。 并不是每个使用我们软件的人都会和我们分享他们的想法。 但毫无疑问，有些人会——即使他们只是在发泄沮丧。 为了建立对话，我们必须对这些问题做出回应。 提供这种反馈的用户希望我们对他们做出回应。 产品改进是在与这些用户的持续对话中出现的，而不是在用户最初提交的精彩的想法中。

随着用户基数的增长，我们能否跟上用户的反馈? 显然这是一个挑战，考虑到我们要处理的其他事情，处理我们的应用的增长。 围绕给定的用户数据创建对话是一回事，但根据反馈采取行动又是另一回事。 假设我们在软件中嵌入了很棒的反馈机制。 我们将在某个时候把它变成可行的工作。 因此，我们需要考虑如何根据用户反馈规模来生成需求。 如果不这样做，用户的反馈就不会被采纳，他们就会退出，我们就无法扩大规模。

## 通知用户

JavaScript 应用需要向用户显示通知。 这些可以相当直接地实现，特别是当我们主要关注对用户操作的响应时。 例如，当用户做某件事时，它会导致向后端发送 API 请求。 我们将想要显示一个通知给用户，指示操作已经成功或失败。 这些通知在整个应用中看起来是相同的——我们可以对大多数(如果不是全部)通知使用相同的工具。

在设计可伸缩的 JavaScript 架构时，通知很容易被遗忘。 这是一个大话题——有上下文通知、一般通知和用户离线时发生的通知。 后者通常意味着一些东西已经通过电子邮件发送给用户，提示他们登录并在需要时采取行动。

上下文通知可能是最重要的，因为它们向用户提供他们当前正在做的事情的反馈。 这是具有挑战性的扩展，因为我们必须确保这些类型的通知在整个用户界面上保持一致，对于所有类型的实体。 更一般的通知是在后台发生的事情的结果。

属于用户的某些资源可能已更改状态，可能是预期的，也可能是意外的。 无论如何，用户可能想要了解这些事件。 理想情况下，如果他们已经登录并使用系统，那么一个通用的通知将显示自己。 然而，我们可能也希望通过电子邮件将这些类型的通知发送给用户。

任何通知系统的挑战都是容量。 如果有很多用户，并且他们相当活跃，那么就需要生成和发送大量通知。 这无疑会影响代码中其他组件的性能。 我们还面临着通知的可配置性。 我们不可能为所有用户提供正确的通知，所以我们需要进行某种程度的通知调优。 应用的适当扩展级别取决于我们 JavaScript 架构师和开发人员。

## 用户参数

解决用户如何与我们的软件交互这个问题的最好方法是通过数据。 某些数据点无法猜测或手工收集。 这就是我们需要依赖工具的地方，这些工具在用户与我们的软件交互时自动收集用户指标。 有了原始的数据，我们就能很好地分析我们所看到的，并做出决定。

虽然自动化这个任务是有意义的，但是这个任务在一开始可能不是必需的。 只有当我们不确定某一特定功能的未来发展方向时，或者当我们想进一步了解哪些工作需要优先考虑时，收集用户参数才有价值。 很多时候，我们可以不费多大力气就得到这些答案，而且“肯定不需要分析工具”。 如果我们在某个地方部署了本地部署，甚至可能不允许我们收集这些数据。

有大量好的第三方度量收集工具可用。 这些特别有用，因为它们附带了大量我们需要的报告。 还有很多我们不知道的。 还有一个问题是，我们希望第三方组件紧密地集成在一起。 我们总是有可能需要关闭这样的功能。 或者，至少改变这些数据的存储位置。

除了作为产品方向决策的输入，这些数据还有很多用途。 我们的代码可以获取用户度量数据并反射性地改善体验。 这可能是一些单纯的事情，就像根据过去的事件来建议下一步该做什么一样。 或者我们可以根据这些数据进行效率优化。 这一切都归结为我们的用户想要什么。 搞清楚用户想要什么本身就是一个规模问题，因为随着我们的发展，我们会获得更多用户，他们的需求各不相同。 用户参数可能是解决这个问题的有用工具。

## 伸缩用户示例

我们的软件公司正在开发一种网上借贷应用。 这是相当简单的; 前端没有很多活动部件。 申请人首先创建一个帐户，然后可以申请新的贷款和管理现有贷款。 此应用的业务模型是基于消费的。 我们通过贷款的利息获得收入，所以贷款消费得越多，我们挣得越多。

最明显的影响因素是用户数量和易用性。 我们的部分价值主张是小额贷款的低利息。 用户在申请新贷款时应该有很少的开销; 所需的最小输入和贷款申请成功或失败的最小等待时间。 这是我们高度关注的价值交付愿景，以及我们将面对的一些更明显的规模影响者。

让我们考虑一下我们的应用在规模方面的一些更微妙的含义。 考虑到这款应用的类型，我们不太可能看到对社交功能的需求。 在大多数情况下，用户可以被视为一个黑盒子; 当使用我们的应用时，他们在自己的小宇宙中。 因为易用性对我们来说非常重要，而且我们的应用很少有活动部件，所以当涉及到规模时，支持和反馈不太可能是因素。 我们不能消除支持和反馈，但我们对这些领域的关注可以是最小的。

另一方面，我们需要推广我们的服务，我们真的不知道我们的客户贷款的目的，什么是最流行的还款计划，等等。 因此，我们可以传达更有效的市场信息，并改善我们的整体用户体验。 这里的含义是，收集关于应用的元数据是一件大事。 因为我们追求的是大量的用户，这意味着我们需要存储大量的元数据。 我们还必须以这样一种方式设计每个功能，即我们可以收集指标并存储它们以供以后使用，这将使设计复杂化。

# 规模功能

现在，我们将把注意力转向扩展我们在软件中实现的特性。 用户是最终的影响，现在我们有了一个粗略的概念，在扩展他们方面需要什么，我们可以把这些知识用于特性开发。 当我们考虑扩大用户规模时，我们考虑的是为什么。 为什么我们选择这种商业模式而不是那种商业模式? 为什么我们需要为一个用户角色启用某些功能，而为其他用户角色禁用这些功能? 一旦我们开始用 JavaScript 设计和实现这个特性，我们就会开始思考如何实现它。 我们不仅要考虑正确性，还要考虑可伸缩性。 与用户一样，当涉及到可扩展功能时，影响者是决定性因素。

## 应用价值

我们认为我们实现的功能做得很好，我们引入的每一个新功能都在为用户提供价值。 这是值得我们思考的，因为从本质上来说，这就是我们试图做的——将我们的软件的价值扩展到更广泛的受众。 在这方面，不扩展的一个例子是，依赖于现有特性的现有用户被忽视，并且对我们的软件感到失望，因为我们专注于扩展新的领域。

当我们忘记了我们最初打算用软件解决的问题时，就会发生这种情况。 这听起来可能是一个荒谬的想法，但根据一些因素，很容易朝完全不同的方向发展。 在一些罕见的情况下，这种方向上的改变已经导致了一些世界上最成功的软件。 在更常见的情况下，它会导致软件失败，这确实是一个可伸缩的问题。 我们的软件应该始终提供一套核心的价值主张——这是我们的软件的本质，永远不应该动摇。 我们经常会遇到其他影响扩展的因素，比如新客户的加入，他们想要与我们的软件提供的核心价值不同的东西。 无法处理这一问题意味着我们无法扩展应用的主要价值主张。

当涉及到规模值时，我们误入歧途的一个标志是混淆了当前值和理想值。 也就是说，我们的软件目前所做的事情与我们希望它将来做的事情之间的对比。 我们必须向前看，这是毫无疑问的。 但未来的计划需要不断地检查哪些是可能的。 这通常意味着回溯到我们最初创建软件的原因。

如果我们的应用真的很吸引人(我们也希望如此)，那么我们就必须与其他有影响力的用户进行斗争。 也许这意味着我们评估新特性的过程包括确保该特性在某种程度上有助于我们软件的核心价值主张特性。 并不是所有正在考虑的功能都能够实现，这些功能值得仔细研究。 这真的值得改变方向，并危及我们的扩张能力吗?

## 杀手功能 vs .杀人功能

我们希望我们的申请能在众多申请中脱颖而出。 如果有一个足够利基的市场，我们几乎没有竞争，那就太好了。 这样就可以很容易地实现稳定运行的软件，不需要任何花哨的东西，每个人都会很高兴。 考虑到这不是现实，我们必须区分——实现这一点的一种方法是实现一个杀手级的功能——这是我们的软件中其他人没有的一个方面，也是用户非常关心的东西。

挑战在于，杀手级功能很少被设计出来。 相反，它们是在我们的应用交付过程中发生的其他事情的副作用。 当我们不断完善我们的应用，完善和调整功能时，我们会偶然发现一个“小”的变化，它将发展成一个杀手级的功能。 毫不奇怪，这通常是杀手级功能产生的方式。 通过倾听我们的客户并满足扩展需求，我们能够改进我们的功能。 我们添加新功能，删除一些功能，并修改现有功能。 如果我们长时间成功地做到这一点，那些致命的特征就会显露出来。

有时候，很明显，在规划某个特定功能的过程中，为了成为一个杀手级功能，它试图成为一个杀手级功能。 这不是最优的。 它对用户也没有价值。 他们没有选择我们的软件，因为我们的产品路线图上有“许多杀手级功能”。 他们选择我们是因为我们做了他们需要做的事。 可能比其他方法更有效。 当我们开始考虑杀手级功能本身时，我们就开始偏离应用的核心价值。

这个问题的最佳解决方案是一个开放的环境，一个在特性开始时欢迎所有团队成员输入的环境。 我们越早放弃一个糟糕的想法，就能节省更多的时间。 不幸的是，这并不总是那么明确，我们必须对这一功能进行一些开发，以便发现一个或多个方面不能很好地扩展。 这可能有很多原因，但并不是完全失败。 如果我们仍然愿意在开发开始后终止某个功能，那么我们可以从中吸取宝贵的教训。

当事情不能扩展时，我们决定终止这个特性，我们会帮我们的软件一个忙。 我们不会因为强加一些不起作用的东西而损害我们的架构。 在开发任何功能的过程中，我们都需要扪心自问; “我们是否更重视这个特性，而不是我们现有的架构，如果是，我们是否愿意改变架构来适应它?” 大多数时候，我们的架构比特性更有价值。 因此，停止开发不适合的东西可以作为一个宝贵的教训。 在未来，我们将更好地了解哪些功能可以扩展，哪些不能，基于这个被取消的功能。

## 数据驱动功能

拥有一个拥有大量不同用户基础的应用是一回事。 通过收集数据，利用它们与我们的软件交互的方式是另一回事。 用户指标是一个强大的工具，用于收集与我们的软件决策相关的信息，以及它所采取的未来方向。 我们称这些为数据驱动特性。

一开始，当我们只有很少的用户时，我们显然无法收集用户参数。 我们将不得不依赖其他信息，比如我们团队的集体智慧。 我们过去可能都参与过 JavaScript 项目，所以我们有足够的粗略想法让产品开始工作。 一旦达到这个目标，我们就需要适当的工具来更好地支持我们对特性的决策。 特别是，哪些功能是我们需要的，哪些是我们不需要的? 随着软件的成熟，我们收集了更多的用户指标，我们可以进一步完善我们的功能，以满足用户的实际需求。

拥有制作功能数据驱动的必要数据是一项具有挑战性的任务，因为我们首先需要收集和完善数据的机制。 这需要我们可能没有的开发努力。 此外，我们必须根据这些数据来决定特性——数据本身不会变成我们的需求。

我们还想预测我们被要求实现的功能的可行性。 如果没有数据支持我们的假设，这项任务就很难完成。 例如，我们是否有关于应用将在其中运行的环境的任何数据? 简单的数据点就足以确定某个特性不值得实现。

数据驱动特性从两个角度工作，即我们自动收集的数据和我们提供的数据。 两者都很难规模化，但都是规模化所必需的。 唯一真正的解决方案是确保我们实现的功能的数量足够小，这样我们就可以处理给定功能生成的数据量。

## 与其他产品竞争

除非我们是在一个完全利基的市场上经营，否则很有可能会出现竞争产品。 即使我们是在一个小众市场，仍然会有一些重叠其他应用。 有很多软件开发公司在那里-所以我们可能会面临直接的竞争。 我们通过创造卓越的功能来与同类产品竞争。 这意味着我们不仅要继续交付一流的软件，而且还需要了解竞争对手的情况，以及他们的软件用户的想法。 这是我们扩展能力的一个限制因素，因为我们必须花时间了解这些竞争技术是如何工作的。

如果我们的销售团队比我们的产品更出色，他们通常是了解其他人在做什么的很好的信息来源。 他们经常会被潜在的客户询问我们的软件是否有这样或那样的功能，因为其他的应用有这样的功能。 也许最吸引人的卖点是，我们可以提供这一功能，而且我们可以做得更好。

这是我们必须小心的地方，因为这是限制我们赢得客户能力的另一个比例因素。 我们必须扩大对现有和潜在客户的承诺。 承诺太多，我们将无法实现这些功能，导致用户失望。 承诺太少，或者什么都不做，我们一开始就不会赢得客户。 克服这种扩展限制的最好方法是确保那些销售我们产品的人与我们软件的实际情况保持良好的联系。 它能做什么，不能做什么，未来的可能性和不切实际的选择。

要销售我们的产品，就必须有一些回旋的余地来承诺一些事情，而不理解实现这些承诺的全部含义。 否则，我们就得不到我们想要的顾客，因为我们的产品没有任何令人兴奋的地方。 如果我们要将这种方法扩展到新客户，我们需要一种经过验证的方法，将承诺提炼成可实现的东西。 一方面，我们不能在建筑上妥协。 另一方面，我们必须满足用户的需求。

## 修改已有功能

在我们成功地部署了 JavaScript 应用很久之后，我们仍然在不断地改进代码和整体架构的设计。 唯一不变的是变化，或类似的东西。 为了改善用户的体验，我们需要大量的纪律来返回并修改我们软件的现有特性。 原因是我们从涉众那里感受到更多的压力，要求我们添加新特性。 这给我们的应用带来了一个长期的可伸缩性问题，因为在不改进现有功能的情况下，我们不可能永远添加新功能。

不太可能的情况是，没有必要改变任何东西; 所有现有用户都很满意，他们不希望我们碰任何东西。 有些用户害怕改变，这意味着他们喜欢我们软件的某些方面，因为我们在实现方面做得很好。 显然，我们希望有更多这样好的功能，这样用户就会很高兴，不需要改进。

那么我们是如何做到这一点的呢? 我们必须听取用户的反馈，并根据这些反馈制定修改功能的路线图。 为了满足用户和他们的需求，我们必须在实现新功能和修改现有功能之间取得平衡。 一种检查功能增强是否朝着正确的方向发展的方法是向我们的用户群传播提议的改变。 然后我们可以衡量我们得到的反馈，如果有。 事实上，这可能会吸引我们安静的用户给我们一些具体的建议。 这是一种把球放到用户的球场上的方式——“这是我们的想法，你觉得呢?”

除了确定要改进哪些特性以及何时相对于实现新特性进行改进之外，还存在架构风险。 我们的代码耦合得有多紧密? 我们是否能够将一个功能隔离到不可能破坏其他功能的程度? 我们永远不可能完全消除这种风险——我们只能减少耦合。 这里的规模问题是，由于重构、修复回归等原因，我们要花多少时间来修改给定的特性? 当我们的组件是松耦合的时候，我们在这些活动上花费的时间更少，因此，我们可以扩展特性增强。 从管理的角度来看，我们总是冒着阻碍组织中其他人的风险，通过我们的变化带来的冲突。

## 支持用户组和角色

根据我们遵循的商业模式类型和用户基础的规模，用户管理对我们来说是一个可扩展的问题，因为它涉及到我们执行的每一个功能。 用户管理可能会像特性需求一样频繁地变化，这使得情况更加复杂。 随着应用的发展，我们可能要处理角色、组和访问控制。

复杂的用户管理有很多副作用。 我们刚刚实现的新特性可能一开始运行得很好，但在我们的产品客户可能面临的许多其他情况下会失败。 这意味着我们需要更多的时间来测试特性，而质量保证团队可能已经不堪重负了。 更不用说在我们的每个功能中复杂的用户管理所带来的额外的安全和隐私影响。

对于复杂的用户管理模式，我们真的不能做太多，因为它们通常是使用应用及其结构的组织的症状。 对于内部部署，我们更有可能面对这些类型的复杂性。

## 推出新服务

现在的后端服务已经不能满足新特性的需求了。 当很少依赖后端时，我们可以更好地扩展前端开发工作。 如果这听起来违反直觉，不要担心。 我们确实需要后端服务来执行用户的请求。 所以依赖性总是存在的。 我们想要避免的是不必要地改变 API。

如果有使用现有 api 实现该特性的方法，我们就会去做。 这使得后端团队可以通过修复 bug 来关注稳定性和性能。 如果 API 为了支持我们的特性而不断改变，他们就无法做到这一点。

有时候，添加新的后端服务是不可能的。 为了扩展我们的开发过程，我们需要知道什么时候需要新的服务，以及如何实现它们。

第一个问题是这项新服务的必要性。 有时这很容易——不可能实现所请求的 API。 我们只能将就一下了。 第二个问题是新服务的可行性。 我们可能会形成新的 API，因为我们是需要它的人。 然后我们就得听听后端团队的想法了。 如果我们是一个拥有全栈开发人员的团队，那么开销就会更少，因为我们可能都在同一个团队中，并且彼此之间的交流更密切。

既然我们已经决定继续使用新的 API，我们就必须在前端和后端同步实现我们的特性。 这里没有现成的解决方案供我们遵循，因为服务可能容易实现，也可能难以实现。 我们的功能可能需要几个新的服务。 诀窍是在 API 上达成一致，并有一个模拟机制。 一旦真正的服务可用，禁用模拟就是一个时间问题。

然而，就整个应用而言，这只是前端特性和后端服务之间的一个集成点。 引入新功能对系统的影响还不清楚。 我们只能通过测试和先验知识来猜测。 直到制作完成，我们才会看到我们的新功能有多强大。 使用相同服务的不同特性对请求负载、错误率等有不同的影响。

## 实时数据消费

在 JavaScript 应用中，使用套接字连接后端数据是很常见的，以保持任何用户会话与现实同步。 这简化了代码的某些部分，同时使其他部分复杂化。 这对规模的影响是巨大的。 通过网络套接字连接发送实时数据就是所谓的“推送数据”。 在 web 套接字连接之前，流行的技术是长轮询 HTTP 请求。 这基本上意味着，当数据发生变化时，不是将数据传递给客户端，而是客户端负责检查数据是否发生了变化。

如今，围绕实时数据的可伸缩性问题仍然存在。 使用 web 套接字技术，一些负担已经从前端代码转移到后端代码。 当相关消息发生时，由应用服务推送 web 套接字消息。 这里我们需要从几个角度来考虑。 例如，我们的架构作为一个整体是否依赖于实时数据的交付，或者我们是否只考虑单个特性的实时数据?

如果我们正在考虑首次引入 web-socket 连接，以更好地支持一个新特性，我们必须问问自己，它是否适合我们的架构向前发展。 实时数据只影响一两个功能的挑战是缺乏清晰度。 开发人员只关注一个具有实时数据的特性，而不关注另一个没有实时数据的特性，他们将很难解决软件开发过程中出现的一致性问题。

它通常更有意义，而且从多个角度可以更好地扩展，以便将实时数据恰当地集成到我们的前端架构的代码中。 这本质上意味着任何给定的组件都应该以与任何其他组件相同的方式访问实时数据。 尽管如此，当我们从用户和他们的组织自上而下地流动时所面临的可伸缩性问题，最终决定了我们实现的特性类型。 这反过来又会影响实时数据发布的速度。 根据应用的结构以及用户数据的连接方式，实时数据发送到每个浏览器会话的频率可能会发生剧烈波动。 对于我们实现的每个功能，都必须考虑这些因素。

## 规模特征示例

我们的视频会议软件深受大型组织的欢迎。 主要是因为它的稳定性，性能，以及它是基于浏览器的，不需要插件的事实。 我们的一个客户要求我们也实现聊天工具。 他们非常喜欢我们的软件，宁愿用它来进行所有的实时通信，而不仅仅是视频会议。

在 JavaScript 级别上实现聊天实用程序并不太难。 我们最终将重用几个支持网络视频会议功能的组件。 稍加重构，我们就得到了我们需要的新聊天组件。 但是文字聊天和视频聊天在规模上有一些细微的区别。

关键的区别在于文本聊天和视频聊天的寿命，后者通常是短暂的。 这意味着我们需要找出持久聊天的策略。 我们的视频聊天不需要用户账号加入，以防人们想邀请以外的人。 这与短信聊天不同，因为我们不能邀请匿名的演员，然后在他们离开后就把聊天内容吹走。 我们还可能对用户管理组件进行其他更改。 例如，现在的聊天群是否对应于视频群?

因为只有一个客户需要这个功能，所以我们可能需要一种方法来关闭它。 这个新特性不仅有可能削弱我们的核心价值——视频会议——而且可能会给其他客户的部署带来问题。 有了新的后端服务、增加的接口复杂性以及所需的额外培训和支持，可以理解的是，并不是所有的组织都希望启用这个特性。 因此，如果这不是我们的架构中已经有的东西，也就是打开和关闭组件的能力，那么这是影响我们伸缩能力的其他东西。

# 规模性开发

我们要克服的最后一个障碍(T0)是扩大影响因素的实际开发。 任何足够复杂的 JavaScript 应用都不会由一个开发人员单独编写。 这涉及到一个团队，即使它只是在开放源代码上下文中特别和自组织的。 在其他机构中，团队及其角色的定义更为具体。 不管团队是如何组成的，团队的扩展是我们如何对其他扩展影响因素做出反应的直接结果。

我们要解决的第一个问题是我们最有可能在初期软件项目寻找开发资源时首先遇到的问题。 团队不是一成不变的; 随着软件在代码大小和解决方案范围上的增长，我们必须添加新的资源。 不管你喜不喜欢，最好的资源是最有可能离开的，因为它们是最受欢迎的。 理想情况下，我们可以留住一个有才华的团队，但我们仍然需要扩大获取新资源的过程。 我们雇佣 JavaScript 程序员的方式和时间受到我们正在实现的特性以及我们为这些特性的功能而构建的架构的影响。

从日常的角度来看，每个团队成员都应该负责实现应用的特定块。 这是一个复杂的问题，而扩大影响力是罪魁祸首。 我们必须谨慎定义我们在团队中的角色; 不要把它们限制得太紧。 当事情因有影响力的人而改变时，我们需要调整和交付。 刻板的角色定义在这里并没有多大帮助。 相反地，我们至少需要尝试设置边界，如果在开发组件的方式中存在任何自治级别的话。

最后，我们将尝试找出是否有一种合理的方法来确定何时我们可能拥有过多的开发资源。 大声说出来听起来像是一件坏事。 我们有所有的天赋和所有的工作要做——这两项似乎是携手并进的，不是吗? 不,不总是正确的。

## 寻找开发资源

对于产品经理来说，雇佣开发资源不是为了我们目前正在做的工作，而是为了我们计划在未来做的工作，这是很诱人的。 但是，由于许多原因，这种方法不能很好地扩展。 在这种情况下，新员工可能面临的第一个问题是不能通过对真实特性的工作来学习代码。 记住，他们是被雇佣去做一些我们还没有开始的路线图上的事情。 所以他们最终会努力成为有用的人，但他们还没有真正的义务。 几周后，他们就会竭力避开那些想要完成工作的人。

通常最好考虑一下我们现在正在做什么。 在我们的能力上是否有一个明显的差距来交付在我们的软件的下一个版本中所期望的东西? 如果没有明确定义的缺口，新程序员就没有什么可填的了，这只会造成不必要的通信开销。 缺点是，一旦我们在开发所需功能的能力上有了明确的差距，我们就无法找到所需的资源。 这种压力可能会导致聘用错误的人，因为这样或那样的原因，他们不能与团队融洽相处。

扩大我们开发资源增长的一个更好的方法是等待出现缺口。 差距并不一定意味着这个世界着火了，你的公司就要失败了。 这只是意味着我们可以在发展方面做得更好。 如果可以避免的话，我们不应该一次雇佣一个以上的开发人员。 如果我们花时间去寻找合适的资源，那么它们很可能会填补我们在过程中发现的任何漏洞。

### 提示

关于软件开发生命周期中通信开销的典型资源是 Fred Brooks 的“人月神话”。

## 开发责任

web 浏览器平台是一个复杂的领域，有很多技术，也有很多移动部件。 网络平台的一些组件比其他组件更新鲜，但对我们来说，理解它们是很重要的。 这些新兴技术是网络的未来。 那么，我们团队中的谁将负责学习这些新技术，并将它们在整个组织中进行社交? 网络平台的挑战在于，一个人在交付产品功能的同时，还需要掌握更多的东西。 这就是为什么我们需要至少某种程度的开发角色。

这些角色的界限有多严格取决于组织及其文化。 正在开发的应用的性质也可能影响要设置的开发角色的类型。 没有配方，尽可能避免严格要求。 原因是我们需要适应由规模影响者带来的变化。 严格的角色本质上阻碍了原本有能力的开发人员灭火。 随着最后期限的临近，我们通常没有时间进行角色划分的争论。

前端的架构师最有可能看到对实现给定的应用架构有意义的角色。 这些可能是暂时的角色，由架构师指导，但由成员自己有机地形成。 这一点在开源项目中尤其明显，因为在这些项目中，人们做自己擅长的事情，因此也就做了他们喜欢做的事情。 虽然我们不能总是准确地采用这个模型，但我们肯定可以从它-形状的角色中获得线索，这些角色围绕着人们在我们的特性需求环境中擅长做什么。 这样做将帮助开发人员在他们需要的地方获得指导。 对 JavaScript 开发的某些方面感兴趣并不意味着他们已经达到了他们所需要的水平。 这就是让资深人士给他们指点窍门，做他们喜欢做的事情，从长远来看对产品有巨大的回报。

## 资源过多

我们已经在一定程度上解决了这样一个概念，即很容易雇佣太多的开发资源——甚至是诱人的。 当产品管理为我们制定了清晰的路线图时，我们想要安心地知道我们实际上有开发资源来实现我们的路线图。 招聘过快不可避免地会导致开发资源过多。 我们现在可能已经在那里了，接下来的问题就是如何应对。

如果我们对团队成员不满意，而且很明显我们拥有的资源比需要的多，那么答案就很简单了。 然而，还有另一种看待事物的方式，如果我们有太多我们不想失去的好的资源。 我们必须调整产品路线图，以适应我们招募的开发人才。 这通常意味着要找到一个渠道，让我们能够将产品想法从开发部门传递到产品管理部门。 这是一门艺术而不是科学。

这是一项具有挑战性的工作，作为一名前端架构师并弄清楚谁将构建什么。 规模我们开发资源的最好方法是向那些正在实现它的人提供我们架构的精确地图。 如果存在差异，找出正确的前进道路。 例如，可能存在缺口，我们需要更多的 JavaScript 程序员，或者可能有太多的资源，需要在产品中做出一些改变。

## 规模性开发实例

我们的应用已经存在一段时间了，已经看到了一些成功，并部署在各种环境中。 我们的核心开发人员之一 Ryan 触及了代码的许多领域。 他帮助许多其他开发人员改进他们的代码，提供建议等等。 我们的应用已经足够大了，我们开始注意到所有特性的性能下降。

我们需要 Ryan 实现一些性能增强，这将涉及重构某些代码部分，基本上占用了他所有的时间。 如果我们计划扩大规模以满足客户需求，我们仍然有一些功能要交付。 另一方面，我们看到了我们在绩效方面的能力出现了危险信号。

我们意识到我们需要雇佣一个新的开发者来帮助开发新功能。 这个开发者不需要像 ryan 那样的排骨。 他们需要对我们使用的技术有基本的了解。 如果幸运的话，我们会找到一个能承担更多责任的人。 但就目前而言，瑞安留下的缺口相当小，我们需要填补。 按比例来说，我们不需要马上再找一个莱恩。

# 影响者清单

我们将以一些清单来结束这一章。 这些都是没有一个正确答案的简单问题。 有些答案在软件的整个生命周期中都是一样的。 以为例，我们的商业模式希望不会经常改变。 其他依赖于事物的当前状态，这就是这些列表的作用。 我们可以一次又一次地回顾它们，随时都有变化。 这些可能是需求、用户、新的部署或对开发环境的更改。 这些问题只不过是对影响可伸缩 JavaScript 应用的因素的微妙提醒。 如果阅读它们的结果是更多的问题而不是答案，那么它们已经达到了目的。

## 用户清单

用户是我们构建软件的首要原因。 这个清单涵盖了为什么我们需要扩展应用的最基本方面。 这些问题将贯穿于软件的整个生命周期。 而不仅仅是当与用户管理角度有问题时。 特性开发的变化应该会触发查看这个列表。

### 我们软件的商业模式是什么?

*   是*基于 license*吗?
*   是*订阅*吗?
*   是基于消费的*吗?*
*   是*广告*吗?
*   是*开源*吗?

### 我们的应用有不同的用户角色吗?

*   功能对一个角色隐藏而对其他角色可见吗?
*   我们的应用中的每个功能都必须是*角色感知*吗?
*   角色是如何定义和管理的?
*   我们的业务模型如何影响应用中角色的使用?

### 我们的用户使用我们的软件互相交流吗?

*   用户是否与相互协作以有效使用我们的应用?
*   用户通信是我们的数据模型的副作用吗?
*   应用中的用户角色如何影响用户交流?

### 我们如何支持我们的应用?

*   支持是内置在应用中，还是外部处理?
*   用户可以使用中心知识库互相支持吗?
*   我们的业务模型和应用用户角色如何影响我们需要提供的支持类型?

### 如何收集用户反馈?

*   反馈集合是内置在应用中，还是由外部处理?
*   我们如何激励用户提供反馈?
*   我们提供的支持类型如何影响我们想要收集的反馈类型?

### 如何将相关信息通知用户?

*   我们的应用是否有一个通用的、上下文无关的通知机制?
*   我们如何确保在任何给定时间只有相关通知发生?
*   用户可以审核他们的通知吗?

### 我们应该收集哪些类型的用户参数?

*   我们是否使用指标来改进产品的未来版本?
*   我们的特性能否在运行时使用度量来改善用户体验?
*   业务模式如何影响我们收集指标的需求?

## 功能清单

跟随来自我们软件用户的规模影响因素，是我们软件的特性。 这个列表涵盖了一些我们应该问自己的问题，关于任何新功能，或在现有功能中实现更改。 它们将帮助我们解决与每个特性的可伸缩性相关的常见问题。

### 我们软件的核心价值定位是什么?

*   我们正在实施的功能或增强是否有助于我们产品的整体价值主张?
*   我们当前的价值主张是否过于宽泛?
*   用户数量及其角色如何影响我们关注与应用价值相关的特性的能力?

### 我们如何确定一个功能的可行性?

*   我们是否在尝试实现杀手级功能，而不是让它们自然出现?
*   我们是否花时间来确定一个提议的特性是否可行，而不是将其实现得很差?
*   我们软件的价值主张，以及用户对功能的要求，如何影响我们最终实现的功能的可行性?

### 我们能对我们的功能做出明智的决定吗?

*   我们是否有任何用户指标数据，我们可以根据这些数据作出决定?
*   有没有我们过去实现过的类似功能的历史数据?
*   我们的业务模型如何影响我们可以收集并用于决定应用特性的数据?

### 谁是我们的竞争对手?

*   我们是否提供了与竞争产品相似的产品，但做得更好?
*   我们是在 niché市场吗?
*   我们能从竞争对手的产品中学到什么?
*   我们的商业模式如何影响我们面临的竞争数量和我们需要实现的功能类型?

### 我们如何使我们所拥有的变得更好?

*   考虑到我们在添加功能的速度，我们是否有足够的时间来维持我们现有的功能?
*   从架构上来说，在不破坏其他特性的情况下修改一个特性是否安全?
*   我们的用户如何影响我们对现有功能的增强?
*   我们的业务模式如何影响我们部署产品增强功能的能力?

### 我们如何将用户管理整合到我们的功能中?

*   访问控制机制是否普遍到不再是特性开发的日常关注点?
*   我们能把我们的特征组织成组吗?
*   用户可以打开或关闭功能吗?
*   我们正在构建的应用类型，以及我们的用户和他们的角色，是如何影响我们功能的复杂性的?

### 我们的功能与后端服务紧密耦合吗?

*   现有的服务是否足够通用来处理我们正在实现的新特性?
*   我们是否能够模拟后端服务，完全在浏览器中运行?
*   我们的特性如何影响后端服务的设计和功能?

### 前端如何与后端数据保持同步?

*   我们可以利用网络套接字连接来推送通知吗?
*   高用户活动是否会导致更多的消息被传递给其他用户?
*   使用实时数据如何影响我们功能的复杂性?

## 开发人员清单

在整个软件开发过程中，我们想要回顾的最后一个清单与开发资源有关。 这个清单不会像用户或特性列表那样频繁使用。 尽管如此，重要的是要确保我们解决了发展资源方面出现的问题。

### 如何找到合适的开发资源?

*   以我们目前拥有的开发资源，我们能通过吗?
*   我们是否需要重新审视正在开发的特性，以适应我们拥有的资源?
*   对于我们正在构建的产品，我们是否拥有*正确的*开发资源?

### 我们如何分配开发职责?

*   职责范围之间应该有多少重叠?
*   我们目前的职责范围是否反映了我们正在构建的东西?
*   我们团队成员的各种技能如何影响职责?

### 我们能避免雇用太多的资源吗?

*   我们是否在真正需要员工之前就开始招聘了?
*   由于资源过多，我们是否经历了通信开销?
*   同时开发的功能的数量如何影响更多开发人员意味着完成更多工作的看法?

# 小结

在 JavaScript 应用中规模影响者有三个主要方面需要关注。 每个区域都直接影响其下方的区域，直到我们最终触及底层，即开发的发生地。

首先也是最重要的是我们软件的用户。 有许多用户相关的因素会影响我们软件的可伸缩性需求。 例如，我们组织选择的业务模型会微妙地影响以后关于架构的决策。 基于许可的部署很可能部署在某个地方，因此更有可能需要定制。 复杂性的组合是无穷无尽的，它们都源于我们软件的用户。

我们接下来关注的主要领域是功能本身。 我们必须从对用户及其规模影响的思考中获得很多见解，并将其作为功能设计的输入。 例如，一旦人们开始使用我们的软件，在短时间内可能会发生很多事情。 这将如何使我们偏离应用的核心价值? 信不信由你，专注也是需要规模化的。

最后，还有开发活动。 要组建一个团队，找到合适的人并不容易。 即使我们拥有一支由可靠的开发人员组成的团队，我们也需要考虑他们的职责，以及他们是如何受到功能和用户的影响的。 同样，随着应用开发的进行，我们必须确保适当的资源。

现在我们已经为扩展在前端的作用打下了基础，接下来我们将深入研究细节。 本书的其余部分将把前两章的概念放到 JavaScript 上下文中。 我们知道什么是影响规模的因素，现在我们可以对架构进行权衡。 这是有趣的部分，因为我们可以编写代码。