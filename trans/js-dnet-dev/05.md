# 第五章，使用 Angular 2 和 Web API 开发 ASP.NET 应用程序

在本章中，我们将在 ASP.NET 核心上开发一个完整的应用程序，使用 MVC6 实现 MVC 视图和 Web 服务的 Web API。对于客户端，我们将使用 Angular 2，它是最流行的客户端开发框架之一。Angular 2 是用 TypeScript 编写的，但它提供了用 JavaScript 和 Dart 编写代码的选项。在本章中，我们将使用 TypeScript，因为它遵循 ECMAScript 6 标准，并提供了在 ECMAScript 3、ECMAScript 4 和 ECMAScript 5 标准中构建项目时生成 JavaScript 的规定。TypeScript 是 JavaScript 的超集，大多数东西对两者都是通用的；事实上，TypeScript 提供了一些 JavaScript 中除了 Mozilla Firefox 之外，其他浏览器都无法实现的功能。

本章重点介绍基本概念，并通过示例应用程序介绍 Angular 2 如何与 ASP.NET Core 和 MVC 6 一起使用。

# 打字稿

TypeScript 是微软开发的一种语言，是 JavaScript 的超集。TypeScript 在编译时转换为 JavaScript。Visual Studio 2015 自动将 TypeScript 构建到 JavaScript 文件中，并将其放置在配置有`TypeScript.tsconfig`配置文件的文件夹中。它提供了比 JavaScript 更多的功能，但是开发人员仍然可以使用他们在 JavaScript 中使用的 TypeScript 中的一些类型和对象。但是，TypeScript 生成更干净、更优化的代码，然后由 Angular 2 框架运行。因此，当 TypeScript 编译时，它会生成 JavaScript 并存储一个映射文件来处理调试场景。假设您想从 VisualStudio2015 调试 TypeScript 代码；此映射文件包含源 TypeScript 文件和生成的 JavaScript 文件的映射信息，这些文件在 Angular 页面中运行，断点可以在 TypeScript 文件上设置。

## TypeScript 的编译架构

TypeScript 编译器经过几个阶段来编译 TypeScript 文件和生成 JavaScript 文件。

编译过程从一个预处理器开始，它通过以下引用`/// <reference path=…/>`标记和`import`语句确定需要包含哪些文件。一旦文件被识别，解析器将源代码解析并标记为一个**抽象语法树**（**AST**）。

AST 以由节点组成的树格式表示源代码的语法结构。然后，绑定器通过 AST 节点，生成并绑定符号。为每个命名实体创建一个符号，如果有多个实体具有相同的名称，则它们将具有相同的符号。

符号表示命名实体，并在找到多个声明时合并多个文件。为了表示所有文件的全局视图，需要生成一个程序。程序是类型系统和代码生成的主要入口点。创建程序后，即可创建类型检查器和发射器。

类型检查器是 TypeScript 系统的核心部分，它将多个文件中的所有符号合并到一个视图中，并构建符号表。此符号表包含标识的每个符号的类型，并合并到一个公共符号中。类型检查器包含有关哪个符号属于哪个节点、特定符号的类型等的完整信息。

最后，TypeScript 编译器通过程序使用发射器生成输出文件：`.js`、`.js.map`、`.jxs`或`d.ts`。

## 打字脚本的优点

下面的是将 TypeScript 与 Angular 2 结合使用的一些核心好处。

### JavaScript 超集

TypeScript是编译为 JavaScript 的 JavaScript 类型超集。作为超集的基本优势在于，它提供了许多浏览器尚不支持的 JavaScript 的最新特性。开发人员在应用程序开发过程中使用异步函数、装饰器等功能，然后将这些功能编译成一个 JavaScript 文件，以 ECMAScript 4 或 ECMAScript 3 版本为目标，浏览器可以轻松理解和解释这些版本。

### 对类和模块的支持

Typescript支持`class`、`interface`、`extends`和`implements`关键字。

以下是如何在 TypeScript 中定义类：

```js
class Person {
  private personId: string = '';
  private personName: string = '';
  private dateOfBirth: Date;
  constructor() {}
  getPersonName(): string {
  return this.personName;
  }
  setPersonName(value): void {
  this.personName = value;
}}
```

以下是 JavaScript 中 TypeScript 的传输版本：

```js
var Person = (function () {
function Person() {
  this.personId = '';
  this.personName = '';
}
Person.prototype.getPersonName = function () {
  return this.personName;
};
Person.prototype.setPersonName = function (value) {
  this.personName = value;
};
  return Person;
})();
```

### 静态类型检查

使用 TypeScript 的主要好处是静态类型检查。构建项目时，TypeScript 编译器会检查语义，并在编译时给出错误，以避免运行时错误。例如，以下代码将在编译时给出一个错误：

```js
var name: string
name =2;//give error
```

下面是另一个扩展`Person`类的示例，它在编译类型处给出了一个类型不匹配错误：

```js
class Person {
  constructor(name: string) {
  }
}
class Employee extends Person{
  constructor() {
  super(2); //error 
  }
}
```

### ECMAScript 6 功能支持

在撰写本文时，大多数浏览器仍然不完全支持 ECMAScript 6，但通过 TypeScript，我们可以编写代码并使用 ECMAScript 6 功能。由于 ECMAScript 6 支持向后兼容，我们可以通过 TypeScript 配置文件设置目标版本，该文件根据指定的版本生成 JavaScript。这有助于开发人员使用 ECMAScript 6 功能编写代码，输出 JS 文件将在 ECMAScript 3、ECMAScript 4 或 ECMAScript 5 标准中生成。

### 可选打字

TypeScript支持严格类型化，并在编译类型上验证类型，但使用严格类型化不是强制性的。您甚至可以在不指定其类型的情况下声明变量，并且在赋值时将解析该变量。

### 在 TypeScript 中声明类型

下面是一个示例，它声明了一个没有类型的变量：

```js
private sNo = 1;
private text = 'Hello world';
```

以下是使用类型声明变量的示例：

```js
private sNo: number = 1;
private text: string = 'Hello world';
```

## 打字脚本的核心元素

本节讨论了 TypeScript 的核心要素：

*   声明变量
*   类型
*   类和接口
*   功能
*   遍历器
*   模块和名称空间

### 声明变量

变量声明相当于我们在 JavaScript 中所做的。但是，由于 TypeScript 遵循 ECMAScript 6 标准，因此它还提供了强类型。强类型可以通过命名一个后跟冒号（`:`的变量及其类型来声明。

以下是 JavaScript 中的一个简单变量声明：

```js
var name;
```

它可以在 TypeScript 中声明，如下所示：

```js
var name: string;
```

变量可以在 TypeScript 中初始化，如下所示：

```js
var name: string = "Hello World";    
```

### 类型

TypeScript 中可用的大多数类型都与 JavaScript 类型等效。下表包含所有可用类型的列表，以及使用这些类型的代码段：

<colgroup class="calibre18"><col class="calibre19"> <col class="calibre19"> <col class="calibre19"></colgroup> 
| 

类型

 | 

描述

 | 

代码片段

 |
| --- | --- | --- |
| 数字 | TypeScript 提供一种数字类型，用于保存所有类型的十进制、十六进制、二进制和八进制值。 | 

```js
let decimal: number = 2;
let hex: number = 0x001;
let binary: number = 0b1010;
let octal: number = 0o744;
```

 |
| 一串 | 这和我们在其他语言中使用的一样。字符串值可以用单引号或双引号括起来。 | 

```js
let x: string = 'Hello';
let y: string = "Hello";
```

 |
| 大堆 | TypeScript 支持简单数组，也支持通用数组。 | 

```js
let countries = ['US', 'UK', 'UAE'];
let countries<string> = ['US', 'UK', 'UAE'];
```

 |
| 元组 | 通过元组，我们可以定义元素类型已知的数组。 | 

```js
let val: [string, number, Date];
val = ['Hello World', 10, new Date()];
val[0];//print Hello World
```

 |
| 枚举 | 用于为数值命名。默认情况下，指定的第一个值为`0`，但可以显式设置为任何数字。 | 

```js
enum Status {InProcess, Active, Ready, Success, Error}
let s: Status = Status.Active;
//specify values explicitly
enum Status {InProcess=1, Active=2, Ready=3, Success=4, Error=5}
```

 |
| 任何 | 此类型可用于类型未知且依赖于赋值的情况。 | 

```js
let x: any;
x=['Hello', 1, 2]; //tuple;
x=1; //number
x='Hello World'; //string
```

 |

### 类和接口

以下是定义接口、派生类和接口以及用 TypeScript 编写泛型类的方法。

#### 定义接口

与 C#一样，TypeScript允许您定义可以在 TypeScript 类中实现的接口，并强制实现者类实现接口中定义的所有成员。

以下是在 TypeScript 中定义接口的代码：

```js
interface IShape {
  shapeName: string;
  draw();
}
class TodoService implements IShape  {
  constructor(private http: Http) {
  this.shapeName = "Square";
  }

  shapeName: string;

  draw() {
  alert("this is " + this.shapeName);
  }
}
```

#### 派生类和接口

与 C#一样，类和接口可以通过派生基类或接口来扩展。要扩展任何类，我们可以使用`extends`关键字，对于接口，我们可以使用 implements，如下所示：

```js
interface IPerson {
  id: number;
  firstName: string;
  lastName: string;
  dateOfBirth: Date;
}

interface IEmployee extends IPerson{
  empCode: string;
  designation: string;
}

class Person implements IPerson {
  id: number;
  firstName: string;
  lastName: string;
  dateOfBirth: Date;
}

class Employee extends Person implements IEmployee {
  empCode: string;
  designation: string;
}
```

在前面的代码片段中，我们声明了两个接口，`IPerson`和`IEmployee`。`IPerson`包含`id`、`firstName`、`lastName`、`dateOfBirth`等常用属性，可用于`IEmployee`等所有派生接口。

然后在`Person`类中实现`IPerson`接口，最后从`Person`派生`Employee`类，实现`IEmployee`接口。如果您已经注意到，由于`Person`类已经实现了`IPerson`接口，我们不必再次实现它，只需实现`Employee`类中的`empCode`和`designation`等属性。

#### 泛型类

泛型类用于定义类型为泛型且在调用时确定的特定类。泛型类可以使用`<T>`后跟类名来定义。

下面是一个简单的示例，显示了泛型类进程，它可以按照初始化期间指定的类型工作。`getTypeInfo()`方法将根据初始化对象的类型打印特定消息：

```js
class Process<T>{
  value: T;
  getTypeInfo(){
  if (typeof this.value == "string")
    console.log("Type is a string");
  else if (typeof this.value == "number")
    console.log("Type is a number");
  else alert("type is unknown");

  }
}

let pString = new Process<string>();
pString.getTypeInfo(); //print Type is a string
let pNumber = new Process<number>();
pNumber.getTypeInfo(); //print Type is a number
```

### 功能

函数的定义方式与 JavaScript 相同。TypeScript 支持命名函数和匿名函数。在 TypeScript 中，函数参数可以是类型参数，如下所示：

```js
function concat(x: string, y: string): string {
  return x +" "+ y; 
}
```

函数也可以有可选参数，可以使用`(?)`进行声明，如下图：

```js
function concat(x: string, y: string, z?: string): string {
  return x + " " + y + " " + z; 
}
```

使用此选项，我们可以通过传递两个或三个参数来调用函数，因为第三个参数是可选的。

#### 泛型函数

TypeScript允许您定义泛型函数，它接受任何类型的参数或返回类型。泛型函数可以通过在函数名后指定`<T>`来定义，如下代码所示，参数或返回的类型也可以是泛型的，并引用相同的`T`类型。这对于定义一个接受所有类型参数并按预期工作的特定函数非常有用。以下示例显示了基于连接或添加的参数类型的流程函数：

```js
function process<T>(x: T, y: T): string{
  if (typeof x == "string")
  return x + " " + y;
  else if (typeof x == "number")
  return "Sum is: "+ x + y ;
  else 
  return "Type in unknown";
}
```

### 迭代器

除了和`while`等标准循环之外，TypeScript 还提供了两种类型的 for 语句`for..of`和`for..in`。这两条语句都在集合上迭代。两者的区别在于，`for..of`语句返回对象的键，而`for..in`返回值：

```js
countries = ['USA', 'UK', 'UAE'];  
  //this loop will display keys 0, 1, 2
for (let index in this.countries) {
  console.log(index);
}
//this loop will display values USA, UK, UAE
for (let index of this.countries) {
  console.log(index);
}
```

### 模块和名称空间

ECMAScript 6引入了模块的概念。模块可以被认为是具有自己作用域的逻辑容器。在模块内声明的任何类、变量或方法的作用域都在其自己的容器内，并且只有在显式允许的情况下，其他模块才能访问它。在 TypeScript 中，任何包含顶级导入或导出的文件都被视为模块。模块使用模块加载器相互导入，在运行时，模块加载器负责加载其中定义的模块的所有依赖项。模块可以使用`export`关键字导出，其他模块可以使用`import`关键字导入。

以下是在 TypeScript 中定义和导出模块的示例：

```js
//BaseManager.ts
export class BaseManager{
}
```

要在其他区域使用该模块，需要使用`import`关键字，如下所示：

```js
//ServiceManager.ts
export class ServiceManager extends BaseManager{
}
```

模块可以使用`import`关键字导入。导入任何模块时，必须使用`import`关键字，后跟括号`{}`中的类名，后跟包含该类的实际文件名。例如，下面的代码显示了将`ServiceManager`导入`Main.ts`的方式：

```js
//Main.ts
import {ServiceManager} from "./ServiceManager"
```

我们还可以为该类提供一个友好的名称，如下所示：

```js
//Main.ts
import {ServiceManager as serviceMgr} from "./ServiceManager"
```

另一方面，名称空间是对类、方法等进行分类的逻辑模块。与 C#一样，它们可以通过使用`namespace`关键字来定义。一个名称空间可以拆分为不同的 TypeScript 文件，这为开发人员提供了将特定文件分类到单个名称空间的便捷方法。以下示例显示了将 TypeScript 文件分类为单个命名空间并使用它们的方法：

```js
//PersonManager.ts
namespace BusinessManagers{
  export class PersonManager{}
}
//SecurityManager.ts
namespace BusinessManagers{
  export class SecurityManager(){
}
}
//main.ts
/// <reference path="personmanager.ts" />
  ///  <reference path="SecurityManager.ts" />
personObj = new BusinessManagers.PersonManager();
securityObj =new BusinessManagers.SecurityManager();
```

如果您注意到，我们使用了一个三重斜杠指令，它用于在执行 TypeScript 文件中的代码之前引用依赖文件。因此，由于这些文件存在于其他地方，我们必须在前面的代码中显式引用它们。

总而言之，名称空间是一种比模块更好的方法，因为它们通过提供友好的名称对文件进行逻辑分类，并允许开发人员在处理中大型项目时正确地构造代码。

如果名称空间不友好，我们还可以使用`import`关键字为其提供缩写名称，如下所示：

```js
namespace BusinessManagers {
  export class PersonManager {

  }
}

import mgr = BusinessManagers;
let personObj = new mgr.PersonManager();

To LC: Apply code to:
"namespace BusinessManagers {
  export class PersonManager {

  }
}

import mgr = BusinessManagers;
let personObj = new mgr.PersonManager();
```

这就结束了 TypeScript 的核心主题。有关 TypeScript 的更多信息，请参考[http://www.typescriptlang.org/](http://www.typescriptlang.org/) 。

# 角度 2 介绍

Angular 2 是用于构建 web 应用程序的客户端框架。它在移动和网络平台上都非常灵活。使用 Angular 的基本优点是它遵循 ECMAScript 6 标准，开发人员可以使用**普通旧 JavaScript 对象**（**POJO**绑定数据）进行面向对象编程、定义类和接口、实现类以及定义数据结构。性能方面的另一大优势是单向数据流。与 Angular 1.x 不同，Angular 2 提供了进行双向数据绑定或单向数据绑定的选项。在某些情况下，单向绑定有助于提高性能。例如，在提交表单时，与控件的双向绑定可能会过度使用。

## Angular 2 建筑

Angular2 由许多组件组成。每个组件都可以通过选择器（例如`<my-app> </my-app>`）或路由模块绑定到页面。每个组件都有一个选择器、模板 HTML 或模板引用链接、指令、提供程序和一个控制器类，这些类的属性和方法可以在关联视图中访问。当 web 应用程序首次启动时，`System.import`加载应用程序的主组件，从而引导根组件。以下是引导 Angular 应用程序的主要组件示例：

```js
//Loading module through Import statement
Import {AppComponent} from 'path of my component'
bootstrap(AppComponent, [Providers]);
```

提供程序可以在方括号内定义。有各种各样的提供者，我们将在后面的章节中讨论。

此`bootstrap`对象在`angular2/platform/browser`中，可以通过`import`命令导入到 TypeScript 文件中：

```js
import {bootstrap} from 'angular2/platform/browser';
```

此`bootstrap`对象将角度定向以加载其中定义的组件。加载组件时，将评估为组件定义的所有属性或元数据。每个组件都应该有`@Component`注释、一些用于定义组件元数据的属性，以及一个或多个称为组件控制器的类，这些类包含可由`@Component template`或`templateUri`属性中定义的模板访问的属性和方法。

下面是一个样本`app.component.ts`，它包含一个选择器、一个模板和一个类`AppComponent`：

```js
//app.component.ts
import { Component, View} from 'angular2/core';
  import {bootstrap} from 'angular2/platform/browser';
  @Component({
  selector: "my-app",
  template: `<p>This is a first component</p>`,
  })  
  class AppComponent  {
  }
  bootstrap(AppComponent);
```

### 部件生命周期事件

当组件初始化时，它会经历几个事件，并且有一个非常结构化的生命周期过程。我们可以实现这些事件来执行特定的操作。下表显示了我们可以在组件控制器类中使用的事件列表：

<colgroup class="calibre18"><col class="calibre19"> <col class="calibre19"></colgroup> 
| 

事件

 | 

描述

 |
| --- | --- |
| `ngOnInit()` | 组件初始化并执行控制器构造函数后调用。 |
| `ngOnDestroy()` | 用于组件处置时的资源清理。 |
| `ngDoCheck()` | 用于覆盖指令的默认更改检测算法。 |
| `ngOnChanges(changes)` | 当任何组件选择器属性值被修改时，被调用。（选择器的自定义属性可以通过输入定义。） |
| `ngAfterContentInit()` | 当指令的内容被初始化时，被调用。（指令将在后面定义。） |
| `ngAfterContentChecked()` | 每次检查指令内容时都会调用它。 |
| `ngAfterViewInit()` | 当视图完全初始化时调用。 |
| `ngAfterViewChecked()` | 它是在每次检查组件视图时调用的。 |

### 模块

模块表示包含类、接口等的容器，用于导出功能，因此可以使用`import`语句导入其他模块。例如，这里是`math.ts`，用于执行不同的算术运算：

```js
//math.ts
import {Component} from 'angular2/core';
@Component({

})
export class MathService {
  constructor() {
  }
  public sum(a: number, b: number): number {
  return a + b;
  }
  public subtract(a: number, b: number): number {
  return a - b;
  }
  public divide(a: number, b: number): number {
  return a / b;
  }
  public multiply(a: number, b: number): number {
  return a * b;
  }
}
```

### 组件

组件是注释的组合，用于定义元数据属性和包含实际代码的关联控制器类，例如类构造函数、方法和属性。`@Component`注释包含以下元数据属性：

```js
@Component({
  providers: string[],
  selector: string,
  inputs: string[],
  outputs: string[],
  properties: string[],
  events: string[],
  host: { [key: string]: string },
  exportAs: string,
  moduleId: string,
  viewProviders: any[],
  queries: { [key: string]: any },
  changeDetection: ChangeDetectionStrategy,
  templateUrl: string,
  template: string,
  styleUrls: string[],
  styles: string[],
  directives: Array < Type | any[] >,
  pipes: Array < Type | any[] >,
  encapsulation: ViewEncapsulation
})
```

## 角度 2 组件的核心特性

当定义组件时，我们可以指定各种属性，如前所述。在这里，我们将看到创建 Angular 2 组件时经常需要的一些核心属性：

*   模板和选择器
*   投入和产出
*   指令
*   提供者

### 模板和选择器

下面的实例包含组件类中定义的模板和选择器。当点击按钮时，它将调用`logMessage()`方法，该方法在`<p>`元素中打印消息。如果您注意到，我们没有在类中使用`export`关键字，因为我们已经在同一个文件中引导了该组件，并且该组件不需要在其他任何地方引用：

```js
import { Component, View } from 'angular2/core';
import {bootstrap} from 'angular2/platform/browser';
@Component({
  selector: "my-app",
  template: "<p> {{message}}</p><button (click)='logMessage()'>Log Message</button>"
})
class AppComponent {
  logMessage() {
    this.message = "Hello World";
  }
  message: string = "";
}
bootstrap(AppComponent);
```

如果使用 ASP.NET 项目，应用程序选择器可以在 HTML 或`index.cshtml`页面的任何位置使用，模板将在其中呈现。以下是使用自定义标记`my-app`的示例：

```js
<html>
<body>
  <my-app></my-app>
</body>
</html>
```

一旦页面运行，它将使用以下生成的源呈现输出：

```js
<html>
<body>
  <p>Hello World</p>
  <button (click)='logMessage()'>Log Message</button>
</body>
</html>
```

### 输入和输出

输入允许开发人员在组件层次结构中向下指定映射到组件类的某些属性的自定义属性，而输出用于定义组件上的自定义事件处理程序，这些事件处理程序可以在组件层次结构中向上提升。简而言之，输入用于将数据从父组件发送到子组件，而输出用于调用子组件到父组件的事件。在上一个示例中，我们看到了如何使用选择器，并提供了组件类的所有成员可用的情况下，呈现关联的模板来代替选择器。在某些情况下，我们必须在自定义选择器中指定一些属性来传递值以处理特定操作。例如，我们可能需要前面的`<my-app>`标记中的某些属性来指定日志记录类型，例如登录到开发人员的控制台或显示警报消息。

#### 使用输入

在这个示例中，我们将创建两个输入属性，`logToConsole`和`showAlert`。我们可以在`@Component`注释中定义输入属性。以下代码段是`child.component.ts`中定义的单独组件，包含选择器作为子级；该模板显示子标记中指定的`logToConsole`和`showAlert`属性的布尔值。输入包含将定义为子标记属性的字符串变量列表：

```js
//child.component.ts
import { Component} from 'angular2/core';
@Component({
  selector: 'child',
  template: `<div> Log to Console: {{logToConsole}}, Show Alert: {{showAlert}} <button (click)="logMessage()" >Log</button> </div>`,
  inputs: ['logToConsole', 'showAlert'],
})
```

下面是包含`logToConsole`和`showAlert`布尔变量的`ChildComponent`类。这些变量实际上包含通知标记提供的值。最后，我们有`logMessage()`方法，该方法将在按钮点击事件中调用，并在开发人员控制台上记录消息，或根据层次结构中父组件设置的值显示警报消息：

```js
export class ChildComponent {
  public logToConsole: boolean;
  public showAlert: boolean;

  logMessage(message: string) {
    if (this.logToConsole) {
      console.log("Console logging is enabled");
    }
    if (this.showAlert) {
      alert("Showing alert message is enabled");
    }

  }
}
```

在`app.component.ts`文件中，我们定义了主`AppComponent`，我们可以使用子选择器，如下代码所示。定义子选择器时，我们可以设置在`ChildComponent`、`logToConsole`和`showAlert`中定义的自定义输入值。这样，父组件可以通过输入为子组件指定值。以下是`AppComponent`的完整代码：

```js
//app.component.ts
import { Component, View } from 'angular2/core';
import {bootstrap} from 'angular2/platform/browser';
import {ChildComponent} from './child.component';

@Component({
  selector: "my-app",
  template: `<child [logToConsole]=true [showAlert]=true></child>`,
  directives: [ChildComponent]
})
export class AppComponent {
}
bootstrap(AppComponent);
```

### 提示

当使用模板定义 HTML 时，我们可以使用反勾号（```js，而不是双引号（`''`）或单引号（`'`），如上例所示。这允许 HTML 内容跨越多行。

#### 使用输出

输出用于从组件层次结构中的子组件调用父组件上的事件。我们将修改前面的示例，并在`ChildComponent`中添加 outputs 事件，然后使用`ChildComponent`选择器将其注册到`AppComponent`中。

以下是修改后的`ChildComponent`代码段：

```
  //child.component.ts
import { Component, EventEmitter, Output} from 'angular2/core';
@Component({
  selector: 'child',
  template: `<div> Log to Console: {{logToConsole}}, Show Alert: {{showAlert}}  <button (click)="logMessage()" >Log</button> </div>`,
  inputs: ['logToConsole', 'showAlert']
})
export class ChildComponent {
  public logToConsole: boolean;
  public showAlert: boolean;
  @Output() clickLogButton = new EventEmitter();

  logMessage(message: string) {
    this.clickLogButton.next("From child");
  }
}
```js

`@Output`属性将`clickLogButton`列为`ChildComponent`可以发射的自定义事件，其父`AppComponent`将接收该事件。

我们在`import`声明中添加了。`EventEmitter`是一个内置类，随 Angular 一起发布，并提供定义和触发自定义事件的方法。一旦`logMessage()`方法被执行，它将执行`ChildComponent`中的`clickLogButton.next()`方法，最终调用`AppComponent`中注册的事件。

我们在`AppComponent`中增加了`clickLogButton`，如下代码所示。在 Angular 2 中，我们可以通过在括号`()`中指定事件名称，然后在引发事件时调用方法来指定事件。这是事件的注册方式。此处，`logMessage`是`AppComponent`中定义的本地方法：

```
(clickLogButton)="logMessage($event)"

Here is the code snippet for AppComponent:

  //app.component.ts 
import { Component, View } from 'angular2/core';
import {bootstrap} from 'angular2/platform/browser';
import {ChildComponent} from './child.component';

@Component({
  selector: "my-app",
  template: `<child [logToConsole]=true [showAlert]=true (clickLogButton)="logMessage($event)" ></child>`,
  directives: [ChildComponent]
})
export class AppComponent {

  logMessage(value) {
    alert(value);
  }
}
bootstrap(AppComponent);
```js

`logMessage`方法是从`ChildComponent`引发事件时将调用的方法。

### 指令

指令是自定义标记，在运行时呈现 HTML，但将呈现内容封装在指令本身中。我们可以将其与 ASP.NET 中的标记帮助程序联系起来。有三种指令、组件、结构指令和属性指令：

*   **组件**：带模板的指令。
*   **结构指令**：它是添加或删除 DOM 元素的指令。Angular 提供了一些内置的结构指令。像`ngIf`、`ngSwitch`和`ngFor`这样的指令都是结构指令。
*   **属性指令**：它改变任何 DOM 元素的外观。

#### 创建一个简单的 Hello World 指令

指令可以在创建组件时以简单的方式创建，并且可以通过其选择器标记在调用组件中引用。

以下是`HelloWorldComponent`的一个示例，它定义了一个简单的指令，以标题格式显示“`Hello world"`消息：

```
//helloworld.component.ts
import {Component} from 'angular2/core';

@Component({
  selector: "helloworld",
  template: "<h1>Hello world</h1>"
})

export class HelloWorldComponent {

}
```js

以下示例是使用此指令的组件。当使用任何指令时，必须首先通过`import`语句导入，然后需要设置`@Component`元数据属性以在关联模板中访问它：

```
import { Component, View, provide, Inject } from 'angular2/core';
  import {bootstrap} from 'angular2/platform/browser';
  import {HelloWorldComponent} from './helloworld.component';

  @Component({
    selector: "my-app",
    template: `<helloworld></helloworld>`,
    directives: [, HelloWorldComponent],
  })
  export class AppComponent{

  }
  bootstrap(AppComponent);
```js

本指令可在页面上使用，如下所示：

```
<helloworld></helloworld>
```js

### 结构指令

结构指令可用于添加或删除 DOM 元素。例如，我们可以通过`*ngFor`将国家列表添加为表格，如下代码所示，并通过`*ngIf`指令隐藏或取消隐藏 div：

```
  <div *ngIf="display">
    <table>
      <thead>
        <tr>
          <th>
            Country
          </th>
          <th>
            Currency
          </th>
        </tr>
      </thead>
      <tbody *ngFor="#country of countries">
        <tr><td>{{country.CountryName}}</td><td>{{country.Currency}}</td></tr>
      </tbody>
    </table>
  </div>
```js

这里是后端`countries.component.ts`，它使用 HTTP 模块调用 ASP.NET Web API 服务。它返回一个分配给`countries`数组的国家列表。`display`默认值设置为`true`，生成表格。通过将`display`值设置为`false`，将不会生成表格：

```
///<reference path="../../node_modules/angular2/typings/browser.d.ts" />
import {Component} from 'angular2/core';
import {Http, Response} from 'angular2/http';

@Component({
  selector: 'app',
  templateUrl: 'Countries'
})
export class TodoAppComponent {
  countries = [];
  display: boolean = true;
  //constructor
  constructor(private http: Http) {
  }

  //Page Initialized Event Handler
  ngOnInit() {
    this.getCountries();
  }
  getCountries() {
    this.http.get("http://localhost:5000/api/todo").map((res: Response) => res.json())
      .subscribe(data => {
        this.countries = data;
      },
      err => console.log(err),
      () => console.log("done")
      );
  }

}
```js

这就是如何在 Angular 2 中使用结构指令。在下一章中，我们将开发一个示例应用程序，并讨论使用 Angular 2 生成 HTTP`GET`和`POST`请求的每个工件。

### 属性指令

属性指令需要构建一个带有`@Directive`注释的控制器类，并定义一个选择器来标识与其关联的属性。在下面的示例中，我们将开发一个简单的`myFont`指令，当文本应用于任何页面元素时，该指令将文本更改为斜体。以下是`font.directive.ts`文件：

```
import { Directive, ElementRef, Input } from 'angular2/core';
@Directive({ selector: '[myFont]' })
export class FontDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.fontStyle = 'italic';
  }
}
```js

对于页面上的每个匹配元素，Angular 将创建一个新实例并将`ElementRef`注入构造函数。`ElementRef`是通过元素的`nativeElement`属性直接访问元素，并访问其他属性的服务。在前面的代码片段中，我们将应用`myFont`指令的元素的字体样式更改为斜体。

在页面级别，它可以按如下方式使用：

```
<p myFont>myFont is an Attribute directive</p>
```js

### 供应商

提供者用于注册通过 Angular 2 的依赖注入框架实例化的类型。初始化组件时，Angular 将创建一个依赖项注入器，该注入器将注册 providers 数组中指定的所有类型。然后在构造函数级别，如果提供程序数组中定义了任何类型，那么它将被初始化并注入到构造函数中。

下面的例子是`MathComponent`，它将被注入到主应用组件构造函数中，并调用 sum 方法将两个数字相加：

```
//math.component.ts
import { Component } from 'angular2/core';
@Component({})

export class MathComponent {

  public sum(a: number, b: number) : number{
    return a + b;
  }
  public divide(a: number, b: number): number {
    return a / b;
  }
  public subtract(a: number, b: number): number {
    return a - b;
  }
  public multiply(a: number, b: number): number {
    return a * b;
  }

}
```js

下面的例子是`AppComponent`，展示了如何导入`math`组件，然后定义提供者并在构造函数级别注入它：

```
//app.component.ts
import { Component, View } from 'angular2/core';
import {bootstrap} from 'angular2/platform/browser';
import {MathComponent} from './servicemanager.component';
  @Component({
    selector: "my-app",
    template: "<button (click)="add()" >Log</button>",
    providers: [MathComponent]
  })  
  export class AppComponent  {
    obj: MathComponent;
    constructor(mathComponent: MathComponent) {
      this.obj = mathComponent;
    }
    public add() {
      console.log(this.obj.sum(1, 2));
    }
  }
  bootstrap(AppComponent);
```js

其他原语类型也可以使用 InjectAngular 模块以稍微不同的方式注入。我们还可以使用`provide`关键字定义一个类型，该关键字包含一个键和一个值：

```
providers: [provide('Key', {useValue: 'Hello World'})]
```js

在提供程序中定义类型时，也可以使用前面的语法，如下所示：

```
providers: [provide(MathComponent, {mathComponent: MathComponent })]
```js

使用`provide`关键字定义`providers`的主要好处之一是在测试时。在测试应用程序时，我们可以用模拟或测试组件替换实际组件。例如，假设我们有一个类调用某个 SMS 服务来使用某个付费网关发送 SMS，在测试周期中，我们不希望使用生产 SMS 网关组件，而是希望有一些自定义测试组件，只将 SMS 插入本地数据库。在这种情况下，我们可以关联一些模拟类，例如`SMSTestComponent`，来执行测试场景。

下面的示例将字符串值注入构造函数。我们需要按照下面代码中的说明添加注入模块，然后使用`@Inject`注入与该键关联的值：

```
  //app.component.ts
import { Component, View, provide, Inject } from 'angular2/core';
  import {bootstrap} from 'angular2/platform/browser';
  import {MathComponent} from './servicemanager.component';
  @Component({
    selector: "my-app",
    template: `button (click)="logMessage()" >Log</button>`,
    providers: [MathComponent, provide('SampleText', {useValue: 'Sample Value'})]
  })
  export class AppComponent{
    obj: MathComponent;
    Val: string;
    constructor(mathComponent: MathComponent, @Inject('SampleText') value) {
      this.obj = mathComponent;
      this.Val = value;
    }

  public logMessage() {
    alert(this.kVal);
  }
  }
  bootstrap(AppComponent);
```js

## 角度依赖注入

Angular链接依赖项注入并将组件注入子组件（如果它们在父组件的 providers 数组中定义）。但是，子组件可以在其自己的提供程序数组中定义相同的组件。组件的范围在组件链中移动。但是，`viewproviders`数组中定义的组件不会被层次链中的子组件注入或继承。

让我们使用一个简单的例子，其中包含了一个主要的组成部分：在 ORT T0 中。`ChildComponent`是父组件的子组件，而`MathComponent`用于父组件和子组件。如果您注意到，在下面的代码片段中，我们没有在`ChildComponent`的`providers`数组中指定`MathComponent`，并且根据`ParentComponent`中的定义，它已经被角度依赖注入模块注入。

以下是`AppComponent`（父项）的代码片段：

```
  //app.component.ts
  import { Component} from 'angular2/core';
  import {bootstrap} from 'angular2/platform/browser';
  import {MathComponent} from './servicemanager.component';
  import {ChildComponent} from './child.component';
  @Component({
    selector: "my-app",
    template: `<button (click)="callChildComponentMethod()">Log</button>`,
    providers: [MathComponent, ChildComponent]
  })
  export class AppComponent  {
    childObj: ChildComponent;
      constructor(childComponent: ChildComponent) {
      this.childObj = childComponent;

  }
    public callChildComponentMethod() {
      this.childObj.addNumbers(1, 2);   

    }
  }
  bootstrap(AppComponent);
```js

下面是`MathComponent`的代码片段，其中包含一些基本的算术运算：

```
//math.component.ts
import { Component } from 'angular2/core';
@Component({})
export class MathComponent {

  public sum(a: number, b: number) : number{
    return a + b;
  }
  public divide(a: number, b: number): number {
    return a / b;
  }
  public subtract(a: number, b: number): number {
    return a - b;
  }
  public multiply(a: number, b: number): number {
    return a * b;
  }
}
```js

最后，这里是`ChildComponent` 代码，在`providers`数组中没有定义`MathComponent`提供程序：

```
//child.component.ts
import {Component} from 'angular2/core';
import {MathComponent} from './servicemanager.component';
@Component({
  selector: 'child-app',
  template: '<h1>Hello World</h1>'
})
export class ChildComponent {
  obj: MathComponent;
  constructor(mathComponent: MathComponent) {
    this.obj = mathComponent;
  } 
  public addNumbers(a: number, b: number) {
    alert(this.obj.sum(a, b));
  }
}
```js

## 角度布线

在处理大型应用程序时，路由起着的重要作用。路由用于导航到不同的页面。路由可通过三个步骤定义：

1.  在任何组件级别定义`@RouteConfig`：

    ```
    @RouteConfig([
      { path: '/page1', name: 'Page1', component: Page1Component, useAsDefault: true },
      { path: '/page2', name: 'Page2', component: Page2Component }]
    )
    ```js

2.  在锚 HTML 标记上使用`[routerLink]`属性，并指定`@RouteConfig`中配置的路由名称。
3.  最后，添加`<router-outlet>`标记以呈现当前导航路线上的页面。

下面的示例包含两个组件`Page1Component`和`Page2Component`，主`AppComponent`的路由定义如下：

```
//app.component.ts
import {Component} from 'angular2/core';
import {RouteConfig, ROUTER_DIRECTIVES} from 'angular2/router';
import {Page1Component} from './page1.component';
import {Page2Component} from './page2.component';

@Component({
  selector: "my-app",
  template: `{{name}}
    <a [routerLink]="['Page2']">Page 2</a>
    <router-outlet></router-outlet>`,
  directives: [ROUTER_DIRECTIVES],
})
@RouteConfig([
  { path: '/', name: 'Page1', component: Page1Component, useAsDefault:true },
  { path: '/page2', name: 'Page2', component: Page2Component }]
)
export class AppComponent {
}
```js

在前面的代码中，我们首先从`angular2/router`中导入`RouteConfig`和`ROUTER_DIRECTIVES`，然后为第 1 页和第 2 页定义`RouteConfig`。在内联模板中，我们放置了锚标记，并为第 2 页定义了路由名称。当应用程序运行时，页面 1 被设置为根路径`/`上的默认页面，因此页面 1 内容将显示在路由器出口的位置。当用户点击`Page2`链接时，第 2 页内容将呈现在同一位置。

以下是`page1.component.ts`的代码：

```
//page1.component.ts
import {Component} from 'angular2/core';
@Component({
  template:'<h1>Page1 Content</h1>'
})
export class Page1Component {
}
```js

以下是`page2.component.ts`的代码：

```
//page2.component.ts
import {Component} from 'angular2/core';

@Component({
  template: '<h1>Page2 Content</h1>'
})

export class Page2Component {
}
```js

# 在 ASP.NET 内核中开发一个待办应用程序

我们已经学习了 Angular 2 的核心功能以及如何用 TypeScript 编写程序。现在是时候使用 Angular 2 和 ASP.NET 内核开发一个简单的待办应用程序。ASP.NET Core 是 Microsoft 最新的 web 开发平台，它比以前的 ASP.NET 版本更加优化和模块化。它提供了一个选项，可以使用机器范围的.NET Framework，或者一个新的.NET 内核，它可以逐个应用运行，甚至在发布的 web 应用程序文件夹中包含框架二进制文件。有了新的 ASP.NET 内核，我们就不需要依赖 IIS 来运行我们的应用程序，而且还提供了一些其他服务器来使用 Kestrel 跨平台运行。有关 ASP.NET 核心的更多信息，请参阅[http://docs.asp.net](http://docs.asp.net) 。

我们将通过一步一步的教程，学习如何使用待办事项应用程序。以下屏幕截图显示主页的快照。一旦用户登录，它将显示所有可用待办事项的列表。用户可以通过点击**创建待办事项**按钮并删除现有待办事项来添加新的待办事项。在本章中，我们将不介绍安全身份验证和授权模块，而是重点介绍如何将 Angular 2 与 ASP.NET Core 结合使用：

![Developing a to-do application in ASP.NET Core](../images/00040.jpeg)

在这个应用程序中，我们将有三个项目。`TodoWebApp`调用`TodoServiceApp`，Web API 使用`Common`保存实体模型。下图显示了如何开发这三个项目以及如何配置和使用 Angular 2：

![Developing a to-do application in ASP.NET Core](../images/00041.jpeg)

## 创建一个公共项目

`Common`项目持有实体框架将用于创建数据库的实体。我们将在稍后的 Web API 项目中引用此程序集：

1.  Create a .NET Core Class Library project:

    ![Creating a Common project](../images/00042.jpeg)

2.  Add a new folder, `Models`, and add a `TodoItem` class as follows:

    ```
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;

    namespace Common
    {
      public class TodoItem
      {
        public int Id { get; set; }
        public string Title { get; set; }
        public string Description { get; set; }
        public DateTime DueDateTime { get; set; }
        public int UserId { get; set; }
      }
    }
    ```js

    前面的`TodoItem`类包含`Id`（主键）和`Title`、`Description`、`DueDateTime`以及为特定用户保存到 dos 的`UserID`。

## 创建 ToDoService 应用程序项目

在这个项目中，我们将创建一个 web API，该 API 将引用包含`TodoItem`POCO 模型的`Common`项目。在本项目中，我们将公开服务并创建一个数据库存储库，使用 Entity Framework Core 在 Microsoft SQL Server 数据库中执行**创建、读取**、**更新**、**和删除**（**CRUD**操作：

1.  选择 ASP.NET 核心模板创建新的 Web API 项目。Web API 和 ASP.NET MVC 已经合并到一个统一的框架中，因此 Web API 没有单独的项目模板。在本例中，我们将使用 ASP.NET 核心项目模板中可用的空项目模型。
2.  打开`project.json`并添加对我们`Common`组件的引用：

    ```
    "dependencies": {
      "Microsoft.NETCore.App": {
        "version": "1.0.0-rc2-3002702",
        "type": "platform"
      },
      "Microsoft.AspNetCore.Server.IISIntegration": "1.0.0-rc2-final",
      "Microsoft.AspNetCore.Server.Kestrel": "1.0.0-rc2-final",
      "Common": "1.0.0-*"
    }
    ```js

### 在 Web API 项目中启用 MVC

为了启用 MVC 项目，我们必须在`ConfigureServices`方法中调用`AddMvc()`，在`Configure`方法中调用`UseMvc()`：

1.  在`project.json`：

    ```
    "Microsoft.AspNetCore.Mvc": "1.0.0-rc2-final"
    ```js

    中添加 MVC 包
2.  从`ConfigureServices`方法调用`AddMvc()`：

    ```
    public void ConfigureServices(IServiceCollection services)
      {
        services.AddMvc();
      }
    ```js

3.  最后，从`Configure`方法调用`UseMvc()`：

    ```
    public void Configure(IApplicationBuilder app)
      {
        app.UseMvc();
      }
    ```js

### 安装实体框架

以下是安装实体框架的步骤：

1.  增加两个实体框架组件`Microsoft.EntityFrameworkCore.SqlServer`和`Microsoft.EntityFrameworkCore.Tools`，如下代码所示：

    ```
      "dependencies": {
      "Microsoft.NETCore.App": {
        "version": "1.0.0-rc2-3002702",
        "type": "platform"
      },
      "Microsoft.AspNetCore.Server.IISIntegration": "1.0.0-rc2-final",
      "Microsoft.AspNetCore.Server.Kestrel": "1.0.0-rc2-final",
      "common": "1.0.0-*",
      "Microsoft.AspNetCore.Mvc": "1.0.0-rc2-final",
      "Microsoft.EntityFrameworkCore.SqlServer": "1.0.0-rc2-final",
      "Microsoft.EntityFrameworkCore.Tools": {
        "type": "build",
        "version": "1.0.0-preview1-final"
      }
    }
    ```js

### 添加 AppSettings 以存储连接字符串

ASP.NET Core 为存储应用程序设置提供了各种选项。默认配置文件现在是`appsettings.json`，它以 JSON 格式存储数据。但是，也有其他方法可用于以环境变量、XML 和 INI 格式存储数据。在本项目中，我们将连接字符串存储在`appsettings.json`文件中：

1.  添加 ASP.NET 配置文件`appsettings.json`并指定如下连接字符串：

    ```
    {
      "Data": {
        "DefaultConnection": {
          "ConnectionString": "Data Source =.; Initial Catalog = tododatabase; Integrated Security = True;MultiSubnetFailover = False; "
        }
      }
    }
    ```js

2.  在`project.json:`

    ```
    "Microsoft.Extensions.Configuration.Json": "1.0.0-rc2-final",
    "Microsoft.Extensions.Options.ConfigurationExtensions": "1.0.0-rc2-final",
    ```js

    中增加以下包

### 在启动类中配置 AppSettings

ASP.NET 核心新的配置系统基于`System.Configuration`。为了在我们的项目中使用设置，我们将在`Startup`类中实例化一个`Configuration`对象，并使用`Options`模式访问各个设置。

`Options`模式将任何类转换为设置类，然后我们可以通过 ASP.NET 的内置依赖注入将该类注入控制器。通过`options`类，开发人员可以访问设置键和值，如下步骤所示：

1.  In the `Startup` class constructor, we will add the `appsettings.json` file using the `ConfigurationBuilder` object. `ConfigurationBuilder` allows a provision to add different providers and have a build method that builds the configuration stores in different providers and returns the `IConfigurationRoot` instance:

    ```
    public Startup()
      {
        // Set up configuration sources.
        var builder = new ConfigurationBuilder()
          .AddJsonFile("appsettings.json")
        Configuration = builder.Build();
      }

      public IConfigurationRoot Configuration { get; set; }
    ```js

    ### 提示

    如果多个提供者具有相同的密钥，则将使用`ConfigurationBuilder`中指定的最后一个密钥。

2.  现在我们可以使用`Configuration`属性访问连接字符串，如下所示：

    ```
    Configuration["Data:DefaultConnection:ConnectionString"];
    ```js

### 在 Web API 中增加数据访问

在本节中，我们将添加一个`TodoContext`和`TodoRepository`类来执行 CRUD 操作：

1.  添加新文件夹`DataAccess`，并添加`TodoContext`类，该类将从`DbContext`类派生。这是用于创建数据库的主要`TodoContext`类实体框架：

    ```
    using Common;
    using Microsoft.Data.Entity;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;

    namespace TodoServiceApp.DataAccess
    {
      public class TodoContext : DbContext
      {
        public DbSet<TodoItem> TodoItem { get; set; }
      }
    }
    ```js

2.  我们现在必须重写`OnConfiguring()`方法并调用`DbContextOptionsBuilder`对象的`UseSqlServer()`方法。每次初始化`Context`对象并配置指定的选项时，都会调用`OnConfiguring()`方法。`UseSqlServer()`方法采用`appsettings.json` 文件中定义的连接字符串，我们在`Startup`类中配置了该字符串。现在我们要将 appsettings 对象注入这个类。为此，我们将使用`Options`模式。根据选项模式，我们不应该直接使用我们在`Startup`类中定义的`Configuration`属性，相反，我们将创建一个自定义 POCO 类，该类包含我们在应用程序设置文件中拥有的相同密钥，并重载默认`TodoContext`构造函数，该构造函数接受`IOptions<T>`，其中`T`是我们的自定义 POCO 应用程序设置类。
3.  由于连接字符串是在嵌套对象中定义的，因此我们的`Data`类如下：

    ```
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;

    namespace TodoServiceApp
    {
      public class Data
      {
        public DefaultConnection DefaultConnection { get; set; }
      }

      public class DefaultConnection {

        public string ConnectionString { get; set; } 
      }
    }
    ```js

4.  在的`Startup`类中，我们将调用`services.Configure()`方法，用`appsettings.json`文件中指定的键填充此`Data`对象，并将其注入我们将要创建的存储库中。
5.  创建一个包含`ITodoRepository`接口及其实现`TodoRepository`的`TodoRepository`类。此类将使用`TodoContext`对象执行数据库操作。下面是`TodoRepository`类的代码片段：

    ```
    using Common;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using TodoServiceApp.DataAccess;

    namespace TodoServiceApp.Repository
    {
      public interface ITodoRepository
      {
        void CreateTodo(TodoItem todoItem);
        void DeleteTodo(int todoItemId);
        List<TodoItem> GetAllTodos(int userId);
        void UpdateTodo(TodoItem todoItem);
      }

      public class TodoRepository : ITodoRepository
      {
        private TodoContext context;
        public TodoRepository()
        {
          context = new TodoContext();
        }
        public List<TodoItem> GetAllTodos(int userId)
        {
          return context.TodoItems.ToList();
        }
        public void CreateTodo(TodoItem todoItem)
        {
          context.TodoItems.Add(todoItem);
          context.SaveChanges();
        }
        public void DeleteTodo(int todoItemId)
        {
          var item = context.TodoItems.Where(i => i.Id == todoItemId).FirstOrDefault();
          context.Remove(item);
          context.SaveChanges();
        }
        public void UpdateTodo(TodoItem todoItem)
        {
          context.Update(todoItem);
          context.SaveChanges();
        }

      }
    }
    ```js

6.  在的`Startup`类中，在`ConfigureServices()`方法中添加实体框架，如下代码所示。我们的 Web API 控制器将有一个重载构造函数，该构造函数接受`ITodoRepository`对象。我们将使用`services.AddScoped()`方法在需要`ITodoRepository`的地方注入`TodoRepository`。最后，调用`services.Configure()`方法，用`appsettings.json`文件

    ```
    public void ConfigureServices(IServiceCollection services)
    {
      string connString = Configuration["Data:DefaultConnection:ConnectionString"];
      services.AddDbContext<TodoContext>(options => options.UseSqlServer(connString));

      services.AddMvc();

      services.AddScoped<ITodoRepository, TodoRepository>();
      services.Configure<Data>(Configuration.GetSection("Data"));

    }
    ```js

    中指定的键填充`Data`对象

### 在 ASP.NET Web API 中启用 CORS

我们在上一章学习了关于 CORS 的知识；我们必须在我们的 Web API 项目中启用 CORS，以便我们可以从 Angular services 请求访问`TodoService`方法：

1.  在`Startup`类的`ConfigureServices`方法中调用`services.AddCors()`：

    ```
    services.AddCors(options => { options.AddPolicy("AllowAllRequests", builder => builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader()); });
    ```js

2.  在`Startup`类的`Configure`方法中调用`app.UseCors()`：

    ```
    app.UseCors("AllowAllRequests");
    ```js

### 运行数据库迁移

我们正在使用实体框架代码优先模型，所以现在我们想在 Microsoft SQL Server 中创建一个数据库。为此，我们将首先在`TodoServiceApp`的`project.json`文件中添加实体框架工具支持，然后运行.NET CLI 命令添加迁移并创建数据库：

1.  在`project.json`文件中增加`Microsoft.EntityFrameworkCore.Tools`，如下图：

    ```
    "tools": {
      "Microsoft.AspNetCore.Server.IISIntegration.Tools": {
        "version": "1.0.0-preview1-final",
        "imports": "portable-net45+win8+dnxcore50"
      },
      "Microsoft.EntityFrameworkCore.Tools": {
        "imports": [ "portable-net451+win8" ],
        "version": "1.0.0-preview1-final"
      }
      },
    ```js

2.  现在我们可以运行命令、创建迁移和更新数据库。
3.  要创建迁移，请转到命令提示符并导航到`project.json`所在的`TodoServiceApp`项目。
4.  Then, run `dotnet ef migrations add Initial`, where `Initial` is the name of the migration created. Running this command will add the `Migrations` folder and a class containing code about the DDL operations.

    以下屏幕截图显示了在运行上述命令后创建的`Migrations`文件夹，以及创建的`20160405115641_Initial.cs`文件，其中包含实际的迁移代码片段，以应用或从数据库中删除迁移：

    ![Running database migration](../images/00043.jpeg)

5.  为了创建一个数据库，我们需要在`TodoServiceApp`项目中`project.json`所在的同一文件夹中执行另一个命令：

    ```
    dotnet ef database update –verbose 

    ```js

6.  这将创建一个数据库，我们现在可以通过添加一个控制器来处理不同的 HTTP 请求并访问数据库。

### 创建控制器

按照以下步骤创建控制器：

1.  添加一个新的`Controllers`文件夹，并添加一个名为`TodoController`的类。
2.  下面是`TodoController`类的代码片段：

    ```
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Common;
    using TodoServiceApp.Repository;

    namespace TodoApi.Controllers
    {
      [Route("api/[controller]")]
      public class ToDoController : Controller
      {
        ITodoRepository repository;
        public ToDoController(ITodoRepository repo)
        {
          repository = repo;
        }
        // GET: api/values
        [HttpGet]
        public IEnumerable<string> Get()
        {
          return repository.GetAllTodos();
        }
        // GET api/values/5
        [HttpGet("{id}")]
        public IEnumerable<TodoItem> Get(int id)
        {
          return repository.GetAllTodos(id);
        }
        // POST api/values
        [HttpPost]
        public void Post([FromBody]TodoItem value)
        {
          repository.CreateTodo(value);
        }
        // PUT api/values/5
        [HttpPut("{id}")]
        // DELETE api/values/5
        [HttpDelete("{id}")]
        public void Delete(int id)
        {
          repository.DeleteTodo(id);
        }
      }
    }
    ```js

现在我们已经完成了`TodoService`项目，所以我们将开发一个 todo web 应用程序项目并配置 Angular 2。

## 创建 TodoWebApp 项目

我们将开发一个单页应用程序，并使用 MVC 视图使用 Angular 2 进行渲染。此应用程序将有一个主页，列出特定用户的所有待办事项，而要添加新的待办事项，将在模式对话框窗口中打开一个新页面：

1.  首先，让我们使用 Visual Studio 2015 中提供的 ASP.NET 核心项目模板创建一个空项目，并将其命名为`TodoWebApp`。
2.  在`project.json`：

    ```
    "Microsoft.AspNetCore.Mvc": "1.0.0-rc2-final",
    "Microsoft.AspNetCore.StaticFiles": "1.0.0-rc2-final",
    ```js

    中添加 MVC 参考
3.  在`Startup`类中，在`ConfigureServices`方法中添加`AddMvc()`方法，在`Configure`方法中添加`UseMvc()`方法。下面是`Startup`类的代码片段：

    ```
    namespace TodoWebApp
    {
      public class Startup
      {
        // This method gets called by the runtime. Use this method to add services to the container.
        // For more information on how to configure your application, visit http://go.microsoft.com/fwlink/?LinkID=398940
        public void ConfigureServices(IServiceCollection services)
        {
          services.AddMvc();
        }
        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app)
        {
          app.UseStaticFiles();
          app.UseMvc(routes =>
          {
            routes.MapRoute(name: "default", template: "{controller=Home}/{action=Index}/{id?}");
        }
    }
    ```js

### 在 TodowBapp 项目中配置 Angular 2

Angular 2 是节点模块的部分，我们可以通过**节点包管理器**（**NPM**配置文件`package.json`添加节点包。在`package.json`中，我们可以通过`devDependencies`节点和`dependencies`节点添加包。`devDependencies`节点保存开发过程中使用的包，如`Gulp`，可用于连接和缩小 JavaScript 和 CSS 文件，用于开发 Angular 2 组件的 TypeScript，以及删除文件的`rimraf`。在`dependencies`节点，我们将指定`angular2`、`systemjs`、`reflect-metadata`、`rxjs`、`zone.js`等包，这些包将在应用程序运行时使用：

1.  从 Visual Studio 项目模板选项**NPM 配置文件**中添加一个新的`package.json`文件，并添加以下 JSON 片段：

    ```
    {
      "name": "ASP.NET",
      "version": "0.0.0",
      "dependencies": {
      "angular2": "2.0.0-beta.9",
      "systemjs": "0.19.24",
      "reflect-metadata": "0.1.3",
      "rxjs": "5.0.0-beta.2",
      "zone.js": "0.6.4"
      },
      "devDependencies": {
        "gulp": "3.8.11",
        "typescript": "1.8.7",
      }
    }
    ```js

2.  VisualStudio 自动下载并恢复在`package.json`文件中指定的包，在项目本身中创建一个`node_modules`文件夹，并将所有包放在那里。在 Visual Studio 中，`Node_modules`文件夹在默认情况下基本上是隐藏的，但可以通过启用`ShowAllFiles`选项使其可见。

### 依赖关系

以下是依赖项列表及其说明：

*   `angular2`：是角 2 包装。
*   `systemjs`：它提供了`System.import`来连接角度传感器的主要入口点。
*   `reflect-metadata`：这是向 ES7 添加装饰师的建议。通过这个，我们可以在 Angular 2 中为类指定元数据。
*   `rxjs`：它是一个反应流库，允许处理异步数据流。
*   `zone.js`：它提供了一个跨异步任务持久化的执行上下文。

#### 开发依赖性

以下是开发依赖项列表及其说明：

*   `gulp`：用于将文件复制到`wwwroot`文件夹
*   `typescript`：用于用 TypeScript 编写程序

#### 配置类型脚本

要配置 TypeScript，请执行以下步骤：

1.  添加所有 TypeScript 文件所在的`Scripts`文件夹。在当前版本的 ASP.NET 中，对该文件夹命名`Scripts`有限制，需要添加到项目的根目录中；否则，TypeScript 文件将不会传输到 JavaScript 文件。
2.  添加`Scripts`文件夹后，添加 TypeScript 配置文件（`tsconfig.json`并添加以下配置：

    ```
    {
      "compilerOptions": {
      "noImplicitAny": false,
      "noEmitOnError": true,
      "removeComments": false,
      "sourceMap": true,
      "target": "es5",
      "module": "commonjs",
      "moduleResolution": "node",
      "outDir": "../wwwroot/todosapp",
      "mapRoot": "../scripts",
      "experimentalDecorators": true,
      "emitDecoratorMetadata": true
      },
      "exclude": [
        "node_modules",
        "wwwroot"
      ]
    }
    ```js

当您构建项目时，Visual Studio 将使用在`compilerOptions`节点中定义的配置。根据配置生成 JavaScript 文件并存储在输出目录中。下表显示了上述代码中指定的每个属性的说明：

<colgroup class="calibre18"><col class="calibre19"> <col class="calibre19"></colgroup> 
| 

编译器选项

 | 

描述

 |
| --- | --- |
| `noImplicitAny` | 如果为`true`，则警告包含`any`类型的表达式 |
| `noEmitOnError` | 如果`true`，则如果 TypeScript 中存在任何错误，则不会生成 JavaScript |
| `removeComments` | 它`true`，在生成 JavaScript 文件时删除注释 |
| `sourceMap` | 如果为`true`，则生成对应的映射文件 |
| `Target` | 设置目标 ECMA 脚本版本，如 ES5 |
| `modulez` | 指定生成代码的模块，如`commonjs`、`AMD`或`system` |
| `moduleResolution` | 指定模块解析策略，例如节点 |
| `outDir` | 生成的 JavaScript 文件将被转储的路径 |
| `mapRoot` | 地图文件将位于的路径 |
| `experimentalDecorators` | 如果`true`，则支持 ES7 实验装饰器 |
| `emitDecoratorMetadata` | 如果为`true`，则为源代码中的装饰器声明发出设计类型元数据 |

#### 吞咽

在本节中，我们将使用Gulp 缩小 TypeScript 编译器生成的 JavaScript：

1.  添加 Gulp 配置文件`gulpfile.js`。
2.  Gulp 用于运行任务，Visual Studio 提供了一个 task runner 窗口，其中列出了在`gulpfile.js`中指定的所有任务，还允许我们将这些任务绑定到生成事件。
3.  让我们在`gulpfile.js`中添加以下脚本：

    ```
    /// <binding Clean='clean' />
    "use strict";

    var gulp = require("gulp")

    var paths = {
      webroot: "./wwwroot/"
    };
    var config = {
      libBase: 'node_modules',
      lib: [
        require.resolve('systemjs/dist/system.js'),
        require.resolve('systemjs/dist/system.src.js'),
        require.resolve('systemjs/dist/system-polyfills.js'),
        require.resolve('angular2/bundles/angular2.dev.js'),
        require.resolve('angular2/bundles/angular2-polyfills.js'),
        require.resolve('angular2/bundles/router.dev.js'),
        require.resolve('angular2/bundles/http.dev.js'),
        require.resolve('angular2/bundles/http.js'),
        require.resolve('angular2/bundles/angular2'),
        require.resolve('rxjs/bundles/Rx.js')
      ]
    };
    gulp.task('build.lib', function () {
      return gulp.src(config.lib, { base: config.libBase })
      .pipe(gulp.dest(paths.webroot + 'lib'));
    });
    ```js

在`gulpfile.js`之前的中，我们首先声明了“吞咽”的对象。然后 paths 变量为静态文件定义根文件夹（`./wwwroot`。在 ASP.NET 内核中，所有静态文件都应该位于`wwwroot`文件夹下；否则，无法访问它们。现在我们需要将 Angular 和其他相关 JavaScript 文件复制到`wwwroot`文件夹中。因此，我们添加了调用`gulp.src()`的任务`build.lib`并链接`gulp.dest()`方法，将文件从`node_modules/*`文件夹复制到`wwwroot/lib`文件夹。以下是`wwwroot`文件夹的屏幕截图，当您运行上述步骤时，它将创建`lib`文件夹：

![Configuring Gulp](../images/00044.jpeg)

### 提示

任务可以通过 Visual Studio 中的“任务运行程序”窗口运行。

### 增加角度分量

我们已经安装了 Angular 软件包，并将 Gulp 配置为将打包的 JavaScript 文件复制到`wwwroot`文件夹中。现在，我们将添加角度组件来定义主应用程序选择器，并在其中呈现 ASP.NET 页面：

1.  在`Scripts`文件夹中，创建两个文件夹`app`和`services`。`app`文件夹保存我们将在视图中使用的组件，而`services`文件夹保存将用于调用 Web API 方法的服务。
2.  添加一个主 TypeScript 文件，该文件将引导主`TodoAppComponent`。以下是`main.ts`的代码：

    ```
    //main.ts
    import {bootstrap} from 'angular2/platform/browser';
    import {TodoAppComponent} from './apps/todoapp.component';
    import {HTTP_PROVIDERS} from 'angular2/http';
    import 'rxjs/add/operator/map';

    bootstrap(TodoAppComponent, [HTTP_PROVIDERS]);  
    ```js

在前面的代码片段中，我们添加了一个`bootstrap`组件来引导我们的第一个`TodoAppComponent`。`HTTP_PROVIDERS`包含所有发出 HTTP 请求的提供者。它是在引导时提供的，因此`TodoAppComponent`或以下层次结构中的组件链可以执行基于 HTTP 的操作。`Rxjs/add/operator/map`是`HTTP_PROVIDERS`的依赖包，也需要添加：

1.  添加新的 TypeScript 文件并将其命名为`todoapp.component.ts`。
2.  为`TodoAppComponent`添加以下代码段。为了首先测试所有配置是否正确，我们只需添加一个示例标题标签，显示`Hello World`：

    ```
    //todoapp.component.ts
    ///<reference path="../../node_modules/angular2/typings/browser.d.ts" />
    import {Component} from 'angular2/core';

    @Component({

      selector: 'todo',
      template: '<h1>{{message}}</h1>'
    })

    export class TodoAppComponent {
      message: string = "Hello World";

    }
    ```js

3.  Now we will add two files, `importer.js` and `angular_config.js`. `importer.js` calls `System.import` and points to the main file that bootstraps the application component. `angular_config.js` holds the configuration property to allow default JavaScript extensions to be set to `true`.

    以下是`importer.js`的代码片段：

    ```
      System.import('todosapp/Main')
        .then(null, console.error.bind(console));
    ```js

    以下是`angular_config.js`的代码：

    ```
    System.config({ defaultJSExtensions: true });
    ```js

4.  现在我们需要添加 MVC 布局页面并添加所有脚本。添加以下脚本：

    ```
    //_Layout.cshtml

      <environment names="Development">
        <link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.css" />
        <link rel="stylesheet" href="~/css/site.css" />
        <script src="~/lib/angular2/bundles/angular2-polyfills.js"></script>
        <script src="~/lib/systemjs/dist/system.js"></script>
        <script src="~/lib/custom/angular_config.js"></script>
        <script src="~/lib/rxjs/bundles/Rx.js"></script>
        <script src="~/lib/angular2/bundles/angular2.dev.js"></script>
        <script src="~/lib/angular2/bundles/router.dev.js"></script>
        <script src="~/lib/angular2/bundles/http.js"></script>
        <script src="~/lib/custom/importer.js"></script>
        <script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-2.1.4.min.js"
          asp-fallback-src="~/lib/jquery/dist/jquery.min.js"
          asp-fallback-test="window.jQuery">
        </script>
        <script src="https://ajax.aspnetcdn.com/ajax/bootstrap/3.3.5/bootstrap.min.js"
          asp-fallback-src="~/lib/bootstrap/dist/js/bootstrap.min.js"
          asp-fallback-test="window.jQuery && window.jQuery.fn && window.jQuery.fn.modal">
        </script>
      </environment>
    ```js

5.  现在让我们添加`HomeController`并查看`Index.cshtml`。
6.  在`Index.cshtml`中，添加待办事项选择器`todo-app`：

    ```
    @{
      ViewData["Title"] = "Todo Applications";
      Layout = "~/Views/Shared/_Layout.cshtml";

    }
    <div id="myCarousel" class="container" data-ride="carousel" data-interval="6000">
      <todo-app>Loading...</todo-app>
    </div>
    ```js

7.  Build and run the application and it will show **Hello World**:

    ![Adding Angular components](../images/00045.jpeg)

#### 新增待办业务组件

我们现在将添加`services`文件夹中的组件，这些组件将负责通过调用`Todo`服务获取数据：

1.  首先添加`BaseService`组件，其中包含`baseURL`。所有服务组件都将从`BaseService`派生，因此它们可以使用基本 URL 属性进行 Ajax 请求。添加新的 TypeScript 文件并将其命名为`baseservice.component.ts`。以下是`baseservice.component.ts`：

    ```
    //baseservice.component.ts
    import {Component} from 'angular2/core';
    import {Http, Headers} from 'angular2/http';

    @Component({})
    export class BaseService {
      baseUrl: string;
      constructor() {
        this.baseUrl = "http://localhost:7105/api/";
      }
    }
    ```js

    的代码片段
2.  Now add `todoservice.component.ts`, which contains the methods to get all to-do items, add a new to-do item, and delete an existing to-do item. Here is the code snippet for `TodoService`:

    ```
    //todoservice.component.ts
    import {Component} from 'angular2/core';
    import {Http, Headers} from 'angular2/http';
    import {BaseService} from '../services/baseservice.component';

    @Component({
      providers: [TodoService]
    })

    export class TodoService extends BaseService {
      constructor(private http: Http) {
        super();
      }
      public getTodoItems() {
        return this.http.get(this.baseUrl + 'todo/1');
      }
      public createTodo(item) {
        var path = this.baseUrl + 'todo';
        const headers = new Headers({ 'Content-Type': 'application/json' });
        return this.http.post(path, JSON.stringify(item), { headers: headers });
      }

      public deleteTodo(itemId) {
        var path = this.baseUrl + 'todo';
        return this.http.delete(path + "/" + itemId);
      }
    }
    ```js

    在前面的代码中，我们导入了`http`组件并注入了构造函数。`http`对象提供`get`、`post`、`put`和`delete`等方法来读取、插入、更新和删除操作。在我们的`TodoService`Web API 项目中，我们有这些可用的方法，我们调用这些方法，如前面的代码所示。每个方法都返回一个承诺，在调用组件中，我们将检查结果并采取适当的操作。

#### 添加待办事项视图组件

我们已经在前面的步骤中添加了来检查 Angular 是否配置正确。现在我们将修改相同的组件以调用`TodoServiceComponent`并在网页上显示结果。

以下是`TodoApp.Component.ts`的代码片段：

```
//todoApp.component.ts
///<reference path="../../node_modules/angular2/typings/browser.d.ts" />
import {Component} from 'angular2/core';
import {Http, Response} from 'angular2/http';
import {CreateTodoComponent} from '../apps/createTodo.component';
import {TodoService} from '../services/todoservice.component';

@Component({
  selector: 'todo-app',
  templateUrl: 'Todo',
  directives: [CreateTodoComponent],
  providers: [TodoService]
})
export class TodoAppComponent {
  //member variables
  todos = [
  ];

  //constructor
  constructor(private http: Http, private todoService: TodoService) {
  }

  //Page Initialized Event Handler
  ngOnInit() {
    this.getTodoItems();
  }

  //Member Functions
  getTodoItems() {
    this.todoService.getTodoItems().map((res: Response) => res.json())
      .subscribe(data => {
        this.todos = data
        this.parseDate();
      },
      err  => console.log(err),
      () => console.log('done')
      );
  }
  deleteTodoItem(itemID) {
    var r = confirm("Are you sure to delete this item");
    if (r == true) {
      this.todoService.deleteTodo(itemID)
        .map(r=> r.json())
        .subscribe(result => {
          alert("record deleted");
    });
  }
  this.getTodoItems();
  }

  parseDate() {
    for (let todo of this.todos) {
      let todoDate = new Date(todo.DueDateTime);
      todo.DueDateTime = todoDate;
    }
  }

  handleRefresh(args) {
    this.getTodoItems();
  }
}
```js

在`TodoAppComponent`中，我们首先添加了`CreateTodoComponent`指令，我们将在后面的`Todo/Index.cshtml`页面中使用该指令。我们已经实现了获取待办事项列表的`ngOnInit()`事件处理程序，并将其绑定到`todos`数组对象。`getTodoItems()`方法调用`TodoService`获取待办事项列表，而`deleteTodoItem()`用于删除该项。

Angular 中的每个请求都会返回一个`Observable`响应对象，该对象提供一个`map`方法，告诉 Angular 以特定格式解析响应。映射还返回`Observable`对象，在将数据解析为 JSON 格式后，可以使用该对象订阅数据，就像我们的例子一样。最后，我们调用了`subscribe`方法，并将 JSON 响应数据发送到`todos`数组。为了处理错误，我们可以使用`err`方法链接调用。无论响应状态如何，在每次调用中都会调用匿名`expression()`方法。这意味着无论结果是成功还是错误，都将执行匿名`expression()`方法下定义的代码。

为了创建新的待办事项，我们稍后会创建另一个`CreateTodoComponent`，它会通过`Outputs`事件调用`handleRefresh()`方法来刷新列表，并在主页面上反映新添加的项目。

### 创建主待办事项页面

我们已经创建了将在 MVC 视图中使用的角度组件。我们已经在上一节中引导了 Angular组件，并将`<todo-app>`标记放置在`Home/Index.cshtml`页面中，这是我们应用程序的登录页面。接下来，我们将创建一个自定义标记帮助器，然后添加一个`TodoController`，并在索引页面中使用该标记帮助器。

#### 创建自定义待办事项标记帮助器

在主页上，我们将列出特定用户的所有待办事项。为此，我们将在 ASP.NET 中创建一个自定义标记帮助器：

![Creating a custom to-do tag helper](../images/00046.jpeg)

执行以下步骤创建此标记帮助器：

1.  在`TodoWebApp`项目的根目录中创建一个新的控件文件夹，并添加一个`TodoTagHelper`类。下面是`TodoTagHelper`的代码，它使用 Angular 2`ngControl`将 Angular`TodoAppComponent`中的值绑定到以下形式：

    ```
      [HtmlTargetElement("todo")]
      public class TodoTagHelper : TagHelper
      {
        public override void Process(TagHelperContext context, TagHelperOutput output)
        {
          string todo = "<div class='thumbnail'><div class='caption'><nav class='nav navbar-inverse' role='navigation'></nav>";

          todo += "<label class='date'>{{todo.DueDateTime | date:'short'}}</label> <img src='images/delete.png' (click)=deleteTodoItem(todo.Id)/>";

          todo += "<h4><a href='#'>{{todo.Title}}</a></h4>";
          todo += "<textarea readonly class='form-control' style='resize:none;' rows='4' cols='28'>{{todo.Description}}</textarea></div></div>";
          output.Content.AppendHtml(todo);
        }
      }
    ```js

2.  在`_ViewImports.cshtml`：

    ```
    @addTagHelper "*, TodoWebApp"
    ```js

    中添加标签助手

#### 增加一个 to-do MVC 控制器

在`TodoWebApp`项目中增加`TodoController`，为索引视图指定两种方式，即主视图，显示所有项目并新建待办事项：

```
using System.Linq;
using Microsoft.AspNetCore.Mvc;
using TodoNotes.Models;

namespace TodoNotes.Controllers
{
  public class TodoController : Controller
  {
    public TodoController()
    {
      _context = context;  
    }
    // GET: Todo
    public IActionResult Index()
    {
      return View();
    }

    // GET: Todo/Create
    public IActionResult Create()
    {
      return View();
    }

}
```js

#### 为 TodoController 操作方法生成视图

为前面的动作方法`Index`和`Create`生成视图。

以下是`Todo/Index.cshtml`的代码片段：

```
@{
  Layout = null;
}
<div class="col-md-3">
  <p class="lead">ToDo Items</p>
  <div class="list-group">
    <h4>
      <a href="#">Want to add new Todo?</a>
    </h4>
    <p>Click on the button below</p>
    <div class="col-md-3">
      <a class="btn btn-primary" data-toggle="modal" data-target="#todoModal">Create Todo</a>

    </div>
  </div>
</div>
<div id="todoModal" class="modal fade" role="dialog">
  <div class="modal-dialog">

    <!-- Modal content-->
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Insert Todo</h4>
      </div>
      <div class="modal-body">
      <createTodo (refreshTodos)="handleRefresh($event)"></createTodo>
      </div>

    </div>
  </div>
</div>
<div class="col-md-9">
  <div class="row" >
    <div class="col-sm-4 col-lg-4 col-md-4" *ngFor="#todo of todos">
      <todo></todo>
     </div>

  </div>
</div>
```js

在前面的HTML 标记中，我们首先定义了一个打开模式对话框`todoModal`的按钮。在`todoModal`对话框标记中，我们使用了`createTodo`指令，该指令在与此页面关联的`todoapp.component.ts`文件中定义，链接实际上指向`Todo/Create MVC`视图，该视图将在路由器出口处呈现。通过路由器链接和路由器出口的组合，我们可以呈现模板。在`todoapp.component.ts`中，我们将看到如何在 Angular 中使用路由。最后，我们使用自定义标记助手`<todo>`来显示待办事项列表中的每个可用项。

#### 开发创建 Todo 组件

在本节中，我们将添加角度分量，并将其命名为`CreateTodoComponent`。这是必需的，因为我们将通过一个自定义的`createTodo`选择器在一个模式对话框中打开一个新的 MVC 视图，`CreateTodoComponent`有一个方法在数据库中保存一个新的待办事项，如下面的代码所示。

在`Scripts>apps`文件夹下添加一个新的`createtodo.component.ts`，然后添加以下代码段：

```
//createtodo.component.ts
///<reference path="../../node_modules/angular2/typings/browser.d.ts" />
import {Component} from 'angular2/core';
import {Http, Response} from 'angular2/http';
import {FormBuilder, Validators} from 'angular2/common';
import {TodoService} from '../services/todoservice.component';

@Component({
  selector: 'createTodo',
  templateUrl: 'Todo/Create'
})

export class CreateTodoComponent {

  @Output() refreshTodos = new EventEmitter();

  addTodoForm: any;

  constructor(fb: FormBuilder, private todoService: TodoService) {
    this.addTodoForm = fb.group({
      title: ["", Validators.required],
      description: ["", Validators.required],
      dueDateTime: ["", Validators.required]
    });
  }
  addTodoItem(): void {
    this.todoService.createTodo(this.addTodoForm.value)
      .map(r=> r.json())
      .subscribe(result => {});
    this.refreshTodos.next([]);
    alert("Record added successfully");
  }

}
```js

在前面的代码片段中，我们已经导入了`Http`和`Response`对象来处理从`TodoService`接收到的响应。在`@Component`注释中，我们定义了在父`TodoAppComponent`组件中使用的选择器，用于在模态对话框中呈现`Create Todo`视图。

`FormBuilder`和`Validator`用于定义具有特定验证器的属性，这些验证器可以使用`ngControl`指令绑定到 HTML 表单。最后，我们有`addTodoItem`方法，它将在表单提交时被调用，并通过调用`TodoService`在数据库中创建一个待办事项条目。

现在我们在`Create.cshtml`中添加以下代码：

```
@{
  Layout = null;
}

<form [ngFormModel]="addTodoForm" (submit)="addTodoItem($event)" class="container" >
  <div class="form-horizontal">
    <div class="form-group">
      <label class="col-md-2 control-label">Title</label>
      <div class="col-md-10">
        <input ngControl="title" class="form-control" id="Title" placeholder="Enter Todo Title" [(ngModel)]="title" />
      </div>
    </div>
    <div class="form-group">
      <label class="col-md-2 control-label">Description</label>
      <div class="col-md-10">
        <textarea ngControl="description"  class="form-control" placeholder="Enter Description"></textarea>
        {{description}}
      </div>
    </div>
    <div class="form-group">
      <label class="col-md-2 control-label">Due Date</label>
      <div class="col-md-10">
        <input ngControl="dueDateTime" class="form-control" type="datetime-local" placeholder="Enter Due Date" />
      </div>
    </div>
    <div class="form-group">
      <div class="col-md-offset-2 col-md-10">
        <input type="submit" value="Create" class="btn btn-primary" />
      </div>
    </div>
  </div>
</form>
@section Scripts {
  <script src="~/lib/jquery/dist/jquery.min.js"></script>
  <script src="~/lib/jquery-validation/dist/jquery.validate.min.js"></script>
  <script src="~/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.min.js"></script>
}
```

在前面的代码片段中，我们已经将`ngFormModel`设置为`createtodo.component.ts`和`submit`表单中定义的模型，并且我们正在调用`addTodoItem`方法，该方法发送与`ngControl`指令绑定的所有值。`ngControl`是 Angular 2 中引入的一个新指令，提供单向绑定。对于表单，`ngControl`不仅绑定值，还跟踪控件的状态。如果该值无效，它将使用特殊的 CSS 类更新控件，以告知用户该值无效。

# 总结

在本章中，我们学习了 TypeScript 的核心组件以及使用 TypeScript 编写程序。我们还学习了 Angular 2 框架的核心基础知识和概念，并使用 ASP.NET core、Angular 2、MVC 6 for Web API 和 Entity framework core for data access providers 开发了一个简单的 to-do 应用程序。在下一章中，我们将学习由 Microsoft 开发的**Windows JavaScript 库**（**WinJS**，并了解如何访问 Windows 运行时功能、更改 HTML 控件的外观以及该库中提供的其他选项。